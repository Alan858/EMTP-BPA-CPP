// EMTP C++
// Dr. Alan W. Zhang <w.zhang858@outlook.com>
// Copyright (c) 2020~, all rights reserved.
//
#include "emtp_cmn.h"

namespace emtp {

  using namespace fem::major_types;



  void pltlu2(
      common& cmn,
      double& d2,
      arr_ref<double> volti)
  {
    volti(dimension(1));
    common_read read(cmn);
    common_write write(cmn);
    // COMMON cmn
    int& iofgnd = cmn.iofgnd;
    //
    //C     CALLED BY "TACS2" ONLY, IF AND ONLY IF M4PLOT .NE. 0              M32. 436
    //C     THIS MODULE IS UNIVERSAL FOR FORTRAN 77 COMPILERS AND             M37. 906
    //C     COMPUTERS FOR WHICH REAL*4 CORRESPONDS TO SINGLE PRECISION.       M37. 907
    if (iofgnd > 149) {
      stoptp(cmn);
    }
    int n12 = iofgnd + 1;
    arr_1d<150, double> forbyt(fem::fill0);
    int j = fem::int0;
    {
      read_loop rloop(cmn, cmn.lunit2, fem::unformatted);
      FEM_DO_SAFE(j, 1, n12) {
        rloop, forbyt(j);
      }
    }
    d2 = forbyt(1);
    FEM_DO_SAFE(j, 1, iofgnd) {
      volti(j) = forbyt(j + 1);
    }
    auto& lunit6 = cmn.lunit6;
    if (cmn.iprsup >= 1) {
      write(lunit6,
        "(' EXIT \"PLTLU2\".  D2, VOLTI(1,IOFGND) =',3e14.5)"), d2,
        volti(1), volti(iofgnd);
    }

  }

  struct expchk_save
  {
    arr<fem::str<8> > texnum;
    fem::str<8> text1;
    fem::str<8> textn;
    fem::str<8> textp;

    expchk_save() :
      texnum(dimension(11), fem::fill0),
      text1(fem::char0),
      textn(fem::char0),
      textp(fem::char0)
    {}
  };

  void expchk(
      common& cmn,
      int const& n1,
      int const& n2,
      int const& n5)
  {
    FEM_CMN_SVE(expchk);
    common_read read(cmn);
    const auto& abuff = cmn.abuff;
    auto& lstat = cmn.lstat;
    //
    auto& texnum = sve.texnum;
    fem::str<8>& text1 = sve.text1;
    fem::str<8>& textn = sve.textn;
    fem::str<8>& textp = sve.textp;
    if (is_called_first_time) {
      text1 = "E";
      textp = "+";
      textn = "-";
      texnum(1) = "1";
      texnum(2) = "2";
      texnum(3) = "3";
      texnum(4) = "4";
      texnum(5) = "5";
      texnum(6) = "6";
      texnum(7) = "7";
      texnum(8) = "8";
      texnum(9) = "9";
      texnum(10) = "0";
      texnum(11) = ".";
    }
    arr_1d<80, fem::str<8> > x(fem::fill0);
    int i = fem::int0;
    int key = fem::int0;
    int j = fem::int0;
    int n3 = fem::int0;
    int k = fem::int0;
    int n4 = fem::int0;
    int L = fem::int0;
    {
      read_loop rloop(abuff(1), "(80a1)");
      FEM_DO_SAFE(i, 1, 80) {
        rloop, x(i);
      }
    }
    FEM_DOSTEP(i, n1, n2, n5) {
      key = 0;
      FEM_DO_SAFE(j, 1, n5) {
        n3 = i + j - 1;
        if (x(n3) == text1) {
          goto statement_2622;
        }
        if (key > 0) {
          goto statement_2620;
        }
        FEM_DO_SAFE(k, 1, 11) {
          if (x(n3) == texnum(k)) {
            key = k;
          }
        }
        goto statement_2621;
      statement_2620:
        if (x(n3) == textp || x(n3) == textn) {
          goto statement_2622;
        }
      statement_2621:;
      }
      goto statement_2625;
    statement_2622:
      n4 = i + n5 - 1;
      FEM_DO_SAFE(L, 1, 10) {
        if (x(n4) == texnum(L)) {
          goto statement_2625;
        }
      }
      cmn.kill = 97;
      lstat(14) = i;
      lstat(15) = n4;
      lstat(19) = 2624;
      return;
    statement_2625:;
    }

  }

  void intchk(
      common& cmn,
      int const& n1,
      int const& n2,
      int const& n5)
  {
    common_read read(cmn);
    fem::str<8>& blank = cmn.blank;
    const auto& abuff = cmn.abuff;
    auto& lstat = cmn.lstat;
    //
    arr_1d<80, fem::str<8> > x(fem::fill0);
    int i = fem::int0;
    int n6 = fem::int0;
    int n7 = fem::int0;
    int n8 = fem::int0;
    int n3 = fem::int0;
    int n4 = fem::int0;
    {
      read_loop rloop(abuff(1), "(80a1)");
      FEM_DO_SAFE(i, 1, 80) {
        rloop, x(i);
      }
    }
    n6 = n1 - 1;
    FEM_DO_SAFE(i, n1, n2) {
      if (x(i) == blank) {
        goto statement_2648;
      }
      n7 = i - n6;
      n8 = n7 / n5;
      n3 = n8 * n5;
      if (n3 == n7) {
        goto statement_2648;
      }
      n4 = n6 + (n8 + 1) * n5;
      if (n4 > n2) {
        goto statement_2645;
      }
      if (x(n4) != blank) {
        goto statement_2648;
      }
    statement_2645:
      cmn.kill = 98;
      lstat(14) = i;
      lstat(15) = n4;
      cmn.bus1 = x(i);
      lstat(19) = 2642;
      return;
    statement_2648:;
    }

  }


  void midov1(
      common& cmn)
  {
    common_write write(cmn);
    const auto& moncar = cmn.moncar;
    auto& lunit2 = cmn.lunit2;
    auto& lunit3 = cmn.lunit3;
    auto& lunit9 = cmn.lunit9;
    auto& lunt12 = cmn.lunt12;
    const auto& lstat = cmn.lstat;
    int& m4plot = cmn.m4plot;
    int& iplot = cmn.iplot;
    int& nenerg = cmn.nenerg;
    fem::str<16>& ansi16 = cmn.ansi16;
    //
    int ltdelt = fem::int0;
    int n4 = fem::int0;
    int j = fem::int0;
    //C     MODULE CALLED ONLY FROM ONE LOCATION IN "OVER1" OF OVERLAY        M37.1247
    //C     ONE.  IT SHOULD BE ACCEPTABLE TO ALL FORTRAN 77 COMPILERS         M37.1248
    //C!EQUIVALENCE    (MONCAR(3), LTDELT)
    //C IF INTERACTIVE EXECUTION (SPY),
    //C AND IF NOT MONTE CARLO STUDY,
    //C SET END-TIME OF STUDY TO INFINITY
    if (m4plot == 1 && nenerg == 0) {
      cmn.tmax = cmn.fltinf;
    }
    //C     FLAG FOR POSTPROCESSING (LTDELT=-6789) SKIPS THE                  M28.1852
    //C     TAMPERING WITH OLD PLOT FILE NOW CONNECTED TO  LUNIT2:            M31. 350
    ltdelt = moncar(3);
    if (ltdelt == -6789) {
      goto statement_1815;
    }
    cmn.io.close(lunit2)
      .status("DELETE");
    cmn.io.open(lunit2, fem::file_not_specified)
      .form("UNFORMATTED")
      .status("SCRATCH");
  statement_1815:
    if (cmn.jflsos == 0) {
      goto statement_4271;
    }
    if (cmn.lastov == 20) {
      goto statement_4271;
    }
    cmn.io.close(lunit3);
    cmn.io.close(lunit9);
    //C 1ST OF TWO UNITS TO BE OPENED AS SCRATCH
    n4 = lunit3;
  statement_5910:
    {
      write_loop wloop(ansi16, "('ST',i1,'LOG',3i1,'.DAT',3x)");
      wloop, n4;
      FEM_DO_SAFE(j, 14, 16) {
        wloop, lstat(j);
      }
    }
    cmn.io.open(n4, ansi16)
      .form("UNFORMATTED")
      .status("NEW");
    //C BOTH OPENED, SO EXIT
    if (n4 == lunit9) {
      goto statement_4271;
    }
    //C SWITCH TO SECOND OF TWO I/O CHANNELS
    n4 = lunit9;
    goto statement_5910;
  statement_4271:
    if (nenerg == 0) {
      goto statement_5933;
    }
    //C     "STATISITICS"  REQUIRES FORMATTED WRITES TO UNIT 12, WHICH        M32. 813
    //C     CONFLICTS WITH USUAL USAGE.                                       M32. 814
    cmn.io.close(lunt12);
    cmn.io.open(lunt12, fem::file_not_specified)
      .status("SCRATCH");
    //C NOT INTERACTIVE EMTP
  statement_5933:
    if (m4plot != 1) {
      goto statement_5947;
    }
    //C YES, PLOTTING REQUESTED
    if (iplot >= 0) {
      goto statement_5947;
    }
    //C WRITE LITTLE TO PLOT FILE, NOT NOTHING
    iplot = cmn.intinf;
  statement_5947:;

  }

  struct reques_save
  {
    arr<int> jpntr;
    int ll1;
    int ll16;
    int ll25;
    int ll32;
    int ll33;
    int ll40;
    int ll48;
    int ll49;
    int ll56;
    int ll8;
    int ll80;
    vectorEx<fem::str<8> > textax;
    vectorEx<fem::str<8> > textay;

    reques_save() :
      jpntr(dimension(100), fem::fill0),
      ll1(fem::int0),
      ll16(fem::int0),
      ll25(fem::int0),
      ll32(fem::int0),
      ll33(fem::int0),
      ll40(fem::int0),
      ll48(fem::int0),
      ll49(fem::int0),
      ll56(fem::int0),
      ll8(fem::int0),
      ll80(fem::int0),
      //textax(dimension(300), fem::fill0),
      //textay(dimension(100), fem::fill0)
      textax(300, ""),
      textay(100, "")
    {}
  };

  void reques(
      common& cmn)
  {
    FEM_CMN_SVE(reques);
    common_read read(cmn);
    common_write write(cmn);
    fem::str<8>& bus1 = cmn.bus1;
    fem::str<8>& bus2 = cmn.bus2;
    fem::str<8>& bus3 = cmn.bus3;
    fem::str<8>& bus4 = cmn.bus4;
    fem::str<8>& bus5 = cmn.bus5;
    fem::str<8>& trash = cmn.trash;
    fem::str<8>& blank = cmn.blank;
    fem::str<8>& userid = cmn.userid;
    const auto& texta6 = cmn.texta6;
    const auto& tclock= cmn.tclock;
    auto& vstacs= cmn.vstacs;
    const auto& abuff = cmn.abuff;
    double& epsiln = cmn.epsiln;
    auto& znolim = cmn.znolim;
    double& epszno = cmn.epszno;
    double& epwarn = cmn.epwarn;
    double& epstop = cmn.epstop;
    double& szplt = cmn.szplt;
    double& epsuba = cmn.epsuba;
    double& fminfs = cmn.fminfs;
    double& delffs = cmn.delffs;
    double& fmaxfs = cmn.fmaxfs;
    double& tenerg = cmn.tenerg;
    auto& begmax = cmn.begmax;
    auto& peaknd = cmn.peaknd;
    double& fltinf = cmn.fltinf;
    double& statfr = cmn.statfr;
    auto& voltbc = cmn.voltbc;
    auto& flstat = cmn.flstat;
    double& pu = cmn.pu;
    auto& moncar = cmn.moncar;
    auto& lunit2 = cmn.lunit2;
    int& nright = cmn.nright;
    int& nfrfld = cmn.nfrfld;
    int& kolbeg = cmn.kolbeg;
    int& max99m = cmn.max99m;
    auto& ipntv = cmn.ipntv;
    auto& lstat = cmn.lstat;
    const auto& nbyte = cmn.nbyte;
    auto& iprsov= cmn.iprsov;
    int& kol132 = cmn.kol132;
    int& istep = cmn.istep;
    int& m4plot = cmn.m4plot;
    auto& ktrlsw = cmn.ktrlsw;
    int& kpartb = cmn.kpartb;
    int& nsmth = cmn.nsmth;
    int& nstacs = cmn.nstacs;
    int& noutpr = cmn.noutpr;
    int& jflsos = cmn.jflsos;
    int& maxzno = cmn.maxzno;
    int& iofgnd = cmn.iofgnd;
    int& iofbnd = cmn.iofbnd;
    int& modout = cmn.modout;
    int& kill = cmn.kill;
    int& nchain = cmn.nchain;
    int& iprsup = cmn.iprsup;
    int& intinf = cmn.intinf;
    int& lnpin = cmn.lnpin;
    int& nenerg = cmn.nenerg;
    int& nclfix = cmn.nclfix;
    int& numfix = cmn.numfix;
    int& iotfix = cmn.iotfix;
    int& ibsfix = cmn.ibsfix;
    int& kexact = cmn.kexact;
    //
    arr_ref<int> jpntr(sve.jpntr, dimension(100));
    int& ll25 = sve.ll25;
    int& ll33 = sve.ll33;
    int& ll40 = sve.ll40;
    int& ll48 = sve.ll48;
    int& ll49 = sve.ll49;
    int& ll56 = sve.ll56;
    int& ll8 = sve.ll8;
    int& ll80 = sve.ll80;
    auto& textax = sve.textax;
    auto& textay = sve.textay;
    if (is_called_first_time) {
      textay(1) = "X     ";
      jpntr(1) = 1;
      textax(1) = "XFORME";
      textax(2) = "R     ";
      textay(2) = "S     ";
      jpntr(2) = 3;
      textax(3) = "SATURA";
      textax(4) = "TION  ";
      textay(3) = "TL    ";
      jpntr(3) = 5;
      textax(5) = "TYPE99";
      textax(6) = "LIMIT ";
      textay(4) = "R     ";
      jpntr(4) = 7;
      textax(7) = "REPLOT";
      textay(5) = "BNDC  ";
      jpntr(5) = 8;
      textax(8) = "BEGIN ";
      textax(9) = "NEW   ";
      textax(10) = "DATA  ";
      textax(11) = "CASE  ";
      textay(6) = "LC    ";
      jpntr(6) = 12;
      textax(12) = "LINE  ";
      textax(13) = "CONSTA";
      textax(14) = "NTS   ";
      textay(7) = "PPF   ";
      jpntr(7) = 15;
      textax(15) = "POSTPR";
      textax(16) = "OCESS ";
      textax(17) = "PLOT  ";
      textax(18) = "FILE  ";
      textay(8) = "PPH   ";
      jpntr(8) = 19;
      textax(19) = "PLOTTE";
      textax(20) = "R     ";
      textax(21) = "PAPER ";
      textax(22) = "HEIGHT";
      textay(9) = "PLPI  ";
      jpntr(9) = 23;
      textax(23) = "PRINTE";
      textax(24) = "R     ";
      textax(25) = "LINES ";
      textax(26) = "PER   ";
      textax(27) = "INCH  ";
      textay(10) = "MVO   ";
      jpntr(10) = 28;
      textax(28) = "MODE  ";
      textax(29) = "VOLTAG";
      textax(30) = "E     ";
      textax(31) = "OUTPUT";
      textay(11) = "ELDC  ";
      jpntr(11) = 32;
      textax(32) = "END   ";
      textax(33) = "LAST  ";
      textax(34) = "DATA  ";
      textax(35) = "CASE  ";
      textay(12) = "ASU   ";
      jpntr(12) = 36;
      textax(36) = "ANALYT";
      textax(37) = "IC    ";
      textax(38) = "SOURCE";
      textax(39) = "S     ";
      textax(40) = "USAGE ";
      textay(13) = "LOPO  ";
      jpntr(13) = 41;
      textax(41) = "LIMIT ";
      textax(42) = "ON    ";
      textax(43) = "PLOT  ";
      textax(44) = "OSCILL";
      textax(45) = "ATIONS";
      textay(14) = "TES   ";
      jpntr(14) = 46;
      textax(46) = "TACS  ";
      textax(47) = "EMTP  ";
      textax(48) = "SOURCE";
      textax(49) = "S     ";
      textay(15) = "SA    ";
      jpntr(15) = 50;
      textax(50) = "START ";
      textax(51) = "AGAIN ";
      textay(16) = "SS    ";
      jpntr(16) = 52;
      textax(52) = "SEMLYE";
      textax(53) = "N     ";
      textax(54) = "SETUP ";
      textay(17) = "LBU   ";
      jpntr(17) = 55;
      textax(55) = "LINEAR";
      textax(56) = "BIAS  ";
      textax(57) = "USAGE ";
      textay(18) = "CC    ";
      jpntr(18) = 58;
      textax(58) = "CABLE ";
      textax(59) = "CONSTA";
      textax(60) = "NTS   ";
      textay(19) = "AN    ";
      jpntr(19) = 61;
      textax(61) = "AUTO  ";
      textax(62) = "NAME  ";
      textay(20) = "RB    ";
      jpntr(20) = 63;
      textax(63) = "RENUMB";
      textax(64) = "ER    ";
      textax(65) = "BYPASS";
      textay(21) = "FS    ";
      jpntr(21) = 66;
      textax(66) = "FREQUE";
      textax(67) = "NCY   ";
      textax(68) = "SCAN  ";
      textay(22) = "FF    ";
      jpntr(22) = 69;
      textax(69) = "FREE  ";
      textax(70) = "FORMAT";
      textay(23) = "D     ";
      jpntr(23) = 71;
      textax(71) = "DIAGNO";
      textax(72) = "STIC  ";
      textay(24) = "PF    ";
      jpntr(24) = 73;
      textax(73) = "POWER ";
      textax(74) = "FREQUE";
      textax(75) = "NCY   ";
      textay(25) = "FR    ";
      jpntr(25) = 76;
      textax(76) = "FILE  ";
      textax(77) = "REQUES";
      textax(78) = "T     ";
      textay(26) = "UI    ";
      jpntr(26) = 79;
      textax(79) = "USER  ";
      textax(80) = "IDENTI";
      textax(81) = "FICATI";
      textax(82) = "ON    ";
      textay(27) = "CZ    ";
      jpntr(27) = 83;
      textax(83) = "CONVER";
      textax(84) = "T     ";
      textax(85) = "ZNO   ";
      textay(28) = "ADC   ";
      jpntr(28) = 86;
      textax(86) = "ABORT ";
      textax(87) = "DATA  ";
      textax(88) = "CASE  ";
      textay(29) = "KC    ";
      jpntr(29) = 89;
      textax(89) = "KILL  ";
      textax(90) = "CODES ";
      textay(30) = "HR    ";
      jpntr(30) = 91;
      textax(91) = "HIGH  ";
      textax(92) = "RESIST";
      textax(93) = "ANCE  ";
      textay(31) = "AO    ";
      jpntr(31) = 94;
      textax(94) = "AVERAG";
      textax(95) = "E     ";
      textax(96) = "OUTPUT";
      textay(32) = "ATD   ";
      jpntr(32) = 97;
      textax(97) = "ABSOLU";
      textax(98) = "TE    ";
      textax(99) = "TACS  ";
      textax(100) = "DIMENS";
      textax(101) = "IONS  ";
      textay(33) = "RTD   ";
      jpntr(33) = 102;
      textax(102) = "RELATI";
      textax(103) = "VE    ";
      textax(104) = "TACS  ";
      textax(105) = "DIMENS";
      textax(106) = "IONS  ";
      textay(34) = "TER   ";
      jpntr(34) = 107;
      textax(107) = "TABULA";
      textax(108) = "TE    ";
      textax(109) = "ENERGI";
      textax(110) = "ZATION";
      textax(111) = "RESULT";
      textax(112) = "S     ";
      textay(35) = "SOS   ";
      jpntr(35) = 113;
      textax(113) = "STATIS";
      textax(114) = "TICS  ";
      textax(115) = "OUTPUT";
      textax(116) = "SALVAG";
      textax(117) = "E     ";
      textay(36) = "OBC   ";
      jpntr(36) = 118;
      textax(118) = "OMIT  ";
      textax(119) = "BASE  ";
      textax(120) = "CASE  ";
      textay(37) = "CS    ";
      jpntr(37) = 121;
      textax(121) = "CHANGE";
      textax(122) = "SWITCH";
      textay(38) = "MDC   ";
      jpntr(38) = 123;
      textax(123) = "MISCEL";
      textax(124) = "LANEOU";
      textax(125) = "S     ";
      textax(126) = "DATA  ";
      textax(127) = "CARDS ";
      textay(39) = "RTE   ";
      jpntr(39) = 128;
      textax(128) = "REDEFI";
      textax(129) = "NE    ";
      textax(130) = "TOLERA";
      textax(131) = "NCE   ";
      textax(132) = "EPSILN";
      textay(40) = "CPF   ";
      jpntr(40) = 133;
      textax(133) = "CHANGE";
      textax(134) = "PRINTO";
      textax(135) = "UT    ";
      textax(136) = "FREQUE";
      textax(137) = "NCY   ";
      textay(41) = "BPVS  ";
      jpntr(41) = 138;
      textax(138) = "BEGIN ";
      textax(139) = "PEAK  ";
      textax(140) = "VALUE ";
      textax(141) = "SEARCH";
      textay(42) = "TODR  ";
      jpntr(42) = 142;
      textax(142) = "TIME  ";
      textax(143) = "OF    ";
      textax(144) = "DICE  ";
      textax(145) = "ROLL  ";
      textay(43) = "ZO    ";
      jpntr(43) = 146;
      textax(146) = "ZINC  ";
      textax(147) = "OXIDE ";
      textay(44) = "PVM   ";
      jpntr(44) = 148;
      textax(148) = "PEAK  ";
      textax(149) = "VOLTAG";
      textax(150) = "E     ";
      textax(151) = "MONITO";
      textax(152) = "R     ";
      textay(45) = "AUMD  ";
      jpntr(45) = 153;
      textax(153) = "ABSOLU";
      textax(154) = "TE    ";
      textax(155) = "U.M.  ";
      textax(156) = "DIMENS";
      textax(157) = "IONS  ";
      textay(46) = "RUMD  ";
      jpntr(46) = 158;
      textax(158) = "RELATI";
      textax(159) = "VE    ";
      textax(160) = "U.M.  ";
      textax(161) = "DIMENS";
      textax(162) = "IONS  ";
      textay(47) = "TSL   ";
      jpntr(47) = 163;
      textax(163) = "TIME  ";
      textax(164) = "STEP  ";
      textax(165) = "LOOP  ";
      textay(48) = "ADP   ";
      jpntr(48) = 166;
      textax(166) = "ALTERN";
      textax(167) = "ATE   ";
      textax(168) = "DIAGNO";
      textax(169) = "STIC  ";
      textax(170) = "PRINTO";
      textax(171) = "UT    ";
      textay(49) = "TWL   ";
      jpntr(49) = 172;
      textax(172) = "TACS  ";
      textax(173) = "WARN  ";
      textax(174) = "LIMIT ";
      textay(50) = "MS    ";
      jpntr(50) = 175;
      textax(175) = "MARTI ";
      textax(176) = "SETUP ";
      textay(51) = "JMS   ";
      jpntr(51) = 177;
      textax(177) = "JMARTI";
      textax(178) = "SETUP ";
      textay(52) = "CPF   ";
      jpntr(52) = 179;
      textax(179) = "CUSTOM";
      textax(180) = "PLOT  ";
      textax(181) = "FILE  ";
      textay(53) = "OW1   ";
      jpntr(53) = 182;
      textax(182) = "OUTPUT";
      textax(183) = "WIDTH ";
      textax(184) = "132   ";
      textay(54) = "OW8   ";
      jpntr(54) = 185;
      textax(185) = "OUTPUT";
      textax(186) = "WIDTH ";
      textax(187) = "80    ";
      textay(55) = "MSL   ";
      jpntr(55) = 188;
      textax(188) = "MODIFY";
      textax(189) = "SWITCH";
      textax(190) = "LOGIC ";
      textay(56) = "FDU   ";
      jpntr(56) = 191;
      textax(191) = "FAULT ";
      textax(192) = "DATA  ";
      textax(193) = "USAGE ";
      textay(57) = "FXS   ";
      jpntr(57) = 194;
      textax(194) = "FIX   ";
      textax(195) = "SOURCE";
      textay(58) = "USST  ";
      jpntr(58) = 196;
      textax(196) = "USER  ";
      textax(197) = "SUPPLI";
      textax(198) = "ED    ";
      textax(199) = "SWITCH";
      textax(200) = "TIMES ";
      textay(59) = "AS    ";
      jpntr(59) = 201;
      textax(201) = "AMETAN";
      textax(202) = "I     ";
      textax(203) = "SETUP ";
      textay(60) = "HS    ";
      jpntr(60) = 204;
      textax(204) = "HAUER ";
      textax(205) = "SETUP ";
      textay(61) = "LMFS  ";
      jpntr(61) = 206;
      textax(206) = "LINE  ";
      textax(207) = "MODEL ";
      textax(208) = "FREQ  ";
      textax(209) = "SCAN  ";
      jpntr(62) = 210;
      jpntr(63) = 0;
      sve.ll1 = 1;
      ll8 = 8;
      sve.ll16 = 16;
      ll25 = 25;
      sve.ll32 = 32;
      ll33 = 33;
      ll40 = 40;
      ll48 = 48;
      ll49 = 49;
      ll56 = 56;
      ll80 = 80;
    }
    auto& lunit6 = cmn.lunit6;
    auto& kunit6 = cmn.lunit6;
    int i = fem::int0;
    int n1 = fem::int0;
    int n2 = fem::int0;
    int j = fem::int0;
    int L = fem::int0;
    int n3 = fem::int0;
    double d1 = fem::double0;
    int n4 = fem::int0;
    int n13 = fem::int0;
    int n5 = fem::int0;
    arr_1d<1, double> farray(fem::fill0);
    int ltdelt = fem::int0;
    double d13 = fem::double0;
    double znvref = fem::double0;
    int nmauto = fem::int0;
    int n8 = fem::int0;
    double d7 = fem::double0;
    double d8 = fem::double0;
    int n9 = fem::int0;
    int k = fem::int0;
    int n7 = fem::int0;
    double d2 = fem::double0;
    double seed = fem::double0;
    int kbase = fem::int0;
    int ip = fem::int0;
    int m = fem::int0;
    int n14 = fem::int0;
    int kbrnum = fem::int0;
    static const char* format_2605 = "(32x,e8.0)";
    static const char* format_2642 = "(32x,6i8)";
    static const char* format_4721 = "(32x,2i8)";
    static const char* format_7276 = "(32x,6i8)";
    //C!EQUIVALENCE  ( ANGLEX(1), ANGLE )
    //C!EQUIVALENCE (MONCAR(2), KBASE),   (MONCAR(3), LTDELT)
    //C!EQUIVALENCE (IPRSOV(39), NMAUTO)
    //C 9-PHASE AS LIMIT FOR LMFS TEST
    //C
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 1.   'XFORMER'           $$$$$  M28. 894
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 2.   'SATURATION'        $$$$$  M28. 899
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 3.   'TYPE99 LIMIT'      $$$$$  M43. 117
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 4.   'REPLOT'            $$$$$  M28. 909
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 5.   'BEGIN NEW DATA CASE' $$$  M28. 913
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 6.   'LINE CONSTANTS'    $$$$$  M28. 920
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 7.   'POSTPROCESS               M28. 926
    //C                                               PLOT FILE'       $$$$$  M28. 927
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 8.   'PLOTTER PAPER HEIGHT' $$  M28. 934
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 9.   'PRINTER LINES PER INCH'   M28. 941
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 10.   'MODE VOLTAGE OUTPUT' $$$ M28. 949
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 11.   'END LAST DATA CASE' $$$$ M28. 956
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 12.   'ANALYTIC SOURCES USAGE'  M28. 963
    //C     $$$$$ SPECIAL-REQUEST WORD NO. 13.   'LIMIT ON PLOT OSCILLATIONS' M28. 971
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 14.   'TACS EMTP SOURCES'  $$$$ M28. 979
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 15.   'START AGAIN'       $$$$$ M28. 986
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 16.   'SEMLYEN SETUP'     $$$$$ M28. 991
    //C     $$$$  SPECIAL REQUEST-WORD NO. 17.   'LINEAR BIAS USAGE' $$$$$$$$$M42.1159
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 18.   'CABLE CONSTANTS'   $$$$$ M28.1003
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 19.   'AUTO NAME'         $$$$$ M42.1165
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 20.   'RENUMBER BYPASS'   $$$$$ M28.1014
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 21.   'FREQUENCY SCAN'    $$$$$ M28.1020
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 22.   'FREE FORMAT'       $$$$$ M28.1026
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 23.   'DIAGNOSTIC'        $$$$$ M28.1031
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 24.   'POWER FREQUENCY'   $$$$$ M28.1036
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 25.   'FILE REQUEST'      $$$$$ M28.1042
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 26.   'USER IDENTIFICATION' $$$ M28.1048
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 27.   'CONVERT ZNO'  $$$$$$$$$$ M39. 354
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 28.   'ABORT DATA CASE'   $$$$$ M28.1061
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 29.   'KILL CODES'        $$$$$ M28.1067
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 30.   'HIGH RESISTANCE'   $$$$$ M28.1072
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 31.   'AVERAGE OUTPUT'    $$$$$ M28.1078
    //C     $$$$$  SPECIAL REQUEST-WORD NO. 32.  'ABSOLUTE TACS DIMENSIONS'  $M28.1084
    //C     $$$$$  SPECIAL REQUEST-WORD NO. 33.  'RELATIVE TACS DIMENSIONS'  $M28.1092
    //C     $$ SPECIAL REQUEST-WORD NO. 34.  'TABULATE ENERGIZATION RESULTS'  M28.1100
    //C     $$ SPECIAL REQUEST-WORD NO. 35. 'STATISTICS OUTPUT SALVAGE'       M28.1109
    //C     $$$$  SPECIAL REQUEST-WORD NO. 36.   'OMIT BASE CASE'    $$$$$$$$$M28.1117
    //C     $$$$  SPECIAL REQUEST-WORD NO. 37.   'CHANGE SWITCH'     $$$$$$$$$M42.1169
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 38.   'MISCELLANEOUS DATA       M28.1129
    //C                                              CARDS'          $$$$$$$$$M28.1130
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 39.   'REDEFINE TOLERANCE       M28.1138
    //C                                              EPSILN'         $$$$$$$$$M28.1139
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 40.   'CHANGE PRINTOUT          M28.1147
    //C                                              FREQUENCY       $$$$$$$$$M28.1148
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 41.   'BEGIN PEAK               M28.1156
    //C                                              VALUE SEARCH'   $$$$$$$$$M28.1157
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 42.   'TIME OF                  M28.1164
    //C                                              DICE ROLL'    $$$$$$$$$$$M28.1165
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 43.   'ZINC OXIDE'   $$$$$$$$$$$M37.1183
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 44.   'PEAK VOLTAGE'  $$$$$$$$$$M28.1177
    //C     $$$$$$$                                  MONITOR'      $$$$$$$$$$$M28.1178
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 45.   'ABSOLUTE U.M.  $$$$$$$$$$M28.1186
    //C                                              DIMENSIONS'    $$$$$$$$$$M28.1187
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 46.   'RELATIVE U.M.  $$$$$$$$$$M28.1195
    //C                                              DIMENSIONS'    $$$$$$$$$$M28.1196
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 47.   'TIME STEP LOOP'  $$$$$$$$M28.1204
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 48.   'ALTERNATE DIAGNOSTIC     M28.1210
    //C                                                    PRINTOUT'  $$$$$$$$M28.1211
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 49.   'TACS WARN LIMIT' $$$$$$$$M31. 257
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 50.   'MARTI SETUP'       $$$$$ M29.1014
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 51.   'JMARTI SETUP' $$$$$$$$$$ M32. 707
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 52.   'CUSTOM PLOT FILE' $$$$$$ M29.1024
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 53.   'OUTPUT WIDTH 132' $$$$$$ M32. 711
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 54.   'OUTPUT WIDTH 80'  $$$$$$ M32. 717
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 55.   'MODIFY SWITCH LOGIC  $$$ M32. 723
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 56.   'FAULT DATA USAGE' $$$$$$ M32. 729
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 57.   'FIX SOURCE'  $$$$$$      M35. 517
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 58.   'USER SUPPLIED     $$$$$$ M37.1189
    //C     $$$$$$$                                  SWITCH TIMES'     $$$$$$ M37.1190
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 59.   'AMETANI SETUP'  $$$      M42.1173
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 60.   'HAUER SETUP'  $$$$$      M42.1179
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 61.   'LINE MODEL FREQ. SCAN  $$
    lstat(18) = 0;
    if (iprsup >= 1) {
      write(lunit6, "('  \"BEGIN MODULE REQUES.\"')");
    }
    FEM_DO_SAFE(i, 1, 9999) {
      n1 = jpntr(i);
      n2 = jpntr(i + 1) - 1;
      //C     NEXT CHECK IF LAST REQUEST WORD HAS BEEN EXHAUSED.  IF SO,        M28.1245
      //C     EXIT WITH  LSTAT(18)  EQUAL TO ZERO.                              M28.1246
      if (n2 < 0) {
        goto statement_9200;
      }
      if (iprsup >= 35) {
        {
          write_loop wloop(cmn, lunit6,
            "(/,' SPECIAL-REQUEST WORD',i4,' .',10a6)");
          wloop, i;
          FEM_DO_SAFE(j, n1, n2) {
            wloop, textax(j);
          }
        }
      }
      if (textax(n1) == blank) {
        goto statement_3306;
      }
      L = 0;
      n3 = n2 - n1 + 1;
      if (n3 != nfrfld) {
        goto statement_3306;
      }
      FEM_DO_SAFE(j, n1, n2) {
        L++;
        if (texta6(L) != textax(j)) {
          goto statement_3306;
        }
      }
    statement_3294:
      lstat(18) = i;
      //C     NEXT CHECK FOR EXCEPTIONAL REQUEST WORDS WHICH ARE                M28.1260
      //C     PROCESSED OUTSIDE OF SUBROUTINE, BY CALLING MODULE.               M28.1261
      if (i == 15) {
        goto statement_9200;
      }
      if (i == 32) {
        goto statement_9200;
      }
      if (i == 33) {
        goto statement_9200;
      }
      switch (i) {
      case 1: goto statement_8001;
      case 2: goto statement_8002;
      case 3: goto statement_8003;
      case 4: goto statement_8004;
      case 5: goto statement_8005;
      case 6: goto statement_8006;
      case 7: goto statement_8007;
      case 8: goto statement_8008;
      case 9: goto statement_8009;
      case 10: goto statement_8010;
      case 11: goto statement_8011;
      case 12: goto statement_8012;
      case 13: goto statement_8013;
      case 14: goto statement_8014;
      case 15: goto statement_9200;
      case 16: goto statement_8016;
      case 17: goto statement_8017;
      case 18: goto statement_8018;
      case 19: goto statement_8019;
      case 20: goto statement_8020;
      case 21: goto statement_8021;
      case 22: goto statement_8022;
      case 23: goto statement_8023;
      case 24: goto statement_8024;
      case 25: goto statement_8025;
      case 26: goto statement_8026;
      case 27: goto statement_8027;
      case 28: goto statement_8028;
      case 29: goto statement_8029;
      case 30: goto statement_8030;
      case 31: goto statement_8031;
      case 32: goto statement_9200;
      case 33: goto statement_9200;
      case 34: goto statement_8034;
      case 35: goto statement_8035;
      case 36: goto statement_8036;
      case 37: goto statement_8037;
      case 38: goto statement_8038;
      case 39: goto statement_8039;
      case 40: goto statement_8040;
      case 41: goto statement_8041;
      case 42: goto statement_8042;
      case 43: goto statement_8043;
      case 44: goto statement_8044;
      case 45: goto statement_8045;
      case 46: goto statement_8046;
      case 47: goto statement_8047;
      case 48: goto statement_8048;
      case 49: goto statement_8049;
      case 50: goto statement_8050;
      case 51: goto statement_8051;
      case 52: goto statement_8052;
      case 53: goto statement_8053;
      case 54: goto statement_8054;
      case 55: goto statement_8055;
      case 56: goto statement_8056;
      case 57: goto statement_8057;
      case 58: goto statement_8058;
      case 59: goto statement_8059;
      case 60: goto statement_8060;
      case 61: goto statement_8061;
      case 62: goto statement_8062;
      default: break;
      }
    statement_3306:
      if (texta6(1) == textay(i)) {
        goto statement_3294;
      }
    }
    //C     CONTROL WILL NEVER REACH  "STOP"  WHICH FOLLOWS.                  M28.1274
    stoptp(cmn);
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 1.   'XFORMER'           $$$$$  M28.1276
  statement_8001:
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST FOR TRANSFORMER IMPEDANCE-MATRIX ROUTINE.')");
    }
    nchain = 41;
    goto statement_5617;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 2.   'SATURATION'        $$$$$  M28.1282
  statement_8002:
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST FOR MAGNETIC-SATURATION ROUTINE.')");
    }
    nchain = 42;
    goto statement_5617;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 3.   'TYPE99 LIMIT'      $$$$$  M43. 121
  statement_8003:
    if (kolbeg > 0) {
      goto statement_3352;
    }
    read(abuff, format_2642), max99m;
    goto statement_3354;
  statement_3352:
    nfrfld = 1;
    freone(cmn, d1);
    max99m = d1;
  statement_3354:
    if (noutpr == 0) {
      write(kunit6, "('+REDEFINE TYPE-99 MESSAGE LIMIT TO',i6)"), max99m;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 4.   'REPLOT'            $$$$$  M28.1295
  statement_8004:
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST TO RE-PLOT OLD PLOT DATA.')");
    }
    cmn.degmax = 0.0f;
    cmn.ialter = cmn.lunit4;
    midov1(cmn);
    pfatch(cmn);
    nchain = 31;
    goto statement_5617;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 5.   'BEGIN NEW DATA CASE' $$$  M28.1305
  statement_8005:
    if (noutpr == 0) {
      write(kunit6, "('+MARKER CARD PRECEDING NEW DATA CASE.')");
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 6.   'LINE CONSTANTS'    $$$$$  M28.1310
  statement_8006:
    nchain = 44;
    if (iprsup >= 1) {
      write(lunit6, "(' SET NCHAIN=44 FOR \"LINE CONSTANTS\".')");
    }
    goto statement_5617;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 7.   'POSTPROCESS               M28.1316
    //C                                               PLOT FILE'       $$$$$  M28.1317
  statement_8007:
    if (kolbeg > 0) {
      goto statement_3375;
    }
    read(abuff, format_2642), iofbnd;
    goto statement_3379;
  statement_3375:
    nfrfld = 1;
    freone(cmn, d1);
    iofbnd = d1;
  statement_3379:
    write(kunit6, "('+POSTPROCESS.  IPLOT =',i6)"), iofbnd;
    {
      read_loop rloop(cmn, lunit2, fem::unformatted);
      rloop, bus1, bus2, bus3, bus4, n1, n2, n3, n4;
      FEM_DO_SAFE(i, 1, n1) {
        rloop, bus5;
      }
    }
    n13 = n2 + n4;
    if (iprsup > 0) {
      write(lunit6, "(/,' AFTER 1ST RECORD.  DATE=',2a4,4i5)"), bus1,
        bus2, n1, n2, n3, n4;
    }
    if (n2 > 0) {
      {
        read_loop rloop(cmn, lunit2, fem::unformatted);
        FEM_DO_SAFE(i, 1, n2) {
          rloop, n5;
        }
      }
    }
    if (n4 > 0) {
      {
        read_loop rloop(cmn, lunit2, fem::unformatted);
        FEM_DO_SAFE(i, 1, n4) {
          rloop, n5;
        }
      }
    }
    if (m4plot == 0) {
      goto statement_3385;
    }
    iofgnd = 1;
    pltlu2(cmn, epsuba, farray(1));
    goto statement_3386;
  statement_3385:
    read(lunit2, fem::unformatted), epsuba, farray(1);
  statement_3386:
    ltdelt = -6789;
    moncar(3) = ltdelt;
    iofgnd = n13;
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 8.   'PLOTTER PAPER HEIGHT' $$  M28.1339
  statement_8008:
    if (kolbeg > 0) {
      goto statement_2608;
    }
    expchk(cmn, ll25, ll80, ll8);
    if (kill > 0) {
      goto statement_9200;
    }
    read(abuff, format_2605), szplt;
    goto statement_2612;
  statement_2608:
    nfrfld = 1;
    freone(cmn, szplt);
  statement_2612:
    if (noutpr == 0) {
      write(kunit6, "('+NEW PLOTTER PAPER-HEIGHT LIMIT.',2x,e13.3)"), szplt;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 9.   'PRINTER LINES PER INCH'   M28.1352
  statement_8009:
    if (kolbeg > 0) {
      goto statement_2628;
    }
    intchk(cmn, ll25, ll80, ll8);
    if (kill > 0) {
      goto statement_9200;
    }
    read(abuff, format_2642), lnpin;
    goto statement_2631;
  statement_2628:
    nfrfld = 1;
    frefld(cmn, voltbc(1));
    lnpin = voltbc(1);
  statement_2631:
    if (noutpr == 0) {
      write(kunit6, "('+NEW PRINTER SPACING, LINES/DISTANCE =',2x,i8)"), lnpin;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 10.   'MODE VOLTAGE OUTPUT' $$$ M28.1365
  statement_8010:
    if (kolbeg > 0) {
      goto statement_2644;
    }
    intchk(cmn, ll25, ll80, ll8);
    if (kill > 0) {
      goto statement_9200;
    }
    read(abuff, format_2642), modout;
    goto statement_2646;
  statement_2644:
    nfrfld = 1;
    frefld(cmn, voltbc(1));
    modout = voltbc(1);
  statement_2646:
    if (modout <= 0) {
      modout = 3;
    }
    if (noutpr == 0) {
      write(kunit6,
        "('+REQUEST FOR TRICKY KARRENBAUER OUTPUT,',i3,'  MODES.')"),
        modout;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 11.   'END LAST DATA CASE' $$$$ M28.1381
  statement_8011:
    if (noutpr == 0) {
      write(kunit6, "('+SPECIAL TERMINATOR RECORD FOR ALL DATA.')");
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 12.   'ANALYTIC SOURCES USAGE'  M28.1386
  statement_8012:
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST FOR USE OF ANALYTIC TYPE 1-10 SOURCES.')");
    }
    cmn.kanal = 1;
    goto statement_15;
    //C     $$$$$ SPECIAL-REQUEST WORD NO. 13.   'LIMIT ON PLOT OSCILLATIONS' M28.1392
  statement_8013:
    if (kolbeg > 0) {
      goto statement_2671;
    }
    read(abuff, format_2642), nsmth;
    goto statement_2673;
  statement_2671:
    nfrfld = 1;
    frefld(cmn, voltbc(1));
    nsmth = voltbc(1);
  statement_2673:
    if (noutpr == 0) {
      write(kunit6, "('+CHANGE SUCCESSIVE OSCILLATION LIMIT.',2x,i8)"), nsmth;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 14.   'TACS EMTP SOURCES'  $$$$ M28.1403
  statement_8014:
    if (noutpr == 0) {
      write(kunit6, "('+TACS NAMES CONTROLLING TYPE 1-10 EMTP SOURCES.')");
    }
    if (kolbeg > 0) {
      goto statement_2683;
    }
    {
      read_loop rloop(abuff(1), "(20x,10a6)");
      FEM_DO_SAFE(j, 1, 10) {
        rloop, vstacs(j);
      }
    }
    goto statement_2686;
  statement_2683:
    nright = -2;
    freone(cmn, d1);
    FEM_DO_SAFE(j, 1, 10) {
      vstacs(j) = texta6(j);
    }
  statement_2686:
    nstacs = 10;
  statement_2687:
    if (vstacs(nstacs) != blank) {
      goto statement_2690;
    }
    nstacs = nstacs - 1;
    if (nstacs > 0) {
      goto statement_2687;
    }
  statement_2690:
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 15.   'START AGAIN'       $$$$$ M28.1420
    //C              THIS REQUEST IS HANDLED OUTSIDE OF SUBROUTINE.           M28.1421
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 16.   'SEMLYEN SETUP'     $$$$$ M28.1422
  statement_8016:
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST FOR SEMLYEN STEP-RESPONSE ROUTINE.')");
    }
    nchain = 45;
    goto statement_5617;
    //C     $$$$  SPECIAL REQUEST-WORD NO. 17.   'LINEAR BIAS USAGE' $$$$$$$$$M42.1186
  statement_8017:
    if (noutpr == 0) {
      write(lunit6, "('+RAMPED LINEAR VARIATION OF RANDOM BIAS.')");
    }
    cmn.linsys = 1;
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 18.   'CABLE CONSTANTS'   $$$$$ M28.1434
  statement_8018:
    read(abuff, "(48x,e8.0,i8)"), d13, ktrlsw(3);
    if (d13 > 0.0f) {
      znvref = d13;
    }
    if (noutpr == 0) {
      write(kunit6,
        "('+TRANSFER TO \"CABLE CONSTANTS\".  TYPE =',i6)"), ktrlsw(3);
    }
    nchain = 47;
    goto statement_5617;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 19.   'AUTO NAME'         $$$$$ M42.1189
  statement_8019:
    nmauto++;
    iprsov(39) = nmauto;
    if (nmauto >= 2) {
      nmauto = 0;
    }
    if (noutpr == 0) {
      write(kunit6, "('+TOGGLE BRANCH NAMING OPTION.   NMAUTO =',i8)"), nmauto;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 20.   'RENUMBER BYPASS'   $$$$$ M28.1487
  statement_8020:
    if (noutpr == 0) {
      write(kunit6, "('+BYPASS OF TRANSIENT NETWORK RENUMBERING.')");
    }
    //C     NEGATIVE "KPARTB" (1000 OR EXPONENT OF "HIGH RESISTANCE")         M32. 750
    //C     IS FLAG CARRIED INTO "OVER6" TO BYPASS OVERLAY 7:                 M32. 751
    kpartb = -fem::iabs(kpartb);
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 21.   'FREQUENCY SCAN'    $$$$$ M28.1493
  statement_8021:
    if (kolbeg > 0) {
      goto statement_2773;
    }
    expchk(cmn, ll25, ll48, ll8);
    intchk(cmn, ll49, ll56, ll8);
    if (kill > 0) {
      goto statement_9200;
    }
    read(abuff, "(24x,3e8.0,i8)"), fminfs, delffs, fmaxfs, n8;
    goto statement_2776;
  statement_2773:
    nfrfld = 4;
    frefld(cmn, voltbc(1));
    fminfs = voltbc(1);
    delffs = voltbc(2);
    fmaxfs = voltbc(3);
    n8 = voltbc(4);
  statement_2776:
    if (noutpr != 0) {
      goto statement_2781;
    }
    if (kexact == 88333) {
      goto statement_2778;
    }
    write(kunit6, "('+F-SCAN.',3e12.3,i5)"), fminfs, delffs, fmaxfs, n8;
    goto statement_2781;
  statement_2778:
    write(kunit6, "('+LINE MODEL FREQ SCAN.',2e12.3,i3)"), fminfs, fmaxfs, n8;
    cmn.fminsv = fminfs;
  statement_2781:
    if (fminfs <= 0.0f) {
      goto statement_2785;
    }
    if (fmaxfs <= fminfs) {
      goto statement_2785;
    }
    if (n8 != 0) {
      goto statement_2782;
    }
    if (delffs <= 0.0f) {
      goto statement_2785;
    }
    goto statement_15;
  statement_2782:
    if (n8 < 0) {
      goto statement_2785;
    }
    d7 = 10.f;
    d8 = alogz(d7) / n8;
    delffs = -expz(d8);
    goto statement_15;
  statement_2785:
    kill = 193;
    lstat(14) = n8;
    lstat(19) = 2785;
    goto statement_9200;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 22.   'FREE FORMAT'       $$$$$ M28.1524
  statement_8022:
    read(abuff, "(16x,a1,7x,a1)"), bus4, bus5;
    if (noutpr == 0) {
      write(kunit6,
        "('+FREE-FIELD CHARACTERS.   ''',a1,'''   AND   ''',a1,''' .')"),
        bus4, bus5;
    }
    if (bus4 != blank) {
      cmn.csepar = bus4;
    }
    if (bus5 != blank) {
      cmn.chcont = bus5;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 23.   'DIAGNOSTIC'        $$$$$ M28.1535
  statement_8023:
    if (kolbeg > 0) {
      goto statement_2814;
    }
    {
      read_loop rloop(abuff(1), "(20x,30i2)");
      FEM_DO_SAFE(i, 1, 30) {
        rloop, iprsov(i);
      }
    }
    goto statement_2816;
  statement_2814:
    nfrfld = 30;
    frefld(cmn, voltbc(1));
    if (kill > 0) {
      goto statement_9200;
    }
    FEM_DO_SAFE(i, 1, 30) {
      iprsov(i) = voltbc(i);
    }
  statement_2816:
    iprsup = iprsov(1);
    if (noutpr == 0) {
      {
        write_loop wloop(cmn, kunit6, "('+DIAGNOSTIC PRINTOUT CODES.',5i4)");
        FEM_DO_SAFE(i, 1, 5) {
          wloop, iprsov(i);
        }
      }
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 24.   'POWER FREQUENCY'   $$$$$ M28.1550
  statement_8024:
    if (kolbeg > 0) {
      goto statement_2820;
    }
    read(abuff, format_2605), statfr;
    goto statement_2822;
  statement_2820:
    nfrfld = 1;
    freone(cmn, statfr);
  statement_2822:
    if (noutpr == 0) {
      write(kunit6, "('+REDEFINED POWER FREQUENCY =',e12.3,'  HZ.')"), statfr;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 25.   'FILE REQUEST'      $$$$$ M28.1560
  statement_8025:
    if (noutpr == 0) {
      write(kunit6, "('+CALL SUBROUTINE \"MIDOV1\" .')");
    }
    midov1(cmn);
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 26.   'USER IDENTIFICATION' $$$ M28.1566
  statement_8026:
    if (kolbeg > 0) {
      goto statement_4661;
    }
    read(abuff, "(24x,8a6)"), userid;
    goto statement_4664;
  statement_4661:
    nright = -2;
    freone(cmn, d1);
    nright = 0;
    userid = texta6(1);
  statement_4664:
    if (noutpr == 0) {
      write(kunit6, "('+USER IDENTIFICATION.',1x,4a6)"), userid;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 27.   'CONVERT ZNO'  $$$$$$$$$$ M39. 359
  statement_8027:
    iofbnd = 99876;
    nchain = 42;
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST TO CONVERT OLD ZNO DATA TO NEW FORMATS.')");
    }
    goto statement_5617;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 28.   'ABORT DATA CASE'   $$$$$ M28.1590
  statement_8028:
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST TO ABORT THIS DATA CASE.')");
    }
    L = 0;
    //C     READ INPUT CARD USING CIMAGE                                      M28.1595
  statement_4699:
    cimage(cmn);
    n9 = kolbeg;
    kolbeg = 1;
    nright = -2;
    freone(cmn, d1);
    n1 = jpntr(5);
    n2 = jpntr(6) - 1;
    k = 0;
    FEM_DO_SAFE(i, n1, n2) {
      k++;
      if (texta6(k) != textax(i)) {
        goto statement_4711;
      }
    }
    goto statement_15;
  statement_4711:
    L++;
    if (noutpr == 0) {
      write(kunit6, "('+   DISCARDED CARD NUMBER',i5,'   OF SKIPPED CASE.')"), L;
    }
    goto statement_4699;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 29.   'KILL CODES'        $$$$$ M28.1615
  statement_8029:
    ipntv(1) = -8888;
    if (kolbeg > 0) {
      goto statement_4724;
    }
    read(abuff, format_4721), kill, ipntv(2);
    goto statement_4726;
  statement_4724:
    nfrfld = 2;
    frefld(cmn, voltbc(1));
    kill = voltbc(1);
    ipntv(2) = voltbc(2);
  statement_4726:
    write(kunit6, "('+LISTING OF ERROR MESSAGES.',2i8)"), kill, ipntv(2);
    ipntv(3) = kill;
    write(lunit6, "(/,' MESSAGE OF KILL-CODE NUMBER',i4,'.')"), kill;
    bus1 = trash;
    bus2 = trash;
    bus3 = trash;
    bus4 = trash;
    bus5 = trash;
    cmn.bus6 = trash;
    FEM_DO_SAFE(j, 11, 17) {
      lstat(j) = 0;
      flstat(j) = 0.0f;
    }
    nchain = 51;
    goto statement_9200;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 30.   'HIGH RESISTANCE'   $$$$$ M28.1632
  statement_8030:
    n7 = kpartb;
    if (kolbeg > 0) {
      goto statement_4735;
    }
    read(abuff, format_4721), kpartb;
    intchk(cmn, ll33, ll40, ll8);
    if (kill > 0) {
      goto statement_9200;
    }
    goto statement_4737;
  statement_4735:
    nfrfld = 1;
    frefld(cmn, voltbc(1));
    kpartb = voltbc(1);
  statement_4737:
    d1 = fem::pow(10.0f, kpartb);
    if (noutpr == 0) {
      write(kunit6, "('+EXPONENT OF HIGH RESISTANCE.   R =',e12.2)"), d1;
    }
    //C     POSSIBLE NEGATIVE SIGN ON PREVIOUS "KPARTB" MUST BE               M32. 755
    //C     RETAINED AS FLAG FOR "RENUMBER BYPASS" USAGE:                     M32. 756
    if (n7 < 0) {
      kpartb = -kpartb;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 31.   'AVERAGE OUTPUT'    $$$$$ M28.1646
  statement_8031:
    cmn.iaverg = 1;
    nsmth = intinf;
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST TO AVERAGE (SMOOTH) OUTPUT.')");
    }
    goto statement_15;
    //C     $$$$$  SPECIAL REQUEST-WORD NO. 32.  'ABSOLUTE TACS DIMENSIONS'  $M28.1653
    //C     $$$$$  SPECIAL REQUEST-WORD NO. 33.  'RELATIVE TACS DIMENSIONS'  $M28.1654
    //C     THESE TWO REQUESTS HANDLED OUTSIDE OF SUBROUTINE.                 M28.1655
    //C     $$ SPECIAL REQUEST-WORD NO. 34.  'TABULATE ENERGIZATION RESULTS'  M28.1656
  statement_8034:
    write(kunit6, "('+REQUEST FOR  ''STATISTICS''  TERMINATION.')");
    nenerg = intinf;
    goto statement_15;
    //C     $$ SPECIAL REQUEST-WORD NO. 35.  'STATISTICS OUTPUT SALVAGE'      M28.1661
  statement_8035:
    if (kolbeg > 0) {
      goto statement_7193;
    }
    read(abuff, "(29x,i3)"), jflsos;
    goto statement_7195;
  statement_7193:
    nfrfld = 1;
    freone(cmn, d1);
    jflsos = d1;
  statement_7195:
    if (jflsos > 0) {
      goto statement_7199;
    }
    //C     FIND RANDOM INTEGER  'JFLSOS'  BETWEEN ZERO AND 999.              M28.1670
    runtym(d1, d2);
    seed = seedy(cmn, tclock(1)) + 1000.f * (d1 + d2);
    n13 = alog1z(seed) + epsiln;
    n13 = n13 - 2;
    seed = seed / fem::pow(10.f, n13);
    jflsos = seed;
  statement_7199:
    if (noutpr == 0) {
      write(kunit6, "('+DISK STORAGE OF ENERGIZATION RESULTS.',i8)"), jflsos;
    }
    goto statement_15;
    //C     $$$$  SPECIAL REQUEST-WORD NO. 36.   'OMIT BASE CASE'    $$$$$$$$$M28.1681
  statement_8036:
    if (noutpr == 0) {
      write(kunit6, "('+OMIT BASE CASE IF STATISTICS/SYSTEMATIC CASE.')");
    }
    kbase = intinf;
    moncar(2) = kbase;
    goto statement_15;
    //C     $$$$  SPECIAL REQUEST-WORD NO. 37.   'CHANGE SWITCH'     $$$$$$$$$M42.1196
  statement_8037:
    if (noutpr == 0) {
      write(kunit6, "('+CONVERT SWITCHED-L,R TO PSEUDO-NONLINEAR.')");
    }
    iofbnd = 33666;
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 38.   'MISCELLANEOUS DATA       M28.1691
    //C                                              CARDS'          $$$$$$$$$M28.1692
  statement_8038:
    cmn.ifdep = -5555;
    write(kunit6, "('+REQUEST RECORD BEFORE MISC. DATA CARDS.')");
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 39.   'REDEFINE TOLERANCE       M28.1697
    //C                                              EPSILN'         $$$$$$$$$M28.1698
  statement_8039:
    if (kolbeg > 0) {
      goto statement_7217;
    }
    read(abuff, format_2605), epsiln;
    goto statement_7223;
  statement_7217:
    nfrfld = 1;
    freone(cmn, epsiln);
  statement_7223:
    write(kunit6, "('+MISC. DATA CONSTANT  ''EPSILN'' .',e12.3)"), epsiln;
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 40.   'CHANGE PRINTOUT          M28.1707
    //C                                              FREQUENCY       $$$$$$$$$M28.1708
  statement_8040:
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST RECORD BEFORE PRINTOUT FREQUENCIES.')");
    }
    cmn.ktref = -7777;
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 41.   'BEGIN PEAK               M28.1714
    //C                                              VALUE SEARCH'   $$$$$$$$$M28.1715
  statement_8041:
    if (kolbeg > 0) {
      goto statement_7247;
    }
    read(abuff, format_2605), begmax(2);
    goto statement_7249;
  statement_7247:
    nfrfld = 1;
    frefld(cmn, begmax(2));
  statement_7249:
    if (noutpr == 0) {
      write(kunit6, "('+EXTREMA CALC. BEGINS AT',e13.4,'  SECONDS.')"), begmax(2);
    }
    if (begmax(2) != -1.f) {
      goto statement_15;
    }
    //C     READ INPUT DATA CARD USING CIMAGE                                 M31. 292
    cimage(cmn);
    {
      read_loop rloop(abuff(1), "(10e8.0)");
      FEM_DO_SAFE(ip, 2, 6) {
        rloop, begmax(ip);
      }
    }
    if (noutpr == 0) {
      {
        write_loop wloop(cmn, kunit6, "('+(T1,T2):',4e10.2)");
        FEM_DO_SAFE(ip, 2, 5) {
          wloop, begmax(ip);
        }
      }
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 42.   'TIME OF                  M28.1725
    //C                                              DICE ROLL'    $$$$$$$$$$$M28.1726
  statement_8042:
    if (kolbeg > 0) {
      goto statement_7255;
    }
    read(abuff, format_2605), tenerg;
    goto statement_7261;
  statement_7255:
    nfrfld = 1;
    freone(cmn, tenerg);
  statement_7261:
    if (noutpr == 0) {
      write(kunit6, "('+STATISTICS TABLE-SAVING TIME =',e12.3,'  SEC.')"), tenerg;
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 43.   'ZINC OXIDE'   $$$$$$$$$$$M37.1202
  statement_8043:
    if (kolbeg > 0) {
      goto statement_7266;
    }
    {
      read_loop rloop(abuff(1), "(16x,i8,5e8.0)");
      rloop, n13;
      FEM_DO_SAFE(m, 15, 19) {
        rloop, flstat(m);
      }
    }
    goto statement_7268;
  statement_7266:
    nfrfld = 6;
    frefld(cmn, flstat(14));
    n13 = flstat(14);
  statement_7268:
    if (n13 > 0) {
      maxzno = n13;
    }
    if (flstat(15) > 0.0f) {
      epszno = flstat(15);
    }
    if (flstat(16) > 0.0f) {
      epwarn = flstat(16);
    }
    if (flstat(17) > 0.0f) {
      epstop = flstat(17);
    }
    if (flstat(18) > 0.0f) {
      znolim(1) = flstat(18);
    }
    if (flstat(19) > 0.0f) {
      znolim(2) = flstat(19);
    }
    if (noutpr == 0) {
      write(kunit6, "('+ZNO CONST.',i4,3e11.3)"), maxzno, epszno, epwarn, epstop;
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 44.   'PEAK VOLTAGE'  $$$$$$$$$$M28.1743
    //C     $$$$$$$                                  MONITOR'      $$$$$$$$$$$M28.1744
  statement_8044:
    peaknd(1) = cmn.flzero;
    if (noutpr == 0) {
      write(kunit6, "('+OVERALL PROBLEM PEAK NODE VOLTAGE.')");
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 45.   'ABSOLUTE U.M.  $$$$$$$$$$M28.1750
    //C                                              DIMENSIONS'    $$$$$$$$$$M28.1751
  statement_8045:
    if (kolbeg > 0) {
      goto statement_7279;
    }
    read(abuff, format_7276), nclfix, numfix, iotfix, ibsfix;
    goto statement_7282;
  statement_7279:
    nfrfld = 4;
    frefld(cmn, voltbc(1));
    nclfix = voltbc(1);
    numfix = voltbc(2);
    iotfix = voltbc(3);
    ibsfix = voltbc(4);
  statement_7282:
    if (nclfix > 0) {
      goto statement_7284;
    }
    nclfix = 20;
    numfix = 3;
    iotfix = 50;
    ibsfix = 60;
  statement_7284:
    if (noutpr == 0) {
      write(kunit6, "('+U.M. TABLE SIZES.',4i6)"), nclfix, numfix, iotfix, ibsfix;
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 46.   'RELATIVE U.M.  $$$$$$$$$$M28.1772
    //C                                              DIMENSIONS'    $$$$$$$$$$M28.1773
  statement_8046:
    if (kolbeg > 0) {
      goto statement_7298;
    }
    {
      read_loop rloop(abuff(1), format_7276);
      FEM_DO_SAFE(k, 1, 4) {
        rloop, voltbc(k);
      }
    }
    goto statement_7303;
  statement_7298:
    nfrfld = 4;
    frefld(cmn, voltbc(1));
  statement_7303:
    d1 = 0.0f;
    FEM_DO_SAFE(j, 1, 4) {
      d1 += voltbc(j);
    }
    if (d1 > 0.0f) {
      goto statement_7310;
    }
    voltbc(1) = 42;
    voltbc(2) = 23;
    voltbc(3) = 10;
    voltbc(4) = 10;
    goto statement_7303;
  statement_7310:
    d1 = cmn.lspcum * nbyte(3) / d1;
    nclfix = voltbc(1) * d1 / (4 * nbyte(3) + 4 * nbyte(4));
    numfix = voltbc(2) * d1 / (17 * nbyte(3) + 12 * nbyte(4));
    iotfix = voltbc(3) * d1 / (2 * nbyte(4));
    ibsfix = voltbc(4) * d1 / (1 * nbyte(1));
    if (noutpr == 0) {
      write(kunit6, "('+DERIVED U.M. SIZES.',4i6)"), nclfix, numfix,
        iotfix, ibsfix;
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 47.   'TIME STEP LOOP'  $$$$$$$$M28.1797
  statement_8047:
    if (noutpr == 0) {
      write(kunit6, "('+TRANSFER CONTROL TO TIME-STEP LOOP.')");
    }
    nchain = 16;
    cmn.t = flstat(14);
    move0(flstat, 3, 4);
    runtym(d1, d2);
    flstat(1) += d1;
    flstat(2) += d2;
    flstat(7) = -d1;
    flstat(8) = -d2;
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 48.   'ALTERNATE DIAGNOSTIC     M28.1810
    //C                                                    PRINTOUT'  $$$$$$$$M28.1811
  statement_8048:
    if (kolbeg > 0) {
      goto statement_7322;
    }
    {
      read_loop rloop(abuff(1), format_2642);
      FEM_DO_SAFE(j, 1, 4) {
        rloop, iprsov(j + 30);
      }
    }
    goto statement_7329;
  statement_7322:
    nfrfld = 4;
    frefld(cmn, voltbc(1));
    FEM_DO_SAFE(j, 1, 4) {
      iprsov(j + 30) = voltbc(j);
    }
  statement_7329:
    if (noutpr == 0) {
      {
        write_loop wloop(cmn, kunit6, "('+DELTAT-LOOP PRINTOUT.',4i6)");
        FEM_DO_SAFE(j, 1, 4) {
          wloop, iprsov(j + 30);
        }
      }
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 49.   'TACS WARN LIMIT' $$$$$$$$M31. 317
  statement_8049:
    if (kolbeg > 0) {
      goto statement_7334;
    }
    read(abuff, "(16x,i8,e8.0)"), lstat(51), pu;
    goto statement_7335;
  statement_7334:
    nfrfld = 2;
    frefld(cmn, voltbc(1));
    lstat(51) = voltbc(1);
    pu = voltbc(2);
  statement_7335:
    if (noutpr == 0) {
      write(kunit6, "('+WARNING CONTROLS.  LIM, T-BEG =',i6,e10.2)"),
        lstat(51), pu;
    }
    goto statement_15;
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 50.   'MARTI SETUP'       $$$$$ M29.1081
  statement_8050:
    //C     $$$$$    SPECIAL-REQUEST WORD NO. 51.   'JMARTI SETUP' $$$$$$$$$$ M32. 758
  statement_8051:
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST FOR NEW, FORTIFIED \"MARTI SETUP\".')");
    }
    nchain = 39;
    goto statement_5617;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 52.   'CUSTOM PLOT FILE' $$$$$$ M29.1101
  statement_8052:
    n4 = m4plot;
    if (n4 == 0) {
      m4plot = 2;
    }
    if (n4 == 2) {
      m4plot = 0;
    }
    if (noutpr == 0) {
      write(kunit6,
        "('+NON-STD. CHOICE OF DISK PLOT FILE.','   M4PLOT =',i2)"),
        m4plot;
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 53.   'OUTPUT WIDTH 132' $$$$$$ M32. 771
  statement_8053:
    if (noutpr == 0) {
      write(kunit6, "('+USE FULL-WIDTH (132-COL.) PRINTOUT.')");
    }
    kol132 = 132;
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 54.   'OUTPUT WIDTH 80'  $$$$$$ M32. 777
  statement_8054:
    if (noutpr == 0) {
      write(kunit6, "('+USE NARROW (80-COL.) PRINTOUT.')");
    }
    kol132 = 80;
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 55.   'MODIFY SWITCH LOGIC  $$$ M32. 783
  statement_8055:
    n7 = ktrlsw(6) + 1;
    if (n7 >= 2) {
      n7 = 0;
    }
    ktrlsw(6) = n7;
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST FOR ALTERED LOGIC.  KTRLSW(6) =',i2)"), n7;
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 56.   'FAULT DATA USAGE' $$$$$$ M32. 791
  statement_8056:
    if (kolbeg > 0) {
      goto statement_7379;
    }
    read(abuff, format_2642), iofbnd;
    goto statement_7382;
  statement_7379:
    nfrfld = 1;
    frefld(cmn, voltbc(1));
    iofbnd = voltbc(1);
  statement_7382:
    if (noutpr == 0) {
      write(kunit6, "('+REQUEST FOR GENERATOR EQUIVALENTS.')");
    }
    istep = -6633;
    nchain = 29;
    goto statement_5617;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 57.   'FIX SOURCE'  $$$$$$      M36. 307
  statement_8057:
    istep = -4567;
    if (noutpr == 0) {
      write(kunit6, "('+DECLARATION OF DESIRED LOAD FLOW USE.')");
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 58.   'USER SUPPLIED     $$$$$$ M37.1220
    //C     $$$$$$$                                  SWITCH TIMES'     $$$$$$ M37.1221
  statement_8058:
    if (kolbeg > 0) {
      goto statement_7396;
    }
    read(abuff, format_2642), n14;
    goto statement_7402;
  statement_7396:
    nfrfld = 1;
    frefld(cmn, voltbc(1));
    n14 = voltbc(1);
  statement_7402:
    moncar(7) = n14;
    if (n14 == 0) {
      moncar(7) = 24;
    }
    if (noutpr == 0) {
      write(kunit6, "('+FILE OF RANDOM SWITCHING TIMES.  UNIT =',i6)"), moncar(7);
    }
    goto statement_15;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 59.   'AMETANI SETUP'  $$$      M42.1210
  statement_8059:
    if (noutpr == 0) {
      write(lunit6, "('+REQUEST FOR AMETANI STEP-RESPONSE ROUTINE.')");
    }
    nchain = 46;
    goto statement_5617;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 60.   'HAUER SETUP'  $$$$$      M42.1211
  statement_8060:
    if (noutpr == 0) {
      write(lunit6, "('+REQUEST FOR HAUER IMPULSE-RESPONSE ROUTINE.')");
    }
    nchain = 48;
    nenerg = 49;
    goto statement_5617;
    //C     $$$$$$$  SPECIAL REQUEST-WORD NO. 61.   'LINE MODEL FREQ. SCAN  $$
  statement_8061:
    kexact = 88333;
    cmn.nsolve = 0;
    kbrnum = 0;
    goto statement_8021;
    //C     $$$$$$$  ADDITIONAL KEY WORDS GO IN SLOTS BELOW:                  M36. 312
  statement_8062:
  statement_5617:
    flstat(7) = -9999.f;
    cmn.ck1 = -fltinf;
    cmn.ci1 = -fltinf;
  statement_15:
  statement_9200:
    if (iprsup >= 5) {
      write(lunit6,
        "(/,' EXIT  \"REQUES\" .','  NCHAIN  LUNIT6 LSTAT18    KILL',/,17x,4i8)"),
        nchain, lunit6, lstat(18), kill;
    }
    if (iprsup >= 1) {
      write(lunit6, "('  \"EXIT  MODULE REQUES.\"')");
    }
  }








  void sysplt(
      common& cmn,
      int const& lunit4)
  {
    //C     MODULE OF INTERACTIVE EMTP ONLY, WHICH SERVICES "EMTSPY".         M36.3401
    //C     IF NO INTERACTIVE EMTP USE, THIS MODULE CAN BE DELETED.           M36.3402
    //C     IT IS CALLED ONLY BY "SYSDEP", FOR STORAGE IN "DEKPLT".           M35.5872
    //C     SEPARATE MODULE NEEDED BECAUSE "DEKPLT" HAS NO IMPLICIT.          M35.5873
    cmn.l4plot = lunit4;
    //C     USAGE IS RESTRICTED TO "PLOT" FUNCTION OF "EMTSPY", DUE           M35.  37
    //C     TO VARIABLE-LENGTH CONFLICT (THIS IS SINGLE-PRECISION).           M35.  38
    //C!w nc -> ncz, numnvo -> numnvz, numout -> numouz, nv -> nvz
    //C     EVNBYT PUTS BUSLST ON REAL*8 BYTE BOUNDARY (IBM LEVEL 4 ERROR):   M39.  44
    //C!w EQUIVALENCE  ( EV(   1), BUSLST(1) ),  ( EV(1001), IBSOUT(1) )
    //C!w EQUIVALENCE  ( EV(1301), IBRNCH(1) ),  ( EV(1601), JBRNCH(1) )
    //C!w EQUIVALENCE  ( FVCOM( 1),   VMIN ),  ( FVCOM( 2),   VMAX )
    //C!w EQUIVALENCE  ( FVCOM( 3),   HMIN ),  ( FVCOM( 4),   HMAX )
    //C!w EQUIVALENCE  ( FVCOM( 5),     HA ),  ( FVCOM( 6), TAXISL )
    //C!w EQUIVALENCE  ( FVCOM( 7), TOLRCE ),  ( FVCOM( 8),   HTAX )
    //C!w EQUIVALENCE  ( FVCOM( 9),   XTIT ),  ( FVCOM(10),   YTIT )
    //C!w EQUIVALENCE  ( FVCOM(11), SIZTIT ),  ( FVCOM(12), XSUPER )
    //C!w EQUIVALENCE  ( FVCOM(13), YSUPER ),  ( FVCOM(14), SIZSUP )
    //C!w EQUIVALENCE  ( FVCOM(15),  FLINE ),  ( FVCOM(16),  SIZID )
    //C!w EQUIVALENCE  ( FVCOM(17),    XID ),  ( FVCOM(18),    YID )
    //C!w EQUIVALENCE  ( FVCOM(19),   FACT ),  ( FVCOM(20), DXGRD1 )
    //C!w EQUIVALENCE  ( FVCOM(21), DYGRD1 ),  ( FVCOM(22), DXGRD2 )
    //C!w EQUIVALENCE  ( FVCOM(23), DYGRD2 ),  ( FVCOM(24),  FILL1 )
    //C!w EQUIVALENCE  ( FVCOM(25),  FILL2 ),  ( FVCOM(26),     VS )
    //C!w EQUIVALENCE  ( FVCOM(27),     VL ),  ( FVCOM(28),     VH )
    //C!w EQUIVALENCE  ( FVCOM(29), PAPMAX ),  ( FVCOM(30), TIMBEG )
    //C!w EQUIVALENCE  ( FVCOM(31), TIMEND ),  ( FVCOM(32), FHTAX  )
    //C!w EQUIVALENCE  ( FVCOM(33), FXSUP  ),  ( FVCOM(34), FYSUP  )
    //C!w EQUIVALENCE  ( FVCOM(35), FXTIT  ),  ( FVCOM(36), FYTIT  )
    //C!w EQUIVALENCE  ( FVCOM(37), FXID   ),  ( FVCOM(38), FYID   )
    //C!w EQUIVALENCE  ( FVCOM(39), FTCARR ),  ( FVCOM(40), VAXISL )
    //C!w EQUIVALENCE  ( FVCOM(41), FXNUMV ),  ( FVCOM(42), FXNUMH )
    //C!w EQUIVALENCE  ( FVCOM(43), FVAXTT ),  ( FVCOM(44), FXVERT )
    //C!w EQUIVALENCE  ( FVCOM(45), FSYMB  ),  ( FVCOM(46), PAPLIM )
    //C!w EQUIVALENCE  ( IVCOM( 1),  KLEVL ),  ( IVCOM( 2),  KEXTR )
    //C!w EQUIVALENCE  ( IVCOM( 3),    IHS ),  ( IVCOM( 4), LU7PLT )
    //C!w EQUIVALENCE  ( IVCOM( 5), IPRSRT ),  ( IVCOM( 6), LIMCOL )
    //C!w EQUIVALENCE  ( IVCOM( 7), LINEPR ),  ( IVCOM( 8),  IBAUD )
    //C!w EQUIVALENCE  ( IVCOM( 9),   LTEK ),  ( IVCOM(10), NUMTIT )
    //C!w EQUIVALENCE  ( IVCOM(11), MAXSYM ),  ( IVCOM(12),   MTIT )
    //C!w EQUIVALENCE  ( IVCOM(13), MAXISX ),  ( IVCOM(14), MAXISY )
    //C!w EQUIVALENCE  ( IVCOM(15), MGRID1 ),  ( IVCOM(16), MGRID2 )
    //C!w EQUIVALENCE  ( IVCOM(17), MSUPER ),  ( IVCOM(18),    MID )
    //C!w EQUIVALENCE  ( IVCOM(19),  MLINE ),  ( IVCOM(20),  NCUT1 )
    //C!w EQUIVALENCE  ( IVCOM(21),  NCUT2 ),  ( IVCOM(22), NSMPLT )
    //C!w EQUIVALENCE  ( IVCOM(23),  LSYMB ),  ( IVCOM(24),  NXMAX )
    //C!w EQUIVALENCE  ( IVCOM(25),  NYMAX ),  ( IVCOM(26),  LCHID )
    //C!w EQUIVALENCE  ( IVCOM(27), NXINCH ),  ( IVCOM(28), NYINCH )
    //C!w EQUIVALENCE  ( IVCOM(29),  NXOFF ),  ( IVCOM(30),  NYOFF )
    //C!w EQUIVALENCE  ( IVCOM(31),   LOOK ),  ( IVCOM(32), LCHSUP )
    //C!w EQUIVALENCE  ( IVCOM(33), LCHTIT ),  ( IVCOM(34), LCHXAX )
    //C!w EQUIVALENCE  ( IVCOM(35), LCHYAX ),  ( IVCOM(36),  ITERM )
    //C!w EQUIVALENCE  ( IVCOM(37),   LTIC ),  ( IVCOM(38),  IZTIT )
    //C!w EQUIVALENCE  ( IVCOM(39),  IZGR1 ),  ( IVCOM(40),  IZGR2 )
    //C!w EQUIVALENCE  ( IVCOM(41), LDSHG1 ),  ( IVCOM(42), LDSHG2 )
    //C!w EQUIVALENCE  ( IVCOM(43),  IZXAX ),  ( IVCOM(44),  IZYAX )
    //C!w EQUIVALENCE  ( IVCOM(45),  NXID6 ),  ( IVCOM(46),  NYID6 )
    //C!w EQUIVALENCE  ( IVCOM(47),  NXEND ),  ( IVCOM(48),  NYEND )
    //C!w EQUIVALENCE  ( IVCOM(49),   IZID ),  ( IVCOM(50), NXVERN )
    //C!w EQUIVALENCE  ( IVCOM(51), ICHREF ),  ( IVCOM(52), ICHEND )
    //C!w EQUIVALENCE  ( IVCOM(53), INCHPX ),  ( IVCOM(54), INCHPY )
    //C!w EQUIVALENCE  ( IVCOM(55), INWAIT ),  ( IVCOM(56), NOLABL )
    //C!w EQUIVALENCE  ( IVCOM(57), LCHFIL ),  ( IVCOM(58), LCHLIM )
    //C!w EQUIVALENCE  ( IVCOM(59), MU6STD )
    //C       NEXT TYPE KEY CHARACTER KEY WORDS IN COMMON, IN ORDER:          M35. 120
    //C!w EQUIVALENCE ( ANPLT( 1), CHOICE ),  ( ANPLT( 2),   STOP )
    //C!w EQUIVALENCE ( ANPLT( 3),  PURGE ),  ( ANPLT( 4),    OUT )
    //C!w EQUIVALENCE ( ANPLT( 5),   HELP ),  ( ANPLT( 6), SMOOTH )
    //C!w EQUIVALENCE ( ANPLT( 7),   SIZE ),  ( ANPLT( 8),   SHOW )
    //C!w EQUIVALENCE ( ANPLT( 9), LINEZZ ),  ( ANPLT(10),  PHOTO )
    //C!w EQUIVALENCE ( ANPLT(11), REPEAT ),  ( ANPLT(12),  FLUSH )
    //C!w EQUIVALENCE ( ANPLT(13), PLAYBA ),  ( ANPLT(14),    PEN )
    //C!w EQUIVALENCE ( ANPLT(15), MULTIP ),  ( ANPLT(16), OFFSET )
    //C!w EQUIVALENCE ( ANPLT(17), LIMITS ),  ( ANPLT(18),  DEBUG )
    //C!w EQUIVALENCE ( ANPLT(19),    TEK ),  ( ANPLT(20),  STACK )
    //C!w EQUIVALENCE ( ANPLT(21), PRINTE ),  ( ANPLT(22), METRIC )
    //C!w EQUIVALENCE ( ANPLT(23), ALLTIM ),  ( ANPLT(24), COLUMN )
    //C!w EQUIVALENCE ( ANPLT(25), SETCOL ),  ( ANPLT(26), LONGER )
    //C!w EQUIVALENCE ( ANPLT(27), AVERAG ),  ( ANPLT(28),  INNER )
    //C!w EQUIVALENCE ( ANPLT(29), RESCAL ),  ( ANPLT(30),  LASTPL)
    //C!w EQUIVALENCE ( ANPLT(31),  BATCH ),  ( ANPLT(32),  PUNCH )
    //C!w EQUIVALENCE ( ANPLT(33), EXTREM ),  ( ANPLT(34),  LEVEL )
    //C!w EQUIVALENCE ( ANPLT(35), NOPLOT ),  ( ANPLT(36), MESSAG )
    //C!w EQUIVALENCE ( ANPLT(37),    END ),  ( ANPLT(38), TIMESP )
    //C!w EQUIVALENCE ( ANPLT(39),  LABEL ),  ( ANPLT(40), TIMEUN )
    //C!w EQUIVALENCE ( ANPLT(41), CURSOR ),  ( ANPLT(42), XYPLOT )
    //C!w EQUIVALENCE ( ANPLT(43),  SLOPE ),  ( ANPLT(44),   BACK )
    //C!w EQUIVALENCE ( ANPLT(45), REFILE ),  ( ANPLT(46), TEXBLK )
    //C!w EQUIVALENCE ( ANPLT(47), SETDAT )
  }

  void
    settym()
  {
    //C       VAX-11  INSTALLATION-DEPENDENT EMTP MODULE.                     M37. 873
    //C     CALLED ONLY BY VAX "RUNTYM";  DESTROY FOR OTHER COMPUTERS.        M37. 874
    //C     INCLUDE  '[SCOTT]COMMUK.FOR' --- SHARE WITH "RUNTYM" IN-LINE:     M37. 875
    //C!COMMON /TIMERS/ CPUTIME
    //C!INTEGER*4 CPUTIME
    //C!COMMON /TIMER2/ L4CPU,CPUTIME_CODE,CPUTIME_ADR,ZERO,ZEROFIN
    //C!INTEGER*2 L4CPU,CPUTIME_CODE
    //C!INTEGER*4 CPUTIME_ADR,ZERO,ZEROFIN,SYS$GETJPI,NOW_CPUTIME
    //C!DATA CPUTIME_CODE /1031/
    //C!DATA L4CPU /4/
    //C!CPUTIME_ADR=%LOC(CPUTIME)
    //C!IF (.NOT.SYS$GETJPI(,,,L4CPU,,,)) THEN
    //C!            WRITE(6,*) 'ERROR IN A PRIVATE PLACE'
    //C!            ENDIF
  }


  void tacs1c(
      common& cmn)
  {
    common_read read(cmn);
    common_write write(cmn);
    const auto& abuff = cmn.abuff;
    double& deltat = cmn.deltat;
    const auto& lstat = cmn.lstat;
    auto& sptacs = cmn.sptacs;
    const auto& texvec = cmn.texvec;
    //
    //int kaliu = fem::int0;
    //int kiuty = fem::int0;
    //int kud1 = fem::int0;
    //int niu = fem::int0;
    auto& lunit6 = cmn.lunit6;
    int n = fem::int0;
    fem::str<8> alnode = fem::char0;
    double dum1 = fem::double0;
    double dum3 = fem::double0;
    double dum2 = fem::double0;
    int ijk = fem::int0;
    double prx = fem::double0;
    double pru = fem::double0;
    int ndy5 = fem::int0;
    int i = fem::int0;
    int ndx1 = fem::int0;
    //C     CALLED ONLY BY OVER1 FOR START AGAIN USAGE
    // handling equivalence in tacsar.inc
    auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
    auto& ivarb = isptacs;

    auto& kaliu = isptacs(11);
    auto& kiuty = isptacs(13);
    auto& kud1 =  isptacs(14);

    auto& niu = lstat(54);
    if (cmn.iprsup >= 1) {
      write(lunit6, "('  \"BEGIN MODULE TACS1C.\"')");
    }
    read(abuff, "(i2,a6,2x,3e10.0,14x,i6,2e10.0)"), n, alnode, dum1,
      dum3, dum2, ijk, prx, pru;
    if (niu < 12) {
      goto statement_2868;
    }
    ndy5 = kud1 - 5;
    FEM_DO_SAFE(i, 12, niu) {
      ndy5 += 5;
      ndx1 = ivarb(kaliu + i);
      if (texvec(ndx1) == alnode) {
        goto statement_6767;
      }
    }
    write(lunit6, "(' $$$ NO SUCH SOURCS, THE CARD WILL BE IGNORED $$$')");
    goto statement_2868;
  statement_6767:
    if (n == 0) {
      goto statement_6811;
    }
    ivarb(kiuty + i) = n;
  statement_6811:
    if (dum1 != 0.f || ijk < 0) {
      sptacs(ndy5 + 1) = dum1;
    }
    if (dum2 == 0.f && ijk > 0) {
      goto statement_6822;
    }
    sptacs(ndy5 + 2) = dum2;
    if (ivarb(kiuty + i) == 14) {
      sptacs(ndy5 + 2) = dum2 * cmn.twopi / 360.f;
    }
    if (ivarb(kiuty + i) != 23) {
      goto statement_6822;
    }
    if (sptacs(ndy5 + 2) < deltat) {
      sptacs(ndy5 + 2) = deltat;
    }
  statement_6822:
    if (dum3 != 0.f || ijk < 0) {
      sptacs(ndy5 + 3) = dum3;
    }
    if (prx != 0.f || ijk < 0) {
      sptacs(ndy5 + 4) = prx;
    }
    if (pru != 0.f) {
      sptacs(ndy5 + 5) = pru;
    }
    if (cmn.noutpr > 0) {
      write(lunit6, "(' ANOTHER TACS SOURCE CHANGING CARD')");
    }
  statement_2868:;
  }


  struct sysdep_save
  {
    fem::str<8> busnm1;
    fem::str<8> busnm2;
    fem::str<8> busnm3;
    arr<fem::str<1> > colxxx;
    fem::str<1> lettra;
    fem::str<1> lettrb;
    fem::str<1> lettrc;
    fem::str<8> text1;
    fem::str<8> text2;

    sysdep_save() :
      busnm1(fem::char0),
      busnm2(fem::char0),
      busnm3(fem::char0),
      colxxx(dimension(18), fem::fill0),
      lettra(fem::char0),
      lettrb(fem::char0),
      lettrc(fem::char0),
      text1(fem::char0),
      text2(fem::char0)
    {}
  };

  void sysdep(
      common& cmn)
  {
    FEM_CMN_SVE(sysdep);
    common_read read(cmn);
    common_write write(cmn);
    fem::str<8>& blank = cmn.blank;
    auto& date1= cmn.date1;
    auto& tclock= cmn.tclock;
    auto& abuff = cmn.abuff;
    auto& lunit1 = cmn.lunit1;
    auto lunit2 = cmn.lunit2;
    auto& lunit3 = cmn.lunit3;
    auto lunit4 = cmn.lunit4;
    auto& lunt10 = cmn.lunt10;
    auto& lunt11 = cmn.lunt11;
    auto& lunt12 = cmn.lunt12;
    auto& lunt13 = cmn.lunt13;
    auto& lunt14 = cmn.lunt14;
    auto& lunt15 = cmn.lunt15;
    auto& nbyte = cmn.nbyte;
    auto& iprsov= cmn.iprsov;
    int& m4plot = cmn.m4plot;
    auto& ktrlsw = cmn.ktrlsw;
    int& llbuff = cmn.llbuff;
    int& ltacst = cmn.ltacst;
    int& noutpr = cmn.noutpr;
    int& ltlabl = cmn.ltlabl;
    int& icat = cmn.icat;
    int& nenerg = cmn.nenerg;
    int& numcrd = cmn.numcrd;
    auto& col = cmn.col;
    const auto& file6 = cmn.file6;
    fem::str<32>& ansi32 = cmn.ansi32;
    //
    fem::str<8>& busnm1 = sve.busnm1;
    fem::str<8>& busnm2 = sve.busnm2;
    fem::str<8>& busnm3 = sve.busnm3;
    str_arr_ref<1> colxxx(sve.colxxx, dimension(18));
    fem::str<1>& lettra = sve.lettra;
    fem::str<1>& lettrb = sve.lettrb;
    fem::str<1>& lettrc = sve.lettrc;
    fem::str<8>& text1 = sve.text1;
    fem::str<8>& text2 = sve.text2;
    if (is_called_first_time) {
      colxxx(1) = " ";
      colxxx(2) = " ";
      colxxx(3) = " ";
      colxxx(4) = " ";
      colxxx(5) = " ";
      lettra = "A";
      lettrb = "B";
      lettrc = "C";
      colxxx(15) = ".";
      colxxx(16) = "P";
      colxxx(17) = "L";
      colxxx(18) = "4";
      busnm1 = "      ";
      busnm2 = "........";
      busnm3 = "TERRA ";
      text1 = ",";
      text2 = "$";
    }
    int i = fem::int0;
    auto& epomeg = cmn.epomeg;
    auto& lunit6 = cmn.lunit6;
    int j = fem::int0;
    int n7 = fem::int0;
    static const char* format_3641 = "(2a1,1x,a1)";

    FEM_DO_SAFE(i, 1, 18) {
      col(i) = colxxx(i);
    }
    lunit2 = 19;
    lunit4 = 20;
    //C DEFINE L4PLOT=LUNIT4 FOR "DEKPLT"
    sysplt(cmn, lunit4);
    //C THE CATALOG COMMAND OF "SPYING" USES THIS
    cmn.luntsp = 14;
    cmn.mflush = 0;

    //namespace fs = std::filesystem;
    //auto tmpPath = fs::temp_directory_path().string();

    if (m4plot == 1) {
      goto statement_1355;
    }
    if (llbuff == -3333) {
      goto statement_1342;
    }
    if (nenerg == 49) {
      cmn.io.close(lunit1)
        .status("SAVE");
    }
    if (nenerg != 49) {
      cmn.io.close(lunit1)
        .status("DELETE");
    }
    cmn.io.close(lunit2);
    cmn.io.close(lunit3);
    if (icat == 0) {
      goto statement_120;
    }
    if (icat > 2) {
      goto statement_120;
    }
    //cmn.io.close(lunit4) // no use of .pl4
    //  .status("SAVE");
    //goto statement_140;
  statement_120:
    cmn.io.close(lunit4)
      .status("DELETE");
  statement_140:
    cmn.io.close(cmn.lunit9);
    cmn.io.close(lunt10);
    cmn.io.close(lunt11);
    cmn.io.close(lunt12);
    cmn.io.close(lunt13);
    cmn.io.close(lunt14);
    cmn.io.close(lunt15);
  statement_1342:
  {
    cmn.io.open(lunit1, fem::file_not_specified)
      .form("FORMATTED")
      .status("SCRATCH");
    cmn.io.open(lunit2, fem::file_not_specified)
      .form("FORMATTED")
      .status("SCRATCH");
    cmn.io.open(lunit3, fem::file_not_specified)
      .form("UNFORMATTED")
      .status("SCRATCH");
    //C               UNIT 8 IS CALCOMP PLOT FILE (UNUSED WITH OUR VAX-VERSATEM24. 367
    //C               CONNECTION )                                            M24. 368
    cmn.io.open(lunt10, fem::file_not_specified)
      .form("UNFORMATTED")
      .status("SCRATCH");
    cmn.io.open(lunt11, fem::file_not_specified)
      .form("UNFORMATTED")
      .status("SCRATCH");
    cmn.io.open(lunt12, fem::file_not_specified)
      .form("UNFORMATTED")
      .status("SCRATCH");
    cmn.io.open(lunt13, fem::file_not_specified)
      .form("UNFORMATTED")
      .status("SCRATCH");
    cmn.io.open(lunt14, fem::file_not_specified)
      .form("UNFORMATTED")
      .status("SCRATCH");
    cmn.io.open(lunt15, fem::file_not_specified)
      .form("UNFORMATTED")
      .status("SCRATCH");
  }
  statement_1355:
    if (llbuff != -3333) {
      goto statement_1359;
    }
    settym();
    iprsov(38) = 0;
    llbuff = 1025;
    if (ltacst >= 3000) {
      goto statement_1359;
    }
    //C     VAX LINK-EDITS ACCORDING TO LONGEST COMMON BLOCK, NOT             M31. 346
    //C     ACCORDING TO 1ST APPEARANCE (SIZE OF VARDIM OUTPUT):              M31. 347
    ltlabl += 2 * (3000 - ltacst);
    ltacst = 3000;
  statement_1359:
    cmn.statfr = 60.f;
    cmn.kburro = 1;
    cmn.pekexp = 43;
    cmn.szplt = 10.f;
    cmn.szbed = 72.f;
    cmn.epsuba = 1.e-16;
    epomeg = 1.e-15;
    cmn.epdgel = 1.e-16;
    iprsov(37) = 10;
    cmn.lnpin = 6;
    cmn.nsmth = 50;
    date44(cmn, date1(1));
    time44(cmn, tclock(1));
    if (noutpr == 0) {
      write(lunit6, "(' ELECTROMAGNETIC TRANSIENTS PROGRAM (EMTP)')");
      //write(lunit6,
      //  "(' ELECTROMAGNETIC TRANSIENTS PROGRAM (EMTP),',"
      //  "' DIGITAL (DEC) VAX-11/780 TRANSLATION AS',"
      //  "' USED BY BPA IN PORTLAND, OREGON  97208;','  USA.')");
    }
  //  read(date1(1), format_3641), col(25), col(6), col(7);
  //  if (col(25) == "0") {
  //    goto statement_3642;
  //  }
  //  if (col(6) == "0") {
  //    col(6) = lettra;
  //  }
  //  if (col(6) == "1") {
  //    col(6) = lettrb;
  //  }
  //  if (col(6) == "2") {
  //    col(6) = lettrc;
  //  }
  //statement_3642:
  //  read(date1(2), format_3641), col(8);
  //  {
  //    //read_loop rloop(tclock(1), "(2a1,1x,a1)"); //"(2a1,1x,a1,4x,a1,1x,2a1)");
  //    //FEM_DO_SAFE(j, 9, 14) {
  //    //  rloop, col(j);
  //    //}
  //    j = 9;
  //    for (char c : { '1','2','3','4','5','6' })
  //      col(j++)[0] = c;      
  //  }
  //  {
  //    write_loop wloop(ansi32, "(18a1,14x)");
  //    FEM_DO_SAFE(j, 1, 18) {
  //      wloop, col(j);
  //    }
  //  }
  //  if (cmn.iprsup >= 1) {
  //    write(lunit6, "(/,' IN  #SYSDEP# ,   ANSI32 =',a32)"), ansi32;
  //  }
    //auto fileName = ansi32.std_str();
    //trim_str(fileName);
    //if (std::filesystem::exists(fileName))
    //  std::remove(fileName.c_str());
    //cmn.io.open(lunit4, ansi32)
    //  .form("UNFORMATTED")
    //  .status("NEW");

    cmn.io.open(lunit4, fem::file_not_specified)
      .form("UNFORMATTED")
      .status("SCRATCH");

    blank = busnm1;
    cmn.trash = busnm2;
    cmn.terra = busnm3;
    cmn.csepar = text1;
    cmn.chcont = text2;
    cmn.tenm3 = 1.e-3;
    cmn.unity = 1.e0;
    cmn.onehaf = 0.5e0;
    cmn.intinf = 10000000;
    nbyte(1) = 2;
    nbyte(2) = 2;
    //C     ZNVREF = 1.E-6  ! 32-BIT "COMPLEX" IN "CABLE CONSTANTS"           M35. 624
    //C     FOLLOWING ZERO DEFINITION IS REDUNDANT.                           M32. 809
    //C USE "= 1" IF SIMPLE LOGIC IS DESIRED
    ktrlsw(6) = 0;
    nbyte(3) = 2;
    cmn.fltinf = 1.e+20;
    cmn.flzero = 1.e-12;
    cmn.epsiln = 1.e-8;
    //cmn.twopi = 6.28318530717958647692e+00;
    cmn.userid = blank;
    if (noutpr == 0) {
      {
        write(lunit6, "(1x, a)"), getCurrentDateTime().c_str();
        //write_loop wloop(cmn, lunit6,
        //  "(' DATE (MM/DD/YY) AND TIME OF DAY (HH.MM.SS.)=',1x,2a4,2x,2a4,11x,"
        //  "'NAME OF VAX/VMS PLOT DATA',' FILE (IF ANY) =',13a1)");
        //wloop, date1, tclock;
        //FEM_DO_SAFE(j, 6, 18) {
        //  wloop, col(j);
        //}
      }
    }
    //C IF NOT INTERACTIVE EMTP USAGE,
    //C USE "PLTFIL" FOR REAL*4 PLOT FILE ON DISK
    if (m4plot != 1) {
      m4plot = 2;
    }
    //C INTERACTIVE OR NOT USES "NEXTCARD", NOT 5
    // cmn.lunit5 = -5;
    return;
    // UNHANDLED: ENTRY nextcard
  statement_nextcard:
    //C     THIS ENTRY IS USED ONLY FOR INTERACTIVE EMTP.  IT GETS            M35. 628
    //C     NEXT CARD IMAGE FROM MEMORY RATHER THAN UNIT 5.                   M29.1166
    //C NEXT DATA CARD IS RIGHT AFTER LAST
    n7 = cmn.numdcd + 1;
    //C JUMP AROUND DIAGNOSTIC
  statement_1472:
    if (cmn.iprspy < 5) {
      goto statement_1486;
    }
    write(cmn.munit6, "(' IN \"NEXTCARD\":',i5,1x,a80)"), n7, file6(n7);
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    //C AT LEAST 1 CARD REMAINS
  statement_1486:
    if (n7 <= numcrd) {
      goto statement_1488;
    }
    write(lunit6,
      "('   ****  ****   DATA CRISIS.   LAST',' CARD HAS BEEN READ. NUMCRD =',"
      "i6,/,'                USE \"DATA\" COMMAND OF',"
      "' SPY TO READ IN NEXT BLOCK OF DATA.')"),
      numcrd;
    //C SET KILL, THEN EXIT
    if (m4plot != 1) {
      goto statement_9000;
    }
    //C ALLOW USER TO CHANGE DATA CARD STORAGE
    emtspy(cmn);
    //C LOOP BACK FOR ANOTHER TRY AT READING
    goto statement_1472;
  statement_1488:
    {
      read_loop rloop(file6(n7), "(10a8)");
      FEM_DO_SAFE(j, 1, 10) {
        rloop, abuff(j);
      }
    }
    //C EXIT MODULE WITH NEW CARD IMAGE IN ABUFF
    goto statement_9200;
    //C POSITIVE KILL IS EOF FLAG IN "CIMAGE"
  statement_9000:
    cmn.kill = 7654;
  statement_9200:;

  }

  struct swmodf_save
  {
    fem::str<8> text14;
    fem::str<8> text15;

    swmodf_save() :
      text14(fem::char0),
      text15(fem::char0)
    {}
  };

  void swmodf(
      common& cmn)
  {
    FEM_CMN_SVE(swmodf);
    common_read read(cmn);
    common_write write(cmn);
    fem::str<8>& bus1 = cmn.bus1;
    fem::str<8>& bus2 = cmn.bus2;
    fem::str<8>& bus4 = cmn.bus4;
    const auto& abuff = cmn.abuff;
    double& ck1 = cmn.ck1;
    int& it2 = cmn.it2;
    int& noutpr = cmn.noutpr;
    int& iprsup = cmn.iprsup;
    const auto& kswtyp = cmn.kswtyp;
    const auto& kmswit = cmn.kmswit;
    const auto& bus = cmn.bus;
    auto& topen = cmn.topen;
    auto& crit = cmn.crit;
    auto& tclose = cmn.tclose;
    auto& adelay = cmn.adelay;
    //
    fem::str<8>& text14 = sve.text14;
    if (is_called_first_time) {
      text14 = "ING   ";
      sve.text15 = "CLOSED";
    }
    auto& lunit6 = cmn.lunit6;
    auto& kunit6 = cmn.lunit6;
    double gus3 = fem::double0;
    double gus4 = fem::double0;
    double a = fem::double0;
    int ijk = fem::int0;
    int jdu = fem::int0;
    int j = fem::int0;
    int msw = fem::int0;
    int k = fem::int0;
    int m = fem::int0;
    //C     CALLED ONLY BY OVER1 FOR START AGAIN USAGE                        M37.1133
    if (iprsup >= 1) {
      write(lunit6, "(' BEGIN MODULE \"SWMODF\".')");
    }
    read(abuff, "(i2,2a6,4e10.0,i6,a4,2a6,2x,2i1)"), it2, bus1,
      bus2, gus3, gus4, ck1, a, ijk, bus4, cmn.bus5, cmn.bus6, jdu, j;
    FEM_DO_SAFE(msw, 1, cmn.kswtch) {
      k = kmswit(msw);
      if (bus(k) != bus1) {
        goto statement_3535;
      }
      m = kmswit(msw + cmn.lswtch);
      if (bus(m) == bus2) {
        goto statement_3510;
      }
    statement_3535:;
    }
    write(lunit6, "(' NO SUCH SWITCH, THE CARD WILL BE DISCARDED')");
    goto statement_209;
  statement_3510:
    if (it2 != 0 || kswtyp(msw) != 0) {
      goto statement_209;
    }
    if (bus4 != text14) {
      goto statement_7218;
    }
    if (noutpr == 0) {
      write(kunit6, "('+PERMANENTLY-CLOSED SWITCH USED FOR METERING.')");
    }
    gus3 = -1.0f;
    gus4 = cmn.fltinf;
    goto statement_216;
  statement_7218:
    if (noutpr == 0) {
      write(kunit6, "('+SWITCH.',2x,4e10.2)"), gus3, gus4, ck1, a;
    }
    if (a == 0.0f) {
      goto statement_216;
    }
    if (gus4 != 0.0f || ijk < 0) {
      adelay(msw) = std::abs(gus4);
    }
    gus4 = std::abs(a);
    if (gus3 >= 0.f) {
      goto statement_216;
    }
    gus3 = 0.f;
    if (iprsup >= 1) {
      write(lunit6, "(16x,'TCLOSE CHANGED TO ZERO')");
    }
  statement_216:
    if (gus3 != 0.0f || ijk < 0) {
      tclose(msw) = gus3;
    }
    if (gus4 != 0.0f || ijk < 0) {
      topen(msw) = gus4;
    }
    if (ck1 != 0.0f || ijk < 0) {
      crit(msw) = ck1;
    }
  statement_209:
    if (iprsup >= 1) {
      write(lunit6, "('  EXIT  MODULE \"SWMODF.\" ')");
    }
  }


struct over1_save
{
  int ll1;
  int ll11;
  int ll20;
  int ll24;
  int ll25;
  int ll30;
  int ll40;
  int ll6;
  int ll60;
  int ll64;
  int ll8;
  int ll80;
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;

  over1_save() :
    ll1(fem::int0),
    ll11(fem::int0),
    ll20(fem::int0),
    ll24(fem::int0),
    ll25(fem::int0),
    ll30(fem::int0),
    ll40(fem::int0),
    ll6(fem::int0),
    ll60(fem::int0),
    ll64(fem::int0),
    ll8(fem::int0),
    ll80(fem::int0),
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0)
  {}
};

// INPUT OF MISCELLANEOUS DATA CARDS
void over1(common& cmn)
{
  FEM_CMN_SVE(over1);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& blank = cmn.blank;
  auto& texcol = cmn.texcol;
  const auto& date1  = cmn.date1;
  const auto& tclock = cmn.tclock;
  const auto& abuff = cmn.abuff;
  double& deltat = cmn.deltat;
  double& delta2 = cmn.delta2;
  double& epsiln = cmn.epsiln;
  double& xunits = cmn.xunits;
  double& aincr = cmn.aincr;
  double& xmaxmx = cmn.xmaxmx;
  auto& znolim = cmn.znolim;
  double& t = cmn.t;
  double& tolmat = cmn.tolmat;
  auto& twopi = cmn.twopi;
  double& tmax = cmn.tmax;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  double& sigmax = cmn.sigmax;
  auto& begmax = cmn.begmax;
  double& tenm3 = cmn.tenm3;
  auto& peaknd = cmn.peaknd;
  double& fltinf = cmn.fltinf;
  double& degmin = cmn.degmin;
  double& degmax = cmn.degmax;
  double& statfr = cmn.statfr;
  auto& voltbc = cmn.voltbc;
  auto& flstat = cmn.flstat;
  //auto& moncar = cmn.moncar;
  auto& lunit1 = cmn.lunit1;
  auto& lunit2 = cmn.lunit2;
  auto& lunit3 = cmn.lunit3;
  auto& lunit4 = cmn.lunit4;
  auto& lunit5 = cmn.lunit5;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& kprchg = cmn.kprchg;
  auto& multpr = cmn.multpr;
  auto& ipntv = cmn.ipntv;
  auto& lstat = cmn.lstat;
  auto& nbyte = cmn.nbyte;
  auto& iprsov= cmn.iprsov;
  int& iout = cmn.iout;
  int& ldata = cmn.ldata;
  int& lbrnch = cmn.lbrnch;
  int& lexct = cmn.lexct;
  int& lbus = cmn.lbus;
  int& lymat = cmn.lymat;
  int& lswtch = cmn.lswtch;
  int& lnonl = cmn.lnonl;
  int& lchar = cmn.lchar;
  int& lpast = cmn.lpast;
  int& lsize7 = cmn.lsize7;
  int& iplot = cmn.iplot;
  int& lcomp = cmn.lcomp;
  int& ifdep = cmn.ifdep;
  int& ltails = cmn.ltails;
  int& lfdep = cmn.lfdep;
  int& lwt = cmn.lwt;
  int& lsiz12 = cmn.lsiz12;
  int& lsmout = cmn.lsmout;
  int& limass = cmn.limass;
  auto& ktrlsw = cmn.ktrlsw;
  int& ntcsex = cmn.ntcsex;
  int& nstacs = cmn.nstacs;
  int& lastov = cmn.lastov;
  int& ltacst = cmn.ltacst;
  int& lhist = cmn.lhist;
  int& noutpr = cmn.noutpr;
  int& jflsos = cmn.jflsos;
  int& lspcum = cmn.lspcum;
  int& ialter = cmn.ialter;
  int& ktref = cmn.ktref;
  int& memsav = cmn.memsav;
  int& lsiz23 = cmn.lsiz23;
  int& lsiz26 = cmn.lsiz26;
  int& lsiz27 = cmn.lsiz27;
  int& lsiz28 = cmn.lsiz28;
  int& ltlabl = cmn.ltlabl;
  int& idoubl = cmn.idoubl;
  int& ipun = cmn.ipun;
  int& lfsem = cmn.lfsem;
  int& lfd = cmn.lfd;
  int& isplot = cmn.isplot;
  int& maxout = cmn.maxout;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& intinf = cmn.intinf;
  int& lsyn = cmn.lsyn;
  auto& maxpe = cmn.maxpe;
  int& kssout = cmn.kssout;
  auto& loopss = cmn.loopss;
  int& limstp = cmn.limstp;
  int& indstp = cmn.indstp;
  int& icat = cmn.icat;
  int& numnvo = cmn.numnvo;
  int& nenerg = cmn.nenerg;
  auto& ibsout = cmn.ibsout;
  auto& bvalue = cmn.bvalue;
  auto& topen = cmn.topen;
  auto& isourc = cmn.isourc;
  auto& length = cmn.length;
  auto& texvec = cmn.texvec;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  auto& kodebr = cmn.kodebr;
  auto& indhst = cmn.indhst;
  auto& kodsem = cmn.kodsem;
  auto& tclose = cmn.tclose;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;

  auto& bus = cmn.bus;
  auto& busum = cmn.busum;
  int& n1 = cmn.n1;
  int& n2 = cmn.n2;
  int& n3 = cmn.n3;
  int& n13 = cmn.n13;
  int& ida = cmn.ida;
  int& ifkc = cmn.ifkc;
  auto& locker = cmn.locker;
  //
  int& ll1 = sve.ll1;
  int& ll11 = sve.ll11;
  int& ll20 = sve.ll20;
  int& ll24 = sve.ll24;
  int& ll25 = sve.ll25;
  int& ll30 = sve.ll30;
  int& ll6 = sve.ll6;
  int& ll60 = sve.ll60;
  int& ll64 = sve.ll64;
  int& ll8 = sve.ll8;
  int& ll80 = sve.ll80;
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  if (is_called_first_time) {
    text2 = "NAME  ";
    text6 = "COPY  ";
    text1 = "TACS O";
    text3 = "TACS H";
    text4 = "TACS S";
    text5 = "4     ";
    text6 = "TACS  ";
    ll1 = 1;
    ll6 = 6;
    ll8 = 8;
    ll11 = 11;
    ll20 = 20;
    ll24 = 24;
    ll25 = 25;
    ll30 = 30;
    sve.ll40 = 40;
    ll60 = 60;
    ll64 = 64;
    ll80 = 80;
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  arr_1d<8, int> lstacs(fem::fill0);
  int j = fem::int0;
  double d13 = fem::double0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double znvref = fem::double0;
  int iswent = fem::int0;
  int iadqq = fem::int0;
  int nk = fem::int0;
  int ngroup = fem::int0;
  int nturn = fem::int0;
  int nfdbr = fem::int0;
  int nfdph = fem::int0;
  int nfdhst = fem::int0;
  int nfdpol = fem::int0;
  int ntlin = fem::int0;
  int lu2 = fem::int0;
  int lu6 = fem::int0;
  int ip = fem::int0;
  int iy = fem::int0;
  int i = fem::int0;
  int n9 = fem::int0;
  fem::str<80> disk_file = fem::char0;
  int n7 = fem::int0;
  int lunt77 = fem::int0;
  arr_1d<2, fem::str<8> > datexx(fem::fill0);
  arr_1d<2, fem::str<8> > tcloxx(fem::fill0);
  int numnam = fem::int0;
  int numbco = fem::int0;
  int numbrn = fem::int0;
  int n8 = fem::int0;
  int num888 = fem::int0;
  int n18 = fem::int0;
  int k = fem::int0;
  int n19 = fem::int0;
  int n18l1 = fem::int0;
  int n19l2 = fem::int0;
  int ijk = fem::int0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  double d3 = fem::double0;
  double ddd = fem::double0;
  fem::str<132> ansi132 = fem::char0;
  double d4 = fem::double0;
  double d12 = fem::double0;
  int n23 = fem::int0;
  int kswpe4 = fem::int0;
  int n12 = fem::int0;
  int n15 = fem::int0;
  int n14 = fem::int0;
  arr_1d<14, fem::str<8> > aupper(fem::fill0);
  int niunrs = fem::int0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  static const char* format_1984 = "(18x,i2)";
  static const char* format_3415 = "(10e8.0)";
  static const char* format_5 = "(10i8)";
  static const char* format_83049 =
    "(' --------------------------------------------------','+',"
    "'----------------------------------------',"
    "'----------------------------------------')";
  //C      %INCLUDE  '//c/tsu/cables.INS.FTN'                               M43.   5
  //C     TO AVOID "INSERT DECK TACSAR" HERE, USE SMALL PART OF IT:         M31. 190

  //C!REAL*8         AUPPER, TEXT1, TEXT2, TEXT6, DATEXX(2)
  //C!REAL*8         TEXT3,  TEXT4, TEXT5, TEXT9, TCLOXX(2)
  //C     DEFAULT LIST SIZES FOR TACS PROPORTIONING OF EMTP LIST 19.        M22. 943
  auto& kbase = cmn.moncar(2);
  auto& idist = cmn.moncar(5);

  auto& itest = cmn.moncar(6);
  auto& jseedr = cmn.moncar(8);
  auto& isw = cmn.moncar(4);
  auto& mtape = cmn.moncar(10);

  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER1.\"')");
  }
  lstacs(1) = 20;
  lstacs(2) = 90;
  lstacs(3) = 100;
  lstacs(4) = 20;
  lstacs(5) = 30;
  lstacs(6) = 250;
  lstacs(7) = 350;
  lstacs(8) = 60;
  cmn.pu = fltinf;
  move0(ktrlsw, ll6);
  move0(ipntv, ll11);
  move0(loopss, ll11);
  cmn.moncar(7) = 0;
  iprsov(39) = 0;
  busum(1) = text2;
  nright = 0;
  cmn.iofgnd = 0;
  cmn.moldat = 0;
  cmn.istep = 0;
  cmn.moncar(9) = 0;
  cmn.tenerg = 1.e+20f;
  cmn.branch = text2;
  cmn.copy = text6;
  ialter = 0;
  cmn.isprin = 0;
  isplot = 0;
  indstp = 1;
  noutpr = 0;

  cmn.speedl = 2.997925e8;
  peaknd(1) = 0.0f;
  cmn.kburro = 0;
  //C     ASSIGN DEFAULT RELATIVE PRECISION FOR 6 EMTP VARIABLE TYPES.      M35. 465
  //C        1 --- ALPHANUMERIC              2 --- COMPLEX                  M22.1190
  //C        3 --- FLOATING-POINT NUMERIC    4 --- INTEGER NUMERIC          M22.1191
  //C        5 --- 3 OF 'SUBR31'             6 --- 4 OF 'SUBR31'            M22.1192
  //C     SETTING ALL EQUAL TO UNITY MEANS THAT ALL HAVE EQUAL LENGTH.      M22.1193
  FEM_DO_SAFE(j, 1, 6) {
    nbyte(j) = 1;
  }
  dimens(lstat(1), nchain, bus1, bus2);
  lbus = lstat(1);
  lbrnch = lstat(2);
  ldata = lstat(3);
  lexct = lstat(4);
  lymat = lstat(5);
  lswtch = lstat(6);
  lsize7 = lstat(7);
  lpast = lstat(8);
  lnonl = lstat(9);
  lchar = lstat(10);
  lsmout = lstat(11);
  lsiz12 = lstat(12);
  lfdep = lstat(13);
  lwt = lstat(14);
  ltails = lstat(15);
  limass = lstat(16);
  lsyn = lstat(17);
  maxpe = lstat(18);
  ltacst = lstat(19);
  lfsem = lstat(20);
  lfd = lstat(21);
  lhist = lstat(22);
  lsiz23 = lstat(23);
  lcomp = lstat(24);
  lspcum = lstat(25);
  lsiz26 = lstat(26);
  lsiz27 = lstat(27);
  lsiz28 = lstat(28);
  //C     ASSIGN  'N1'  EQUAL TO THE NUMBER OF EMTP LISTS OF VARIABLE       M22.1220
  //C     DIMENSIONING (OF THE SOLUTION OVERLAYS).                          M22.1221
  n1 = 28;
  ltlabl = lstat(n1 + 1);
  locker(1) = bus1;
  locker(2) = bus2;
  //C      write (*,*) ' Save  LOCKER =',  LOCKER                           M42.1055
  d13 = ltacst;
  d13 = d13 / 1600.f;
  FEM_DO_SAFE(j, 1, 8) {
    lstacs(j) = lstacs(j) * d13;
  }
  n1 = -9999;
  copyi(n1, lstat(1), ll60);
  sysdep(cmn);
  move0(flstat, ll20);
  runtym(d1, d2);
  flstat(1) = flstat(1) - d1;
  flstat(2) = flstat(2) - d2;
  cmn.tenm6 = fem::pow2(tenm3);
  cmn.maxzno = 50;
  cmn.epszno = epsiln;
  cmn.epwarn = tenm3;
  cmn.epstop = 0.1f;
  znolim(1) = 1.0f;
  znolim(2) = 1.5f;
  kbase = 0;
  isw = 0;
  kprchg(1) = -7777;
  jflsos = 0;
  cmn.io.rewind(lunit1);
  cmn.io.rewind(lunit3);
  cmn.io.rewind(lunit4);
  cmn.moncar(1) = 1;
  mtape = lunit5;
  ifdep = 0;
  ntcsex = 0;
  nstacs = 0;
  cmn.kanal = 0;
  //C     INITIALIZE "KPARTB" WITH NONZERO VALUE SO LATER MINUS             M32. 658
  //C     SIGN CAN BE APPLIED AS FLAG OF "RENUMBER BYPASS" USAGE:           M32. 659
  cmn.kpartb = 1000;
  //C     "SYSDEP" WILL REDEFINE IF LOW-PREC. COMPLEX ("CABLE CONSTANTS"):  M35. 466
  znvref = 0.0f;
  cmn.fmaxfs = 0.0f;
  begmax(1) = 0.0f;
  begmax(2) = 0.0f;
  begmax(3) = fltinf;
  ktref = 0;
  cmn.ncomp = 0;
  cmn.numsm = 0;
  cmn.numum = 0;
  cmn.numout = 0;
  kill = 0;
  cmn.num99 = 0;
  cmn.modout = 0;
  cmn.inecho = 0;
  bus(1) = blank;
  cmn.iaverg = 0;
  move0(isourc, lswtch);
  move0(kodebr, lbrnch);
  move0(kodsem, lbrnch);
  move0(length, lbrnch);
  move0(indhst, lbrnch);
  move0(bvalue, lsiz12);
  iswent = 1;
  cmn.omega = 0.0f;
  degmin = 0.0f;
  degmax = 0.0f;
  cmn.sglfir = twopi;
  cmn.jst = 0;
  cmn.jst1 = 1;
  cmn.ifdep2 = 1;
  cmn.iadd = 0;
  cmn.ifsem = 0;
  //C                                                                       M43.   9
  cmn.idm = 1;
  cmn.idq = 1;
  cmn.idu = 1;
  cmn.idt = 1;
  iadqq = 1;
  cmn.iq = 0;
  ida = 0;
  cmn.idy = 0;
  ifkc = 0;
  nk = 0;
  ngroup = 0;
  nturn = 0;
  nfdbr = 27;
  nfdph = 9;
  nfdhst = 5400;
  //C      NFDPOL = 25      ! Assign maximum order of rational approximationM43.  25
  nfdpol = 30;
  ntlin = 0;
  lu2 = 69;
  lu6 = lunit6;
  //C      IF ( ABUFF(1:5) .NE. 'FILE:' )  GO TO 5223                       M43.  30
  //C      write (*,*) ' Ready to open  ABUFF(6:40) =',  ABUFF(6:40)        M43.  31
  //C      OPEN ( UNIT=LU2,  STATUS='OLD',  FILE=ABUFF(6:40) )              M43.  32
  //C      write (*,*) ' Successful open ABUFF(6:40) =', ABUFF(6:40)        M43.  33
  //C     CALL CIMAGE  !Erase spcl request of cables by rding 1st real brnchM43.  34
  //C                                                                       M43.  35
  cmn.ifx = 0;
  ip = 2;
  iy = 2;
  icat = 0;
  if (noutpr != 0) {
    goto statement_15;
  }
  if (cmn.kol132 == 132) {
    goto statement_6452;
  }
  write(lunit6,
    "(' *********  BEGIN \"M40.\" EMTP SOLUTION.','   SIZE /LABEL/ =',i7,"
    "'  INTEGER WORDS.',/,' LIST LIMITS  1-10 :',10i6,/,"
    "' LIST LIMITS 11-20 :',10i6,/,' LIST LIMITS 21-END:',10i6)"),
    ltlabl, lbus, lbrnch, ldata, lexct, lymat, lswtch, lsize7, lpast,
    lnonl, lchar, lsmout, lsiz12, lfdep, lwt, ltails, limass, lsyn,
    maxpe, ltacst, lfsem, lfd, lhist, lsiz23, lcomp, lspcum, lsiz26,
    lsiz27, lsiz28;
  goto statement_15;
statement_6452:
  write(lunit6,
    "(' ASSOCIATED USER DOCUMENTATION IS THE 864-PAGE',"
    "' EMTP RULE BOOK DATED  JUNE, 1984.',3x,)");
    //"'VERSION M43.   VARDIM TIME/DATE =',2i7)"),
    //locker;
  write(lunit6,
    "(' INDEPENDENT LIST LIMITS FOLLOW. TOTAL LENGTH OF /LABEL/ EQUALS ',"
    "i8,' INTEGER WORDS.',3x,6i6,/(1x,21i6,i5))"),
    ltlabl, lbus, lbrnch, ldata, lexct, lymat, lswtch, lsize7, lpast,
    lnonl, lchar, lsmout, lsiz12, lfdep, lwt, ltails, limass, lsyn,
    maxpe, ltacst, lfsem, lfd, lhist, lsiz23, lcomp, lspcum, lsiz26,
    lsiz27, lsiz28;
  write(lunit6, format_83049);
  {
    write_loop wloop(cmn, lunit6,
      "(' DESCRIPTIVE INTERPRETATION OF NEW-CASE INPUT DATA 1 INPUT DATA CARD "
      "IMAGES PRINTED BELOW, ALL 80 COLUMNS, CHARACTER BY CHARACTER.',/,51x,"
      "'0',8(9x,i1))");
    FEM_DO_SAFE(i, 1, 8) {
      wloop, i;
    }
  }
  j = 0;
  {
    write_loop wloop(cmn, lunit6, "(51x,'0',8(9x,i1))");
    FEM_DO_SAFE(i, 1, 8) {
      wloop, j;
    }
  }
  write(lunit6, format_83049);
  //C     BEGIN LOOP OVER ALL INPUT DATA CARDS READ BY "OVER1" :            M32. 692
  //C     READ INPUT CARD USING CIMAGE.                                     M42.1077
statement_15:
  cimage(cmn);
  if (kill > 0) {
    goto statement_9200;
  }
  nright = -2;
  n9 = kolbeg;
  kolbeg = 1;
  read(abuff, "(80a1)"), texcol;
  freone(cmn, d1);
statement_3247:
  nright = 0;
  if (n9 == -intinf) {
    kolbeg = n9;
  }
  if (nfrfld > 0) {
    goto statement_3280;
  }
  if (noutpr == 0) {
    write(kunit6, "('+BLANK TERMINATION-OF-RUN CARD.')");
  }
  interp();
  cmn.ivolt = 7777;
statement_3273:
  kill = 9999;
  nchain = 31;
  goto statement_9800;
statement_3280:
  reques(cmn);
  i = lstat(18);
  //C     REQUEST WORD NUMBER  0  IMPLIES MISCELLANEOUS DATA CARDS:         M28. 801
  if (i == 0) {
    goto statement_2843;
  }
  //C     NEXT COME EXCEPTIONS HANDLED OUTSIDE SUBROUTINE:                  M28. 803
  if (i == 15) {
    goto statement_8015;
  }
  if (i == 32) {
    goto statement_8032;
  }
  if (i == 33) {
    goto statement_8033;
  }
  //C     NEXT COME EXCEPTIONAL TERMINATIONS (SPECIAL JUMPS):               M28. 807
  if (i == 11) {
    goto statement_3273;
  }
  if (i == 28) {
    goto statement_3247;
  }
  if (i == 34) {
    goto statement_6523;
  }
  if (i == 38) {
    goto statement_15;
  }
  if (i == 40) {
    goto statement_4308;
  }
  //C     NEXT COME EXITS TO OTHER OVERLAYS:                                M28. 813
  if (kill > 0) {
    goto statement_9200;
  }
  if (nchain != 1) {
    goto statement_9800;
  }
  //C     CONTINUE IN LOOP OF REQUEST WORDS, IF NONE OF ABOVE.              M28. 816
  goto statement_15;
  //C     $$$$$    SPECIAL-REQUEST WORD NO. 15.   'START AGAIN'       $$$$$ M43.  37
statement_8015:
  ialter = lunit2;
  if (noutpr == 0) {
    write(kunit6, "('+CONTINUE PARTIALLY-COMPLETED DATA CASE.')");
  }
  if (texcol(13) != text5) {
    goto statement_2861;
  }
  read(abuff, "(a80)"), disk_file;
  FEM_DO_SAFE(j, 1, 2) {
    n7 = fem::index(disk_file, ",");
    disk_file(1, n7) = " ";
  }
  FEM_DO_SAFE(j, n7, 80) {
    if (disk_file(j, j) != " ") {
      goto statement_2849;
    }
  }
statement_2849:
  write(6, star), " Name of old PL4 file  DISK_FILE(J:80) =", disk_file(j, 80);
  lunt77 = 77;
  cmn.io.open(lunt77, disk_file(j, 80))
    .form("UNFORMATTED")
    .status("OLD");
  texcol(13) = blank;
  cmn.io.rewind(lunt77);
  read(lunt77, fem::unformatted), datexx, tcloxx, numnam, numnvo,
    numbco, numbrn;
  write(6, star), " 1st record.  NUMNAM, NUMNVO, NUMBCO, NUMBRN =",
    numnam, numnvo, numbco, numbrn;
  if (lbus + lsize7 >= numnam && lsiz12 >= numnvo && lbrnch >= numbrn) {
    goto statement_2859;
  }
  write(lunit6,
    "(' TEMPORARY ERROR STOP IN \"OVER1\".',"
    "'   PROGRAM DIMENSIONING IS INADEQUATE.','   NUMNAM, NUMNVO, NUMBRN =',"
    "3i8)"),
    numnam, numnvo, numbrn;
  stoptp(cmn);
statement_2859:
  cmn.io.rewind(lunt77);
  n8 = lbus;
  if (lbus >= numnam) {
    n8 = numnam - 1;
  }
  write(6, star), " New name logic.  n8, numnam, lbus =", n8, numnam, lbus;
  {
    read_loop rloop(cmn, lunt77, fem::unformatted);
    rloop, datexx, tcloxx, numnam, numnvo, numbco, numbrn;
    FEM_DO_SAFE(j, 1, n8) {
      rloop, bus(j);
    }
  }
  {
    write_loop wloop(cmn, 6, "(' BUS(1:N8) =',10a7)");
    FEM_DO_SAFE(j, 1, n8) {
      wloop, bus(j);
    }
  }
  cmn.io.rewind(lunt77);
  num888 = numnam - n8;
  write(6, star), " Ready for final, full read with  NUM888 =", num888;
  {
    read_loop rloop(cmn, lunt77, fem::unformatted);
    rloop, datexx, tcloxx, numnam, numnvo, numbco, numbrn;
    FEM_DO_SAFE(j, 1, n8) {
      rloop, bus(j);
    }
    FEM_DO_SAFE(j, 1, num888) {
      rloop, texvec(j);
    }
  }
  write(6, star), " After all names are read.  Next, IBSOUT.";
  if (numnvo > 0) {
    {
      read_loop rloop(cmn, lunt77, fem::unformatted);
      FEM_DO_SAFE(j, 1, numnvo) {
        rloop, ibsout(j);
      }
    }
  }
  write(6, star), " After IBSOUT.  Next, ....";
  if (numbrn > 0) {
    {
      read_loop rloop(cmn, lunt77, fem::unformatted);
      FEM_DO_SAFE(j, 1, numbrn) {
        rloop, kbus(j), mbus(j);
      }
    }
  }
  write(6, star), " After KBUS, MBUS.";
  {
    write_loop wloop(cmn, lunit4, fem::unformatted);
    wloop, date1, tclock, numnam, numnvo, numbco, numbrn;
    FEM_DO_SAFE(j, 1, n8) {
      wloop, bus(j);
    }
    FEM_DO_SAFE(j, 1, num888) {
      wloop, texvec(j);
    }
  }
  write(6, "(' over1, lunit4 date and time =',2a4,2x,2a4)"), date1, tclock;
  if (numnvo > 0) {
    {
      write_loop wloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(j, 1, numnvo) {
        wloop, ibsout(j);
      }
    }
  }
  if (numbrn > 0) {
    {
      write_loop wloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(j, 1, numbrn) {
        wloop, kbus(j), mbus(j);
      }
    }
  }
  n18 = numnvo + numbrn + 1;
  write(6, star), " Enter loop over numbers.  N18 =", n18;
  FEM_DO_SAFE(j, 1, 99999) {
    try {
      read_loop rloop(cmn, lunt77, fem::unformatted);
      FEM_DO_SAFE(k, 1, n18) {
        rloop, volti(k);
      }
    }
    catch (fem::read_end const&) {
      goto statement_6539;
    }
    if (iprsup == 7 || iprsup > 9) {
      write(6, star), " J, VOLTI(1) =", j, volti(1);
    }
    if (volti(1) == -9999.f) {
      goto statement_6539;
    }
    {
      write_loop wloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(k, 1, n18) {
        wloop, volti(k);
      }
    }
  }
statement_6539:
  write(6, star), " Done transferring LUNT77 to LUNIT4.  J =", j;
statement_2861:
  runtym(d1, d2);
  //C!N18 = LOCKER(1)
  //C!N19 = LOCKER(2)
  read(locker(1), star), n18;
  read(locker(2), star), n19;
  pfatch(cmn);
  tables(cmn);
  write(6, star), " N18, N19, LOCKER(1), LOCKER(2) =", n18, n19,
    locker(1), locker(2);
  flstat(1) = -d1;
  flstat(2) = -d2;
  read(locker(1), star), n18l1;
  read(locker(2), star), n19l2;
  if (n18 == n18l1 && n19 == n19l2) {
    goto statement_2863;
  }
  kill = 201;
  lstat(19) = 2861;
  goto statement_9200;
statement_2863:
  //C     READ INPUT CARD USING CIMAGE.                                     M28. 827
statement_2868:
  cimage(cmn);
  read(abuff, "(54x,i6)"), ijk;
  if (ijk != 0) {
    goto statement_6161;
  }
  if (kolbeg > 0) {
    goto statement_2872;
  }
  read(abuff, "(i8,2e16.0)"), n3, d7, d8;
  goto statement_2875;
statement_2872:
  nfrfld = 1;
  freone(cmn, d3);
  n3 = d3;
  freone(cmn, d7);
  freone(cmn, d8);
  freone(cmn, ddd);
statement_2875:
  if (n3 == 9999) {
    goto statement_2879;
  }
  if (noutpr == 0) {
    write(kunit6, "('+ALTERED SWITCH.',i4,2e13.4)"), n3, d7, d8;
  }
  tclose(n3) = d7;
  if (d8 > 0.0f) {
    topen(n3) = d8;
  }
  goto statement_2868;
statement_6161:
  if (fem::iabs(ijk) == 1111) {
    goto statement_6363;
  }
  swmodf(cmn);
  goto statement_2868;
statement_6363:
  tacs1c(cmn);
  goto statement_2868;
statement_2879:
  if (noutpr == 0) {
    write(kunit6, "('+TERMINATOR FOR SWITCH CLOSING TIMES.')");
  }
  read(lunit2, fem::unformatted), locker;
  FEM_DO_SAFE(j, 1, 9999) {
    try {
      read(lunit2, fem::unformatted), ansi132;
    }
    catch (fem::read_end const&) {
      goto statement_2479;
    }
    write(lunit6, "(a132)"), ansi132;
  }
statement_2479:
  limstp = 0;
  indstp = 1;
  isplot = 0;
  flstat(14) = t;
  nchain = 1;
  lastov = 0;
  goto statement_15;
  //C     $$$$$  SPECIAL REQUEST-WORD NO. 32.  'ABSOLUTE TACS DIMENSIONS'  $M22.1469
statement_8032:
  if (noutpr == 0) {
    write(kunit6, "('+SET ABSOLUTE TACS LIST SIZE LIMITS.')");
  }
  //C     READ INPUT CARD USING CIMAGE                                      M22.1472
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_7030;
  }
  intchk(cmn, ll1, ll80, ll8);
  if (kill > 0) {
    goto statement_9200;
  }
  {
    read_loop rloop(abuff(1), format_5);
    FEM_DO_SAFE(i, 1, 8) {
      rloop, lstacs(i);
    }
  }
  goto statement_7050;
statement_7030:
  nfrfld = 10;
  frefld(cmn, voltbc(1));
  FEM_DO_SAFE(i, 1, 8) {
    lstacs(i) = voltbc(i);
  }
statement_7050:
  if (lstacs(1) < 5) {
    lstacs(1) = 5;
  }
  if (noutpr == 0) {
    write(kunit6, "('+1ST TACS DIMENSIONS CARD.    ',3i6)"), lstacs(1),
      lstacs(2), lstacs(3);
  }
  goto statement_15;
  //C     $$$$$  SPECIAL REQUEST-WORD NO. 33.  'RELATIVE TACS DIMENSIONS'  $M22.1499
statement_8033:
  if (noutpr == 0) {
    write(kunit6, "('+PROPORTIONAL ALLOCATION OF TOTAL TACS STORAGE.')");
  }
  //C     READ INPUT CARD USING CIMAGE                                      M22.1502
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_7120;
  }
  expchk(cmn, ll1, ll80, ll8);
  if (kill > 0) {
    goto statement_9200;
  }
  {
    read_loop rloop(abuff(1), format_3415);
    FEM_DO_SAFE(i, 1, 10) {
      rloop, voltbc(i);
    }
  }
  goto statement_7130;
statement_7120:
  nfrfld = 10;
  frefld(cmn, voltbc(1));
statement_7130:
  if (noutpr == 0) {
    write(kunit6, "('+RELATIVE LIST SIZES.  ',3e9.2)"), voltbc(1),
      voltbc(2), voltbc(3);
  }
  d1 = 0.0f;
  FEM_DO_SAFE(i, 1, 8) {
    d1 += voltbc(i);
  }
  d1 = ltacst * nbyte(3) / d1;
  lstacs(1) = voltbc(1) * d1 / (4 * nbyte(3) + 8 * nbyte(4));
  lstacs(2) = voltbc(2) * d1 / (2 * nbyte(3) + nbyte(4));
  lstacs(3) = voltbc(3) * d1 / (2 * nbyte(4));
  lstacs(4) = voltbc(4) * d1 / (5 * nbyte(3) + nbyte(4));
  lstacs(5) = voltbc(5) * d1 / (3 * nbyte(4));
  lstacs(6) = voltbc(6) * d1 / nbyte(4);
  lstacs(7) = voltbc(7) * d1 / nbyte(3);
  lstacs(8) = voltbc(8) * d1 / (6 * nbyte(3) + 2 * nbyte(4));
  goto statement_15;
  //C     BEGIN PROCESSING FLOATING POINT MISC. DATA CARD ....              M28. 866
statement_2843:
  if (noutpr != 0 && iprsup > 0) {
    noutpr = 0;
  }
  xopt = statfr;
  copt = statfr;
  kolbeg = n9;
  if (kolbeg > 0) {
    goto statement_4201;
  }
  expchk(cmn, ll1, ll80, ll8);
  if (kill > 0) {
    goto statement_9200;
  }
  read(abuff, format_3415), deltat, tmax, d1, d2, d3, tolmat, t;
  if (t == 0.0f) {
    t = 0.0f;
  }
  goto statement_4202;
statement_4201:
  nfrfld = 1;
  nright = 0;
  freone(cmn, deltat);
  freone(cmn, tmax);
  freone(cmn, d1);
  freone(cmn, d2);
  freone(cmn, d3);
  freone(cmn, tolmat);
  freone(cmn, t);
statement_4202:
  if (noutpr == 0) {
    write(kunit6, "('+MISC. DATA. ',3e12.3)"), deltat, tmax, d1;
  }
  if (cmn.iofbnd != 33666) {
    goto statement_4206;
  }
  nchain = 41;
  xopt = d1;
  goto statement_9800;
  //C     READ INPUT CARD USING CIMAGE.                                     M42.1094
statement_4206:
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_4207;
  }
  intchk(cmn, ll1, ll80, ll8);
  if (kill > 0) {
    goto statement_9200;
  }
  read(abuff, format_5), iout, iplot, idoubl, kssout, maxout, ipun,
    memsav, icat, n1, n2;
  icat = memsav = 0;  //w disable
  goto statement_4208;
statement_4207:
  nfrfld = 10;
  frefld(cmn, voltbc(1));
  iout = voltbc(1);
  iplot = voltbc(2);
  idoubl = voltbc(3);
  kssout = voltbc(4);
  maxout = voltbc(5);
  ipun = voltbc(6);
  memsav = voltbc(7);
  icat = voltbc(8);
  n1 = voltbc(9);
  n2 = voltbc(10);
statement_4208:
  nenerg = n1;
  if (iplot == 0) {
    iplot = 1;
  }
  if (cmn.m4plot == 1 && iplot == -1) {
    iplot = 1;
  }
  if (iplot == -1) {
    isplot = intinf;
  }
  if (noutpr == 0) {
    write(kunit6, "('+MISC. DATA. ',2i5,8i3)"), iout, iplot, idoubl,
      kssout, maxout, ipun, memsav, icat, n1, n2;
  }
  begmax(1) = maxout;
  maxout = 2;
  if (n2 == 0) {
    goto statement_6519;
  }
  copyi(n2, iprsov(1), ll30);
statement_6519:
  iprsup = iprsov(1);
  if (icat > 2) {
    icat = 0;
  }
  if (n1 == 0) {
    goto statement_600;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M42.1098
statement_6523:
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_623;
  }
  intchk(cmn, ll1, ll24, ll8);
  expchk(cmn, ll25, ll64, ll8);
  if (kill > 0) {
    goto statement_9200;
  }
  read(abuff, "(3i8,6f8.0,i8)"), isw, itest, idist, aincr, xmaxmx,
    degmin, degmax, d4, sigmax, jseedr;
  goto statement_624;
statement_623:
  nfrfld = 3;
  frefld(cmn, voltbc(1));
  isw = voltbc(1);
  itest = voltbc(2);
  idist = voltbc(3);
  nfrfld = 1;
  freone(cmn, aincr);
  freone(cmn, xmaxmx);
  freone(cmn, degmin);
  freone(cmn, degmax);
  freone(cmn, d4);
  freone(cmn, sigmax);
  frefld(cmn, voltbc(1));
  jseedr = voltbc(1);
statement_624:
  if (noutpr == 0) {
    write(kunit6, "('+STATISTICS DATA.',3i8,f9.4)"), isw, itest, idist, aincr;
  }
  if (xmaxmx == 0.0f) {
    xmaxmx = 2.0f;
  }
  if (aincr == 0.0f) {
    aincr = cmn.unity / 20.f;
  }
  if (d4 > 0.0f) {
    statfr = d4;
  }
  if (degmax == 0.0f) {
    degmax = 360.f;
  }
  if (sigmax == 0.0f) {
    sigmax = 4.0f;
  }
  if (jseedr > 0) {
    jseedr = intinf;
  }
  if (kbase != intinf) {
    kbase = 1;
  }
  begmax(1) = 1.0f;
  if (nenerg != intinf) {
    goto statement_600;
  }
  nchain = 29;
  goto statement_9800;
statement_600:
  if (d1 == 0.0f) {
    goto statement_6260;
  }
  if (d1 == xopt) {
    goto statement_6260;
  }
  if (noutpr == 0) {
    write(lunit6,
      "(' ----- WARNING.   NONZERO MISC. DATA',"
      "' PARAMETER \"XOPT\" DIFFERS FROM THE',' POWER FREQUENCY OF',f8.2,"
      "' .   THIS IS UNUSUAL.',/,7x,'A VALUE OF',e13.4,"
      "' WAS READ FROM COLUMNS 17-24 OF THE DATA CARD JUST READ.   EXECUTION W"
      "ILL CONTINUE USING',/,7x,"
      "'THIS VALUE, AS SUSPICIOUS AS IT SEEMS TO THE EMTP')"),
      xopt, d1;
  }
statement_6260:
  xopt = d1;
  if (d2 == 0.0f) {
    goto statement_6265;
  }
  if (d2 == copt) {
    goto statement_6265;
  }
  if (noutpr == 0) {
    write(lunit6,
      "(' ----- WARNING.   NONZERO MISC. DATA',"
      "' PARAMETER \"COPT\" DIFFERS FROM THE',' POWER FREQUENCY OF',f8.2,"
      "' .   THIS IS UNUSUAL.',/,7x,'A VALUE OF',e13.4,"
      "' WAS READ FROM COLUMNS 25-32 OF THE DATA CARD JUST READ.   EXECUTION W"
      "ILL CONTINUE USING',/,7x,"
      "'THIS VALUE, AS SUSPICIOUS AS IT SEEMS TO THE EMTP')"),
      copt, d2;
  }
statement_6265:
  copt = d2;
  if (d3 > 0.0f) {
    epsiln = d3;
  }
  if (tolmat <= 0.0f) {
    tolmat = epsiln;
  }
  tolmat = fem::pow2(tolmat);
  if (iplot == 0) {
    iplot = 1;
  }
  if (iplot < 0) {
    goto statement_6279;
  }
  if ((iplot / 2) * 2 == iplot) {
    write(lunit6, star), "    -----  WARNING!  Even  IPLOT =", iplot;
  }
statement_6279:
  if (iout == 0) {
    iout = 1;
  }
  if (tmax <= 0.0f && deltat <= 0.0f) {
    deltat = 1.0f;
  }
  if (deltat > 0.0f && t >= 0.0f) {
    goto statement_4215;
  }
  kill = 2;
  flstat(16) = deltat;
  lstat(19) = 4215;
  goto statement_9200;
statement_4215:
  d12 = tmax / deltat + 1.0f;
  d13 = intinf;
  if (d12 < d13) {
    goto statement_4223;
  }
  kill = 81;
  lstat(19) = 4215;
  flstat(15) = d12;
  flstat(16) = d13;
  goto statement_9200;
statement_4223:
  cmn.ioutin = iout;
  delta2 = deltat / 2.0f;
  cmn.dltinv = 1.0f / deltat;
  tmax = tmax - delta2;
  if (memsav == 1) {
    tmax += deltat;
  }
  i = 1;
  if (ipun < 0) {
    goto statement_4303;
  }
  if (kprchg(1) == -7777) {
    goto statement_4213;
  }
  goto statement_4312;
statement_4303:
  ipun = 0;
  //C     READ INPUT CARD USING CIMAGE.                                     M42.1127
statement_4308:
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_4217;
  }
  intchk(cmn, ll1, ll80, ll8);
  if (kill > 0) {
    goto statement_9200;
  }
  {
    read_loop rloop(abuff(1), "(10i8)");
    FEM_DO_SAFE(i, 1, 5) {
      rloop, kprchg(i), multpr(i);
    }
  }
  goto statement_4219;
statement_4217:
  nfrfld = 10;
  frefld(cmn, voltbc(1));
  j = 1;
  FEM_DO_SAFE(i, 1, 5) {
    kprchg(i) = voltbc(j);
    multpr(i) = voltbc(j + 1);
    j += 2;
  }
statement_4219:
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, "('+PRINTOUT :',6i6)");
      FEM_DO_SAFE(i, 1, 3) {
        wloop, kprchg(i), multpr(i);
      }
    }
  }
  FEM_DO_SAFE(i, 1, 5) {
    if (kprchg(i) == 0) {
      goto statement_4213;
    }
  }
  i = 6;
statement_4213:
  kprchg(i) = intinf;
  if (ktref != -7777) {
    goto statement_4312;
  }
  ktref = 0;
  goto statement_15;
statement_4312:
  if (iprsup >= 1) {
    write(lunit6,
      "(10x,'DELTAT',11x,'TMAX',11x,'XOPT',11x,'COPT',9x,'EPSILN',9x,'TOLMAT',"
      "/,1x,6e15.5,/,1x)"),
      deltat, tmax, xopt, copt, epsiln, tolmat;
  }
  if (iprsup <= 0) {
    goto statement_4266;
  }
  if (nenerg == 0) {
    goto statement_4266;
  }
  if (noutpr == 0) {
    write(lunit6,
      "(/,' STATISTICS PARAMETERS.     ISW   ITEST   IDIST',10x,'AINCR',9x,"
      "'XMAXMX',9x,'DEGMIN',9x,'DEGMAX',9x,'STATFR',/,23x,3i8,5e15.5)"),
      isw, itest, idist, aincr, xmaxmx, degmin, degmax, statfr;
  }
statement_4266:
  if (ifdep != -5555) {
    goto statement_4269;
  }
  ifdep = 0;
  goto statement_15;
statement_4269:
  xunits = 1000.f;
  if (xopt > 0.0f) {
    xunits = twopi * xopt;
  }
  cmn.ntot = 1;
  cmn.maxbus = 0;
  n23 = 0;
  namea6(cmn, blank, n23);
  cmn.icheck = 1;
  cmn.ibr = 0;
  cmn.ichar = 0;
  cmn.inonl = 0;
  cmn.kswtch = 0;
  cmn.numsub = 0;
  cmn.npower = 0;
  kswpe4 = 0;
  cmn.nv = 0;
  numnvo = 0;
  cmn.it = 1;
  n1 = 0;
  n12 = jflsos / 100;
  n15 = jflsos - 100 * n12;
  n13 = n15 / 10;
  n14 = n15 - 10 * n13;
  lstat(14) = n12;
  lstat(15) = n13;
  lstat(16) = n14;
  midov1(cmn);
  lstat(39) = 137;
  //C     READ INPUT CARD USING CIMAGE                                      M13. 301
statement_2691:
  cimage(cmn);
  {
    read_loop rloop(abuff(1), "(13a6,a2)");
    FEM_DO_SAFE(i, 1, 14) {
      rloop, aupper(i);
    }
  }
  if (aupper(1) == text1) {
    goto statement_2697;
  }
  if (aupper(1) == text3) {
    goto statement_2697;
  }
  if (aupper(1) == text4) {
    goto statement_2699;
  }
  if (aupper(1) != text6) {
    goto statement_7722;
  }
  write(kunit6, "(' Begin TACS. ==========================')");
  cmn.newtac = 1;
  ntcsex = 1;
  niunrs = 1;
  write(6, star), " Prepare to call  NTACS1  from over1.";
  //C!w      call ntacs1
  write(6, star), " Back from ntacs1, back in over1.";
  goto statement_4284;
statement_7722:
  goto statement_4281;
statement_2697:
  ntcsex = 1;
statement_2699:
  n1 = 1;
  if (noutpr != 0) {
    goto statement_2691;
  }
  if (ntcsex == 0) {
    goto statement_22699;
  }
  if (noutpr == 0) {
    write(kunit6, "('+TACS HYBRID SETUP.  TACS DATA CARDS FOLLOW. ')");
  }
  read(abuff, format_1984), lstat(52);
  goto statement_2691;
statement_22699:
  if (noutpr == 0) {
    write(kunit6, "('+TACS STAND-ALONE SETUP.  DATA CARDS FOLLOW. ')");
  }
  read(abuff, format_1984), lstat(52);
  goto statement_2691;
statement_4281:
  if (n1 == 0) {
    goto statement_4284;
  }
  move(lstacs(1), lstat(61), ll8);
  cmn.ktab = 1;
  tacs1(cmn);
  if (kill > 0) {
    goto statement_9200;
  }
  if (ntcsex + nstacs > 0) {
    goto statement_4276;
  }
  indstp = 1;
  limstp = kprchg(1);
  runtym(d1, d2);
  flstat(1) += d1;
  flstat(2) += d2;
  flstat(7) = flstat(7) - d1;
  flstat(8) = flstat(8) - d2;
  nchain = 12;
  goto statement_9800;
  //C     READ INPUT CARD USING CIMAGE                                      M13. 337
statement_4276:
  cimage(cmn);
statement_4284:
  nchain = 2;
  goto statement_9800;
statement_9200:
  nchain = 51;
  lstat(18) = 1;
statement_9800:
  lastov = 1;
  n5 = locint(ida);
  n6 = locint(ifkc);
  //C      write (*,*) ' End over1.  N5, N6, IDA, IFKC =',                  M43. 114
  //C     1                          N5, N6, IDA, IFKC                      M43. 115
  if (iprsup >= 1) {
    write(lunit6, "(' \"EXIT  MODULE OVER1.\" ')");
  }
} // over1




struct inlmfs_save
{
  int komlev;

  inlmfs_save() :
    komlev(fem::int0)
  {}
};

void inlmfs(
  common& cmn)
{
  FEM_CMN_SVE(inlmfs);
  common_read read(cmn);
  common_write write(cmn);
  auto& lunt13 = cmn.lunt13;
  int& numcrd = cmn.numcrd;
  int& iprspy = cmn.iprspy;
  int& limcrd = cmn.limcrd;
  bool& logvar = cmn.logvar;
  fem::str<1>& char1 = cmn.char1;
  fem::str<80>& buff77 = cmn.buff77;
  auto& file6 = cmn.file6;
  fem::str<80>& prom80 = cmn.prom80;
  const auto& digit = cmn.digit;
  fem::str<80>& answ80 = cmn.answ80;
  fem::str<132>& munit6 = cmn.munit6;
  //
  int& komlev = sve.komlev;
  if (is_called_first_time) {
    komlev = -1;
  }
  arr_1d<200, int> kard(fem::fill0);
  int n16 = fem::int0;
  int n26 = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  int n7 = fem::int0;
  int n8 = fem::int0;
  int L = fem::int0;
  int n19 = fem::int0;
  int m = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int n13 = fem::int0;
  int keybrd = fem::int0;
  int incdat = fem::int0;
  int n12 = fem::int0;
  int n14 = fem::int0;
  int n15 = fem::int0;
  arr_1d<35, int> kolinc(fem::fill0);
  int n18 = fem::int0;
  arr_1d<35, fem::str<20> > arginc(fem::fill0);
  int n1 = fem::int0;
  arr_1d<200, int> kbeg(fem::fill0);
  int n6 = fem::int0;
  arr_1d<200, int> karg(fem::fill0);
  arr_1d<200, int> kend(fem::fill0);
  arr_1d<200, int> ktex(fem::fill0);
  int n5 = fem::int0;
  int n20 = fem::int0;
  int n24 = fem::int0;
  int n2 = fem::int0;
  int n4 = fem::int0;
  int n3 = fem::int0;
  int n = fem::int0;
  int ip = fem::int0;
  static const char* format_4223 =
    "(' DONE WITH ARGUMENT.  L, N12, N13, N14, N26 =',8i6)";
  static const char* format_4232 = "(4x,25i3)";
  static const char* format_4237 = "(4x,25i3)";
  //C        character*80  answ80,  file6(500)
  //C        character*1  char1, digit(10)
  //C        logical  logvar
  //C1st time in for $INCLUDE
  if (buff77(1, 1) == "$") {
    goto statement_1788;
  }
  n16 = kard(200);
  n26 = 2;
  //C     WRITE(*,*) ' Encoding "C " card, n16=', n16
  //C2ND CONT. CARD
  if (buff77(1, 2) == "C ") {
    goto statement_4203;
  }
  write(6, star), " Invalid cont. card for $INCLUDE argument list.";
  FEM_STOP(0);
statement_1788:
  n26 = 9;
statement_1789:
  if (buff77(n26, n26) != " " && buff77(n26, n26) != ",") {
    goto statement_1797;
  }
  n26++;
  if (n26 < 40) {
    goto statement_1789;
  }
statement_1794:
  cmn.istep = j;
  write(6, star), " Halt with bad $INCLUDE in INLMFS.";
  FEM_STOP(0);
statement_1797:
  k = n26 + 1;
statement_1801:
  if (buff77(k, k) == "," || buff77(k, k) == " ") {
    goto statement_1804;
  }
  k++;
  if (k > 60) {
    goto statement_1794;
  }
  goto statement_1801;
statement_1804:
  n7 = k - n26;
  answ80(1, n7) = buff77(n26, k - 1);
  n8 = n7;
  answ80(n8 + 1, 80) = cmn.blan80(n8 + 1, 80);
  L = numcrd;
  n19 = limcrd;
  j = cmn.numdcd;
  //C       write (*,*) ' Move LINE CON..  J, NUMCRD =',  J, NUMCRD
  FEM_DO_SAFE(m, j, numcrd) {
    //C      write (*,*) ' Next LINE CONSTANTS card.   M, FILE6(M) =',
    //C    1                                           M, FILE6(M)
    file6(n19) = file6(m);
    n19 = n19 - 1;
  }
  //C     N19 = N19 + 1
  write(lunit6,
    "('   --- THL PASS.  CARD =',i4,'.   READY TO OPEN $INCLUDE =',a)"),
    j, answ80(1, n8);
  cmn.io.inquire_file(answ80(1, n8))
    .exist(logvar);
  if (logvar) {
    goto statement_2294;
  }
  write(lunit6,
    "(/,' Trouble with special  $INCLUDE that',"
    "' is to service line model frequency scan.',/,"
    "' Halt in  INLMFS  called by  OVER2.  Bye, bye!')"),
    answ80(1, n8);
  FEM_STOP(0);
statement_2294:
  prom80 = file6(j);
  file6(j) = "C " + prom80(1, 78);
  cmn.io.open(lunt13, answ80(1, n8))
    .status("OLD");
  n16 = 0;
  n26 = k + 1;
  //C SEARCH COLS. N26-80 FOR NONBLANK
statement_4203:
  FEM_DO_SAFE(L, n26, 80) {
    //C If continue card, exi
    if (buff77(L, L + 1) == "$$") {
      goto statement_2006;
    }
    //C IF NOT "," OR BLANK,
    //C ARGUMENT STARTS
    if (buff77(L, L) != "," && buff77(L, L) != " ") {
      goto statement_4208;
    }
    //C END  DO 4205  LOOP;  COL. "L" NOT ARGUMENT
  }
  //C ALL ARGUMENTS FOUND; NOW USE THEM
  goto statement_4226;
statement_2006:
  write(6, star),
    " Continuation next.   N13, N16, keybrd, INCDAT, L =", n13, n16,
    keybrd, incdat, L;
  //C
  //C Save N16 when '$$' CARD is read
  kard(200) = n16;
  //C  go back  to over2 for 2nd 'arg' card for LMFS
  return;
  //C
  //C      N13 = N13 + 1 ! Next LUNT10 index below last $INCLUDE: for continu
  //CCCC  CALL READ10 ( N13, ABUFF ) ! Load ABUFF with LUNT10 card numbr N13
  //C      BUFF77 = FILE6(N13)     ! TRANSFER TO SCALAR WORKING STORAGE
  //C      write (*,*) ' Continue is card  N13, BUFF77 =',
  //C     1                                n13, buff77
  //C      N26 = 2   ! Reset column number to begin search for next ABUFF arg
  //C      write (*,*) ' Begin arg continuation  BUFF77 =',  BUFF77
  //C
  //C      GO TO 4203   ! Loop back to begin search for args on this continue
  //C
  //C ANOTHER (THE N16-TH) ARGUMENT BEGINS
statement_4208:
  n16++;
  //C      IF ( N16 .GT. 10 )  ! IF NUMBER OF ARGUMENTS IS TOO LARGE,
  //C CURRENT LIMIT OF 18 NODES (9-PHASE)
  if (n16 > 18) {
    stoptp(cmn);
  }
  n12 = fem::index(buff77(L, buff77.len()), ",");
  n13 = fem::index(buff77(L, buff77.len()), " ");
  n14 = n12;
  if (n12 > 0) {
    goto statement_4214;
  }
  n14 = n13;
  if (n13 > 0) {
    goto statement_4220;
  }
  write(munit6, "(' NO BOUNDING SYMBOL.  STOP AFTER DISPLAY.')");
  window(cmn);
  write(munit6, format_4223), L, n12, n13, n14, n26;
  window(cmn);
  stoptp(cmn);
statement_4214:
  if (n13 > 0 && n13 < n14) {
    n14 = n13;
  }
statement_4220:
  n15 = n14 - 1;
  kolinc(n16) = n15;
  n18 = L - 1 + n15;
  arginc(n16) = " ";
  arginc(n16)(1, n15) = buff77(L, n18);
  n26 = n18 + 1;
  if (iprspy < 5) {
    goto statement_4224;
  }
  write(munit6, format_4223), L, n12, n13, n14, n26;
  window(cmn);
statement_4224:
  goto statement_4203;
statement_4226:
  kard(1) = 999999;
  n1 = 0;
  if (n16 == 0) {
    goto statement_4239;
  }
statement_4228:
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(L, 1, 25) {
      rloop, kbeg(L);
    }
  }
  FEM_DO_SAFE(L, 1, 25) {
    if (kbeg(L) == 0) {
      goto statement_4230;
    }
  }
  n1 += 25;
  if (n1 <= 175) {
    goto statement_4228;
  }
  stoptp(cmn);
statement_4230:
  cmn.io.rewind(lunt13);
  n6 = n1 + L - 1;
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(k, 1, n6) {
      rloop, kard(k);
    }
  }
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(k, 1, n6) {
      rloop, karg(k);
    }
  }
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(k, 1, n6) {
      rloop, kbeg(k);
    }
  }
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(k, 1, n6) {
      rloop, kend(k);
    }
  }
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(k, 1, n6) {
      rloop, ktex(k);
    }
  }
  if (iprspy < 1) {
    goto statement_4235;
  }
  write(munit6, "(' DONE READING ARGUMENT USAGE VECTORS.  N4 =',i5)"), n6;
  window(cmn);
statement_4235:
  if (iprspy < 5) {
    goto statement_4238;
  }
  write(munit6, "(' VECTORS KARD, KARG, KBEG, KEND, KTEXT(1:25) ...')");
  window(cmn);
  {
    write_loop wloop(munit6, format_4237);
    FEM_DO_SAFE(k, 1, n5) {
      wloop, kard(k);
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, format_4237);
    FEM_DO_SAFE(k, 1, n5) {
      wloop, karg(k);
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, format_4237);
    FEM_DO_SAFE(k, 1, n5) {
      wloop, kbeg(k);
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, format_4237);
    FEM_DO_SAFE(k, 1, n5) {
      wloop, kend(k);
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, format_4237);
    FEM_DO_SAFE(k, 1, n5) {
      wloop, ktex(k);
    }
  }
  window(cmn);
statement_4238:
  kard(n6 + 1) = 999999;
statement_4239:
  n20 = 0;
  n24 = 1;
  //C
  n18 = j + 1;
  FEM_DO_SAFE(k, n18, limcrd) {
    try {
      read(lunt13, "(a80)"), buff77;
    }
    catch (fem::read_end const&) {
      goto statement_1828;
    }
    if (buff77(1, 1) != "C") {
      goto statement_4247;
    }
    FEM_DO_SAFE(L, 1, 10) {
      if (buff77(2, 2) == digit(L)) {
        goto statement_4244;
      }
    }
    goto statement_4247;
  statement_4244:
    if (L == 10) {
      L = 0;
    }
    if (L > komlev) {
      goto statement_4273;
    }
    buff77(2, 2) = " ";
  statement_4247:
    j++;
    file6(j) = buff77;
    if (buff77(1, 1) == "C") {
      goto statement_4273;
    }
    n20++;
    if (iprspy < 3) {
      goto statement_4249;
    }
    write(munit6,
      "(' READY WITH NEXT CARD.  N20, N24, KARD(N24) =',3i8)"), n20,
      n24, kard(n24);
    window(cmn);
  statement_4249:
    if (n20 < kard(n24)) {
      goto statement_4273;
    }
    n1 = kbeg(n24);
    n2 = kend(n24);
    n4 = karg(n24);
    n3 = kolinc(n4);
    if (n4 <= n16) {
      goto statement_34250;
    }
    write(lunit6,
      "('   ? ? ? ?   ERROR STOP AT S.N. 4250 OF \"DATAIN\".',"
      "'   INSUFFICIENT NUMBER OF $INCLUDE ARGUMENTS.',/,"
      "'             N24, N4, N16 =',3i8)"),
      n24, n4, n16;
    stoptp(cmn);
  statement_34250:
    if (n2 - n1 != n3 - 1 && ktex(n24) == 1) {
      goto statement_4253;
    }
    if (n2 - n1 >= n3 - 1) {
      goto statement_4261;
    }
  statement_4253:
    write(munit6,
      "('   +++ Argument',i4,'   length-mismatch error.','   Used on card',i4,"
      "' .')"),
      n4, n20;
    window(cmn);
    write(munit6,
      "('       N24 =',i4,'    KBEG, KEND =',2i4,'    Length from $INCLUDE =',"
      "i4,' .')"),
      n24, n1, n2, n3;
    window(cmn);
    FEM_STOP(0);
  statement_4261:
    n = n2;
    if (iprspy < 4) {
      goto statement_34261;
    }
    write(munit6, "(' ARGUMENT NOW PROCESSED, ARGINC(N4) =',a20)"), arginc(n4);
    window(cmn);
  statement_34261:
    FEM_DO_SAFE(ip, 1, 20) {
      m = 21 - ip;
      char1 = arginc(n4)(m, m);
      if (char1 == " ") {
        goto statement_4263;
      }
      if (iprspy < 8) {
        goto statement_54262;
      }
      write(munit6,
        "('  NEXT NON-BLANK DIGIT.  IP, N, DIGIT =',2i6,'   \"',a1,'\"')"),
        ip, m, char1;
      window(cmn);
    statement_54262:
      if (char1 == "#") {
        char1 = " ";
      }
      if (n < n1) {
        goto statement_4253;
      }
      file6(j)(n, n) = char1;
      n = n - 1;
    statement_4263:;
    }
    if (n + 1 > n1&& ktex(n24) == 1) {
      goto statement_4253;
    }
    if (n >= n1) {
      file6(j)(n1, n) = " ";
    }
    n24++;
    goto statement_4249;
  statement_4273:;
  }
  FEM_STOP(0);
statement_1828:
  cmn.io.close(lunt13)
    .status("KEEP");
  if (iprspy < 1) {
    goto statement_1832;
  }
  write(munit6, "(' DONE WITH DISK FILE (CLOSE).  J, N19 =',2i8)"), j, n19;
  window(cmn);
statement_1832:
  buff77(1, 32) = "C END OF $INCLUDE.  FILE NAME = ";
  buff77(33, 80) = answ80(1, 48);
  j++;
  file6(j) = buff77;
  n13 = limcrd + 1;
  FEM_DO_SAFE(m, n19, limcrd) {
    j++;
    n13 = n13 - 1;
    file6(j) = file6(n13);
  }
  numcrd = j;
  //C     write (*,*) ' Exit INLMFS.   NUMDCD, NUMCRD =',
  //C    1                             NUMDCD, NUMCRD
}


void over3(common& cmn);

struct over2_save
{
  int ibrnam;
  int inonam;
  int nfscan;
  fem::str<8> text1;
  fem::str<8> text10;
  fem::str<8> text11;
  fem::str<8> text12;
  fem::str<8> text13;
  fem::str<8> text14;
  fem::str<8> text16;
  fem::str<8> text17;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;
  fem::str<8> text8;
  fem::str<8> text9;

  over2_save() :
    ibrnam(fem::int0),
    inonam(fem::int0),
    nfscan(fem::int0),
    text1(fem::char0),
    text10(fem::char0),
    text11(fem::char0),
    text12(fem::char0),
    text13(fem::char0),
    text14(fem::char0),
    text16(fem::char0),
    text17(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0),
    text8(fem::char0),
    text9(fem::char0)
  {}
};

void fddata(
  common& cmn,
  int& ikf,
  int& isfd,
  int& ibf)
{
  common_read read(cmn);
  common_write write(cmn);
  int& l27dep = cmn.l27dep;
  const auto& abuff = cmn.abuff;
  auto& lstat = cmn.lstat;
  int& noutpr = cmn.noutpr;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  auto& rmfd = cmn.rmfd;
  auto& imfd = cmn.imfd;
  //
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int idk = fem::int0;
  int ikk = fem::int0;
  int ka = fem::int0;
  int ibk = fem::int0;
  double ar1 = fem::double0;
  double al1 = fem::double0;
  double ac1 = fem::double0;
  double arl = fem::double0;
  int ifk = fem::int0;
  double d3 = fem::double0;
  int igk = fem::int0;
  int kb = fem::int0;
  int isk = fem::int0;
  //C     OVERLAY 2 MODULE USED ONLY FOR FREQUENCY-DEPENDENT                M32.1142
  //C     REPRESENTATION OF GENERATOR EQUIVALENTS.                          M32.1143
  //C     THIS ROUTINE READS-IN THE BRANCH DATA FOR THE MODES  * * * * * * *M32.1147
  //C     I N I T I A L I Z E   C O U N T E R S    *   *   *   *   *   *   *M32.1148
  idk = 2 * ikf;
  ikk = isfd;
  ikf++;
  if (iprsup > 0) {
    write(lunit6, "(' AT START OF FDDATA IKF,IDK,IKK =',3i10)"), ikf, idk, ikk;
  }
  //C     PROCES MODAL BRANCH DATA         *   *   *   *   *   *   *   *   *M32.1155
  FEM_DO_SAFE(ka, 1, 2) {
    ibk = 0;
    //C     READ INPUT CARD USING CIMAGE                                      M32.1158
  statement_3:
    cimage(cmn);
    read(abuff, "(4e16.0)"), ar1, al1, ac1, arl;
    ifk = 3;
    if (ar1 == 9999.f) {
      goto statement_10;
    }
    d3 = ar1 + al1 + ac1 + arl;
    if (d3 > 0.f) {
      goto statement_6;
    }
    lstat(19) = 6;
    goto statement_3719;
  statement_6:
    if (al1 > 0.f) {
      goto statement_7;
    }
    ar1 += arl;
    arl = 0.f;
  statement_7:
    ibk++;
    ikk++;
    igk = 7;
    if (ikk + 4 <= l27dep) {
      goto statement_8;
    }
    lstat(19) = 8;
    goto statement_3742;
  statement_8:
    rmfd(ikk) = ar1;
    rmfd(ikk + 1) = al1;
    rmfd(ikk + 2) = ac1;
    rmfd(ikk + 3) = arl;
    rmfd(ikk + 4) = 0.f;
    ikk += 4;
    if (noutpr == 0) {
      write(kunit6, "('+ NEXT BRANCH',8x,3e10.3)"), ar1, al1, ac1;
    }
    goto statement_3;
  statement_10:
    if (noutpr == 0) {
      write(kunit6, "('+SPECIAL TERMINATION OF BRANCHES')");
    }
    ifk = 10;
    if (ibk > 0) {
      goto statement_15;
    }
    lstat(19) = 15;
    goto statement_3719;
  statement_15:
    kb = idk + ka;
    igk = 12;
    if (kb <= cmn.lsiz27) {
      goto statement_16;
    }
    lstat(19) = 16;
    goto statement_3742;
  statement_16:
    imfd(kb) = ibk;
  }
  if (iprsup < 1) {
    goto statement_14;
  }
  isk = isfd + 1;
  {
    write_loop wloop(cmn, lunit6,
      "(' AT END OF FDDATA  RMFD FROM',i6,'  TO',i6,/(2x,6e21.12))");
    wloop, isk, ikk;
    FEM_DO_SAFE(ka, isk, ikk) {
      wloop, rmfd(ka);
    }
  }
statement_14:
  isfd = ikk;
  igk = 14;
  ibf += (imfd(idk + 1) + imfd(idk + 2) * (cmn.itype - 1)) * 3;
  if (ibf <= l27dep) {
    goto statement_9999;
  }
  lstat(19) = 14;
statement_3742:
  kill = 1;
  goto statement_9999;
statement_3719:
  kill = 37;
statement_9999:;
}

struct nonln2_save
{
  fem::str<8> text1;
  fem::str<8> text2;

  nonln2_save() :
    text1(fem::char0),
    text2(fem::char0)
  {}
};

void
nonln2(
  common& cmn)
{
  FEM_CMN_SVE(nonln2);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& blank = cmn.blank;
  const auto& abuff = cmn.abuff;
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  double& fltinf = cmn.fltinf;
  double& flzero = cmn.flzero;
  auto& flstat = cmn.flstat;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  int& inonl = cmn.inonl;
  int& itype = cmn.itype;
  int& lchar = cmn.lchar;
  int& num99 = cmn.num99;
  int& noutpr = cmn.noutpr;
  int& ichar = cmn.ichar;
  int& moldat = cmn.moldat;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  int& it = cmn.it;
  int& ibr = cmn.ibr;
  auto& nonlad = cmn.nonlad;
  auto& nonle = cmn.nonle;
  auto& vnonl = cmn.vnonl;
  auto& curr = cmn.curr;
  auto& anonl = cmn.anonl;
  auto& vecnl1 = cmn.vecnl1;
  auto& vecnl2 = cmn.vecnl2;
  auto& namenl = cmn.namenl;
  auto& vzer5 = cmn.vzer5;
  auto& ilast = cmn.ilast;
  auto& nltype = cmn.nltype;
  auto& cchar = cmn.cchar;
  auto& vchar = cmn.vchar;
  auto& gslope = cmn.gslope;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  const auto& texvec = cmn.texvec;
  auto& nonlk = cmn.nonlk;
  auto& nonlm = cmn.nonlm;
  int& n2 = cmn.n2;
  int& n3 = cmn.n3;
  int& n4 = cmn.n4;
  int& n13 = cmn.n13;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  if (is_called_first_time) {
    text1 = "SINGLE";
    text2 = " FLASH";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int ll9 = fem::int0;
  int iprint = fem::int0;
  int n16 = fem::int0;
  fem::str<8> text3 = fem::char0;
  double d3 = fem::double0;
  int n10 = fem::int0;
  double d2 = fem::double0;
  double d4 = fem::double0;
  double a2 = fem::double0;
  int iseg = fem::int0;
  int ibk = fem::int0;
  int ichr = fem::int0;
  int icard = fem::int0;
  double d11 = fem::double0;
  double d5 = fem::double0;
  int jk = fem::int0;
  int jb = fem::int0;
  double d6 = fem::double0;
  double xlong = fem::double0;
  double d1 = fem::double0;
  double c1 = fem::double0;
  int n11 = fem::int0;
  int n12 = fem::int0;
  int n14 = fem::int0;
  int n15 = fem::int0;
  int n17 = fem::int0;
  int j = fem::int0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  double d12 = fem::double0;
  double d9 = fem::double0;
  double d10 = fem::double0;
  int ii = fem::int0;
  int i = fem::int0;
  int iaw = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  static const char* format_1272 = "(5e16.0)";
  static const char* format_149 = "(3e25.0)";
  static const char* format_2272 = "('+  CONSTS. ',i2,'-',i2,'.',3e11.3)";
  static const char* format_54118 = "('+SPECIAL TERMINATION-OF-POINTS CARD.')";
  static const char* format_59 = "('+ BREAKPOINT',4x,3e11.4)";
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE NONLN2.\"')");
  }
  ll9 = 9;
  //C     FOLLOWING CHECK IS FOR SATURABLE TRANSFORMER CHAR.                M28.2900
  if (lstat(18) == 187) {
    goto statement_187;
  }
  if (itype >= 91) {
    goto statement_4221;
  }
  kill = 3;
  lstat(19) = 4221;
  lstat(16) = itype;
  goto statement_9999;
statement_4221:
  iprint = 9;
  inonl++;
  lstat(19) = 6862;
  if (inonl > cmn.lnonl) {
    goto statement_9000;
  }
  if (moldat == 0) {
    goto statement_4236;
  }
  read(abuff, "(26x,4e12.0)"), tr(it), tx(it), c(it), tr(it + 1);
statement_4236:
  if (bus3 != cmn.branch) {
    goto statement_6874;
  }
  n16 = 1;
  text3 = bus4;
  namea6(cmn, text3, n16);
  if (n16 == -cmn.intinf) {
    goto statement_6824;
  }
  kill = 167;
  lstat(19) = 4236;
  lstat(14) = n16;
  goto statement_9999;
statement_6824:
  n16 = 0;
  namea6(cmn, text3, n16);
  namenl(inonl) = n16;
  bus3 = blank;
  bus4 = blank;
  n4 = 1;
  n3 = 1;
statement_6874:
  ibr = ibr - 1;
  nltype(inonl) = itype;
  nonlk(inonl) = cmn.n1;
  if (cmn.iout > 0) {
    n2 = -n2;
  }
  nonlm(inonl) = n2;
  vnonl(inonl) = tr(it);
  if (itype != 93 && itype != 96 && itype != 98) {
    goto statement_185;
  }
  vzer5(inonl) = tr(it);
  anonl(inonl) = tx(it);
  vnonl(inonl) = 0.f;
statement_185:
  curr(inonl) = 0.f;
  if (itype == 94) {
    goto statement_270;
  }
  if (itype != 99) {
    goto statement_73412;
  }
  d3 = c(it);
  if (moldat > 0) {
    goto statement_4257;
  }
  read(abuff, "(38x,e6.0)"), d3;
statement_4257:
  if (d3 == 0.0f) {
    d3 = 1.0f;
  }
  anonl(inonl) = d3;
  n10 = d3;
  vecnl1(inonl) = tx(it);
  vecnl2(inonl) = tx(it);
  nltype(inonl) = -99;
  num99++;
  curr(inonl) = 0.0f;
  vzer5(inonl) = tr(it + 1);
  if (vzer5(inonl) > vnonl(inonl)) {
    vzer5(inonl) = 0.0f;
  }
  if (n3 * n4 != 1) {
    goto statement_182;
  }
  if (noutpr == 0) {
    write(kunit6, "('+TYPE-99 NONLINEAR R.',2x,2e11.3,i5)"), tr(it),
      tx(it), n10;
  }
statement_73408:
  ci1 = 0.0f;
  goto statement_73420;
statement_73412:
  if (itype != 98) {
    goto statement_73416;
  }
  nltype(inonl) = -98;
  num99++;
  curr(inonl) = 1.0f;
  if (n3 * n4 != 1) {
    goto statement_182;
  }
  if (noutpr == 0) {
    write(kunit6, "('+TYPE-98 PSEUDO-NONLINEAR L.',2e11.3)"), tr(it), tx(it);
  }
  goto statement_73408;
statement_73416:
  if (itype != 97) {
    goto statement_73418;
  }
  nltype(inonl) = -97;
  num99++;
  anonl(inonl) = tx(it);
  if (n3 * n4 != 1) {
    goto statement_182;
  }
  if (noutpr == 0) {
    write(kunit6, "('+TYPE-97 R(T).',10x,2e12.4)"), tr(it), tx(it);
  }
statement_73418:
  if (itype != 96) {
    goto statement_4741;
  }
  nltype(inonl) = -96;
  nonlad(inonl) = ichar + 1;
  ilast(inonl) = nonlad(inonl) + 6;
  num99++;
  vecnl1(inonl) = c(it);
  if (n3 * n4 == 1) {
    goto statement_4736;
  }
  ichar += 6;
  nonle(inonl) = -ichar;
  goto statement_182;
statement_4736:
  if (noutpr == 0) {
    write(kunit6, "('+HYSTERESIS.',3e12.4)"), tr(it), tx(it), c(it);
  }
statement_4741:
  if (n3 != 1 || n4 != 1) {
    goto statement_182;
  }
  if (itype == 93 && noutpr == 0) {
    write(kunit6, "('+N.L. INDUCTANCE, TYPE 93.',2x,2e11.3)"), tr(it), tx(it);
  }
  if (itype > 91) {
    goto statement_19;
  }
  if (noutpr == 0) {
    write(kunit6, "('+TIME-VARYING R, TYPE 91.',3x,2e11.3)"), tr(it), c(it);
  }
  if (c(it) == 3333.f) {
    goto statement_12;
  }
  kill = 5;
  lstat(19) = 20;
  goto statement_9999;
statement_12:
  nltype(inonl) = 923;
  goto statement_21;
statement_19:
  if (itype != 92) {
    goto statement_80;
  }
  if (noutpr == 0) {
    write(kunit6, "('+ GAP, TYPE 92.',1x,3e11.3)"), tr(it), tx(it), c(it);
  }
  if (tr(it) != 5555.f) {
    goto statement_20;
  }
  kill = 28;
  lstat(19) = 20;
  goto statement_9999;
statement_20:
  if (c(it) == 4444.f || c(it) == 5555.f) {
    goto statement_21;
  }
  kill = 5;
  lstat(19) = 20;
  goto statement_9999;
statement_21:
  iprint = ichar + 1;
  nonlad(inonl) = iprint;
  iprint = 10;
  //C     READ CARDS USING CIMAGE                                           M37.2258
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_22;
  }
  read(abuff, format_149), d2, d3, d4;
  goto statement_23;
statement_22:
  nfrfld = 1;
  nright = 0;
  freone(cmn, d2);
  freone(cmn, d3);
  freone(cmn, d4);
statement_23:
  ck1 = -fltinf;
  a2 = 0.0f;
  vzer5(inonl) = d4;
  if (c(it) == 4444.f) {
    goto statement_40;
  }
  //C     ENTER ZNO DATA CODE********************************************** M37.2273
  if (d2 > 0.0f) {
    goto statement_25;
  }
  kill = 28;
  lstat(19) = 23;
  goto statement_9999;
statement_25:
  anonl(inonl) = d2;
  if (itype == 91) {
    goto statement_45;
  }
  if (d3 <= 0.0f) {
    d3 = fltinf;
  }
  vnonl(inonl) = d3;
  if (noutpr == 0) {
    write(kunit6, "('+VREF,VGAP,VINIT',1x,3e11.3)"), d2, d3, d4;
  }
  //C     READ-IN ARRESTER CHARACTERISTICS********************************* M37.2285
  iseg = 2;
  if (d3 == fltinf) {
    iseg = 1;
  }
  if (iseg == 2) {
    vnonl(inonl) = d3 * d2;
  }
  FEM_DO_SAFE(ibk, 1, iseg) {
    ichar++;
    ichr = ichar;
    icard = 0;
  statement_29:
    icard++;
    //C     READ CARDS USING CIMAGE                                           M37.2294
    cimage(cmn);
    if (kolbeg > 0) {
      goto statement_30;
    }
    read(abuff, format_149), d2, d3, d4;
    goto statement_31;
  statement_30:
    nfrfld = 1;
    nright = 0;
    freone(cmn, d2);
    freone(cmn, d3);
    freone(cmn, d4);
  statement_31:
    if (d2 == 9999.f) {
      goto statement_37;
    }
    ichar++;
    if (ichar <= lchar) {
      goto statement_36;
    }
    lstat(19) = 36;
    goto statement_9000;
  statement_36:
    cchar(ichar) = d2;
    gslope(ichar) = d3;
    vchar(ichar) = d4;
    if (noutpr == 0) {
      write(kunit6, format_59), d2, d3, d4;
    }
    goto statement_29;
  statement_37:
    if (icard > 1) {
      goto statement_38;
    }
    //C     NO VALID DATA ENCOUNTERED, TERMINATE RUN                          M37.2318
    kill = 28;
    lstat(19) = 37;
    goto statement_9999;
  statement_38:
    if (noutpr == 0) {
      write(kunit6, format_54118);
    }
    if (ibk == 1) {
      ilast(inonl) = ichar;
    }
    //C     CALCULATE INITIAL ( LINEAR ) SLOPE                                M37.2325
    d11 = cchar(ichr + 1) * (fem::pow(vchar(ichr + 1), gslope(ichr + 1)));
    cchar(ichr) = d11 / (vchar(ichr + 1) * anonl(inonl));
    vchar(ichr) = 0.0f;
  }
  nonle(inonl) = ichar;
  nltype(inonl) = 921;
  goto statement_100;
  //C     ENTER CODE FOR PIECEWISE LINEAR AND TIME VARYING RESISTANCE****** M37.2333
statement_40:
  a2 = d2;
  if (d3 < 0.0f) {
    d3 = fltinf;
  }
  vnonl(inonl) = d3;
  vecnl1(inonl) = tr(it);
  if (noutpr == 0) {
    write(kunit6, "('+RLIN,VFLASH,NFLASH',1x,3e10.3)"), d2, d3, d4;
  }
  goto statement_46;
statement_45:
  if (noutpr == 0) {
    write(kunit6, "('+V START=',e15.5)"), d2;
  }
  anonl(inonl) = 2.0f * d2;
  vnonl(inonl) = d2;
  ilast(inonl) = 1;
  //C     READ-IN NONLINEAR CHARACTERISTIC (MININMUM TWO DATA POINTS)****** M37.2348
statement_46:
  icard = 0;
statement_47:
  icard++;
  //C     READ CARDS USING CIMAGE                                           M37.2351
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_48;
  }
  read(abuff, format_149), d2, d3;
  goto statement_49;
statement_48:
  nfrfld = 1;
  nright = 0;
  freone(cmn, d2);
  freone(cmn, d3);
statement_49:
  if (d2 == 9999.f) {
    goto statement_53;
  }
  if (noutpr == 0) {
    write(kunit6, format_59), d2, d3;
  }
  if (itype == 91) {
    goto statement_51;
  }
  if (d3 > ck1) {
    goto statement_51;
  }
  kill = 5;
  lstat(19) = 49;
  goto statement_9999;
statement_51:
  ichar++;
  if (ichar <= lchar) {
    goto statement_52;
  }
  lstat(19) = 51;
  goto statement_9000;
statement_52:
  vchar(ichar) = d3 + a2 * d2;
  ck1 = d3;
  cchar(ichar) = d2;
  goto statement_47;
statement_53:
  if (icard > 2) {
    goto statement_54;
  }
  kill = 28;
  lstat(19) = 53;
  goto statement_9999;
statement_54:
  if (noutpr == 0) {
    write(kunit6, format_54118);
  }
  //C     PROCESS INPUT DATA (CALCULATE SLOPE + CONSTANT, EXTEND DATA       M37.2382
  //C     POINTS TO INFINITY , DETERMINE VREFERENCE************************ M37.2383
  ichr = nonlad(inonl);
  if (itype == 91) {
    goto statement_74;
  }
  d5 = std::abs(vchar(ichr));
  d3 = std::abs(vchar(ichar));
  if (d5 > d3) {
    d3 = d5;
  }
  anonl(inonl) = d3;
  //C     DETERMINE WHETHER ONLY UPPER HALF OF DATA SPECIFIED ************* M37.2390
  if (vchar(ichr) > 0.0f && cchar(ichr) > 0.0f) {
    goto statement_55;
  }
  goto statement_74;
  //C     ADD ( 0.0, 0.0 ) POINT TO THE USER'S DATA *********************** M37.2394
statement_55:
  jk = ichar + 1;
  if (jk <= lchar) {
    goto statement_70;
  }
  lstat(19) = 55;
  goto statement_9000;
statement_70:
  FEM_DO_SAFE(jb, ichr, ichar) {
    vchar(jk) = vchar(jk - 1);
    cchar(jk) = cchar(jk - 1);
    jk = jk - 1;
  }
  vchar(ichr) = 0.0f;
  cchar(ichr) = 0.0f;
  ichar++;
statement_74:
  ichr++;
  FEM_DO_SAFE(jb, ichr, ichar) {
    d5 = cchar(jb) - cchar(jb - 1);
    if (jb == ichar && vchar(jb) == vchar(jb - 1)) {
      goto statement_77;
    }
    d5 = d5 / (vchar(jb) - vchar(jb - 1));
    goto statement_78;
  statement_77:
    d5 = 0.0f;
  statement_78:
    d6 = cchar(jb) - vchar(jb) * d5;
    gslope(jb - 1) = d5;
    cchar(jb - 1) = d6;
  }
  ichar = ichar - 1;
  nonle(inonl) = ichar;
  if (itype == 91) {
    goto statement_76;
  }
  if (vchar(ichr - 1) < 0.0f) {
    vchar(ichr - 1) = -fltinf;
  }
  ilast(inonl) = 1;
  if (vnonl(inonl) == fltinf || vnonl(inonl) == 0.0f) {
    ilast(inonl) = -1;
  }
  nltype(inonl) = 922;
  goto statement_100;
statement_76:
  ilast(inonl) = 1;
  vecnl1(inonl) = -1.0f;
  goto statement_100;
statement_80:
  ci1 = -fltinf;
statement_73420:
  ck1 = ci1;
  if (itype != 96) {
    goto statement_73421;
  }
  ichar += 7;
  goto statement_73422;
statement_73421:
  iprint = ichar + 1;
  nonlad(inonl) = iprint;
statement_73422:
  iprint = 10;
  //C     READ INPUT CARD USING CIMAGE.                                     M28.3019
statement_187:
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_73423;
  }
  read(abuff, "(3e16.0)"), d2, xlong;
  goto statement_73424;
statement_73423:
  nfrfld = 1;
  nright = 0;
  freone(cmn, d2);
  freone(cmn, xlong);
statement_73424:
  if (d2 == 9999.f) {
    goto statement_189;
  }
  if (noutpr == 0) {
    write(kunit6, "('+    BREAKPOINT.',2e15.5)"), d2, xlong;
  }
  if (d2 > ci1) {
    goto statement_4225;
  }
statement_4224:
  kill = 5;
  lstat(19) = 181;
  goto statement_9999;
statement_4225:
  if (itype != 96 && itype != 98) {
    goto statement_4227;
  }
  if (xlong > ck1) {
    goto statement_4226;
  }
  goto statement_4224;
statement_4227:
  if (xlong >= ck1) {
    goto statement_4226;
  }
  if (itype == 97) {
    goto statement_4226;
  }
  goto statement_4224;
statement_4226:
  ichar++;
  if (ichar <= lchar) {
    goto statement_6472;
  }
  iprint = 10;
  lstat(19) = 4226;
  goto statement_9000;
statement_6472:
  d3 = d2 - ci1;
  d4 = xlong - ck1;
  if (itype != 99) {
    goto statement_73430;
  }
  gslope(ichar) = d3 / d4;
  cchar(ichar) = ci1 - gslope(ichar) * ck1;
  goto statement_73436;
statement_73430:
  if (itype != 98) {
    goto statement_73437;
  }
  d1 = d4 / d3;
  gslope(ichar) = cmn.delta2 / d1;
  cchar(ichar) = ck1 - d1 * ci1;
  goto statement_73436;
statement_73437:
  if (itype != 97) {
    goto statement_73441;
  }
  if (xlong > 0.0f) {
    goto statement_7344;
  }
  kill = 72;
  lstat(19) = 7344;
  flstat(16) = xlong;
  goto statement_9999;
statement_7344:
  gslope(ichar) = 1.0f / xlong;
statement_73441:
  if (itype != 96) {
    goto statement_73442;
  }
  cchar(ichar) = d2;
  vchar(ichar) = xlong;
  c1 = d2;
  ck1 = xlong;
  if (iprsup >= 4) {
    write(lunit6,
      "(/,' TYPE-96  POINT.','   ICHAR   INONL',3x,'NONLAD(INONL)',13x,'D2',"
      "10x,'XLONG',/,16x,2i8,8x,i8,2e15.6)"),
      ichar, inonl, nonlad(inonl), d2, xlong;
  }
  goto statement_187;
statement_73442:
  cchar(ichar) = d2;
statement_73436:
  ci1 = d2;
  ck1 = xlong;
  vchar(ichar) = xlong;
  goto statement_187;
statement_189:
  if (itype != 96) {
    goto statement_4758;
  }
  n11 = nonlad(inonl);
  n12 = ilast(inonl);
  cchar(n12) = -cchar(ichar - 1);
  vchar(n12) = -vchar(ichar - 1);
  cchar(n11) = ichar - ilast(inonl);
  n13 = cchar(n11);
  //C     CALCULATE THE SLOPE AND INTERCEPT FOR MAJOR HYSTERESIS LOOP       M28.3092
  //C     SEGMENTS,  FOR  TYPE-96  PSEUDONONLINEAR ELEMENT.                 M28.3093
  n14 = ichar + 2;
  n15 = n14 + n13 - 1;
  FEM_DO_SAFE(n16, n14, n15) {
    n17 = n16 - n13 - 1;
    vchar(n16) = (vchar(n17) - vchar(n17 - 1)) / (cchar(n17) - cchar(n17 - 1));
    cchar(n16) = vchar(n17) - vchar(n16) * cchar(n17);
    gslope(n17) = 1.0f / vchar(n16);
    gslope(n16) = -cchar(n16) / vchar(n16);
  }
  n16 = ichar + n13 + 1;
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' PROCESS TYPE-96.','   INONL   ICHAR     N11     N13',14x,'TR(IT)',"
      "7x,'VECNL1(INONL)',8x,'ANONL(INONL)',/,17x,4i8,3e20.11)"),
      inonl, ichar, n11, n13, tr(it), vecnl1(inonl), anonl(inonl);
  }
  cchar(ichar + 1) = -cchar(n16);
  vchar(ichar + 1) = vchar(n16);
  gslope(n12) = gslope(ichar);
  gslope(ichar + 1) = -gslope(n16);
  ichar += n13 + 1;
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' ICHAR =',i3,5x,"
        "'(CCHAR(J), VCHAR(J), GSLOPE(J), J=N11, ICHAR)  FOLLOW ...',/(1x,"
        "6e20.11))");
      wloop, ichar;
      FEM_DO_SAFE(j, n11, ichar) {
        wloop, cchar(j), vchar(j), gslope(j);
      }
    }
  }
  //C     HANDLING OF STEADY-STATE CURRENT AND FLUX CONDITIONS.             M28.3123
statement_5309:
  n12 = ilast(inonl);
  n13 = nonlad(inonl);
  n13 = cchar(n13);
  n14 = n12 + n13 - 1;
  if (tr(it) == 8888.f) {
    goto statement_5330;
  }
  //C     MAKE SURE THAT THE USER-SPECIFIED POINT LIES WITHIN THE MAJOR     M28.3129
  //C     HYSTERESIS LOOP.                                                  M28.3130
  FEM_DO_SAFE(n15, n12, n14) {
    if (tr(it) > cchar(n15)) {
      goto statement_5310;
    }
    n16 = n15;
    goto statement_5313;
  statement_5310:;
  }
  n16 = n14 + 1;
statement_5313:
  n17 = n16 + n13 + 1;
  d7 = vchar(n17) * tr(it) + cchar(n17) - flzero;
  FEM_DO_SAFE(n15, n12, n14) {
    if (-tr(it) > cchar(n15)) {
      goto statement_5320;
    }
    n16 = n15;
    goto statement_5323;
  statement_5320:;
  }
  n16 = n14 + 1;
statement_5323:
  n17 = n16 + n13 + 1;
  d8 = -vchar(n17) * (-tr(it)) - cchar(n17) + flzero;
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' TYPE-96 S.S. CHECK.','      IT     N16     N17',13x,'D7',13x,'D8',"
      "3x,'ANONL(INONL)',9x,'FLZERO',/,20x,3i8,4e15.6)"),
      it, n16, n17, d7, d8, anonl(inonl), flzero;
  }
  if (anonl(inonl) <= d8 && anonl(inonl) >= d7) {
    goto statement_5360;
  }
  kill = 204;
  lstat(19) = 5323;
  flstat(14) = tr(it);
  flstat(15) = tx(it);
  goto statement_9999;
  //C     IT IS DESIRED TO HAVE THE PROGRAM CALCULATE THE VALUES FOR        M28.3159
  //C     STEADY-STATE FLUX AND CURRENT BASED ON 70 PERCENT OF SATURATION.  M28.3160
statement_5330:
  d12 = 0.7e0;
  anonl(inonl) = d12 * vchar(n14);
  FEM_DO_SAFE(n15, n12, n14) {
    if (cchar(n15) < 0.0f) {
      goto statement_5340;
    }
    n16 = n15;
    goto statement_5343;
  statement_5340:;
  }
  n16 = n14 + 1;
statement_5343:
  n17 = n16 + n13 + 1;
  d9 = -cchar(n17);
  d12 = 0.3e0;
  d10 = anonl(inonl) - d12 * d9;
  FEM_DO_SAFE(n15, n12, n14) {
    if (d10 > vchar(n15)) {
      goto statement_5350;
    }
    n16 = n15;
    goto statement_5353;
  statement_5350:;
  }
  n16 = n14 + 1;
statement_5353:
  n17 = n16 + n13 + 1;
  vzer5(inonl) = gslope(n16) * d10 + gslope(n17);
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' PROGRAM CALCULATED SS PT.  N12  N14  N16  N17          D9       AN"
      "ONL       VZER5    GSLOPE(N16)    GSLOPE(N17)',/,26x,4i5,3(1x,e15.6),"
      "2e15.6)"),
      n12, n14, n16, n17, d9, anonl(inonl), vzer5(inonl), gslope(n16),
      gslope(n17);
  }
  goto statement_5380;
  //C     MAKE SURE THAT THE USER-SPECIFIED RESIDUAL FLUX IS WITHIN THE     M28.3188
  //C     MAJOR HYSTERESIS LOOP.                                            M28.3189
statement_5360:
  FEM_DO_SAFE(n15, n12, n14) {
    if (cchar(n15) < 0.0f) {
      goto statement_5370;
    }
    n16 = n15;
    goto statement_5373;
  statement_5370:;
  }
  n16 = n14 + 1;
statement_5373:
  n17 = n16 + n13 + 1;
  d9 = -cchar(n17);
statement_5380:
  d9 = std::abs(d9);
  d12 = vecnl1(inonl);
  d12 = std::abs(d12);
  if (d12 <= d9 + flzero) {
    goto statement_4758;
  }
  kill = 205;
  lstat(19) = 5380;
  flstat(16) = vecnl1(inonl);
  flstat(17) = d9;
  goto statement_9999;
statement_4758:
  if (n3 * n4 != 1) {
    goto statement_100;
  }
  nonle(inonl) = ichar;
  if (ichar <= lchar) {
    goto statement_4763;
  }
  lstat(19) = 4758;
  iprint = 10;
  goto statement_9000;
statement_4763:
  if (itype != 99) {
    goto statement_54127;
  }
  read(abuff, "(32x,2a6)"), bus1, bus2;
  if (bus1 != text1) {
    goto statement_54127;
  }
  if (bus2 != text2) {
    goto statement_54127;
  }
  j = nonlad(inonl);
  cmn.sglfir = vchar(j);
  if (noutpr == 0) {
    write(kunit6, "('+',39x,'''1-FLASH''')");
  }
statement_54127:
  if (noutpr == 0) {
    write(kunit6, format_54118);
  }
  if (itype != 93 && itype != 96 && itype != 98) {
    goto statement_100;
  }
  nonle(inonl) = -ichar;
  vnonl(inonl) = 0.f;
  goto statement_100;
statement_182:
  ii = inonl - 1;
  if (ii > 0) {
    goto statement_4231;
  }
  lstat(19) = 182;
  goto statement_4230;
statement_4231:
  if (noutpr == 0) {
    write(kunit6,
      "('+REFERENCE BRANCH.   COPY  \"',a6,'\" TO \"',a6,'\"')"),
      bus3, bus4;
  }
  FEM_DO_SAFE(i, 1, ii) {
    if (bus3 == cmn.copy) {
      goto statement_6881;
    }
    if (nonlk(i) != n3) {
      goto statement_183;
    }
    if (fem::iabs(nonlm(i)) != n4) {
      goto statement_183;
    }
    goto statement_184;
  statement_6881:
    n13 = namenl(i);
    if (bus4 == texvec(n13)) {
      goto statement_184;
    }
  statement_183:;
  }
  lstat(19) = 183;
statement_4230:
  kill = 6;
  goto statement_9999;
statement_184:
  if (itype != 96) {
    goto statement_269;
  }
  ilast(inonl) = ilast(i);
  n16 = nonlad(inonl);
  n17 = nonlad(i);
  cchar(n16) = cchar(n17);
  goto statement_5309;
statement_269:
  nonlad(inonl) = nonlad(i);
  if (itype == 94) {
    goto statement_100;
  }
  nonle(inonl) = nonle(i);
  if (itype == 99) {
    goto statement_100;
  }
  vzer5(inonl) = vzer5(i);
  anonl(inonl) = anonl(i);
  if (itype != 91) {
    goto statement_72;
  }
  if (c(it) != 3333.f) {
    lstat(19) = 269;
  }
  goto statement_73;
statement_72:
  if (itype != 92) {
    goto statement_100;
  }
statement_73:
  if (c(it) != 4444.f && c(it) != 5555.f) {
    lstat(19) = 269;
  }
  if (lstat(19) == 269) {
    goto statement_4230;
  }
  vnonl(inonl) = vnonl(i);
  vecnl1(inonl) = vecnl1(i);
  ilast(inonl) = ilast(i);
  nltype(inonl) = nltype(i);
  goto statement_100;
statement_270:
  if (ichar + 11 <= lchar) {
    goto statement_271;
  }
statement_1270:
  iprint = 10;
  lstat(19) = 270;
  goto statement_9000;
statement_271:
  iaw = ichar + 1;
  nonle(inonl) = iaw;
  move0(vchar, iaw, ll9);
  if (tx(it) == 0.0f) {
    tx(it) = 1.0f;
  }
  vchar(ichar + 10) = tx(it);
  if (c(it) == 0.0f) {
    c(it) = 1.0f;
  }
  vchar(ichar + 11) = c(it);
  if (n3 != 1) {
    goto statement_4271;
  }
  if (n4 == 1) {
    goto statement_3271;
  }
statement_4271:
  ichar += 11;
  goto statement_182;
statement_3271:
  nonlad(inonl) = -iaw;
  if (noutpr == 0) {
    write(kunit6, "('+TYPE-94 ARRESTER.',e10.3,2e11.4)"), tr(it), tx(it), c(it);
  }
  if (ichar + 18 > lchar) {
    goto statement_1270;
  }
  j = 1;
  ii = 4;
  //C     READ INPUT CARD USING CIMAGE                                      M28.3289
  cimage(cmn);
  n6 = j + ichar;
  n7 = ii + ichar;
  {
    read_loop rloop(abuff(1), format_1272);
    FEM_DO_SAFE(i, n6, n7) {
      rloop, cchar(i);
    }
  }
  ii = 3;
  n7 = ii + ichar;
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, format_2272);
      wloop, j, ii;
      FEM_DO_SAFE(i, n6, n7) {
        wloop, cchar(i);
      }
    }
  }
  FEM_DOSTEP(j, 5, 17, 3) {
    ii = j + 2;
    if (ii > 18) {
      ii = 18;
    }
    //C     READ INPUT CARD USING CIMAGE                                      M28.3303
    cimage(cmn);
    n6 = j + ichar;
    n7 = ii + ichar;
    {
      read_loop rloop(abuff(1), format_1272);
      FEM_DO_SAFE(i, n6, n7) {
        rloop, cchar(i);
      }
    }
    if (noutpr == 0) {
      {
        write_loop wloop(cmn, kunit6, format_2272);
        wloop, j, ii;
        FEM_DO_SAFE(i, n6, n7) {
          wloop, cchar(i);
        }
      }
    }
  }
  ichar += 18;
statement_100:
  goto statement_9999;
statement_9000:
  lstat(16) = iprint;
  kill = 1;
statement_9999:
  if (iprsup >= 3 || kill > 0) {
    write(lunit6,
      "(/,' EXIT  \"NONLN2\" .','    KILL   INONL   NUM99   ICHAR   ITYPE',/,"
      "17x,10i8)"),
      kill, inonl, num99, ichar, itype;
  }
  lstat(18) = 0;
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE NONLN2.\"')");
  }
}

struct distr2_save
{
  int ipsem;
  fem::str<8> text10;
  fem::str<8> text11;
  fem::str<8> text12;
  fem::str<8> text13;
  fem::str<8> text14;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;
  fem::str<8> text8;
  fem::str<8> text9;
  arr<fem::str<8> > textmx;

  distr2_save() :
    ipsem(fem::int0),
    text10(fem::char0),
    text11(fem::char0),
    text12(fem::char0),
    text13(fem::char0),
    text14(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0),
    text8(fem::char0),
    text9(fem::char0),
    textmx(dimension(2), fem::fill0)
  {}
};

void
distr2(
  common& cmn)
{
  FEM_CMN_SVE(distr2);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& bus6 = cmn.bus6;
  const auto& abuff = cmn.abuff;
  double& ci1 = cmn.ci1;
  double& deltat = cmn.deltat;
  auto& twopi = cmn.twopi;
  double& tmax = cmn.tmax;
  double& omega = cmn.omega;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  auto& voltbc = cmn.voltbc;
  auto& flstat = cmn.flstat;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& indtv = cmn.indtv;
  auto& lstat = cmn.lstat;
  int& icheck = cmn.icheck;
  int& iline = cmn.iline;
  int& ipunch = cmn.ipunch;
  int& itype = cmn.itype;
  int& kcount = cmn.kcount;
  int& lbrnch = cmn.lbrnch;
  auto& ktrlsw = cmn.ktrlsw;
  int& lhist = cmn.lhist;
  int& ifx = cmn.ifx;
  int& noutpr = cmn.noutpr;
  int& moldat = cmn.moldat;
  int& ifsem = cmn.ifsem;
  int& lfsem = cmn.lfsem;
  int& iadd = cmn.iadd;
  int& lfd = cmn.lfd;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  auto& sconst = cmn.sconst;
  auto& cnvhst = cmn.cnvhst;
  auto& sfd = cmn.sfd;
  auto& qfd = cmn.qfd;
  auto& semaux = cmn.semaux;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  auto& ck = cmn.ck;
  auto& litype = cmn.litype;
  auto& imodel = cmn.imodel;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  auto& kodebr = cmn.kodebr;
  auto& cki = cmn.cki;
  auto& ckkjm = cmn.ckkjm;
  auto& indhst = cmn.indhst;
  auto& kodsem = cmn.kodsem;
  auto& namebr = cmn.namebr;
  int& n1 = cmn.n1;
  int& n2 = cmn.n2;
  int& n3 = cmn.n3;
  int& n4 = cmn.n4;
  int& model = cmn.model;
  int& ibr1 = cmn.ibr1;
  int& nrecur = cmn.nrecur;
  int& kgroup = cmn.kgroup;
  int& ifq = cmn.ifq;
  int& n13 = cmn.n13;
  int& ida = cmn.ida;
  int& ifkc = cmn.ifkc;
  int& idm = cmn.idm;
  int& idq = cmn.idq;
  int& idu = cmn.idu;
  //
  int& ipsem = sve.ipsem;
  fem::str<8>& text10 = sve.text10;
  fem::str<8>& text11 = sve.text11;
  fem::str<8>& text12 = sve.text12;
  fem::str<8>& text13 = sve.text13;
  fem::str<8>& text14 = sve.text14;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  fem::str<8>& text7 = sve.text7;
  fem::str<8>& text8 = sve.text8;
  fem::str<8>& text9 = sve.text9;
  str_arr_ref<1> textmx(sve.textmx, dimension(2));
  if (is_called_first_time) {
    text2 = "   CON";
    text3 = "STANT ";
    text4 = "STEADY";
    text5 = " STATE";
    text6 = "A";
    text7 = "B";
    text8 = "C";
    text9 = "D";
    text10 = "E";
    text11 = "F";
    text12 = "G";
    text13 = "H";
    text14 = "I";
    textmx(1) = "+TR(  ";
    textmx(2) = "+TX(  ";
    ipsem = 0;
  }
  int iaddrs = fem::int0;
  int itranm = fem::int0;
  int ichtr2 = fem::int0;
  double xlong1 = fem::double0;
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int n45 = fem::int0;
  int n46 = fem::int0;
  int isecti = fem::int0;
  int numaki = fem::int0;
  double pdt0 = fem::double0;
  double h1 = fem::double0;
  double aa = fem::double0;
  double h3 = fem::double0;
  double xlong = fem::double0;
  fem::str<8> text1 = fem::char0;
  int ips1 = fem::int0;
  int ips2 = fem::int0;
  int ips3 = fem::int0;
  int n5 = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  int iprint = fem::int0;
  int mxphas = fem::int0;
  int n8 = fem::int0;
  int i = fem::int0;
  int n9 = fem::int0;
  int n10 = fem::int0;
  int n11 = fem::int0;
  int irow = fem::int0;
  int n9old = fem::int0;
  int nt1 = fem::int0;
  int nt2 = fem::int0;
  double pdt = fem::double0;
  int npz = fem::int0;
  double ak0zc = fem::double0;
  int npll = fem::int0;
  int n12 = fem::int0;
  int ii = fem::int0;
  int nn11 = fem::int0;
  int nn12 = fem::int0;
  int jj = fem::int0;
  int nycmp = fem::int0;
  int nn13 = fem::int0;
  int nk1 = fem::int0;
  int npza = fem::int0;
  double xsum = fem::double0;
  double ysum = fem::double0;
  int npa = fem::int0;
  int ntemp = fem::int0;
  double tauo = fem::double0;
  int nt13 = fem::int0;
  int nn17 = fem::int0;
  int j = fem::int0;
  double akr = fem::double0;
  double aki = fem::double0;
  double dddd = fem::double0;
  int inoff5 = fem::int0;
  int imarti = fem::int0;
  int iluis = fem::int0;
  double d17 = fem::double0;
  int ibr15 = fem::int0;
  double a = fem::double0;
  double h2 = fem::double0;
  int ntlin = fem::int0;
  int inoff1 = fem::int0;
  int inoff2 = fem::int0;
  int inoff3 = fem::int0;
  int inoff4 = fem::int0;
  int koff1 = fem::int0;
  int koff2 = fem::int0;
  int koff3 = fem::int0;
  int koff4 = fem::int0;
  int koff5 = fem::int0;
  int koff6 = fem::int0;
  int koff7 = fem::int0;
  int koff8 = fem::int0;
  int koff9 = fem::int0;
  int koff10 = fem::int0;
  int koff13 = fem::int0;
  int koff14 = fem::int0;
  int koff15 = fem::int0;
  int koff16 = fem::int0;
  int koff17 = fem::int0;
  int koff18 = fem::int0;
  int koff19 = fem::int0;
  int koff20 = fem::int0;
  int ncount = fem::int0;
  int nphs = fem::int0;
  int nphs2 = fem::int0;
  int nphsu = fem::int0;
  int ibr2 = fem::int0;
  int ibr3 = fem::int0;
  int np = fem::int0;
  int j1 = fem::int0;
  int nticpl = fem::int0;
  int j2 = fem::int0;
  int m = fem::int0;
  int jj1 = fem::int0;
  int jj2 = fem::int0;
  int iml = fem::int0;
  int intcpl = fem::int0;
  int jkl = fem::int0;
  int ip = fem::int0;
  int kl = fem::int0;
  int ifqt = fem::int0;
  int ifqq = fem::int0;
  int nrowt = fem::int0;
  int ik = fem::int0;
  int k = fem::int0;
  int ibrm = fem::int0;
  int ibrm1 = fem::int0;
  double d4 = fem::double0;
  static const char* format_105 = "(3e26.0)";
  static const char* format_18170 = "(2x,5e15.8)";
  static const char* format_18376 = "(2x,6e12.5)";
  static const char* format_191 = "(75x,i3)";
  static const char* format_6733 = "(i8,e32.20)";
  static const char* format_6741 = "(3e26.0)";
  static const char* format_6744 = "('+RESIDUALS',i3,'-',i2,'.',3e11.3)";
  static const char* format_6755 = "('+POLES',i3,'-',i2,'.',3e12.4)";
  static const char* format_7633 = "(i8,e32.20)";
  static const char* format_7641 = "(3e26.0)";
  static const char* format_7644 = "('+RESIDUALS',i3,'-',i2,'.',3e11.3)";
  static const char* format_7655 = "('+POLES',i3,'-',i2,'.',3e12.4)";
  static const char* format_8045 = "(26x,3e12.5,4i3)";
  static const char* format_8170 = "(2x,6e12.5)";
  //C!DIMENSION CBLHST(1)
  //C!EQUIVALENCE  ( CNVHST(1),  CBLHST(1) )
  //C!DIMENSION  WK1(1)
  //C!EQUIVALENCE ( SEMAUX(1), WK1(1) )
  //C!DIMENSION INFDLI(1)
  //C!EQUIVALENCE  ( NAMEBR(1),  INFDLI(1) )
  //C!EQUIVALENCE  (OMEGA, XLONG1 ),  ( INDTV(4), ICHTR2 )
  //C!EQUIVALENCE  (INDTV(1), IADDRS), (INDTV(2), ITRANM)
  //C     BURROUGHS: PRESERVE LOCAL VARIABLE BETWEEN MODULE CALLS:          M32.1216
  iaddrs = indtv(1);
  itranm = indtv(2);
  ichtr2 = indtv(4);
  xlong1 = omega;
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE DISTR2.\"')");
  }
  n45 = locint(ida);
  n46 = locint(ifkc);
  isecti = 400;
  if (iprsup >= 4) {
    write(6, star), " Top distr2.  N45, N46, IDA, IFKC =", n45, n46, ida, ifkc;
  }
  numaki = 0;
  lstat(18) = 0;
  pdt0 = 0;
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' BEGIN  \"DISTR2\" .','  ICHECK  MOLDAT     IBR   ITYPE',/,18x,4i8,"
      "/,1x)"),
      icheck, moldat, ibr, itype;
  }
  n13 = 0;
  if (icheck == 3) {
    goto statement_196;
  }
  if (icheck == 5) {
    goto statement_20000;
  }
statement_190:
  if (moldat == 0) {
    goto statement_3265;
  }
  //C     READ (ABUFF(1), 3241 )  TEXT1
  //C  3241 FORMAT ( 75X,  A1 )                                               M28.3343
  //C     IF ( TEXT1  .EQ.  BLANK )   GO TO 3265                            M28.3344
  read(abuff, "(26x,4e12.0,2i2)"), h1, aa, h3, xlong, iline, ipunch;
  if (xlong > 0.f) {
    goto statement_21633;
  }
  xlong = std::abs(xlong);
  read(abuff, "(78x,a1)"), text1;
  if (text1 == text6) {
    n13 = 10;
  }
  if (text1 == text7) {
    n13 = 11;
  }
  if (text1 == text8) {
    n13 = 12;
  }
  if (text1 == text9) {
    n13 = 13;
  }
  if (text1 == text10) {
    n13 = 14;
  }
  if (text1 == text11) {
    n13 = 15;
  }
  if (text1 == text12) {
    n13 = 16;
  }
  if (text1 == text13) {
    n13 = 17;
  }
  if (text1 == text14) {
    n13 = 18;
  }
  if (n13 != 0) {
    goto statement_21633;
  }
  read(abuff, "(78x,i1)"), n13;
  goto statement_21633;
statement_3265:
  read(abuff, format_191), ipsem;
  //C      IF (IPSEM .NE. 0) GO TO 21633                                    M44.  23
  if (ipsem != 0) {
    goto statement_8010;
  }
  read(abuff, "(26x,4e6.2,4i2)"), h1, aa, h3, xlong, iline, ipunch,
    n13, cmn.lint;
  //C 2345678901234567890123456789012345678901234567890123456789012345678901M43. 402
  if (iprsup >= 4) {
    write(6, star), " distr2, extract from col 55-56  N13 =", n13;
  }
  goto statement_21633;
  //C RECURSIVE CONVOLUTION BRANCH PROCESSING BEGINS HERE for Semlyem (LJG'sM28.3355
statement_8010:
  ipunch = fem::iabs(ipsem);
  if (ipunch <= 50) {
    goto statement_8030;
  }
  kill = 117;
  lstat(19) = 8030;
  goto statement_9999;
statement_8030:
  ips1 = -ipunch;
  ips2 = 0;
  ips3 = 0;
  n5 = ipsem;
statement_8040:
  read(abuff, format_8045), d1, d2, d3, n1, n2, n3, n4;
  if (ipsem != n5) {
    goto statement_8050;
  }
  if (n2 <= 0 || n2 > ipunch) {
    goto statement_8050;
  }
  n5 = n1 + (n2 - 1) * ipunch;
  if (n5 <= ips1) {
    goto statement_8050;
  }
  if (n5 != ips1 + ipunch + 1) {
    ips3 = 1;
  }
  if (ips2 <= ipunch || fem::iabs(mbus(ibr)) == 1) {
    goto statement_8060;
  }
statement_8050:
  kill = 169;
  lstat(19) = 8050;
  goto statement_9999;
statement_8060:
  kodebr(ibr) = ipunch;
  n6 = ifx;
  n7 = ifx;
  ifsem++;
  if (ifsem <= lfsem) {
    goto statement_8100;
  }
statement_8090:
  iprint = 20;
  lstat(19) = 8090;
  goto statement_9000;
statement_8100:
  sconst(ifsem) = d1;
  ci(ibr) = n3;
  ck(ibr) = n4;
  cik(ibr) = iaddrs;
  cki(ibr) = n5;
  indhst(ibr) = ifx + 1;
  ips1 = n5;
  ips2++;
  //C     MAKE LENGTH(IBR) CONDITIONAL FOR TORONTO.  6 OCT 1981:            M31. 541
  if (ips3 == 0) {
    length(ibr) = ipunch;
  }
  if (ipunch > mxphas) {
    mxphas = ipunch;
  }
  bus5 = text2;
  bus6 = text3;
  if (ipsem < 0) {
    goto statement_8140;
  }
  kodsem(ibr) = ifsem;
  if (noutpr == 0) {
    write(kunit6, "('+CONVOLUTION.',2e13.4,2i4)"), d1, d2, n1, n2;
  }
  if (n3 <= 0) {
    goto statement_8160;
  }
  n6++;
  if (n6 <= lhist) {
    goto statement_8130;
  }
statement_8120:
  iprint = 22;
  lstat(19) = 8120;
  goto statement_9000;
statement_8130:
  cnvhst(n6) = d2;
  if (d2 > deltat) {
    goto statement_8160;
  }
  kill = 197;
  lstat(19) = 8130;
  goto statement_9999;
statement_8140:
  kodsem(ibr) = -ifsem;
  if (noutpr == 0) {
    write(kunit6,
      "('+LUMPED ELEMENT CONVOLUTION (',i2,',',i2,')',1x,e10.3)"),
      n1, n2, d1;
  }
  ifsem++;
  if (ifsem > lfsem) {
    goto statement_8090;
  }
  ifx++;
  if (ifx > lhist) {
    goto statement_8120;
  }
  sconst(ifsem) = d2;
statement_8160:
  if (ips2 > ipunch) {
    goto statement_8190;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M28.3427
  cimage(cmn);
  n8 = n6 + 1;
  n6 += 5;
  if (n6 > lhist) {
    goto statement_8120;
  }
  if (kolbeg <= 0) {
    goto statement_8161;
  }
  nfrfld = 5;
  frefld(cmn, cnvhst(n8));
  goto statement_8162;
statement_8161:
  if (moldat == 1) {
    goto statement_18161;
  }
  {
    read_loop rloop(abuff(1), format_18170);
    FEM_DO_SAFE(i, n8, n6) {
      rloop, cnvhst(i);
    }
  }
  goto statement_8162;
statement_18161:
  {
    read_loop rloop(abuff(1), format_8170);
    FEM_DO_SAFE(i, n8, n6) {
      rloop, cnvhst(i);
    }
  }
statement_8162:
  d1 = cnvhst(n6);
  cnvhst(n6) = cnvhst(n6) * twopi;
  if (noutpr == 0) {
    write(kunit6, "('+PHASOR Z,Y.',3e12.4)"), cnvhst(n8), cnvhst(n8 + 1),
      cnvhst(n8 + 2);
  }
statement_8190:
  switch (fem::if_arithmetic(n3)) {
  case -1: goto statement_8200;
  case  0: goto statement_8270;
  default: goto statement_8240;
  }
statement_8200:
  n9 = 0;
  numaki = 1;
statement_8205:
  n8 = ifsem + 1;
  n10 = -n3 - n9;
  if (n10 > 3) {
    n10 = 3;
  }
  ifsem += n10 + n10;
  if (ifsem > lfsem) {
    goto statement_8090;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M28.3454
  cimage(cmn);
  if (kolbeg <= 0) {
    goto statement_8206;
  }
  nfrfld = ifsem - n8 + 1;
  frefld(cmn, sconst(n8));
  goto statement_8208;
statement_8206:
  {
    read_loop rloop(abuff(1), format_8170);
    FEM_DO_SAFE(i, n8, ifsem) {
      rloop, sconst(i);
    }
  }
statement_8208:
  if (n9 == 0) {
    goto statement_8207;
  }
  if (sconst(n8) - sconst(n8 - 2) < deltat) {
    goto statement_8210;
  }
statement_8207:
  if (n9 == 0 && sconst(n8) < deltat) {
    goto statement_8210;
  }
  if (n10 <= 1) {
    goto statement_8220;
  }
  if (sconst(n8 + 2) - sconst(n8) < deltat) {
    goto statement_8210;
  }
  if (n10 <= 2) {
    goto statement_8220;
  }
  if (sconst(n8 + 4) - sconst(n8 + 2) > deltat) {
    goto statement_8220;
  }
statement_8210:
  kill = 197;
  lstat(19) = 8210;
  goto statement_9999;
statement_8220:
  n8 = n9 + 1;
  n9 += n10;
  if (noutpr == 0) {
    write(kunit6,
      "('+AMETANI PROPAGATION IMPULSE, SEGMENTS ',i3,' THRU ',i3)"),
      n8, n9;
  }
  if (n9 < -n3) {
    goto statement_8205;
  }
  if (d2 <= 0.0f) {
    d2 = tmax;
  }
  if (d2 - sconst(ifsem - 1) < deltat && d2 > sconst(ifsem - 1)) {
    goto statement_8210;
  }
  sconst(ifsem) = (cmn.unity - sconst(ifsem)) / (d2 - sconst(ifsem - 1));
  if (sconst(ifsem) < 0.0f) {
    sconst(ifsem) = 0.0f;
  }
  ifx += 2;
  if (ifx > lhist) {
    goto statement_8120;
  }
  goto statement_8270;
statement_8240:
  n9 = 0;
statement_8250:
  n8 = ifsem + 1;
  n10 = n3 - n9;
  if (n10 > 2) {
    n10 = 2;
  }
  n11 = 3 * n10;
  ifsem += 5 * n10;
  if (ifsem > lfsem) {
    goto statement_8090;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M28.3493
  cimage(cmn);
  if (kolbeg <= 0) {
    goto statement_8251;
  }
  nfrfld = n11;
  frefld(cmn, voltbc(1));
  goto statement_8252;
statement_8251:
  {
    read_loop rloop(abuff(1), format_8170);
    FEM_DO_SAFE(i, 1, n11) {
      rloop, voltbc(i);
    }
  }
statement_8252:
  n11 = 1;
  FEM_DOSTEP(i, n8, ifsem, 5) {
    sconst(i + 0) = voltbc(n11 + 0);
    sconst(i + 1) = voltbc(n11 + 1);
    sconst(i + 2) = voltbc(n11 + 2);
    n11 += 3;
    if (sconst(i) >= 0.0f) {
      goto statement_8254;
    }
  statement_8254:;
  }
  n8 = n9 + 1;
  n9 += n10;
  if (noutpr == 0) {
    write(kunit6, "('+PROPAGATION EXP.',i3,'-',i2,'. ',2e12.3)"), n8,
      n9, voltbc(1), voltbc(2);
  }
  if (n9 < n3) {
    goto statement_8250;
  }
  ifx += n3 + n3;
  if (ifx > lhist) {
    goto statement_8120;
  }
statement_8270:
  switch (fem::if_arithmetic(n4)) {
  case -1: goto statement_8280;
  case  0: goto statement_8340;
  default: goto statement_8310;
  }
statement_8280:
  n9 = 0;
statement_8290:
  n8 = ifsem + 1;
  n10 = -n4 - n9;
  if (n10 > 3) {
    n10 = 3;
  }
  ifsem += n10 + n10;
  if (ifsem > lfsem) {
    goto statement_8090;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M28.3525
  cimage(cmn);
  if (kolbeg <= 0) {
    goto statement_8291;
  }
  nfrfld = ifsem - n8 + 1;
  frefld(cmn, sconst(n8));
  goto statement_8293;
statement_8291:
  {
    read_loop rloop(abuff(1), format_8170);
    FEM_DO_SAFE(i, n8, ifsem) {
      rloop, sconst(i);
    }
  }
statement_8293:
  if (n9 == 0) {
    goto statement_8292;
  }
  if (sconst(n8) - sconst(n8 - 2) < deltat) {
    goto statement_8210;
  }
statement_8292:
  if (n9 == 0 && sconst(n8) != 0.0f) {
    goto statement_8210;
  }
  if (n10 <= 1) {
    goto statement_8294;
  }
  if (sconst(n8 + 2) - sconst(n8) < deltat) {
    goto statement_8210;
  }
  if (n10 <= 2) {
    goto statement_8294;
  }
  if (sconst(n8 + 4) - sconst(n8 + 2) < deltat) {
    goto statement_8210;
  }
statement_8294:
  n8 = n9 + 1;
  n9 += n10;
  if (noutpr == 0) {
    write(kunit6,
      "('+AMETANI ADMITTANCE IMPULSE, SEGMENT ',i3,' THRU ',i3)"),
      n8, n9;
  }
  if (n9 < -n4) {
    goto statement_8290;
  }
  if (d3 <= 0.0f) {
    d3 = tmax;
  }
  if (d3 - sconst(ifsem - 1) < deltat && d3 > sconst(ifsem - 1)) {
    goto statement_8210;
  }
  sconst(ifsem) = sconst(ifsem) / (d3 - sconst(ifsem - 1));
  if (d3 < sconst(ifsem - 1)) {
    sconst(ifsem) = 0.0f;
  }
  ifx++;
  if (ipsem > 0) {
    ifx++;
  }
  if (ifx > lhist) {
    goto statement_8120;
  }
  goto statement_8340;
statement_8310:
  n9 = 0;
statement_8320:
  n8 = ifsem + 1;
  n10 = n4 - n9;
  if (n10 > 2) {
    n10 = 2;
  }
  n11 = 3 * n10;
  ifsem += 4 * n10;
  if (ifsem > lfsem) {
    goto statement_8090;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M28.3562
  cimage(cmn);
  if (kolbeg <= 0) {
    goto statement_8321;
  }
  nfrfld = n11;
  frefld(cmn, voltbc(1));
  goto statement_8322;
statement_8321:
  {
    read_loop rloop(abuff(1), format_8170);
    FEM_DO_SAFE(i, 1, n11) {
      rloop, voltbc(i);
    }
  }
statement_8322:
  n11 = 1;
  FEM_DOSTEP(i, n8, ifsem, 4) {
    sconst(i + 0) = voltbc(n11 + 0);
    sconst(i + 1) = voltbc(n11 + 1);
    sconst(i + 2) = voltbc(n11 + 2);
    n11 += 3;
    if (sconst(i) >= 0.0f) {
      goto statement_8324;
    }
  statement_8324:;
  }
  n8 = n9 + 1;
  n9 += n10;
  if (noutpr == 0) {
    write(kunit6, "('+ADMITTANCE  EXP.',i3,'-',i2,'. ',2e12.3)"), n8,
      n9, voltbc(1), voltbc(2);
  }
  if (n9 < n4) {
    goto statement_8320;
  }
  ifx += n4;
  if (ipsem > 0) {
    ifx += n4;
  }
  if (ifx > lhist) {
    goto statement_8120;
  }
statement_8340:
  if (n6 > ifx) {
    ifx = n6;
  }
  nr(ibr) = ifx - n7;
  icheck = 5;
  nrecur++;
  if (nrecur == ipunch) {
    goto statement_8351;
  }
  goto statement_100;
statement_8350:
  if (fem::iabs(mbus(ibr)) == ntot) {
    ntot = ntot - 1;
  }
  if (fem::iabs(kbus(ibr)) == ntot) {
    ntot = ntot - 1;
  }
  ibr = ibr - 1;
statement_8351:
  cki(ibr) = -cki(ibr);
  if (ips3 == 0) {
    goto statement_8357;
  }
  n1 = -iadd - 1;
  n2 = ibr - ips2 + 1;
  FEM_DO_SAFE(i, n2, ibr) {
    cik(i) = n1;
  }
  bus5 = text4;
  bus6 = text5;
statement_8357:
  n1 = iaddrs - 1;
  n3 = ipunch * ipunch;
  iadd = iaddrs + n3 + n3 - 1;
  if (iadd <= lfd) {
    goto statement_8360;
  }
  iprint = 21;
  lstat(19) = 8360;
  goto statement_9000;
statement_8360:
  n2 = n1 + n3;
  n4 = 1;
  n5 = 1;
  n8 = ipunch * 2;
  //C                   !total # of elements in matrix for thE coupled groupM43. 412
  irow = 0;
  //C     READ INPUT CARD USING CIMAGE                                      M28.3619
statement_8370:
  cimage(cmn);
  if (kolbeg <= 0) {
    goto statement_8376;
  }
statement_18375:
  irow++;
  n9old = (irow - 1) * 6;
  n9 = irow * 6;
  if (n8 < n9) {
    goto statement_38376;
  }
  nfrfld = 6;
  goto statement_18377;
statement_38376:
  nfrfld = n8 - n9old;
  if (nfrfld > 0) {
    goto statement_18377;
  }
  irow = 0;
  goto statement_18375;
statement_18377:
  frefld(cmn, voltbc(1));
  goto statement_8377;
statement_8376:
  {
    read_loop rloop(abuff(1), format_18376);
    FEM_DO_SAFE(i, 1, 6) {
      rloop, voltbc(i);
    }
  }
statement_8377:
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, "('+[TV] ROW',i3,'.',3e12.3)");
      wloop, n5;
      FEM_DO_SAFE(i, 1, 3) {
        wloop, voltbc(i);
      }
    }
  }
  FEM_DOSTEP(i, 1, 5, 2) {
    n6 = n4 + n1;
    sfd(n6) = voltbc(i);
    if (numaki == 0) {
      goto statement_8381;
    }
    n4 += ipunch;
    if (n4 > n3) {
      goto statement_8400;
    }
    sfd(n4) = voltbc(i + 1);
    goto statement_8382;
  statement_8381:
    n6 = n4 + n2;
    sfd(n6) = voltbc(i + 1);
  statement_8382:
    n4 += ipunch;
    if (n4 > n3) {
      goto statement_8400;
    }
  }
  goto statement_8370;
statement_8400:
  n5++;
  n4 = n5;
  if (n5 <= ipunch) {
    goto statement_8370;
  }
  n4 = 1;
  n5 = 1;
  irow = 0;
  //C     READ INPUT CARD USING CIMAGE                                      M28.3661
statement_8410:
  cimage(cmn);
  if (kolbeg <= 0) {
    goto statement_8415;
  }
statement_28375:
  irow++;
  n9old = (irow - 1) * 6;
  n9 = irow * 6;
  if (n8 < n9) {
    goto statement_28376;
  }
  nfrfld = 6;
  goto statement_28377;
statement_28376:
  nfrfld = n8 - n9old;
  if (nfrfld > 0) {
    goto statement_28377;
  }
  irow = 0;
  goto statement_28375;
statement_28377:
  frefld(cmn, voltbc(1));
  goto statement_8417;
statement_8415:
  {
    read_loop rloop(abuff(1), format_18376);
    FEM_DO_SAFE(i, 1, 6) {
      rloop, voltbc(i);
    }
  }
statement_8417:
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, "('+[TI] ROW',i3,'.',3e12.3)");
      wloop, n5;
      FEM_DO_SAFE(i, 1, 3) {
        wloop, voltbc(i);
      }
    }
  }
  FEM_DOSTEP(i, 1, 5, 2) {
    n6 = n4 + n1;
    qfd(n6) = voltbc(i);
    if (numaki == 0) {
      goto statement_8421;
    }
    n4 += ipunch;
    if (n4 > n3) {
      goto statement_8440;
    }
    qfd(n4) = voltbc(i + 1);
    goto statement_8422;
  statement_8421:
    n6 = n4 + n2;
    qfd(n6) = voltbc(i + 1);
  statement_8422:
    n4 += ipunch;
    if (n4 > n3) {
      goto statement_8440;
    }
  }
  goto statement_8410;
statement_8440:
  n5++;
  n4 = n5;
  if (n5 <= ipunch) {
    goto statement_8410;
  }
  icheck = 1;
  nrecur = 0;
  iaddrs = iadd + 1;
  indtv(1) = iaddrs;
  goto statement_100;
statement_20000:
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  read(abuff, format_191), n5;
  if (n5 == 0) {
    goto statement_8350;
  }
  goto statement_8040;
  //C     END OF RECURSIVE CONVOLUTION BRANCH INPUT ************************M28.3706
  //C
statement_21633:
  if (ipsem != 0) {
    imodel(ibr) = -4;
  }
  if (ipsem == 0) {
    goto statement_1923;
  }
  read(abuff, format_8045), d1, d2, d3, nt1, nt2, n3, n4;
statement_1923:
  if (ipsem == 0) {
    imodel(ibr) = ipunch;
  }
  if (imodel(ibr) != -4) {
    goto statement_76893;
  }
  //C     1 .AND.IMODEL(IBR).NE.-2)GO TO 76893    !If not Marti model bapassM44.  26
  pdt0 = aa;
  if (pdt0 >= 1.f || pdt0 == 0.f) {
    goto statement_6100;
  }
  pdt0 = 1.f;
  write(lunit6,
    "(/,/,' A TOO LOW VALUE OF P*DELTAT WAS READ. P*DELTAT CHANGED  TO 1.',/,"
    "/)");
statement_6100:
  pdt = pdt0;
  ifx++;
  if (ifx > lhist) {
    goto statement_8120;
  }
  ifsem++;
  if (ifsem > lfsem) {
    goto statement_8090;
  }
  if (ipsem != 0) {
    itype = itype - 1;
  }
  if (ipsem == 0) {
    goto statement_1989;
  }
  if (noutpr == 0) {
    write(kunit6, "(' Semlyen''s  MODE',i3,'  parameters begin')"), nt1;
  }
  cki(ibr) = n4;
  npz = n4;
  sconst(ifsem) = d1;
  kodsem(ibr) = ifsem;
  indhst(ibr) = ifx;
  goto statement_1988;
statement_1989:
  n11 = -itype;
  if (noutpr == 0) {
    write(kunit6, "(' Cable MODE',i3,'  parameters begin')"), n11;
  }
  aa = noutpr;
  if (h1 == 2.0f) {
    noutpr = 1;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M43. 437
  cimage(cmn);
  read(abuff, format_6733), npz, ak0zc;
  cki(ibr) = npz;
  sconst(ifsem) = ak0zc;
  kodsem(ibr) = ifsem;
  indhst(ibr) = ifx;
  if (noutpr != 0) {
    npll = noutpr;
  }
  if (noutpr == 0) {
    write(kunit6, "('+Yc BEGINS. ORDER, Yc(INFINITY) =',i5,e11.3)"), npz, ak0zc;
  }
  if (h1 == 1.0f) {
    noutpr = 1;
  }
  n11 = 1;
statement_6738:
  n12 = n11 + 2;
  if (n12 > npz) {
    n12 = npz;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M43. 453
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_6741);
    FEM_DO_SAFE(ii, n11, n12) {
      rloop, voltbc(ii);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, format_6744);
      wloop, n11, n12;
      FEM_DO_SAFE(ii, n11, n12) {
        wloop, voltbc(ii);
      }
    }
  }
  nn11 = n11 + ifsem;
  nn12 = n12 + ifsem;
  i = n11;
  FEM_DO_SAFE(jj, nn11, nn12) {
    sconst(jj) = voltbc(i);
    i++;
  }
  n11 += 3;
  if (n11 <= npz) {
    goto statement_6738;
  }
  nycmp = 0;
  n11 = 1;
statement_6753:
  n12 = n11 + 2;
  if (n12 > npz) {
    n12 = npz;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M31. 619
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_6741);
    FEM_DO_SAFE(ii, n11, n12) {
      rloop, voltbc(ii);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, lunit6, format_6755);
      wloop, n11, n12;
      FEM_DO_SAFE(ii, n11, n12) {
        wloop, voltbc(ii);
      }
    }
  }
  nn11 = nn12 + n11;
  nn13 = nn12 + n12;
  i = n11;
  FEM_DO_SAFE(jj, nn11, nn13) {
    sconst(jj) = voltbc(i);
    if (sconst(jj) >= 1.e+14f || sconst(jj) <= -1.e+14f) {
      nycmp++;
    }
    i++;
  }
  n11 += 3;
  if (n11 <= npz) {
    goto statement_6753;
  }
  //C     GO TO 3567                                                        M44.  43
  nycmp = nycmp * 3;
  nk1 = ifx + 19 + 1;
  cnvhst(nk1) = nycmp;
  if (h1 == 1.0f) {
    noutpr = aa;
  }
  if (pdt0 == 0.f) {
    goto statement_45000;
  }
  npza = npz;
  ii = 0;
statement_40021:
  n11 = ifsem + npza + ii + 1;
  n12 = n11 + npza - 1;
  xsum = 0.f;
  ysum = 0.f;
  FEM_DO_SAFE(jj, n11, n12) {
    if (sconst(jj) * deltat < pdt) {
      goto statement_40000;
    }
    goto statement_40001;
  statement_40000:;
  }
  goto statement_40007;
statement_40001:
  if (jj == n11) {
    jj++;
  }
  if (jj == n12) {
    goto statement_40007;
  }
  FEM_DO_SAFE(i, jj, n12) {
    nn11 = i - npza;
    xsum += sconst(nn11) / sconst(i);
    ysum += sconst(nn11) / fem::pow2(sconst(i));
  }
  ysum = xsum / ysum;
  if (ysum * deltat >= pdt) {
    goto statement_40030;
  }
  pdt += 1.f;
  goto statement_40021;
statement_40030:
  nn11 = jj - npza;
  if (ii != 0) {
    goto statement_40003;
  }
  pdt = pdt0;
  npz = npz - n12 + jj;
  cki(ibr) = npz;
  goto statement_40004;
statement_40003:
  npa = npa - n12 + jj;
  ckkjm(ibr) = npa;
statement_40004:
  sconst(nn11) = ysum * xsum;
  sconst(jj) = ysum;
  i = n12 - jj + 1;
  if (ii == 0 && noutpr == 0) {
    write(lunit6, "(' Z0 EQUIVALENCE.  I, R*P, P =',i5,2e20.13)"), i,
      sconst(nn11), sconst(jj);
  }
  if (ii != 0 && noutpr == 0) {
    write(lunit6, "(' A1 EQUIVALENCE.  I, R*P, P =',i5,2e20.13)"), i,
      sconst(nn11), sconst(jj);
  }
  //C      IF(PDT.NE.PDT0)                                                  M43. 528
  //C     1 WRITE(LUNIT6,40031)PDT                                          M43. 529
  //C40031 FORMAT(//' *** NOTE - PDT CHANGED TO *** ',F7.2//)               M43. 530
  n12 = n12 - i + 1;
  jj = nn11;
  FEM_DO_SAFE(i, n11, n12) {
    jj++;
    sconst(jj) = sconst(i);
  }
  nn13 = jj;
  //CCCC     POINTER FOR NO. OF COMPLEX POLES MUST BE RESET AFTER POLE
  //CCCC     REDUCTION, THL.  MARCH 20, 1990
  //CCCC     40007 IF(II.NE.0)GO TO 40022
statement_40007:
  if (ii == 0) {
    goto statement_3179;
  }
  //C SAVE NO. OF COMPLEX POLES
  ntemp = sconst(nk1);
  //C DEFINE THE NEW POINTER
  nk1 = ifsem + 5 * (npa + npz + 1);
  //C STORE THE NUMBER IN THE NEW CELL
  sconst(nk1) = ntemp;
  goto statement_40022;
  //CCCC  END OF THL'S CORRECTION, MARCH 20, 1990
  //C     READ INPUT CARD USING CIMAGE                                      M31. 635
statement_3179:
  if (ipsem == 0) {
    goto statement_45000;
  }
statement_1988:
  tauo = d2;
  npa = n3;
  goto statement_1992;
statement_45000:
  cimage(cmn);
  //C 3456789012345678901234567890123456789012345678901234567890123456789012M43. 541
  read(abuff, format_6733), npa, tauo;
statement_1992:
  if (tauo > deltat) {
    goto statement_6756;
  }
  kill = 197;
  flstat(14) = tauo;
  lstat(19) = 6756;
  goto statement_9999;
statement_6756:
  ckkjm(ibr) = npa;
  if (ipsem != 0) {
    goto statement_2016;
  }
  if (noutpr == 0) {
    write(lunit6, "('+A1 BEGINS. ORDER, TAU(SEC) =',i6,e14.5)"), npa, tauo;
  }
  if (h1 == 1.0f) {
    noutpr = 1;
  }
statement_2016:
  if (ipsem == 0) {
    goto statement_2002;
  }
  cimage(cmn);
  n8 = ifx + 15;
  n6 = ifx + 19;
  {
    read_loop rloop(abuff(1), format_18170);
    FEM_DO_SAFE(i, n8, n6) {
      rloop, cnvhst(i);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, "(' Phasor Z-Y.',3e12.3)");
      FEM_DO_SAFE(i, n8, n6) {
        wloop, cnvhst(i);
      }
    }
  }
  n11 = npz * 2 + ifsem + 1;
  nt13 = n11 + npa;
  nn17 = 0;
  FEM_DO_SAFE(j, 1, npa / 2) {
    cimage(cmn);
    nfrfld = 6;
    if (kolbeg <= 0) {
      goto statement_1993;
    }
    frefld(cmn, voltbc(1));
    goto statement_1994;
  statement_1993:
    {
      read_loop rloop(abuff(1), format_8170);
      FEM_DO_SAFE(i, 1, nfrfld) {
        rloop, voltbc(i);
      }
    }
  statement_1994:
    n12 = 1;
    if (noutpr == 0) {
      {
        write_loop wloop(cmn, kunit6, "(' Propagation Exp.',2e12.3)");
        FEM_DO_SAFE(ii, 1, nfrfld) {
          wloop, voltbc(ii);
        }
      }
    }
    FEM_DOSTEP(i, 1, 6, 3) {
      if (voltbc(n12) == -1) {
        goto statement_2022;
      }
      if (voltbc(n12) != 1) {
        goto statement_2021;
      }
      nn17++;
      akr = voltbc(n12 + 2) * voltbc(n12 + 1) - voltbc(n12 + 5) *
        voltbc(n12 + 4);
      akr = voltbc(n12 + 2);
      akr = akr * 1.e+15f;
      aki = voltbc(n12 + 2) * voltbc(n12 + 4) + voltbc(n12 + 5) *
        voltbc(n12 + 1);
      aki = voltbc(n12 + 5);
      aki = aki * 1.e+15f;
      voltbc(n12 + 2) = akr;
      voltbc(n12 + 5) = aki;
      goto statement_2022;
    statement_2021:
      dddd = voltbc(n12 + 1) * voltbc(n12 + 2);
      sconst(n11) = dddd;
      if (voltbc(n12 + 1) == 0) {
        voltbc(n12 + 1) = 1.f;
      }
      sconst(nt13) = voltbc(n12 + 1);
      goto statement_2023;
    statement_2022:
      sconst(n11) = voltbc(n12 + 2);
      sconst(nt13) = voltbc(n12 + 1) * 1.e+15f;
    statement_2023:
      n12 += 3;
      n11++;
      nt13++;
    }
  }
  n11 = ifsem + 1;
  n13 = n11 + npz;
  FEM_DO_SAFE(j, 1, npz / 2) {
    cimage(cmn);
    nfrfld = 6;
    if (kolbeg <= 0) {
      goto statement_1998;
    }
    frefld(cmn, voltbc(1));
    goto statement_1999;
  statement_1998:
    {
      read_loop rloop(abuff(1), format_8170);
      FEM_DO_SAFE(i, 1, nfrfld) {
        rloop, voltbc(i);
      }
    }
  statement_1999:
    n12 = 1;
    if (noutpr == 0) {
      {
        write_loop wloop(cmn, kunit6, "(' Char. Admt. Exp.',2e12.3)");
        FEM_DO_SAFE(ii, 1, nfrfld) {
          wloop, voltbc(ii);
        }
      }
    }
    FEM_DOSTEP(i, 1, 6, 3) {
      dddd = voltbc(n12 + 1) * voltbc(n12 + 2);
      sconst(n11) = dddd;
      if (voltbc(n12 + 1) == 0) {
        voltbc(n12 + 1) = 1.f;
      }
      sconst(n13) = voltbc(n12 + 1);
      n12 += 3;
      n11++;
      n13++;
    }
  }
  nn17 = nn17 * 2;
  goto statement_2001;
statement_2002:
  n11 = 1;
statement_6764:
  n12 = n11 + 2;
  if (n12 > npa) {
    n12 = npa;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M31. 646
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_6741);
    FEM_DO_SAFE(ii, n11, n12) {
      rloop, voltbc(ii);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, format_6744);
      wloop, n11, n12;
      FEM_DO_SAFE(ii, n11, n12) {
        wloop, voltbc(ii);
      }
    }
  }
  nn11 = nn13 + n11;
  nn12 = nn13 + n12;
  i = n11;
  FEM_DO_SAFE(jj, nn11, nn12) {
    sconst(jj) = voltbc(i);
    i++;
  }
  n11 += 3;
  if (n11 <= npa) {
    goto statement_6764;
  }
  nn17 = 0;
  n11 = 1;
statement_6772:
  n12 = n11 + 2;
  if (n12 > npa) {
    n12 = npa;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M31. 663
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_6741);
    FEM_DO_SAFE(ii, n11, n12) {
      rloop, voltbc(ii);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, lunit6, format_6755);
      wloop, n11, n12;
      FEM_DO_SAFE(ii, n11, n12) {
        wloop, voltbc(ii);
      }
    }
  }
  nn11 = nn12 + n11;
  nn13 = nn12 + n12;
  i = n11;
  FEM_DO_SAFE(jj, nn11, nn13) {
    sconst(jj) = voltbc(i);
    if (sconst(jj) >= 1.e+14f || sconst(jj) <= -1.e+14f) {
      nn17++;
    }
    i++;
  }
  n11 += 3;
  if (n11 <= npa) {
    goto statement_6772;
  }
statement_2001:
  nn17 = nn17 * 3;
  nk1 = ifsem + 5 * npa + 5 * npz + 4 + 1;
  sconst(nk1) = nn17;
  //C      IF ( IMODEL(IBR) .EQ. -4 )    GO TO 40022                        M44. 138
  if (pdt == 0.f) {
    goto statement_40022;
  }
  ii = 2 * npz;
  npza = npa;
  goto statement_40021;
statement_40022:
  noutpr = aa;
  cnvhst(ifx) = tauo;
  //C                                                                       M43. 594
  inoff5 = 5 * lbrnch;
  namebr(inoff5 + ibr) = cnvhst(ifx) / deltat + 1;
  //C                                                                       M43. 598
  ifx += 19 + 1 + nycmp;
  if (ifx > lhist) {
    goto statement_8120;
  }
  ifsem += 11 * npa + nn17 + 7 * npz + 9;
  if (kcount == model || nt1 == ipsem) {
    ifq = ifsem;
  }
  if (ifsem > lfsem) {
    goto statement_8090;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(' DONE MARTI CARDS.  IFX, NPZ, NPA, IBR,IFSEM =',5i6)"), ifx,
      npz, npa, ibr, ifsem;
  }
  icheck = 3;
  length(ibr1) = kcount;
  if (kcount > mxphas) {
    mxphas = kcount;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(' BELOW 21105. ITYPE, N13, MODEL, IPUNCH =',4i6)"), itype,
      n13, model, ipunch;
  }
  //C     IF ( IPUNCH  .NE.  -4                                             M43. 615
  //C    1    .AND. IPSEM .EQ. 0)   GO TO 100          !flag for jose's caseM44. 139
  if (ipsem != 0 && nt1 == ipsem) {
    goto statement_50050;
  }
  if (kcount == model) {
    goto statement_50050;
  }
  if (kcount != 1) {
    goto statement_100;
  }
  if (n13 < 1) {
    goto statement_100;
  }
  model = n13;
  if (ipsem != 0) {
    model = ipsem;
  }
  litype(ibr) = iaddrs;
  if (iprsup >= 1) {
    write(lunit6,
      "('   Cable MODEL FOR UNTRANSPOSED LINE, MODEL, IADDRS, IBR1 =',3i10)"),
      model, iaddrs, ibr1;
  }
  if (n13 == 1) {
    goto statement_50050;
  }
  goto statement_100;
  //C                                                                       M43. 626
  //C                                                                       M43. 627
  //C
statement_76893:
  imodel(ibr) = ipunch;
  if (ipunch != -2) {
    goto statement_10105;
  }
  //C     BEGINNING OF INPUT FOR Jose MARTI'S BRANCHES                      M31. 572
  if (ipunch != -2) {
    imarti++;
  }
  if (iluis != 0) {
    write(lunit6, "(' Attantion. You have mixed Luis- with Jose- model')");
  }
  pdt0 = aa;
  if (pdt0 >= 1.f || pdt0 == 0.f) {
    goto statement_6000;
  }
  pdt0 = 1.f;
  write(lunit6,
    "(/,/,' A TOO LOW VALUE OF P*DELTAT WAS READ. P*DELTAT CHANGED  TO 1.',/,"
    "/)");
statement_6000:
  pdt = pdt0;
  //C 3456789012345678901234567890123456789012345678901234567890123456789012M43. 635
  ifx++;
  if (ifx > lhist) {
    goto statement_8120;
  }
  ifsem++;
  if (ifsem > lfsem) {
    goto statement_8090;
  }
  n11 = -itype;
  if (noutpr == 0) {
    write(kunit6, "('+MARTI TRANSMISSION MODE',i3,'  PARAMETERS BEGIN.')"), n11;
  }
  aa = noutpr;
  if (h1 == 2.0f) {
    noutpr = 1;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M31. 584
  cimage(cmn);
  read(abuff, format_7633), npz, ak0zc;
  cki(ibr) = npz;
  sconst(ifsem) = ak0zc;
  kodsem(ibr) = ifsem;
  indhst(ibr) = ifx;
  if (noutpr == 0) {
    write(kunit6, "('+ZC BEGINS. ORDER, ZC(INFINITY) =',i5,e11.3)"), npz, ak0zc;
  }
  if (h1 == 1.0f) {
    noutpr = 1;
  }
  n11 = 1;
statement_7638:
  n12 = n11 + 2;
  if (n12 > npz) {
    n12 = npz;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M31. 600
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_7641);
    FEM_DO_SAFE(ii, n11, n12) {
      rloop, voltbc(ii);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, format_7644);
      wloop, n11, n12;
      FEM_DO_SAFE(ii, n11, n12) {
        wloop, voltbc(ii);
      }
    }
  }
  nn11 = n11 + ifsem;
  nn12 = n12 + ifsem;
  i = n11;
  FEM_DO_SAFE(jj, nn11, nn12) {
    sconst(jj) = voltbc(i);
    i++;
  }
  n11 += 3;
  if (n11 <= npz) {
    goto statement_7638;
  }
  n11 = 1;
statement_7653:
  n12 = n11 + 2;
  if (n12 > npz) {
    n12 = npz;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M31. 619
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_7641);
    FEM_DO_SAFE(ii, n11, n12) {
      rloop, voltbc(ii);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, lunit6, format_7655);
      wloop, n11, n12;
      FEM_DO_SAFE(ii, n11, n12) {
        wloop, voltbc(ii);
      }
    }
  }
  nn11 = nn12 + n11;
  nn13 = nn12 + n12;
  i = n11;
  FEM_DO_SAFE(jj, nn11, nn13) {
    sconst(jj) = voltbc(i);
    i++;
  }
  n11 += 3;
  if (n11 <= npz) {
    goto statement_7653;
  }
  if (h1 == 1.0f) {
    noutpr = aa;
  }
  if (pdt0 == 0.f) {
    goto statement_55000;
  }
  npza = npz;
  ii = 0;
statement_50021:
  n11 = ifsem + npza + ii + 1;
  n12 = n11 + npza - 1;
  xsum = 0.f;
  ysum = 0.f;
  FEM_DO_SAFE(jj, n11, n12) {
    if (sconst(jj) * deltat < pdt) {
      goto statement_50000;
    }
    goto statement_50001;
  statement_50000:;
  }
  goto statement_50007;
statement_50001:
  if (jj == n11) {
    jj++;
  }
  if (jj == n12) {
    goto statement_50007;
  }
  FEM_DO_SAFE(i, jj, n12) {
    nn11 = i - npza;
    xsum += sconst(nn11) / sconst(i);
    ysum += sconst(nn11) / fem::pow2(sconst(i));
  }
  ysum = xsum / ysum;
  if (ysum * deltat >= pdt) {
    goto statement_50030;
  }
  pdt += 1.f;
  goto statement_50021;
statement_50030:
  nn11 = jj - npza;
  if (ii != 0) {
    goto statement_50003;
  }
  pdt = pdt0;
  npz = npz - n12 + jj;
  cki(ibr) = npz;
  goto statement_50004;
statement_50003:
  npa = npa - n12 + jj;
  ckkjm(ibr) = npa;
statement_50004:
  sconst(nn11) = ysum * xsum;
  sconst(jj) = ysum;
  i = n12 - jj + 1;
  if (ii == 0 && noutpr == 0) {
    write(lunit6, "(' Z0 EQUIVALENCE.  I, R*P, P =',i5,2e20.13)"), i,
      sconst(nn11), sconst(jj);
  }
  if (ii != 0 && noutpr == 0) {
    write(lunit6, "(' A1 EQUIVALENCE.  I, R*P, P =',i5,2e20.13)"), i,
      sconst(nn11), sconst(jj);
  }
  //C      IF(PDT.NE.PDT0 .AND. NOUTPR .EQ. 0)                              M43. 675
  //C     1 WRITE(LUNIT6,50031)PDT                                          M43. 676
  //C50031 FORMAT(//' *** NOTE - PDT CHANGED TO *** ',F7.2//)               M43. 677
  n12 = n12 - i + 1;
  jj = nn11;
  FEM_DO_SAFE(i, n11, n12) {
    jj++;
    sconst(jj) = sconst(i);
  }
  nn13 = jj;
statement_50007:
  if (ii != 0) {
    goto statement_50022;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M31. 635
statement_55000:
  cimage(cmn);
  //C 3456789012345678901234567890123456789012345678901234567890123456789012M43. 686
  read(abuff, format_7633), npa, tauo;
  if (tauo > deltat) {
    goto statement_7656;
  }
  kill = 197;
  flstat(14) = tauo;
  lstat(19) = 7656;
  goto statement_9999;
statement_7656:
  ckkjm(ibr) = npa;
  if (noutpr == 0) {
    write(lunit6, "('+A1 BEGINS. ORDER, TAU(SEC) =',i6,e14.5)"), npa, tauo;
  }
  if (h1 == 1.0f) {
    noutpr = 1;
  }
  n11 = 1;
statement_7664:
  n12 = n11 + 2;
  if (n12 > npa) {
    n12 = npa;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M31. 646
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_7641);
    FEM_DO_SAFE(ii, n11, n12) {
      rloop, voltbc(ii);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, format_7644);
      wloop, n11, n12;
      FEM_DO_SAFE(ii, n11, n12) {
        wloop, voltbc(ii);
      }
    }
  }
  nn11 = nn13 + n11;
  nn12 = nn13 + n12;
  i = n11;
  FEM_DO_SAFE(jj, nn11, nn12) {
    sconst(jj) = voltbc(i);
    i++;
  }
  n11 += 3;
  if (n11 <= npa) {
    goto statement_7664;
  }
  n11 = 1;
statement_7672:
  n12 = n11 + 2;
  if (n12 > npa) {
    n12 = npa;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M31. 663
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_7641);
    FEM_DO_SAFE(ii, n11, n12) {
      rloop, voltbc(ii);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, lunit6, format_7655);
      wloop, n11, n12;
      FEM_DO_SAFE(ii, n11, n12) {
        wloop, voltbc(ii);
      }
    }
  }
  nn11 = nn12 + n11;
  nn13 = nn12 + n12;
  i = n11;
  FEM_DO_SAFE(jj, nn11, nn13) {
    sconst(jj) = voltbc(i);
    i++;
  }
  n11 += 3;
  if (n11 <= npa) {
    goto statement_7672;
  }
  if (pdt == 0.f) {
    goto statement_50022;
  }
  ii = 2 * npz;
  npza = npa;
  goto statement_50021;
statement_50022:
  noutpr = aa;
  cnvhst(ifx) = tauo;
  ifx += 14;
  if (ifx > lhist) {
    goto statement_8120;
  }
  ifsem += 7 * npa + 7 * npz + 8;
  if (ifsem > lfsem) {
    goto statement_8090;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(' DONE MARTI CARDS.  IFX, NPZ, NPA, IBR,IFSEM =',5i6)"), ifx,
      npz, npa, ibr, ifsem;
  }
  icheck = 3;
  length(ibr1) = kcount;
  if (kcount > mxphas) {
    mxphas = kcount;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(' BELOW 20105. ITYPE, N13, MODEL, IPUNCH =',4i6)"), itype,
      n13, model, ipunch;
  }
  if (ipunch != -2) {
    goto statement_100;
  }
  if (kcount == model) {
    goto statement_10010;
  }
  if (kcount != 1) {
    goto statement_100;
  }
  if (n13 < 1) {
    goto statement_100;
  }
  model = n13;
  litype(ibr) = iaddrs;
  if (iprsup >= 1) {
    write(lunit6,
      "(' MARTI''S MODEL FOR UNTRANSPOSED LINE, MODEL, IADDRS, IBR1 =',3i10)"),
      model, iaddrs, ibr1;
  }
  if (n13 == 1) {
    goto statement_10010;
  }
  goto statement_100;
statement_10105:
  if (ipunch != -3) {
    goto statement_6552;
  }
statement_6552:
  if (kcount > 1) {
    goto statement_5874;
  }
  xlong1 = xlong;
  omega = xlong1;
  if (xlong > 0.0f) {
    goto statement_5877;
  }
  if (iline == 2) {
    goto statement_5877;
  }
  kill = 78;
  flstat(16) = xlong;
  lstat(19) = 5874;
  goto statement_9999;
statement_5874:
  if (xlong == xlong1) {
    goto statement_5877;
  }
  if (xlong == 0.0f) {
    goto statement_5877;
  }
  kill = 77;
  lstat(19) = 191;
  flstat(16) = xlong;
  flstat(15) = xlong1;
  lstat(14) = kcount;
  goto statement_9999;
statement_5877:
  d17 = h1 + aa + h3 + xlong;
  ichtr2 = 0;
  indtv(4) = ichtr2;
  if (d17 != 0.0f) {
    ichtr2 = 1;
  }
  xlong = xlong1;
  if (kcount != 3) {
    goto statement_198;
  }
  if (n13 > 0) {
    goto statement_198;
  }
  if (ichtr2 == 0) {
    goto statement_197;
  }
  if (aa <= 0.0f) {
    goto statement_5878;
  }
  if (h3 > 0.0f) {
    goto statement_5879;
  }
statement_5878:
  kill = 93;
  lstat(19) = 5878;
  flstat(14) = aa;
  flstat(15) = h3;
  goto statement_9999;
statement_5879:
  ibr15 = ibr1 + 5;
  FEM_DO_SAFE(i, ibr1, ibr15) {
    kodebr(i) = -1;
  }
statement_198:
  if (iline > 0) {
    goto statement_192;
  }
  d2 = aa * cmn.tenm3;
  ci1 = h3 / 1000000.f;
  if (xopt > 0.0f) {
    d2 = d2 * 1000.f / (twopi * xopt);
  }
  if (copt > 0.0f) {
    ci1 = ci1 / (twopi * copt);
  }
  a = sqrtz(d2 / ci1);
  h2 = xlong * a * ci1;
  goto statement_193;
statement_192:
  a = aa;
  h2 = h3;
  if (iline == 1) {
    h2 = xlong / h2;
  }
statement_193:
  cik(ibr) = h2;
  if (noutpr == 0) {
    write(kunit6, "('+',5e10.3)"), h1, aa, h3, a, h2;
  }
  if (iprsup >= 4) {
    write(lunit6,
      "(' BELOW 4104.  IPUNCH, KCOUNT, MODEL, N13 =',4i5)"), ipunch,
      kcount, model, n13;
  }
  if (h1 == 0.f || ipunch > 0) {
    a = -a;
  }
  ck(ibr) = h1 * xlong;
  ci(ibr) = a;
  if (ipunch < 0) {
    goto statement_20160;
  }
  icheck = 3;
  length(ibr1) = kcount;
  if (kcount > mxphas) {
    mxphas = kcount;
  }
  if (kcount == model) {
    goto statement_10010;
  }
  if (kcount != 1) {
    goto statement_100;
  }
  if (n13 == 0) {
    model = 0;
  }
  if (n13 <= 1) {
    goto statement_100;
  }
  model = n13;
  litype(ibr) = iaddrs;
  goto statement_100;
statement_196:
  kcount++;
  if (iprsup >= 1) {
    write(6, "(' READY FOR [TI]?  KCOUNT, ITYPE, MODEL =',3i6)"),
      kcount, itype, model;
  }
  if (ipsem != 0) {
    goto statement_2011;
  }
  if ((-itype) != kcount) {
    goto statement_141;
  }
statement_2011:
  if (kcount > 18) {
    goto statement_9175;
  }
  if (iprsup >= 4) {
    write(6, star), " Cable cont.?  NTLIN, IBR,  N1, N2 =", ntlin, ibr, n1, n2;
  }
  if (iprsup >= 4) {
    write(6, star), "CABLE CHECK?      model= , kcount=", model, kcount;
  }
  if (-ipunch != 4) {
    goto statement_5202;
  }
  ipunch = imodel(ibr - 1);
  mbus(ibr1) = fem::iabs(mbus(ibr1));
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  //C      if ( n13 .eq. 0 ) N13Q = N13 + 1                                 M44. 147
  //C      IF (kcount .nq. N13Q ) GO TO 190                                 M43. 711
  //C      IF(MODEL.LE.1)GO TO 10004                                        M43. 712
  if (-itype <= model) {
    goto statement_190;
  }
  if (ipunch == -4 && n13 == 0) {
    goto statement_190;
  }
  //C                                                                       M43. 714
  //C                                                                       M43. 715
statement_50050:
  inoff1 = lbrnch;
  inoff2 = 2 * lbrnch;
  noutpr = npll;
  inoff3 = 3 * lbrnch;
  inoff4 = 4 * lbrnch;
  koff1 = 900;
  koff2 = koff1 + isecti;
  koff3 = koff2 + isecti;
  koff4 = koff3 + isecti;
  koff5 = koff4 + isecti;
  koff6 = koff5 + isecti;
  koff7 = koff6 + isecti;
  koff8 = koff7 + isecti;
  koff9 = koff8 + isecti;
  koff10 = koff9 + isecti;
  koff13 = koff10 + isecti;
  koff14 = koff13 + isecti;
  koff15 = koff14 + isecti;
  koff16 = koff15 + isecti;
  koff17 = koff16 + isecti;
  koff18 = koff17 + isecti;
  koff19 = koff18 + isecti;
  koff20 = koff19;
  if (kgroup != 1) {
    semaux(koff19) = 1;
  }
  semaux(koff19) += kgroup;
  ncount = idm;
  if (ipsem != 0) {
    n13 = ipsem;
  }
  nphs = n13;
  nphs2 = fem::pow2(n13);
  nphsu = (nphs + 1) * nphs / 2;
  ibr2 = ibr - nphs + 1;
  ibr3 = ibr - nphs + 3;
  ifq++;
  namebr(inoff2 + ibr2) = ifq;
  //C      INFDLI( INOFF1 + IBR2 ) =                                        M43. 754
  //C    1              IDM    !Remember intial adress for this group, 1--10M43. 755
  namebr(inoff1 + ibr2) = iaddrs;
  namebr(inoff1 + ibr2) = idm;
  //C      NCOUNT = IADDRS                                                  M44. 153
  iaddrs += nphs2;
  indtv(1) = iaddrs;
  namebr(inoff4 + ibr2) = idu;
  if (iprsup >= 4) {
    write(6, star), " BEGIN TO READ Qi. NTLIN,IQ,IDM,IDU,IDT,IDQ= ",
      ntlin, cmn.iq, idm, idu, cmn.idt, idq;
  }
  if (ipsem != 0) {
    goto statement_2003;
  }
  FEM_DO_SAFE(i, 1, nphs2) {
    semaux(koff20 + ncount) = idq;
    cimage(cmn);
    read(abuff, "(i8,e32.0)"), np, sconst(ifq);
    if (noutpr != -7777 && noutpr != 1) {
      write(kunit6, "('+ Ti.  NP, SCONST(IFQ) =',i5,e15.5)"), np, sconst(ifq);
    }
    interp();
    semaux(koff20 + ncount) = np;
    if (np >= 0) {
      goto statement_1441;
    }
  statement_1441:
    j1 = 1;
    nticpl = 0;
  statement_4888:
    j2 = j1 + 2;
    m = np;
    if (j2 > m) {
      j2 = m;
    }
    //C     READ INPUT CARD USING CIMAGE                                      M43. 775
    cimage(cmn);
    {
      read_loop rloop(abuff(1), format_105);
      FEM_DO_SAFE(j, j1, j2) {
        rloop, voltbc(j);
      }
    }
    if (noutpr != -7777 && noutpr != 1) {
      {
        write_loop wloop(cmn, kunit6, "('+ QK-I:',3e14.5)");
        FEM_DO_SAFE(j, j1, j2) {
          wloop, voltbc(j);
        }
      }
    }
    jj1 = j1 + ifq;
    jj2 = j2 + ifq;
    iml = j1;
    FEM_DO_SAFE(jj, jj1, jj2) {
      if (fem::abs(sconst(jj)) >= 1.e+13f) {
        nticpl++;
      }
      sconst(jj) = voltbc(iml);
      iml++;
    }
    j1 += 3;
    if (j1 <= m) {
      goto statement_4888;
    }
    interp();
    intcpl = lhist + i;
    cnvhst(intcpl) = nticpl;
    j1 = 1;
  statement_4847:
    j2 = j1 + 2;
    m = np;
    if (j2 > m) {
      j2 = m;
    }
    //C     READ INPUT CARD USING CIMAGE                                      M43. 797
    cimage(cmn);
    {
      read_loop rloop(abuff(1), format_105);
      FEM_DO_SAFE(j, j1, j2) {
        rloop, voltbc(j);
      }
    }
    if (noutpr != -7777 && noutpr != 1) {
      {
        write_loop wloop(cmn, kunit6, "('+ QP-I:',3e14.5)");
        FEM_DO_SAFE(j, j1, j2) {
          wloop, voltbc(j);
        }
      }
    }
    nn11 = jj2 + j1;
    nn13 = jj2 + j2;
    iml = j1;
    FEM_DO_SAFE(jj, nn11, nn13) {
      sconst(jj) = voltbc(iml);
      iml++;
    }
    j1 += 3;
    if (j1 <= m) {
      goto statement_4847;
    }
    ifq = nn13 + 1;
    interp();
    ncount++;
    idq += np;
  }
  idq = idq - 1;
  idq = 2 * idq;
  idq++;
  ifq = nn13 + (nn13 - ifsem - nphs2) * 3 / 2 + 2 * nphs2;
  ifsem = ifq;
  namebr(inoff3 + ibr2) = nn13;
  idm += nphs2;
  idu += nphsu;
  goto statement_2009;
statement_2003:
  jkl = 0;
  if (ipsem < 3) {
    jkl = 1;
  }
  FEM_DO_SAFE(j, 1, nphs2) {
    semaux(koff20 + ncount) = 1;
    ncount++;
  }
  if (ipsem <= 3) {
    ip = ipsem * 2;
  }
  if (ipsem > 3 && ipsem < 6) {
    ip = ipsem * 4;
  }
  if (ipsem == 6) {
    ip = ipsem * 4;
  }
  kl = 0;
  ifqt = ifq;
  ifqq = ifq;
  FEM_DO_SAFE(i, 1, ip) {
    cimage(cmn);
    if (ipsem <= 3) {
      goto statement_2113;
    }
    if (i <= ipsem * 2) {
      goto statement_2008;
    }
    goto statement_2114;
  statement_2113:
    if (i <= ipsem) {
      goto statement_2008;
    }
  statement_2114:
    if (ipsem == 6) {
      nrowt = 6;
    }
    if (ipsem == 6) {
      goto statement_2014;
    }
    if (ipsem > 3 && jkl == 0) {
      nrowt = 6;
    }
    if (ipsem <= 3) {
      nrowt = 2 * ipsem;
    }
    if (ipsem <= 3) {
      goto statement_2014;
    }
    if (jkl == 1) {
      nrowt = ipsem * 2 - 6;
    }
    if (nrowt == 6) {
      jkl = 1;
    }
    if (nrowt < 6) {
      jkl = 0;
    }
    if (ipsem > 3 && ipsem == 6) {
      nrowt = 6;
    }
  statement_2014:
    nfrfld = nrowt;
    if (kolbeg <= 0) {
      goto statement_2005;
    }
    frefld(cmn, voltbc(1));
    goto statement_2006;
  statement_2005:
    {
      read_loop rloop(abuff(1), format_8170);
      FEM_DO_SAFE(ik, 1, nfrfld) {
        rloop, voltbc(ik);
      }
    }
  statement_2006:
    n12 = 1;
    if (noutpr == 0) {
      {
        write_loop wloop(cmn, kunit6, "(' Ti - Semlyen.',3e12.3)");
        FEM_DO_SAFE(ii, 1, nfrfld) {
          wloop, voltbc(ii);
        }
      }
    }
    FEM_DOSTEP(k, 1, nrowt, 2) {
      kl++;
      sconst(ifq) = voltbc(n12);
      sconst(ifq + 1) = 0.f;
      sconst(ifq + 2) = 1.f;
      n12 += 2;
      if (kl < ipsem) {
        goto statement_2015;
      }
      kl = 0;
      ifqq += 3;
      ifq = ifqq;
      goto statement_2007;
    statement_2015:
      ifq += ipsem * 3;
    statement_2007:;
    }
  statement_2008:;
  }
  ifq = ifqt + fem::pow2(ipsem) * 3;
  nn13 = ifq - 1;
  ifq = nn13 + (nn13 - ifsem - nphs2) * 3 / 2 + 2 * nphs2;
  ifsem = ifq;
  namebr(inoff3 + ibr2) = nn13;
  idm += nphs2;
  idu += nphsu;
statement_2009:
  if (-itype == nphs || nt1 == ipsem) {
    icheck = 1;
  }
  if (-itype == nphs || nt1 == ipsem) {
    ifkc += n13;
  }
  if (iprsup >= 4) {
    write(6, star),
      "Next bunch of coupled branches. ntlin=, kcount=", ntlin,
      kcount;
  }
  itranm = model;
  indtv(2) = itranm;
  model = 0;
  icheck = 1;
  kgroup = 1;
  noutpr = aa;
  goto statement_100;
  //C                                                                       M43. 842
statement_5202:
  length(ibr1) = kcount;
  if (kcount > mxphas) {
    mxphas = kcount;
  }
  mbus(ibr1) = fem::iabs(mbus(ibr1));
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  if (ipunch == -2 && n13 == 0) {
    goto statement_190;
  }
  if (kcount <= 3) {
    goto statement_190;
  }
  if (model <= 1) {
    goto statement_10004;
  }
  if (kcount <= model) {
    goto statement_190;
  }
statement_10010:
  iadd = iaddrs + 2 * model * model - 1;
  //C   constant and frequence-dependent modal, 2XNPSXNPS cells sre requiredM43. 845
  if (iprsup >= 1) {
    write(lunit6, "(' AT S.N. 10010, READY TO READ [TI]')");
  }
  if (iadd < lfd) {
    goto statement_10007;
  }
  //C CHECK FOR OVERFLOW FOR TI ARRAY                                       M29.1306
  iprint = 21;
  lstat(19) = 10010;
  goto statement_9000;
statement_9175:
  write(lunit6, "(' LAST DISTRIBUTED PARAM. LINE HAS MORE THAN 18 PHASES')");
  goto statement_9000;
  //C     NEXT READ IN COMPLEX TRANSFORMATION MATRIX  [TR] + J[TI] :        M31. 724
statement_10007:
  n9 = 1;
statement_2711:
  n7 = 1;
statement_2716:
  n1 = n9 + iaddrs - 1;
  i = 1;
  //C     READ INPUT CARD USING CIMAGE                                      M31. 729
statement_2722:
  cimage(cmn);
  nfrfld = 6;
  if (i + 5 > model) {
    nfrfld = model - i + 1;
  }
  if (kolbeg > 0) {
    goto statement_2728;
  }
  {
    read_loop rloop(abuff(1), "(6e12.0)");
    FEM_DO_SAFE(j, 1, nfrfld) {
      rloop, voltbc(j);
    }
  }
  goto statement_2733;
statement_2728:
  frefld(cmn, voltbc(1));
statement_2733:
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, "(a4,i2,',',i2,')...',6f6.3)");
      wloop, textmx(n7), n9, i;
      FEM_DO_SAFE(j, 1, nfrfld) {
        wloop, voltbc(j);
      }
    }
  }
  FEM_DO_SAFE(n8, 1, nfrfld) {
    if (n7 == 1) {
      qfd(n1) = voltbc(n8);
    }
    if (n7 == 2) {
      sfd(n1) = voltbc(n8);
    }
    i++;
    n1 += model;
  }
  if (i <= model) {
    goto statement_2722;
  }
  n7++;
  if (n7 <= 2) {
    goto statement_2716;
  }
  n9++;
  if (n9 <= model) {
    goto statement_2711;
  }
  if (iprsup < 2) {
    goto statement_10005;
  }
  n9 = itranm * itranm;
  {
    write_loop wloop(cmn, lunit6,
      "(' FOR THIS UNTRANSPOSED LINE, N13, MODEL,',"
      "' IADD, N9, (QFD(I), I=(IADD-N9), IADD) =',4i7,/(1x,6e15.6))");
    wloop, n13, model, iadd, n9;
    FEM_DO_SAFE(i, iaddrs, iadd) {
      wloop, qfd(i);
    }
  }
  //C     DEFINE NEW ADDRESS FOR FOLLOWING UNTRANSPOSED LINE                M32.1236
statement_10005:
  iaddrs = iadd;
  indtv(1) = iaddrs + 1;
  itranm = model;
  indtv(2) = itranm;
  model = 0;
  icheck = 1;
  goto statement_100;
statement_10004:
  cik(ibr) = cik(ibr1 + 1);
  imodel(ibr) = imodel(ibr1 + 1);
  if (imodel(ibr) != -2) {
    goto statement_10106;
  }
  ktrlsw(5) = 1;
  goto statement_100;
statement_10106:
statement_197:
  if (ichtr2 != 0 && kcount == 4) {
    goto statement_5891;
  }
  ibrm = ibr1 + 1;
  if (kodebr(ibr1) == -1) {
    ibrm = ibr1 + 2;
  }
  cik(ibr) = cik(ibrm);
  ci(ibr) = ci(ibrm);
  ck(ibr) = ck(ibrm);
  nr(ibr) = nr(ibrm);
  goto statement_5892;
statement_5891:
  ibrm = ibr - 1;
  ibrm1 = ibr - 2;
  if (kodebr(ibr1) != -1) {
    goto statement_15891;
  }
  d1 = cik(ibrm);
  d2 = ci(ibrm);
  d3 = ck(ibrm);
  d4 = nr(ibrm);
statement_15891:
  cik(ibrm) = cik(ibrm1);
  ci(ibrm) = ci(ibrm1);
  ck(ibrm) = ck(ibrm1);
  nr(ibrm) = nr(ibrm1);
  if (kodebr(ibr1) != -1) {
    goto statement_15895;
  }
  cik(ibrm1) = d1;
  ci(ibrm1) = d2;
  ck(ibrm1) = d3;
  nr(ibrm1) = d4;
statement_15895:
  cik(ibr) = cik(ibrm);
  ci(ibr) = ci(ibrm);
  ck(ibr) = ck(ibrm);
  nr(ibr) = nr(ibrm);
statement_5892:
  if (kodebr(ibr1) == -1) {
    goto statement_5895;
  }
  if (noutpr == 0) {
    write(kunit6, "('+3RD OR LATER UNIF.-TRANSPOSED DISTRIBUTED COND.')");
  }
  goto statement_100;
statement_5895:
  if (noutpr == 0) {
    write(kunit6, "('+4TH OR LATER DOUBLE CKT DISTRIBUTED CONDUCTOR.')");
  }
statement_100:
  lstat(18) = 100;
  goto statement_9999;
statement_141:
  lstat(18) = 141;
  goto statement_9999;
statement_20160:
  nchain = 4;
  goto statement_9999;
statement_9000:
  lstat(16) = iprint;
  kill = 1;
statement_9999:
  if (iprsup >= 3) {
    write(lunit6,
      "(/,' EXIT  \"DISTR2\" .','    KILL  NCHAIN LSTAT18     IBR   IFSEM',/,"
      "17x,10i8)"),
      kill, nchain, lstat(18), ibr, ifsem;
  }
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE DISTR2.\"')");
  }
}


void over4(common& cmn);
void over2(common& cmn) // INPUT BRANCH DATA. 
{
  FEM_CMN_SVE(over2);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& bus6 = cmn.bus6;
  fem::str<8>& blank = cmn.blank;
  const auto& texta6 = cmn.texta6;
  const auto& abuff = cmn.abuff;
  double& freqcs = cmn.freqcs;
  double& xunits = cmn.xunits;
  auto& voltbc = cmn.voltbc;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& indtv = cmn.indtv;
  auto& lstat = cmn.lstat;
  auto& iprsov= cmn.iprsov;
  int& icheck = cmn.icheck;
  int& inonl = cmn.inonl;
  int& iout = cmn.iout;
  int& ipunch = cmn.ipunch;
  int& itype = cmn.itype;
  int& it2 = cmn.it2;
  int& kcount = cmn.kcount;
  int& lbrnch = cmn.lbrnch;
  int& lbus = cmn.lbus;
  int& lswtch = cmn.lswtch;
  int& lnonl = cmn.lnonl;
  int& nv = cmn.nv;
  int& npower = cmn.npower;
  int& maxpe = cmn.maxpe;
  int& lsiz12 = cmn.lsiz12;
  auto& ktrlsw = cmn.ktrlsw;
  int& num99 = cmn.num99;
  int& lastov = cmn.lastov;
  int& lhist = cmn.lhist;
  int& ifx = cmn.ifx;
  int& noutpr = cmn.noutpr;
  int& numdcd = cmn.numdcd;
  int& nphcas = cmn.nphcas;
  int& ichar = cmn.ichar;
  int& ktref = cmn.ktref;
  int& moldat = cmn.moldat;
  int& ifsem = cmn.ifsem;
  int& lfsem = cmn.lfsem;
  int& iadd = cmn.iadd;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kswtch = cmn.kswtch;
  int& it = cmn.it;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  auto& koutvp = cmn.koutvp;
  auto& sconst = cmn.sconst;
  auto& cnvhst = cmn.cnvhst;
  auto& sfd = cmn.sfd;
  auto& qfd = cmn.qfd;
  auto& semaux = cmn.semaux;
  auto& modswt = cmn.modswt;
  auto& topen = cmn.topen;
  auto& crit = cmn.crit;
  auto& isourc = cmn.isourc;
  auto& nonlad = cmn.nonlad;
  auto& nonle = cmn.nonle;
  auto& vnonl = cmn.vnonl;
  auto& curr = cmn.curr;
  auto& anonl = cmn.anonl;
  auto& namenl = cmn.namenl;
  auto& vzer5 = cmn.vzer5;
  auto& nltype = cmn.nltype;
  const auto& cchar = cmn.cchar;
  const auto& vchar = cmn.vchar;
  const auto& gslope = cmn.gslope;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  auto& ck = cmn.ck;
  const auto& texvec = cmn.texvec;
  auto& ibrnch = cmn.ibrnch;
  auto& jbrnch = cmn.jbrnch;
  auto& nonlk = cmn.nonlk;
  auto& nonlm = cmn.nonlm;
  auto& litype = cmn.litype;
  auto& imodel = cmn.imodel;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  auto& kodebr = cmn.kodebr;
  auto& cki = cmn.cki;
  auto& ckkjm = cmn.ckkjm;
  auto& indhst = cmn.indhst;
  auto& kodsem = cmn.kodsem;
  auto& namebr = cmn.namebr;
  auto& kmswit = cmn.kmswit;
  auto& nextsw = cmn.nextsw;
  auto& tclose = cmn.tclose;
  auto& kpos = cmn.kpos;
  auto& namesw = cmn.namesw;
  const auto& r = static_cast<common_c0b064&>(cmn).r;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;

  auto& bus = cmn.bus;
  auto& buff77 = cmn.buff77;
  int& n1 = cmn.n1;
  int& n2 = cmn.n2;
  int& n3 = cmn.n3;
  int& n4 = cmn.n4;
  int& model = cmn.model;
  int& ibr1 = cmn.ibr1;
  int& kgroup = cmn.kgroup;
  int& ifq = cmn.ifq;
  int& n13 = cmn.n13;
  int& ifkc = cmn.ifkc;
  int& idm = cmn.idm;
  int& idq = cmn.idq;
  int& idu = cmn.idu;
  int& numrun = cmn.numrun;
  int& nphlmt = cmn.nphlmt;
  auto& char80 = cmn.char80;
  auto& chlmfs = cmn.chlmfs;
  //
  int& ibrnam = sve.ibrnam;
  int& inonam = sve.inonam;
  int& nfscan = sve.nfscan;
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text10 = sve.text10;
  fem::str<8>& text11 = sve.text11;
  fem::str<8>& text12 = sve.text12;
  fem::str<8>& text13 = sve.text13;
  fem::str<8>& text14 = sve.text14;
  fem::str<8>& text16 = sve.text16;
  fem::str<8>& text17 = sve.text17;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  fem::str<8>& text7 = sve.text7;
  fem::str<8>& text8 = sve.text8;
  fem::str<8>& text9 = sve.text9;
  if (is_called_first_time) {
    text1 = "STOP C";
    text2 = "ASCADE";
    text3 = "USE AB";
    text4 = "USE RL";
    text5 = "CASCAD";
    text6 = "ED PI ";
    text7 = "TRANSF";
    text8 = "ORMER ";
    text9 = "THREE ";
    text10 = "PHASE ";
    text11 = "BRANCH";
    text12 = " NAME:";
    text13 = "NONLIN";
    text14 = "ES    ";
    text16 = "LIN000";
    text17 = "NLN000";
    ibrnam = 0;
    inonam = 0;
    nfscan = 0;
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int k = fem::int0;
  int jk = fem::int0;
  int m = fem::int0;
  int L = fem::int0;
  int kreqab = fem::int0;
  int iold = fem::int0;
  int kph = fem::int0;
  int ksat = fem::int0;
  int nn17 = fem::int0;
  int nycmp = fem::int0;
  int isecti = fem::int0;
  int ll2 = fem::int0;
  int ll3 = fem::int0;
  int ll9 = fem::int0;
  int mxphas = fem::int0;
  int ifk = fem::int0;
  int ikf = fem::int0;
  int isfd = fem::int0;
  int ibf = fem::int0;
  int isgfd = fem::int0;
  int mread2 = fem::int0;
  int icas = fem::int0;
  int i = fem::int0;
  int iprint = fem::int0;
  double d1 = fem::double0;
  int n24 = fem::int0;
  int itym1 = fem::int0;
  int n9 = fem::int0;
  int n9sq = fem::int0;
  int j = fem::int0;
  double temp = fem::double0;
  int inoff1 = fem::int0;
  int inoff2 = fem::int0;
  int inoff3 = fem::int0;
  int inoff4 = fem::int0;
  int koff1 = fem::int0;
  int koff2 = fem::int0;
  int koff3 = fem::int0;
  int koff4 = fem::int0;
  int koff5 = fem::int0;
  int koff6 = fem::int0;
  int koff7 = fem::int0;
  int koff8 = fem::int0;
  int koff9 = fem::int0;
  int koff10 = fem::int0;
  int koff13 = fem::int0;
  int koff14 = fem::int0;
  int koff15 = fem::int0;
  int koff16 = fem::int0;
  int koff17 = fem::int0;
  int koff18 = fem::int0;
  int koff19 = fem::int0;
  int koff20 = fem::int0;
  int ncount = fem::int0;
  int nphs = fem::int0;
  int nphs2 = fem::int0;
  int nphsu = fem::int0;
  int ibr2 = fem::int0;
  int ibr3 = fem::int0;
  int ntlin = fem::int0;
  int nnn1 = fem::int0;
  int np = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  int jj1 = fem::int0;
  int jj2 = fem::int0;
  int iml = fem::int0;
  int jj = fem::int0;
  int nn11 = fem::int0;
  int nn13 = fem::int0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  arr_1d<18, fem::str<6> > chrpad(fem::fill0);
  double yzero = fem::double0;
  double rmag = fem::double0;
  int ioutmg = fem::int0;
  int nodtop = fem::int0;
  int it3 = fem::int0;
  int n = fem::int0;
  int keept = fem::int0;
  int keepb = fem::int0;
  int ideal = fem::int0;
  int iref = fem::int0;
  int n5 = fem::int0;
  double turn1 = fem::double0;
  int ncoil = fem::int0;
  double cut1 = fem::double0;
  double cut2 = fem::double0;
  double cut3 = fem::double0;
  int idumy = fem::int0;
  int itrans = fem::int0;
  int n8 = fem::int0;
  int mpower = fem::int0;
  int n16 = fem::int0;
  fem::str<8> text15 = fem::char0;
  fem::str<8> texta5 = fem::char0;
  int ll = fem::int0;
  int n14 = fem::int0;
  int it32 = fem::int0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  int iend = fem::int0;
  int ips1 = fem::int0;
  int n6 = fem::int0;
  int itemq = fem::int0;
  int iihst = fem::int0;
  int inoff5 = fem::int0;
  int nfir = fem::int0;
  int nsec = fem::int0;
  int nq = fem::int0;
  int interm = fem::int0;
  int ibrter = fem::int0;
  int kq = fem::int0;
  int nkq = fem::int0;
  int isec = fem::int0;
  int kq1 = fem::int0;
  int inew = fem::int0;
  int ii = fem::int0;
  static const char* format_1 = "(i2,4a6,9e6.2)";
  static const char* format_142 = "(79x,i1)";
  static const char* format_2005 = "(a)";
  static const char* format_21696 =
    "('+REFERENCE BRANCH.   COPY  ''',a6,''' TO ''',a6,'''')";
  static const char* format_2516 = "('C ',11(a6,1x))";
  static const char* format_2689 = "(a6)";
  static const char* format_54104 = "('+',5e10.3)";
  static const char* format_54111 = "('+REFERENCE BRANCH.   COPY CONT.')";
  static const char* format_8331 = "(26x,3e16.0)";
  //C           %INCLUDE  '//c/tsu/cables.INS.FTN'                          M44.   1
  //C 9-PHASE AS LIMIT FOR LMFS TEST
  //C
  auto& iaddrs = indtv(1);
  auto& itranm = indtv(2);
  auto& ityold = indtv(3);
  auto& ichtr2 = indtv(4);
  auto& nmauto = iprsov(39);
  if (lastov != 44) { // over2
    goto statement_2000;
  }
  //C READY FOR NEXT BRANCH, LMFS CASE
  k = nphlmt + 1;
  ibr = nphlmt;
  ntot = 2 * nphlmt + 1;
  it = 1;
  ibr1 = 1;
  FEM_DO_SAFE(jk, 1, nphlmt) {
    m = jk + nphlmt;
    L = 2 * jk;
    //C      WRITE (BUS(L), 2689)  CHLMFS(JK)(1:6)
    read(chlmfs(jk)(1, 6), format_2689), bus(L);
    //C      WRITE (BUS(L+1), 2689)  CHLMFS(M)(1:6)
    read(chlmfs(m)(1, 6), format_2689), bus(L + 1);
  }
  //C GO DIRECTLY TO USE $INCLUDE FOR LMFS Pi model half
  goto statement_4199;
  //C
  //C     FOLLOWING USED RATHER THAN DATA STATEMENTS DUE TO COMMON:         M37.2210
statement_2000:
  ityold = 0;
  kreqab = 0;
  ichtr2 = 0;
  iold = 0;
  kph = 0;
  ksat = 0;
  ibr1 = 0;
  nn17 = 0;
  nycmp = 0;
  isecti = 400;
statement_1000:
  if (iprsup >= 1) {
    write(lunit6, "(' BEGIN MODULE \"OVER2\". ')");
  }
  cmn.l27dep = lbrnch * cmn.lsiz27 / 2;
  ll2 = 2;
  ll3 = 3;
  ll9 = 9;
  mxphas = 0;
  ifk = 0;
  cmn.lcount = 0;
  //C     INITIALIZE COUNTERS FOR THE -666 BRANCHES  * * * * * * * * * * * *M32.1056
  ikf = 0;
  isfd = 0;
  ibf = 0;
  isgfd = -100;
  mread2 = 0;
  icas = 0;
  cmn.nrecur = 0;
  model = 0;
  if (lastov == 4) {
    goto statement_100;
  }
  FEM_DO_SAFE(i, 1, lfsem) {
    sconst(i) = 0.0f;
  }
  FEM_DO_SAFE(i, 1, lbrnch) {
    imodel(i) = 0;
  }
  FEM_DO_SAFE(i, 1, lbrnch) {
    litype(i) = 0;
  }
  iaddrs = 1;
statement_100:
  it2 = it + 2;
  if (kill > 0) {
    goto statement_9200;
  }
  iprint = 3;
  lstat(19) = 100;
  if (it2 > cmn.ldata) {
    goto statement_9000;
  }
  if (ksat >= 0) {
    goto statement_3986;
  }
  ksat = 1;
  goto statement_100;
statement_3986:
  if (ntot > 1) {
    goto statement_3988;
  }
  if (mread2 == 0) {
    goto statement_3989;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M13.1213
statement_3988:
  cimage(cmn);
statement_3989:
  mread2 = 1;
  //C
  read(abuff, format_2005), char80;
  //C not LMFS case
  if (char80(1, 8) != "NO. OF P") {
    goto statement_2100;
  }
  FEM_DO_SAFE(jk, 16, 80) {
    if (char80(jk, jk) != " ") {
      goto statement_2008;
    }
  }
  write(lunit6,
    "(' No integer value (format I1) was inputted for number',"
    "' of phases in this LMFS case, run will be aborted. STOP.')");
  FEM_STOP(0);
statement_2008:
  read(char80(jk, jk), "(i1)"), nphlmt;
  //C
  if (noutpr == 0) {
    write(kunit6, "('+LMFS OF A ',i1,'-PHASE CIRCUIT')"), nphlmt;
  }
  cimage(cmn);
  read(abuff, format_2005), char80;
  if (char80(1, 7) == "SENDING") {
    goto statement_2020;
  }
  write(lunit6,
    "('  CARD OF SENDING END NODES:  OF THIS LMFS CASE IS NOT',"
    "' INPUTTED, AND CASE IS TO BE ABORTED. STOP.')");
  FEM_STOP(0);
statement_2020:
  {
    read_loop rloop(abuff(1), "(18x,9a6)");
    FEM_DO_SAFE(jk, 1, nphlmt) {
      rloop, chlmfs(jk);
    }
  }
  FEM_DO_SAFE(jk, 1, nphlmt) {
    if (chlmfs(jk)(1, 6) == "      ") {
      goto statement_2028;
    }
  }
  goto statement_2030;
statement_2028:
  write(lunit6,
    "(' PROGRAM OBSERVED AN INVALID BLANK NODE NAME FOR SENDING',"
    "' END OF THIS ',i1,'-PHASE LMFS CIRCUIT. CASE IS TO BE STOPPED.')"),
    nphlmt;
  FEM_STOP(0);
statement_2030:
  if (noutpr == 0) {
    write(kunit6, "('+SENDING END NODE NAMES (9A6 FORMAT)')");
  }
  cimage(cmn);
  read(abuff, format_2005), char80;
  if (char80(1, 9) == "RECEIVING") {
    goto statement_2040;
  }
  write(lunit6,
    "('  CARD OF RECEIVING END NODES: OF THIS LMFS CASE IS NOT',"
    "' INPUTTED, AND CASE IS TO BE ABORTED. STOP.')");
  FEM_STOP(0);
statement_2040:
  {
    read_loop rloop(abuff(1), "(20x,9a6)");
    FEM_DO_SAFE(jk, nphlmt + 1, 2 * nphlmt) {
      rloop, chlmfs(jk);
    }
  }
  FEM_DO_SAFE(jk, 1, nphlmt) {
    if (chlmfs(jk)(1, 6) == "      ") {
      goto statement_2048;
    }
  }
  goto statement_2050;
statement_2048:
  write(lunit6,
    "(' PROGRAM OBSERVED AN INVALID BLANK NAME FOR RECEIVING ','END OF THIS ',"
    "i1,'-PHASE LMFS CIRCUIT. CASE IS TO BE STOPPED.')"),
    nphlmt;
  FEM_STOP(0);
statement_2050:
  if (noutpr == 0) {
    write(kunit6, "('+RECEIVING END NODE NAMES (9A6 FORMAT)')");
  }
  //C END OF THREE "/" CARDS FOR LMFS DATA CASE
  goto statement_100;
  //C
statement_2100:
  if (kolbeg > 0) {
    goto statement_6618;
  }
  read(abuff, format_1), itype, bus1, bus2, bus3, bus4;
  goto statement_6621;
statement_6618:
  nfrfld = 1;
  frefld(cmn, voltbc(1));
  itype = voltbc(1);
  nfrfld = 4;
  nright = -1;
  freone(cmn, d1);
  bus1 = texta6(1);
  bus2 = texta6(2);
  bus3 = texta6(3);
  bus4 = texta6(4);
  nright = 0;
statement_6621:
  if (iprsup >= 3 && ibr1 >= 1) {
    write(lunit6,
      "(' CONT. TRANSP.?,  IBR1, ITYOLD, KODSEM(IBR1),',"
      "' ITRANM, ITYPE, LENGTH(IBR1) =',6i7)"),
      ibr1, ityold, kodsem(ibr1), itranm, itype, length(ibr1);
  }
  if (bus2 != text12) {
    goto statement_7682;
  }
  n24 = 0;
  if (bus1 != text11) {
    goto statement_7677;
  }
  n1 = ibr + 1;
  namea6(cmn, bus3, n24);
  namebr(n1) = n24;
  if (noutpr == 0) {
    write(kunit6,
      "('+MONIKER \"',a6,'\" IS FOR NEXT BRANCH  +',i6,' .')"), bus3,
      n1;
  }
statement_7675:
  ibrnam++;
  if (ibrnam > ibr) {
    goto statement_7676;
  }
  namebr(ibrnam) = 1;
  if (nmauto == 0) {
    goto statement_7675;
  }
  nmincr(cmn, text16, ibrnam);
  n24 = 0;
  namea6(cmn, text16, n24);
  namebr(ibrnam) = n24;
  goto statement_7675;
statement_7676:
  goto statement_3988;
statement_7677:
  if (bus1 != text13) {
    goto statement_7682;
  }
  n1 = inonl + 1;
  namea6(cmn, bus3, n24);
  namesw(n1) = n24;
  if (noutpr == 0) {
    write(kunit6,
      "('+MONIKER \"',a6,'\" IS FOR NEXT NONLINEAR  +',i6,' .')"),
      bus3, n1;
  }
statement_7680:
  inonam++;
  if (inonam > inonl) {
    goto statement_7681;
  }
  namebr(inonam) = 1;
  if (nmauto == 0) {
    goto statement_7680;
  }
  nmincr(cmn, text17, inonam);
  n24 = 0;
  namea6(cmn, text17, n24);
  namenl(inonam) = n24;
  goto statement_7680;
statement_7681:
  goto statement_3988;
statement_7682:
  if (ibr1 == 0) {
    goto statement_36621;
  }
  if (ityold >= 0) {
    goto statement_36621;
  }
  //C MODEL phases untransposed
  if (model >= 1) {
    goto statement_36621;
  }
  if (kodsem(ibr1) != 0 && imodel(ibr1) == 0) {
    goto statement_36621;
  }
  if (kodsem(ibr1) != 0 && n13 != 0) {
    goto statement_36621;
  }
  if (itranm > 0) {
    goto statement_36621;
  }
  if (n13 == 0 && imodel(ibr1) == -4) {
    ktrlsw(3) = 0;
  }
  if (itype >= 0) {
    goto statement_26621;
  }
  itym1 = iabsz(itype) - 1;
  if (imodel(ibr1) == -3) {
    goto statement_36621;
  }
  if (itym1 == iabsz(length(ibr1))) {
    goto statement_36621;
  }
statement_26621:
  if (length(ibr1) != 3 || ktrlsw(3) == 0) {
    goto statement_8200;
  }
  litype(ibr1) = ktrlsw(3);
  goto statement_36621;
statement_8200:
  k = 1;
  n9 = iabsz(length(ibr1));
  iadd = iaddrs + 2 * n9 * n9 - 1;
  if (iadd < cmn.lfd) {
    goto statement_5950;
  }
  iprint = 21;
  lstat(19) = 5950;
  goto statement_9000;
statement_5950:
  n9sq = n9 * n9;
  litype(ibr1) = -iaddrs;
  if (kodebr(ibr1) == -1) {
    goto statement_15970;
  }
  FEM_DO_SAFE(j, 1, n9) {
    FEM_DO_SAFE(i, 1, n9) {
      volti(k) = 1.f;
      if (i == j && i != 1) {
        volti(k) = 1 - i;
      }
      if (i > j&& j != 1) {
        volti(k) = 0.f;
      }
      k++;
    }
  }
  n1 = iaddrs;
  FEM_DOSTEP(i, 1, n9sq, n9) {
    k = i + n9 - 1;
    temp = 0.f;
    FEM_DO_SAFE(j, i, k) {
      temp += fem::pow2(volti(j));
    }
    temp = sqrtz(temp);
    FEM_DO_SAFE(j, i, k) {
      qfd(n1) = volti(j) / temp;
      sfd(n1) = 0.0f;
      n1++;
    }
  }
  if (ipunch != -4 && n13 == 0.0f) {
    goto statement_50050;
  }
  ifq = ifsem;
  inoff1 = lbrnch;
  inoff2 = 2 * lbrnch;
  inoff3 = 3 * lbrnch;
  inoff4 = 4 * lbrnch;
  koff1 = 900;
  koff2 = koff1 + isecti;
  koff3 = koff2 + isecti;
  koff4 = koff3 + isecti;
  koff5 = koff4 + isecti;
  koff6 = koff5 + isecti;
  koff7 = koff6 + isecti;
  koff8 = koff7 + isecti;
  koff9 = koff8 + isecti;
  koff10 = koff9 + isecti;
  koff13 = koff10 + isecti;
  koff14 = koff13 + isecti;
  koff15 = koff14 + isecti;
  koff16 = koff15 + isecti;
  koff17 = koff16 + isecti;
  koff18 = koff17 + isecti;
  koff19 = koff18 + isecti;
  koff20 = koff19;
  if (kgroup != 1) {
    semaux(koff19) = 1;
  }
  semaux(koff19) += kgroup;
  ncount = idm;
  nphs = n9;
  nphs2 = fem::pow2(n9);
  nphsu = (nphs + 1) * nphs / 2;
  ibr2 = ibr - nphs + 1;
  ibr3 = ibr - nphs + 3;
  ifq++;
  namebr(inoff2 + ibr2) = ifq;
  namebr(inoff1 + ibr2) = idm;
  namebr(inoff4 + ibr2) = idu;
  if (iprsup >= 4) {
    write(6, star), " BEGIN TO READ Qi. NTLIN,IQ,IDM,IDU,IDT,IDQ= ",
      ntlin, cmn.iq, idm, idu, cmn.idt, idq;
  }
  nnn1 = iaddrs;
  FEM_DO_SAFE(i, 1, nphs2) {
    semaux(koff20 + ncount) = idq;
    np = 1;
    sconst(ifq) = qfd(nnn1);
    nnn1++;
    //C      IF (NOUTPR .EQ. 0)                                               M44.  15
    //C     1 WRITE (*, 8262) NP , SCONST(IFQ)                                M44.  58
    //C 8262 FORMAT ( 24H+ Ti.  NP, SCONST(IFQ) =, I5,  E15.5  )              M44.  59
    semaux(koff20 + ncount) = np;
    j1 = 1;
  statement_4888:
    j2 = j1 + 2;
    m = np;
    if (j2 > m) {
      j2 = m;
    }
    jj1 = j1 + ifq;
    jj2 = j2 + ifq;
    iml = j1;
    FEM_DO_SAFE(jj, jj1, jj2) {
      sconst(jj) = 0.0f;
      iml++;
    }
    //C      IF (NOUTPR .EQ. 0)                                               M44.  16
    //C     1 WRITE (*, 4413)   ( SCONST(J), J=JJ1, JJ2 )                     M44.  72
    //C 4413 FORMAT ( 7H+ QK-I:, 3E14.5 )                                     M44.  73
    j1 += 3;
    if (j1 <= m) {
      goto statement_4888;
    }
    //C                                                                       M44.  76
    j1 = 1;
  statement_4847:
    j2 = j1 + 2;
    m = np;
    if (j2 > m) {
      j2 = m;
    }
    nn11 = jj2 + j1;
    nn13 = jj2 + j2;
    iml = j1;
    FEM_DO_SAFE(jj, nn11, nn13) {
      sconst(jj) = 1.0f;
      iml++;
    }
    //C      IF (NOUTPR .EQ. 0)                                               M44.  17
    //C     1 WRITE (*, 8414)  ( SCONST(J), J=J1, J2 )                        M44.  88
    //C 8414 FORMAT ( 7H+ QP-I:, 3E14.5 )                                     M44.  89
    j1 += 3;
    if (j1 <= m) {
      goto statement_4847;
    }
    ifq = nn13 + 1;
    ncount++;
    idq += np;
  }
  idq = idq - 1;
  idq = 2 * idq;
  idq++;
  ifq = nn13 + (nn13 - ifsem - nphs2) * 3 / 2 + 2 * nphs2;
  ifsem = ifq;
  namebr(inoff3 + ibr2) = nn13;
  idm += nphs2;
  idu += nphsu;
  ifkc += n9;
  if (iprsup >= 4) {
    write(6, star),
      "Next bunch of coupled branches. ntlin=, kcount=", ntlin,
      kcount;
  }
  itranm = model;
  model = 0;
  kgroup = 1;
statement_50050:
  if (length(ibr1) == 3) {
    ktrlsw(3) = -iaddrs;
  }
  goto statement_25970;
statement_15970:
  d1 = 2.0f;
  d2 = 6.0f;
  d3 = 1.0f / sqrtz(d1);
  d4 = 1.0f / sqrtz(d2);
  n1 = iaddrs;
  FEM_DO_SAFE(j, 1, 36) {
    if (j > 9) {
      goto statement_15975;
    }
    qfd(n1) = d4;
    goto statement_25960;
  statement_15975:
    if (j > 12) {
      goto statement_15980;
    }
    qfd(n1) = -d4;
    goto statement_25960;
  statement_15980:
    if (j > 13) {
      goto statement_15985;
    }
    qfd(n1) = d3;
    goto statement_25960;
  statement_15985:
    if (j > 14) {
      goto statement_15990;
    }
    qfd(n1) = -d3;
    goto statement_25960;
  statement_15990:
    if (j > 18) {
      goto statement_15991;
    }
    qfd(n1) = 0.0f;
    goto statement_25960;
  statement_15991:
    if (j > 20) {
      goto statement_15992;
    }
    qfd(n1) = d4;
    goto statement_25960;
  statement_15992:
    if (j > 21) {
      goto statement_15993;
    }
    qfd(n1) = -d1 * d4;
    goto statement_25960;
  statement_15993:
    if (j > 27) {
      goto statement_15994;
    }
    qfd(n1) = 0.0f;
    goto statement_25960;
  statement_15994:
    if (j > 28) {
      goto statement_15995;
    }
    qfd(n1) = d3;
    goto statement_25960;
  statement_15995:
    if (j > 29) {
      goto statement_15996;
    }
    qfd(n1) = -d3;
    goto statement_25960;
  statement_15996:
    if (j > 33) {
      goto statement_15997;
    }
    qfd(n1) = 0.0f;
    goto statement_25960;
  statement_15997:
    if (j > 35) {
      goto statement_15999;
    }
    qfd(n1) = d4;
    goto statement_25960;
  statement_15999:
    qfd(n1) = -d1 * d4;
  statement_25960:
    sfd(n1) = 0.0f;
    n1++;
  }
statement_25970:
  if (iprsup < 1) {
    goto statement_5971;
  }
  n1 = iaddrs;
  n2 = n1 + n9sq - 1;
  {
    write_loop wloop(cmn, lunit6,
      "(' QFD(I) AND SFD(I) FOR I =',i6,' TO ',i6,' ARE',/(1x,8e15.7))");
    wloop, n1, n2;
    FEM_DO_SAFE(i, n1, n2) {
      wloop, qfd(i);
    }
    FEM_DO_SAFE(i, n1, n2) {
      wloop, sfd(i);
    }
  }
  write(lunit6,
    "(' AT 25968, IBR1, IADDRS AND LITYPE(IBR1) ARE',3i10)"), ibr1,
    iaddrs, litype(ibr1);
statement_5971:
  iaddrs = iadd + 1;
statement_36621:
  itranm = 0;
  if (bus1 != blank) {
    goto statement_110;
  }
  if (bus2 != blank) {
    goto statement_110;
  }
  if (itype == 0) {
    goto statement_4199;
  }
  if (itype < 0) {
    goto statement_110;
  }
  if (icas == 0) {
    nphcas = itype - 51;
  }
  icas = -1;
  goto statement_147;
statement_4199:
  //C           =================  line-model F-scan building of network ===========
  if (cmn.kexact != 88333) {
    goto statement_5823;
  }
  //C     WRITE (*,*) ' Check F-scan data.  NTOT, IBR =',  ntot, ibr
  if (nfscan > 0) {
    goto statement_5823;
  }
  if (lastov != 44) {
    numrun++;
  }
  nfscan = nphlmt;
  //C     IF ( NFSCAN*2 .EQ. NTOT - 1  .AND.
  //C    1     NFSCAN .EQ. IBR ) GO TO 1583
  //C      IF ( NFSCAN*2 .EQ. NTOT-1 )  GO TO 1583
  //C      WRITE (*,*) ' Error F-scan data.  NTOT, IBR =',  ntot, ibr
  //C      stop
  //C 1583 DO 5281  M= 2, NTOT, 2
  //C      N9 = M / 2
  //C      CHAR6 = 'SEND_'//ALPHAN(N9:N9)
  //C      READ(CHAR6,4207) BUS(M)
  //C      CHAR6 = 'RECV_'//ALPHAN(N9:N9)
  //C      READ(CHAR6,4207) BUS(M+1)
  //C 4207 FORMAT ( A6 )
  //C  5281 continue
  //C
  FEM_DO_SAFE(m, 1, 2 * nphlmt) {
    chrpad(m)(1, 6) = chlmfs(m)(1, 6);
    FEM_DO_SAFE(k, 1, 6) {
      if (chlmfs(m)(k, k) == " ") {
        chrpad(m)(k, k) = "#";
      }
    }
  }
  if (numrun >= 2) {
    goto statement_2540;
  }
  if (nphlmt > 3) {
    goto statement_2510;
  }
  {
    write_loop wloop(buff77,
      "('$INCLUDE, [TSU]LINESCANZ',i1,'.THL ',6(a6,1x))");
    wloop, nphlmt;
    FEM_DO_SAFE(m, 1, 2 * nphlmt) {
      wloop, chrpad(m)(1, 6);
    }
  }
  //C  3629 FORMAT ( '$INCLUDE, DRD5:[BOB]LINESCANZ', I1, '.THL ',
  goto statement_2580;
statement_2510:
  FEM_DO_SAFE(i, 1, 2) {
    if (i == 1) {
      {
        write_loop wloop(buff77,
          "('$INCLUDE,[TSU]LINESCANZ',i1,'.THL ',7(a6,1x),'$$')");
        wloop, nphlmt;
        FEM_DO_SAFE(m, 1, 7) {
          wloop, chrpad(m)(1, 6);
        }
      }
    }
    if (i == 2) {
      {
        write_loop wloop(buff77, format_2516);
        FEM_DO_SAFE(m, 8, 2 * nphlmt) {
          wloop, chrpad(m)(1, 6);
        }
      }
    }
    numdcd++;
    inlmfs(cmn);
  }
  goto statement_3988;
statement_2540:
  if (numrun > 2) {
    goto statement_2560;
  }
  if (nphlmt > 3) {
    goto statement_2545;
  }
  {
    write_loop wloop(buff77,
      "('$INCLUDE, [TSU]LINESCANP',i1,'.THL ',6(a6,1x))");
    wloop, nphlmt;
    FEM_DO_SAFE(m, 1, 2 * nphlmt) {
      wloop, chrpad(m)(1, 6);
    }
  }
  goto statement_2580;
statement_2545:
  FEM_DO_SAFE(i, 1, 2) {
    if (i == 1) {
      {
        write_loop wloop(buff77,
          "('$INCLUDE,[TSU]LINESCANP',i1,'.THL ',7(a6,1x),'$$')");
        wloop, nphlmt;
        FEM_DO_SAFE(m, 1, 7) {
          wloop, chrpad(m)(1, 6);
        }
      }
    }
    if (i == 2) {
      {
        write_loop wloop(buff77, format_2516);
        FEM_DO_SAFE(m, 8, 2 * nphlmt) {
          wloop, chrpad(m)(1, 6);
        }
      }
    }
    numdcd++;
    inlmfs(cmn);
  }
  goto statement_3988;
statement_2560:
  FEM_DO_SAFE(i, 1, 2) {
    if (i == 1) {
      {
        write_loop wloop(buff77,
          "('$INCLUDE,[TSU]LINESCANM',i1,'.THL ',7(a6,1x),'$$')");
        wloop, nphlmt;
        FEM_DO_SAFE(m, 1, 7) {
          wloop, chrpad(m)(1, 6);
        }
      }
    }
    if (i == 2) {
      {
        write_loop wloop(buff77, format_2516);
        FEM_DO_SAFE(m, 8, 2 * nphlmt) {
          wloop, chrpad(m)(1, 6);
        }
      }
    }
    numdcd++;
    inlmfs(cmn);
  }
  goto statement_3988;
  //C     write (*,*) ' Internally encoded card '
statement_2580:
  numdcd++;
  inlmfs(cmn);
  goto statement_3988;
  //C           =================  End line-model F-scan building of network =======
statement_5823:
  if (noutpr == 0) {
    write(kunit6, "('+BLANK CARD TERMINATING BRANCH CARDS.')");
  }
  //C reset NFSCAN for 2nd and 3rd LMFS cases
  nfscan = 0;
  if (ntot <= lbus) {
    goto statement_4192;
  }
  iprint = 1;
  lstat(19) = 110;
  goto statement_9000;
statement_4192:
  if (ksat == 0) {
    goto statement_200;
  }
statement_110:
  n1 = 0;
  n2 = 0;
  n3 = 0;
  n4 = 0;
  ityold = itype;
  FEM_DO_SAFE(i, 1, ntot) {
    if (bus1 == bus(i)) {
      n1 = i;
    }
    if (bus2 == bus(i)) {
      n2 = i;
    }
    if (bus3 == bus(i)) {
      n3 = i;
    }
    if (bus4 == bus(i)) {
      n4 = i;
    }
  }
  if (model == 0) {
    goto statement_4005;
  }
  //C     ITYPE GETS NEGATIVE SIGN INTERNALLY FOR 2ND TO MTH PHASE          M29.1262
  //C     OF A UNTRANSPOSED LINE                                            M29.1263
  if (icheck == 3) {
    itype = -iabsz(itype);
  }
statement_4005:
  if (bus1 != text7) {
    goto statement_4110;
  }
  if (bus2 != text8) {
    goto statement_4110;
  }
  if (ksat > 0) {
    goto statement_4040;
  }
  if (bus3 != text9) {
    goto statement_4003;
  }
  if (bus4 != text10) {
    goto statement_4003;
  }
  read(abuff, "(26x,a6,e6.2)"), bus6, yzero;
  if (noutpr == 0) {
    write(kunit6,
      "('+3-PHASE XFORMER REQUEST.  ''',a6,'''  ',e12.4)"), bus6,
      yzero;
  }
  if (yzero > 0.0f) {
    goto statement_3998;
  }
  kill = 52;
  lstat(16) = 1;
  lstat(19) = 3998;
  goto statement_9200;
statement_3998:
  kph = 1;
  goto statement_100;
statement_4003:
  read(abuff, "(26x,2e6.2,a6,e6.2,29x,i1)"), tr(it), tx(it), bus5, rmag, ioutmg;
  if (ioutmg < 2) {
    goto statement_3400;
  }
  nv++;
  if (nv <= lsiz12) {
    goto statement_3400;
  }
  iprint = 11;
  lstat(19) = 3400;
  goto statement_9000;
statement_3400:
  ntot++;
  bus(ntot) = bus5;
  if (bus5 != blank) {
    goto statement_3401;
  }
  kill = 161;
  lstat(19) = 3401;
  goto statement_9200;
statement_3401:
  nodtop = ntot;
  kswtch++;
  if (kswtch <= lswtch) {
    goto statement_4004;
  }
  kill = 47;
  lstat(19) = 4010;
  lstat(16) = lswtch;
  goto statement_9200;
statement_4004:
  nextsw(kswtch) = ntot;
  if (kph > 0) {
    kph++;
  }
  if (n3 != 1) {
    goto statement_4002;
  }
  if (noutpr == 0) {
    write(kunit6, "('+SAT. XFORMER.',2x,3e11.3)"), tr(it), tx(it), rmag;
  }
  ksat = -1;
  inonl++;
  if (inonl <= lnonl) {
    goto statement_4011;
  }
statement_4012:
  iprint = 9;
  lstat(19) = 4012;
  goto statement_9000;
statement_4011:
  vzer5(inonl) = tr(it);
  anonl(inonl) = tx(it);
  cmn.ci1 = 0.0f;
  cmn.ck1 = 0.0f;
  nonlad(inonl) = ichar + 1;
  itype = 98;
  nltype(inonl) = -98;
  curr(inonl) = 1.0f;
  if (iprsup >= 2) {
    write(lunit6, "(/,' AT 4014 ',7i10)"), ksat, it, ichar, ntot, it3, inonl;
  }
  lstat(18) = 187;
  goto statement_186;
statement_4002:
  if (noutpr == 0) {
    write(kunit6,
      "('+TRANSFORMER COPY USING REFERENCE NAME ''',a6,'''.')"), bus3;
  }
  ktref = 1;
statement_4006:
  if (ktref <= kswtch) {
    goto statement_4007;
  }
  kill = 48;
  lstat(19) = 4007;
  goto statement_9200;
statement_4007:
  if (n3 == nextsw(ktref)) {
    goto statement_4008;
  }
  ktref++;
  goto statement_4006;
statement_4008:
  i = isourc(ktref);
  tclose(kswtch) = tclose(ktref);
  topen(kswtch) = topen(ktref);
  if (i <= 0) {
    goto statement_4027;
  }
  inonl++;
  if (inonl > lnonl) {
    goto statement_4012;
  }
  nltype(inonl) = nltype(i);
  nonlad(inonl) = nonlad(i);
  nonle(inonl) = nonle(i);
  vzer5(inonl) = vzer5(i);
  anonl(inonl) = anonl(i);
  vnonl(inonl) = 0.0f;
  curr(inonl) = curr(i);
  isourc(kswtch) = inonl;
statement_4027:
  ksat = 1;
  goto statement_100;
statement_4040:
  if (itype == ksat) {
    goto statement_4045;
  }
  kmswit(kswtch) = ibr;
  crit(kswtch) = ksat - 1;
  if (ksat >= 3) {
    goto statement_4093;
  }
  bus1 = cmn.trash;
  lstat(19) = 4093;
  goto statement_4067;
statement_4093:
  ksat = 0;
  if (isourc(kswtch) > 0) {
    num99++;
  }
  if (ktref == 0) {
    goto statement_4041;
  }
  lstat(19) = 4040;
  goto statement_4067;
statement_4041:
  if (kph == 4) {
    kph = 0;
  }
  if (iprsup < 3) {
    goto statement_84041;
  }
  write(lunit6,
    "(/,' DONE WITH SAT. XFORMER AT 34041.  KSWTCH, IBR, IT, INONL, ICHAR= ',"
    "5i10)"),
    kswtch, ibr, it, inonl, ichar;
  {
    write_loop wloop(cmn, lunit6,
      "(/,' LINEAR BRANCH TABLE.',/,13x,'ROW',11x,'KBUS',11x,'MBUS',13x,'NR',"
      "9x,'LENGTH',9x,'KODEBR',12x,'BUS',/(1x,6i15,a15))");
    FEM_DO_SAFE(i, 1, ibr) {
      wloop, i, kbus(i), mbus(i), nr(i), length(i), kodebr(i), bus(i);
    }
  }
  n = ichar;
  if (inonl > n) {
    n = inonl;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' N.L. ELEM ARRAYS.',/,6x,'ROW',3x,'NONLK',3x,'NONLM',2x,'NLTYPE',"
      "2x,'NONLAD',3x,'NONLE',10x,'ANONL',10x,'VZERO',10x,'VCHAR',9x,'GSLOPE',"
      "10x,'CCHAR',/(1x,6i8,5e15.5))");
    FEM_DO_SAFE(i, 1, n) {
      wloop, i, nonlk(i), nonlm(i), nltype(i), nonlad(i), nonle(i),
        anonl(i), vzer5(i), vchar(i), gslope(i), cchar(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' SWITCH ARRAYS WITH XFORMER INFO.',/,11x,'MODSWT',4x,'KMSWIT',4x,"
      "'ISOURC',4x,'NEXTSW',5x,'ICRIT',6x,'KPOS',9x,'TCLOSE',9x,' TOPEN',/(7x,"
      "6i10,2e15.5))");
    FEM_DO_SAFE(i, 1, kswtch) {
      wloop, modswt(i), kmswit(i), isourc(i), nextsw(i), crit(i),
        kpos(i), tclose(i), topen(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' LUMPED PARAM STORAGE TR, TX, C',/(1x,i10,3e20.6))");
    FEM_DO_SAFE(i, 1, it) {
      wloop, i, tr(i), tx(i), c(i);
    }
  }
statement_84041:
  if (n1 != 1) {
    goto statement_4005;
  }
  if (n2 != 1) {
    goto statement_4005;
  }
  goto statement_200;
statement_4045:
  ksat++;
  if (noutpr == 0) {
    write(kunit6, "('+  WINDING',i2,'.')"), itype;
  }
  if (itype > 1) {
    goto statement_4034;
  }
  modswt(kswtch) = ibr + 1;
  if (ioutmg <= 1) {
    goto statement_14045;
  }
  ibrnch(nv) = nodtop;
  jbrnch(nv) = n2;
  if (ioutmg == 2) {
    ioutmg = 0;
  }
statement_14045:
  if (kph <= 0) {
    goto statement_4034;
  }
  if (kph > 2) {
    goto statement_4031;
  }
  keept = nodtop;
  keepb = n2;
  goto statement_4034;
statement_4031:
  ibrinc(cmn);
  kbus(ibr) = nodtop;
  mbus(ibr) = n2;
  if (kph > 3) {
    goto statement_4033;
  }
  nr(ibr) = it;
  kodebr(ibr) = 1;
  length(ibr) = 2;
  tr(it) = yzero;
  ideal = it;
  move0(tx, it, ll3);
  move0(c, it, ll3);
  it++;
  ibrinc(cmn);
  nr(ibr) = it;
  tr(it) = -yzero;
  it++;
  tr(it) = yzero;
  it++;
  kbus(ibr) = keepb;
  ntot++;
  bus(ntot) = bus6;
  mbus(ibr) = ntot;
  keepb = ntot;
statement_64033:
  modswt(kswtch) = ibr + 1;
  kodebr(ibr) = 1;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' IDEAL XFORMER INTERCONNECT, AT 54033.  YZERO =',e15.6,5i12,/(1x,"
      "10i12))"),
      yzero, kswtch, ibr, it, inonl, ichar, kph, ksat, ideal, keepb,
      keept, ntot, nodtop, n1, n2;
  }
  goto statement_4034;
statement_4033:
  nr(ibr) = ideal;
  length(ibr) = -2;
  kodebr(ibr) = 1;
  ibrinc(cmn);
  kbus(ibr) = keepb;
  mbus(ibr) = keept;
  nr(ibr) = ideal + 1;
  goto statement_64033;
statement_4034:
  if (ktref == 0) {
    goto statement_4044;
  }
  if (ksat > 2) {
    goto statement_4065;
  }
  if (kph == 2) {
    yzero = 2.0f * yzero / fem::pow2(tclose(ktref));
  }
  if (isourc(ktref) <= 0) {
    goto statement_34035;
  }
  nonlk(inonl) = nodtop;
  nonlm(inonl) = n2;
  if (ioutmg > 0) {
    nonlm(inonl) = -nonlm(inonl);
  }
statement_34035:
  iref = modswt(ktref);
  ibrinc(cmn);
  nr(ibr) = nr(iref);
  length(ibr) = -1;
  kbus(ibr) = n1;
  mbus(ibr) = nodtop;
  read(abuff, format_142), iout;
  if (iout > 0) {
    mbus(ibr) = -mbus(ibr);
  }
  kpos(kswtch) = n2;
statement_44035:
  iref++;
  n5 = fem::iabs(length(iref));
  if (iprsup > 3) {
    write(lunit6,
      "(/,' REF. COMP. COPY OF R1-L1 AND MAG. BRANCH, AT 74035',/,1x,8i15)"),
      ibr, it, ktref, iref, n5, kbus(ibr), mbus(ibr);
  }
  if (n5 == 2) {
    goto statement_100;
  }
  ibrinc(cmn);
  nr(ibr) = nr(iref);
  length(ibr) = -1;
  kbus(ibr) = nodtop;
  mbus(ibr) = n2;
  i = fem::iabs(nr(ibr));
  if (tr(i) != 0.0f) {
    goto statement_44035;
  }
  if (ioutmg > 0) {
    mbus(ibr) = -mbus(ibr);
  }
  goto statement_44035;
statement_4044:
  read(abuff, "(26x,3e6.2,35x,i1)"), tr(it), tx(it), c(it), iout;
  if (noutpr == 0) {
    write(kunit6, "('+  WINDING',i2,'. ',3e12.4)"), itype, tr(it), tx(it),
      c(it);
  }
  i = it + 1;
  move0(tr, i, ll2);
  move0(tx, i, ll2);
  move0(c, i, ll2);
  if (c(it) > 0.0f) {
    goto statement_4047;
  }
  kill = 52;
  lstat(19) = 4047;
  lstat(16) = 3;
  goto statement_9200;
statement_4047:
  if (ksat > 2) {
    goto statement_4070;
  }
  turn1 = c(it);
  if (kph == 2) {
    yzero = 2.0f * yzero / fem::pow2(turn1);
  }
  kpos(kswtch) = n2;
  tclose(kswtch) = turn1;
  c(it) = 0.0f;
  if (tr(it) != 0.0f) {
    goto statement_4049;
  }
  if (tx(it) != 0.0f) {
    goto statement_4049;
  }
  lstat(19) = 4049;
  kill = 52;
  lstat(16) = 2;
  goto statement_9200;
statement_4049:
  ibrinc(cmn);
  kbus(ibr) = n1;
  mbus(ibr) = nodtop;
  if (iout > 0) {
    mbus(ibr) = -mbus(ibr);
  }
  length(ibr) = 1;
  nr(ibr) = -it;
  it++;
  if (rmag == 0.0f) {
    goto statement_4052;
  }
  tr(it) = rmag;
statement_4048:
  ibrinc(cmn);
  kbus(ibr) = nodtop;
  mbus(ibr) = n2;
  length(ibr) = 1;
  nr(ibr) = -it;
  it++;
  if (tx(it - 1) != 0.0f) {
    goto statement_100;
  }
statement_4052:
  it3 = nonlad(inonl);
  if (kph <= 2) {
    goto statement_4054;
  }
  if (tclose(kswtch) == tclose(kswtch - 1)) {
    goto statement_4054;
  }
statement_24054:
  kill = 52;
  lstat(19) = 4054;
  lstat(16) = 4;
  goto statement_9200;
statement_4054:
  ncoil = -nonle(inonl) - it3;
  if (ncoil > 0) {
    goto statement_4056;
  }
  ichar = it3 - 1;
  inonl = inonl - 1;
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' MAG. BR. NOT ACTUALLY N.L., AT 4053.',/,1x,8i15)"), it,
      ibr, ichar, inonl, kswtch, ncoil, ksat, kph;
  }
  if (ncoil < 0) {
    goto statement_100;
  }
  tx(it) = cmn.delta2 / gslope(it3) * xunits;
  if (ioutmg > 0) {
    n2 = -n2;
  }
  goto statement_4048;
statement_4056:
  nonlk(inonl) = nodtop;
  nonlm(inonl) = n2;
  if (ioutmg > 0) {
    nonlm(inonl) = -nonlm(inonl);
  }
  isourc(kswtch) = inonl;
  goto statement_100;
statement_4065:
  ibrinc(cmn);
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  nr(ibr) = nr(iref);
  kodebr(ibr) = 1;
  length(ibr) = -fem::iabs(length(iref));
  ibrinc(cmn);
  kbus(ibr) = nextsw(kswtch);
  mbus(ibr) = kpos(kswtch);
  kodebr(ibr) = 1;
  iref++;
  nr(ibr) = nr(iref);
  iref++;
  if (itype <= crit(ktref)) {
    goto statement_4068;
  }
  lstat(19) = 4067;
statement_4067:
  kill = 49;
  j = nextsw(ktref);
  bus1 = bus(j);
  lstat(13) = ksat;
  lstat(16) = crit(ktref);
  goto statement_9200;
statement_4068:
  if (itype < crit(ktref)) {
    goto statement_100;
  }
  ktref = 0;
  goto statement_100;
statement_4070:
  d1 = c(it) / turn1;
  if (ksat > 3) {
    goto statement_4073;
  }
  topen(kswtch) = c(it);
  if (kph <= 2) {
    goto statement_4073;
  }
  if (topen(kswtch) != topen(kswtch - 1)) {
    goto statement_24054;
  }
statement_4073:
  if (tx(it) != 0.0f) {
    goto statement_4071;
  }
  kill = 52;
  lstat(19) = 4071;
  lstat(16) = 2;
  goto statement_9200;
statement_4071:
  c(it) = 0.0f;
  tx(it) = tx(it) / xunits;
  cut1 = 1.0f / tx(it);
  cut2 = cut1 * d1;
  cut3 = -tr(it) * cut1;
  tr(it) = cut1;
  tx(it) = cut3;
  ibrinc(cmn);
  if (iprsup >= 2) {
    write(lunit6, "(/,' ROW 1 OF 2X2 AT 4076 ',i10,5e15.4,/,1x)"),
      it, d1, cut1, cut2, tr(it), tx(it);
  }
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  length(ibr) = 2;
  nr(ibr) = it;
  kodebr(ibr) = 1;
  ibrinc(cmn);
  it++;
  kbus(ibr) = nextsw(kswtch);
  mbus(ibr) = kpos(kswtch);
  kodebr(ibr) = 1;
  nr(ibr) = it;
  tr(it) = -cut2;
  it++;
  tr(it) = d1 * cut2;
  tx(it) = cut3;
  if (iprsup >= 2) {
    write(lunit6, "(/,' ROW 2 OF 2X2 AT 4084 ',i10,/,1x)"), it;
  }
  it++;
  goto statement_100;
statement_4110:
  if (bus1 != text3) {
    goto statement_4112;
  }
  kreqab = 1;
  if (noutpr == 0) {
    write(kunit6, "('+BEGIN COUPLED, LUMPED ELEMENTS USING (A), (B).')");
  }
  goto statement_100;
statement_4112:
  if (bus1 != text4) {
    goto statement_4114;
  }
  kreqab = 0;
  if (noutpr == 0) {
    write(kunit6, "('+BEGIN COUPLED, LUMPED ELEMENTS USING (R), (L).')");
  }
  goto statement_100;
statement_4114:
  if (bus1 != text5) {
    goto statement_7642;
  }
  if (bus2 != text6) {
    goto statement_7642;
  }
  icas = 1;
  iprsov(36) = it;
  iprsov(35) = ibr + 1;
  read(abuff, "(26x,i6,e6.2)"), nphcas, freqcs;
  if (noutpr == 0) {
    write(kunit6, "('+CASCADED-PI HEADER CARD.',i10,2x,e12.4)"), nphcas, freqcs;
  }
  idumy = 3 * nphcas;
  idumy = idumy * (idumy + 1) / 2;
  if (idumy < cmn.lpast) {
    goto statement_7671;
  }
  lstat(19) = 764;
  lstat(15) = 1;
  goto statement_76724;
statement_7671:
  idumy = nphcas * (nphcas + 1) / 2;
  if (idumy < lbus) {
    goto statement_100;
  }
  lstat(19) = 7671;
  lstat(15) = 2;
statement_76724:
  kill = 53;
  lstat(16) = idumy;
  lstat(12) = nphcas;
  goto statement_9200;
statement_7642:
  if (isgfd < 0) {
    goto statement_15;
  }
  if (bus1 != text11 || bus2 != text14) {
    goto statement_15;
  }
  length(ibr1 + 1) = -666;
  fddata(cmn, ikf, isfd, ibf);
  if (kill > 0) {
    goto statement_9200;
  }
  isgfd = -100;
  goto statement_100;
statement_15:
  iprint = 1;
  if (n1 != 0) {
    goto statement_130;
  }
  ntot++;
  lstat(19) = 7642;
  if (ntot > lbus) {
    goto statement_9000;
  }
  bus(ntot) = bus1;
  n1 = ntot;
statement_130:
  if (n2 != 0) {
    goto statement_140;
  }
  ntot++;
  lstat(19) = 130;
  if (ntot > lbus) {
    goto statement_9000;
  }
  bus(ntot) = bus2;
  n2 = ntot;
statement_140:
  if (ksat > 0) {
    goto statement_4040;
  }
  if (itype < 0) {
    goto statement_64117;
  }
  if (itype > 50 && itype <= 90) {
    goto statement_64117;
  }
  if (kolbeg > 0) {
    goto statement_132;
  }
  if (moldat > 0) {
    goto statement_64117;
  }
  {
    read_loop rloop(abuff(1), "(26x,9e6.2)");
    FEM_DO_SAFE(i, it, it2) {
      rloop, tr(i), tx(i), c(i);
    }
  }
  goto statement_64117;
statement_132:
  kolbeg = 27;
  nfrfld = 3 * (it2 - it + 1);
  frefld(cmn, voltbc(1));
  n9 = 1;
  FEM_DO_SAFE(i, it, it2) {
    tr(i) = voltbc(n9);
    tx(i) = voltbc(n9 + 1);
    c(i) = voltbc(n9 + 2);
    n9 += 3;
  }
statement_64117:
  if (kph == 0) {
    goto statement_4115;
  }
  kill = 50;
  lstat(15) = kph - 1;
  lstat(19) = 4115;
  goto statement_9200;
statement_4115:
  iprint = 2;
  itrans = 0;
  if (itype < 51) {
    goto statement_144;
  }
  if (itype > 90) {
    goto statement_144;
  }
statement_147:
  itrans = itype;
  itype = itype - 50;
  n8 = it2 - it + 1;
  if (kolbeg > 0) {
    goto statement_4243;
  }
  {
    read_loop rloop(abuff(1), "(26x,3(e6.2,e12.2))");
    FEM_DO_SAFE(i, it, it2) {
      rloop, tr(i), tx(i);
    }
  }
  goto statement_4246;
statement_4243:
  kolbeg = 27;
  nfrfld = 2 * n8;
  n9 = 1;
  frefld(cmn, voltbc(1));
  FEM_DO_SAFE(i, it, it2) {
    tr(i) = voltbc(n9);
    tx(i) = voltbc(n9 + 1);
    n9 += 2;
  }
statement_4246:
  move0(c, it, n8);
statement_144:
  if (itype > 2 && itype <= 50) {
    goto statement_143;
  }
  read(abuff, format_142), iout;
  if (iout <= 3) {
    goto statement_54208;
  }
  iout = 3;
  if (npower < maxpe) {
    goto statement_54201;
  }
  iprint = 18;
  lstat(19) = 142;
  goto statement_9000;
statement_54201:
  npower++;
  mpower = npower + maxpe;
  koutvp(npower) = nv + 1;
  if (itype < 90) {
    goto statement_54203;
  }
  koutvp(mpower) = -(inonl + 1);
  goto statement_54205;
statement_54203:
  koutvp(mpower) = ibr + 1;
statement_54205:
  if (iprsup >= 2) {
    write(lunit6, "(/,' POWER OUTPUT REQUEST',4i10)"), npower, maxpe,
      koutvp(npower), koutvp(mpower);
  }
statement_54208:
  if (iout < 2) {
    goto statement_143;
  }
  nv++;
  ibrnch(nv) = n1;
  jbrnch(nv) = n2;
  if (itype != 99) {
    goto statement_138;
  }
  if (n1 <= n2) {
    goto statement_138;
  }
  ibrnch(nv) = n2;
  jbrnch(nv) = n1;
statement_138:
  if (nv <= lsiz12) {
    goto statement_143;
  }
  iprint = 11;
  lstat(19) = 143;
  goto statement_9000;
statement_143:
  if (iout == 2) {
    iout = 0;
  }
  if (itype < 0) {
    n1 = -n1;
  }
  ibrinc(cmn);
  lstat(19) = 141;
  if (ibr > lbrnch) {
    goto statement_9000;
  }
  if (itype == 92) {
    icheck = 1;
  }
  switch (icheck) {
  case 1: goto statement_141;
  case 2: goto statement_162;
  case 3: goto statement_190;
  case 4: goto statement_177;
  case 5: goto statement_190;
  case 6: goto statement_8520;
  case 7: goto statement_8130;
  case 8: goto statement_8178;
  default: break;
  }
statement_141:
  icheck = 1;
  if (itype > 50) {
    goto statement_186;
  }
  if (iout > 0 && itype <= 0) {
    n2 = -n2;
  }
  if (bus3 != cmn.branch) {
    goto statement_6835;
  }
  n16 = 1;
  text15 = bus4;
  namea6(cmn, text15, n16);
  if (n16 == -cmn.intinf) {
    goto statement_6824;
  }
  lstat(19) = 6829;
  kill = 167;
  lstat(14) = n16;
  goto statement_9200;
statement_6824:
  n16 = 0;
  namea6(cmn, texta5, n16);
  namebr(ibr) = n16;
  bus3 = blank;
  bus4 = blank;
  n3 = 1;
  n4 = 1;
statement_6835:
  iold = 0;
  if (n3 == 1 && n4 == 1) {
    goto statement_156;
  }
  iold = 1;
  goto statement_155;
statement_150:
  ll = fem::iabs(length(iold));
  if (bus3 == cmn.copy) {
    goto statement_6841;
  }
  if (fem::iabs(kbus(iold)) != n3) {
    goto statement_28150;
  }
  if (fem::iabs(mbus(iold)) == n4) {
    goto statement_156;
  }
  goto statement_28150;
statement_6841:
  n14 = namebr(iold);
  if (bus4 == texvec(n14)) {
    goto statement_156;
  }
statement_28150:
  iold += ll;
statement_155:
  if (iold < ibr) {
    goto statement_150;
  }
  lstat(19) = 150;
  kill = 6;
  goto statement_9200;
statement_156:
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  if (iold != 0) {
    goto statement_175;
  }
  length(ibr) = 1;
  if (itype == 0) {
    goto statement_170;
  }
  ibr1 = ibr;
  kcount = 1;
  if (itype == 1) {
    goto statement_160;
  }
  if (itype == (-1)) {
    goto statement_190;
  }
  lstat(19) = 160;
statement_4218:
  kill = 3;
  lstat(16) = itype;
  goto statement_9200;
  //C     PI-EQUIVALENT ****************************************************M42.1971
statement_160:
  nr(ibr) = it;
  if (kreqab > 0) {
    kodebr(ibr) = 1;
  }
  if (moldat == 0) {
    goto statement_171;
  }
  if (kolbeg > 0) {
    goto statement_171;
  }
  read(abuff, format_8331), tr(it), tx(it), c(it);
statement_171:
  if (noutpr != 0) {
    goto statement_5411;
  }
  if (itrans > 0) {
    goto statement_54108;
  }
  write(kunit6, "('+1ST OF PI-CKT.',1x,3e11.3)"), tr(it), tx(it), c(it);
  goto statement_5411;
statement_54108:
  write(kunit6, "('+1ST OF COUPLED R-L.',5x,2e11.3)"), tr(it), tx(it);
statement_5411:
  icheck = 2;
  if (tr(it) == -6666.f && tx(it) == -6666.f) {
    isgfd = 100;
  }
  goto statement_8383;
statement_162:
  kcount++;
  if (itype != kcount) {
    goto statement_141;
  }
  length(ibr1) = kcount;
  if (kcount > mxphas) {
    mxphas = kcount;
  }
  it2 = it + itype - 1;
  if (moldat == 0) {
    goto statement_8352;
  }
  if (kolbeg > 0) {
    goto statement_8352;
  }
  FEM_DO_SAFE(it32, it, it2) {
    //C     READ INPUT CARD USING CIMAGE.                                     M28.2859
    if (it32 > it) {
      cimage(cmn);
    }
    read(abuff, format_8331), tr(it32), tx(it32), c(it32);
    if (noutpr != 0) {
      goto statement_8346;
    }
    if (it32 > it) {
      goto statement_8338;
    }
    write(kunit6, "('+PHASE',i3,3e13.4)"), itype, tr(it32), tx(it32), c(it32);
    goto statement_8346;
  statement_8338:
    write(kunit6, "('+',3x,'CONT.',3e13.4)"), tr(it32), tx(it32), c(it32);
  statement_8346:;
  }
  goto statement_163;
statement_8352:
  if (itype != 3) {
    goto statement_47634;
  }
  d3 = std::abs(tr(it)) + std::abs(tx(it)) + std::abs(tr(it + 1)) + std::abs(tx(it +
    1)) + std::abs(tr(it + 2)) + std::abs(tx(it + 2));
  if (d3 > 0.0f) {
    goto statement_47634;
  }
  d3 = tr(it - 3);
  d4 = tr(it - 2);
  d5 = (d3 + 2.0f * d4) / 3.f;
  d6 = (d3 - d4) / 3.f;
  tr(it - 3) = d5;
  tr(it - 1) = d5;
  tr(it + 2) = d5;
  tr(it - 2) = d6;
  tr(it) = d6;
  tr(it + 1) = d6;
  d3 = tx(it - 3);
  d4 = tx(it - 2);
  d5 = (d3 + 2.0f * d4) / 3.f;
  d6 = (d3 - d4) / 3.f;
  tx(it - 3) = d5;
  tx(it - 1) = d5;
  tx(it + 2) = d5;
  tx(it - 2) = d6;
  tx(it) = d6;
  tx(it + 1) = d6;
statement_47634:
  if (itrans > 0) {
    goto statement_21693;
  }
  it3 = it + 1;
  if (noutpr == 0) {
    write(kunit6, format_54104), tr(it), tx(it), c(it), tr(it3), tx(it3);
  }
  goto statement_21694;
statement_21693:
  it3 = itype + (it - 1);
  n3 = it + 2;
  if (it3 < n3) {
    n3 = it3;
  }
  if (noutpr == 0) {
    write(kunit6, format_54104), tr(it), tx(it), tr(it + 1), tx(it + 1), tr(n3);
  }
statement_21694:
  if (itype <= 3) {
    goto statement_163;
  }
  it3 = it + 3;
statement_165:
  it32 = it3 + 2;
  if (it2 < it32) {
    it32 = it2;
  }
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2011
  cimage(cmn);
  if (itrans == 0) {
    goto statement_168;
  }
  n8 = it32 - it3 + 1;
  if (kolbeg > 0) {
    goto statement_4254;
  }
  {
    read_loop rloop(abuff(1), "(26x,3(e6.2,e12.2))");
    FEM_DO_SAFE(i, it3, it32) {
      rloop, tr(i), tx(i);
    }
  }
  goto statement_4256;
statement_4254:
  kolbeg = 27;
  nfrfld = 2 * n8;
  n9 = 1;
  frefld(cmn, voltbc(1));
  FEM_DO_SAFE(i, it3, it32) {
    tr(i) = voltbc(n9);
    tx(i) = voltbc(n9 + 1);
    n9 += 2;
  }
statement_4256:
  move0(c, it3, n8);
  if (noutpr == 0) {
    write(kunit6, format_54104), tr(it3), tx(it3), tr(it3 + 1), tx(it3 + 1),
      tr(it32);
  }
  goto statement_169;
statement_168:
  if (kolbeg > 0) {
    goto statement_4262;
  }
  {
    read_loop rloop(abuff(1), "(26x,9e6.2)");
    FEM_DO_SAFE(i, it3, it32) {
      rloop, tr(i), tx(i), c(i);
    }
  }
  goto statement_4264;
statement_4262:
  nfrfld = 3 * (it32 - it3 + 1);
  kolbeg = 27;
  n9 = 1;
  frefld(cmn, voltbc(1));
  FEM_DO_SAFE(i, it3, it32) {
    tr(i) = voltbc(n9);
    tx(i) = voltbc(n9 + 1);
    c(i) = voltbc(n9 + 2);
    n9 += 3;
  }
statement_4264:
  i = it3;
  if (it32 > i) {
    i++;
  }
  n3 = i;
  if (noutpr == 0) {
    write(kunit6, format_54104), tr(it3), tx(it3), c(it3), tr(n3), tx(n3);
  }
statement_169:
  if (it32 == it2) {
    goto statement_163;
  }
  it3 += 3;
  goto statement_165;
statement_163:
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  nr(ibr) = it;
  if (kreqab > 0) {
    kodebr(ibr) = 1;
  }
  it += itype;
  if (icas == -1 && itype == 2 * nphcas) {
    goto statement_148;
  }
  if (icas <= 0) {
    goto statement_100;
  }
  if (itype < nphcas) {
    goto statement_100;
  }
  over3(cmn);
  goto statement_1000;
statement_148:
  iend = ibr1 + nphcas - 1;
  FEM_DO_SAFE(i, ibr1, iend) {
    kodebr(i) = -2;
  }
  n3 = ibr1 + nphcas;
  n4 = ibr1 + ibr;
  FEM_DO_SAFE(i, n3, n4) {
    kbus(i) = 0;
    mbus(i) = 0;
  }
  icas = 0;
  ibr = ibr - nphcas;
  length(ibr1) = nphcas;
  if (nphcas > mxphas) {
    mxphas = nphcas;
  }
  goto statement_100;
  //C     SERIES R-L-C  ****************************************************M42.2044
statement_170:
  nr(ibr) = -it;
  icheck = 1;
  if (moldat == 0) {
    goto statement_8371;
  }
  if (kolbeg > 0) {
    goto statement_8371;
  }
  read(abuff, format_8331), tr(it), tx(it), c(it);
statement_8371:
  if (noutpr == 0) {
    write(kunit6, "('+SERIES R-L-C.',2x,3e11.3)"), tr(it), tx(it), c(it);
  }
statement_8383:
  d1 = std::abs(tr(it)) + std::abs(tx(it)) + std::abs(c(it));
  if (d1 != 0.0f) {
    goto statement_4220;
  }
  kill = 4;
  lstat(19) = 5411;
  goto statement_9200;
statement_4220:
  it++;
  goto statement_100;
  //C     DATA ALREADY AVAILABLE IN REFERENCE BRANCH ***********************M42.2053
statement_175:
  if (imodel(iold) == -3 || imodel(iold) == -4) {
    goto statement_8100;
  }
  if (imodel(iold) == -2) {
    goto statement_8100;
  }
  if (kodsem(iold) == 0) {
    goto statement_8600;
  }
  ipunch = fem::iabs(kodebr(iold));
  ips1 = 1;
  icheck = 6;
  if (noutpr == 0) {
    write(kunit6, format_21696), bus3, bus4;
  }
  goto statement_8560;
statement_8520:
  n6 = 5;
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  if (noutpr == 0) {
    write(kunit6, format_54111);
  }
  iold++;
  ips1++;
statement_8540:
  if (itype == -1) {
    goto statement_8560;
  }
  kill = 169;
  lstat(19) = 8550;
  goto statement_9200;
statement_8560:
  kodebr(ibr) = -ipunch;
  kodsem(ibr) = kodsem(iold);
  length(ibr) = length(iold);
  ci(ibr) = ci(iold);
  ck(ibr) = ck(iold);
  cik(ibr) = cik(iold);
  cki(ibr) = cki(iold);
  n3 = nr(iold);
  nr(ibr) = n3;
  n5 = ifx + 1;
  ifx += n3;
  if (ifx <= lhist) {
    goto statement_8570;
  }
  iprint = 22;
  lstat(19) = 8570;
  goto statement_9000;
statement_8570:
  indhst(ibr) = n5;
  n3 = indhst(iold);
  if (ci(iold) > 0.0f) {
    n6++;
  }
  if (kodsem(iold) > 0) {
    n6 = 6;
  }
  if (n6 > 0) {
    mover(cnvhst(n3), cnvhst(n5), n6);
  }
  if (ips1 < ipunch) {
    goto statement_100;
  }
  if (cki(iold) > 0.0f) {
    goto statement_8580;
  }
  icheck = 1;
  goto statement_100;
statement_8580:
  ibrinc(cmn);
  if (ibr <= lbrnch) {
    goto statement_8590;
  }
  iprint = 2;
  lstat(19) = 8590;
  goto statement_9000;
statement_8590:
  n6 = 0;
  kbus(ibr) = -1;
  mbus(ibr) = 1;
  goto statement_8540;
statement_8100:
  if (imodel(iold) == -2) {
    goto statement_8987;
  }
  if (itype < 0) {
    write(kunit6, "('+Reference cable branch: ',i2,4a6)"), itype,
      bus1, bus2, bus3, bus4;
  }
  interp();
  icheck = 8;
  model = length(iold);
  ibr1 = ibr;
  length(ibr1) = length(iold);
statement_8187:
  litype(ibr) = litype(iold);
  //C     IMODL(IBR) = IMODL(IOLD)
  imodel(ibr) = imodel(iold);
  //C      MATCON(IBR) = MATCON(IOLD)                                       M44. 137
  //C      IFBRC(IBR) = IBR
  //C      ICRBF(IBR) = IBR
  ifx++;
  if (ifx > lhist) {
    FEM_STOP(0);
  }
  ifsem++;
  if (ifsem > lfsem) {
    FEM_STOP(0);
  }
  cki(ibr) = cki(iold);
  itemq = kodsem(iold);
  sconst(ifsem) = sconst(itemq);
  kodsem(ibr) = ifsem;
  indhst(ibr) = ifx;
  ckkjm(ibr) = ckkjm(iold);
  iihst = indhst(iold);
  cnvhst(ifx) = cnvhst(iihst);
  inoff5 = 5 * lbrnch;
  namebr(inoff5 + ibr) = cnvhst(ifx) / cmn.deltat + 1;
  itemq += 7 * cki(iold) + 11 * ckkjm(iold) + 9 + nn17;
  ifsem += 7 * cki(ibr) + 11 * ckkjm(ibr) + 9 + nn17;
  if (ifsem > lfsem) {
    FEM_STOP(0);
  }
  nfir = kodsem(iold) + 1;
  nsec = kodsem(ibr) + 1;
  mover(sconst(nfir), sconst(nsec), itemq - 1);
  //C      IFX = IFX + 14
  ifx += 19 + 1 + nycmp;
  if (model != -itype) {
    goto statement_100;
  }
  if (-itype == model) {
    goto statement_50087;
  }
statement_50087:
  ifq = ifsem;
  //C                                                   !the refernce branchM44. 177
  inoff1 = lbrnch;
  inoff2 = 2 * lbrnch;
  inoff3 = 3 * lbrnch;
  inoff4 = 4 * lbrnch;
  icheck = 1;
  nphs = model;
  nphs2 = fem::pow2(model);
  nphsu = (model + 1) * model / 2;
  ibr2 = ibr - nphs + 1;
  ibr3 = ibr - nphs + 3;
  ifq++;
  namebr(inoff2 + ibr2) = ifq;
  namebr(inoff1 + ibr2) = idm;
  namebr(inoff4 + ibr2) = idu;
  //C        IADRSM(IOLD) contains the index for first cell of Qii(1,1), forM44. 196
  //C        double six phases circuits it should be 1*6+7(16+9+10+11+12+12)M44. 197
  //C+7(21+16+17+10+10+17)+6*8=1181 which been added 1 gives 1st cell of QiiM44. 198
  koff1 = 900;
  koff2 = koff1 + isecti;
  koff3 = koff2 + isecti;
  koff4 = koff3 + isecti;
  koff5 = koff4 + isecti;
  koff6 = koff5 + isecti;
  koff7 = koff6 + isecti;
  koff8 = koff7 + isecti;
  koff9 = koff8 + isecti;
  koff10 = koff9 + isecti;
  koff13 = koff10 + isecti;
  koff14 = koff13 + isecti;
  koff15 = koff14 + isecti;
  koff16 = koff15 + isecti;
  koff17 = koff16 + isecti;
  koff18 = koff17 + isecti;
  koff19 = koff18 + isecti;
  koff20 = koff19;
  if (kgroup != 1) {
    semaux(koff19) = 1;
  }
  semaux(koff19) += kgroup;
  nq = 0;
  interm = iold - model + 1;
  ibrter = ibr - model + 1;
  nphs2 = fem::pow2(length(interm));
  //C     KQ = IADRSU( INTERM ) !index of Q - 'M'atrix for referenced branchM44. 224
  kq = namebr(inoff1 + interm);
  //C     NKQ = IADRSU( IBRTER ) !index of Q - 'M'atrix for reference branchM44. 226
  nkq = namebr(inoff1 + ibrter);
  FEM_DO_SAFE(i, 1, nphs2) {
    semaux(koff20 + nkq) = semaux(koff20 + kq);
    //C     NTERMQ(NKQ) = NTERMQ(KQ)  !load # terms form refd brch to ref brchM44. 231
    //C     QK0(NKQ)    = QK0(KQ)     !Load feedforward coefficient Qk0 of QiiM44. 232
    nkq++;
    kq++;
  }
  iold = iold - model + 1;
  isec = iold + 1;
  kq = namebr(inoff2 + iold);
  kq1 = namebr(inoff3 + iold);
  inew = ibr - model + 1;
  nkq = namebr(inoff2 + inew);
  kq1 = kq1 - kq + 1;
  mover(sconst(kq), sconst(nkq), kq1);
  nkq += kq1 - 1;
  ifq = nkq + (nkq - namebr(inoff2 + inew) + 1 - nphs2) * 3 / 2 + 2 * nphs2;
  ifsem = ifq;
  namebr(inoff3 + ibr2) = nkq;
  idm += nphs2;
  idu += nphsu;
  if (model != -itype) {
    goto statement_100;
  }
  icheck = 1;
  kgroup = 1;
  goto statement_100;
statement_8178:
  iold++;
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  goto statement_8187;
statement_8987:
  icheck = 7;
  model = length(iold);
  ibr1 = ibr;
  length(ibr1) = 0;
  litype(ibr) = litype(iold);
statement_8110:
  if (itype < 0 && noutpr == 0) {
    write(kunit6, "('+Reference Jose''s branch: ',i2,4a6)"), itype,
      bus1, bus2, bus3, bus4;
  }
  interp();
  cki(ibr) = cki(iold);
  ckkjm(ibr) = ckkjm(iold);
  imodel(ibr) = imodel(iold);
  n5 = ifsem + 1;
  n6 = 7 * cki(ibr) + 7 * ckkjm(ibr) + 5;
  ifsem += n6;
  if (ifsem > lfsem) {
    goto statement_8170;
  }
  kodsem(ibr) = n5;
  n3 = kodsem(iold);
  mover(sconst(n3), sconst(n5), n6);
  n5 = ifx + 1;
  ifx += 15;
  if (ifx > lhist) {
    goto statement_8150;
  }
  indhst(ibr) = n5;
  n3 = indhst(iold);
  cnvhst(n5) = cnvhst(n3);
  length(ibr1)++;
  if (model > length(ibr1)) {
    goto statement_100;
  }
  icheck = 1;
  itranm = model;
  model = 0;
  goto statement_100;
statement_8130:
  iold++;
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  goto statement_8110;
statement_8150:
  iprint = 22;
  lstat(19) = 8150;
  goto statement_9000;
statement_8170:
  iprint = 20;
  lstat(19) = 8170;
  goto statement_9000;
statement_8600:
  nr(ibr) = nr(iold);
  namebr(ibr) = namebr(iold);
  length(ibr) = -fem::iabs(length(iold));
  litype(ibr) = litype(iold);
  kodebr(ibr) = kodebr(iold);
  cik(ibr) = cik(iold);
  ci(ibr) = ci(iold);
  ck(ibr) = ck(iold);
  cki(ibr) = cki(iold);
  ibr1 = ibr;
  if (noutpr == 0) {
    write(kunit6, format_21696), bus3, bus4;
  }
  if (ll == 1) {
    goto statement_178;
  }
  mbus(ibr) = fem::iabs(n2);
  icheck = 4;
  ii = 2;
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2065
statement_176:
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_6634;
  }
  read(abuff, format_1), itype, bus1, bus2;
  goto statement_6637;
statement_6634:
  nfrfld = 1;
  frefld(cmn, voltbc(1));
  itype = voltbc(1);
  nfrfld = 2;
  nright = -1;
  freone(cmn, d1);
  bus1 = texta6(1);
  bus2 = texta6(2);
  nright = 0;
statement_6637:
  if (itype > 50 && itype < 91) {
    itype = itype - 50;
  }
  if (fem::iabs(itype) == ii) {
    goto statement_110;
  }
  lstat(19) = 176;
  goto statement_4218;
statement_177:
  if (noutpr == 0) {
    write(kunit6, format_54111);
  }
  iold++;
  kbus(ibr) = n1;
  mbus(ibr) = n2;
  nr(ibr) = nr(iold);
  kodebr(ibr) = kodebr(iold);
  cki(ibr) = cki(iold);
  cik(ibr) = cik(iold);
  ci(ibr) = ci(iold);
  ck(ibr) = ck(iold);
  ii++;
  if (ii <= ll) {
    goto statement_176;
  }
statement_178:
  icheck = 1;
  itranm = 1;
  if (icas != 1) {
    goto statement_100;
  }
  icas = 0;
  cimage(cmn);
  read(abuff, "(2x,2a6)"), bus1, bus2;
  if (bus1 != text1) {
    goto statement_7662;
  }
  if (bus2 == text2) {
    goto statement_76617;
  }
statement_7662:
  lstat(19) = 7662;
  kill = 58;
  goto statement_9200;
statement_76617:
  if (noutpr == 0) {
    write(kunit6, "('+TERMINATION OF CASCADED PI.')");
  }
  goto statement_100;
  //C     PROCESS NONLINEAR ELEMENT INSIDE SUBROUTINE  "NONLN2" .           M28.2879
statement_186:
  nonln2(cmn);
  if (kill > 0) {
    goto statement_9200;
  }
  goto statement_100;
  //C     PROCESS DISTRIBUTED LINE INSIDE SUBROUTINE  "DISTR2" .            M28.2883
statement_190:
  distr2(cmn);
  if (kill > 0) {
    goto statement_9200;
  }
  if (nchain != 4) {
    goto statement_197;
  }
  over4(cmn);
  goto statement_1000;
statement_197:
  i = lstat(18);
  if (i == 100) {
    goto statement_100;
  }
  if (i == 141) {
    goto statement_141;
  }
  stoptp(cmn);
statement_200:
  it = it - 1;
  if (mxphas * mxphas < cmn.lsiz26) {
    goto statement_1641;
  }
  kill = 1;
  iprint = 26;
  lstat(19) = 200;
  lstat(13) = mxphas;
  goto statement_9000;
statement_1641:
  lastov = nchain;
  nchain = 5;
  ktrlsw(3) = 0;
  FEM_DO_SAFE(i, 1, ibr) {
    if (litype(i) >= 0) {
      goto statement_1642;
    }
    litype(i) = -litype(i);
  statement_1642:;
  }
statement_8675:
  ibrnam++;
  if (ibrnam > ibr) {
    goto statement_8680;
  }
  namebr(ibrnam) = 1;
  if (nmauto == 0) {
    goto statement_8675;
  }
  nmincr(cmn, text16, ibrnam);
  n24 = 0;
  namea6(cmn, text16, n24);
  namebr(ibrnam) = n24;
  goto statement_8675;
statement_8680:
  inonam++;
  if (inonam > inonl) {
    goto statement_8681;
  }
  namebr(inonam) = 1;
  if (nmauto == 0) {
    goto statement_8680;
  }
  nmincr(cmn, text17, inonam);
  n24 = 0;
  namea6(cmn, text17, n24);
  namenl(inonam) = n24;
  goto statement_8680;
statement_8681:
  if (iprsup >= 1) {
    write(lunit6,
      "(' BOTTOM OF \"OVER2\".','    NTOT     IBR      IT   INONL  MXPHAS',/,"
      "19x,10i8)"),
      ntot, ibr, it, inonl, mxphas;
  }
  if (iprsup <= 2) {
    goto statement_9900;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' BRANCH-TABLE INTEGER VECTORS AT END  ''OVER2'' .',/,"
      "'     ROW    KBUS    MBUS      NR  KODEBR  LENGTH  KODSEM  INDHST  LITY"
      "PE  IMODEL  NAMEBR',/(11i8))");
    FEM_DO_SAFE(k, 1, ibr) {
      wloop, k, kbus(k), mbus(k), nr(k), kodebr(k), length(k), kodsem(k),
        indhst(k), litype(k), imodel(k), namebr(k);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,5x,'ROW',7x,'BUS',13x,'CI',13x,'CK',12x,'CIK',12x,'CKI',10x,'CKKJM',"
      "/(i8,4x,a6,5e15.6))");
    FEM_DO_SAFE(k, 1, ibr) {
      wloop, k, bus(k), ci(k), ck(k), cik(k), cki(k), ckkjm(k);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' ROWS 1 THROUGH IT OF PARAMETERS FOLLOW:',/,7x,'ROW',13x,'TR',13x,"
      "'TX',14x,'R',14x,'C',/(i10,4e15.5))");
    FEM_DO_SAFE(i, 1, it) {
      wloop, i, tr(i), tx(i), r(i), c(i);
    }
  }
  goto statement_9900;
statement_9000:
  lstat(16) = iprint;
  kill = 1;
statement_9200:
  nchain = 51;
  lstat(18) = 2;
statement_9900:
  if (iprsup >= 1) {
    write(lunit6,
      "(' EXIT MODULE \"OVER2\".','     IBR   INONL    NTOT    KILL',/,21x,"
      "10i8)"),
      ibr, inonl, ntot, kill;
  }
} // over2

void cxred(
  arr_ref<double> a,
  arr_ref<double> c,
  int const& n,
  int const& m)
{
  a(dimension(1));
  c(dimension(1));
  int j = fem::int0;
  double w = fem::double0;
  int ij = fem::int0;
  double h1 = fem::double0;
  double g1 = fem::double0;
  double x = fem::double0;
  arr_1d<30, double> b(fem::fill0);
  arr_1d<30, double> d(fem::fill0);
  int k = fem::int0;
  int ik = fem::int0;
  int i1 = fem::int0;
  int i = fem::int0;
  double h2 = fem::double0;
  double g2 = fem::double0;
  int i2 = fem::int0;
  int L = fem::int0;
  double y = fem::double0;
  //C)    ELIMINATION OF VARIABLES M+1,...N IN SYMMETRIC COMPLEX MATRIX WITHM15. 558
  //C)    A=REAL PART, C=IMAGINARY PART. A AND C ARE                        M15. 559
  //C)    STORED AS TRIANGLE (1 ELEMENT FOR 1.COLUMN,2 FOR 2.COLUMN ETC.).  M15. 560
  //C)    RESULT IS REDUCED MATRIX IN COLUMNS 1,...M IN CASE OF REDUCTION   M15. 561
  //C)    (M UNEQUAL 0) OR NEGATIVE INVERSE MATRIX IN COLUMNS 1,...N IN CASEM15. 562
  //C)    OF INVERSION (M=0).                                               M15. 563
  j = n + 1;
  w = 1.0f;
  if (m > 0) {
    w = -w;
  }
  ij = n * j / 2;
statement_3:
  j = j - 1;
  if (j == m) {
    return;
  }
  h1 = a(ij);
  g1 = c(ij);
  x = 1.0f / (h1 * h1 + g1 * g1);
  h1 = -h1 * x;
  g1 = g1 * x;
  b(j) = h1;
  d(j) = g1;
  ij = ij - j;
  k = 0;
  ik = 0;
  //C                                   BEGIN K-LOOP                        M42.2686
statement_4:
  ik += k;
  i1 = ik + 1;
  k++;
  if (k > n) {
    goto statement_3;
  }
  if (k < j) {
    goto statement_9;
  }
  if (w < 0.f) {
    goto statement_3;
  }
  if (k == j) {
    goto statement_7;
  }
  i = ik + j;
statement_5:
  h2 = a(i);
  g2 = c(i);
  b(k) = h2 * h1 - g2 * g1;
  d(k) = h2 * g1 + g2 * h1;
  //C                                   BEGIN I-LOOP                        M42.2699
  i2 = ik + k;
  L = 0;
  FEM_DO_SAFE(i, i1, i2) {
    L++;
    x = b(L);
    y = d(L);
    a(i) += x * h2 - y * g2;
    c(i) += x * g2 + y * h2;
  }
  if (k < j) {
    goto statement_4;
  }
  i = ik + j;
  a(i) = b(k);
  c(i) = d(k);
  goto statement_4;
  //C                                   END I-LOOP                          M42.2713
statement_7:
  i = ij;
  FEM_DO_SAFE(L, 1, j) {
    i++;
    c(i) = d(L);
    a(i) = b(L);
  }
  goto statement_4;
  //C                                   END K-LOOP                          M42.2720
statement_9:
  i = ij + k;
  goto statement_5;
}













struct over3_save
{
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;

  over3_save() :
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0)
  {}
};

// CODE ASSOCIATED WITH THE CASCADING OF PI-CIRCUITS FOR         
// STEADY-STATE PHASOR SOLUTIONS ONLY.                           
void over3(common& cmn)
{
  FEM_CMN_SVE(over3);
  common_read read(cmn);
  common_write write(cmn);
  const auto& abuff = cmn.abuff;
  double& freqcs = cmn.freqcs;
  auto& twopi = cmn.twopi;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  auto& lstat = cmn.lstat;
  //const auto& iprsov = cmn.iprsov;
  int& itype = cmn.itype;
  int& lastov = cmn.lastov;
  int& noutpr = cmn.noutpr;
  int& nphcas = cmn.nphcas;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  auto& xk = cmn.xk;
  auto& xm = cmn.xm;
  auto& kk = cmn.kk;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& kks = cmn.kks;
  auto& kknonl = cmn.kknonl;
  auto& kodebr = cmn.kodebr;
  auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  auto& kode = cmn.kode;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  if (is_called_first_time) {
    text1 = "STOP";
    text2 = " CAS";
    text3 = "CADE";
    text4 = "    ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int ll0 = fem::int0;
  int ll3 = fem::int0;
  int iend = fem::int0;
  int idumy = fem::int0;
  double dsectj = fem::double0;
  int multip = fem::int0;
  int mser = fem::int0;
  int mbr = fem::int0;
  int msect = fem::int0;
  int istart = fem::int0;
  int npos2 = fem::int0;
  int npos3 = fem::int0;
  int locznn = fem::int0;
  double freqx = fem::double0;
  double freqc = fem::double0;
  int npos = fem::int0;
  int nnpos = fem::int0;
  fem::str<8> text5 = fem::char0;
  fem::str<8> text6 = fem::char0;
  fem::str<8> text7 = fem::char0;
  int mbr1 = fem::int0;
  int iendd = fem::int0;
  int nredct = fem::int0;
  int iph = fem::int0;
  int iphase = fem::int0;
  double ymag2 = fem::double0;
  double yserr = fem::double0;
  double yserx = fem::double0;
  int ii = fem::int0;
  int jbr = fem::int0;
  double yshunr = fem::double0;
  double yshunx = fem::double0;
  int nrow1 = fem::int0;
  int nrow2 = fem::int0;
  int idumy2 = fem::int0;
  int icas = fem::int0;
  static const char* format_4012 = "(2x,3a4)";
  static const char* format_4568 = "('  \"EXIT  MODULE OVER3.\"')";
  static const char* format_54104 = "('+',5e10.3)";
  static const char* format_76501 = "(2x,e6.2,18i4)";
  static const char* format_76502 = "(24x,14i4)";
  static const char* format_76604 = "(1x,9e13.5)";
  static const char* format_76605 = "(/,/,1x)";
  static const char* format_76702 = "('+LINE POS.',1x,e11.3,7i4)";
  static const char* format_76703 = "('+',12i4)";
  static const char* format_76721 =
    "(/,' SHUNT BRANCH ADMITTANCE CALCULATION AT 76721.',4i10,/(1x,3e30.8))";

  auto mapcas = ArraySpan(reinterpret_cast<int*>(&cmn.ykm(1)), cmn.ykm.size_1d() * 2);
  auto mapinv = ArraySpan(reinterpret_cast<int*>(&cmn.volt(1)), cmn.volt.size() * 2);
  auto node1  = ArraySpan(reinterpret_cast<int*>(&cmn.volti(1)), cmn.volti.size() * 2);
  auto node2  = ArraySpan(reinterpret_cast<int*>(&cmn.voltk(1)), cmn.voltk.size() * 2);
  auto& ipoint = cmn.iprsov(35);
  auto& locz11 = cmn.iprsov(36);

  arr_2d<1000, 1000, int> locatn(fem::fill0);
  int i = 1;
  int j = 1;
  locatn(i, j) = (j * j - j) / 2 + i;
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER3.\"')");
  }
  ll0 = 0;
  ll3 = 3;
  iend = nphcas;
  idumy = nphcas;
  //C     READ INPUT CARD USING CIMAGE.                                     
  cimage(cmn);
  if (iend > 14) {
    idumy = 14;
  }
  {
    read_loop rloop(abuff(1), format_76501);
    rloop, dsectj, multip, mser, mbr, msect;
    FEM_DO_SAFE(i, 1, idumy) {
      rloop, mapcas(i);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, format_76702);
      wloop, dsectj, multip, mser, mbr, msect;
      FEM_DO_SAFE(i, 1, ll3) {
        wloop, mapcas(i);
      }
    }
  }
  if (dsectj == 0.0f) {
    dsectj = 1.0f;
  }
  if (multip == 0) {
    multip = 1;
  }
  if (multip > 0) {
    goto statement_7671;
  }
  kill = 55;
  lstat(19) = 7671;
  lstat(12) = multip;
  goto statement_9200;
statement_7671:
  istart = 15;
statement_76504:
  iend = iend - 14;
  if (iend <= 0) {
    goto statement_76503;
  }
  //C     READ INPUT CARD USING CIMAGE.                                    
  cimage(cmn);
  idumy = istart + iend - 1;
  if (iend > 14) {
    idumy = istart + 13;
  }
  {
    read_loop rloop(abuff(1), format_76502);
    FEM_DO_SAFE(i, istart, idumy) {
      rloop, mapcas(i);
    }
  }
  if (idumy > istart + 11) {
    idumy = istart + 11;
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, format_76703);
      FEM_DO_SAFE(i, istart, idumy) {
        wloop, mapcas(i);
      }
    }
  }
  istart += 14;
  goto statement_76504;
statement_76503:
  npos2 = 2 * nphcas;
  npos3 = 3 * nphcas;
  freqcs = twopi * freqcs;
  locznn = locz11 + locatn(nphcas, nphcas) - 1;
  freqx = xopt * twopi;
  freqc = copt * twopi * 1000000.0f;
  if (xopt == 0.0f) {
    freqx = 1000.f;
  }
  if (copt == 0.0f) {
    freqc = 1000000.0f;
  }
  FEM_DO_SAFE(i, locz11, locznn) {
    tx(i) = freqcs * tx(i) / freqx;
    c(i) = freqcs * c(i) / (2.0f * freqc);
  }
  cxred(tr(locz11), tx(locz11), nphcas, ll0);
  FEM_DO_SAFE(i, locz11, locznn) {
    tr(i) = -tr(i);
    tx(i) = -tx(i);
  }
  iend = locatn(npos3, npos3);
  move0(xk, iend);
  move0(xm, iend);
  FEM_DO_SAFE(i, 1, nphcas) {
    FEM_DO_SAFE(j, i, nphcas) {
      if (mapcas(i) <= nphcas) {
        goto statement_76711;
      }
      kill = 54;
      lstat(19) = 7655;
      lstat(12) = mapcas(i);
      lstat(13) = nphcas;
      goto statement_9200;
    statement_76711:
      npos = locatn(mapcas(i), mapcas(j)) + locz11 - 1;
      if (mapcas(i) > mapcas(j)) {
        npos = locatn(mapcas(j), mapcas(i)) + locz11 - 1;
      }
      nnpos = locatn(i, j);
      xk(nnpos) = tr(npos) / dsectj;
      xm(nnpos) = tx(npos) / dsectj + c(npos) * dsectj;
      nnpos = locatn(i, j + nphcas);
      xk(nnpos) = -tr(npos) / dsectj;
      xm(nnpos) = -tx(npos) / dsectj;
      if (i == j) {
        goto statement_76433;
      }
      nnpos = locatn(j, i + nphcas);
      xk(nnpos) = -tr(npos) / dsectj;
      xm(nnpos) = -tx(npos) / dsectj;
    statement_76433:
      nnpos = locatn(i + nphcas, j + nphcas);
      xk(nnpos) = tr(npos) / dsectj;
      xm(nnpos) = tx(npos) / dsectj + c(npos) * dsectj;
    }
  }
statement_76521:
  multip = multip - 1;
  if (multip > 0) {
    goto statement_76505;
  }
  iend = nphcas;
  idumy = nphcas;
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2215
  cimage(cmn);
  if (iend > 14) {
    idumy = 14;
  }
  read(abuff, format_4012), text5, text6, text7;
  if (text5 != text1) {
    goto statement_4013;
  }
  if (text6 != text2) {
    goto statement_4013;
  }
  if (text7 == text3) {
    goto statement_76600;
  }
statement_4013:
  {
    read_loop rloop(abuff(1), format_76501);
    rloop, dsectj, multip, mser, mbr, msect;
    FEM_DO_SAFE(i, 1, idumy) {
      rloop, mapcas(i);
    }
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, format_76702);
      wloop, dsectj, multip, mser, mbr, msect;
      FEM_DO_SAFE(i, 1, ll3) {
        wloop, mapcas(i);
      }
    }
  }
  if (dsectj == 0.0f) {
    dsectj = 1.0f;
  }
  if (multip == 0) {
    multip = 1;
  }
  if (multip > 0) {
    goto statement_76713;
  }
  lstat(19) = 4013;
  kill = 55;
  lstat(12) = multip;
  goto statement_9200;
statement_76713:
  istart = 15;
statement_76506:
  iend = iend - 14;
  if (iend <= 0) {
    goto statement_76507;
  }
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2235
  cimage(cmn);
  idumy = istart + iend - 1;
  if (iend > 14) {
    idumy = istart + 13;
  }
  {
    read_loop rloop(abuff(1), format_76502);
    FEM_DO_SAFE(i, istart, idumy) {
      rloop, mapcas(i);
    }
  }
  if (idumy > istart + 12) {
    idumy = istart + 12;
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, format_76703);
      FEM_DO_SAFE(i, istart, idumy) {
        wloop, mapcas(i);
      }
    }
  }
  goto statement_76506;
statement_76507:
  FEM_DO_SAFE(i, 1, nphcas) {
    idumy = mapcas(i);
    mapinv(idumy) = i;
  }
  if (mser <= 0) {
    goto statement_76510;
  }
  move0(e, nphcas);
  move0(f, nphcas);
  move0(kode, nphcas);
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2249
statement_76511:
  cimage(cmn);
  read(abuff, "(i2)"), itype;
  if (itype >= 0 && itype <= nphcas) {
    goto statement_76714;
  }
  lstat(19) = 7651;
  kill = 54;
  lstat(12) = itype;
  goto statement_9200;
statement_76714:
  if (itype == 0 && noutpr == 0) {
    write(kunit6, "('+BLANK CARD TERMINATING SERIES R-L-C.')");
  }
  if (itype == 0) {
    goto statement_76510;
  }
  read(abuff, "(26x,3e6.0)"), e(itype), f(itype), kode(itype);
  if (noutpr == 0) {
    write(kunit6, "('+SERIES R-L-C.',2x,3e11.3)"), e(itype), f(itype),
      kode(itype);
  }
  goto statement_76511;
statement_76510:
  if (mbr <= 0) {
    goto statement_76513;
  }
  mbr1 = 0;
statement_76516:
  mbr1++;
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2263
  cimage(cmn);
  read(abuff, format_4012), text5, text6, text7;
  if (text5 != text4) {
    goto statement_4018;
  }
  if (text6 != text4) {
    goto statement_4018;
  }
  if (text7 != text4) {
    goto statement_4018;
  }
  if (noutpr == 0) {
    write(kunit6, "('+BLANK CARD TERMINATING SHUNT R-L-C BRANCHES.')");
  }
  goto statement_76540;
statement_4018:
  read(abuff, "(2x,2i6,12x,3e6.2)"), node1(mbr1), node2(mbr1), kk(mbr1),
    kks(mbr1), kknonl(mbr1);
  if (noutpr == 0) {
    write(kunit6, "('+SHUNT.',2x,2i4,3e11.3)"), node1(mbr1), node2(mbr1),
      kk(mbr1), kks(mbr1), kknonl(mbr1);
  }
  goto statement_76516;
statement_76540:
  mbr1 = mbr1 - 1;
statement_76513:
  if (msect <= 0) {
    goto statement_76505;
  }
  istart = locz11;
  FEM_DO_SAFE(i, 1, nphcas) {
    idumy = i;
    if (idumy > 3) {
      idumy = 3;
    }
    iend = istart + idumy - 1;
    //C     READ INPUT CARD USING CIMAGE.                                     M42.2285
    cimage(cmn);
    {
      read_loop rloop(abuff(1), "(i2,24x,9e6.2)");
      rloop, itype;
      FEM_DO_SAFE(j, istart, iend) {
        rloop, tr(j), tx(j), c(j);
      }
    }
    if (i > 1) {
      goto statement_5264;
    }
    if (noutpr == 0) {
      write(kunit6, "('+1ST OF PI-CKT.',1x,3e11.3)"), tr(istart), tx(istart),
        c(istart);
    }
    goto statement_5271;
  statement_5264:
    idumy = istart + 1;
    if (noutpr == 0) {
      write(kunit6, format_54104), tr(idumy), tx(idumy), c(idumy), tr(
        idumy + 1), tx(idumy + 1);
    }
  statement_5271:
    istart = iend + 1;
    idumy = i;
  statement_76520:
    idumy = idumy - 3;
    if (idumy <= 0) {
      goto statement_76517;
    }
    iend = istart + idumy - 1;
    if (idumy > 3) {
      iend = istart + 2;
    }
    //C     READ INPUT CARD USING CIMAGE.                                     M42.2299
    cimage(cmn);
    {
      read_loop rloop(abuff(1), "(26x,9e6.2)");
      FEM_DO_SAFE(j, istart, iend) {
        rloop, tr(j), tx(j), c(j);
      }
    }
    iendd = iend;
    if (idumy > 3) {
      iendd = istart + 1;
    }
    if (noutpr == 0) {
      write(kunit6, format_54104), tr(istart), tx(istart), c(istart),
        tr(istart + 1), tx(istart + 1);
    }
    istart = iend + 1;
    goto statement_76520;
  statement_76517:;
  }
  FEM_DO_SAFE(i, locz11, locznn) {
    tx(i) = freqcs * tx(i) / freqx;
    c(i) = freqcs * c(i) / (2.0f * freqc);
  }
  cxred(tr(locz11), tx(locz11), nphcas, ll0);
  FEM_DO_SAFE(i, locz11, locznn) {
    tr(i) = -tr(i);
    tx(i) = -tx(i);
  }
statement_76505:
  if (mser == 0) {
    goto statement_6434;
  }
  FEM_DO_SAFE(i, 1, nphcas) {
    FEM_DO_SAFE(j, 1, nphcas) {
      npos = locatn(i, j + nphcas);
      nnpos = locatn(i, j + npos2);
      xk(nnpos) = xk(npos);
      xk(npos) = 0.0f;
      xm(nnpos) = xm(npos);
      xm(npos) = 0.0f;
    }
  }
  FEM_DO_SAFE(i, 1, nphcas) {
    FEM_DO_SAFE(j, i, nphcas) {
      npos = locatn(i + nphcas, j + nphcas);
      nnpos = locatn(i + npos2, j + npos2);
      xk(nnpos) = xk(npos);
      xk(npos) = 0.0f;
      xm(nnpos) = xm(npos);
      xm(npos) = 0.0f;
    }
  }
  nredct = nphcas;
  FEM_DO_SAFE(iph, 1, nphcas) {
    iphase = mapcas(iph);
    if (e(iphase) == 0.0f && f(iphase) == 0.0f && kode(iphase) == 0.0f) {
      goto statement_76438;
    }
    if (e(iphase) == 999999.f) {
      goto statement_76441;
    }
    if (kode(iphase) == 0.0f) {
      goto statement_76439;
    }
    ymag2 = fem::pow2(e(iphase)) + fem::pow2((freqcs * f(iphase) /
      freqx - 1.0f / (freqcs * kode(iphase) / freqc)));
    yserr = e(iphase) / ymag2;
    yserx = (-freqcs * f(iphase) / freqx + 1.0f / (freqcs * kode(
      iphase) / freqc)) / ymag2;
    goto statement_76440;
  statement_76439:
    yserr = e(iphase) / (fem::pow2(e(iphase)) + fem::pow2((freqcs * f(
      iphase) / freqx)));
    yserx = (-freqcs * f(iphase) / freqx) / (fem::pow2(e(iphase)) +
      fem::pow2((freqcs * f(iphase) / freqx)));
    goto statement_76440;
  statement_76441:
    yserr = 0.0f;
    yserx = 0.0f;
  statement_76440:
    nnpos = locatn(iph + nphcas, iph + nphcas);
    xk(nnpos) = yserr;
    xm(nnpos) = yserx;
    nnpos = locatn(iph + nphcas, iph + nphcas + nredct);
    xk(nnpos) = -yserr;
    xm(nnpos) = -yserx;
    nnpos = locatn(iph + nphcas + nredct, iph + nphcas + nredct);
    xk(nnpos) += yserr;
    xm(nnpos) += yserx;
    goto statement_76442;
  statement_76438:
    idumy = nphcas + iph;
    FEM_DO_SAFE(i, 1, idumy) {
      nnpos = locatn(i, idumy);
      npos = locatn(i, idumy + nredct);
      xk(nnpos) = xk(npos);
      xm(nnpos) = xm(npos);
    }
    nnpos = locatn(idumy, idumy);
    npos = locatn(idumy + nredct, idumy + nredct);
    xk(nnpos) = xk(npos);
    xm(nnpos) = xm(npos);
    iend = npos2 + nredct;
    istart = idumy + nredct;
    FEM_DO_SAFE(i, istart, iend) {
      nnpos = locatn(idumy, i);
      npos = locatn(idumy + nredct, i);
      xk(nnpos) = xk(npos);
      xm(nnpos) = xm(npos);
    }
    istart = npos2 + 1;
    iend = idumy + nredct;
    FEM_DO_SAFE(i, istart, iend) {
      nnpos = locatn(idumy, i);
      npos = locatn(i, idumy + nredct);
      xk(nnpos) = xk(npos);
      xm(nnpos) = xm(npos);
    }
    istart = idumy + nredct + 1;
    iend = npos2 + nredct;
    FEM_DO_SAFE(i, istart, iend) {
      FEM_DO_SAFE(j, i, iend) {
        npos = locatn(i, j);
        nnpos = npos - 1;
        xk(nnpos) = xk(npos);
        xm(nnpos) = xm(npos);
      }
    }
    FEM_DO_SAFE(j, istart, iend) {
      iendd = j - 1;
      FEM_DO_SAFE(i, 1, iendd) {
        nnpos = locatn(i, iendd);
        npos = locatn(i, j);
        xk(nnpos) = xk(npos);
        xm(nnpos) = xm(npos);
      }
    }
    nredct = nredct - 1;
  statement_76442:;
  }
  if (iprsup < 9) {
    goto statement_76630;
  }
  write(lunit6, format_76605);
  write(lunit6, "(5x,'Y-MATRIX BEFORE SERIES R-L-C ELIMINATION.')");
  FEM_DO_SAFE(i, 1, npos3) {
    write(lunit6, format_76605);
    istart = locatn(i - 1, i - 1) + 1;
    idumy = i + 9;
  statement_76633:
    idumy = idumy - 9;
    iend = idumy + istart - 1;
    if (idumy > 9) {
      iend = istart + 8;
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xk(ii);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xm(ii);
      }
    }
    istart += 9;
    if (idumy > 9) {
      goto statement_76633;
    }
  }
statement_76630:
  cxred(xk, xm, npos2 + nredct, npos2);
  if (iprsup < 9) {
    goto statement_76650;
  }
  write(lunit6, format_76605);
  write(lunit6, "(5x,'Y-MATRIX AFTER SERIES R-L-C ELIMINATION. ')");
  FEM_DO_SAFE(i, 1, npos2) {
    write(lunit6, format_76605);
    istart = locatn(i - 1, i - 1) + 1;
    idumy = i + 9;
  statement_76659:
    idumy = idumy - 9;
    iend = idumy + istart - 1;
    if (idumy > 9) {
      iend = istart + 8;
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xk(ii);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xm(ii);
      }
    }
    istart += 9;
    if (idumy > 9) {
      goto statement_76659;
    }
  }
statement_76650:
  istart = locatn(npos2, npos2) + 1;
  iend = locatn(npos3, npos3);
  i = iend - istart + 1;
  move0(xk, istart, i);
  move0(xm, istart, i);
statement_6434:
  if (mbr == 0) {
    goto statement_76450;
  }
  FEM_DO_SAFE(jbr, 1, mbr1) {
    if (node1(jbr) != node2(jbr)) {
      goto statement_6715;
    }
    lstat(19) = 6434;
    kill = 56;
    lstat(12) = node1(jbr);
    lstat(13) = mbr1;
    lstat(14) = jbr;
    goto statement_9200;
  statement_6715:
    if (fem::iabs(node1(jbr)) <= nphcas) {
      goto statement_6716;
    }
    lstat(19) = 6715;
    kill = 54;
    lstat(12) = node1(jbr);
    goto statement_9200;
  statement_6716:
    if (fem::iabs(node2(jbr)) <= nphcas) {
      goto statement_76717;
    }
    lstat(19) = 6716;
    kill = 54;
    lstat(12) = node2(jbr);
    goto statement_9200;
  statement_76717:
    if (kk(jbr) != 0.0f || kks(jbr) != 0.0f || kknonl(jbr) != 0.0f) {
      goto statement_6718;
    }
    lstat(19) = 6718;
    kill = 57;
    lstat(12) = node1(jbr);
    lstat(13) = node2(jbr);
    goto statement_9200;
  statement_6718:
    if (kknonl(jbr) == 0.0f) {
      goto statement_76452;
    }
    ymag2 = fem::pow2(kk(jbr)) + fem::pow2((freqcs * kks(jbr) /
      freqx - 1.0f / (kknonl(jbr) * freqcs / freqc)));
    yshunr = kk(jbr) / ymag2;
    yshunx = (-freqcs * kks(jbr) / freqx + 1.0f / (freqcs * kknonl(
      jbr) / freqc)) / ymag2;
    if (iprsup >= 6) {
      write(lunit6, format_76721), jbr, mbr1, node1(jbr), node2(jbr),
        kk(jbr), kks(jbr), kknonl(jbr), freqx, freqc, freqcs, ymag2,
        yshunr, yshunx;
    }
    goto statement_76453;
  statement_76452:
    ymag2 = fem::pow2(kk(jbr)) + fem::pow2((freqcs * kks(jbr) / freqx));
    yshunr = kk(jbr) / ymag2;
    yshunx = (-freqcs * kks(jbr) / freqx) / ymag2;
    if (iprsup >= 6) {
      write(lunit6, format_76721), jbr, mbr1, node1(jbr), node2(jbr),
        kk(jbr), kks(jbr), kknonl(jbr), freqx, freqc, freqcs, ymag2,
        yshunr, yshunx;
    }
  statement_76453:
    if (node1(jbr) >= 0 && node2(jbr) >= 0) {
      goto statement_76454;
    }
    if (node1(jbr) <= 0 && node2(jbr) <= 0) {
      goto statement_76455;
    }
    if (node1(jbr) > 0) {
      goto statement_76456;
    }
    idumy = node1(jbr);
    node1(jbr) = node2(jbr);
    node2(jbr) = idumy;
  statement_76456:
    node2(jbr) = -node2(jbr);
    idumy = node1(jbr);
    nrow1 = nphcas + mapinv(idumy);
    nrow2 = npos2 + node2(jbr);
    nnpos = locatn(nrow1, nrow1);
    xk(nnpos) += yshunr;
    xm(nnpos) += yshunx;
    nnpos = locatn(nrow1, nrow2);
    xk(nnpos) = -yshunr;
    xm(nnpos) = -yshunx;
    nnpos = locatn(nrow2, nrow2);
    xk(nnpos) += yshunr;
    xm(nnpos) += yshunx;
    node2(jbr) = -node2(jbr);
    goto statement_76451;
  statement_76454:
    if (node1(jbr) == 0 || node2(jbr) == 0) {
      goto statement_76457;
    }
    idumy = node1(jbr);
    idumy2 = node2(jbr);
    if (mapinv(idumy) < mapinv(idumy2)) {
      goto statement_76458;
    }
    idumy = node2(jbr);
    idumy2 = node1(jbr);
  statement_76458:
    nrow1 = nphcas + mapinv(idumy);
    nrow2 = nphcas + mapinv(idumy2);
    nnpos = locatn(nrow1, nrow1);
    xk(nnpos) += yshunr;
    xm(nnpos) += yshunx;
    nnpos = locatn(nrow1, nrow2);
    xk(nnpos) = xk(nnpos) - yshunr;
    xm(nnpos) = xm(nnpos) - yshunx;
    nnpos = locatn(nrow2, nrow2);
    xk(nnpos) += yshunr;
    xm(nnpos) += yshunx;
    goto statement_76451;
  statement_76457:
    idumy = node1(jbr) + node2(jbr);
    nrow1 = nphcas + mapinv(idumy);
    nnpos = locatn(nrow1, nrow1);
    xk(nnpos) += yshunr;
    xm(nnpos) += yshunx;
    goto statement_76451;
  statement_76455:
    node1(jbr) = -node1(jbr);
    node2(jbr) = -node2(jbr);
    if (node1(jbr) == 0 || node2(jbr) == 0) {
      goto statement_76460;
    }
    if (node1(jbr) < node2(jbr)) {
      goto statement_76459;
    }
    idumy = node1(jbr);
    node1(jbr) = node2(jbr);
    node2(jbr) = idumy;
  statement_76459:
    nrow1 = npos2 + node1(jbr);
    nrow2 = npos2 + node2(jbr);
    nnpos = locatn(nrow1, nrow1);
    xk(nnpos) += yshunr;
    xm(nnpos) += yshunx;
    nnpos = locatn(nrow1, nrow2);
    xk(nnpos) = xk(nnpos) - yshunr;
    xm(nnpos) = xm(nnpos) - yshunx;
    nnpos = locatn(nrow2, nrow2);
    xk(nnpos) += yshunr;
    xm(nnpos) += yshunx;
    node1(jbr) = -node1(jbr);
    node2(jbr) = -node2(jbr);
    goto statement_76451;
  statement_76460:
    nrow1 = npos2 + node1(jbr) + node2(jbr);
    nnpos = locatn(nrow1, nrow1);
    xk(nnpos) += yshunr;
    xm(nnpos) += yshunx;
    node1(jbr) = -node1(jbr);
    node2(jbr) = -node2(jbr);
  statement_76451:;
  }
  nredct = 0;
  FEM_DO_SAFE(i, 1, nphcas) {
    npos = locatn(npos2 + i - 1, npos2 + i - 1);
    nnpos = locatn(npos2 + i, npos2 + i);
    ymag2 = std::abs(xk(nnpos)) + std::abs(xm(nnpos));
    if (ymag2 == 0.0f) {
      goto statement_76461;
    }
    ymag2 = std::abs(xk(npos)) + std::abs(xm(npos));
    if (ymag2 != 0.0f) {
      goto statement_6470;
    }
    lstat(19) = 6470;
    kill = 60;
    lstat(12) = -i;
    goto statement_9200;
  statement_6470:
    nredct++;
  statement_76461:;
  }
  if (iprsup < 9) {
    goto statement_76640;
  }
  write(lunit6, format_76605);
  write(lunit6, "(5x,'Y-MATRIX BEFORE SHUNT R-L-C ELIMATION.   ')");
  FEM_DO_SAFE(i, 1, npos3) {
    write(lunit6, format_76605);
    istart = locatn(i - 1, i - 1) + 1;
    idumy = i + 9;
  statement_76638:
    idumy = idumy - 9;
    iend = idumy + istart - 1;
    if (idumy > 9) {
      iend = istart + 8;
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xk(ii);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xm(ii);
      }
    }
    istart += 9;
    if (idumy > 9) {
      goto statement_76638;
    }
  }
statement_76640:
  cxred(xk, xm, npos2 + nredct, npos2);
  if (iprsup < 9) {
    goto statement_76651;
  }
  write(lunit6, format_76605);
  write(lunit6, "(5x,'Y-MATRIX AFTER SHUNT R-L-C ELIMATION. ')");
  FEM_DO_SAFE(i, 1, npos2) {
    write(lunit6, format_76605);
    istart = locatn(i - 1, i - 1) + 1;
    idumy = i + 9;
  statement_76660:
    idumy = idumy - 9;
    iend = idumy + istart - 1;
    if (idumy > 9) {
      iend = istart + 8;
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xk(ii);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xm(ii);
      }
    }
    istart += 9;
    if (idumy > 9) {
      goto statement_76660;
    }
  }
statement_76651:
  istart = locatn(npos2, npos2) + 1;
  iend = locatn(npos3, npos3);
  i = iend - istart + 1;
  move0(xk, istart, i);
  move0(xm, istart, i);
statement_76450:
  FEM_DO_SAFE(i, 1, nphcas) {
    FEM_DO_SAFE(j, 1, nphcas) {
      npos = locatn(i, j + nphcas);
      nnpos = locatn(i, j + npos2);
      xk(nnpos) = xk(npos);
      xk(npos) = 0.0f;
      xm(nnpos) = xm(npos);
      xm(npos) = 0.0f;
    }
  }
  FEM_DO_SAFE(i, 1, nphcas) {
    FEM_DO_SAFE(j, i, nphcas) {
      npos = locatn(i + nphcas, j + nphcas);
      nnpos = locatn(i + npos2, j + npos2);
      xk(nnpos) = xk(npos);
      xk(npos) = 0.0f;
      xm(nnpos) = xm(npos);
      xm(npos) = 0.0f;
    }
  }
  FEM_DO_SAFE(i, 1, nphcas) {
    FEM_DO_SAFE(j, i, nphcas) {
      npos = locatn(mapcas(i), mapcas(j)) + locz11 - 1;
      if (mapcas(i) > mapcas(j)) {
        npos = locatn(mapcas(j), mapcas(i)) + locz11 - 1;
      }
      nnpos = locatn(i + nphcas, j + nphcas);
      xk(nnpos) = tr(npos) / dsectj;
      xm(nnpos) = tx(npos) / dsectj + c(npos) * dsectj;
      nnpos = locatn(i + nphcas, j + npos2);
      xk(nnpos) = -tr(npos) / dsectj;
      xm(nnpos) = -tx(npos) / dsectj;
      if (i == j) {
        goto statement_76466;
      }
      nnpos = locatn(j + nphcas, i + npos2);
      xk(nnpos) = -tr(npos) / dsectj;
      xm(nnpos) = -tx(npos) / dsectj;
    statement_76466:
      nnpos = locatn(i + npos2, j + npos2);
      xk(nnpos) += tr(npos) / dsectj;
      xm(nnpos) += tx(npos) / dsectj + c(npos) * dsectj;
    }
  }
  if (iprsup < 9) {
    goto statement_76641;
  }
  write(lunit6, format_76605);
  write(lunit6, "(5x,'Y-MATRIX BEFORE SECTION ELIMINATION.')");
  FEM_DO_SAFE(i, 1, npos3) {
    write(lunit6, format_76605);
    istart = locatn(i - 1, i - 1) + 1;
    idumy = i + 9;
  statement_76639:
    idumy = idumy - 9;
    iend = idumy + istart - 1;
    if (idumy > 9) {
      iend = istart + 8;
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xk(ii);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xm(ii);
      }
    }
    istart += 9;
    if (idumy > 9) {
      goto statement_76639;
    }
  }
statement_76641:
  cxred(xk, xm, npos3, npos2);
  if (iprsup < 9) {
    goto statement_76652;
  }
  write(lunit6, format_76605);
  write(lunit6, "(5x,'Y-MATRIX AFTER SECTION ELIMINATION. ')");
  FEM_DO_SAFE(i, 1, npos2) {
    write(lunit6, format_76605);
    istart = locatn(i - 1, i - 1) + 1;
    idumy = i + 9;
  statement_76661:
    idumy = idumy - 9;
    iend = idumy + istart - 1;
    if (idumy > 9) {
      iend = istart + 8;
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xk(ii);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xm(ii);
      }
    }
    istart += 9;
    if (idumy > 9) {
      goto statement_76661;
    }
  }
statement_76652:
  istart = locatn(npos2, npos2) + 1;
  iend = locatn(npos3, npos3);
  i = iend - istart + 1;
  move0(xk, istart, i);
  move0(xm, istart, i);
  goto statement_76521;
statement_76600:
  if (noutpr == 0) {
    write(kunit6, "('+TERMINATION OF CASCADED PI.')");
  }
  locznn = locatn(npos2, npos2) + locz11 - 1;
  cmn.it = locz11 + locatn(npos2, npos2);
  cmn.tmax = -1.0f;
  icas = 0;
  FEM_DO_SAFE(i, locz11, locznn) {
    j = i - locz11 + 1;
    tr(i) = xk(j);
    tx(i) = xm(j);
    c(i) = 0.0f;
  }
  FEM_DO_SAFE(i, ipoint, cmn.ibr) {
    kodebr(i) = -2;
  }
  if (iprsup < 2) {
    goto statement_100;
  }
  write(lunit6, "(5x,'Y-MATRIX FOR LINE REPRESENTED BY CASCADED-PI. ')");
  FEM_DO_SAFE(i, 1, npos2) {
    write(lunit6, format_76605);
    istart = locatn(i - 1, i - 1) + 1;
    idumy = i + 9;
  statement_76603:
    idumy = idumy - 9;
    iend = idumy + istart - 1;
    if (idumy > 9) {
      iend = istart + 8;
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xk(ii);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_76604);
      FEM_DO_SAFE(ii, istart, iend) {
        wloop, xm(ii);
      }
    }
    istart += 9;
    if (idumy > 9) {
      goto statement_76603;
    }
  }
statement_100:
  lastov = nchain;
  nchain = 2;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
statement_9200:
  lastov = nchain;
  nchain = 51;
  lstat(18) = 3;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
statement_99999:;
}

// INPUT AND PROCESSING OF FREQUENCY-DEPENDENCE DATA FOR         
// DISTRIBUTED-PARAMETER LINE MODE.                              
void over4(common& cmn)
{
  common_read read(cmn);
  common_write write(cmn);
  const auto& abuff = cmn.abuff;
  double& deltat = cmn.deltat;
  double& t = cmn.t;
  double& tenm3 = cmn.tenm3;
  double& onehaf = cmn.onehaf;
  auto& flstat = cmn.flstat;
  auto& lstat = cmn.lstat;
  int& ifdep = cmn.ifdep;
  int& lfdep = cmn.lfdep;
  int& lwt = cmn.lwt;
  int& lastov = cmn.lastov;
  int& noutpr = cmn.noutpr;
  int& ifdep2 = cmn.ifdep2;
  int& jst = cmn.jst;
  int& jst1 = cmn.jst1;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& ibr = cmn.ibr;
  const auto& ykm = cmn.ykm;
  auto& weight = cmn.weight;
  auto& iwtent = cmn.iwtent;
  auto& con1 = cmn.con1;
  auto& iskip = cmn.iskip;
  auto& zinf = cmn.zinf;
  auto& eta = cmn.eta;
  auto& nhist = cmn.nhist;
  auto& tp = cmn.tp;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  auto& ci = cmn.ci;
  auto& ck = cmn.ck;
  //
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int jfdep2 = fem::int0;
  int kfdep2 = fem::int0;
  double d1tttt = fem::double0;
  int iofa1p = fem::int0;
  int ioftm2 = fem::int0;
  int ioftm1 = fem::int0;
  double d1 = fem::double0;
  int ntime1 = fem::int0;
  int ntime2 = fem::int0;
  int locmax = fem::int0;
  int locmin = fem::int0;
  double z1 = fem::double0;
  double cut1 = fem::double0;
  double cut2 = fem::double0;
  int n10 = fem::int0;
  double rtotal = fem::double0;
  int nii = fem::int0;
  int n9 = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int n3 = fem::int0;
  int n12 = fem::int0;
  arr_1d<8, double> buffin(fem::fill0);
  int j = fem::int0;
  int n4 = fem::int0;
  int n5 = fem::int0;
  int i = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  double d3 = fem::double0;
  double d2 = fem::double0;
  double atheo = fem::double0;
  int iend = fem::int0;
  double dzero = fem::double0;
  int kfin = fem::int0;
  int n = fem::int0;
  double tend = fem::double0;
  double a1 = fem::double0;
  double aditn = fem::double0;
  double t1 = fem::double0;
  double tbound = fem::double0;
  int kflop = fem::int0;
  int mode = fem::int0;
  double a = fem::double0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  double d18 = fem::double0;
  double d4 = fem::double0;
  double tails = fem::double0;
  double aamp = fem::double0;
  double tcor = fem::double0;
  double bct = fem::double0;
  int ik = fem::int0;
  double d12 = fem::double0;
  double d17 = fem::double0;
  double fstar = fem::double0;
  double fder = fem::double0;
  int ikp = fem::int0;
  int npoint = fem::int0;
  static const char* format_4568 = "('  \"EXIT  MODULE OVER4.\"')";
  static const char* format_6115 = "(8f10.0)";

  //C     FREQUENCY DEPENDENT LINE. ********************************        M29.1338
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER4.\"')");
  }
  jfdep2 = 2 * lfdep + ifdep2;
  kfdep2 = 4 * lfdep + ifdep2;
  d1tttt = t;
  if (cmn.kburro == 1) {
    goto statement_8716;
  }
  iofa1p = ykm.size() / 4; // (locf(weight(1)) - locf(ykm(1))) / 4;
  goto statement_8721;
statement_8716:
  iofa1p = cmn.lsiz23 / 4;
statement_8721:
  ioftm2 = 2 * iofa1p;
  ioftm1 = 3 * iofa1p;
  ifdep++;
  if (ifdep <= lfdep) {
    goto statement_20170;
  }
  kill = 1;
  lstat(16) = 13;
  lstat(19) = 20170;
  goto statement_9200;
statement_20170:
  nr(ibr) = ifdep;
  length(ibr) = cmn.kcount;
  ck(ibr) = -ck(ibr);
  d1 = -tenm3 / 100.f;
  if (ck(ibr) > d1) {
    ck(ibr) = d1;
  }
  ci(ibr) = std::abs(ci(ibr));
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2734
  cimage(cmn);
  read(abuff, "(4i8,3f8.0,i8,f8.0,i8)"), ntime1, ntime2, locmax,
    locmin, z1, cut1, cut2, n10, rtotal, nii;
  if (cut1 <= 0.0f) {
    cut1 = 10.f * tenm3;
  }
  if (cut2 <= 0.0f) {
    cut2 = 100.f * tenm3;
  }
  if (nii <= 0) {
    nii = 100;
  }
  if (noutpr == 0) {
    write(kunit6, "('+FREQUENCY-DEPENDENCE MISC. DATA VALUES.')");
  }
  n9 = noutpr;
  noutpr = n10;
  n1 = ntime1;
  if (ntime2 > n1) {
    n1 = ntime2;
  }
  if (n1 + 3 <= iofa1p) {
    goto statement_6103;
  }
  kill = 145;
  lstat(14) = ntime1;
  lstat(15) = ntime2;
  lstat(16) = iofa1p;
  lstat(19) = 6103;
  goto statement_9200;
statement_6103:
  n2 = ioftm1 + 1;
  n3 = iofa1p + 1;
  n12 = ioftm1 + ntime1;
  goto statement_5736;
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2738
statement_6111:
  cimage(cmn);
  read(abuff, format_6115), buffin;
  FEM_DOSTEP(j, 1, 7, 2) {
    tp(n2) = buffin(j);
    tp(n3) = buffin(j + 1);
    n2++;
    n3++;
  }
  if (noutpr == 0) {
    write(kunit6, "('+   WEIGHTING FUNCTION A1 POINTS.')");
  }
statement_5736:
  if (n2 <= n12) {
    goto statement_6111;
  }
  n4 = ioftm2 + 1;
  n5 = 1;
  goto statement_5741;
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2741
statement_6116:
  cimage(cmn);
  read(abuff, format_6115), buffin;
  FEM_DOSTEP(j, 1, 7, 2) {
    tp(n4) = buffin(j);
    tp(n5) = buffin(j + 1);
    n4++;
    n5++;
  }
  if (noutpr == 0 && n12 > 0) {
    write(kunit6, "('+   WEIGHTING FUNCTION A2 POINTS.')");
  }
statement_5741:
  n12 = ntime2 - n5;
  if (n12 <= 7) {
    noutpr = n9;
  }
  if (n12 >= 0) {
    goto statement_6116;
  }
  FEM_DO_SAFE(i, 1, ntime1) {
    n6 = ioftm1 + i;
    tp(n6) = tp(n6) / 1000000.f;
  }
  FEM_DO_SAFE(i, 1, ntime2) {
    n7 = ioftm2 + i;
    tp(n7) = tp(n7) / 1000000.f;
  }
  d3 = 0.0f;
  FEM_DO_SAFE(i, 2, ntime1) {
    n2 = ioftm1 + i;
    n4 = iofa1p + i;
    d1 = tp(n2) - tp(n2 - 1);
    d2 = tp(n4) + tp(n4 - 1);
    if (d1 > 0.0f) {
      goto statement_6125;
    }
    kill = 45;
    lstat(19) = 6125;
    lstat(17) = 1;
    lstat(14) = i;
    flstat(15) = tp(n2);
    flstat(16) = tp(n2 - 1);
    goto statement_9200;
  statement_6125:
    d3 += d1 * d2;
  }
  FEM_DO_SAFE(i, 2, ntime2) {
    n6 = ioftm2 + i;
    d1 = tp(n6) - tp(n6 - 1);
    d2 = tp(i) + tp(i - 1);
    if (d1 > 0.0f) {
      goto statement_6126;
    }
    kill = 45;
    lstat(19) = 6126;
    lstat(17) = 2;
    lstat(14) = i;
    flstat(15) = tp(n6);
    flstat(16) = tp(n6 - 1);
    goto statement_9200;
  statement_6126:
    d3 += d1 * d2;
  }
  d3 = d3 * onehaf;
  if (noutpr == 0) {
    write(kunit6, "('+   WEIGHTING FUNCTION A2 POINTS.',f16.8)"), d3;
  }
  if (rtotal > 0.0f) {
    goto statement_7820;
  }
  d1 = 1.0f / d3;
  FEM_DO_SAFE(i, 1, ntime1) {
    n2 = iofa1p + i;
    tp(n2) = tp(n2) * d1;
  }
  FEM_DO_SAFE(i, 1, ntime2) {
    tp(i) = tp(i) * d1;
  }
statement_7820:
  cut2 = cut2 * tp(locmin);
  atheo = rtotal / (2.0f * z1 + rtotal);
  iend = ntime2;
  dzero = 0.0f;
  i = 1;
  kfin = 0;
  n = 0;
  tend = 0.0f;
statement_6200:
  a1 = tp(i);
  aditn = 0.0f;
  n3 = ioftm2 + i;
  n4 = ioftm2 + iend;
  t1 = tp(n3);
  tbound = tp(n4);
  iwtent(ifdep2) = jst1;
  weight(jst1) = 0.0f;
  n = n - 1;
  kflop = 1;
  mode = 0;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' BEGIN  A(T)  PROCESSING.',"
      "'   IFDEP  IFDEP2     JST       I  IOFTM2    IEND',11x,'DZERO',10x,"
      "'DELTAT',/,25x,6i8,2e16.7)"),
      ifdep, ifdep2, jst, i, ioftm2, iend, dzero, deltat;
  }
  goto statement_6450;
statement_6220:
  if (mode > 0) {
    goto statement_6240;
  }
  if (t <= tend) {
    goto statement_6240;
  }
  kflop = 1;
  d1 = (a - a1) / (t - t1);
  a = a1 + d1 * (tend - t1);
  i = i - 1;
  t = tend;
  goto statement_6250;
statement_6240:
  if (i < iend) {
    goto statement_6250;
  }
  if (iprsup <= 0) {
    goto statement_6245;
  }
  write(lunit6,
    "(/,' END RAW DATA POINTS.',"
    "'       I    IEND     JST    MODE   KFLOP     LWT',"
    "'    KFIN       N   IFDEP  IFDEP2  IOFTM2  LOCMIN  LOCMAX',/,21x,13i8)"),
    i, iend, jst, mode, kflop, lwt, kfin, n, ifdep, ifdep2, ioftm2,
    locmin, locmax;
  write(lunit6,
    "(/,15x,'T1',14x,'A1',15x,'T',15x,'A',14x,'D5',14x,'D6',12x,'TEND',14x,"
    "'D3',/,1x,8e16.7)"),
    t1, a1, t, a, d5, d6, tend, d3;
statement_6245:
  i = -1;
  kflop = 1;
statement_6250:
  d1 = (t - t1) * onehaf;
  d18 = d1 * (a1 + a);
  d5 += d18;
  d6 += d1 * (t1 * a1 + t * a);
  t1 = t;
  a1 = a;
  if (mode == 0) {
    goto statement_6260;
  }
  if (i > 0) {
    goto statement_6450;
  }
  goto statement_6465;
statement_6260:
  aditn += d18;
  if (kflop == 0) {
    goto statement_6450;
  }
  d6 = d6 / deltat;
  if (iprsup >= 4) {
    write(lunit6,
      "(/,' DONE WITH PANEL.','       I     JST    MODE       N',15x,'T',15x,"
      "'A',14x,'D5',14x,'D6',/,17x,4i8,4e16.7)"),
      i, jst, mode, n, t, a, d5, d6;
  }
  if (dzero != 0.0f) {
    goto statement_6320;
  }
  dzero = d5;
  d3 = dzero - d6;
  d4 = 1.0f + d3;
  d5 = 1.0f - d3;
  eta(ifdep) = d4 / d5;
  d3 = 1.0f / d4;
  weight(jst) = d6 * d3;
  goto statement_6455;
  //C     THE FOLLOWING CHANGES RESTORE WEIGHTING FUNCTIONS TO THE          M24. 604
  //C     WAY THEY WERE IN  "M21." .   REMOVE THE  "M22."  CHANGE           M24. 605
  //C     WHICH HAS (WE SUSPECT) LEAD TO INSTABILITY FOR AL'S CASES.        M24. 606
statement_6320:
  d1 = d6 - n * d5;
  d2 = (d5 - d1) * d3;
  d1 = d1 * d3;
  weight(jst) += d2;
  if (n <= 5 && iprsup >= 2) {
    write(lunit6,
      "(/,' ACCUMULATE  ''WEIGHT'' .',4x,'WEIGHT(JST1)',14x,'D2',14x,'D3',5x,"
      "'WEIGHT(JST)',/,23x,4e16.7)"),
      d1, d2, d3, weight(jst);
  }
  weight(jst1) = d1;
  if (kfin > 0) {
    goto statement_6340;
  }
  if (i <= locmin) {
    goto statement_6450;
  }
  if (a < cut2) {
    goto statement_6450;
  }
  goto statement_6410;
statement_6340:
  if (i <= locmax) {
    goto statement_6450;
  }
  if (a > cut1) {
    goto statement_6450;
  }
statement_6410:
  mode = 1;
  tails = t;
  aamp = a;
statement_6450:
  if (kflop == 0) {
    goto statement_6460;
  }
  jst = jst1;
  jst1++;
  if (jst <= lwt) {
    goto statement_6455;
  }
  kill = 1;
  lstat(16) = 14;
  lstat(19) = 6455;
  goto statement_9200;
statement_6455:
  if (i < 0) {
    goto statement_6470;
  }
  kflop = 0;
  d5 = 0.0f;
  d6 = 0.0f;
  tend += deltat;
  n++;
statement_6460:
  i++;
  n5 = ioftm2 + i;
  t = tp(n5);
  a = tp(i);
  goto statement_6220;
statement_6465:
  d1 = 1.0f / (d6 / d5 - tails);
  d2 = d1 * d5;
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' TAIL INTEGRAL COMPLETE.','  IFDEP2',14x,'D2',14x,'D1',11x,'TAILS',"
      "14x,'D5',14x,'D6',/,24x,i8,5e16.7)"),
      ifdep2, d2, d1, tails, d5, d6;
  }
  con1(ifdep2) = d2 * d3;
  con1(jfdep2) = d1;
  con1(kfdep2) = tails;
  if (rtotal <= 0.0f) {
    goto statement_6475;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "('  BEFORE TAIL ADJUSTMENT.',/,18x,'D3',16x,'AAMP',15x,'ADITN',15x,"
      "'TAILP',15x,'TAILQ',15x,'TAILS',4x,'IFDEP2',/,1x,6e20.11,i10)"),
      d3, aamp, aditn, con1(ifdep2), d1, tails, ifdep2;
  }
  tcor = atheo - aditn;
  //C     START NEWTON RAPHSON ITERATIONS ON TAILQ * * * * * * * * * * * * *M29.1368
  bct = std::abs(tcor / aamp);
  bct = alogz(bct);
  d18 = 0.0f;
  ik = 0;
statement_7843:
  ik++;
  if (ik > nii) {
    goto statement_7904;
  }
  d12 = d1 + d18;
  if (ik == 1) {
    goto statement_7910;
  }
  d17 = std::abs(d18) / d1;
  if (d17 <= cmn.epsiln) {
    goto statement_7905;
  }
statement_7910:
  d1 = d12;
  fstar = -alogz(d1) - d1 * tails - bct;
  fder = 1.0f / d1 + tails;
  d18 = fstar / fder;
  if (iprsup >= 1) {
    write(lunit6, "(1x,'ON ITERATION NO.',i5,/,5e22.12)"), ik, fstar,
      fder, d18, d1, bct;
  }
  FEM_DO_SAFE(ikp, 1, 6) {
    if (std::abs(d18) < d1) {
      goto statement_7843;
    }
    d18 = d18 / 5.0f;
  }
  if (std::abs(d18) < d1) {
    goto statement_7843;
  }
statement_7904:
  kill = 46;
  lstat(19) = 7904;
  lstat(14) = nii;
  lstat(15) = ifdep;
  flstat(15) = rtotal;
  goto statement_9200;
statement_7905:
  con1(jfdep2) = d1;
  con1(ifdep2) = tcor * d1 * d3;
  if (iprsup >= 1) {
    write(lunit6,
      "(' SUCCESSFUL TERMINATION.','  IFDEP2',15x,'TAILP',15x,'TAILQ',/,24x,"
      "i8,2e20.12)"),
      ifdep2, con1(ifdep2), con1(jfdep2);
  }
  goto statement_6475;
statement_6470:
  con1(ifdep2) = 0.0f;
  con1(jfdep2) = 0.0f;
  con1(kfdep2) = 0.0f;
statement_6475:
  npoint = jst - iwtent(ifdep2);
  ifdep2++;
  jfdep2++;
  kfdep2++;
  if (kfin > 0) {
    goto statement_6600;
  }
  kfin = 1;
  n6 = iofa1p + locmax;
  cut1 = cut1 * tp(n6);
  n = tp(ioftm1 + 1) / deltat;
  iskip(ifdep) = n;
  tend = n * deltat;
  nhist(ifdep) = npoint;
  i = iofa1p;
  iend = ntime1 + i;
  locmax += i;
  i++;
  atheo = (2.0f * z1) / (2.0f * z1 + rtotal);
  goto statement_6200;
statement_6600:
  zinf(ifdep) = z1;
  npoint += (iskip(ifdep) - 1);
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' READY TO EXIT  ''OVER4'' .',12x,'IBR',12x,'JST',9x,'NPOINT',3x,"
      "'ISKIP(IFDEP)',8x,'NR(IBR)',3x,'NHIST(IFDEP)',/,25x,6i15)"),
      ibr, jst, npoint, iskip(ifdep), nr(ibr), nhist(ifdep);
  }
  if (npoint > nhist(ifdep)) {
    nhist(ifdep) = npoint;
  }
  nhist(ifdep)++;
  cmn.icheck = 3;
  lastov = nchain;
  nchain = 2;
  t = d1tttt;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
statement_9200:
  lastov = nchain;
  nchain = 51;
  lstat(18) = 4;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
statement_99999:;

} // over4

void umoffs(
  common& cmn)
{
  common_write write(cmn);
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  int& lspcum = cmn.lspcum;
  int& iprsup = cmn.iprsup;
  int& iureac = cmn.iureac;
  int& iugpar = cmn.iugpar;
  int& iufpar = cmn.iufpar;
  int& iuhist = cmn.iuhist;
  int& iuumrp = cmn.iuumrp;
  int& iunod1 = cmn.iunod1;
  int& iunod2 = cmn.iunod2;
  int& iujclt = cmn.iujclt;
  int& iujclo = cmn.iujclo;
  int& iujtyp = cmn.iujtyp;
  int& iunodo = cmn.iunodo;
  int& iujtmt = cmn.iujtmt;
  int& iuhism = cmn.iuhism;
  int& iuomgm = cmn.iuomgm;
  int& iuomld = cmn.iuomld;
  int& iutham = cmn.iutham;
  int& iuredu = cmn.iuredu;
  int& iureds = cmn.iureds;
  int& iuflds = cmn.iuflds;
  int& iufldr = cmn.iufldr;
  int& iurequ = cmn.iurequ;
  int& iuflqs = cmn.iuflqs;
  int& iuflqr = cmn.iuflqr;
  int& iujcds = cmn.iujcds;
  int& iujcqs = cmn.iujcqs;
  int& iuflxd = cmn.iuflxd;
  int& iuflxq = cmn.iuflxq;
  int& iunppa = cmn.iunppa;
  int& iurotm = cmn.iurotm;
  int& iuncld = cmn.iuncld;
  int& iunclq = cmn.iunclq;
  int& iujtqo = cmn.iujtqo;
  int& iujomo = cmn.iujomo;
  int& iujtho = cmn.iujtho;
  int& iureqs = cmn.iureqs;
  int& iuepso = cmn.iuepso;
  int& iudcoe = cmn.iudcoe;
  int& iukcoi = cmn.iukcoi;
  int& iuvolt = cmn.iuvolt;
  int& iuangl = cmn.iuangl;
  int& iunodf = cmn.iunodf;
  int& iunodm = cmn.iunodm;
  int& iukumo = cmn.iukumo;
  int& iujumo = cmn.iujumo;
  int& iuumou = cmn.iuumou;
  int& nclfix = cmn.nclfix;
  int& numfix = cmn.numfix;
  int& iotfix = cmn.iotfix;
  int& ibsfix = cmn.ibsfix;
  //
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int i = fem::int0;
  double d5 = fem::double0;
  int n5 = fem::int0;
  //C     OVERLAY-5  U.M.  MODULE CALLED BY "OVER5A".                       M32.1492
  if (nclfix > 0) {
    goto statement_1758;
  }
  nclfix = 20;
  numfix = 3;
  iotfix = 50;
  ibsfix = 60;
statement_1758:
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' BEGIN  \"UMOFFS\" .','  NBYTE1  NBYTE2  NBYTE3  NBYTE4',"
        "'  NCLFIX  NUMFIX  IOTFIX  IBSFIX',/,18x,10i8)");
      FEM_DO_SAFE(i, 1, 4) {
        wloop, nbyte(i);
      }
      wloop, nclfix, numfix, iotfix, ibsfix;
    }
  }
  d5 = nbyte(4);
  d5 = d5 / nbyte(3);
  iureac = 1;
  //C     STEP OVER ALL COIL-TABLE VECTORS NEXT.                            M27. 701
  iugpar = iureac + nclfix;
  iufpar = iugpar + nclfix;
  iuhist = iufpar + nclfix;
  iuumrp = iuhist + nclfix;
  iunod1 = (iuumrp + nclfix) / d5 + 1;
  iunod2 = iunod1 + nclfix;
  iujclt = iunod2 + nclfix;
  iujclo = iujclt + nclfix;
  iujtyp = iujclo + nclfix;
  //C     STEP OVER ALL MACHINE-TABLE VECTORS NEXT.                         M27. 711
  iunodo = iujtyp + numfix;
  iujtmt = iunodo + numfix;
  iuhism = (iujtmt + numfix) * d5 + 1;
  iuomgm = iuhism + numfix;
  iuomld = iuomgm + numfix;
  iutham = iuomld + numfix;
  iuredu = iutham + numfix;
  iureds = iuredu + numfix;
  iuflds = iureds + numfix;
  iufldr = iuflds + numfix;
  iurequ = iufldr + numfix;
  iuflqs = iurequ + numfix;
  iuflqr = iuflqs + numfix;
  iujcds = (iuflqr + numfix) / d5 + 1;
  iujcqs = iujcds + numfix;
  iuflxd = (iujcqs + numfix) * d5 + 1;
  iuflxq = iuflxd + numfix;
  iunppa = (iuflxq + numfix) / d5 + 1;
  iurotm = (iunppa + numfix) * d5 + 1;
  iuncld = (iurotm + numfix) / d5 + 1;
  iunclq = iuncld + numfix;
  iujtqo = iunclq + numfix;
  iujomo = iujtqo + numfix;
  iujtho = iujomo + numfix;
  iureqs = (iujtho + numfix) * d5 + 1;
  iuepso = iureqs + numfix;
  iudcoe = iuepso + numfix;
  iukcoi = (iudcoe + numfix) / d5 + 1;
  iuvolt = (iukcoi + numfix) * d5 + 1;
  iuangl = iuvolt + numfix;
  iunodf = (iuangl + numfix) / d5 + 1;
  iunodm = iunodf + numfix;
  iukumo = iunodm + numfix;
  //C     STEP OVER ALL OUTPUT-TABLE VECTORS NEXT.                          M27. 742
  iujumo = iukumo + iotfix;
  iuumou = (iujumo + iotfix) * d5 + 1;
  //C     FINALLY, STEP OVER LAST VECTOR, AND CHECK FOR OVERFLOW.           M27. 746
  n5 = iuumou + ibsfix;
  lstat(45) = n5;
  if (n5 <= lspcum) {
    goto statement_3458;
  }
  //C     FOLLOWING IS TEMPORARY MESSAGE, TO BE MOVED TO ERROR OVERLAYS     M27. 750
  //C     LATER, WHEN WE HAVE TIME.                                         M27. 751
  write(lunit6,
    "(/,' OVERFLOW ERROR STOP IN  \"UMOFFS\" .',"
    "'   INSUFFICIENT TOTAL WORKING SPACE.',/,1x,10i8)"),
    n5, lspcum, nclfix, numfix, iotfix, ibsfix;
  stoptp(cmn);
statement_3458:
  if (iprsup >= 1) {
    write(lunit6, "(/,' EXIT  \"UMOFFS\" .   N5, LSPCUM =',2i6,/)"), n5, lspcum;
  }
  if (cmn.noutpr == 0) {
    write(kunit6, "('+U.M. DATA BEGINS.  LIST-25 CELLS USED =',i5)"), n5;
  }
}


struct umdatb_save
{
  fem::str<8> tesm1;
  fem::str<8> tesm2;
  fem::str<8> tesm3;
  fem::str<8> tesm4;
  fem::str<8> tesm5;
  fem::str<8> tesm6;
  fem::str<8> tesm7;
  fem::str<8> tesm8;
  fem::str<8> tesm9;
  fem::str<8> textm;

  umdatb_save() :
    tesm1(fem::char0),
    tesm2(fem::char0),
    tesm3(fem::char0),
    tesm4(fem::char0),
    tesm5(fem::char0),
    tesm6(fem::char0),
    tesm7(fem::char0),
    tesm8(fem::char0),
    tesm9(fem::char0),
    textm(fem::char0)
  {}
};

void umdatb(
  common& cmn,
  arr_ref<double> reacl,
  arr_ref<double> gpar,
  arr_ref<double> fpar,
  arr_ref<int> nodvo1,
  arr_ref<int> nodvo2,
  arr_ref<int> jcltac,
  arr_ref<int> jtype,
  arr_ref<int> nodom,
  arr_ref<int> ncld,
  arr_ref<int> jtmtac,
  arr_ref<double> reamdu,
  arr_ref<double> reamds,
  arr_ref<double> flxds,
  arr_ref<double> flxdr,
  arr_ref<double> reamqu,
  arr_ref<double> flxqs,
  arr_ref<double> flxqr,
  arr_ref<int> jcdsat,
  arr_ref<int> jcqsat,
  arr_ref<int> nppair,
  arr_ref<double> rotmom,
  arr_ref<int> nclq,
  arr_ref<int> jtqout,
  arr_ref<int> jthout,
  arr_ref<double> reamqs,
  arr_ref<double> voltum,
  arr_ref<double> anglum,
  arr_ref<int> nodfum,
  arr_ref<int> nodmum,
  arr_ref<int> kumout,
  arr_ref<int> jumout,
  arr_ref<int> jclout,
  arr_ref<double> dcoef,
  arr_ref<int> jomout,
  arr_ref<double> umoutp)
{
  FEM_CMN_SVE(umdatb);
  reacl(dimension(1));
  gpar(dimension(1));
  fpar(dimension(1));
  nodvo1(dimension(1));
  nodvo2(dimension(1));
  jcltac(dimension(1));
  jtype(dimension(1));
  nodom(dimension(1));
  ncld(dimension(1));
  jtmtac(dimension(1));
  reamdu(dimension(1));
  reamds(dimension(1));
  flxds(dimension(1));
  flxdr(dimension(1));
  reamqu(dimension(1));
  flxqs(dimension(1));
  flxqr(dimension(1));
  jcdsat(dimension(1));
  jcqsat(dimension(1));
  nppair(dimension(1));
  rotmom(dimension(1));
  nclq(dimension(1));
  jtqout(dimension(1));
  jthout(dimension(1));
  reamqs(dimension(1));
  voltum(dimension(1));
  anglum(dimension(1));
  nodfum(dimension(1));
  nodmum(dimension(1));
  kumout(dimension(1));
  jumout(dimension(1));
  jclout(dimension(1));
  dcoef(dimension(1));
  jomout(dimension(1));
  umoutp(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  const auto& texta = cmn.texta;
  double& d1 = cmn.d1;
  double& d2 = cmn.d2;
  double& d3 = cmn.d3;
  double& d17 = cmn.d17;
  double& fmum = cmn.fmum;
  double& rmvaum = cmn.rmvaum;
  double& rkvum = cmn.rkvum;
  double& s1um = cmn.s1um;
  double& s2um = cmn.s2um;
  double& zlsbum = cmn.zlsbum;
  double& s1qum = cmn.s1qum;
  double& s2qum = cmn.s2qum;
  double& aglqum = cmn.aglqum;
  double& raum = cmn.raum;
  double& xdum = cmn.xdum;
  double& xdpum = cmn.xdpum;
  double& xqpum = cmn.xqpum;
  double& xdppum = cmn.xdppum;
  double& xqppum = cmn.xqppum;
  double& tdpum = cmn.tdpum;
  double& tdppum = cmn.tdppum;
  double& x0um = cmn.x0um;
  double& rnum = cmn.rnum;
  double& xnum = cmn.xnum;
  double& xfum = cmn.xfum;
  double& xdfum = cmn.xdfum;
  double& xkdum = cmn.xkdum;
  double& xkqum = cmn.xkqum;
  double& xqkqum = cmn.xqkqum;
  double& xqum = cmn.xqum;
  double& xgum = cmn.xgum;
  double& distrf = cmn.distrf;
  double& hjum = cmn.hjum;
  double& dsynum = cmn.dsynum;
  double& dmutum = cmn.dmutum;
  double& spring = cmn.spring;
  double& dabsum = cmn.dabsum;
  double& tqppum = cmn.tqppum;
  double& agldum = cmn.agldum;
  double& xlum = cmn.xlum;
  int& n5 = cmn.n5;
  int& n6 = cmn.n6;
  int& n7 = cmn.n7;
  int& n8 = cmn.n8;
  int& n9 = cmn.n9;
  int& n10 = cmn.n10;
  int& n11 = cmn.n11;
  int& n12 = cmn.n12;
  int& n14 = cmn.n14;
  int& n15 = cmn.n15;
  int& n16 = cmn.n16;
  int& n17 = cmn.n17;
  int& n19 = cmn.n19;
  int& n20 = cmn.n20;
  int& nexc = cmn.nexc;
  int& kconex = cmn.kconex;
  int& ibrexc = cmn.ibrexc;
  int& nstan = cmn.nstan;
  int& numasu = cmn.numasu;
  int& nmgen = cmn.nmgen;
  int& nmexc = cmn.nmexc;
  int& ntypsm = cmn.ntypsm;
  int& netrum = cmn.netrum;
  int& nsmtpr = cmn.nsmtpr;
  int& nsmtac = cmn.nsmtac;
  int& nrsyn = cmn.nrsyn;
  int& ntorq = cmn.ntorq;
  int& mlum = cmn.mlum;
  int& nparum = cmn.nparum;
  int& ngroup = cmn.ngroup;
  int& nall = cmn.nall;
  int& nangre = cmn.nangre;
  int& nexcsw = cmn.nexcsw;
  int& limasu = cmn.limasu;
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& trash = cmn.trash;
  fem::str<8>& blank = cmn.blank;
  const auto& abuff = cmn.abuff;
  double& epsiln = cmn.epsiln;
  auto& twopi = cmn.twopi;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  double& fltinf = cmn.fltinf;
  auto& lstat = cmn.lstat;
  int& lswtch = cmn.lswtch;
  int& nv = cmn.nv;
  int& noutpr = cmn.noutpr;
  int& ktab = cmn.ktab;
  int& numum = cmn.numum;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& kswtch = cmn.kswtch;
  int& it = cmn.it;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  int& kssout = cmn.kssout;
  const auto& loopss = cmn.loopss;
  auto& sptacs = cmn.sptacs;
  auto& kswtyp = cmn.kswtyp;
  auto& topen = cmn.topen;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  const auto& texvec = cmn.texvec;
  auto& ibrnch = cmn.ibrnch;
  auto& jbrnch = cmn.jbrnch;
  auto& tstop = cmn.tstop;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  auto& iform = cmn.iform;
  auto& node = cmn.node;
  auto& crest = cmn.crest;
  auto& tstart = cmn.tstart;
  auto& sfreq = cmn.sfreq;
  auto& kmswit = cmn.kmswit;
  auto& tclose = cmn.tclose;
  auto& kpos = cmn.kpos;
  auto& kode = cmn.kode;
  auto& bus = cmn.bus;
  int& ncltot = cmn.ncltot;
  auto& ndum = cmn.ndum;
  auto& ismtac = cmn.ismtac;
  int& ntotac = cmn.ntotac;
  int& lbstac = cmn.lbstac;
  //
  fem::str<8>& tesm2 = sve.tesm2;
  fem::str<8>& tesm3 = sve.tesm3;
  fem::str<8>& tesm4 = sve.tesm4;
  fem::str<8>& tesm5 = sve.tesm5;
  fem::str<8>& tesm6 = sve.tesm6;
  fem::str<8>& tesm7 = sve.tesm7;
  fem::str<8>& tesm8 = sve.tesm8;
  fem::str<8>& tesm9 = sve.tesm9;
  if (is_called_first_time) {
    sve.textm = "MORE  ";
    sve.tesm1 = "SMDATA";
    tesm2 = "TOLERA";
    tesm3 = "PARAME";
    tesm4 = "ALL   ";
    tesm5 = "NONE  ";
    tesm6 = "EXTEND";
    tesm7 = "FINISH";
    tesm8 = " PART ";
    tesm9 = "SHARE ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  //int kaliu = fem::int0;
  //int kiuty = fem::int0;
  //int kud1 = fem::int0;
  //int klntab = fem::int0;
  //int niu = fem::int0;
  int n1 = fem::int0;
  int n3 = fem::int0;
  int itexc = fem::int0;
  fem::str<8> text3 = fem::char0;
  int n2 = fem::int0;
  fem::str<8> text4 = fem::char0;
  fem::str<8> text5 = fem::char0;
  double tqpum = fem::double0;
  double d10 = fem::double0;
  double d11 = fem::double0;
  double d12 = fem::double0;
  double xfkdum = fem::double0;
  int n4 = fem::int0;
  int ntotst = fem::int0;
  double distr1 = fem::double0;
  int i = fem::int0;
  int kswsta = fem::int0;
  int ndx1 = fem::int0;
  int j = fem::int0;
  int num = fem::int0;
  int ntacb = fem::int0;
  int niunrs = fem::int0;
  int ndy5 = fem::int0;
  int ijk = fem::int0;
  int n1iu = fem::int0;
  int kswexc = fem::int0;
  int mjm = fem::int0;
  int nk = fem::int0;
  static const char* format_17053 =
    "(/,' ERROR STOP. THE UM CODE DOES',' NOT ACCEPT DUAL MACHINES.')";
  static const char* format_17244 =
    "('+UM -',i3,'   SM-59 CLASS 3,',' MANUFACTURE CARD ',i1)";
  static const char* format_17412 =
    "('+UM -',i3,'   SM-59 CLASS 3,',' R AND L PARAM CARD ',i1)";
  static const char* format_17503 =
    "(/,' THE RESULT IS A SATURATED INDUCTANCE GREATER',"
    "' THAN THE UNSATURATED ONE. THE MACHINE',' CONCERNED IS UM NUMBER ',i4,"
    "'.',/,' PLEASE TAKE REALISTICALLY EITHER A LOWER',"
    "' VALUE FOR S1 OR A HIGHER VALUE FOR S2.')";
  static const char* format_17701 = "(a6)";
  static const char* format_17702 = "(80i1)";
  static const char* format_17704 =
    "('+UM -',i3,'   SM-59 CLASS 5, OUTPUT CARD')";
  static const char* format_17826 =
    "(/,' ERROR STOP.   JUST-READ CARD REQUESTING',"
    "' CONTROL BY TACS, BEARS UNRECOGNIZED',/,' TACS NAME :',a6)";
  static const char* format_97507 =
    "(' THE RESULT IS AN UNREALISTIC SATURATION',"
    "' CHARACTERISTIC WITH THE SATURATED LINE-SEGMENT',"
    "' NOT INTERSECTING THE UNSATURATED LINE-SEGMENT',/,"
    "' IN THE FIRST QUADRANT. THE MACHINE CONCERNED',' IS UM NUMBER',i4,'.')";
  //C!w n1, n2, n3, n4 changed to nz1, nz2, nz3, nz4
  //C  START READING SM TYPE -50 TO 59 DATA INPUT FORMAT **********         M42.3148

  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;

  auto& kaliu =  isptacs(11);
  auto& kiuty =  isptacs(13);
  auto& kud1 =   isptacs(14);
  auto& klntab = isptacs(18);

  auto& niu = lstat(54);
  cmn.initum = 1;
  cmn.nsmach = numum;
  n1 = numum;
  jtype(n1) = 13;
  ncld(n1) = 2;
  nclq(n1) = 2;
  jtmtac(n1) = 0;
  nmexc = 0;
  n5 = ncltot + 1;
  n6 = ncltot + 7;
  FEM_DO_SAFE(n10, n5, n6) {
    fpar(n10) = 0.0f;
  }
  //C  *************************** READ CLASS 1 SM TYPE-59 DATA             M42.3161
  FEM_DO_SAFE(n5, 1, 3) {
    if (n5 != 1) {
      cimage(cmn);
    }
    n6 = ncltot + n5;
    read(abuff, "(i2,a6,2x,3e10.6)"), n19, bus1, d1, d2, d3;
    if (noutpr == 0) {
      write(kunit6, "('+UM -',i3,'   SM-59 CLASS 1, CARD ',i1)"), numum, n5;
    }
    if (n5 != 1) {
      goto statement_17056;
    }
    ntypsm = n19;
    if (n19 == 59) {
      goto statement_17054;
    }
    if (n19 == 50) {
      goto statement_17054;
    }
    if (n19 == 52) {
      goto statement_17054;
    }
    write(lunit6, format_17053);
    goto statement_9600;
  statement_17054:
    voltum(n1) = d1;
    anglum(n1) = d3;
    if (d2 == 0.0f) {
      d2 = cmn.statfr;
    }
    rotmom(n1) = twopi * d2;
    cmn.stat59 = d2;
    //C  CREATION OF 2 EXCITATION NODES :                                     M42.3184
    ntot++;
    kode(ntot) = 0;
    nodvo1(ncltot + 4) = ntot;
    nodvo2(ncltot + 4) = 1;
    bus(ntot) = trash;
    ntot++;
    kode(ntot) = 0;
    nexc = ntot;
    bus(nexc) = trash;
    if (numum > 5) {
      goto statement_17056;
    }
    n3 = 41 + (numum - 1) * 4;
    bus(ntot - 1) = texta(n3 + 1);
    bus(nexc) = texta(n3 + 2);
  statement_17056:
    FEM_DO_SAFE(n10, 1, ntot) {
      if (bus1 != bus(n10)) {
        goto statement_17060;
      }
      nodvo1(n6) = n10;
      goto statement_17070;
    statement_17060:;
    }
    write(lunit6,
      "(/,' ERROR STOP.   JUST-READ SM CLASS 1 CARD',"
      "' BEARS ILLEGAL NODE NAME:',a6)"),
      bus1;
    goto statement_9600;
  statement_17070:;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' *********',' ELEMENTS INTERNALLY CREATED FOR UM NR.',i3,': ',"
      "'NODE TO NODE',5x,'IBR',6x,'IT',2x,'KSWTCH',2x,'LSWTCH',2x,'KCONST',9x,"
      "'SFREQ',/)"),
      n1;
  }
  //C  SET VOLTAGE SOURCE FOR EXCITATION                                    M42.3213
  kconst++;
  kconex = kconst;
  nodfum(n1) = kconst;
  iform(kconst) = 14;
  node(kconst) = nexc;
  kode(nexc) = -nexc;
  sfreq(kconst) = epsiln * 1.0e+3;
  tstart(kconst) = -1.0f;
  tstop(kconst) = fltinf;
  if (iprsup >= 1) {
    write(lunit6,
      "(' *********',' FIELD VOLTAGE SOURCE',23x,i4,44x,i4,e14.5)"),
      node(kconst), kconst, sfreq(kconst);
  }
  //C  SET SERIES AND PARALLEL RESISTANCE FOR EXCITATION                    M42.3227
  ibrinc(cmn);
  ibrexc = ibr;
  it++;
  kbus(ibr) = nodvo1(ncltot + 4);
  mbus(ibr) = nexc;
  length(ibr) = 1;
  nr(ibr) = -it;
  tr(it) = epsiln;
  itexc = it;
  //C  NOTE : TR(IT=ITEXC) WILL BE CHANGED LATER TO 0.5 * RF                M42.3237
  tx(it) = 0.0f;
  c(it) = 0.0f;
  if (iprsup >= 1) {
    write(lunit6,
      "(' *********',' SERIES FIELD RESIST.',23x,i4,4x,i4,4x,i4,4x,i4)"),
      mbus(ibr), kbus(ibr), ibr, it;
  }
  ibrinc(cmn);
  it++;
  kbus(ibr) = nexc;
  mbus(ibr) = 1;
  length(ibr) = 1;
  nr(ibr) = -it;
  tr(it) = epsiln;
  tx(it) = 0.0f;
  c(it) = 0.0f;
  if (iprsup >= 1) {
    write(lunit6,
      "(' *********',' PARALL FIELD RESIST.',23x,i4,4x,i4,4x,i4,4x,i4)"),
      mbus(ibr), kbus(ibr), ibr, it;
  }
  //C  SHORTING DAMPER AND EDDY CURRENT COILS                               M42.3257
  FEM_DO_SAFE(n5, 5, 7) {
    nodvo1(ncltot + n5) = 1;
    nodvo2(ncltot + n5) = 1;
  }
  //C  *************************** READ CLASS 2 SM TYPE-59 DATA             M42.3262
  //C  NSTAN = 1 IS A FLAG FOR STANDARD MANUFACTURER DATA                   M42.3263
  nstan = 0;
  cimage(cmn);
  read(abuff, "(a6)"), text3;
  if (text3 != tesm2) {
    goto statement_17106;
  }
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   SM-59 CLASS 2, TOLERANCE CARD')"), numum;
  }
  cimage(cmn);
statement_17106:
  n19 = 1;
  read(abuff, "(a6,18x,e8.0)"), text3, fmum;
  if (text3 != tesm3) {
    goto statement_17200;
  }
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   SM-59 CLASS 2, PAR FIT REQUEST')"), numum;
  }
  nstan = 1;
  cimage(cmn);
  //C  *************************** READ CLASS 3 SM TYPE-59 DATA             M42.3282
statement_17200:
  n2 = 0;
  read(abuff, "(3i2,i4,f6.0,14x,5e10.6)"), numasu, nmgen, nmexc,
    n20, d17, rmvaum, rkvum, agldum, s1um, s2um;
  if (numasu == 0) {
    numasu = d17;
  }
  if (noutpr == 0) {
    write(kunit6,
      "('+UM -',i3,'   SM-59 CLASS 3,',' GENERAL PARAMETERS')"),
      numum;
  }
  //C   ZLSBUM IS THE STATOR BASE INDUCTANCE, IF MULTIPLIED WITH            M42.3292
  //C      ROTMOM(N1), IT BECOMES THE STATOR BASE IMPEDANCE.                M42.3293
  rmvaum = rmvaum * 1.0e+6;
  rkvum = rkvum * 1.0e+3;
  zlsbum = rkvum * rkvum;
  zlsbum = zlsbum / (rotmom(n1) * rmvaum);
  jcdsat(n1) = 0;
  if (agldum < 0.0f) {
    jcdsat(n1) = 1;
  }
  if (agldum < 0.0f) {
    agldum = -agldum;
  }
  nppair(n1) = n20 / 2;
  n5 = 2;
  n6 = nppair(n1) * n5;
  if (n6 == n20) {
    goto statement_17218;
  }
  write(lunit6,
    "(/,' ERROR STOP. ERRONEOUS DATA INPUT BECAUSE',"
    "' AN UNEVEN NUMBER OF POLES HAS BEEN',' SPECIFIED FOR MACH NUMBER',i4,"
    "'.')"),
    n1;
  goto statement_9600;
statement_17218:
  cimage(cmn);
  read(abuff, "(3a6,32x,3e10.6)"), text3, text4, text5, aglqum, s1qum, s2qum;
  if (text3 != blank) {
    goto statement_17224;
  }
  if (text4 != blank) {
    goto statement_17224;
  }
  if (text5 != blank) {
    goto statement_17224;
  }
  goto statement_17226;
statement_17224:
  aglqum = 0.0f;
  s1qum = 0.0f;
  s2qum = 0.0f;
  goto statement_17230;
statement_17226:
  if (noutpr == 0) {
    write(kunit6,
      "('+UM -',i3,'   SM-59 CLASS 3,',' Q-AXIS SATURATION CARD')"),
      numum;
  }
  cimage(cmn);
statement_17230:
  jcqsat(n1) = 0;
  d1 = s1qum + s2qum;
  if (d1 != 0.0f) {
    jcqsat(n1) = 1;
  }
  if (aglqum >= 0.0f) {
    goto statement_17240;
  }
  jcqsat(n1) = 1;
  aglqum = 1.6f * agldum;
  s1qum = 1.5f * s1um;
  s2qum = 1.5f * s2um;
  //C  READING STANDARD MANUFACTURER DATA :                                 M42.3335
statement_17240:
  if (ntypsm == 52) {
    goto statement_17400;
  }
  if (ntypsm == 53) {
    goto statement_17400;
  }
  if (ntypsm == 50) {
    goto statement_17241;
  }
  if (ntypsm == 51) {
    goto statement_17241;
  }
  if (nstan != 1) {
    goto statement_17400;
  }
statement_17241:
  n2 = 0;
  read(abuff, "(8e10.6)"), raum, xlum, xdum, xqum, xdpum, xqpum,
    xdppum, xqppum;
  n2++;
  if (noutpr == 0) {
    write(kunit6, format_17244), numum, n2;
  }
  cimage(cmn);
  read(abuff, "(7e10.6,i10)"), tdpum, tqpum, tdppum, tqppum, x0um,
    rnum, xnum, netrum;
  n2++;
  if (noutpr == 0) {
    write(kunit6, format_17244), numum, n2;
  }
  //C  CONVERSION OF PU SYSTEM TO STATOR REFERED SI SYSTEM :                M42.3357
  raum = raum * zlsbum * rotmom(n1);
  xlum = xlum * zlsbum;
  xdum = xdum * zlsbum;
  xqum = xqum * zlsbum;
  xdpum = xdpum * zlsbum;
  xqpum = xqpum * zlsbum;
  xdppum = xdppum * zlsbum;
  xqppum = xqppum * zlsbum;
  x0um = x0um * zlsbum;
  rnum = rnum * zlsbum * rotmom(n1);
  xnum = xnum * zlsbum;
  //C  ESTABLISHING STATOR AND MACH TABLE VARIABLES                         M42.3369
  if (raum == 0.0f) {
    raum = epsiln;
  }
  FEM_DO_SAFE(n5, 1, 3) {
    gpar(ncltot + n5) = raum;
    if (n5 == 1) {
      goto statement_17260;
    }
    reacl(ncltot + n5) = xlum;
  statement_17260:;
  }
  reacl(ncltot + 1) = x0um;
  reamdu(n1) = xdum - xlum;
  reamqu(n1) = xqum - xlum;
  if (reamqu(n1) > 0.0f) {
    goto statement_17262;
  }
  write(lunit6,
    "(/,' ERROR STOP. INCORRECT UM DATA INPUT. THE',"
    "' RESULT IS THAT THE Q-AXIS MAIN INDUCTANCE',/,7x,"
    "' IS EITHER ZERO OR NEGATIVE FOR MACHINE',' NUMBER',i4,'.')"),
    n1;
  goto statement_9600;
statement_17262:
  if (xqum != xqpum) {
    goto statement_17290;
  }
  if (xqum != xqppum) {
    goto statement_17280;
  }
  gpar(ncltot + 6) = 0.0f;
  gpar(ncltot + 7) = 0.0f;
  reacl(ncltot + 6) = 1.0f;
  reacl(ncltot + 7) = 1.0f;
  goto statement_17290;
statement_17280:
  if (fmum != 1.0f) {
    goto statement_17285;
  }
  gpar(ncltot + 6) = 0.0f;
  reacl(ncltot + 6) = 1.0f;
statement_17285:
  if (fmum == 0.0f) {
    fmum = 0.95f;
  }
  if (fmum < 1.0f) {
    xqpum = fmum * xqum;
  }
statement_17290:
  if (xdum != xdpum) {
    goto statement_17310;
  }
  if (xdum != xdppum) {
    goto statement_17300;
  }
  gpar(ncltot + 4) = 0.0f;
  gpar(ncltot + 5) = 0.0f;
  reacl(ncltot + 4) = 1.0f;
  reacl(ncltot + 5) = 1.0f;
  goto statement_17310;
statement_17300:
  if (fmum != 1.0f) {
    goto statement_17305;
  }
  gpar(ncltot + 4) = 0.0f;
  reacl(ncltot + 4) = 1.0f;
statement_17305:
  if (fmum == 0.0f) {
    fmum = 0.3f;
  }
  if (fmum < 1.0f) {
    xdpum = fmum * xdum;
  }
  //C  ESTABLISHING ROTOR VARIABLES :                                       M42.3410
statement_17310:
  d1 = reamdu(n1) * reamdu(n1);
  if (reacl(ncltot + 4) != 1.0f) {
    goto statement_17320;
  }
  if (reacl(ncltot + 5) == 1.0f) {
    goto statement_17330;
  }
  d10 = d1 / (xdum - xdppum);
  reacl(ncltot + 5) = d10 - reamdu(n1);
  d10 = reamdu(n1) + reacl(ncltot + 5);
  gpar(ncltot + 5) = d10 / tdppum;
  goto statement_17330;
statement_17320:
  d10 = d1 / (xdum - xdpum);
  reacl(ncltot + 4) = d10 - reamdu(n1);
  d10 = reamdu(n1) + reacl(ncltot + 4);
  gpar(ncltot + 4) = d10 / tdpum;
  if (reacl(ncltot + 5) == 1.0f) {
    goto statement_17330;
  }
  d11 = xdum - xdppum + d10 - 2.0f * reamdu(n1);
  d11 = d11 * d1;
  d12 = (xdum - xdppum) * d10 - d1;
  reacl(ncltot + 5) = d11 / d12 - reamdu(n1);
  d11 = reamdu(n1) + reacl(ncltot + 5);
  d12 = d1 / d10;
  gpar(ncltot + 5) = (d11 - d12) / tdppum;
statement_17330:
  d1 = reamqu(n1) * reamqu(n1);
  if (reacl(ncltot + 6) != 1.0f) {
    goto statement_17340;
  }
  if (reacl(ncltot + 7) == 1.0f) {
    goto statement_17500;
  }
  d10 = d1 / (xqum - xqppum);
  reacl(ncltot + 7) = d10 - reamqu(n1);
  d10 = reamqu(n1) + reacl(ncltot + 7);
  gpar(ncltot + 7) = d10 / tqppum;
  goto statement_17500;
statement_17340:
  d10 = d1 / (xqum - xqpum);
  reacl(ncltot + 6) = d10 - reamqu(n1);
  d10 = reamqu(n1) + reacl(ncltot + 6);
  gpar(ncltot + 6) = d10 / tqpum;
  if (reacl(ncltot + 7) == 1.0f) {
    goto statement_17500;
  }
  d11 = xqum - xqppum + d10 - 2.0f * reamqu(n1);
  d11 = d11 * d1;
  d12 = (xqum - xqppum) * d10 - d1;
  reacl(ncltot + 7) = d11 / d12 - reamqu(n1);
  d11 = reamqu(n1) + reacl(ncltot + 7);
  d12 = d1 / d10;
  gpar(ncltot + 7) = (d11 - d12) / tqppum;
  goto statement_17500;
  //C  PROCESSING STANDARD MANUFACTURER DATA COMPLETED.                     M42.3452
  //C  READING OF INDUCTANCE/RESISTANCE DATA INPUT :                        M42.3453
statement_17400:
  n2 = 0;
  read(abuff, "(6e10.6)"), xfum, xdfum, xfkdum, xdum, cmn.xdkdum, xkdum;
  n2++;
  if (noutpr == 0) {
    write(kunit6, format_17412), numum, n2;
  }
  cimage(cmn);
  read(abuff, "(6e10.6,10x,i10)"), xkqum, xqkqum, cmn.xgkqum,
    xqum, cmn.xqgum, xgum, netrum;
  n2++;
  if (noutpr == 0) {
    write(kunit6, format_17412), numum, n2;
  }
  cimage(cmn);
  read(abuff, "(8e10.6)"), reacl(ncltot + 1), gpar(ncltot + 1), gpar(
    ncltot + 4), gpar(ncltot + 5), gpar(ncltot + 6), gpar(ncltot + 7),
    rnum, xnum;
  n2++;
  if (noutpr == 0) {
    write(kunit6, format_17412), numum, n2;
  }
  //C  CONVERSION PU SYSTEM INTO STATOR REFERED SI SYSTEM AND UM            M42.3478
  //C    PARAMETER INPUT                                                    M42.3479
  rnum = rnum * zlsbum * rotmom(n1);
  xnum = xnum * zlsbum;
  if (gpar(ncltot + 1) == 0.0f) {
    gpar(ncltot + 1) = epsiln;
  }
  gpar(ncltot + 2) = gpar(ncltot + 1);
  gpar(ncltot + 3) = gpar(ncltot + 1);
  d1 = zlsbum * rotmom(n1);
  FEM_DO_SAFE(n5, 1, 7) {
    gpar(ncltot + n5) = gpar(ncltot + n5) * d1;
  }
  reamdu(n1) = xdfum;
  reamqu(n1) = xqkqum;
  reacl(ncltot + 1) = reacl(ncltot + 1) * zlsbum;
  reacl(ncltot + 2) = (xdum - reamdu(n1)) * zlsbum;
  reacl(ncltot + 3) = (xqum - reamqu(n1)) * zlsbum;
  reacl(ncltot + 4) = (xfum - reamdu(n1)) * zlsbum;
  reacl(ncltot + 5) = (xkdum - reamdu(n1)) * zlsbum;
  reacl(ncltot + 6) = (xkqum - reamqu(n1)) * zlsbum;
  reacl(ncltot + 7) = (xgum - reamqu(n1)) * zlsbum;
  reamdu(n1) = reamdu(n1) * zlsbum;
  reamqu(n1) = reamqu(n1) * zlsbum;
  //C  REDUCTION FACTOR 1/KF = IFB/ISB , STORED IN DCOEF(N1) :              M42.3499
statement_17500:
  dcoef(n1) = reamdu(n1) * agldum * rotmom(n1) / rkvum;
  //C  START PROCESSING SATURATION :                                        M42.3501
  flxds(n1) = 0.0f;
  flxqs(n1) = 0.0f;
  reamds(n1) = 0.0f;
  reamqs(n1) = 0.0f;
  flxdr(n1) = 0.0f;
  flxqr(n1) = 0.0f;
  if (jcdsat(n1) == 0) {
    jcqsat(n1) = 0;
  }
  if (jcdsat(n1) == 0) {
    goto statement_17510;
  }
  reamds(n1) = 0.2f * reamdu(n1) * agldum / (s2um - s1um);
  d1 = reamds(n1) - epsiln;
  if (d1 <= reamdu(n1)) {
    goto statement_17504;
  }
  write(lunit6,
    "(/,' ERROR STOP. YOU HAVE CHOSEN INCORRECT',"
    "' D - AXIS SATURATION PARAMETERS S1 AND S2.')");
  write(lunit6, format_17503), n1;
  goto statement_9600;
statement_17504:
  flxds(n1) = (s2um - 1.2f * s1um) * rkvum / rotmom(n1);
  d2 = s2um - s1um - 0.2f * agldum;
  if (d2 != 0.0f) {
    goto statement_17505;
  }
  jcdsat(n1) = 0.0f;
  jcqsat(n1) = 0.0f;
  goto statement_17510;
statement_17505:
  flxds(n1) = flxds(n1) / d2;
  d10 = 1.0f - reamds(n1) / reamdu(n1);
  d10 = d10 * flxds(n1);
  if (d10 >= 0.0f) {
    goto statement_97510;
  }
  write(lunit6,
    "(/,' ERROR STOP.  YOU HAVE CHOSEN INCORRECT',"
    "' D-AXIS SATURATION PARAMETERS S1 AND S2.')");
  write(lunit6, format_97507), n1;
  goto statement_9600;
statement_97510:
  if (jcqsat(n1) == 0) {
    goto statement_17510;
  }
  reamqs(n1) = 0.2f * reamqu(n1) * aglqum / (s2qum - s1qum);
  d1 = reamqs(n1) - epsiln;
  if (d1 <= reamqu(n1)) {
    goto statement_17508;
  }
  write(lunit6,
    "(/,' ERROR STOP. YOU HAVE CHOSEN INCORRECT',"
    "' Q - AXIS SATURATION PARAMETERS S1 AND S2.')");
  write(lunit6, format_17503), n1;
  goto statement_9600;
statement_17508:
  flxqs(n1) = (s2qum - 1.2f * s1qum) * rkvum / rotmom(n1);
  d2 = s2qum - s1qum - 0.2f * aglqum;
  if (d2 != 0.0f) {
    goto statement_17509;
  }
  jcqsat(n1) = 0.0f;
  goto statement_17510;
statement_17509:
  flxqs(n1) = flxqs(n1) / d2;
  d10 = 1.0f - reamqs(n1) / reamqu(n1);
  d10 = d10 * flxqs(n1);
  if (d10 >= 0.0f) {
    goto statement_17510;
  }
  write(lunit6,
    "(/,' ERROR STOP.  YOU HAVE CHOSEN INCORRECT',"
    "' Q-AXIS SATURATION PARAMATERS S1 AND S2.')");
  write(lunit6, format_97507), n1;
  goto statement_9600;
  //C  START PROCESSING NEUTRAL ELEMENT VALUES :                            M42.3566
statement_17510:
  d2 = 1.0e+2;
  if (netrum == 1) {
    rnum = d2;
  }
  d1 = rnum + xnum * 1.0e+3;
  if (d1 > d2) {
    rnum = d2;
  }
  if (d1 > d2) {
    xnum = 0.0f;
  }
  n7 = 1;
  //C  CREATION OF NEUTRAL NODE                                             M42.3573
  FEM_DO_SAFE(n5, 1, 3) {
    n6 = ncltot + n5;
    if (d1 == 0.0f) {
      goto statement_17520;
    }
    if (n5 > 1) {
      goto statement_17520;
    }
    ntot++;
    kode(ntot) = 0;
    n7 = ntot;
    bus(ntot) = trash;
    if (numum > 5) {
      goto statement_17520;
    }
    bus(ntot) = texta(numum + 60);
  statement_17520:
    nodvo2(n6) = n7;
  }
  //C  CREATE HIGH RESISTANCES IN PARALLEL OVER COILS IF                    M42.3586
  if (loopss(8) != 0) {
    goto statement_17536;
  }
  FEM_DO_SAFE(n5, 1, 3) {
    ibrinc(cmn);
    it++;
    kbus(ibr) = nodvo1(ncltot + n5);
    mbus(ibr) = nodvo2(ncltot + n5);
    length(ibr) = 1;
    nr(ibr) = -it;
    tr(it) = 1.0e+8;
    tx(it) = 0.0f;
    c(it) = 0.0f;
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' HIGH POWER RESIST.',25x,i4,4x,i4,4x,i4,4x,i4)"),
        mbus(ibr), kbus(ibr), ibr, it;
    }
  }
  //C  INSERTION OF NEUTRAL IMPEDANCE                                       M42.3603
statement_17536:
  if (d1 == 0.0f) {
    goto statement_17540;
  }
  ibrinc(cmn);
  it++;
  kbus(ibr) = nodvo2(ncltot + 1);
  mbus(ibr) = 1;
  length(ibr) = 1;
  nr(ibr) = -it;
  tr(it) = rnum;
  if (xopt == 0.0f) {
    tx(it) = xnum * 1.0e+3;
  }
  if (xopt != 0.0f) {
    tx(it) = xnum * twopi * xopt;
  }
  c(it) = 0.0f;
  if (iprsup >= 1) {
    write(lunit6,
      "(' *********',' NEUTRAL IMPEDANCE',26x,i4,4x,i4,4x,i4,4x,i4)"),
      mbus(ibr), kbus(ibr), ibr, it;
  }
  //C  SET 0.5*RF FOR EXTERNAL EXCITER RESISTANCE:                          M42.3619
  //C    (INTERNAL FIELD RESISTANCE ADJUSTED AT 17958)                      M42.3620
statement_17540:
  tr(itexc) = 0.5f * gpar(ncltot + 4) / (dcoef(n1) * dcoef(n1));
  //C  *************************** READ CLASS 4 SM TYPE-59 DATA             M42.3622
  d10 = 1.0e+6;
  nsmtpr = nsmtac;
  nrsyn = 0;
  ntorq = 0;
  //C   NTOTST + K = EMTP NODE NR OF MASS NR. K                             M42.3627
  //C   NMGEN NOW BECOMES EMTP NODE NR OF GENERATOR MASS                    M42.3628
  //C   NMEXC NOW BECOMES EMTP NODE NR OF EXCITER MASS                      M42.3629
  jtmtac(n1) = 0;
  cimage(cmn);
  read(abuff, "(a6)"), text3;
  if (text3 != tesm9) {
    goto statement_17570;
  }
  read(abuff, "(6x,2i6)"), n3, n4;
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   SM-59 CLASS 4, SHARE MECH NETW')"), numum;
  }
  if (n1 != n3 && n1 != n4) {
    goto statement_17560;
  }
  write(lunit6,
    "(/,' ERROR STOP. THIS UM-',i3,' IS SUPPOSED TO',"
    "' SHARE ITS MECH NETWORK WITH OTHER UM''S. WHAT',"
    "' SHOULD BE SPECIFIED ON THIS CARD ARE THE',/,"
    "' NUMBERS OF THESE OTHER UM''S WITHOUT',"
    "' INCLUDING THE NUMBER OF THE UM WHICH IS',"
    "' BEING PROCESSED RIGHT NOW.')"),
    n1;
  goto statement_9600;
statement_17560:
  n6 = n1;
  if (n3 != 0 && n3 < n6) {
    n6 = n3;
  }
  if (n4 != 0 && n4 < n6) {
    n6 = n4;
  }
  //C  ONLY THE LOWEST NUMBERED UM OF THE MACHINES SHARING                  M42.3651
  //C   A COMMON MECH NETWORK ARE SPECIFIED WITH THE MECH NETWORK           M42.3652
  //C   STRUCTURE (THROUGH THE MASS CARDS OF CLASS 4). THE FLAG             M42.3653
  //C   JTMTAC(N1)=-999999 INDICATES THAT UM NUMBER N1 IS NOT THE           M42.3654
  //C   THIS LOWEST NUMBERED UM.                                            M42.3655
  if (n1 == n6) {
    jtmtac(n1) = -ntot;
  }
  if (n1 != n6) {
    jtmtac(n1) = -999999;
  }
  ntotst = -jtmtac(n6);
  goto statement_17571;
statement_17570:
  ntotst = ntot;
statement_17571:
  nmgen += ntotst;
  if (nmexc == 0) {
    goto statement_17575;
  }
  nmexc += ntotst;
  //C. STORING IN FPAR AND CREATE CURRENT SOURCE FOR "TQEXC" :              M42.3664
  kconst++;
  iform(kconst) = 14;
  node(kconst) = -nmexc;
  kode(nmexc) = 0;
  crest(kconst) = 0.0f;
  tstart(kconst) = -1.0f;
  tstop(kconst) = fltinf;
  sfreq(kconst) = 0.00001f;
  if (iprsup >= 1) {
    write(lunit6,
      "(' *********',' EXCITER TORQUE SOURCE',22x,i4,44x,i4,e14.5)"),
      node(kconst), kconst, sfreq(kconst);
  }
  fpar(ncltot + 4) = -kconst;
  fpar(ncltot + 5) = nmexc;
  fpar(ncltot + 6) = nexc;
statement_17575:
  nodom(n1) = nmgen;
  //C  SET ALL MECHANICAL NODES                                             M42.3681
  if (jtmtac(n1) == -999999) {
    goto statement_17700;
  }
  ntot += 2 * numasu;
  n6 = ntotst + 1;
  FEM_DO_SAFE(n5, n6, ntot) {
    kode(n5) = 0;
  }
  //C  NSMTPR IS TO STORE THE VALUE OF NSMTAC OF THE PREVIOUS MACH.         M42.3687
  //C  NSMTAC IS THE TOTAL NR OF VARIABLES TO BE PASSED TO TACS.            M42.3688
  //C  NTORQ IS THE NUMBER OF MASSES WITH DISTRF .NE. 0.0 , THUS            M42.3689
  //C    FOR THE MASSES WITH AN EXTERNALLY APPLIED TORQUE.                  M42.3690
  //C  STORAGE APPROACH IN UMOUTP FOR EACH SM :                             M42.3691
  //C    THE FIRST NUMASU CELLS BEHIND NSMTPR IS FOR DISTRF.                M42.3692
  //C    THE SECOND NUMASU CELLS FOR L12 (AND OF COURSE L23,ETC).           M42.3693
  //C    THE THIRD NUMASU CELLS FOR L12/R12 .                               M42.3694
  //C    THEN THE REST FOR QUANTITIES REFLECTING TACS TRANSFER.             M42.3695
  //C    AFTER COMPLETION OF READING ALL SM DATA, THE 3*NUMASU              M42.3696
  //C      CELLS BEHIND NSMTPR ARE DESTROYED AND THE QUANTITIES             M42.3697
  //C      FOR TACS TRANSFER ARE SHIFTED TO BEHIND NSMTPR.                  M42.3698
  //C  STORAGE APPROACH FOR EACH VARIABLE TO BE TRANSFERED :                M42.3699
  //C   * FOR VOLTAGES (SPEEDS) :                                           M42.3700
  //C          FIRST CELL = CODE NR PROVIDED WITH NEG SIGN                  M42.3701
  //C          SECOND CELL = NODE NR                                        M42.3702
  //C          THIRD CELL = TACS TABLE NR (NTOTAC)                          M42.3703
  //C   * FOR CURRENTS (TORQUES) :                                          M42.3704
  //C        SAME AS VOLTAGES, EXCEPT THIRD CELL = SWITCH TABLE NR.         M42.3705
  //C   * FOR MASS ANGLES :                                                 M42.3706
  //C          FIRST, SECOND AND THIRD CELL SAME AS VOLTAGES                M42.3707
  //C          FOURTH CELL = ANGLE HISTORY, ANGLE PART                      M42.3708
  //C          FIFTH CELL = ANGLE HISTORY, OMEGA*DELTAT/2 PART              M42.3709
  FEM_DO_SAFE(n5, 1, numasu) {
    if (n5 == 1 && jtmtac(n1) == 0) {
      goto statement_17582;
    }
    cimage(cmn);
  statement_17582:
    n17 = 0;
    read(abuff, "(i2,i6,2x,6e10.6,a6)"), mlum, n17, distrf, hjum,
      dsynum, dmutum, spring, dabsum, bus1;
    if (mlum == 0) {
      mlum = n17;
    }
    if (noutpr == 0) {
      write(kunit6, "('+UM -',i3,'   SM-59 CLASS 4, MASS NR.',i6)"),
        numum, mlum;
    }
    if (mlum <= numasu) {
      goto statement_17604;
    }
    write(lunit6,
      "(/,' ERROR STOP. THE LAST CARD INDICATES THE DATA',' OF MASS NUMBER',"
      "i6,', AND YET IN CLASS-3 OF ',/,"
      "' OF SM DATA CARDS YOU HAVE SPECIFIED THE',"
      "' TOTAL NUMBER OF MASSES \"NUMAS\" TO BE EQUAL',' TO',i6,'.',/,"
      "' PLEASE REMOVE THIS CONFLICT.')"),
      mlum, numasu;
    goto statement_9600;
    //C  OUTPUT NAMES OF MECHANICAL NODES :                                   M42.3730
  statement_17604:
    bus(ntotst + mlum) = bus1;
    //C  CREATING MASS ELEMENT                                                M42.3732
    ibrinc(cmn);
    it++;
    kbus(ibr) = ntotst + mlum;
    mbus(ibr) = 1;
    length(ibr) = 1;
    nr(ibr) = -it;
    tr(it) = 0.0f;
    tx(it) = 0.0f;
    //C  THE FOLLOWING FACTOR OF D10=1.0D+6 IS DUE TO MICRO F OR MHO.         M42.3741
    c(it) = d10 * d10 * hjum / 23.73f;
    if (copt != 0.0f) {
      c(it) = c(it) * copt * twopi;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' MASS BRANCH NR.',i3,25x,i4,4x,i4,4x,i4,4x,i4)"),
        mlum, mbus(ibr), kbus(ibr), ibr, it;
    }
    //C  CREATING SPRING ELEMENT :                                            M42.3748
    n6 = nsmtpr + numasu + mlum + 1;
    if (mlum == numasu) {
      goto statement_17608;
    }
    if (spring == 0.0f) {
      goto statement_17608;
    }
    ibrinc(cmn);
    it++;
    kbus(ibr) = ntotst + numasu + mlum;
    mbus(ibr) = ntotst + mlum + 1;
    length(ibr) = 1;
    nr(ibr) = -it;
    tr(it) = 0.0f;
    //C  THE FOLLOWING FACTOR OF 1.0D+3 IS BECAUSE OF MILLI HENRY             M42.3759
    d1 = d10 * spring / 0.73756f;
    if (xopt == 0.0f) {
      tx(it) = 1.0e+3 / d1;
    }
    if (xopt != 0.0f) {
      tx(it) = twopi * xopt / d1;
    }
    c(it) = 0.0f;
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' SPRING BRANCH',30x,i4,4x,i4,4x,i4,4x,i4)"),
        mbus(ibr), kbus(ibr), ibr, it;
    }
    umoutp(n6) = 1.0f / d1;
    goto statement_17610;
  statement_17608:
    umoutp(n6) = 0.0f;
    //C  CREATING SYNCHRONOUS DAMPING AND SYNCHRONOUS SPEED SOURCE :          M42.3771
  statement_17610:
    if (dsynum == 0.0f) {
      goto statement_17620;
    }
    ntot++;
    nrsyn++;
    kode(ntot) = 0;
    bus(ntot) = trash;
    if (numum > 5) {
      goto statement_17614;
    }
    if (n5 != 1) {
      goto statement_17612;
    }
    bus(ntot) = texta(numum + 65);
  statement_17612:
    if (n5 != 2) {
      goto statement_17614;
    }
    bus(ntot) = texta(numum + 70);
  statement_17614:
    kconst++;
    iform(kconst) = 14;
    node(kconst) = ntot;
    kode(ntot) = -ntot;
    sfreq(kconst) = 0.00001f;
    tstart(kconst) = -1.0f;
    tstop(kconst) = fltinf;
    crest(kconst) = rotmom(n1) / nppair(n1);
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' SYNCHR DAMPING VOLTAGE SOURCE',14x,i4,44x,i4,e14.5)"),
        node(kconst), kconst, sfreq(kconst);
    }
    ibrinc(cmn);
    it++;
    kbus(ibr) = ntotst + mlum;
    mbus(ibr) = ntot;
    length(ibr) = 1;
    nr(ibr) = -it;
    tr(it) = 0.73756f / dsynum;
    tx(it) = 0.0f;
    c(it) = 0.0f;
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' SYNCHR. DAMPING BRANCH FOR MASS NR.',i3,5x,i4,4x,i4,"
        "4x,i4,4x,i4)"),
        mlum, mbus(ibr), kbus(ibr), ibr, it;
    }
    //C  CREATING MUTUAL DAMPING :                                            M42.3809
  statement_17620:
    n6 = nsmtpr + 2 * numasu + mlum + 1;
    if (mlum == numasu) {
      goto statement_17628;
    }
    if (dmutum == 0.0f) {
      goto statement_17628;
    }
    ibrinc(cmn);
    it++;
    kbus(ibr) = ntotst + numasu + mlum;
    mbus(ibr) = ntotst + mlum + 1;
    length(ibr) = 1;
    nr(ibr) = -it;
    tr(it) = 0.73756f / dmutum;
    tx(it) = 0.0f;
    c(it) = 0.0f;
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' MUTUAL DAMPING BRANCH',22x,i4,4x,i4,4x,i4,4x,i4)"),
        mbus(ibr), kbus(ibr), ibr, it;
    }
    if (spring == 0.0f) {
      goto statement_17628;
    }
    d1 = 0.73756f / (d10 * spring);
    umoutp(n6) = d1 / tr(it);
    goto statement_17630;
  statement_17628:
    umoutp(n6) = 0.0f;
    //C  CREATING ABSOLUTE DAMPING :                                          M42.3831
  statement_17630:
    if (dabsum == 0.0f) {
      goto statement_17640;
    }
    ibrinc(cmn);
    it++;
    kbus(ibr) = ntotst + mlum;
    mbus(ibr) = 1;
    length(ibr) = 1;
    nr(ibr) = -it;
    tr(it) = 0.73756f / dabsum;
    tx(it) = 0.0f;
    c(it) = 0.0f;
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' ABSLT DAMPING BRANCH FOR MASS NR.',i3,7x,i4,4x,i4,4x,"
        "i4,4x,i4)"),
        mlum, mbus(ibr), kbus(ibr), ibr, it;
    }
    //C  STORING APPLIED TORQUE DISTRIBUTION FACTORS DISTRF IN                M42.3847
    //C   UMOUTP AND THE CORRESPONDING MASS NODE NRS IN KUMOUT                M42.3848
  statement_17640:
    if (distrf == 0.0f) {
      goto statement_17660;
    }
    ntorq++;
    kumout(ntorq) = ntotst + mlum;
    if (ntorq != 1) {
      goto statement_17650;
    }
    distr1 = distrf;
    //C  DISTR1 IS THE FIRST MASS ENCOUNTERED WITH DISTRF .NE. 0.0            M42.3854
    umoutp(nsmtpr + 1) = 1.0e+3;
    goto statement_17660;
  statement_17650:
    umoutp(nsmtpr + ntorq) = 1.0e+3 * distrf / distr1;
  statement_17660:;
  }
  //C  OUTPUT NAMES OF NODES NEXT TO MEASUREMENT SWITCHES :                 M42.3859
  n6 = numasu - 1;
  if (numasu == 1) {
    goto statement_17672;
  }
  FEM_DO_SAFE(n5, 1, n6) {
    n7 = ntotst + numasu + n5;
    n8 = ntotst + n5 + 1;
    bus(n7) = bus(n8);
  }
statement_17672:
  n7 = ntotst + 2 * numasu;
  bus(n7) = trash;
  if (numum > 5) {
    goto statement_17700;
  }
  n3 = 41 + (numum - 1) * 4;
  bus(n7) = texta(n3);
  //C  *************************** READ CLASS 5 SM TYPE-59 DATA             M42.3872
statement_17700:
  cimage(cmn);
  read(abuff, format_17701), text3;
  if (text3 == blank) {
    goto statement_17770;
  }
  if (text3 == tesm4) {
    goto statement_17750;
  }
  if (text3 == tesm5) {
    goto statement_17750;
  }
  if (text3 == tesm6) {
    goto statement_17750;
  }
  n15 = 68;
  if (numasu <= 68) {
    n15 = numasu;
  }
  {
    read_loop rloop(abuff(1), format_17702);
    rloop, nparum, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12;
    FEM_DO_SAFE(i, 1, n15) {
      rloop, jumout(i);
    }
  }
  if (jtmtac(n1) != -999999) {
    goto statement_17703;
  }
  FEM_DO_SAFE(i, 1, n15) {
    jumout(i) = 0;
  }
statement_17703:
  if (noutpr == 0) {
    write(kunit6, format_17704), numum;
  }
  n16 = 0;
  n17 = 1;
statement_17706:
  if (numasu <= n15) {
    goto statement_17710;
  }
statement_17708:
  cimage(cmn);
  n16++;
  n14 = 68 * n17 + (n16 - 1) * 80 + 1;
  n15 = 68 * n17 + n16 * 80;
  if (numasu <= n15) {
    n15 = numasu;
  }
  {
    read_loop rloop(abuff(1), format_17702);
    FEM_DO_SAFE(i, n14, n15) {
      rloop, jumout(i);
    }
  }
  if (jtmtac(n1) != -999999) {
    goto statement_17709;
  }
  FEM_DO_SAFE(i, n14, n15) {
    jumout(i) = 0;
  }
statement_17709:
  if (noutpr == 0) {
    write(kunit6, format_17704), numum;
  }
  goto statement_17706;
statement_17710:
  if (n3 == 0) {
    goto statement_17716;
  }
  FEM_DO_SAFE(n15, 1, 3) {
    jclout(ncltot + n15) = 2;
  }
statement_17716:
  if (n2 != 0) {
    kssout = 1;
  }
  if (n4 != 0) {
    jclout(ncltot + 4) = 1;
  }
  if (n5 != 0) {
    jclout(ncltot + 5) = 1;
  }
  if (n6 != 0) {
    jclout(ncltot + 6) = 1;
  }
  if (n7 != 0) {
    jclout(ncltot + 7) = 1;
  }
  if (n9 != 0) {
    jtqout(n1) = 1;
  }
  if (n10 == 1) {
    jthout(n1) = 3;
  }
  if (nmexc == 0) {
    jthout(n1) = 0;
  }
  if (n10 == 3) {
    jthout(n1) = 1;
  }
  if (n3 != 0) {
    goto statement_17726;
  }
  if (n11 == 0) {
    goto statement_17726;
  }
  FEM_DO_SAFE(n15, 1, 3) {
    jclout(ncltot + n15) = 1;
  }
statement_17726:
  if (n12 == 0) {
    goto statement_17728;
  }
  if (n12 == 2) {
    goto statement_17727;
  }
  jtqout(n1) = 2;
  jomout(n1) = 2;
  goto statement_17728;
statement_17727:
  jtqout(n1) = 3;
  jomout(n1) = 3;
  //C  INTERFACING IF MASS SPEED OUTPUT IS REQUESTED :                      M42.3929
statement_17728:
  FEM_DO_SAFE(n15, 1, numasu) {
    if (jumout(n15) == 0) {
      goto statement_17734;
    }
    if (jumout(n15) == 2) {
      goto statement_17734;
    }
    nv++;
    if (nv <= cmn.lsiz12) {
      goto statement_17732;
    }
    write(lunit6,
      "(/,' ERROR STOP.   OUTPUT NV .GT. LSIZ12',' FOR SPEEDS OF UM -',i3)"),
      numum;
    goto statement_9600;
  statement_17732:
    ibrnch(nv) = ntotst + n15;
    jbrnch(nv) = 1;
  statement_17734:;
  }
  //C  SET MEASUREMENT SWITCHES AND SHAFT TORQUE OUTPUTTING :               M42.3942
  //C   (KSWSTA+1) IS FIRST SWITCH TO BE SET FROM MASS 1 TO MASS 2          M42.3943
  if (jtmtac(n1) == -999999) {
    goto statement_17800;
  }
  kswsta = kswtch;
  n16 = numasu - 1;
  if (numasu == 1) {
    goto statement_17742;
  }
  FEM_DO_SAFE(n15, 1, n16) {
    kswtch++;
    ndx1 = kswtch + lswtch;
    kmswit(kswtch) = ntotst + n15 + numasu;
    kmswit(ndx1) = ntotst + n15;
    kswtyp(kswtch) = 0;
    tclose(kswtch) = -1.0f;
    topen(kswtch) = fltinf;
    kpos(kswtch) = 11;
    if (jumout(n15) == 2) {
      kpos(kswtch) = -11;
    }
    if (jumout(n15) == 3) {
      kpos(kswtch) = -11;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' TORQUE SENSOR SWITCH',23x,i4,4x,i4,20x,i4,4x,i4)"),
        kmswit(kswtch), kmswit(ndx1), kswtch, lswtch;
    }
  }
  //C  CREATE SMALL SERIES RESISTANCE FOR APPLIED TORQUE TO UM MASS         M42.3965
statement_17742:
  ibrinc(cmn);
  it++;
  kbus(ibr) = nmgen;
  mbus(ibr) = ntotst + 2 * numasu;
  length(ibr) = 1;
  nr(ibr) = -it;
  tr(it) = 1.0f;
  tx(it) = 0.0f;
  c(it) = 0.0f;
  if (iprsup >= 1) {
    write(lunit6,
      "(' *********',' SMALL SERIES RESIST FOR APLL GEN TORQUE',4x,i4,4x,i4,"
      "4x,i4,4x,i4)"),
      mbus(ibr), kbus(ibr), ibr, it;
  }
  goto statement_17800;
statement_17750:
  n15 = 1;
  read(abuff, "(10x,12i5)"), nparum, n2, n3, n4, n5, n6, n7, n8,
    n9, n10, n11, n12;
  if (noutpr == 0) {
    write(kunit6, format_17704), numum;
  }
  if (text3 != tesm4) {
    goto statement_17756;
  }
  if (jtmtac(n1) == -999999) {
    goto statement_17710;
  }
  FEM_DO_SAFE(n15, 1, numasu) {
    jumout(n15) = 3;
  }
  goto statement_17710;
statement_17756:
  if (text3 != tesm5) {
    goto statement_17760;
  }
  FEM_DO_SAFE(n15, 1, numasu) {
    jumout(n15) = 0;
  }
  goto statement_17710;
statement_17760:
  n15 = 0;
  n16 = 0;
  n17 = 0;
  goto statement_17708;
  //C  IN CASE OF NEW SM-59 OUTPUT REQUEST USAGE :                          M42.4000
statement_17770:
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   SM-59 CLASS 4, TERMINATION CARD')"), numum;
  }
statement_17774:
  cimage(cmn);
  read(abuff, format_17701), text3;
  if (text3 == blank) {
    goto statement_17799;
  }
  {
    read_loop rloop(abuff(1), "(2x,2i1,4x,12i6)");
    rloop, ngroup, nall;
    FEM_DO_SAFE(i, 1, 12) {
      rloop, ndum(i);
    }
  }
  if (noutpr == 0) {
    write(kunit6,
      "('+UM -',i3,'   SM-59 CLASS 5, OUTPUT GROUP',i2)"), numum,
      ngroup;
  }
  if (ngroup > 0 && ngroup <= 4) {
    goto statement_97778;
  }
  write(lunit6,
    "(/,' ERROR STOP. THE LAST-READ CARD IS AN SM-59',"
    "' OUTPUT REQUEST CARD FOR OUTPUT GROUP',i2,'.',"
    "' THIS IS AN ILLEGAL OUTPUT GROUP AS YOU',/,"
    "' COULD FIND OUT BY CONSULTING THE EMTP RULE',"
    "' BOOK REGARDING THE SM-59 OUTPUT REQUEST RULES.')"),
    ngroup;
  goto statement_9600;
statement_97778:
  switch (ngroup) {
  case 1: goto statement_17782;
  case 2: goto statement_17779;
  case 3: goto statement_17793;
  case 4: goto statement_17798;
  default: break;
  }
  //C  TREATMENT OF GROUP 2 (ANGLES) OUTPUT REQUEST : IGNORED               M42.4019
statement_17779:
  if (noutpr == 0) {
    write(lunit6,
      "(/,' WARNING : THIS OUTPUT REQUEST FOR MASS',"
      "' ANGLES IS IGNORED BY THE UM. THEY',"
      "' ARE TO BE OBTAINED FROM THE TACS OUTPUT',/,"
      "' AFTER REQUEST OF TRANSFER INTO TACS THROUGH',"
      "' THE CLASS-6 SM-59 DATA INPUT CARDS (CONSULT',' EMTP RULE BOOK)',/)");
  }
  goto statement_17774;
  //C   TREATMENT OF GROUP 1 (ELECTRICAL VARIABLES) OUTPUT REQUEST :        M42.4028
statement_17782:
  if (nall == 0) {
    goto statement_17784;
  }
  kssout = 1;
  if (nmexc != 0) {
    jthout(n1) = 3;
  }
  if (nmexc == 0) {
    jthout(n1) = 1;
  }
  jtqout(n1) = 3;
  jomout(n1) = 3;
  FEM_DO_SAFE(i, 1, 7) {
    jclout(ncltot + i) = 1;
  }
  goto statement_17774;
statement_17784:
  FEM_DO_SAFE(i, 1, 12) {
    if (ndum(i) == 0) {
      goto statement_17786;
    }
    FEM_DO_SAFE(j, 4, 10) {
      if (ndum(i) != j) {
        goto statement_17785;
      }
      n2 = j;
      if (j > 7) {
        n2 = j - 7;
      }
      jclout(ncltot + n2) = 1;
      goto statement_17786;
    statement_17785:;
    }
    if (ndum(i) == 15) {
      jthout(n1) = 3;
    }
    if (ndum(i) != 14) {
      goto statement_17786;
    }
    jtqout(n1) = 1;
    jomout(n1) = 1;
    if (jthout(n1) == 0) {
      jthout(n1) = 1;
    }
  statement_17786:;
  }
  n3 = 0;
  FEM_DO_SAFE(i, 1, 12) {
    if (ndum(i) == 0) {
      goto statement_17792;
    }
    FEM_DO_SAFE(j, 1, 3) {
      if (ndum(i) != j) {
        goto statement_17791;
      }
      if (jclout(ncltot + j) == 0) {
        goto statement_17790;
      }
      n3 = 1;
      goto statement_17792;
    statement_17790:
      jclout(ncltot + j) = 2;
      goto statement_17792;
    statement_17791:;
    }
    if (ndum(i) < 12) {
      goto statement_17792;
    }
    if (ndum(i) > 13) {
      goto statement_17792;
    }
    jtqout(n1) = 3;
    jomout(n1) = 3;
  statement_17792:;
  }
  if (noutpr == 0 && n3 != 0) {
    write(lunit6,
      "(/,' WARNING : SIMULTANEOUS REQUEST OF PARK',"
      "' DOMAIN CURRENTS AND REAL CURRENTS OF THE',"
      "' POWER WINDINGS OF THIS UM NR.',i3,' IS NOT',/,"
      "' HONORED. THE OUTPUT WILL ONLY DISPLAY THE',' REAL CURRENTS.',/)"),
      num;
  }
  goto statement_17774;
  //C   TREATMENT OF GROUP 3 (MASS SPEEDS) OUTPUT REQUEST :                 M42.4076
statement_17793:
  n2 = 2;
  n3 = 1;
statement_17794:
  if (jtmtac(n1) != -999999) {
    goto statement_17796;
  }
  FEM_DO_SAFE(i, 1, numasu) {
    jumout(i) = 0;
  }
  goto statement_17774;
statement_17796:
  if (nall == 0) {
    goto statement_97797;
  }
  FEM_DO_SAFE(i, 1, numasu) {
    if (jumout(i) == n2) {
      jumout(i) = 3;
    }
    if (jumout(i) == 0) {
      jumout(i) = n3;
    }
  }
  goto statement_17774;
statement_97797:
  FEM_DO_SAFE(i, 1, 12) {
    n15 = ndum(i);
    if (n15 == 0) {
      goto statement_97798;
    }
    if (jumout(n15) == n2) {
      jumout(n15) = 3;
    }
    if (jumout(n15) == 0) {
      jumout(n15) = n3;
    }
  statement_97798:;
  }
  goto statement_17774;
  //C   TREATMENT OF GROUP 4 (TORQUES) OUTPUT REQUEST :                     M42.4096
statement_17798:
  n2 = 1;
  n3 = 2;
  goto statement_17794;
  //C   BLANK CARD ENDING SM-59 OUTPUT REQUEST :                            M42.4100
statement_17799:
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   SM-59 CLASS 5, TERMINATION CARD')"), numum;
  }
  goto statement_17728;
  //C  *************************** READ CLASS 6 SM TYPE-59 DATA             M42.4104
statement_17800:
  nangre = 0;
  nexcsw = 0;
  ntacb = ntotac;
  //C  NANGRE IS FIRST ENTRY OF UMOUTP THAT INDICATES ANGLE TRANSFER        M42.4108
  n19 = 0;
  //C  N19 = 1 IS FLAG FOR TACS CONTROL OF TOTAL APPLIED TORQUE.            M42.4110
  niunrs = ivarb(kiuty + 1);
statement_17810:
  cimage(cmn);
  n17 = 0;
  //C  N17 IS IN READING CLASS 6 RESERVED AS FLAG FOR MODIFIED              M42.4114
  //C    FORMAT OF CODE NUMBERS IF N20 .EQ. 0                               M42.4115
  read(abuff, "(i2,a6,i6)"), n20, bus1, n2;
  if (n20 == 0) {
    n17 = 3 * limasu;
  }
  if (n20 == 0) {
    n20 = n2;
  }
  if (n20 == 0) {
    goto statement_17816;
  }
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   SM-59 CLASS 6, TACS REQUEST')"), numum;
  }
statement_17816:
  if (bus1 != tesm7) {
    goto statement_17820;
  }
  read(abuff, "(2x,2a6)"), bus1, bus2;
  if (bus2 != tesm8) {
    goto statement_17818;
  }
  write(lunit6, format_17053);
  goto statement_9600;
statement_17818:
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   READING COMPLETED')"), numum;
  }
  if (n19 == 0) {
    goto statement_17890;
  }
  goto statement_17900;
  //C  REQUEST FOR TACS CONTROL OF FIELD VOLTAGE :                          M42.4135
statement_17820:
  n4 = 71 + n17;
  if (n20 != n4) {
    goto statement_17830;
  }
  FEM_DO_SAFE(n5, 1, ktab) {
    ndx1 = ivarb(klntab + n5);
    if (bus1 == texvec(ndx1)) {
      goto statement_17827;
    }
  }
  write(lunit6, format_17826), bus1;
  goto statement_9600;
statement_17827:
  tstop(kconex) = 0.0f;
  //C  CREATE TYPE-60 SOURCE :                                              M42.4148
  kconst++;
  iform(kconst) = 60;
  node(kconst) = nexc;
  kode(nexc) = -nexc;
  bus(nexc) = bus1;
  sfreq(kconst) = n5;
  tstart(kconst) = 0.0f;
  tstop(kconst) = fltinf;
  if (iprsup >= 1) {
    write(lunit6,
      "(' *********',' TACS ORIGINATED FIELD VOLT TYPE-60 SOURCE',2x,i4,44x,"
      "i4,e14.5)"),
      node(kconst), kconst, sfreq(kconst);
  }
  write(lunit6,
    "(/,' NOTE: THE EMTP CONNECTIVITY LISTING WILL',"
    "' SHOW ONE OF THE NODES BEARING THE TACS NAME',"
    "' AS USED IN THE LAST READ CARD. NO REASON',/,"
    "' TO GET ALARMED, SINCE THIS NODE IS ONE OF',"
    "' THE AUXILIARY NODES CREATED INTERNALLY BY',' THE U.M. CODE.',/)");
  goto statement_17810;
  //C  REQUEST FOR TRANSFER TO TACS OF EXCITER VOLTAGE :                    M42.4170
statement_17830:
  n4 = 73 + n17;
  if (n20 != n4 && n20 != (n4 + 1) && n20 > (3 * limasu)) {
    goto statement_17870;
  }
  //C     LOAD ADDRESS OF BUS1 INTO TACS ARRAY 'UD1' ***************        M42.4174
  ndy5 = kud1;
  FEM_DO_SAFE(ijk, niunrs, niu) {
    ndx1 = ivarb(kaliu + ijk);
    n1iu = ivarb(kiuty + ijk);
    if (n1iu != 92) {
      goto statement_15481;
    }
    if (bus1 != texvec(ndx1)) {
      goto statement_15481;
    }
    goto statement_15482;
  statement_15481:
    ndy5 += 5;
  }
  cmn.kill = 108;
  lstat(19) = 15481;
  lstat(15) = lbstac;
  lstat(16) = ntotac;
  lstat(14) = n20;
  lstat(17) = -1;
  lstat(13) = 0;
  cmn.bus6 = bus1;
  cmn.jr = 1;
  return;
statement_15482:
  ntotac++;
  sptacs(ndy5 + 2) = ntotac;
  if (ntotac <= lbstac) {
    goto statement_17834;
  }
  write(lunit6,
    "(/,' ERROR STOP.   OVERFLOW LBSTAC DURING',"
    "' EXECUTION OF REQUEST IN UMDATA TO')");
  write(lunit6,
    "(/,' PASS UM VARIABLES TO TACS. THE MACHINE',"
    "' IN QUESTION, UM -,I3, 12H,IS PROVIDED')"),
    numum;
  write(lunit6, "(/,' WITH SM TYPE-59 DATA INPUT.')");
  goto statement_9600;
statement_17834:
  ismtac(ntotac) = n20;
  if (n20 != n4) {
    goto statement_17840;
  }
  n3 = 3 * numasu + nsmtac;
  umoutp(n3 + 1) = -5.0f;
  umoutp(n3 + 2) = nexc;
  umoutp(n3 + 3) = ntotac;
  nsmtac += 3;
  goto statement_17810;
  //C  REQUEST FOR TRANSFER TO TACS OF EXCITER CURRENT :                    M42.4213
statement_17840:
  n4 = 74 + n17;
  if (n20 != n4) {
    goto statement_17850;
  }
  //C    CREATE ADDITIONAL EXCITER NODE TO INSERT SWITCH                    M42.4216
  ntot++;
  kode(ntot) = 0;
  nexcsw = ntot;
  bus(nexcsw) = trash;
  if (numum > 5) {
    goto statement_17842;
  }
  n3 = 41 + (numum - 1) * 4;
  bus(nexcsw) = texta(n3 + 3);
  //C    CREATE SWITCH IN EXCITER CIRCUIT                                   M42.4224
statement_17842:
  kswtch++;
  kswexc = kswtch;
  ndx1 = kswtch + lswtch;
  kmswit(kswtch) = nexcsw;
  kmswit(ndx1) = nexc;
  kswtyp(kswtch) = 0;
  tclose(kswtch) = -1.0f;
  topen(kswtch) = fltinf;
  kpos(kswtch) = 11;
  if (iprsup >= 1) {
    write(lunit6,
      "(' *********',' FIELD CURRENT SENSOR SWITCH',16x,i4,4x,i4,20x,i4,4x,"
      "i4)"),
      kmswit(kswtch), kmswit(ndx1), kswtch, lswtch;
  }
  //C    CONNECT EXCITER SERIES RESISTANCE TO NEW SWITCH NODE               M42.4240
  mbus(ibrexc) = nexcsw;
  n3 = 3 * numasu + nsmtac;
  umoutp(n3 + 1) = -4.0f;
  umoutp(n3 + 2) = kswexc;
  umoutp(n3 + 3) = ntotac;
  nsmtac += 3;
  goto statement_17810;
  //C  TRANSFER TO SOLVUM FOR ANGLE HISTORY CALCULATIONS IF ANGLE           M42.4248
  //C    TRANSFER TO TACS IS REQUESTED :                                    M42.4249
statement_17850:
  if (jtmtac(n1) == -999999) {
    goto statement_17810;
  }
  if (n20 > limasu) {
    goto statement_17858;
  }
  //C  NOTE : IN CASE THAT JUST ONE MASS ANGLE IS REQUESTED TO BE           M42.4252
  //C         PASSED TO TACS, THEN THE ANGLE HISTORY OF ALL MASSES          M42.4253
  //C         NEEDS TO BE TRANSFERED TO SOLVUM.                             M42.4254
  if (nangre != 0) {
    goto statement_17854;
  }
  nangre = nsmtac + 1;
  FEM_DO_SAFE(n5, 1, numasu) {
    n3 = 3 * numasu + nsmtac;
    n4 = nsmtpr + n5;
    umoutp(n3 + 1) = -299;
    umoutp(n3 + 2) = ntotst + n5;
    umoutp(n3 + 3) = 0.0f;
    umoutp(n3 + 4) = umoutp(n4);
    umoutp(n3 + 5) = umoutp(numasu + n4);
    nsmtac += 5;
    if (n5 != 1) {
      goto statement_17852;
    }
    umoutp(n3 + 1) = -300.0f - kswsta;
    umoutp(n3 + 4) = 5.0f * numasu;
    umoutp(n3 + 5) = numasu;
  statement_17852:;
  }
  //C  REQUEST FOR TRANSFER TO TACS OF MASS ANGLES                          M42.4271
statement_17854:
  n3 = 3 * numasu + nangre;
  if (n20 == 1) {
    goto statement_17857;
  }
  n6 = n3 + (n20 - 1) * 5;
  umoutp(n6) = -3.0f;
statement_17857:
  n6 = n3 + 2 + (n20 - 1) * 5;
  umoutp(n6) = ntotac;
  goto statement_17810;
  //C  REQUEST FOR TRANSFER TO TACS OF MASS SPEEDS :                        M42.4280
statement_17858:
  if (jtmtac(n1) == -999999) {
    goto statement_17810;
  }
  n10 = 2 * limasu;
  if (n20 > n10) {
    goto statement_17860;
  }
  n3 = 3 * numasu + nsmtac;
  umoutp(n3 + 1) = -2.0f;
  umoutp(n3 + 2) = ntotst + n20 - limasu;
  umoutp(n3 + 3) = ntotac;
  nsmtac += 3;
  goto statement_17810;
  //C  REQUEST FOR TRANSFER TO TACS OF SHAFT TORQUES :                      M42.4290
statement_17860:
  if (jtmtac(n1) == -999999) {
    goto statement_17810;
  }
  n10 = 3 * limasu;
  if (n20 > n10) {
    goto statement_17870;
  }
  n3 = 3 * limasu + nsmtac;
  umoutp(n3 + 1) = -1.0f;
  umoutp(n3 + 2) = kswsta + n20 - 2 * limasu;
  umoutp(n3 + 3) = ntotac;
  nsmtac += 3;
  goto statement_17810;
  //C  SET TYPE-14 AND 18 FOR ELECTROMECH. EXCITER TORQUE FROM TACS:        M42.4300
statement_17870:
  n4 = 80 + n17;
  if (n20 != n4) {
    goto statement_17880;
  }
  write(lunit6,
    "(/,' NOTE : THIS TACS INTERFACE REQUEST REGARDING',"
    "' THE EXCITER TORQUE FOR UM NUMBER',i4,"
    "',  IS NO LONGER IN EFFECT. THE INFLUENCE OF',/,"
    "' THE EXCITER TORQUE WILL BE AUTOMATICALLY',"
    "' INCLUDED IN EXACTLY THE SAME WAY AS WITH',' THE SM TYPE-59 CODE.',/)"),
    numum;
  goto statement_17810;
  //C  REQUEST FOR TACS CONTROL OF TOTAL APPLIED TORQUE :                   M42.4311
statement_17880:
  if (jtmtac(n1) == -999999) {
    goto statement_17810;
  }
  n4 = 72 + n17;
  if (n20 != n4) {
    goto statement_17810;
  }
  n19 = 1;
  FEM_DO_SAFE(n10, 1, ktab) {
    ndx1 = ivarb(klntab + n10);
    if (bus1 == texvec(ndx1)) {
      goto statement_17890;
    }
  }
  write(lunit6, format_17826), bus1;
  goto statement_9600;
  //C  SET TYPE-14 SOURCES FOR APPLIED TORQUES :                            M42.4322
statement_17890:
  if (jtmtac(n1) == -999999) {
    goto statement_17899;
  }
  FEM_DO_SAFE(n5, 1, ntorq) {
    if (n19 != 1) {
      goto statement_17894;
    }
    kconst++;
    sfreq(kconst) = n10;
    iform(kconst) = 17;
    node(kconst) = -1;
    tstart(kconst) = -1.0f;
    tstop(kconst) = fltinf;
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' TYPE-17 SOURCE FOR NEXT TACS CONTROL',7x,i4,44x,i4,"
        "e14.5)"),
        node(kconst), kconst, sfreq(kconst);
    }
  statement_17894:
    kconst++;
    if (n5 == 1) {
      nodmum(n1) = kconst;
    }
    iform(kconst) = 14;
    n6 = kumout(n5);
    if (n6 == nmgen) {
      n6 = ntotst + 2 * numasu;
    }
    node(kconst) = -n6;
    kode(n6) = 0;
    n4 = nsmtpr + n5;
    crest(kconst) = umoutp(n4);
    umoutp(n4) = 0.0f;
    tstart(kconst) = -7777.0f;
    tstop(kconst) = fltinf;
    sfreq(kconst) = 0.00001f;
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' APPLIED TORQUE SOURCE',22x,i4,44x,i4,e14.5)"),
        node(kconst), kconst, sfreq(kconst);
    }
  }
statement_17899:
  if (n19 == 0) {
    goto statement_17900;
  }
  goto statement_17810;
  //C ********************* FINISH STATEMENTS OF SM TYPE-59 DATA            M42.4357
statement_17900:
  ncltot += 7;
  if (ncltot <= cmn.nclfix) {
    goto statement_17905;
  }
  write(lunit6,
    "(/,' OVERFLOW OF U.M. COIL TABLE,',' NCLTOT = ',i5,' INCREASE',"
    "' NCLFIX ON UM DIMENSION CARD.')"),
    ncltot;
  goto statement_9600;
statement_17905:
  FEM_DO_SAFE(n5, 1, numasu) {
    kumout(n5) = 0;
    jumout(n5) = 0;
  }
  mjm = ncltot - 6;
  FEM_DO_SAFE(nk, mjm, ncltot) {
    jcltac(nk) = 0;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' *********',' CREATED NODES FOR MECHANICAL SYSTEM :',"
      "' FIRST NODE NR = NTOTST+1, LAST NODE NR =',"
      "' NTOTST + 2*NUMASU + NRSYN .',/,30x,'NTOTST',2x,'NUMASU',2x,' NRSYN',"
      "2x,' NMGEN',2x,' NMEXC',/,32x,i4,4x,i4,4x,i4,4x,i4,4x,i4)"),
      ntotst, numasu, nrsyn, nmgen, nmexc;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' *********',' CREATED NODES FOR FIELD CIRCUIT :',' NEXC = ',i4,10x,"
      "'NEXCSW = ',i4)"),
      nexc, nexcsw;
  }
  //C  SHIFTING UMOUTP ENTRIES WITH 3*NUMASU TO BEHIND NSMTPR :             M42.4383
  n6 = nsmtac - nsmtpr;
  n7 = nsmtpr + n6;
  FEM_DO_SAFE(n5, 1, n6) {
    n3 = nsmtpr + n5;
    n4 = n3 + 3 * numasu;
    umoutp(n3) = umoutp(n4);
    if (n4 > n7) {
      umoutp(n4) = 0.0f;
    }
  }
  if (nparum != 0) {
    goto statement_17951;
  }
  if (iprsup < 3) {
    goto statement_17958;
  }
statement_17951:
  write(lunit6,
    "(/,' PARAMETERS OF UM NR.',i4,':',10x,'LMUD',10x,'LMSD',10x,'LMUQ',10x,"
    "'LMSQ',9x,'FLXSD',9x,'FLXSQ',/,26x,6e14.5)"),
    n1, reamdu(n1), reamds(n1), reamqu(n1), reamqs(n1), flxds(n1),
    flxqs(n1);
  write(lunit6, "(/,' COIL     RESISTANCE    LEAKAGE INDUCTANCE')");
  n6 = ncltot - 6;
  FEM_DO_SAFE(n5, n6, ncltot) {
    if (gpar(n5) == 0.0f) {
      write(lunit6, "(1x,i4,10x,' DUMMY COIL')"), n5;
    }
    if (gpar(n5) == 0.0f) {
      goto statement_17957;
    }
    write(lunit6, "(1x,i4,2x,2e14.5)"), n5, gpar(n5), reacl(n5);
    if (n5 == ncltot) {
      write(lunit6, "(/,' ')");
    }
  statement_17957:;
  }
  //C  SET 0.5*RF FOR INTERNAL FIELD RESISTANCE :                           M42.4411
statement_17958:
  gpar(ncltot - 3) = 0.5f * gpar(ncltot - 3);
  n5 = nsmtac + 3 * numasu;
  if (n5 <= cmn.iotfix) {
    goto statement_17970;
  }
  write(lunit6,
    "(/,' OVERFLOW OF UM OUTPUT TABLE, INCREASE',"
    "' IN CARD FOR ABSOLUTE UM DIMENSIONS',/,' VALUE OF IOTFIX.',/,"
    "' REMARK : IF SM TYPE-59 DATA INPUT IS',' INCLUDED, THEN IOTFIX IS ALSO',"
    "/,' RELATED TO OUTPUTS OF MECH. SYSTEMS',"
    "' IN ALL SM TYPE-59 DATA MACHINES.')");
  goto statement_9600;
statement_17970:
  cmn.jf = 1;
  return;
  //C  END READING SM TYPE-59 DATA INPUT $$$$$$$$$$$$$$$$$$$$$$$$$$         M42.4426
statement_9600:
  stoptp(cmn);
}


struct umdata_save
{
  fem::str<8> tesm1;
  fem::str<8> tesm2;
  fem::str<8> tesm3;
  fem::str<8> tesm4;
  fem::str<8> tesm5;
  fem::str<8> tesm6;
  fem::str<8> tesm7;
  fem::str<8> tesm8;
  fem::str<8> tesm9;
  fem::str<8> textm;

  umdata_save() :
    tesm1(fem::char0),
    tesm2(fem::char0),
    tesm3(fem::char0),
    tesm4(fem::char0),
    tesm5(fem::char0),
    tesm6(fem::char0),
    tesm7(fem::char0),
    tesm8(fem::char0),
    tesm9(fem::char0),
    textm(fem::char0)
  {}
};

void
umdata(
  common& cmn,
  arr_ref<double> reacl,
  arr_ref<double> gpar,
  arr_ref<double> fpar,
  arr_ref<double> hist,
  arr_ref<double> umcurp,
  arr_ref<int> nodvo1,
  arr_ref<int> nodvo2,
  arr_ref<int> jcltac,
  arr_ref<int> jclout,
  arr_ref<int> jtype,
  arr_ref<int> nodom,
  arr_ref<int> jtmtac,
  arr_cref<double> /* histom */,
  arr_ref<double> omegm,
  arr_ref<double> omold,
  arr_ref<double> thetam,
  arr_ref<double> reamdu,
  arr_ref<double> reamds,
  arr_ref<double> flxds,
  arr_ref<double> flxdr,
  arr_ref<double> reamqu,
  arr_ref<double> flxqs,
  arr_ref<double> flxqr,
  arr_ref<int> jcdsat,
  arr_ref<int> jcqsat,
  arr_ref<double> flxd,
  arr_ref<double> flxq,
  arr_ref<int> nppair,
  arr_ref<double> rotmom,
  arr_ref<int> ncld,
  arr_ref<int> nclq,
  arr_ref<int> jtqout,
  arr_ref<int> jomout,
  arr_ref<int> jthout,
  arr_ref<double> reamqs,
  arr_ref<double> epsom,
  arr_ref<double> dcoef,
  arr_ref<int> kcoil,
  arr_ref<double> voltum,
  arr_ref<double> anglum,
  arr_ref<int> nodfum,
  arr_ref<int> nodmum,
  arr_ref<int> kumout,
  arr_ref<int> jumout,
  arr_ref<double> umoutp)
{
  FEM_CMN_SVE(umdata);
  reacl(dimension(1));
  gpar(dimension(1));
  fpar(dimension(1));
  hist(dimension(1));
  umcurp(dimension(1));
  nodvo1(dimension(1));
  nodvo2(dimension(1));
  jcltac(dimension(1));
  jclout(dimension(1));
  jtype(dimension(1));
  nodom(dimension(1));
  jtmtac(dimension(1));
  omegm(dimension(1));
  omold(dimension(1));
  thetam(dimension(1));
  reamdu(dimension(1));
  reamds(dimension(1));
  flxds(dimension(1));
  flxdr(dimension(1));
  reamqu(dimension(1));
  flxqs(dimension(1));
  flxqr(dimension(1));
  jcdsat(dimension(1));
  jcqsat(dimension(1));
  flxd(dimension(1));
  flxq(dimension(1));
  nppair(dimension(1));
  rotmom(dimension(1));
  ncld(dimension(1));
  nclq(dimension(1));
  jtqout(dimension(1));
  jomout(dimension(1));
  jthout(dimension(1));
  reamqs(dimension(1));
  epsom(dimension(1));
  dcoef(dimension(1));
  kcoil(dimension(1));
  voltum(dimension(1));
  anglum(dimension(1));
  nodfum(dimension(1));
  nodmum(dimension(1));
  kumout(dimension(1));
  jumout(dimension(1));
  umoutp(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  auto& texta = cmn.texta;
  double& d1 = cmn.d1;
  double& d2 = cmn.d2;
  double& d3 = cmn.d3;
  double& distrf = cmn.distrf;
  int& n5 = cmn.n5;
  int& n6 = cmn.n6;
  int& n7 = cmn.n7;
  int& n8 = cmn.n8;
  int& n10 = cmn.n10;
  int& n11 = cmn.n11;
  int& n12 = cmn.n12;
  int& n20 = cmn.n20;
  int& jr = cmn.jr;
  int& jf = cmn.jf;
  int& nsmtac = cmn.nsmtac;
  int& limasu = cmn.limasu;
  int& nshare = cmn.nshare;
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& bus6 = cmn.bus6;
  fem::str<8>& trash = cmn.trash;
  fem::str<8>& blank = cmn.blank;
  const auto& abuff = cmn.abuff;
  auto& twopi = cmn.twopi;
  double& xopt = cmn.xopt;
  double& statfr = cmn.statfr;
  int& istep = cmn.istep;
  int& noutpr = cmn.noutpr;
  int& ktab = cmn.ktab;
  int& numum = cmn.numum;
  int& numout = cmn.numout;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& it = cmn.it;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  auto& loopss = cmn.loopss;
  auto& sptacs = cmn.sptacs;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  const auto& texvec = cmn.texvec;
  auto& tstop = cmn.tstop;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  auto& iform = cmn.iform;
  auto& node = cmn.node;
  auto& crest = cmn.crest;
  auto& time1 = cmn.time1;
  auto& tstart = cmn.tstart;
  auto& sfreq = cmn.sfreq;
  auto& kode = cmn.kode;
  auto& bus = cmn.bus;
  auto& busum = cmn.busum;
  auto& pi = cmn.pi;
  int& numbus = cmn.numbus;
  int& ncltot = cmn.ncltot;
  int& initum = cmn.initum;
  int& nclfix = cmn.nclfix;
  int& numfix = cmn.numfix;
  int& nsmach = cmn.nsmach;
  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;
  //
  fem::str<8>& tesm1 = sve.tesm1;
  fem::str<8>& tesm9 = sve.tesm9;
  fem::str<8>& textm = sve.textm;
  if (is_called_first_time) {
    texta(1) = "UM-1  ";
    texta(2) = "UM-2  ";
    texta(3) = "UM-3  ";
    texta(4) = "UM-4  ";
    texta(5) = "UM-5  ";
    texta(6) = "UM-6  ";
    texta(7) = "UM-7  ";
    texta(8) = "UM-8  ";
    texta(9) = "UM-9  ";
    texta(10) = "UM-10 ";
    texta(11) = "UM-11 ";
    texta(12) = "UM-12 ";
    texta(13) = "UM-13 ";
    texta(14) = "UM-14 ";
    texta(15) = "UM-15 ";
    texta(16) = "UM-16 ";
    texta(17) = "UM-17 ";
    texta(18) = "UM-18 ";
    texta(19) = "UM-19 ";
    texta(20) = "UM-20 ";
    texta(21) = "TQGEN ";
    texta(22) = "OMEGM ";
    texta(23) = "THETAM";
    texta(24) = "IPA   ";
    texta(25) = "IPB   ";
    texta(26) = "IPC   ";
    texta(27) = "IE1   ";
    texta(28) = "IE2   ";
    texta(29) = "IE3   ";
    texta(30) = "IE4   ";
    texta(31) = "IE5   ";
    texta(32) = "IE6   ";
    texta(33) = "IE7   ";
    texta(34) = "IE8   ";
    texta(35) = "IE9   ";
    texta(36) = "IE10  ";
    texta(37) = "IE11  ";
    texta(38) = "IE12  ";
    texta(39) = "IE13  ";
    texta(40) = "IE14  ";
    texta(41) = "UM1MXX";
    texta(42) = "UM1E1X";
    texta(43) = "UM1E2X";
    texta(44) = "UM1E3X";
    texta(45) = "UM2MXX";
    texta(46) = "UM2E1X";
    texta(47) = "UM2E2X";
    texta(48) = "UM2E3X";
    texta(49) = "UM3MXX";
    texta(50) = "UM3E1X";
    texta(51) = "UM3E2X";
    texta(52) = "UM3E3X";
    texta(53) = "UM4MXX";
    texta(54) = "UM4E1X";
    texta(55) = "UM4E2X";
    texta(56) = "UM4E3X";
    texta(57) = "UM5MXX";
    texta(58) = "UM5E1X";
    texta(59) = "UM5E2X";
    texta(60) = "UM5E3X";
    texta(61) = "UM1NTR";
    texta(62) = "UM2NTR";
    texta(63) = "UM3NTR";
    texta(64) = "UM4NTR";
    texta(65) = "UM5NTR";
    texta(66) = "UM1MS1";
    texta(67) = "UM2MS1";
    texta(68) = "UM3MS1";
    texta(69) = "UM4MS1";
    texta(70) = "UM5MS1";
    texta(71) = "UM1MS2";
    texta(72) = "UM2MS2";
    texta(73) = "UM3MS2";
    texta(74) = "UM4MS2";
    texta(75) = "UM5MS2";
    texta(76) = "UM1TLA";
    texta(77) = "UM1TLB";
    texta(78) = "UM1TLC";
    texta(79) = "UM2TLA";
    texta(80) = "UM2TLB";
    texta(81) = "UM2TLC";
    texta(82) = "UM3TLA";
    texta(83) = "UM3TLB";
    texta(84) = "UM3TLC";
    texta(85) = "UM4TLA";
    texta(86) = "UM4TLB";
    texta(87) = "UM4TLC";
    texta(88) = "UM5TLA";
    texta(89) = "UM5TLB";
    texta(90) = "UM5TLC";
    texta(91) = "FLUXMD";
    texta(92) = "IMD   ";
    texta(93) = "FLUXMQ";
    texta(94) = "IMQ   ";
    texta(95) = "IP0   ";
    texta(96) = "IPD   ";
    texta(97) = "IPQ   ";
    texta(98) = "TQEXC ";
    texta(99) = "UM1MCC";
    texta(100) = "UM2MCC";
    texta(101) = "UM3MCC";
    textm = "MORE  ";
    tesm1 = "SMDATA";
    sve.tesm2 = "TOLERA";
    sve.tesm3 = "PARAME";
    sve.tesm4 = "ALL   ";
    sve.tesm5 = "NONE  ";
    sve.tesm6 = "EXTEND";
    sve.tesm7 = "FINISH";
    sve.tesm8 = " PART ";
    tesm9 = "SHARE ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int kxtcs = fem::int0;
  int klntab = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int n3 = fem::int0;
  fem::str<8> text3 = fem::char0;
  fem::str<8> text4 = fem::char0;
  fem::str<8> text5 = fem::char0;
  int j = fem::int0;
  int ndx1 = fem::int0;
  int n13 = fem::int0;
  double d10 = fem::double0;
  int ncldq = fem::int0;
  int ntacb = fem::int0;
  int numoui = fem::int0;
  double rppair = fem::double0;
  int kcl = fem::int0;
  int n4 = fem::int0;

  static const char* format_1207 = "(13a6,a2)";
  static const char* format_13206 =
    "(/,' ERROR STOP.  JUST-READ COIL CARD',' BEARS ILLEGAL NODE NAME:',a6)";
  static const char* format_13207 =
    "(/,' ERROR STOP.   THE TACS NAME  \"BUS4\"',' ON THE LAST-READ CARD IS',"
    "/,' UNRECOGNIZED.   BUS4=',a6)";
  static const char* format_14203 = "(2e14.5,i1,3e14.5)";
  static const char* format_30 =
    "(/,' UM ERROR STOP. YOU HAVE REQUESTED ANOTHER UM',"
    "' TO BE INCLUDED TO THIS DATA CASE. THE RULES',"
    "' REGARDING THE ORDERING OF UM')";
  static const char* format_31 =
    "(' DATA CARDS HAVE HOWEVER BEEN VIOLATED.',"
    "' THE DATA CARDS OF THIS UM SHOULD BE PLACED',"
    "' IMMEDIATELY BEHIND THOSE OF THE',/,"
    "' PREVIOUS UM IN ACCORDANCE WITH THE',' FOLLOWING RULES :')";
  static const char* format_32 =
    "(/,' (1). THE DATA CARDS OF THE NEXT UM HAVE TO',"
    "' FOLLOW IMMEDIATELY THOSE OF THE PREVIOUS UM',"
    "' WITHOUT THE INSERTION OF')";
  static const char* format_3206 =
    "(/,' ERROR STOP.  JUST-READ COIL CARD',' BEARS ILLEGAL NODE NAME:',a6)";
  static const char* format_3207 =
    "(/,' ERROR STOP.   THE TACS NAME  \"BUS4\"',' ON THE LAST-READ CARD IS',"
    "' UNRECOGNIZED.   BUS4=',a6)";
  static const char* format_33 =
    "(' A BLANK CARD AND WITHOUT REPEATED',"
    "' INSERTION OF THE CLASS-1 UM DATA CARDS.',"
    "'  THESE CLASS-1 CARDS, CONSISTING OF TWO')";
  static const char* format_34 =
    "(' CARDS AND A BLANK TERMINATION CARD,',"
    "' CONTAINS INITIAL INFORMATION REGARDING THE',"
    "' READING OF ALL UM CARDS TO FOLLOW. IT IS')";
  static const char* format_35 =
    "(' THEREFORE TO BE PLACED ON TOP AND NEVER TO',"
    "' BE REPEATED BETWEEN THE CARDS OF THE',' DIFFERENT UM''S.')";
  static const char* format_36 =
    "(/,' (2). THE DATA CARDS OF THE LAST UM TO BE',"
    "' INCLUDED TO THIS DATA CASE IS TO BE',"
    "' TERMINATED WITH A BLANK CARD, INDICATING',/,"
    "' THE ENDING OF ALL UM DATA CARDS.')";
  static const char* format_4203 = "(2e14.5,i1,3e14.5)";
  static const char* format_6198 =
    "(/,' ERROR STOP. INCORRECT UM DATA INPUT. THE',"
    "' RESULT IS THAT THE Q-AXIS MAIN INDUCTANCE',/,7x,"
    "' IS EITHER ZERO OR NEGATIVE FOR MACHINE',' NUMBER',i4,'.')";
  static const char* format_80502 =
    "(/,' ERROR STOP. YOU HAVE REQUESTED THE UM TO',"
    "' BE INITIALIZED THROUGH A LOAD-FLOW PROCESS.',"
    "' YOU HAVE HOWEVER FAILED TO SET UP THE UM',/,"
    "' DATA INPUT FOR AUTOMATIC STEADY-STATE',"
    "' INITIALIZATION. CONSULT THE EMTP RULE BOOK',"
    "' REGARDING THIS USAGE OF THE UM.')";
  static const char* format_90202 =
    "(' THIS UM -',i3,' IS REQUESTED TO SHARE ITS',"
    "' MECHANICAL NETWORK WITH OTHER UM''S.  THE',"
    "' SPECIFICATION OF ALL APPLIED TORQUES IN THIS',/,"
    "' MECH NETWORK SHOULD HAVE BEEN PLACED WITH',"
    "' THE DATA INPUT FOR THE LOWEST-NUMBERED UM OF',"
    "' THE SET OF UM''S SHARING THIS MECH NETWORK.')";
  //C!w n1, n2, n3, n4 changed to nz1, nz2, nz3, nz4
  //C. DATA INITIALIZATION:                                                 M28.3938
  //C     BE CAREFUL WITH FPAR(KCL) AND UMCURP(KCL). IN UMDATA AND          M36. 336
  //C      AND IN UMRENU THEY ARE USED DIFFERENTLY THAN IN SOLVUM.          M36. 337
  //C     FPAR(KCL) IN UMDATA AND UMRENU : ADRESS IBR OF LEAKAGE IND        M37.2462
  //C     FPAR(KCL+1) IN UMDATA AND UMRENU : ADRESS KCONST OF EXCIT         M37.2463
  //C       SOURCES TO REPRESENT IM EXCIT COILS (UMDATA CREATION)           M37.2464
  //C     UMCURP IN UMDATA AND UMRENU : USED TO STORE SHIFT IN POWER        M37.2465
  //C      NODES IF LOAD-FLOW IS REQUESTED. THEN AFTER LOAD-FLOW IS         M37.2466
  //C      IS COMPLETED, THESE SAME CELLS OF UMCURP ARE USED AS             M37.2467
  //C      POINTERS FOR THE SHIFT OF POWER RESISTANCES TO NETWORK.          M37.2468
  //C   IF MECH NETWORK OPTION IS USED, ROTMOM IS USED TO STORE             M37.2469
  //C      FREQUENCY OF NETWORK CONNECTED TO POWER COIL. INITIALI -         M37.2470
  //C      ZATION IS IN UMRENU, EXCEPT IF SM TYPE-59 IS USED.               M37.2471
  kxtcs = sptacs(17);
  klntab = sptacs(18);
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE UMDATA.\"')");
  }
  if (numum == 0) {
    goto statement_40;
  }
  write(lunit6, format_30);
  write(lunit6, format_31);
  write(lunit6, format_32);
  write(lunit6, format_33);
  write(lunit6, format_34);
  write(lunit6, format_35);
  write(lunit6, format_36);
  goto statement_9600;
  //C. BUSUM ADJUSTMENT DUE TO VARIABLE NUMFIX :                            M28.3955
statement_40:
  FEM_DO_SAFE(n1, 1, numfix) {
    busum(n1) = texta(n1);
  }
  FEM_DO_SAFE(n1, 1, 28) {
    n2 = n1 + numfix;
    n3 = n1 + 12;
    if (n1 > 11) {
      goto statement_50;
    }
    n3 = n1 + 87;
    if (n1 > 3) {
      goto statement_50;
    }
    n3 = n1 + 20;
  statement_50:
    busum(n2) = texta(n3);
  }
  //pi = twopi * cmn.onehaf;
  d2 = 2.0f;
  d3 = 3.0f;
  cmn.sroot2 = sqrtz(d2);
  cmn.sroot3 = sqrtz(d3);
  cmn.omegrf = twopi * statfr;
  //C  START READING UM DATA ***************************************        M32.1547
  //C    NOTE : THE FOLLOWING VARIABLE NAMES ARE RESERVED FOR               M32.1548
  //C           LOOPING DURING READING OF THE DATA INPUT :                  M32.1549
  numum = 0;
  ncltot = 0;
  nsmtac = 0;
  nsmach = 0;
  //C   NSMTAC IS THE TOTAL NUMBER OF ADDITIONAL ENTRIES TO                 M32.1553
  //C    UMOUTP(NUMOUT) BECAUSE OF SM TACS TRANSFER.                        M32.1554
  n1 = 0;
  //C.USER1 : GENERAL SPECIFICATIONS (CLASS 1 UM DATA CARDS)                M36. 349
  //C     READ INPUT CARD USING CIMAGE                                      M28.3967
  cimage(cmn);
  read(abuff, "(2i1,a6,i6,i1)"), cmn.inpu, initum, bus3, limasu, loopss(8);
  if (bus3 == tesm1) {
    initum = 1;
  }
  if (limasu == 0) {
    limasu = 10;
  }
  if (loopss(8) == 0) {
    goto statement_105;
  }
  if (noutpr == 0) {
    write(kunit6, "('+UM POWER COIL INTERFACING BY PREDICTION')");
  }
  goto statement_150;
statement_105:
  if (noutpr == 0) {
    write(kunit6, "('+UM FULLY COMPENSATED')");
  }
  //C     READ(LUNIT5,203) JTYPE(N1),NCLD(N1),NCLQ(N1),JTQOUT(N1),          M28.3978
  //C    VJOMOUT(N1),JTHOUT(N1),BUM3(N1),BUM4(N1),NPPAIR(N1),               M28.3979
  //C    VROTMOM(N1),DCOEF(N1),EPSOM(N1),OMEGM(N1),REAMDU(N1),              M28.3980
  //C    VJCDSAT(N1),REAMDS(N1),FLXDS(N1),FLXDR(N1),THETAM(N1),             M28.3981
  //C    VREAMQU(N1),JCQSAT(N1),REAMQS(N1),FLXQS(N1),FLXQR(N1),NOREAD       M28.3982
  //C  DECISION ON M31 OR M32 DATA INPUT ***************************        M32.1567
  //C    WITH M32 , THE INPUT IS MODULAR.                                   M32.1568
statement_150:
  cimage(cmn);
  read(abuff, format_1207), text3, text4, text5;
  if (text3 != blank) {
    goto statement_3202;
  }
  if (text4 != blank) {
    goto statement_3202;
  }
  if (text5 != blank) {
    goto statement_3202;
  }
  if (noutpr == 0) {
    write(kunit6, "('+BLANK CARD ENDING CLASS-1 UM DATA CARDS')");
  }
  goto statement_11202;
  //C  DATA INPUT FOR M31 AND OLDER VERSIONS ***********************        M32.1577
  //C. USER2 : MACH-TABLE INPUT FOR M31 AND OLDER                           M32.1578
  //C     READ INPUT CARD USING CIMAGE                                      M28.3985
statement_1202:
  cimage(cmn);
statement_1203:
  n6 = 0;
  read(abuff, format_1207), text3, text4, text5;
  if (text3 != blank) {
    goto statement_3202;
  }
  if (text4 != blank) {
    goto statement_3202;
  }
  if (text5 != blank) {
    goto statement_3202;
  }
  if (noutpr == 0) {
    write(kunit6, "('+BLANK CARD ENDING MACHINE TABLE.')");
  }
  goto statement_300;
statement_3202:
  numum++;
  if (iprsup >= 1) {
    write(lunit6, "('0THE MACHINE-TABLE INPUT OF UM NUMBER',i3,':')"), numum;
  }
  if (numum <= numfix) {
    goto statement_5202;
  }
  write(lunit6,
    "(/,' OVERFLOW U.M. MACHINE TABLE IN MODULE \"UMDATA\".  CURRENT CASE HAS'"
    ",2x,i4,2x,'U.M.,  NUMFIX ON THE CARD FOR ABSOLUTE UM DIMENSIONS',/,"
    "' MUST BE SET TO NO LESS THAN',2x,i4,'.')"),
    numum;
  goto statement_9600;
statement_5202:
  n1 = numum;
  read(abuff, "(3i2,3i1,2a6,i2,3e14.5)"), jtype(n1), ncld(n1),
    nclq(n1), jtqout(n1), jomout(n1), jthout(n1), bus3, bus4, nppair(n1),
    rotmom(n1), dcoef(n1), epsom(n1);
  if (noutpr == 0) {
    write(kunit6, "('+MACH-TABLE CARD   1.',3i5)"), jtype(n1), ncld(n1),
      nclq(n1);
  }
  FEM_DO_SAFE(n10, 1, ntot) {
    if (bus3 == blank) {
      goto statement_205;
    }
    if (bus3 != bus(n10)) {
      goto statement_204;
    }
    nodom(n1) = n10;
    rotmom(n1) = twopi * statfr;
    goto statement_205;
  statement_204:;
  }
  write(lunit6,
    "(/,' ERROR STOP.   THE NODE NAME  \"BUS3\"',"
    "' ON THE LAST-READ CARD IS NOT THAT',/,' OF ANY ELECTRIC NETWORK NODE.',"
    "' BUS3=',a6)"),
    bus3;
  goto statement_9600;
statement_205:
  jtmtac(n1) = 0;
  if (bus3 != blank) {
    goto statement_213;
  }
  FEM_DO_SAFE(j, 1, ktab) {
    ndx1 = ivarb(klntab + j);
    if (bus4 == texvec(ndx1)) {
      goto statement_209;
    }
  }
  if (bus4 == blank) {
    goto statement_213;
  }
  write(lunit6, format_3207), bus4;
  goto statement_9600;
statement_209:
  ndx1 = kxtcs + j;
  jtmtac(n1) = ndx1;
  //C     READ INPUT CARD USING CIMAGE                                      M28.4031
statement_213:
  cimage(cmn);
  read(abuff, format_4203), omegm(n1), reamdu(n1), jcdsat(n1),
    reamds(n1), flxds(n1), flxdr(n1);
  if (noutpr == 0) {
    write(kunit6, "('+MACH-TABLE CARD   2.',2e12.4)"), omegm(n1), reamdu(n1);
  }
  //C     READ INPUT CARD USING CIMAGE                                      M28.4039
  cimage(cmn);
  read(abuff, format_4203), thetam(n1), reamqu(n1), jcqsat(n1),
    reamqs(n1), flxqs(n1), flxqr(n1);
  if (reamqu(n1) > 0.0f) {
    goto statement_6199;
  }
  write(lunit6, format_6198), n1;
  goto statement_9600;
statement_6199:
  if (noutpr == 0) {
    write(kunit6, "('+MACH-TABLE CARD   3.',2e12.4)"), thetam(n1), reamqu(n1);
  }
  if (iprsup >= 1) {
    write(lunit6,
      "('0',3i2,3i1,2a6,i2,3e14.5,/,' ',2e14.5,i1,3e14.5,/,' ',2e14.5,i1,"
      "3e14.5)"),
      jtype(n1), ncld(n1), nclq(n1), jtqout(n1), jomout(n1), jthout(n1),
      bus3, bus4, nppair(n1), rotmom(n1), dcoef(n1), epsom(n1), omegm(n1),
      reamdu(n1), jcdsat(n1), reamds(n1), flxds(n1), flxdr(n1), thetam(n1),
      reamqu(n1), jcqsat(n1), reamqs(n1), flxqs(n1), flxqr(n1);
  }
  if (initum == 0) {
    goto statement_249;
  }
  cimage(cmn);
  d1 = 1.0e+3f;
  n5 = 4;
  n6 = 0;
  read(abuff, "(2e14.5,2a6,e14.5)"), voltum(n1), anglum(n1), bus5,
    bus6, distrf;
  if (noutpr == 0) {
    write(kunit6, "('+MACH-TABLE CARD   4.',2e12.4)"), voltum(n1), anglum(n1);
  }
  if (jtype(n1) == 3) {
    goto statement_230;
  }
  if (jtype(n1) == 4) {
    goto statement_230;
  }
  if (jtype(n1) == 5) {
    goto statement_230;
  }
  FEM_DO_SAFE(n10, 1, ntot) {
    if (bus5 != bus(n10)) {
      goto statement_220;
    }
    nodfum(n1) = n10;
    FEM_DO_SAFE(n11, 1, kconst) {
      n12 = node(n11);
      if (n12 < 0) {
        n12 = -n12;
      }
      if (nodfum(n1) != n12) {
        goto statement_219;
      }
      nodfum(n1) = n11;
      goto statement_230;
    statement_219:;
    }
  statement_220:;
  }
  write(lunit6,
    "(/,' ERROR STOP.   THE NODE NAME  \"BUSF\"',"
    "' ON THE LAST-READ CARD IS NOT THAT',/,"
    "' OF ANY ELECTRIC NETWORK SOURCE NODE.',' BUSF=',a6)"),
    bus5;
  goto statement_9600;
statement_230:
  FEM_DO_SAFE(n10, 1, ntot) {
    if (bus6 != bus(n10)) {
      goto statement_233;
    }
    FEM_DO_SAFE(n11, 1, kconst) {
      n12 = node(n11);
      if (n12 < 0) {
        n12 = -n12;
      }
      if (n10 != n12) {
        goto statement_232;
      }
      crest(n11) = d1 * distrf;
      if (n6 != 0) {
        goto statement_231;
      }
      nodmum(n1) = n11;
      if (distrf == 0.0f) {
        crest(n11) = d1;
      }
    statement_231:
      tstart(n11) = -7777.f;
      goto statement_240;
    statement_232:;
    }
  statement_233:;
  }
  write(lunit6,
    "(/,' ERROR STOP.   THE NODE NAME  \"BUSM\"',"
    "' ON THE LAST-READ CARD IS NOT THAT',/,"
    "' OF ANY ELECTRIC NETWORK SOURCE NODE.',' BUSM=',a6)"),
    bus6;
  goto statement_9600;
statement_240:
  cimage(cmn);
  read(abuff, "(a6)"), text3;
  if (text3 != textm) {
    goto statement_248;
  }
  n5++;
  n6 = 1;
  read(abuff, "(a6,28x,a6,e14.5)"), text3, bus6, distrf;
  if (noutpr == 0) {
    write(kunit6, "('+MACH-TABLE CARD',i4,'.',e12.4)"), n5, distrf;
  }
  goto statement_230;
statement_248:
  goto statement_1203;
statement_249:
  goto statement_1202;
  //C. IF FLUX OUTPUT IS DESIRED :                                          M28.4055
  //C. USER3 : COIL-TABLE INPUT FOR M31 AND OLDER                           M32.1623
statement_300:
  if (iprsup >= 1) {
    write(lunit6, "('0THE COIL-TABLE INPUT:',/,1x)");
  }
  //C. AVOID CONFLICT BLANK TERMINATION CARD WITH DUMMY COIL                M28.4063
  //C. AND ADJUSTMENT OF NCLD AND NCLQ FOR UM TYPE 4 :                      M28.4064
  n5 = 0;
  FEM_DO_SAFE(n10, 1, numum) {
    if (jtype(n10) != 4) {
      goto statement_302;
    }
    n5++;
    ncld(n10) = 1;
    nclq(n10) = 1;
  statement_302:
    n5 += ncld(n10) + nclq(n10);
  }
  n5 += 3 * numum;
  //C     READ(LUNIT5,303) GPAR(N1),REACL(N1),BUM1(N1),BUM2(N1),            M28.4073
  //C    VBUM6(N1),JCLOUT(N1),HIST(N1),NOREAD                               M28.4074
  //C     READ INPUT CARD USING CIMAGE                                      M28.4076
statement_3302:
  cimage(cmn);
  read(abuff, format_1207), text3, text4, text5;
  if (text3 != blank) {
    goto statement_4303;
  }
  if (text4 != blank) {
    goto statement_4303;
  }
  if (text5 != blank) {
    goto statement_4303;
  }
  if (ncltot < n5) {
    goto statement_4303;
  }
  if (noutpr == 0) {
    write(kunit6, "('+BLANK CARD ENDING COIL TABLE.')");
  }
  goto statement_500;
statement_4303:
  ncltot++;
  fpar(ncltot) = 0.0f;
  if (ncltot <= nclfix) {
    goto statement_6302;
  }
  write(lunit6, "(/,' OVERFLOW U.M. COIL TABLE.','   NCLTOT =',i5)"), ncltot;
  goto statement_9600;
statement_6302:
  n1 = ncltot;
  read(abuff, "(2e14.5,3a6,i1,e14.5)"), gpar(n1), reacl(n1), bus1,
    bus2, bus6, jclout(n1), hist(n1);
  if (noutpr == 0) {
    write(kunit6, "('+COIL',i4,'.',2e14.5,i5)"), ncltot, gpar(n1),
      reacl(n1), jclout(n1);
  }
  n11 = 0;
  n12 = 0;
  FEM_DO_SAFE(n10, 1, ntot) {
    if (n11 != 0) {
      goto statement_304;
    }
    if (bus1 != bus(n10)) {
      goto statement_304;
    }
    nodvo1(n1) = n10;
    n11 = 1;
    if (n12 != 0) {
      goto statement_305;
    }
  statement_304:
    if (bus2 != bus(n10)) {
      goto statement_305;
    }
    nodvo2(n1) = n10;
    n12 = 1;
  statement_305:
    n13 = n11 * n12;
    if (n13 != 0) {
      goto statement_307;
    }
  }
  if (n11 == 0) {
    write(lunit6, format_3206), bus1;
  }
  if (n12 == 0) {
    write(lunit6, format_3206), bus2;
  }
  goto statement_9600;
statement_307:
  jcltac(n1) = 0;
  if (bus6 == blank) {
    goto statement_313;
  }
  FEM_DO_SAFE(j, 1, ktab) {
    ndx1 = ivarb(klntab + j);
    if (bus6 == texvec(ndx1)) {
      goto statement_311;
    }
  }
  write(lunit6, format_3207), bus6;
  goto statement_9600;
statement_311:
  ndx1 = kxtcs + j;
  jcltac(n1) = ndx1;
statement_313:
  if (iprsup >= 1) {
    write(lunit6, "(' ',2e14.5,3a6,i1,e14.5)"), gpar(n1), reacl(n1),
      bus1, bus2, bus6, jclout(n1), hist(n1);
  }
  goto statement_3302;
  //C  DATA INPUT FOR M32 AND NEWER VERSIONS ********************           M32.1624
  //C. USER2 : MACH-TABLE INPUT FOR M32 AND NEWER                           M32.1625
  //C     CLASS 2 AND CLASS 3 UM DATA CARDS                                 M36. 363
statement_11202:
  cimage(cmn);
  read(abuff, "(13a6,a2)"), text3, text4, text5;
  if (text3 != blank) {
    goto statement_13202;
  }
  if (text4 != blank) {
    goto statement_13202;
  }
  if (text5 != blank) {
    goto statement_13202;
  }
  if (noutpr == 0) {
    write(kunit6, "('+BLANK CARD ENDING UM DATA.')");
  }
  goto statement_500;
statement_13202:
  numum++;
  if (numum <= numfix) {
    goto statement_17000;
  }
  write(lunit6,
    "(/,'OVERFLOW U.M. MACHINE TABLE.  NUMUM =',i4,"
    "'INCREASE NUMFIX IN CARD FOR ABSOLUTE',/,' UM DIMENSIONS.')"),
    numum;
  goto statement_9600;
  //C  CHECKING OF DATA INPUT FORMAT ******************************         M36. 364
statement_17000:
  n10 = 0;
  read(abuff, "(i2)"), n10;
  if (n10 != 19) {
    goto statement_17004;
  }
  write(lunit6, format_30);
  write(lunit6, format_31);
  write(lunit6, format_32);
  write(lunit6, format_33);
  write(lunit6, format_34);
  write(lunit6, format_35);
  write(lunit6, format_36);
  goto statement_9600;
statement_17004:
  if (n10 >= 50 && n10 < 60) {
    goto statement_17040;
  }
  if (n10 < 50) {
    goto statement_15202;
  }
  //C  START READING SM TYPE -50 TO 59 DATA INPUT FORMAT **********         M36. 367
  jf = 0;
  jr = 0;
statement_17040:
  umdatb(cmn, reacl, gpar, fpar, nodvo1, nodvo2, jcltac, jtype,
    nodom, ncld, jtmtac, reamdu, reamds, flxds, flxdr, reamqu, flxqs,
    flxqr, jcdsat, jcqsat, nppair, rotmom, nclq, jtqout, jthout,
    reamqs, voltum, anglum, nodfum, nodmum, kumout, jumout, jclout,
    dcoef, jomout, umoutp);
  if (jf == 1) {
    goto statement_11202;
  }
  if (jr == 1) {
    return;
  }
  //C  END READING SM TYPE-59 DATA INPUT $$$$$$$$$$$$$$$$$$$$$$$$$$         M32.2562
  //C    START READING PURE UM DATA INPUT FORMAT ******************         M36. 606
statement_15202:
  n1 = numum;
  read(abuff, "(3i2,3i1,2a6,i2,4e14.5)"), jtype(n1), ncld(n1),
    nclq(n1), jtqout(n1), jomout(n1), jthout(n1), bus3, bus4, nppair(n1),
    rotmom(n1), dcoef(n1), epsom(n1), d10;
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   MACH CARD  1.   TYPE = ',i2)"),
      numum, jtype(n1);
  }
  FEM_DO_SAFE(n10, 1, ntot) {
    if (bus3 == blank) {
      goto statement_10205;
    }
    if (bus3 != bus(n10)) {
      goto statement_10204;
    }
    nodom(n1) = n10;
    if (d10 == 0.0f) {
      d10 = statfr;
    }
    rotmom(n1) = twopi * d10;
    goto statement_10205;
  statement_10204:;
  }
  write(lunit6,
    "(/,' ERROR STOP.   THE NODE NAME  \"BUS3\"',"
    "' ON THE LAST-READ CARD IS NOT THAT',/,' OF ANY ELECTRIC NETWORK NODE.',"
    "' BUS3=',a6)"),
    bus3;
  goto statement_9600;
statement_10205:
  jtmtac(n1) = 0;
  if (bus3 != blank) {
    goto statement_10213;
  }
  FEM_DO_SAFE(j, 1, ktab) {
    ndx1 = ivarb(klntab + j);
    if (bus4 == texvec(ndx1)) {
      goto statement_10209;
    }
  }
  if (bus4 == blank) {
    goto statement_10213;
  }
  write(lunit6, format_13207), bus4;
  goto statement_9600;
statement_10209:
  ndx1 = kxtcs + j;
  jtmtac(n1) = ndx1;
  //C     READ INPUT CARD USING CIMAGE                                      M32.2595
statement_10213:
  cimage(cmn);
  read(abuff, format_14203), omegm(n1), reamdu(n1), jcdsat(n1),
    reamds(n1), flxds(n1), flxdr(n1);
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   MACH CARD  2.',2e10.2)"), numum,
      omegm(n1), reamdu(n1);
  }
  //C     READ INPUT CARD USING CIMAGE                                      M32.2603
  cimage(cmn);
  read(abuff, format_14203), thetam(n1), reamqu(n1), jcqsat(n1),
    reamqs(n1), flxqs(n1), flxqr(n1);
  if (reamqu(n1) > 0.0f) {
    goto statement_15910;
  }
  write(lunit6, format_6198), n1;
  goto statement_9600;
statement_15910:
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   MACH CARD  3.',2e10.2)"), numum,
      thetam(n1), reamqu(n1);
  }
  if (iprsup >= 4) {
    write(lunit6,
      "(/,' ***************************************',"
      "' THE MACHINE-TABLE INPUT OF UM NUMBER',i4,' :')"),
      n1;
  }
  if (iprsup >= 4) {
    write(lunit6,
      "(' *********',3i2,3i1,2a6,i2,3e14.5,/,' *********',2e14.5,i1,3e14.5,/,"
      "' *********',2e14.5,i1,3e14.5)"),
      jtype(n1), ncld(n1), nclq(n1), jtqout(n1), jomout(n1), jthout(n1),
      bus3, bus4, nppair(n1), rotmom(n1), dcoef(n1), epsom(n1), omegm(n1),
      reamdu(n1), jcdsat(n1), reamds(n1), flxds(n1), flxdr(n1),
      thetam(n1), reamqu(n1), jcqsat(n1), reamqs(n1), flxqs(n1),
      flxqr(n1);
  }
  //C  READ SHARE CARD(IF SHARING OF MECH NETW IS REQUESTED) :              M39.1167
  nshare = 0;
  cimage(cmn);
  read(abuff, "(a6)"), text3;
  if (text3 != tesm9) {
    goto statement_15830;
  }
  nshare = 1;
  read(abuff, "(6x,2i6)"), n5, n6;
  if (n6 == 0) {
    goto statement_15822;
  }
  if (noutpr == 0) {
    write(kunit6,
      "('+UM -',i3,' SHARES MECH NETW WITH UM-',i3,'AND',i3)"),
      numum, n5, n6;
  }
  goto statement_15826;
statement_15822:
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,' SHARES MECH NETW WITH UM-',i3)"), numum, n5;
  }
statement_15826:
  if (n1 != n5 && n1 != n6) {
    goto statement_15828;
  }
  write(lunit6,
    "(/,' ERROR STOP. THIS UM-',i3,' IS SUPPOSED TO',"
    "' SHARE ITS MECH NETWORK WITH OTHER UM''S. WHAT',"
    "' SHOULD BE SPECIFIED ON THIS CARD ARE THE',/,"
    "' NUMBERS OF THESE OTHER UM''S WITHOUT',"
    "' INCLUDING THE NUMBER OF THE UM WHICH IS',"
    "' BEING PROCESSED RIGHT NOW.')"),
    n1;
  stoptp(cmn);
statement_15828:
  n10 = n1;
  if (n10 > n5) {
    n10 = n5;
  }
  if (n6 != 0 && n10 > n6) {
    n10 = n6;
  }
  if (n1 != n10) {
    nshare = 2;
  }
statement_15830:
  if (initum == 0) {
    goto statement_10300;
  }
  if (nshare == 0) {
    goto statement_15880;
  }
  cimage(cmn);
statement_15880:
  d1 = 1.0e+3f;
  //C  MAKE SURE THAT USER SETS UP AUTOMATIC SS-CALC IF LDFLOW :            M39.1200
  if (istep != -4567) {
    goto statement_15890;
  }
  if (nshare == 2) {
    goto statement_15890;
  }
  read(abuff, "(34x,a6)"), bus6;
  if (bus6 != blank) {
    goto statement_15890;
  }
  write(lunit6, format_80502);
  stoptp(cmn);
statement_15890:
  n5 = 4;
  n6 = 0;
  read(abuff, "(2e14.5,2a6,e14.5)"), voltum(n1), anglum(n1), bus5,
    bus6, distrf;
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   MACH CARD  4.',2e10.2)"), numum,
      voltum(n1), anglum(n1);
  }
  if (jtype(n1) == 3) {
    goto statement_10230;
  }
  if (jtype(n1) == 4) {
    goto statement_10230;
  }
  if (jtype(n1) == 5) {
    goto statement_10230;
  }
  FEM_DO_SAFE(n10, 1, ntot) {
    if (bus5 != bus(n10)) {
      goto statement_10220;
    }
    nodfum(n1) = n10;
    FEM_DO_SAFE(n11, 1, kconst) {
      n12 = node(n11);
      if (n12 < 0) {
        n12 = -n12;
      }
      if (nodfum(n1) != n12) {
        goto statement_10219;
      }
      nodfum(n1) = n11;
      goto statement_10230;
    statement_10219:;
    }
  statement_10220:;
  }
  write(lunit6,
    "(/,' ERROR STOP.   THE NODE NAME  \"BUSF\"',"
    "' ON THE LAST-READ CARD IS NOT THAT',/,"
    "' OF ANY ELECTRIC NETWORK SOURCE NODE.',' BUSF=',a6)"),
    bus5;
  goto statement_9600;
statement_10230:
  FEM_DO_SAFE(n10, 1, ntot) {
    if (nshare == 2 && bus6 == blank) {
      goto statement_10250;
    }
    if (bus6 != bus(n10)) {
      goto statement_10233;
    }
    FEM_DO_SAFE(n11, 1, kconst) {
      n12 = node(n11);
      if (n12 < 0) {
        n12 = -n12;
      }
      if (n10 != n12) {
        goto statement_10232;
      }
      crest(n11) = d1 * distrf;
      if (n6 != 0) {
        goto statement_10231;
      }
      nodmum(n1) = n11;
      if (distrf == 0.0f) {
        crest(n11) = d1;
      }
    statement_10231:
      tstart(n11) = -7777.f;
      goto statement_10250;
    statement_10232:;
    }
  statement_10233:;
  }
  if (nshare != 2) {
    goto statement_90233;
  }
  write(lunit6,
    "(/,' ERROR STOP. THE NODE NAME \"',a6,'\" ON THE',"
    "' LAST-READ CARD SHOULD BE LEFT BLANK.')"),
    bus6;
  write(lunit6, format_90202), n1;
  stoptp(cmn);
statement_90233:
  write(lunit6,
    "(/,' ERROR STOP.   THE NODE NAME  \"BUSM\"',"
    "' ON THE LAST-READ CARD IS NOT THAT',/,"
    "' OF ANY ELECTRIC NETWORK SOURCE NODE.',' BUSM=',a6)"),
    bus6;
  goto statement_9600;
statement_10250:
  cimage(cmn);
  read(abuff, "(a6)"), text3;
  if (text3 != textm) {
    goto statement_10300;
  }
  if (nshare != 2) {
    goto statement_90260;
  }
  write(lunit6,
    "(/,' ERROR STOP. THIS CARD 5 OF CLASS 2 UM DATA',' CARDS OF THIS UM -',"
    "i3,' SHOULD BE REMOVED.')"),
    n1;
  write(lunit6, format_90202), n1;
  stoptp(cmn);
statement_90260:
  n5++;
  n6 = 1;
  read(abuff, "(a6,28x,a6,e14.5)"), text3, bus6, distrf;
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   MACH CARD',i3,'.',e14.5)"), numum,
      n5, distrf;
  }
  goto statement_10230;
  //C. IF FLUX OUTPUT IS DESIRED :                                          M32.2681
  //C. USER3 : COIL-TABLE INPUT FOR M32 AND NEWER                           M32.2684
statement_10300:
  if (iprsup >= 4) {
    write(lunit6,
      "(/,' ***************************************',"
      "' THE COIL-TABLE INPUT OF UM NUMBER',i4,' :')"),
      numum;
  }
  n8 = 0;
  ncldq = ncld(n1) + nclq(n1) + 3;
  //C. ADJUSTMENT OF NCLD AND NCLQ FOR UM TYPE 4 :                          M32.2689
  if (jtype(n1) != 4) {
    goto statement_10304;
  }
  ncld(n1) = 1;
  nclq(n1) = 1;
  ncldq = ncld(n1) + nclq(n1) + 4;
statement_10304:
  if (initum != 0) {
    goto statement_14303;
  }
statement_13302:
  if (n8 >= ncldq) {
    goto statement_11202;
  }
  if (n8 == 0 && nshare == 0) {
    goto statement_14303;
  }
  cimage(cmn);
statement_14303:
  ncltot++;
  fpar(ncltot) = 0.0f;
  if (ncltot <= nclfix) {
    goto statement_14305;
  }
  write(lunit6, "(/,' OVERFLOW U.M. COIL TABLE.','   NCLTOT =',i5)"), ncltot;
  goto statement_9600;
statement_14305:
  n8++;
  read(abuff, "(2e14.5,3a6,i1,e14.5)"), gpar(ncltot), reacl(ncltot),
    bus1, bus2, bus6, jclout(ncltot), hist(ncltot);
  if (noutpr == 0) {
    write(kunit6, "('+UM -',i3,'   COIL CARD',i3,'.',2e11.2)"),
      numum, n8, gpar(ncltot), reacl(ncltot);
  }
  n11 = 0;
  n12 = 0;
  FEM_DO_SAFE(n10, 1, ntot) {
    if (n11 != 0) {
      goto statement_13304;
    }
    if (bus1 != bus(n10)) {
      goto statement_13304;
    }
    nodvo1(ncltot) = n10;
    n11 = 1;
    if (n12 != 0) {
      goto statement_13305;
    }
  statement_13304:
    if (bus2 != bus(n10)) {
      goto statement_13305;
    }
    nodvo2(ncltot) = n10;
    n12 = 1;
  statement_13305:
    n13 = n11 * n12;
    if (n13 != 0) {
      goto statement_13307;
    }
  }
  if (n11 == 0) {
    write(lunit6, format_13206), bus1;
  }
  if (n12 == 0) {
    write(lunit6, format_13206), bus2;
  }
  goto statement_9600;
statement_13307:
  jcltac(ncltot) = 0;
  if (bus6 == blank) {
    goto statement_13313;
  }
  FEM_DO_SAFE(j, 1, ktab) {
    ndx1 = ivarb(klntab + j);
    if (bus6 == texvec(ndx1)) {
      goto statement_13311;
    }
  }
  write(lunit6, format_13207), bus6;
  goto statement_9600;
statement_13311:
  ndx1 = kxtcs + j;
  jcltac(ncltot) = ndx1;
statement_13313:
  if (iprsup >= 4) {
    write(lunit6,
      "(' ******** COIL CARD NR.',i3,' :',2e14.5,3a6,i1,e14.5)"),
      ncltot, gpar(ncltot), reacl(ncltot), bus1, bus2, bus6, jclout(ncltot),
      hist(ncltot);
  }
  goto statement_13302;
  //C.  AT THIS POINT READING OF ALL UM DATA INPUT IS FINISHED              M32.2747
  //C         ******************************************************        M32.2748
  //C. CALCULATION OF REAL GPAR :                                           M32.2749
statement_500:
  FEM_DO_SAFE(n1, 1, ncltot) {
    if (gpar(n1) != 0.0f) {
      gpar(n1) = 1.0f / gpar(n1);
    }
  }
  if (istep != -4567) {
    goto statement_80510;
  }
  if (initum == 1) {
    goto statement_80510;
  }
  write(lunit6, format_80502);
  stoptp(cmn);
statement_80510:
  if (nsmach == 0) {
    goto statement_510;
  }
  //C  WARNING IF OVERFLOW OF ETAC,ISMTAC AND BUSTAC                        M32.2753
  n1 = cmn.ntotac - ntacb;
  if (n1 <= 10) {
    goto statement_510;
  }
  write(lunit6,
    "(/,' WARNING: IN USING SM TYPE-50 TO 59 DATA',"
    "' INPUT,YOU HAVE REQUESTED A TOTAL OF',i4)"),
    n1;
  write(lunit6,
    "(/,' TO BE PASSED TO TACS. THE DEFAULT',"
    "' STORAGE ALLOCATION IS JUST FOR 10 OF')");
  write(lunit6,
    "(/,' SUCH VARIABLES BECAUSE IN DECK SYNMAC',"
    "' THE ARRAYS ISMTAC, ETAC, BUSTAC ARE')");
  write(lunit6,
    "(/,' DIMENSIONED TO 10. DID YOU INCREASE THIS',"
    "' DIMENSION TO BE AT LEAST EQUAL TO THIS')");
  write(lunit6,
    "(/,' TOTAL NR OF VARIABLES YOU WANT TO TRANSFER',"
    "' TO TACS?  YOU SHOULD HAVE.')");
statement_510:
  kcoil(1) = 1;
  numout = 0;
  if (loopss(8) != 1) {
    goto statement_530;
  }
  n1 = 6 * numum;
  if (n1 <= nclfix) {
    goto statement_530;
  }
  write(lunit6,
    "(/,' OVERFLOW OF UM COIL TABLE, ',' INCREASE NCLFIX ON UM DIMENSION',"
    "' CARD TO BE GREATER THAN 6 TIMES',"
    "' THE TOTAL NR. OF USED UM MACHINES.')");
  goto statement_9600;
  //C. MACHINE LOOPING FOR SPECIAL PROCESSING OF SOME PARAMETERS:           M32.2773
statement_530:
  FEM_DO_SAFE(n1, 1, numum) {
    numoui = numout;
    rppair = nppair(n1);
    if (jtype(n1) == 13) {
      jtmtac(n1) = 0;
    }
    if (initum == 1) {
      omegm(n1) = rotmom(n1) / rppair;
    }
    omold(n1) = omegm(n1);
    flxd(n1) = 0.0f;
    flxq(n1) = 0.0f;
    //C. OMOLD INITIALIZATION, TORQUE ANGLE FOR TYPE 1 AND 1,                 M28.4148
    //C. AND COIL ADJUSTMENT FOR THREE-PHASE EXC. COILS :                     M28.4149
    if (jtype(n1) > 2) {
      goto statement_921;
    }
    thetam(n1) = (thetam(n1) + pi / 2.0f) / rppair;
    //C. SET UP OF ARRAY KCOIL(1:NUMUM) :                                     M28.4156
  statement_921:
    if (n1 == numum) {
      goto statement_950;
    }
    n2 = n1 + 1;
    n3 = 3 + ncld(n1) + nclq(n1);
    if (jtype(n1) != 4) {
      goto statement_940;
    }
    n3++;
  statement_940:
    kcoil(n2) = kcoil(n1) + n3;
  statement_950:
    kcl = kcoil(n1);
    //C  MAKING SURE THAT POWER COILS ARE NOT TACS CONTROLLED :               M39.1247
    FEM_DO_SAFE(n2, 1, 3) {
      n3 = kcl - 1 + n2;
      if (jcltac(n3) == 0) {
        goto statement_958;
      }
      write(lunit6,
        "(/,' ERROR STOP. UM NUMBER',i4,' IS PROVIDED',"
        "' WITH TACS CONTROLLED SOURCES ON THE POWER',"
        "' SIDE. THIS IS ONLY ALLOWED FOR THE COILS ON',/,"
        "' THE EXCITATION SIDE. TACS CONTROL OF POWER',"
        "' SIDE COILS IS TO BE DONE THROUGH THE NETWORK',"
        "' WHICH IS CONNECTED TO THESE COILS.')"),
        n1;
      stoptp(cmn);
    statement_958:;
    }
    if (initum == 0) {
      goto statement_990;
    }
    FEM_DO_SAFE(n2, 1, 3) {
      n3 = kcl - 1 + n2;
      //C  PREPARING SHIFT OF LEAKAGE INDUCTANCES OF POWER COILS *******        M39.1261
      //C  NOTE : THE EMTP ADDRESS IT OF THESE SHIFTED INDUCTANCES              M38.1343
      //C         ARE STORED IN FPAR(KCL).                                      M38.1344
      if (nodvo1(n3) == nodvo2(n3)) {
        goto statement_980;
      }
      //C  CREATE NEW NODE BEHIND LEAKAGE INDUCTANCE. THIS NODE                 M36. 628
      //C    BECOMES THE NEW UM POWER NODE.                                     M36. 629
      ntot++;
      kode(ntot) = 0;
      bus(ntot) = trash;
      if (n1 > 5) {
        goto statement_962;
      }
      n4 = 75 + (n1 - 1) * 3 + n2;
      bus(ntot) = texta(n4);
      //C  CREATION OF THE LEAKAGE INDUCTANCE BRANCHE                           M36. 636
    statement_962:
      ibrinc(cmn);
      it++;
      length(ibr) = 1;
      nr(ibr) = -it;
      tr(it) = 0.0f;
      c(it) = 0.0f;
      d1 = reacl(kcl + 2);
      if (d1 > reacl(kcl + 1)) {
        d1 = reacl(kcl + 1);
      }
      if (jtype(n1) < 3) {
        goto statement_966;
      }
      if (jtype(n1) > 5) {
        goto statement_966;
      }
      if (n2 != 3) {
        goto statement_966;
      }
      reacl(kcl + 1) = reacl(kcl + 1) - d1;
      reacl(kcl + 2) = reacl(kcl + 2) - d1;
    statement_966:
      if (xopt == 0.0f) {
        tx(it) = d1 * 1.0e+3;
      }
      if (xopt != 0.0f) {
        tx(it) = d1 * twopi * xopt;
      }
      if (n3 == kcl) {
        fpar(kcl) = ibr;
      }
      n4 = 3 * (n1 - 1);
      if (nodvo1(n3) == 1) {
        goto statement_972;
      }
      umcurp(n4 + n2) = nodvo1(n3);
      kbus(ibr) = nodvo1(n3);
      mbus(ibr) = ntot;
      nodvo1(n3) = ntot;
      goto statement_974;
    statement_972:
      umcurp(n4 + n2) = nodvo2(n3);
      kbus(ibr) = nodvo2(n3);
      mbus(ibr) = ntot;
      nodvo2(n3) = ntot;
    statement_974:
      if (n2 != 1) {
        goto statement_976;
      }
      if (iprsup >= 1) {
        write(lunit6,
          "(/,' ADDITIONAL BRANCHES CREATED TO MOVE',"
          "' LEAKAGE INDUCT TO EMTP NETWORK FOR UM',' NUMBER',i3,'.',/,21x,"
          "'NODE TO NODE',5x,'IBR',6x,'IT',8x,'TX(IT)')"),
          n1;
      }
    statement_976:
      if (iprsup >= 1) {
        write(lunit6, "(21x,i4,4x,i4,4x,i4,4x,i4,e14.5)"), mbus(ibr),
          kbus(ibr), ibr, it, tx(it);
      }
    statement_980:;
    }
    //C  CREATION OF SPEED CAPACITORS FOR STEADY-STATE INITIALIZATION:        M39.1262
    ntot++;
    if (jtmtac(n1) <= 0) {
      jtmtac(n1) = -ntot;
    }
    bus(ntot) = trash;
    if (n1 < 4) {
      bus(ntot) = texta(98 + n1);
    }
    ibrinc(cmn);
    it++;
    fpar(kcl + 2) = it;
    length(ibr) = 1;
    nr(ibr) = -it;
    kbus(ibr) = nodom(n1);
    mbus(ibr) = ntot;
    tr(it) = cmn.epsiln;
    c(it) = 0.0f;
    tx(it) = 0.0f;
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' POTENTIAL SPEED CAP : MBUS =',i6,' KBUS =',i6,"
        "' IBR =',i6,' IT =',i6,' TR(IT) =',e14.5,' C(IT) =',e14.5)"),
        mbus(ibr), kbus(ibr), ibr, it, tr(it), c(it);
    }
    //C  CREATION OF SOURCES TO REPRESENT IM EXCITATION COILS FOR             M37.2604
    //C    STEADY-STATE INITIALIZATION (ACCOMMODATES KPSOUR USE):             M37.2605
    if (jtype(n1) < 3) {
      goto statement_990;
    }
    if (jtype(n1) > 7) {
      goto statement_990;
    }
    n5 = kcl + 3;
    n6 = kcl + 2 + ncld(n1) + nclq(n1);
    if (jtype(n1) == 4) {
      n6++;
    }
    n11 = kconst + 1;
    FEM_DO_SAFE(j, n5, n6) {
      if (nodvo1(j) == nodvo2(j)) {
        goto statement_988;
      }
      FEM_DO_SAFE(n10, 1, 2) {
        if (n10 == 2) {
          goto statement_982;
        }
        if (nodvo1(j) == 1) {
          goto statement_987;
        }
        kconst++;
        n20 = nodvo1(j);
        node(kconst) = -n20;
        kode(n20) = 0;
        goto statement_984;
      statement_982:
        if (nodvo2(j) == 1) {
          goto statement_987;
        }
        kconst++;
        n20 = nodvo2(j);
        node(kconst) = -n20;
        kode(n20) = 0;
      statement_984:
        if (kconst == n11) {
          fpar(kcl + 1) = kconst;
        }
        iform(kconst) = 14;
        crest(kconst) = 0.0f;
        time1(kconst) = 0.0f;
        tstart(kconst) = -1.0f;
        tstop(kconst) = 0.0f;
        sfreq(kconst) = 0.0001f;
        if (iprsup >= 1 && j == n5) {
          write(lunit6,
            "(' *********',' STEADY-STATE CURR SOURCES FOR IM EXCIT COILS :',"
            "'    NODE  KCONST         SFREQ         CREST','         TSTOP')");
        }
        if (iprsup >= 1) {
          write(lunit6, "(' *********',47x,2i8,3e14.5)"), node(kconst),
            kconst, sfreq(kconst), crest(kconst), tstop(kconst);
        }
      statement_987:;
      }
    statement_988:;
    }
  statement_990:
    n2 = kcoil(n1);
    n3 = n2 + ncld(n1) + nclq(n1) + 2;
    if (jtype(n1) == 4) {
      n3++;
    }
    if (iprsup >= 1) {
      write(lunit6, "(/,' ELECTRIC TERMINAL NODES FOR UM NR.',i3,': ')"), n1;
    }
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, lunit6, "(' NODVO1 :',3x,15i4)");
        FEM_DO_SAFE(n4, n2, n3) {
          wloop, nodvo1(n4);
        }
      }
    }
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, lunit6, "(' NODVO2 :',3x,15i4)");
        FEM_DO_SAFE(n4, n2, n3) {
          wloop, nodvo2(n4);
        }
      }
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' UM MASS NODE NR. = NODOM(JM) =',i4,/,' SLACK BUSES :',3x,"
        "'NODMUM(JM) =',i4,10x,'NODFUM(JM) =',i4)"),
        nodom(n1), nodmum(n1), nodfum(n1);
    }
    //C. DETERMINATION OF POINTERS FOR OUTPUT VECTOR :                        M28.4172
    if (jtqout(n1) == 0) {
      goto statement_1000;
    }
    numout++;
    kumout(numout) = n1;
    jumout(numout) = 1 + numfix;
    if (jtqout(n1) < 2) {
      goto statement_1000;
    }
    numout++;
    kumout(numout) = n1;
    jumout(numout) = 4 + numfix;
    if (jtqout(n1) != 3) {
      goto statement_1000;
    }
    numout++;
    kumout(numout) = n1;
    jumout(numout) = 5 + numfix;
  statement_1000:
    if (jomout(n1) == 0) {
      goto statement_1010;
    }
    numout++;
    kumout(numout) = n1;
    jumout(numout) = 2 + numfix;
    if (jomout(n1) < 2) {
      goto statement_1010;
    }
    numout++;
    kumout(numout) = n1;
    jumout(numout) = 6 + numfix;
    if (jomout(n1) != 3) {
      goto statement_1010;
    }
    numout++;
    kumout(numout) = n1;
    jumout(numout) = 7 + numfix;
  statement_1010:
    if (jthout(n1) == 0) {
      goto statement_1020;
    }
    numout++;
    kumout(numout) = n1;
    //C  IF OUTPUT REQUEST FOR THETAM (TORQUE ANGLE OR ROTOR POSITION)        M38.1407
    if (jthout(n1) == 1) {
      jumout(numout) = 3 + numfix;
    }
    //C  IF OUTPUT REQUEST FOR TQEXC (FOR SM TYPE-59 DATA INPUT)              M38.1409
    if (jthout(n1) == 3) {
      jumout(numout) = 11 + numfix;
    }
  statement_1020:
    n2 = 3 + ncld(n1) + nclq(n1);
    if (jtype(n1) != 4) {
      goto statement_1030;
    }
    n2++;
  statement_1030:
    FEM_DO_SAFE(n3, 1, n2) {
      n4 = kcoil(n1) - 1 + n3;
      if (reacl(n4) >= 0.0f) {
        goto statement_1038;
      }
      write(lunit6,
        "(/,' ERROR STOP. A NEGATIVE LEAKAGE INDUCTANCE',"
        "' INDUCTANCE IS USED TO SIMULATE MACHINE',' NUMBER',i4,'.')"),
        n1;
      goto statement_9600;
    statement_1038:
      if (jclout(n4) == 0) {
        goto statement_1040;
      }
      numout++;
      kumout(numout) = n1;
      jumout(numout) = 11 + numfix + n3;
      if (jclout(n4) != 2) {
        goto statement_1040;
      }
      if (n3 == 1) {
        jumout(numout) = numfix + 8;
      }
      if (n3 == 2) {
        jumout(numout) = numfix + 9;
      }
      if (n3 == 3) {
        jumout(numout) = numfix + 10;
      }
    statement_1040:;
    }
    if (numout == numoui) {
      goto statement_1050;
    }
    if (n1 == 1) {
      numbus = jumout(numout);
    }
    n11 = jumout(numout);
    if (n11 > numbus) {
      numbus = n11;
    }
  statement_1050:;
  }
  if (numbus <= cmn.ibsfix) {
    goto statement_1060;
  }
  write(lunit6,
    "(/,' OVERFLOW OF UM OUTPUT NAME TABLE, ',"
    "' INCREASE IBSFIX ON UM DIMENSION CARD.')");
  goto statement_9600;
  //C  SHIFTING ENTRIES OF UMOUTP VECTOR BECAUSE OF SM TYPE-59              M32.2786
  //C    REQUEST FOR TRANSFER OF VARIABLES TO TACS :                        M32.2787
statement_1060:
  if (nsmach == 0) {
    goto statement_18010;
  }
  if (nsmtac == 0) {
    goto statement_18010;
  }
  FEM_DO_SAFE(n5, 1, nsmtac) {
    n6 = nsmtac + 1 - n5;
    n7 = numout + 3 + n6;
    umoutp(n7) = umoutp(n6);
  }
  FEM_DO_SAFE(n5, 1, numout) {
    umoutp(n5) = 0.0f;
  }
  n5 = numout + nsmtac + 3;
  umoutp(numout + 3) = n5;
  //C  UMOUTP(NUMOUT+3) IS LAST ENTRY OF UMOUTP THAT IS USED                M32.2798
  umoutp(numout + 2) = cmn.nangre;
  //C  UMOUTP(NUMOUT+2) .NE. 0.0 INDICATES REQUEST FOR ANGLE TRANSF.        M32.2800
  umoutp(numout + 1) = -9999.0f;
  //C  UMOUTP(NUMOUT+1) .EQ. -9999. IS A FLAG FOR REQUEST OF TACS           M32.2802
  //C  TRANSFER OF UM VARIABLES.                                            M32.2803
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' THE UM OUTPUT TABLE UMOUTP(NUMOUT+NSMTAC+3):',/,6(6x,e14.5),"
        "/(6(6x,e14.5)))");
      FEM_DO_SAFE(n1, 1, n5) {
        wloop, umoutp(n1);
      }
    }
  }
statement_18010:
  cmn.istart = 0;
  if (numout <= cmn.iotfix) {
    goto statement_18020;
  }
  write(lunit6,
    "(/,' OVERFLOW OF UM OUTPUT TABLE, INCREASE',"
    "' IN CARD FOR ABSOLUTE UM DIMENSIONS',/,' VALUE OF IOTFIX.',/,"
    "' REMARK : IF SM TYPE-59 DATA INPUT IS',' INCLUDED, THEN IOTFIX IS ALSO',"
    "/,' RELATED TO OUTPUTS OF MECH. SYSTEMS',"
    "' IN ALL SM TYPE-59 DATA MACHINES.')");
  goto statement_9600;
statement_18020:
  loopss(1) = 0;
  loopss(2) = 0;
  loopss(4) = 0;
  loopss(10) = 0;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' EXIT  \"UMDATA\" :  NUMUM  NUMOUT  NSMTAC',/,17x,3i8)"),
      numum, numout, nsmtac;
  }
  return;
statement_9600:
  stoptp(cmn);
}

void smpfit(
  common& cmn,
  arr_ref<double> x,
  int const& ism,
  double const& fm,
  int const& lunit6,
  int const& noutpr)
{
  x(dimension(6));
  common_write write(cmn);
  double d1 = fem::double0;
  double h3 = fem::double0;
  double h2 = fem::double0;
  double a = fem::double0;
  double c = fem::double0;
  double u2 = fem::double0;
  double b = fem::double0;
  double f1 = fem::double0;
  double f3 = fem::double0;
  double d = fem::double0;
  double f2 = fem::double0;
  double f4 = fem::double0;
  double u = fem::double0;
  //C     THIS MODULE APPLIES ONLY TO  S.M.  MODELING (BOTH 50, 59).        M31. 898
  //C     THIS MODULE APPLIES ONLY TO S.M.  MODELLING ( BOTH 50 AND 59 )    M32.2878
  //C     UNIMPROVED PARAMETERS ( RESISTANCES )    *   *   *   *   *   *   *M32.2880
  d1 = x(1);
  h3 = x(6);
  h2 = x(2);
  if (d1 == h2) {
    h2 = h2 * fm;
  }
  a = x(3) - h3;
  c = d1 - h3;
  u2 = c * c;
  if (d1 == h2) {
    goto statement_5;
  }
  b = u2 / (d1 - h2) - c;
  f1 = b + c;
  f3 = f1 / x(5);
  d = b * c;
  a = -a / ((a * f1) / d - 1.0f);
  f2 = a + c;
  f4 = (a + d / f1) / x(4);
  if (ism == 0) {
    goto statement_13;
  }
  //C     IMPROVE THE ROTOR RESISTANCES    *   *   *   *   *   *   *   *   *M32.2897
  u = (x(4) + x(5)) * .5e0;
  d = u * u - (x(4) * x(5)) / (1.0f - u2 / (f1 * f2));
  if (d < 0.f) {
    goto statement_12;
  }
  d = u - sqrtz(d);
  f4 = f2 / d;
  f3 = f1 / (2.0f * u - d);
  goto statement_13;
statement_12:
  if (noutpr != 0) {
    goto statement_13;
  }
  write(lunit6,
    "(5x,' NOTE  ----  THE LAST-READ DATA CARD',"
    "' BELONGS TO A DYNAMIC SYNCHRONOUS',' MACHINE, FOR WHICH THE PARAMETERS',"
    "/,18x,'ARE TO BE MATHEMATICALLY IMPROVED',"
    "' WITHIN THE MODULE \"SMPFIT\" OF',' OVERLAY NUMBER 5.   THE USER',/,18x,"
    "'REQUESTED THIS PROCEDURE BY MEANS',' OF THE  \"PARAMETER FITTING\"',"
    "'  CARD WHICH ACCOMPANIED THE')");
  write(lunit6,
    "(18x,'DATA CARDS FOR THIS MACHINE.','   THE ATTEMPTED ITERATION HAS',"
    "' FAILED TO CONVERGE.')");
  write(lunit6,
    "(18x,'THE EMTP LOGIC WILL NOW RECOVER',' AND SIMPLY IGNORE THE REQUEST',"
    "' TO IMPROVE MACHINE PARAMETERS.',/,18x,"
    "'INPUT DATA WILL BE USED WITHOUT',' ANY ALTERATIONS.')");
  goto statement_13;
  //C     PARAMETERS OF THE REDUCED ORDER MODEL    *   *   *   *   *   *   *M32.2924
statement_5:
  f1 = 1.0f;
  f2 = u2 / (d1 - x(3));
  f3 = 0.f;
  f4 = f2 / x(4);
statement_13:
  x(2) = c;
  x(3) = f1;
  x(4) = f2;
  x(5) = f3;
  x(6) = f4;
}

void rinfin(
  common& cmn)
{
  common_write write(cmn);
  auto& lstat = cmn.lstat;
  int& noutpr = cmn.noutpr;
  int& it = cmn.it;
  int& ibr = cmn.ibr;
  const auto& nltype = cmn.nltype;
  const auto& nonlk = cmn.nonlk;
  const auto& nonlm = cmn.nonlm;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  const auto& bus = cmn.bus;
  //
  int n3 = fem::int0;
  double d1 = fem::double0;
  int n7 = fem::int0;
  int i = fem::int0;
  int k = fem::int0;
  int m = fem::int0;
  int j = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  n3 = 0;
  d1 = 1.0f / (100.f * cmn.flzero);
  //C     1ST REMOVE MINUS SIGN OF "KPARTB" IF PRESENT AS FLAG              M32.2937
  //C     INDICATING "RENUMBER BYPASS".   THEN REDEFINE VALUE OF            M32.2938
  //C     THIS LOFTY RESISTANCE IF USER HAD A "HIGH RESISTANCE"             M32.2939
  //C     REQUEST (KNOWN BY N7 .NE. DEFAULT VALUE OF 1000 IN OVER1):        M32.2940
  n7 = fem::iabs(cmn.kpartb);
  if (n7 < 1000) {
    d1 = fem::pow(10.0f, n7);
  }
  i = cmn.inonl;
statement_54147:
  if (i == 0) {
    goto statement_54180;
  }
  if (nltype(i) > 0) {
    goto statement_54174;
  }
  k = nonlk(i);
  m = fem::iabs(nonlm(i));
  FEM_DO_SAFE(j, 1, ibr) {
    n1 = fem::iabs(kbus(j));
    n2 = fem::iabs(mbus(j));
    if (n1 != k) {
      goto statement_54154;
    }
    if (n2 == m) {
      goto statement_54174;
    }
    goto statement_54155;
  statement_54154:
    if (n2 != k) {
      goto statement_54155;
    }
    if (n1 == m) {
      goto statement_54174;
    }
  statement_54155:;
  }
  ibr++;
  if (ibr <= cmn.lbrnch) {
    goto statement_4716;
  }
  lstat(19) = 4716;
  cmn.kill = 1;
  lstat(16) = 2;
  //C      GO TO 9200                                                       VAX. 924
statement_4716:
  kbus(ibr) = k;
  mbus(ibr) = m;
  if (n3 > 0) {
    goto statement_54162;
  }
  j1 = k;
  j2 = m;
  it++;
  tr(it) = d1;
  tx(it) = 0.0f;
  c(it) = 0.0f;
statement_54162:
  nr(ibr) = -it;
  length(ibr) = 1;
  if (n3 > 0) {
    length(ibr) = -1;
  }
  n7 = -nltype(i);
  if (n7 != 98) {
    n7 = 99;
  }
  if (noutpr == 0 && n3 > 0) {
    write(lunit6,
      "(' HIGH RES. ADDED BY EMTP ACROSS TYPE-',i2,' ELEM.',i3,1x,2x,'1 0',"
      "4a6)"),
      n7, i, bus(k), bus(m), bus(j1), bus(j2);
  }
  if (n3 == 0 && noutpr == 0) {
    write(lunit6,
      "(' HIGH RES. ADDED BY EMTP ACROSS TYPE-',i2,' ELEM.',i3,1x,2x,'1 0',"
      "2a6,12x,e6.1)"),
      n7, i, bus(k), bus(m), tr(it);
  }
  n3 = 1;
statement_54174:
  i = i - 1;
  if (i > 0) {
    goto statement_54147;
  }
statement_54180:;
}

struct smdat_save
{
  fem::str<8> text1;
  fem::str<8> text10;
  fem::str<8> text11;
  fem::str<8> text12;
  fem::str<8> text16;
  fem::str<8> text17;
  fem::str<8> text18;
  fem::str<8> text19;
  fem::str<8> text2;
  fem::str<8> text20;
  fem::str<8> text21;
  fem::str<8> text3;
  fem::str<8> text7;
  fem::str<8> text8;

  smdat_save() :
    text1(fem::char0),
    text10(fem::char0),
    text11(fem::char0),
    text12(fem::char0),
    text16(fem::char0),
    text17(fem::char0),
    text18(fem::char0),
    text19(fem::char0),
    text2(fem::char0),
    text20(fem::char0),
    text21(fem::char0),
    text3(fem::char0),
    text7(fem::char0),
    text8(fem::char0)
  {}
};

void smdat(
  common& cmn,
  int const& mtype)
{
  FEM_CMN_SVE(smdat);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& bus6 = cmn.bus6;
  const auto& texta6 = cmn.texta6;
  const auto& abuff = cmn.abuff;
  double& omega = cmn.omega;
  double& epsuba = cmn.epsuba;
  double& epdgel = cmn.epdgel;
  double& tenm6 = cmn.tenm6;
  double& onehaf = cmn.onehaf;
  double& flzero = cmn.flzero;
  auto& voltbc = cmn.voltbc;
  auto& flstat = cmn.flstat;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  auto& iprsov= cmn.iprsov;
  int& numsm = cmn.numsm;
  int& lsmout = cmn.lsmout;
  int& limass = cmn.limass;
  int& iv = cmn.iv;
  int& noutpr = cmn.noutpr;
  int& ktab = cmn.ktab;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& it = cmn.it;
  int& ibr = cmn.ibr;
  int& lsyn = cmn.lsyn;
  auto& sptacs = cmn.sptacs;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  auto& ismout = cmn.ismout;
  auto& elp = cmn.elp;
  auto& shp = cmn.shp;
  auto& histq = cmn.histq;
  auto& ismdat = cmn.ismdat;
  const auto& texvec = cmn.texvec;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  const auto& sfreq = cmn.sfreq;
  auto& ismtac = cmn.ismtac;
  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;
  int& ntotac = cmn.ntotac;
  int& lbstac = cmn.lbstac;
  auto& x1 = cmn.x1;
  double& sqrt3 = cmn.sqrt3;
  double& thtw = cmn.thtw;
  double& om2 = cmn.om2;
  double& bdam = cmn.bdam;
  int& mfirst = cmn.mfirst;
  int& nst = cmn.nst;
  int& nsmout = cmn.nsmout;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text10 = sve.text10;
  fem::str<8>& text11 = sve.text11;
  fem::str<8>& text12 = sve.text12;
  fem::str<8>& text16 = sve.text16;
  fem::str<8>& text17 = sve.text17;
  fem::str<8>& text18 = sve.text18;
  fem::str<8>& text19 = sve.text19;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text20 = sve.text20;
  fem::str<8>& text21 = sve.text21;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text7 = sve.text7;
  fem::str<8>& text8 = sve.text8;
  if (is_called_first_time) {
    text1 = "FINISH";
    text2 = "TOLERA";
    text3 = "NCES  ";
    text7 = "PARAME";
    text8 = "TER   ";
    text10 = "DELTA ";
    text11 = "CONNEC";
    text12 = "TION  ";
    text17 = "FITTIN";
    text18 = "G     ";
    text19 = "T     ";
    text20 = "PF    ";
    text21 = "DC    ";
    text16 = " PART ";
  }
  int ipout = fem::int0;
  int n56 = fem::int0;
  int ismold = fem::int0;
  int nn10 = fem::int0;
  int nn4 = fem::int0;
  int nn14 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int kaliu = fem::int0;
  int kiuty = fem::int0;
  int kud1 = fem::int0;
  int klntab = fem::int0;
  int niu = fem::int0;
  int n50 = fem::int0;
  double d10 = fem::double0;
  int n19 = fem::int0;
  double d8 = fem::double0;
  double bin = fem::double0;
  int jk = fem::int0;
  int ism = fem::int0;
  double fm = fem::double0;
  int k = fem::int0;
  int j30 = fem::int0;
  int idelta = fem::int0;
  int n11 = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  int n9 = fem::int0;
  auto& epomeg = cmn.epomeg;
  int i101 = fem::int0;
  int i26 = fem::int0;
  int i30 = fem::int0;
  int np = fem::int0;
  double sm3 = fem::double0;
  double sm4 = fem::double0;
  double rmva = fem::double0;
  double rkv = fem::double0;
  double aglin = fem::double0;
  double dab = fem::double0;
  double dac = fem::double0;
  int numask = fem::int0;
  int iln = fem::int0;
  double ad1 = fem::double0;
  double ad2 = fem::double0;
  double aq1 = fem::double0;
  double aq2 = fem::double0;
  double qaa = fem::double0;
  double qab = fem::double0;
  double qac = fem::double0;
  double zb = fem::double0;
  double emf = fem::double0;
  double ra = fem::double0;
  double xl = fem::double0;
  double xd = fem::double0;
  double xq = fem::double0;
  double xdp = fem::double0;
  double xqp = fem::double0;
  double xdpp = fem::double0;
  double xqpp = fem::double0;
  int ndwqa = fem::int0;
  double tdop = fem::double0;
  double tqop = fem::double0;
  double tdopp = fem::double0;
  double tqopp = fem::double0;
  double el2 = fem::double0;
  double r1 = fem::double0;
  double el1 = fem::double0;
  double a = fem::double0;
  double rat = fem::double0;
  double rat2 = fem::double0;
  int ib2 = fem::int0;
  double rat1 = fem::double0;
  double sf5 = fem::double0;
  double sf2 = fem::double0;
  double sf3 = fem::double0;
  double sf6 = fem::double0;
  double dsm = fem::double0;
  double hsp = fem::double0;
  double dsd = fem::double0;
  double dsr = fem::double0;
  int ilv = fem::int0;
  double b6 = fem::double0;
  double smext = fem::double0;
  int num2 = fem::int0;
  int num3 = fem::int0;
  int num4 = fem::int0;
  int num5 = fem::int0;
  int i = fem::int0;
  int mloc = fem::int0;
  double extrs = fem::double0;
  double hico = fem::double0;
  int n167 = fem::int0;
  int il1 = fem::int0;
  int il2 = fem::int0;
  int il = fem::int0;
  int iexc = fem::int0;
  int n14 = fem::int0;
  int n8 = fem::int0;
  int ij = fem::int0;
  int n7 = fem::int0;
  int n55 = fem::int0;
  int ioutr = fem::int0;
  int iall = fem::int0;
  int n16 = fem::int0;
  int ivar = fem::int0;
  int ipl = fem::int0;
  int n6 = fem::int0;
  int kflag = fem::int0;
  int n21 = fem::int0;
  int n17 = fem::int0;
  arr_1d<165, int> npbuf(fem::fill0);
  int ijn = fem::int0;
  int ijk = fem::int0;
  int ijl = fem::int0;
  int n30 = fem::int0;
  int jj3 = fem::int0;
  int jkm = fem::int0;
  int jkn = fem::int0;
  int ids = fem::int0;
  int ip1 = fem::int0;
  int n2 = fem::int0;
  int i72 = fem::int0;
  int niunrs = fem::int0;
  int n18 = fem::int0;
  int n3 = fem::int0;
  double d11 = fem::double0;
  int m = fem::int0;
  int ndx1 = fem::int0;
  int n3671 = fem::int0;
  int nfirst = fem::int0;
  int m1 = fem::int0;
  int ndy5 = fem::int0;
  int ip = fem::int0;
  int k1 = fem::int0;
  int k2 = fem::int0;
  int n4 = fem::int0;
  double elf = fem::double0;
  double elaf = fem::double0;
  double elfkd = fem::double0;
  double elakd = fem::double0;
  double elkd = fem::double0;
  double elg = fem::double0;
  double elag = fem::double0;
  double elgkq = fem::double0;
  double elakq = fem::double0;
  double elkq = fem::double0;
  double rf = fem::double0;
  double rkd = fem::double0;
  double rg = fem::double0;
  double rkq = fem::double0;
  double zb3 = fem::double0;
  double zb1 = fem::double0;
  static const char* format_105 = "(6e10.6,19x,i1)";
  static const char* format_156 =
    "(10x,'APPROXIMATE CHARACTERISTIC FOR THE Q-AXIS, MACHINE NO.',i5,/,14x,"
    "'QSAT12',14x,'QSAT10',/,2(6x,e14.5))";
  static const char* format_3628 = "('+  5TH S.M. CARD.',3f10.4)";
  static const char* format_3637 = "('+  6TH S.M. CARD.',3f10.4)";
  static const char* format_3662 =
    "(1x,10('*'),'  WARNING  ',10('*'),3x,' REQUEST FOR NONEXISTENT VARIABLE',"
    "i4,' IN CLASS',i3,' OF S.M. NO. ',i3,' DISCARDED. ',/,' IN THIS CLASS',"
    "' THE ABOVE S.M. CAN HAVE NUMBERS BETWEEN 1(ONE) AND',i4)";
  static const char* format_6110 =
    "('  ****** WARNING, WARNING ******',/,"
    "'  SUBROUTINE SMDAT, NEARBY STATEMENT NUMBER',i8,/,"
    "'  SATURATION TRESHOLD RESET FROM',2x,e15.8,3x,'TO',2x,e15.8)";
  //C     THIS MODULE IS USED ONLY BY TYPE-59 BRANDWAJN  S.M.  MODEL        M31. 879
  //C     THE FOLLOWING ARRAY IS SIZED 3 (NN4-1) * N50 ( N50 = 50  AT PRE-  M39.1266
  //C     SENT ) + NN10 ( NO. OF CLASS 1 REQUESTS <=15 AT PRESENT> ) ****** M39.1267
  //C!      EQUIVALENCE (ISMDAT(22),IPOUT), (ISMDAT(23),N56), ( ISMDAT(24),   M39.1269
  //C!     1 ISMOLD), (ISMDAT(25),NN10), (ISMDAT(26),NN4), (ISMDAT(27),NN14)  M37.2652
  //C!DIMENSION MASSEX(1)
  //C!EQUIVALENCE (HISTQ(1),MASSEX(1))
  ipout = ismdat(22);
  n56 = ismdat(23);
  ismold = ismdat(24);
  nn10 = ismdat(25);
  nn4 = ismdat(26);
  nn14 = ismdat(27);
  //C
  kaliu = sptacs(11);
  kiuty = sptacs(13);
  kud1 = sptacs(14);
  klntab = sptacs(18);
  niu = lstat(54);
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE SMDAT.\"')");
  }
  //C     DEFINE NO. OF OUTPUTS IN CLASS 1 (NN10) AND NO. OF CLASSES (NN4)**M33. 324
  nn10 = 15;
  ismdat(25) = nn10;
  nn4 = 4;
  ismdat(26) = nn4;
  nn14 = 14;
  ismdat(27) = nn14;
  n50 = 50;
  nright = 0;
  nfrfld = 1;
  d10 = 1.0f / cmn.fltinf;
  if (numsm > 1) {
    goto statement_123;
  }
  rinfin(cmn);
  n19 = voltbc.size(); // locf(flstat(1)) - locf(voltbc(1));
  if (n19 >= 41) {
    goto statement_8258;
  }
  kill = 180;
  lstat(18) = nchain;
  lstat(19) = 8258;
  lstat(17) = 41;
  lstat(16) = n19;
  goto statement_9999;
statement_8258:
  d8 = 3.0f / 2.0f;
  thtw = sqrtz(d8);
  cmn.athtw = 1.0f / thtw;
  d8 = 3.0f;
  sqrt3 = sqrtz(d8);
  cmn.asqrt3 = 1.0f / sqrt3;
  cmn.sqrt32 = sqrt3 * onehaf;
  cmn.omdt = omega * cmn.deltat;
  cmn.radeg = 360.0f / cmn.twopi;
  bdam = 1.356306e0 * tenm6;
  bin = .0421409745e0;
  nst = 0;
  cmn.itold = it;
  cmn.ibrold = ibr;
  ismold = 0;
  ismdat(24) = ismold;
  ipout = 0;
  ismdat(22) = ipout;
  n56 = (nn4 - 1) * n50 + nn10;
  ismdat(23) = n56;
  mfirst = 6 * limass;
  d8 = nbyte(3);
  d8 = d8 / nbyte(4);
  om2 = d8;
  d8 = mfirst * d8 - 1.0f;
  mfirst = d8;
statement_123:
  jk = numsm;
  ism = 0;
  fm = -2.0f;
  k = nst + 1;
  if (k <= lsyn) {
    goto statement_8818;
  }
  kill = 1;
  lstat(19) = 123;
  lstat(16) = 17;
  goto statement_9999;
statement_8818:
  j30 = 30 * jk - 29;
  ismdat(j30) = 0;
  cmn.statfr = sfreq(kconst - 1);
  idelta = 0;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' AT START OF  ''SMDAT''  ...',"
      "'       K     NST   MTYPE  KCONST   NUMSM',/,24x,10i8)"),
      k, nst, mtype, kconst, numsm;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M20.1371
statement_1:
  cimage(cmn);
  if (kill > 0) {
    goto statement_9999;
  }
  nright = -2;
  n11 = kolbeg;
  kolbeg = 1;
  freone(cmn, d1);
  nright = 0;
  //C     CHECK FOR KEY WORD   'TOLERANCES'  (OR  'T' ).                    M22.3074
  if (texta6(1) == text19) {
    goto statement_7103;
  }
  if (texta6(1) != text2) {
    goto statement_7106;
  }
  if (texta6(2) != text3) {
    goto statement_7106;
  }
statement_7103:
  if (n11 > 0) {
    goto statement_7104;
  }
  read(abuff, "(10x,3e10.0,10x,i10)"), d1, d2, d3, n9;
  goto statement_7105;
statement_7104:
  nfrfld = 1;
  freone(cmn, d1);
  freone(cmn, d2);
  freone(cmn, d3);
  frefld(cmn, voltbc(1));
  n9 = voltbc(1);
statement_7105:
  if (d1 > 0.0f) {
    epsuba = d1;
  }
  if (d2 > 0.0f) {
    epomeg = d2;
  }
  if (d3 > 0.0f) {
    epdgel = d3;
  }
  if (n9 > 0) {
    iprsov(37) = n9;
  }
  if (noutpr == 0) {
    write(kunit6, "('+  EPSILON.',3e11.2,i5)"), epsuba, epomeg,
      epdgel, iprsov(37);
  }
  goto statement_1;
  //C     CHECK FOR KEY WORD   'PARAMETER FITTING'  (OR  'PF' ).            M22.3082
statement_7106:
  if (texta6(1) == text20) {
    goto statement_2115;
  }
  if (texta6(1) != text7) {
    goto statement_8641;
  }
  if (texta6(2) != text8) {
    goto statement_8641;
  }
  if (texta6(3) != text17) {
    goto statement_8641;
  }
  if (texta6(4) != text18) {
    goto statement_8641;
  }
statement_2115:
  if (n11 > 0) {
    goto statement_7109;
  }
  read(abuff, "(24x,e8.0)"), fm;
  goto statement_7110;
statement_7109:
  nfrfld = 1;
  freone(cmn, fm);
statement_7110:
  if (fm > 1.0f) {
    goto statement_152;
  }
  ism = 1;
  goto statement_153;
statement_152:
  ism = 0;
  fm = 1.0f;
statement_153:
  if (noutpr == 0) {
    write(kunit6, "('+  OPTIMIZE PARK''S DATA.',3x,e12.3)"), fm;
  }
  goto statement_1;
  //C     CHECK FOR KEY WORD   'DELTA CONNECTION'  (OR  'DC' ).             M22.3092
statement_8641:
  if (texta6(1) == text21) {
    goto statement_2125;
  }
  if (texta6(1) != text10) {
    goto statement_8659;
  }
  if (texta6(2) != text11) {
    goto statement_8659;
  }
  if (texta6(3) != text12) {
    goto statement_8659;
  }
statement_2125:
  if (noutpr == 0) {
    write(kunit6, "('+  NOTIFICATION OF DELTA-CONNECTED ARMATURE.')");
  }
  idelta = 1;
  goto statement_1;
statement_8659:
  kolbeg = n11;
  ismdat(j30)++;
  nst++;
  if (nst <= lsyn) {
    goto statement_8819;
  }
  kill = 1;
  lstat(19) = 8659;
  lstat(16) = 17;
  goto statement_9999;
statement_8819:
  k = nst;
  i101 = 101 * k - 100;
  i26 = i101;
  i30 = 30 * k - 29;
  ismdat(i30 + 1) = idelta;
  if (kolbeg > 0) {
    goto statement_7113;
  }
  read(abuff, "(3i2,i4,7e10.6)"), ismdat(i30 + 11), ismdat(i30 + 12),
    ismdat(i30 + 13), np, sm3, sm4, rmva, rkv, aglin, dab, dac;
  goto statement_7114;
statement_7113:
  nfrfld = 4;
  frefld(cmn, voltbc(1));
  ismdat(i30 + 11) = voltbc(1);
  ismdat(i30 + 12) = voltbc(2);
  ismdat(i30 + 13) = voltbc(3);
  np = voltbc(4);
  nfrfld = 1;
  freone(cmn, sm3);
  freone(cmn, sm4);
  freone(cmn, rmva);
  freone(cmn, rkv);
  freone(cmn, aglin);
  freone(cmn, dab);
  freone(cmn, dac);
statement_7114:
  if (noutpr == 0) {
    write(kunit6, "('+  4TH S.M. CARD.',4i4,2f7.3)"), ismdat(i30 + 11),
      ismdat(i30 + 12), ismdat(i30 + 13), np, sm3, sm4;
  }
  elp(i26 + 25) = np / 2;
  if (sm3 == 0.0f) {
    sm3 = d10;
  }
  if (sm4 == 0.0f) {
    sm4 = d10;
  }
  elp(i26 + 28) = sm3;
  elp(i26 + 29) = sm4;
  numask = ismdat(i30 + 11);
  if (numask < 0) {
    goto statement_306;
  }
  iln = ismold * 12;
  ismold += numask;
  ismdat(24) = ismold;
  if (ismold <= limass) {
    goto statement_8;
  }
  kill = 1;
  lstat(19) = 300;
  lstat(16) = 16;
  goto statement_9999;
statement_306:
  kill = 105;
  lstat(19) = 306;
  lstat(14) = numask;
  lstat(18) = nchain;
  goto statement_9999;
statement_8:
  ismdat(i30 + 8) = 0;
  if (aglin > 0.0f) {
    goto statement_150;
  }
  ismdat(i30 + 8) = 2;
statement_150:
  aglin = std::abs(aglin);
  //C     READ  INPUT  CARDS  USING  CIMAGE                                 M23.1169
  cimage(cmn);
  read(abuff, "(10x,7e10.6)"), ad1, ad2, aq1, aq2, qaa, qab, qac;
  if (noutpr == 0) {
    write(kunit6, "('+  Q-AXIS',f7.3,3f10.4)"), aq1, qaa, qab, qac;
  }
  //C     READ INPUT CARD USING CIMAGE.                                     M28.4236
  cimage(cmn);
  zb = (fem::pow2(rkv)) / rmva;
  //C     IF( IDELTA  .EQ.  1  )  ZB = 3.D0 * ZB                            M39.1277
  emf = rkv / (cmn.tenm3 * aglin);
  if (fm <= -1.0f) {
    goto statement_100;
  }
  if (kolbeg > 0) {
    goto statement_7124;
  }
  read(abuff, "(8e10.6)"), ra, xl, xd, xq, xdp, xqp, xdpp, xqpp;
  goto statement_7125;
statement_7124:
  freone(cmn, ra);
  freone(cmn, xl);
  freone(cmn, xd);
  freone(cmn, xq);
  freone(cmn, xdp);
  freone(cmn, xqp);
  freone(cmn, xdpp);
  freone(cmn, xqpp);
statement_7125:
  if (noutpr == 0) {
    write(kunit6, format_3628), ra, xl, xd;
  }
  //C     CHECK FOR AN ERROR IN REACTANCE VALUES ***************************M20.1484
  if (ra < 0.0f) {
    goto statement_19;
  }
  if (xl < 0.0f) {
    goto statement_19;
  }
  if (xd < 0.0f) {
    goto statement_19;
  }
  if (xq < 0.0f) {
    goto statement_19;
  }
  if (xdp < 0.0f) {
    goto statement_19;
  }
  if (xqp < 0.0f) {
    goto statement_19;
  }
  if (xdpp < 0.0f) {
    goto statement_19;
  }
  if (xqpp < 0.0f) {
    goto statement_19;
  }
  if ((xd - xdp) <= flzero && fm == 0.0f) {
    goto statement_19;
  }
  if ((xdp - xdpp) <= flzero) {
    goto statement_19;
  }
  if ((xdpp - xl) <= flzero) {
    goto statement_19;
  }
  ndwqa = 0;
  if (xq == xqp && xqp == xqpp) {
    ndwqa = -2;
  }
  if (ndwqa < 0) {
    goto statement_25;
  }
  if ((xq - xqp) <= flzero && fm == 0.0f) {
    goto statement_19;
  }
  if ((xqp - xqpp) <= flzero) {
    goto statement_19;
  }
  if ((xqpp - xl) <= flzero) {
    goto statement_19;
  }
  goto statement_25;
statement_19:
  kill = 176;
  goto statement_9999;
statement_25:
  //C     CONVERT MACHINE PARAMETERS TO PHYSICAL VALUES ,THIS WILL  RESULT  M39.1278
  //C     IN ALL DATA BEING REFERRED TO THE ROTOR SIDE ******************** M39.1279
  xq = xq * zb;
  xd = xd * zb;
  xl = xl * zb;
  ra = ra * zb;
  if (iprsup > 0) {
    write(kunit6, format_3628), ra, xl, xd;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M20.1515
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_7136;
  }
  read(abuff, "(7e10.6,9x,i1)"), tdop, tqop, tdopp, tqopp, el2, r1, el1;
  goto statement_7137;
statement_7136:
  freone(cmn, tdop);
  freone(cmn, tqop);
  freone(cmn, tdopp);
  freone(cmn, tqopp);
  freone(cmn, el2);
  freone(cmn, r1);
  freone(cmn, el1);
statement_7137:
  if (noutpr == 0) {
    write(kunit6, format_3637), tdop, tqop, tdopp;
  }
  //C     PROCESS MANUFACTURER'S DATA ,START WITH THE D-AXIS ************** M37.2697
  x1(1) = xd;
  x1(2) = xdp * zb;
  x1(3) = xdpp * zb;
  x1(4) = tdopp * omega;
  x1(5) = tdop * omega;
  x1(6) = xl;
  smpfit(cmn, x1(1), ism, fm, lunit6, noutpr);
  //C     CALCULATE TRANSFORMER RATIO FOR SCALING OF ROTOR CIRCUITS ********M20.1555
  a = x1(2) / thtw;
  rat = emf / a;
  rat2 = 2.0f * fem::pow2(rat) / 3.0f;
  a = emf * rat / thtw;
  //C     LOAD PROCESSED DATA INTO PERMANENT STORAGE ********************** M37.2706
  ib2 = 20;
  move0(elp, i26, ib2);
  elp(i26) = xd;
  elp(i26 + 1) = emf;
  if (x1(5) == 0) {
    goto statement_6014;
  }
  elp(i26 + 2) = x1(3) * rat2;
  elp(i26 + 3) = emf;
  elp(i26 + 4) = a;
  elp(i26 + 5) = x1(4) * rat2;
  elp(i26 + 6) = x1(5) * rat2;
  elp(i26 + 7) = x1(6) * rat2;
  goto statement_6015;
statement_6014:
  elp(i26 + 2) = x1(4) * rat2;
  elp(i26 + 5) = rat2;
  elp(i26 + 6) = x1(6) * rat2;
statement_6015:
  rat1 = emf / x1(2);
  //C     QUADRATURE AXIS PARAMETERS ***************************************M20.1577
  elp(i26 + 8) = xq;
  if (ndwqa < 0) {
    goto statement_6013;
  }
  x1(1) = xq;
  x1(2) = xqp * zb;
  x1(3) = xqpp * zb;
  x1(4) = tqopp * omega;
  x1(5) = tqop * omega;
  x1(6) = xl;
  smpfit(cmn, x1(1), ism, fm, lunit6, noutpr);
  a = x1(2) * rat / thtw;
  elp(i26 + 9) = a;
  if (x1(5) == 0.f) {
    goto statement_71;
  }
  elp(i26 + 10) = x1(3) * rat2;
  elp(i26 + 11) = a;
  elp(i26 + 12) = x1(2) * rat2;
  elp(i26 + 13) = x1(4) * rat2;
  elp(i26 + 14) = x1(5) * rat2;
  elp(i26 + 15) = x1(6) * rat2;
  goto statement_70;
statement_71:
  elp(i26 + 10) = x1(4) * rat2;
  elp(i26 + 13) = rat2;
  elp(i26 + 14) = x1(6) * rat2;
  goto statement_70;
statement_6013:
  elp(i26 + 10) = rat2;
  elp(i26 + 13) = rat2;
  //C     STORE REMAINING VARIABLES *************************************** M37.2745
statement_70:
  elp(i26 + 16) = el2 * zb + 3.0f * el1;
  elp(i26 + 17) = ra + 3.0f * r1;
  elp(i26 + 18) = xl;
  elp(i26 + 19) = ra;
  elp(i26 + 20) = rat1;
  //C     CALCULATE AND STORE SATURATION CONSTANTS ************************ M37.2751
  if (ismdat(i30 + 8) == 0) {
    goto statement_158;
  }
  //C     START   WITH   THE  D-AXIS   CHARACTERISTIC***********************M23.1197
  //C     CHECK FOR INCONSISTENT SATURATION DATA ***************************M23.1198
  if (dab >= aglin && dac > dab) {
    goto statement_167;
  }
  kill = 211;
  lstat(14) = k;
  lstat(19) = 167;
  flstat(13) = aglin;
  flstat(14) = dab;
  flstat(15) = dac;
  goto statement_9999;
statement_167:
  if (ad1 <= 0.0f) {
    ad1 = 1.0f;
  }
  if (ad2 <= 0.0f) {
    ad2 = 1.2f;
  }
  sf5 = dab / (aglin * ad1);
  sf2 = dac / (aglin * ad2);
  sf3 = (sf2 - sf5) / (dac - dab);
  sf6 = dac + (1.0f - sf2) / sf3;
  if (sf6 > (aglin * onehaf)) {
    goto statement_437;
  }
  //C     RESET SATURATION PARAMETERS ************************************* M39.1289
  dsm = rkv / aglin;
  hsp = rkv * (ad2 - ad1) / (dac - dab);
  dsd = rkv * ad1 - hsp * dab;
  dsr = dsd / (dsm - hsp);
  ilv = 167;
  write(lunit6, format_6110), ilv, sf6, dsr;
  sf6 = dsr;
  sf3 = (1.0f - sf2) / (sf6 - dac);
statement_437:
  elp(i26 + 21) = sf6;
  elp(i26 + 22) = sf3;
  if (iprsup >= 1) {
    write(lunit6,
      "(1x,' SATURATION CONSTANTS.',7x,'K',11x,'SF3',11x,'SF6',11x,'SF5',11x,"
      "'SF2',/,22x,i8,4e14.5,/,1x)"),
      k, sf3, sf6, sf5, sf2;
  }
  //C     CALCULATE  PARAMETERS  FOR  THE  Q-AXIS **************************M23.1216
  if (qaa > 0.0f) {
    goto statement_157;
  }
  //C     UNKNOWN   PARAMETERS-CALCULATE AN  APPROXIMATE CHARACTERISTIC ****M23.1219
  b6 = (elp(i26 + 8) - xl) / (elp(i26) - xl);
  sf6 = sf6 * b6;
  elp(i26 + 23) = sf6;
  elp(i26 + 24) = sf3;
  if (iprsup >= 1) {
    write(lunit6, format_156), k, sf3, sf6;
  }
  goto statement_158;
  //C     KNOWN  PARAMETERS , CALCULATE CONSTANTS **************************M23.1227
  //C     CHECK FOR MISSING  SATURATION DATA FOR THE Q-AXIS ****************M23.1228
statement_157:
  if (qab >= qaa && qac > qab) {
    goto statement_166;
  }
  kill = 211;
  lstat(19) = 157;
  lstat(14) = k;
  flstat(13) = qaa;
  flstat(14) = qab;
  flstat(15) = qac;
  goto statement_9999;
statement_166:
  if (aq1 <= 0.0f) {
    aq1 = 1.0f;
  }
  if (aq2 <= 0.0f) {
    aq2 = 1.2f;
  }
  sf5 = qab / (qaa * aq1);
  sf2 = qac / (qaa * aq2);
  sf3 = (sf2 - sf5) / (qac - qab);
  sf6 = qac + (1.0f - sf2) / sf3;
  if (sf6 > (qaa * onehaf)) {
    goto statement_439;
  }
  dsm = rkv / qaa;
  hsp = rkv * (aq2 - aq1) / (qac - qab);
  dsd = rkv * aq1 - hsp * qab;
  dsr = dsd / (dsm - hsp);
  ilv = 166;
  write(lunit6, format_6110), ilv, sf6, dsr;
  sf6 = dsr;
  sf3 = (1.0f - sf2) / (sf6 - dac);
statement_439:
  elp(i26 + 23) = sf6;
  elp(i26 + 24) = sf3;
  if (iprsup >= 1) {
    write(lunit6, format_156), k, sf3, sf6, sf5, sf2;
  }
  //C     PROCESS MECHANICAL DATA OF THE GENERATOR  *********************** M38.1490
  //C     SCALE THE MECHANICAL DATA TO MKS UNITS   *************************M37.2767
  //C     THIS SCALING OF DATA CORRESPONDS TO TORQUE GIVEN IN MVA  *********M37.2768
statement_158:
  smext = 0.f;
  num2 = numask + numask;
  num3 = num2 + numask;
  num4 = num2 + num2;
  num5 = num3 + num2;
  ib2 = iln + num2;
  FEM_DO_SAFE(i, 1, numask) {
    //C     READ INPUT CARD USING CIMAGE                                      M20.1606
    cimage(cmn);
    if (kolbeg > 0) {
      goto statement_7144;
    }
    read(abuff, "(i2,8x,6e10.6)"), mloc, extrs, hico, dsr, dsm, hsp, dsd;
    goto statement_7145;
  statement_7144:
    frefld(cmn, voltbc(1));
    if (kill > 0) {
      goto statement_9999;
    }
    mloc = voltbc(1);
    nfrfld = 1;
    freone(cmn, extrs);
    freone(cmn, hico);
    freone(cmn, dsr);
    freone(cmn, dsm);
    freone(cmn, hsp);
    freone(cmn, dsd);
  statement_7145:
    if (mloc > 0 && mloc <= numask) {
      goto statement_7146;
    }
    n167 = 7145;
    kill = 181;
    lstat(19) = n167;
    lstat(18) = nchain;
    lstat(15) = mloc;
    lstat(16) = numask;
    goto statement_9999;
  statement_7146:
    if (noutpr == 0) {
      write(kunit6, "('+  MASS CARD',i2,i2,3e11.3)"), i, mloc, extrs, hico, dsd;
    }
    il1 = ib2 + mloc;
    shp(il1) = extrs;
    shp(il1 + numask) = hico * bin;
    shp(il1 + num2) = dsm * bdam;
    shp(il1 + num3) = hsp * bdam / tenm6;
    shp(il1 + num4) = dsd * bdam;
    shp(il1 + num5) = dsr * bdam;
    smext += extrs;
  }
  if (numask == 1) {
    smext = 1.0f;
  }
  if (std::abs(smext) > flzero) {
    goto statement_410;
  }
  kill = 107;
  lstat(19) = 420;
  goto statement_9999;
statement_410:
  il2 = ib2 + numask;
  il1 = ib2 + 1;
  FEM_DO_SAFE(il, il1, il2) {
    shp(il) = shp(il) / smext;
  }
  //C     CHECK FOR BLANK CARD TERMINATING MASS CARDS  *********************M33. 400
  //C     READ INPUT CARD USING CIMAGE   ***********************************M33. 401
  cimage(cmn);
  {
    read_loop rloop(abuff(1), "(41f1.0)");
    FEM_DO_SAFE(i, 1, 41) {
      rloop, voltbc(i);
    }
  }
  n167 = 3654;
  if (kill > 0) {
    goto statement_9999;
  }
  //C     SET-UP DUMMY BRANCHES TO RESERVE SPACE FOR FUTURE USE  ***********M33. 411
  if (it + 6 <= cmn.ldata) {
    goto statement_8917;
  }
  kill = 1;
  lstat(19) = 8917;
  lstat(16) = 3;
  goto statement_9999;
statement_8917:
  if (ibr + 3 <= cmn.lbrnch) {
    goto statement_8921;
  }
  kill = 1;
  lstat(19) = 8921;
  lstat(16) = 2;
  goto statement_9999;
statement_8921:
  FEM_DO_SAFE(il, 1, 3) {
    it++;
    ibr++;
    length(ibr) = 1;
    kbus(ibr) = 1;
    mbus(ibr) = 1;
    nr(ibr) = -it;
    tr(it) = 1.0f;
    tx(it) = 0.0f;
    c(it) = 0.0f;
  }
  it += 3;
  //C     READ OUTPUT SPECIFICATION CARD. ISMOUT IS ARRAY OF OUTPUT FLAGS.  M20.1670
  //C     ZERO-OUT OUTPUT REQUEST ARRAYS. PRESET FLAGS FOR PARAMETER OUTPUT M33. 412
  //C     REQUESTS     *****************************************************M33. 413
  iexc = 0;
  if (ismdat(i30 + 13) == 0) {
    iexc = 1;
  }
  n14 = i30 + 20;
  n8 = n14 - 3;
  FEM_DO_SAFE(il, n8, n14) {
    ismdat(il) = 0;
  }
  elp(i26 + 26) = 0.0f;
  elp(i26 + 27) = 0.0f;
  ism = 0;
  n8 = n8 - 1;
  FEM_DO_SAFE(ij, 1, 41) {
    if (voltbc(ij) != 0.0f) {
      goto statement_1983;
    }
  }
  if (noutpr == 0) {
    write(kunit6, "('+ BLANK CARD TERMINATING MASS CARDS.')");
  }
  //C     READ INPUT CARD USING CIMAGE                                      M33. 429
statement_7219:
  cimage(cmn);
  read(abuff, "(i8)"), n7;
  if (n7 != 0) {
    goto statement_8235;
  }
  if (noutpr == 0) {
    write(kunit6, "('+ BLANK CARD TERMINATING OUTPUT REQUESTS.')");
  }
  goto statement_7251;
  //C     CHECK FOR OVERFLOW OF NPBUF() *********************************** M39.1316
statement_8235:
  n55 = (nn4 - 1) * numask + nn10;
  if (n55 < n56) {
    goto statement_7220;
  }
  kill = 111;
  lstat(13) = n56;
  lstat(15) = k;
  lstat(16) = n55;
  lstat(17) = 0;
  lstat(19) = 8235;
  goto statement_9999;
statement_7220:
  {
    read_loop rloop(abuff(1), "(2x,2f1.0,4x,12f6.0)");
    FEM_DO_SAFE(i, 1, nn14) {
      rloop, voltbc(i);
    }
  }
  ioutr = voltbc(1);
  iall = voltbc(2);
  if (ioutr > 0 && ioutr <= (nn4 + 1)) {
    goto statement_7221;
  }
  write(lunit6,
    "(1x,10('*'),'  WARNING  ',10('*'),3x,"
    "' REQUEST FOR NONEXISTENT OUTPUT CLASS ',i4,'  NEGLECTED.')"),
    ioutr;
  goto statement_7219;
statement_7221:
  if (noutpr == 0) {
    write(kunit6, "('+',2x,' OUTPUT REQUEST CARD FOR CLASS',i4)"), ioutr;
  }
  switch (ioutr) {
  case 1: goto statement_7230;
  case 2: goto statement_7240;
  case 3: goto statement_7240;
  case 4: goto statement_7250;
  case 5: goto statement_7210;
  default: break;
  }
  //C     PROCESS FLAGS FOR OUTPUTS AFTER THE S.S. SOLUTION  ***************M33. 451
statement_7210:
  n16 = 2;
  ivar = 0;
  FEM_DO_SAFE(ipl, 3, nn14) {
    n6 = voltbc(ipl);
    if (iall == 0) {
      goto statement_7213;
    }
    n6 = ipl - 2;
    goto statement_7212;
  statement_7213:
    if (n6 > -1 && n6 <= n16) {
      goto statement_7212;
    }
    write(lunit6, format_3662), n6, ioutr, k, n16;
    goto statement_7211;
  statement_7212:
    if (n6 == 0) {
      goto statement_7211;
    }
    ivar++;
    if (ivar > n16) {
      goto statement_7219;
    }
    kflag = i26 + n6;
    elp(kflag + 25) = n6;
  statement_7211:;
  }
  goto statement_7219;
statement_7230:
  n16 = nn10 - iexc;
  n21 = 0;
statement_7231:
  n17 = n8 + ioutr;
  n21 += ismdat(n17);
  if (iall > 0) {
    goto statement_7238;
  }
  FEM_DO_SAFE(il, 3, nn14) {
    n6 = voltbc(il);
    if (n6 <= n16 && n6 > -1) {
      goto statement_7233;
    }
    write(lunit6, format_3662), n6, ioutr, k, n16;
    goto statement_7232;
  statement_7233:
    if (n6 == 0) {
      goto statement_7232;
    }
    ism++;
    n21++;
    ismdat(n17)++;
    npbuf(n21) = n6;
    //C     REMOVE DUPLICATE REQUSTS. PUT ALL REQUEST IN AN ASCENDING ORDER   M33. 488
    ipl = ismdat(n17) - 1;
    if (ipl < 1) {
      goto statement_7232;
    }
    ijn = n21;
    FEM_DO_SAFE(ijk, 1, ipl) {
      ijl = ijn - 1;
      if (npbuf(ijl) < npbuf(ijn)) {
        goto statement_7232;
      }
      if (npbuf(ijl) == npbuf(ijn)) {
        goto statement_7245;
      }
      n30 = npbuf(ijl);
      npbuf(ijl) = npbuf(ijn);
      npbuf(ijn) = n30;
      ijn = ijn - 1;
    }
    goto statement_7232;
    //C     DISCARD DUPLICATE REQUEST ****************************************M33. 501
  statement_7245:
    write(lunit6,
      "(1x,10('*'),'  WARNING  ',10('*'),3x,' DUPLICATE REQUEST',i5,"
      "'  IN CLASS',i5,'  DISCARDED.')"),
      npbuf(ijn), ioutr;
    ism = ism - 1;
    ismdat(n17) = ismdat(n17) - 1;
    FEM_DO_SAFE(ijk, ijn, ipl) {
      npbuf(ijk) = npbuf(ijk + 1);
    }
  statement_7232:;
  }
statement_7234:
  if ((ipout + ism) <= lsmout) {
    goto statement_7219;
  }
  kill = 111;
  lstat(19) = 7234;
  lstat(13) = lsmout;
  lstat(15) = k;
  lstat(16) = ipout + ism;
  lstat(17) = 0;
  goto statement_9999;
statement_7238:
  if (n16 > 0) {
    goto statement_7239;
  }
  write(lunit6, format_3662), n16, ioutr, k, n16;
  goto statement_7234;
statement_7239:
  n21 = n21 - ismdat(n17);
  ismdat(n17) = 0;
  FEM_DO_SAFE(il, 1, n16) {
    ismdat(n17)++;
    ism++;
    n21++;
    npbuf(n21) = il;
  }
  goto statement_7234;
statement_7240:
  n16 = numask;
  n21 = nn10 + (ioutr - 2) * numask;
  goto statement_7231;
statement_7250:
  n16 = numask - 1;
  n21 = nn10 + (ioutr - 2) * numask;
  goto statement_7231;
  //C     PROCESSING OLD OUTPUT CARDS                                       M35. 985
statement_1983:
  n21 = 0;
  n17 = n8 + 1;
  jj3 = 31 + numask;
  jkm = -1;
  ij = 1;
statement_1125:
  if (ij == 13 || ij == 23 || ij == 33) {
    goto statement_1999;
  }
statement_1130:
  n6 = voltbc(ij);
  if (n6 > -1 && n6 <= 2) {
    goto statement_1155;
  }
  write(lunit6,
    "(1x,10('*'),'  WARNING  ',10('*'),/,'  THE OUTPUT REQUEST IN COLUMN',i4,"
    "'  DISCARDED','  BECAUSE OF THE WRONG NUMBER',i4,/,"
    "'  THE CORRECT NUMBER SHOULD BE 1 OR 2 . ')"),
    ij, n6;
  goto statement_1899;
statement_1155:
  if (n6 == 0) {
    goto statement_1899;
  }
  if (ij >= 3) {
    goto statement_1255;
  }
  kflag = i26 + ij;
  elp(kflag + 25) = ij;
  goto statement_1950;
statement_1255:
  if (ij != 3 && ij != 11) {
    goto statement_1355;
  }
  jkn = 0;
  if (ij == 11) {
    jkn = 7;
  }
  FEM_DO_SAFE(jk, 1, 3) {
    n21++;
    ismdat(n17)++;
    npbuf(n21) = jk + jkn;
  }
  if (ij == 3) {
    goto statement_1950;
  }
statement_1299:
  ij = ij - 3;
  goto statement_1130;
statement_1355:
  n21++;
  ismdat(n17)++;
  if (ij >= 13) {
    goto statement_1990;
  }
  npbuf(n21) = ij;
  if (ij == 8) {
    npbuf(n21) += 3;
  }
  if (ij == 9 || ij == 10) {
    npbuf(n21) += 5;
  }
statement_1899:
  if (ij == 11 || ij == 12) {
    goto statement_1299;
  }
  if (ij == 10) {
    ij += 2;
  }
  if (ij == 7 || ij == 8) {
    ij += 3;
  }
statement_1950:
  ij++;
  if (ij > jj3) {
    goto statement_7251;
  }
  goto statement_1125;
statement_1990:
  npbuf(n21) = ij - 12 - jkm * 10;
  goto statement_1950;
statement_1999:
  n17++;
  jkm++;
  n21 = nn10 + jkm * numask;
  goto statement_1130;
  //C     LOAD OUTPUT REQUESTS INTO PERMANENT STORAGE **********************M33. 537
statement_7251:
  ids = ipout + 1;
  n21 = 0;
  ip1 = 3 * ipout - 2;
  FEM_DO_SAFE(il, 1, 4) {
    n17 = n8 + il;
    n6 = ismdat(n17);
    if (n6 == 0) {
      goto statement_7252;
    }
    FEM_DO_SAFE(i, 1, n6) {
      ipout++;
      ismdat(22) = ipout;
      n21++;
      ip1 += 3;
      ismout(ip1) = npbuf(n21);
    }
  statement_7252:
    n21 = (il - 1) * numask + nn10;
  }
  if (ids > ipout) {
    ismdat(n8 + 1) = -10;
  }
  n2 = ntotac;
  i72 = 0;
  niunrs = ivarb(kiuty + 1);
  n18 = 3 * numask - 1;
  n19 = 17;
  FEM_DO_SAFE(i, 1, 9999) {
    //C     READ AUXILIARY INPUT TO TACS CARD                                 M20.1825
    //C     READ INPUT CARD USING CIMAGE                                      M20.1826
    cimage(cmn);
    if (kolbeg > 0) {
      goto statement_2183;
    }
    read(abuff, "(i2,2a6,i3)"), n3, bus6, bus5, iv;
    goto statement_2185;
  statement_2183:
    nfrfld = 1;
    if (kill > 0) {
      goto statement_9999;
    }
    freone(cmn, d11);
    n3 = d11;
    nfrfld = -2;
    freone(cmn, d1);
    bus6 = texta6(1);
    bus5 = texta6(2);
    nfrfld = 1;
    freone(cmn, d11);
    iv = d11;
    nfrfld = 0;
  statement_2185:
    if (bus6 != text1) {
      goto statement_3674;
    }
    n2 = ntotac - n2;
    if (noutpr != 0) {
      goto statement_7841;
    }
    if (cmn.bus3 != text16) {
      write(kunit6, "('+  END OF',i3,'  TACS INTERFACE VARIABLES.')"), n2;
    }
    if (bus5 == text16) {
      write(kunit6,
        "('+  END OF',i3,'  TACS INTERFACE VARIABLES.  PARALLEL')"),
        n2;
    }
  statement_7841:
    ismdat(i30 + 14) = n2;
    goto statement_205;
  statement_3674:
    if (n3 != 71) {
      goto statement_5431;
    }
    if (noutpr == 0) {
      write(kunit6, "('+  TACS CONTROLLED EXCITATION.  ''',a6,''' .')"), bus6;
    }
    FEM_DO_SAFE(m, 1, ktab) {
      ndx1 = ivarb(klntab + m);
      if (bus6 == texvec(ndx1)) {
        goto statement_3672;
      }
    }
    n3671 = 3676;
    goto statement_5448;
  statement_3672:
    ismdat(i30 + 15) = m;
    goto statement_204;
  statement_5431:
    if (n3 != 72) {
      goto statement_5460;
    }
    if (noutpr == 0) {
      write(kunit6,
        "('+  TACS CONTROLLED MECHANICAL TORQUE. ''',a6,''' .')"),
        bus6;
    }
    n3671 = 5434;
    if (i72 > 0) {
      goto statement_5434;
    }
    i72 = 1;
    ismdat(i30 + 16) = mfirst;
    //C     CHECK FOR POSSIBLE OVERFLOW ************************************* M38.1552
    nfirst = mfirst - numask;
    nsmout = 5 * ismold;
    d8 = nsmout * om2 + 1.0f;
    nsmout = d8;
    if (nfirst >= nsmout) {
      goto statement_5432;
    }
    kill = 1;
    lstat(19) = 5432;
    lstat(16) = 16;
    goto statement_9999;
  statement_5432:
    FEM_DO_SAFE(m, 1, numask) {
      m1 = mfirst - m;
      histq(m1) = 0;
    }
    m1 = mfirst;
    mfirst = nfirst;
    nfirst = m1;
  statement_5434:
    if (iv <= 0 || iv > numask) {
      goto statement_5448;
    }
    m1 = nfirst - iv;
    FEM_DO_SAFE(m, 1, ktab) {
      ndx1 = ivarb(klntab + m);
      if (bus6 == texvec(ndx1)) {
        goto statement_5455;
      }
    }
    n3671 = 5442;
  statement_5448:
    kill = 190;
    lstat(19) = n3671;
    lstat(14) = n3;
    lstat(15) = iv;
    goto statement_9999;
  statement_5455:
    histq(m1) = m;
    goto statement_204;
  statement_5460:
    if (noutpr == 0) {
      write(kunit6,
        "('+  AUXILIARY S.M. INPUT TO TACS.',i3,' ''',a6,'''',i3)"),
        n3, bus6, iv;
    }
    lstat(17) = 1;
    lstat(19) = 5461;
    if (iv > 0) {
      goto statement_5461;
    }
    goto statement_202;
  statement_5461:
    if (n3 != 74 && n3 != 73) {
      goto statement_202;
    }
    //C     LOAD ADDRESS OF BUS6 INTO TACS ARRAY 'UD1' ********************** M38.1588
    ndy5 = kud1;
    FEM_DO_SAFE(ip, niunrs, niu) {
      ndx1 = ivarb(kaliu + ip);
      m1 = ivarb(kiuty + ip);
      if (m1 != 92) {
        goto statement_5481;
      }
      if (bus6 != texvec(ndx1)) {
        goto statement_5481;
      }
      goto statement_5482;
    statement_5481:
      ndy5 += 5;
    }
    lstat(17) = -1;
    lstat(19) = 5481;
    goto statement_202;
  statement_5482:
    sptacs(ndy5 + 2) = ntotac + 1;
    if (n3 == 74) {
      goto statement_5463;
    }
    lstat(19) = 5462;
    if (iv > n19) {
      goto statement_202;
    }
    if (ismdat(i30 + 13) != 0) {
      goto statement_5463;
    }
    if (iv == 15) {
      goto statement_202;
    }
    iv = -iv;
    goto statement_5464;
  statement_5463:
    lstat(19) = 5463;
    if (iv > n18) {
      goto statement_202;
    }
  statement_5464:
    ntotac++;
    lstat(19) = 5464;
    if (ntotac > lbstac) {
      goto statement_202;
    }
    ismtac(ntotac) = iv;
    if (iprsup >= 2) {
      {
        write_loop wloop(cmn, lunit6,
          "(/,' NTOTAC =',i4,"
          "' .   (ISMTAC(J), J = 1, NTOTAC) FOLLOWS.         ',/(12(1x,i5)))");
        wloop, ntotac;
        FEM_DO_SAFE(n6, 1, ntotac) {
          wloop, ismtac(n6);
        }
      }
    }
    goto statement_204;
  statement_202:
    kill = 108;
    lstat(13) = fem::iabs(iv);
    lstat(14) = n3;
    lstat(15) = lbstac;
    lstat(16) = ntotac;
    goto statement_9999;
  statement_204:;
  }
statement_205:
  if (bus5 != text16) {
    goto statement_99;
  }
  ism = 0;
  fm = -2.0f;
  goto statement_1;
statement_99:
  if (iprsup <= 0) {
    goto statement_4793;
  }
  write(lunit6,
    "(/,/,' DUMP OF TABLES AT END OF  ''SMDAT'' .','   NUMSM  KCONST',11x,"
    "'RMVA',12x,'RKV',10x,'AGLIN',/,36x,2i8,3e15.7)"),
    numsm, kconst, rmva, rkv, aglin;
  FEM_DO_SAFE(k, 1, nst) {
    k1 = 30 * k;
    k2 = 101 * k;
    write(lunit6,
      "(/,' ROW','  IMDUAL  ICONFG   NUMAS    KMAC    KEXC     CNP',12x,'ELD',"
      "12x,'ELQ',12x,'ELF',10x,'ELFKD',10x,'ELAKD',/(1x,i3,5i8,f8.0,5e15.6))"),
      k, ismdat(k1 - 29), ismdat(k1 - 28), ismdat(k1 - 18), ismdat(k1 - 17),
      ismdat(k1 - 16), elp(k2 - 75), elp(k2 - 100), elp(k2 - 92), elp(k2 - 98),
      elp(k2 - 96), elp(k2 - 97);
    write(lunit6,
      "(/,' ROW',12x,'ELG',10x,'ELGKQ',12x,'EL0',11x,'ELAG',10x,'ELAKQ',11x,"
      "'ELKQ',11x,'ELKD',11x,'ELAF',/(1x,i3,8e15.6))"),
      k, elp(k2 - 90), elp(k2 - 88), elp(k2 - 84), elp(k2 - 91), elp(k2 - 89),
      elp(k2 - 87), elp(k2 - 95), elp(k2 - 99);
    write(lunit6,
      "(/,' ROW',13x,'RA',13x,'R0',13x,'RF',12x,'RKD',13x,'RG',12x,'RKQ',9x,"
      "'SMOUTP',9x,'SMOUTQ',/(1x,i3,8e15.6))"),
      k, elp(k2 - 81), elp(k2 - 83), elp(k2 - 94), elp(k2 - 93), elp(k2 - 86),
      elp(k2 - 85), elp(k2 - 72), elp(k2 - 71);
    n4 = k2 - 76;
    write(lunit6,
      "(/,' ROW',11x,'ISAT',10x,'SAT10',9x,'QSAT10',10x,'SAT12',9x,'QSAT12',"
      "11x,'RAT1',9x,'AGLINE',/(1x,i3,10x,i2,3x,6e15.6))"),
      k, ismdat(k1 - 21), elp(n4 - 3), elp(n4 - 1), elp(n4 - 2), elp(n4),
      elp(n4 - 4), elp(n4 - 6);
  }
  n2 = 0;
  FEM_DO_SAFE(k, 1, nst) {
    num2 = ismdat(30 * k - 18) * 2;
    n3 = n2 + num2 * 4;
    n2 += num2 + 1;
    {
      write_loop wloop(cmn, lunit6,
        "(/,' ''SHFDAT'' STORAGE CELLS FOLLOW ............',/(1x,8e16.7))");
      FEM_DO_SAFE(k2, n2, n3) {
        wloop, shp(k2);
      }
    }
    n2 = n3 + num2 * 2;
  }
statement_4793:
  return;
statement_100:
  //C     READ PER UNIT MACHINE DATA  AS NORMALLY DEFINED IN TRANSIENT      M20.1935
  //C     STABILITY PROGRAMS,I.E., OBTAINED WITH AN ASSYMMETRIC MATRIX      M20.1936
  if (kolbeg > 0) {
    goto statement_7313;
  }
  read(abuff, format_105), elf, elaf, elfkd, xd, elakd, elkd;
  goto statement_7314;
statement_7313:
  freone(cmn, elf);
  freone(cmn, elaf);
  freone(cmn, elfkd);
  freone(cmn, xd);
  freone(cmn, elakd);
  freone(cmn, elkd);
statement_7314:
  if (noutpr == 0) {
    write(kunit6, format_3628), elf, elaf, elfkd;
  }
  //C     READ INPUT CARD USING CIMAGE.                                     M20.1951
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_7327;
  }
  read(abuff, format_105), elg, elag, elgkq, xq, elakq, elkq;
  goto statement_7328;
statement_7327:
  freone(cmn, elg);
  freone(cmn, elag);
  freone(cmn, elgkq);
  freone(cmn, xq);
  freone(cmn, elakq);
  freone(cmn, elkq);
statement_7328:
  if (noutpr == 0) {
    write(kunit6, format_3637), elg, elag, elgkq;
  }
  //C     READ INPUT CARD USING CIMAGE.                                     M20.1966
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_7235;
  }
  read(abuff, "(8e10.6)"), el2, ra, rf, rkd, rg, rkq, r1, el1;
  goto statement_7236;
statement_7235:
  freone(cmn, el2);
  freone(cmn, ra);
  freone(cmn, rf);
  freone(cmn, rkd);
  freone(cmn, rg);
  freone(cmn, rkq);
  freone(cmn, r1);
  freone(cmn, el1);
statement_7236:
  if (noutpr == 0) {
    write(kunit6, "('+  7TH S.M. CARD.',3f10.4)"), el2, ra, rf;
  }
  elp(i26) = xd * zb;
  elp(i26 + 8) = xq * zb;
  elaf = elaf * zb;
  xl = (xd - elaf) * zb;
  ra = ra * zb;
  zb3 = zb;
  //C     CALCULATE THE TRANSFORMER RATIO  *********************************M20.1990
  a = elaf / thtw;
  rat = emf / a;
  rat2 = 2.0f * fem::pow2(rat) / 3.0f;
  rat1 = emf / elaf;
  elp(i26 + 1) = emf;
  zb1 = zb * rat2;
  elp(i26 + 2) = elf * zb1;
  elp(i26 + 4) = elfkd * zb1;
  elp(i26 + 5) = elkd * zb1;
  elp(i26 + 6) = rf * zb1;
  elp(i26 + 7) = rkd * zb1;
  elp(i26 + 10) = elg * zb1;
  elp(i26 + 12) = elgkq * zb1;
  elp(i26 + 13) = elkq * zb1;
  elp(i26 + 14) = rg * zb1;
  elp(i26 + 15) = rkq * zb1;
  zb = zb * rat / thtw;
  elp(i26 + 3) = elakd * zb;
  elp(i26 + 9) = elag * zb;
  elp(i26 + 11) = elakq * zb;
  zb = zb3;
  goto statement_70;
statement_9999:
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE SMDAT.\"')");
  }
}

struct over5a_save
{
  fem::str<8> text12;

  over5a_save() :
    text12(fem::char0)
  {}
};

void over5a(
  common& cmn)
{
  FEM_CMN_SVE(over5a);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& bus6 = cmn.bus6;
  const auto& texta6 = cmn.texta6;
  const auto& abuff = cmn.abuff;
  double& ck1 = cmn.ck1;
  double& deltat = cmn.deltat;
  double& delta2 = cmn.delta2;
  auto& twopi = cmn.twopi;
  double& omega = cmn.omega;
  auto& voltbc = cmn.voltbc;
  auto& flstat = cmn.flstat;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  int& inonl = cmn.inonl;
  int& iread = cmn.iread;
  int& istead = cmn.istead;
  int& ldata = cmn.ldata;
  int& lbrnch = cmn.lbrnch;
  int& lexct = cmn.lexct;
  int& lbus = cmn.lbus;
  int& lswtch = cmn.lswtch;
  int& ncomp = cmn.ncomp;
  int& nv = cmn.nv;
  int& numsm = cmn.numsm;
  int& noutpr = cmn.noutpr;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& kswtch = cmn.kswtch;
  int& it = cmn.it;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  const auto& sptacs = cmn.sptacs;
  auto& kswtyp = cmn.kswtyp;
  auto& topen = cmn.topen;
  auto& crit = cmn.crit;
  auto& isourc = cmn.isourc;
  auto& energy = cmn.energy;
  const auto& nltype = cmn.nltype;
  auto& ktrans = cmn.ktrans;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& r = static_cast<common_c0b064&>(cmn).r;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  auto& ismdat = cmn.ismdat;
  const auto& texvec = cmn.texvec;
  auto& ibrnch = cmn.ibrnch;
  auto& jbrnch = cmn.jbrnch;
  auto& tstop = cmn.tstop;
  auto& spum = cmn.spum;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  const auto& kdepsw = cmn.kdepsw;
  const auto& kodebr = cmn.kodebr;
  const auto& kodsem = cmn.kodsem;
  auto& iform = cmn.iform;
  auto& node = cmn.node;
  auto& crest = cmn.crest;
  auto& time1 = cmn.time1;
  auto& time2 = cmn.time2;
  auto& tstart = cmn.tstart;
  auto& sfreq = cmn.sfreq;
  auto& kmswit = cmn.kmswit;
  auto& tclose = cmn.tclose;
  auto& adelay = cmn.adelay;
  auto& kpos = cmn.kpos;
  auto& kode = cmn.kode;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;

  auto& bus = cmn.bus;
  auto& ksmspy = cmn.ksmspy;
  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;
  //
  fem::str<8>& text12 = sve.text12;
  if (is_called_first_time) {
    text12 = "TYP-16";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  //int klntab = fem::int0;
  int ll2 = fem::int0;
  int ll3 = fem::int0;
  int ll4 = fem::int0;
  int iprint = fem::int0;
  int kpu = fem::int0;
  int machfl = fem::int0;
  int n2 = fem::int0;
  int n1 = fem::int0;
  arr_1d<4, int> kpen(fem::fill0);
  int j = fem::int0;
  int n14 = fem::int0;
  double a = fem::double0;
  double d1 = fem::double0;
  double gus2 = fem::double0;
  double h1 = fem::double0;
  double h2 = fem::double0;
  double gus3 = fem::double0;
  double gus4 = fem::double0;
  double smang = fem::double0;
  double smamp = fem::double0;
  double smangl = fem::double0;
  int n2mach = fem::int0;
  int j30 = fem::int0;
  int i = fem::int0;
  int m = fem::int0;
  int ndx1 = fem::int0;
  double d2 = fem::double0;
  double h3 = fem::double0;
  double yx = fem::double0;
  int n3 = fem::int0;
  double reps = fem::double0;
  double dcfreq = fem::double0;
  int loutbr = fem::int0;
  int k = fem::int0;
  int k13 = fem::int0;
  int ndx2 = fem::int0;
  static const char* format_6304 = "(i2,a6,i2)";

  auto ispum = ArraySpan(reinterpret_cast<int*>(&spum(1)), spum.size() * sizeof(spum(1)) / sizeof(int));

  auto& klntab = sptacs(18);
  ll2 = 2;
  ll3 = 3;
  ll4 = 4;
  iread = 0;
  istead = 0;
  iprint = 4;
  kpu = 0;
  cmn.nsmout = 0;
  machfl = 0;
  cmn.numum = 0;
  move0(ksmspy, ll3);
  move0(kode, ntot);
  kode(1) = -1;
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2951
statement_310:
  cimage(cmn);
  if (kill > 0) {
    return;
  }
  if (machfl == 1) {
    goto statement_110;
  }
  if (machfl == 2) {
    goto statement_110;
  }
  if (machfl == 3) {
    machfl = 0;
  }
  if (kolbeg > 0) {
    goto statement_313;
  }
  read(abuff, format_6304), n2, bus1, n1;
  if (n2 != 18) {
    goto statement_6347;
  }
  //C     SPECIAL TYPE-18 INPUT EXTENDS PRECEDING SOURCE TO ALLOW           M32.1319
  //C     FOR UNGROUNDED 2ND TERMINAL AND IDEAL TRANSFORMER:                M32.1320
  kconst++;
  lstat(19) = 6304;
  iprint = 4;
  if (kconst > lexct) {
    goto statement_9000;
  }
  read(abuff, "(10x,e10.0,3a6)"), crest(kconst), bus2, bus3, bus4;
  move0(kpen, ll4);
  FEM_DO_SAFE(j, 1, ntot) {
    if (bus(j) != bus1) {
      goto statement_6313;
    }
    kpen(1) = j;
    node(kconst) = j;
    iform(kconst) = 18;
  statement_6313:
    if (bus(j) != bus2) {
      goto statement_6317;
    }
    kpen(2) = j;
    time2(kconst) = j;
  statement_6317:
    if (bus(j) != bus3) {
      goto statement_6322;
    }
    kpen(3) = j;
    sfreq(kconst) = j;
  statement_6322:;
  }
  if (kpen(1) != 0) {
    goto statement_6325;
  }
  bus6 = bus1;
  goto statement_6330;
statement_6325:
  if (kpen(2) != 0) {
    goto statement_6326;
  }
  bus6 = bus2;
  goto statement_6330;
statement_6326:
  if (kpen(3) != 0) {
    goto statement_6335;
  }
  bus6 = bus3;
statement_6330:
  write(lunit6,
    "('  ++++++  WARNING.  ++++++  TYPE-18',"
    "' SOURCE HAS UNRECOGNIZABLE NODE NAME  \"',a6,'\" .   DEVICE IGNORED.')"),
    bus6;
  kconst = kconst - 1;
  goto statement_310;
statement_6335:
  if (n1 != -1) {
    goto statement_6339;
  }
  //C     UNGROUNDED CURRENT SOURCE (NO TRANSFORMER ALLOWED):               M32.1355
  iform(kconst) = iform(kconst - 1);
  crest(kconst) = -crest(kconst - 1);
  node(kconst) = kpen(1);
  sfreq(kconst) = sfreq(kconst - 1);
  tstart(kconst) = tstart(kconst - 1);
  tstop(kconst) = tstop(kconst - 1);
  time1(kconst) = time1(kconst - 1);
  goto statement_310;
statement_6339:
  n14 = fem::iabs(node(kconst - 1));
  kode(n14) = 0;
  ntot++;
  ktrans(ntot) = -664422;
  iprint = 1;
  lstat(19) = 6335;
  if (ntot > lbus) {
    goto statement_9000;
  }
  bus(ntot) = bus4;
  time1(kconst) = ntot;
  iprint = 2;
  lstat(19) = 6343;
  if (ibr + 8 > lbrnch) {
    goto statement_9000;
  }
  iprint = 3;
  lstat(19) = 6343;
  if (it + 8 > ldata) {
    goto statement_9000;
  }
  kpen(4) = fem::iabs(node(kconst - 1));
  volti(ll4) = -1.0f;
  volti(1) = +1.0f;
  volti(ll2) = +1.0f / crest(kconst);
  volti(ll3) = -volti(ll2);
  FEM_DO_SAFE(j, 1, 4) {
    if (volti(j) == 0.0f) {
      goto statement_6343;
    }
    ibr++;
    kbus(ibr) = kpen(j);
    mbus(ibr) = ntot;
    length(ibr) = 1;
    nr(ibr) = it + 1;
    it++;
    tr(it) = volti(j);
    tx(it) = 0.0f;
    c(it) = 0.0f;
    r(it) = 0.0f;
    ibr++;
    kbus(ibr) = kpen(j);
    mbus(ibr) = 1;
    length(ibr) = 1;
    nr(ibr) = it + 1;
    it++;
    tr(it) = -volti(j);
    tx(it) = 0.0f;
    c(it) = 0.0f;
    r(it) = 0.0f;
  statement_6343:;
  }
  goto statement_310;
  //C     END OF TYPE-18 (IDEAL TRANSFORMER) CODE;  CONSIDER NON-18:        M32.1407
statement_6347:
  read(abuff, "(10x,7e10.0)"), a, d1, gus2, h1, h2, gus3, gus4;
  if (n2 != 19) {
    goto statement_314;
  }
  //C     UNIVERSAL MACHINE OF HIAN LAUW --- TYPE-19 SOURCE.                M27. 668
  umoffs(cmn);
  umdata(cmn, spum(cmn.iureac), 
    spum(cmn.iugpar), spum(cmn.iufpar), spum(cmn.iuhist), spum(cmn.iuumrp), 
    ispum(cmn.iunod1), ispum(cmn.iunod2), ispum(cmn.iujclt), ispum(cmn.iujclo), 
    ispum(cmn.iujtyp), ispum(cmn.iunodo), ispum(cmn.iujtmt), spum(cmn.iuhism), 
    spum(cmn.iuomgm), spum(cmn.iuomld), spum(cmn.iutham), spum(cmn.iuredu), 
    spum(cmn.iureds), spum(cmn.iuflds), spum(cmn.iufldr), spum(cmn.iurequ), 
    spum(cmn.iuflqs), spum(cmn.iuflqr), ispum(cmn.iujcds), ispum(cmn.iujcqs), 
    spum(cmn.iuflxd), spum(cmn.iuflxq), ispum(cmn.iunppa), spum(cmn.iurotm), 
    ispum(cmn.iuncld), ispum(cmn.iunclq), ispum(cmn.iujtqo), ispum(cmn.iujomo), 
    ispum(cmn.iujtho), spum(cmn.iureqs), spum(cmn.iuepso), spum(cmn.iudcoe), 
    ispum(cmn.iukcoi), spum(cmn.iuvolt), spum(cmn.iuangl), ispum(cmn.iunodf), 
    ispum(cmn.iunodm), ispum(cmn.iukumo), ispum(cmn.iujumo), spum(cmn.iuumou));

  if (kill > 0) {
    return;
  }
  goto statement_310;
statement_313:
  read(abuff, format_6304), n2, bus1;
  nfrfld = 1;
  nright = 6;
  freone(cmn, h2);
  n1 = h2;
  freone(cmn, a);
  freone(cmn, d1);
  freone(cmn, gus2);
  freone(cmn, h1);
  freone(cmn, h2);
  freone(cmn, gus3);
  freone(cmn, gus4);
statement_314:
  smang = gus2;
  if (n2 > 0) {
    goto statement_4568;
  }
  if (bus1 != cmn.blank) {
    goto statement_4562;
  }
  if (a == 0.0f) {
    goto statement_400;
  }
statement_4562:
  kill = 10;
  lstat(19) = 4562;
  lstat(16) = n2;
  return;
statement_4568:
  if (n2 >= 50 && n2 <= 59) {
    goto statement_114;
  }
  //C     CHECK THAT CONVENTIONAL SOURCES DONT FOLLOW SYNCH.MACHINES        M16. 597
  if (numsm == 0) {
    goto statement_114;
  }
  kill = 177;
  lstat(14) = n2;
  lstat(19) = 8;
  return;
statement_110:
  if (kolbeg > 0) {
    goto statement_7642;
  }
  read(abuff, "(2x,a6)"), bus1;
  goto statement_7646;
statement_7642:
  nfrfld = 1;
  nright = -1;
  freone(cmn, d1);
  nright = 0;
  bus1 = texta6(1);
statement_7646:
  smang = smang - 120.f;
  read(abuff, "(10x,e10.6,10x,e10.6)"), smamp, smangl;
  if (smamp == 0.f && smangl == 0.f) {
    goto statement_103;
  }
  smang = smangl;
  a = smamp;
statement_103:
  n2 = 14;
  gus2 = smang;
  if (machfl == 2) {
    goto statement_130;
  }
  if (noutpr == 0) {
    write(kunit6, "('+2ND PHASE OF S.M. ',e12.5,2x,f8.2)"), a, smang;
  }
  goto statement_113;
statement_130:
  if (noutpr == 0) {
    write(kunit6, "('+3RD PHASE OF S.M. ',e12.5,2x,f8.2)"), a, smang;
  }
  //C     TRANSFER CONTROL TO SYNCHRONOUS MACHINE DATA-INPUT SUBROUTINE.    M16. 615
  smdat(cmn, n2mach);
  if (kill > 0) {
    return;
  }
statement_113:
  machfl++;
statement_114:
  kconst++;
  kpu++;
  if (n2 < 50) {
    goto statement_115;
  }
  if (n2 > 59) {
    goto statement_115;
  }
  //C     THIS SOURCE IS PHASE A OF A SYNCHRONOUS MACHINE                   M16. 624
  numsm++;
  j30 = 30 * numsm - 28;
  if (numsm <= cmn.lsyn) {
    goto statement_125;
  }
  kill = 1;
  lstat(16) = 17;
  lstat(19) = 125;
  return;
statement_125:
  machfl = 1;
  n2mach = n2;
  n2 = 14;
  gus3 = -9988.f;
statement_115:
  if (kconst <= lexct) {
    goto statement_27;
  }
  lstat(19) = 310;
  goto statement_9000;
statement_27:
  if (gus4 == 0.0f) {
    gus4 = cmn.fltinf;
  }
  if (kpu == 1) {
    cmn.pu = a;
  }
  sfreq(kconst) = d1;
  if (machfl <= 1 && noutpr == 0) {
    write(kunit6, "('+SOURCE.',2x,4e10.2)"), a, sfreq(kconst), gus2, gus3;
  }
  if (n2 == 17) {
    goto statement_4259;
  }
  if (n2 != 14) {
    goto statement_317;
  }
  if (sfreq(kconst) > 0.0f) {
    goto statement_317;
  }
  kill = 149;
  flstat(14) = sfreq(kconst);
  lstat(19) = 317;
  return;
statement_317:
  FEM_DO_SAFE(i, 1, ntot) {
    if (bus1 == bus(i)) {
      goto statement_330;
    }
  }
  lstat(19) = 320;
statement_4258:
  kill = 12;
  return;
statement_330:
  if (n2 <= 16) {
    goto statement_4250;
  }
  lstat(19) = 330;
  if (n2 < 60) {
    goto statement_4249;
  }
statement_4259:
  FEM_DO_SAFE(m, 1, cmn.ktab) {
    ndx1 = ivarb(klntab + m);
    if (bus1 == texvec(ndx1)) {
      goto statement_3435;
    }
  }
  lstat(19) = 3429;
  goto statement_4249;
statement_3435:
  sfreq(kconst) = m;
  goto statement_362;
statement_4249:
  kill = 10;
  lstat(16) = n2;
  return;
statement_4250:
  if (n2 != 16) {
    goto statement_349;
  }
  if (n1 >= 1 && n1 <= 3) {
    goto statement_4254;
  }
  kill = 11;
  lstat(19) = 4250;
  lstat(16) = n1;
  return;
statement_4254:
  d2 = gus2 + h2;
  h3 = gus2 * h2;
  yx = gus3;
  gus3 = 1.0f + d2 / delta2 + h3 / delta2 / delta2;
  gus4 = (1.0f + h1 / delta2) * a;
  ck1 = sfreq(kconst);
  sfreq(kconst) = a;
  time1(kconst) = gus3;
  tstart(kconst) = 4.0f * h3 / deltat / gus3;
  iform(kconst) = 16;
  node(kconst) = -i;
  kconst++;
  lstat(19) = 4254;
  if (kconst > lexct) {
    goto statement_9000;
  }
  iform(kconst) = n1;
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2978
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_7653;
  }
  read(abuff, "(2x,a6,i2,6e10.6,9x,i1)"), bus1, n3, a, gus2, time1(kconst),
    tstart(kconst), reps, dcfreq, loutbr;
  goto statement_7658;
statement_7653:
  nfrfld = 1;
  frefld(cmn, voltbc(1));
  n3 = voltbc(1);
  nright = -1;
  freone(cmn, d1);
  nright = 0;
  bus1 = texta6(1);
  frefld(cmn, voltbc(1));
  n3 = voltbc(1);
  freone(cmn, a);
  freone(cmn, gus2);
  frefld(cmn, time1(kconst));
  frefld(cmn, tstart(kconst));
  freone(cmn, reps);
  freone(cmn, dcfreq);
  frefld(cmn, voltbc(1));
  loutbr = voltbc(1);
statement_7658:
  if (noutpr == 0) {
    write(kunit6, "('+SECOND DC SIMULATOR CARD.')");
  }
  if (dcfreq == 0.f) {
    dcfreq = cmn.tenm3;
  }
  crest(kconst - 1) = a * gus3 / gus2 / gus4;
  gus3 = gus4 * gus2 / gus3;
  FEM_DO_SAFE(k, 1, ntot) {
    if (bus1 == bus(k)) {
      goto statement_342;
    }
  }
  lstat(19) = 341;
  goto statement_4258;
statement_342:
  n3 = 4;
  if (yx < 0.f) {
    yx = 0.f;
  }
  ntot++;
  bus(ntot) = text12;
  kode(ntot) = 0;
  if (loutbr < 2) {
    goto statement_4257;
  }
  nv++;
  if (nv <= cmn.lsiz12) {
    goto statement_4256;
  }
  iprint = 11;
  lstat(19) = 4256;
  goto statement_9000;
statement_4256:
  ibrnch(nv) = k;
  jbrnch(nv) = i;
  if (loutbr == 2) {
    loutbr = 0;
  }
statement_4257:
  ntot++;
  iprint = 1;
  lstat(19) = 342;
  if (ntot > lbus) {
    goto statement_9000;
  }
  bus(ntot) = cmn.trash;
  kode(ntot) = 0;
  iprint = 6;
  kswtch++;
  if (kswtch <= lswtch) {
    goto statement_2342;
  }
  lstat(19) = 2342;
  goto statement_9000;
statement_2342:
  kmswit(kswtch) = ntot;
  ndx1 = kswtch + lswtch;
  kmswit(ndx1) = ntot - 1;
  kpos(kswtch) = n3;
  kswtyp(kswtch) = 0;
  tclose(kswtch) = -yx;
  topen(kswtch) = deltat + deltat / 2.0f;
  adelay(kswtch) = 0.f;
  crit(kswtch) = 0.f;
  energy(kswtch) = 0.f;
  isourc(kswtch) = 0;
  ibr++;
  kbus(ibr) = k;
  mbus(ibr) = ntot - 1;
  if (loutbr > 0) {
    mbus(ibr) = -mbus(ibr);
  }
  length(ibr) = 1;
  it++;
  if (reps == 0.0f) {
    reps = sqrtz(cmn.epsiln);
  }
  tr(it) = reps;
  tx(it) = 0.0f;
  c(it) = 0.0f;
  nr(ibr) = -it;
  k = ntot;
  node(kconst) = -k;
  ibr++;
  iprint = 2;
  if (ibr <= lbrnch) {
    goto statement_2343;
  }
  lstat(19) = 2343;
  goto statement_9000;
statement_2343:
  kbus(ibr) = i;
  mbus(ibr) = k;
  it++;
  iprint = 3;
  if (it <= ldata) {
    goto statement_2344;
  }
  lstat(19) = 2344;
  goto statement_9000;
statement_2344:
  iprint = 4;
  nr(ibr) = -it;
  length(ibr) = 1;
  c(it) = 0.f;
  tr(it) = gus3;
  tx(it) = 0.f;
  if (noutpr == 0) {
    write(kunit6, "('+',30x,'EQUIV R=',f10.6)"), gus3;
  }
  tstop(kconst - 1) = 1.0f / gus3;
  crest(kconst) = gus4;
  tstop(kconst) = ck1;
  if (n1 <= 0) {
    goto statement_310;
  }
  kconst += 2;
  lstat(19) = 340;
  if (kconst > lexct) {
    goto statement_9000;
  }
  if (istead == 0) {
    omega = dcfreq * twopi;
  }
  istead = 1;
  node(kconst - 1) = -i;
  node(kconst) = -k;
  iform(kconst - 1) = 14;
  iform(kconst) = 14;
  if (n1 != 1) {
    goto statement_343;
  }
  if (ck1 <= tstart(kconst - 2)) {
    goto statement_4265;
  }
statement_4264:
  kill = 13;
  lstat(19) = 4264;
  return;
statement_4265:
  if (ck1 < time1(kconst - 2)) {
    goto statement_4264;
  }
statement_343:
  if (n1 == 2) {
    ck1 = tstart(kconst - 2);
  }
  if (n1 == 3) {
    ck1 = time1(kconst - 2);
  }
  gus2 = ck1 / gus3 + yx;
  crest(kconst - 1) = gus2;
  crest(kconst) = -gus2;
  tstart(kconst - 1) = -1.0f;
  tstart(kconst) = -1.0f;
  tstop(kconst - 1) = delta2;
  tstop(kconst) = delta2;
  sfreq(kconst) = dcfreq;
  sfreq(kconst - 1) = dcfreq;
  time1(kconst - 1) = 0.0f;
  time1(kconst) = 0.0f;
  goto statement_310;
statement_349:
  if (n2 <= 10) {
    goto statement_362;
  }
  if (a != 0.0f) {
    goto statement_362;
  }
  kill = 73;
  lstat(19) = 349;
  lstat(16) = n2;
  return;
statement_362:
  if (n1 >= 0) {
    goto statement_336;
  }
  i = -i;
statement_331:
  node(kconst) = i;
  if (0 < machfl) {
    k13 = j30 + machfl;
    ismdat(k13) = i;
  }
  if (n2 > 0) {
    goto statement_4266;
  }
  lstat(19) = 331;
  goto statement_4249;
statement_4266:
  tstop(kconst) = gus4;
  iform(kconst) = n2;
  crest(kconst) = a;
  if (n2 == 14) {
    goto statement_332;
  }
  if (gus3 < 0.f) {
    gus3 = 0.f;
  }
  if (n2 <= 10 && crest(kconst) == 0.0f) {
    iread = 1;
  }
  if (n2 == 13) {
    sfreq(kconst) = (h1 - a) / (h2 - gus2);
  }
  goto statement_333;
statement_332:
  gus2 = gus2 * twopi / 360.f;
  if (h1 > 0.f) {
    gus2 = gus2 * sfreq(kconst) * 360.0f;
  }
  if (gus3 >= 0.f) {
    goto statement_333;
  }
  if (omega == 0.0f && istead == 0) {
    omega = twopi * sfreq(kconst);
  }
  istead = 1;
statement_333:
  time1(kconst) = gus2;
  tstart(kconst) = gus3;
  if (i < 0) {
    goto statement_310;
  }
  k = 0;
statement_334:
  k++;
  if (k == kconst) {
    goto statement_310;
  }
  if (node(k) == i) {
    goto statement_335;
  }
  goto statement_334;
statement_335:
  iform(kconst) = -n2;
  goto statement_310;
statement_336:
  kode(i) = -i;
  goto statement_331;
statement_400:
  if (noutpr == 0) {
    write(kunit6, "('+BLANK CARD TERMINATING SOURCE CARDS.')");
  }
  if (numsm > 0) {
    cmn.mfirst = ismdat(24);
  }
  interp();
  if (kconst <= 1) {
    goto statement_4145;
  }
  FEM_DO_SAFE(j, 1, kconst) {
    if (fem::iabs(iform(j)) != 17) {
      goto statement_4142;
    }
    iform(j) = 17;
    crest(j) = crest(j + 1);
    write(lunit6, "(' TYPE-17 REASSIGN. J, CREST(J) =',i5,e15.4)"), j, crest(j);
  statement_4142:;
  }
statement_4145:
  if (cmn.t > 0.0f) {
    goto statement_5737;
  }
  if (istead != 0) {
    goto statement_5737;
  }
  if (inonl <= 0) {
    goto statement_5737;
  }
  FEM_DO_SAFE(j, 1, inonl) {
    if (nltype(j) != -96) {
      goto statement_5732;
    }
    kill = 203;
    lstat(19) = 5732;
    return;
  statement_5732:;
  }
statement_5737:
  if (ncomp > 0) {
    goto statement_419;
  }
  if (inonl > cmn.num99) {
    ncomp = 1;
  }
statement_419:
  if (cmn.fmaxfs == 0.0f) {
    goto statement_447;
  }
  cmn.tmax = 0.0f;
  n1 = 0;
  n2 = 0;
  if (kconst == 0) {
    goto statement_433;
  }
  FEM_DO_SAFE(j, 1, kconst) {
    if (iform(j) != 14) {
      goto statement_431;
    }
    n1++;
    if (tstart(j) < 0.0f) {
      goto statement_424;
    }
    n2++;
  statement_424:
    sfreq(j) = cmn.fminfs;
  statement_431:;
  }
  if (n1 > n2) {
    goto statement_437;
  }
statement_433:
  kill = 194;
  lstat(13) = n1;
  lstat(14) = n1 - n2;
  lstat(19) = 433;
  return;
statement_437:
  if (n2 == 0) {
    goto statement_447;
  }
  write(lunit6,
    "(/,' NOTICE  ----  THIS  ''FREQUENCY SCAN''  DATA CASE CONTAINS',i5,"
    "'   EMTP SOURCES, OF WHICH',i5,'   ARE',/,15x,"
    "'SINUSOIDAL (TYPE-CODE 14).   BUT OF THESE SINUSOIDAL SOURCES, NOT ALL HA"
    "VE FIELD  ''TSTART''  OF COLUMNS',/,15x,"
    "'61-70 PUNCHED NEGATIVE (WHICH WOULD INDICATE THAT SUCH A SOURCE IS PRESE"
    "NT DURING THE STEADY-STATE',/,15x,'PHASOR SOLUTIONS).   THERE WERE',i5,"
    "'   EXCEPTIONS OF THIS SORT.   THE USER IS REMINDED THAT ONLY')"),
    kconst, n1, n2;
  write(lunit6,
    "(15x,"
    "'SINUSOIDAL SOURCES WHICH HAVE NEGATIVE  ''TSTART'' WILL AFFECT THE EMTP "
    "SOLUTION.   BY DEFINITION OF',/,15x,"
    "' ''FREQUENCY SCAN'' ,   THIS DATA CASE WILL INVOLVE ONLY STEADY-STATE PH"
    "ASOR SOLUTIONS (THERE WILL BE',/,15x,'NO TRANSIENT SIMULATIONS).')");
statement_447:
  if (ibr > 0) {
    goto statement_2436;
  }
  //C     DEGENERATE CASE WITHOUT LINEAR BRANCHES; ADD INFINITE R:          M32.1454
  write(lunit6,
    "(/,' THIS IS A DEGENERATE DATA CASE WITHOUT',"
    "' ANY LINEAR BRANCHES.  ADD INFINITE',"
    "' RESISTANCE FROM NODE 2 TO GROUND.',/)");
  ibr = 1;
  kbus(1) = 2;
  mbus(1) = 1;
  length(1) = 1;
  nr(1) = -1;
  it = 1;
  tr(1) = 1.e10f;
  tx(1) = 0.0f;
  r(1) = 0.0f;
  c(1) = 0.0f;
statement_2436:
  if (iprsup < 3) {
    goto statement_1416;
  }
  write(lunit6,
    "(/,' SWITCH TABLE VECTORS',/,"
    "'     ROW   BUS1     BUS2    KPOS  KDEPSM  ISOURC  KSWTYP',9x,'TCLOSE',"
    "9x,'ADELAY',10x,'TOPEN',11x,'CRIT')");
  if (kswtch <= 0) {
    goto statement_2428;
  }
  FEM_DO_SAFE(i, 1, kswtch) {
    ndx2 = lswtch + i;
    write(lunit6, "(7i8,4e15.6)"), i, kmswit(i), kmswit(ndx2), kpos(i),
      kdepsw(i), isourc(i), kswtyp(i), tclose(i), adelay(i), topen(i),
      crit(i);
  }
statement_2428:
  {
    write_loop wloop(cmn, lunit6,
      "(/,' BRANCH TABLE VECTORS',/,"
      "'       ROW      KBUS      MBUS        NR    LENGTH    KODEBR    KODSEM"
      "',/(7i10))");
    FEM_DO_SAFE(i, 1, ibr) {
      wloop, i, kbus(i), mbus(i), nr(i), length(i), kodebr(i), kodsem(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' SOURCE TABLE VECTORS',/,'       ROW     IFORM      NODE',15x,"
      "'CREST',15x,'TIME1',14x,'TSTART',15x,'SFREQ',/(3i10,4e20.10))");
    FEM_DO_SAFE(i, 1, kconst) {
      wloop, i, iform(i), node(i), crest(i), time1(i), tstart(i), sfreq(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' ROWS 1 THROUGH IT OF PARAMETERS FOLLOW:',/,7x,'ROW',13x,'TR',13x,"
      "'TX',14x,'R',14x,'C',/(i10,4e15.5))");
    FEM_DO_SAFE(i, 1, it) {
      wloop, i, tr(i), tx(i), r(i), c(i);
    }
  }
statement_1416:
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' NORMAL EXIT \"OVER5A\".',"
      "'  KCONST     IBR   INONL  KSWTCH  ISTEAD',8x,'OMEGA',9x,'XOPT',9x,"
      "'COPT',8x,'TWOPI',/,22x,5i8,4e13.4)"),
      kconst, ibr, inonl, kswtch, istead, omega, cmn.xopt, cmn.copt,
      twopi;
  }
  cmn.lastov = nchain;
  nchain++;
  goto statement_9999;
statement_9000:
  lstat(16) = iprint;
  kill = 1;
statement_9999:;
}



struct over5_save
{
  fem::str<8> text1;
  fem::str<8> text13;
  fem::str<8> text14;
  fem::str<8> text15;
  fem::str<8> text16;
  fem::str<8> text17;
  fem::str<8> text2;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;
  fem::str<8> text8;

  over5_save() :
    text1(fem::char0),
    text13(fem::char0),
    text14(fem::char0),
    text15(fem::char0),
    text16(fem::char0),
    text17(fem::char0),
    text2(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0),
    text8(fem::char0)
  {}
};

// INPUT OF SWITCH AND SOURCE DATA CARDS.                        
void over5(
  common& cmn)
{
  FEM_CMN_SVE(over5);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& bus6 = cmn.bus6;
  fem::str<8>& blank = cmn.blank;
  const auto& texta6 = cmn.texta6;
  const auto& abuff = cmn.abuff;
  double& ck1 = cmn.ck1;
  double& omega = cmn.omega;
  double& sigmax = cmn.sigmax;
  double& tenerg = cmn.tenerg;
  double& fltinf = cmn.fltinf;
  auto& voltbc = cmn.voltbc;
  auto& flstat = cmn.flstat;
  //auto& moncar = cmn.moncar;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  auto& ipntv = cmn.ipntv;
  auto& indtv = cmn.indtv;
  auto& lstat = cmn.lstat;
  int& icheck = cmn.icheck;
  int& inonl = cmn.inonl;
  int& it2 = cmn.it2;
  int& lexct = cmn.lexct;
  int& lbus = cmn.lbus;
  int& lswtch = cmn.lswtch;
  int& lpast = cmn.lpast;
  int& nv = cmn.nv;
  int& ifdep = cmn.ifdep;
  int& lfdep = cmn.lfdep;
  int& npower = cmn.npower;
  int& maxpe = cmn.maxpe;
  int& lastov = cmn.lastov;
  int& noutpr = cmn.noutpr;
  int& ktab = cmn.ktab;
  int& ichar = cmn.ichar;
  int& jst = cmn.jst;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  int& numref = cmn.numref;
  int& nenerg = cmn.nenerg;
  auto& xk = cmn.xk;
  auto& xm = cmn.xm;
  const auto& weight = cmn.weight;
  auto& iwtent = cmn.iwtent;
  const auto& con1 = cmn.con1;
  const auto& iskip = cmn.iskip;
  const auto& zinf = cmn.zinf;
  const auto& eta = cmn.eta;
  auto& koutvp = cmn.koutvp;
  auto& sptacs = cmn.sptacs;
  auto& kswtyp = cmn.kswtyp;
  auto& topen = cmn.topen;
  auto& crit = cmn.crit;
  auto& kdepsw = cmn.kdepsw;
  auto& tdns = cmn.tdns;
  auto& isourc = cmn.isourc;
  auto& energy = cmn.energy;
  auto& iardub = cmn.iardub;
  auto& ardube = cmn.ardube;
  const auto& texvec = cmn.texvec;
  auto& ibrnch = cmn.ibrnch;
  auto& jbrnch = cmn.jbrnch;
  auto& crest = cmn.crest;
  auto& time1 = cmn.time1;
  auto& sfreq = cmn.sfreq;
  auto& kmswit = cmn.kmswit;
  auto& tclose = cmn.tclose;
  auto& adelay = cmn.adelay;
  auto& kpos = cmn.kpos;
  auto& namesw = cmn.namesw;
  auto& bus = cmn.bus;
  auto& a8sw = cmn.a8sw;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text13 = sve.text13;
  fem::str<8>& text14 = sve.text14;
  fem::str<8>& text15 = sve.text15;
  fem::str<8>& text16 = sve.text16;
  fem::str<8>& text17 = sve.text17;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  fem::str<8>& text7 = sve.text7;
  fem::str<8>& text8 = sve.text8;
  if (is_called_first_time) {
    text1 = "NAME  ";
    text2 = "SWT001";
    text5 = "STATIS";
    text6 = "TICS";
    text7 = "SYSTEM";
    text8 = "ATIC";
    text13 = "MEASUR";
    text14 = "ING   ";
    text15 = "CLOSED";
    text16 = "SAME  ";
    text17 = "TARGET";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int i = fem::int0;
  int n1 = fem::int0;
  int n3 = fem::int0;
  int n4 = fem::int0;
  double d1 = fem::double0;
  int ip2 = fem::int0;
  int ip3 = fem::int0;
  int j = fem::int0;
  int n2 = fem::int0;
  int kpass = fem::int0;
  int idube1 = fem::int0;
  int mk = fem::int0;
  int ll10 = fem::int0;
  int lsw2 = fem::int0;
  int ip = fem::int0;
  double gus3 = fem::double0;
  double gus4 = fem::double0;
  double a = fem::double0;
  int jdube1 = fem::int0;
  int kswt2 = fem::int0;
  int iprint = fem::int0;
  int n24 = fem::int0;
  double atemp = fem::double0;
  int mpower = fem::int0;
  double adube1 = fem::double0;
  double adube2 = fem::double0;
  double adube3 = fem::double0;
  int idube2 = fem::int0;
  int idube3 = fem::int0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  int ndx3 = fem::int0;
  fem::str<80> buffer = fem::char0;
  int n98 = fem::int0;
  int n99 = fem::int0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  int ndxi = fem::int0;
  double ststat = fem::double0;
  double ssigma = fem::double0;
  int ndxj = fem::int0;
  double targ = fem::double0;
  int jk = fem::int0;
  double timchk = fem::double0;
  double abc = fem::double0;
  int ndxk = fem::int0;
  int ndx4 = fem::int0;
  double d2 = fem::double0;
  static const char* format_4568 = "('  \"EXIT  MODULE OVER5.\"')";
  static const char* format_8026 = "(/,' KOUTVP, KOUTIE',/(1x,10i10))";

  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;
  auto& kxtcs =  isptacs(17);
  auto& klntab = isptacs(18);

  auto& knt = cmn.moncar(1);
  auto& isw = cmn.moncar(4);
  auto& idist = cmn.moncar(5);
  auto& itest = cmn.moncar(6);
  auto& kloaep = cmn.moncar(9);
  //C
  auto& nuk = lstat(51);

  if (iprsup >= 1) {
    write(lunit6, "(' BEGIN MODULE \"OVER5\".')");
  }
  lstat(29) = inonl;
  lstat(30) = ichar;
  lstat(33) = ifdep;
  lstat(34) = jst;
  lstat(40) = cmn.ifsem;
  lstat(41) = cmn.iadd;
  move0(crest, lexct);
  move0(time1, lexct);
  move0(sfreq, lexct);
  move0(xk, lpast);
  move0(xm, lpast);
  omega = 0.0f;
  iwtent(cmn.ifdep2) = cmn.jst1;
  if (iprsup <= 0) {
    goto statement_6693;
  }
  if (ifdep == 0) {
    goto statement_6693;
  }
  if (iprsup >= 9) {
    {
      write_loop wloop(cmn, lunit6,
        "(' WEIGHT ---- ARRAY OF WEIGHTING FUNCTION STORAGE',/(1x,10e13.4))");
      FEM_DO_SAFE(i, 1, jst) {
        wloop, weight(i);
      }
    }
  }
  write(lunit6,
    "(/,2x,'ROW',3x,'ISKIP',2x,'IWTENT',12x,'ETA',11x,'ZINF',10x,'TAILP',10x,"
    "'TAILQ',10x,'TAILT',4x,'SUM WEIGHTS')");
  FEM_DO_SAFE(i, 1, ifdep) {
    n1 = 2 * i - 1;
    n3 = iwtent(n1);
    n4 = iwtent(n1 + 2) - 1;
    d1 = 0.0f;
    ip2 = 2 * lfdep + i;
    ip3 = 2 * ip2 - i;
    FEM_DO_SAFE(j, n3, n4) {
      d1 += weight(j);
    }
    write(lunit6, "(1x,i4,2i8,6e15.6)"), i, iskip(i), iwtent(i), eta(i),
      zinf(i), con1(i), con1(ip2), con1(ip3), d1;
  }
  FEM_DO_SAFE(i, 1, ifdep) {
    n1 = ifdep + i;
    n2 = 2 * lfdep + n1;
    n3 = 4 * lfdep + n1;
    write(lunit6, "(1x,i4,8x,i8,10x,3e15.6)"), n1, iwtent(n1), con1(n1),
      con1(n2), con1(n3);
  }
statement_6693:
  //C                                                READING IN SWITCH DATA M42.2874
  kswtch = 0;
  cmn.kconst = 0;
  n4 = 0;
  kpass = 0;
  idube1 = 0;
  mk = 0;
  ll10 = 10;
  lsw2 = lswtch + lswtch;
  move0(indtv, ll10);
  move0(kdepsw, lsw2);
  move0(adelay, lsw2);
statement_209:
  if (kill > 0) {
    goto statement_9200;
  }
  if (iprsup >= 5) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' READ NEXT SWITCH CARD.  KSWTCH  KLOAEP',/,23x,2i8,/(1x,20i6))");
      wloop, kswtch, kloaep;
      FEM_DO_SAFE(ip, 1, kswtch) {
        wloop, kdepsw(ip);
      }
    }
  }
  //C     READ INPUT CARD USING CIMAGE.                                     M42.2879
statement_3483:
  cimage(cmn);
  if (cmn.kolbeg > 0) {
    goto statement_3503;
  }
  read(abuff, "(i2,2a6,4e10.0,a6,a4,2a6,2x,2i1)"), it2, bus1,
    bus2, gus3, gus4, ck1, a, bus3, bus4, bus5, bus6, jdube1, j;
  goto statement_3506;
statement_3503:
  nfrfld = 1;
  frefld(cmn, voltbc(1));
  it2 = voltbc(1);
  nright = -1;
  nfrfld = 2;
  freone(cmn, d1);
  nright = 0;
  bus1 = texta6(1);
  bus2 = texta6(2);
  nfrfld = 4;
  frefld(cmn, voltbc(1));
  gus3 = voltbc(1);
  gus4 = voltbc(2);
  ck1 = voltbc(3);
  a = voltbc(4);
  nright = -2;
  nfrfld = 3;
  freone(cmn, d1);
  nright = 0;
  bus3 = texta6(1);
  bus4 = texta6(2);
  bus5 = texta6(3);
  bus6 = texta6(4);
  nfrfld = 2;
  frefld(cmn, voltbc(1));
  jdube1 = voltbc(1);
  j = voltbc(2);
statement_3506:
  if (bus1 != blank) {
    goto statement_3510;
  }
  if (bus2 == blank) {
    goto statement_213;
  }
statement_3510:
  kswtch++;
  kswt2 = lswtch + kswtch;
  if (kswtch <= lswtch) {
    goto statement_3517;
  }
  lstat(19) = 3510;
  iprint = 6;
  goto statement_9000;
statement_3517:
  crit(lswtch + 1 - kswtch) = 0.0f;
  if (bus1 != text1) {
    goto statement_8212;
  }
  if (noutpr == 0) {
    write(lunit6,
      "(' MONIKER \"',a6,'\" IS FOR NEXT SWITCH ',i6,' .')"), bus2,
      kswtch;
  }
  namea6(cmn, bus2, n24);
  namesw(kswtch) = n24;
  goto statement_3483;
statement_8212:
  if (bus1 != bus2) {
    goto statement_3519;
  }
  kill = 224;
  lstat(19) = 3517;
  goto statement_9200;
statement_3519:
  nmincr(cmn, text2, kswtch);
  namea6(cmn, text2, n24);
  namesw(kswtch) = n24;
  adelay(kswtch) = 0.f;
  atemp = a;
  n1 = 0;
  n2 = 0;
  FEM_DO_SAFE(i, 1, ntot) {
    if (bus1 == bus(i)) {
      n1 = i;
    }
    if (bus2 == bus(i)) {
      n2 = i;
    }
  }
  iprint = 1;
  if (n1 != 0) {
    goto statement_211;
  }
  ntot++;
  lstat(19) = 210;
  if (ntot > lbus) {
    goto statement_9000;
  }
  n1 = ntot;
  bus(n1) = bus1;
statement_211:
  if (n2 != 0) {
    goto statement_212;
  }
  ntot++;
  lstat(19) = 211;
  if (ntot > lbus) {
    goto statement_9000;
  }
  n2 = ntot;
  bus(n2) = bus2;
statement_212:
  isourc(kswtch) = 0;
  if (j <= 3) {
    goto statement_4228;
  }
  j = 3;
  if (npower < maxpe) {
    goto statement_54201;
  }
  iprint = 18;
  lstat(19) = 54201;
  goto statement_9000;
statement_54201:
  npower++;
  mpower = npower + maxpe;
  koutvp(npower) = -(nv + 1);
  koutvp(mpower) = kswtch;
  if (iprsup >= 2) {
    write(lunit6, "(/,' POWER OUTPUT REQUEST',4i10)"), npower, maxpe,
      koutvp(npower), koutvp(mpower);
  }
statement_4228:
  if (j < 2) {
    goto statement_224;
  }
  nv++;
  ibrnch(nv) = n1;
  jbrnch(nv) = n2;
  if (nv <= cmn.lsiz12) {
    goto statement_224;
  }
  iprint = 11;
  lstat(19) = 224;
  goto statement_9000;
statement_224:
  if (j == 2) {
    j = 0;
  }
  if (it2 >= 11 && it2 <= 13) {
    goto statement_250;
  }
  if (it2 == 0) {
    goto statement_218;
  }
  if (it2 != 76) {
    goto statement_4235;
  }
  it2 = 9976;
  goto statement_218;
statement_4235:
  kill = 7;
  lstat(19) = 224;
  lstat(16) = it2;
  goto statement_9200;
  //C     *****   INTERPRETING   ****************************************** M28.3811
  //C     *****     DIODE  OR  TACS-CONTROLLED VALVE  (TYPE-11)  ********** M28.3812
  //C     *****     TACS-CONTROLLED SPARK GAP         (TYPE-12)  ********** M28.3813
  //C     *****     TACS-CONTROLLED ORDINARY SWITCH   (TYPE-13)  ********** M28.3814
statement_250:
  if (bus4 != text16) {
    goto statement_262;
  }
  if (it2 != 11) {
    goto statement_262;
  }
  if (idube1 != 0) {
    goto statement_257;
  }
  kill = 146;
  lstat(19) = 250;
  goto statement_9200;
statement_262:
  adube1 = gus3;
  adube2 = gus4;
  adube3 = ck1;
  idube1 = 1;
statement_257:
  idube2 = 0;
  idube3 = 0;
  if (bus5 == blank) {
    goto statement_264;
  }
  if (it2 == 13) {
    goto statement_264;
  }
  if (ktab == 0) {
    goto statement_259;
  }
  FEM_DO_SAFE(i, 1, ktab) {
    ndx1 = ivarb(klntab + i);
    if (bus5 == texvec(ndx1)) {
      goto statement_261;
    }
  }
statement_259:
  kill = 147;
  lstat(19) = 259;
  goto statement_9200;
statement_261:
  idube2 = i;
statement_264:
  if (bus6 == blank) {
    goto statement_251;
  }
  if (ktab == 0) {
    goto statement_265;
  }
  FEM_DO_SAFE(i, 1, ktab) {
    ndx1 = ivarb(klntab + i);
    if (bus6 == texvec(ndx1)) {
      goto statement_267;
    }
  }
statement_265:
  kill = 119;
  lstat(19) = 265;
  goto statement_9200;
statement_267:
  idube3 = i;
statement_251:
  if (noutpr != 0) {
    goto statement_25199;
  }
  if (it2 != 11) {
    goto statement_25100;
  }
  if (idube2 != 0) {
    goto statement_25110;
  }
  write(kunit6, "('+','DIODE,  NO TACS GRID')");
  goto statement_25150;
statement_25110:
  ndx1 = ivarb(klntab + idube2);
  write(kunit6, "('+','VALVE, TACS GRID= ''',a6,'''')"), texvec(ndx1);
  goto statement_25150;
statement_25100:
  if (it2 != 12) {
    goto statement_25120;
  }
  if (idube2 != 0) {
    goto statement_25105;
  }
  write(kunit6, "('+','GAP,  NO TACS SPARK')");
  goto statement_25150;
statement_25105:
  ndx1 = ivarb(klntab + idube2);
  write(kunit6, "('+','GAP, TACS SPARK = ''',a6,'''')"), texvec(ndx1);
statement_25150:
  if (idube3 == 0) {
    goto statement_25199;
  }
  ndx1 = ivarb(klntab + idube3);
  write(kunit6, "('+',26x,', TACS CLAMP = ''',a6,'''')"), texvec(ndx1);
  goto statement_25199;
statement_25120:
  if (idube3 != 0) {
    goto statement_25125;
  }
  write(kunit6,
    "('+','SWITCH, TACS CONTROL SIGNAL MISSING  \?\?\?\?\?\?\?\?\?\?\?\?')");
  goto statement_25199;
statement_25125:
  ndx1 = ivarb(klntab + idube3);
  write(kunit6, "('+','SWITCH, TACS CONTROL SIGNAL = ''',a6,'''')"),
    texvec(ndx1);
statement_25199:
  adelay(kswtch) = a;
  energy(kswtch) = 0.0f;
  kdepsw(kswt2) = 8888;
  if (it2 == 12) {
    kdepsw(kswt2) = 8890;
  }
  if (it2 == 13) {
    kdepsw(kswt2) = 8891;
  }
  topen(kswtch) = fltinf;
  tclose(kswtch) = fltinf;
  if (bus3 == text15) {
    tclose(kswtch) = -1.0f;
  }
  kpos(kswtch) = 11;
  if (j > 0) {
    kpos(kswtch) = -11;
  }
  kswtyp(kswtch) = 0;
  ndx1 = lswtch + kswtch;
  ndx2 = lswtch + ndx1;
  ndx3 = lswtch + ndx2;
  ardube(ndx1) = adube1;
  ardube(ndx2) = adube2;
  ardube(ndx3) = adube3;
  ardube(kswtch) = -fltinf;
  iardub(kswtch) = idube2;
  iardub(ndx1) = idube3;
  iardub(ndx2) = jdube1;
  if (a != 7777.f) {
    goto statement_220;
  }
  cimage(cmn);
  read(abuff, "(4e16.6)"), a8sw(mk + 1), a8sw(mk + 2), a8sw(mk + 3),
    a8sw(mk + 8);
  a8sw(mk + 7) = 0.0f;
  mk += 8;
  adelay(kswtch) = 7 - mk;
  if (mk <= 400) {
    goto statement_220;
  }
  kill = 1;
  write(lunit6,
    "(' ***** OVERFLOW THE TEMPORARY STORAGE 300 CELLS FOR',"
    "' VECTOR A6SW NEAR STATEMENT 218 AT OVER5 *****')");
  goto statement_9200;
statement_218:
  if (bus3 != text13) {
    goto statement_70218;
  }
  if (bus4 != text14) {
    goto statement_70218;
  }
  if (noutpr == 0) {
    write(kunit6, "('+PERMANENTLY-CLOSED SWITCH USED FOR METERING.')");
  }
  gus3 = -1.0f;
  gus4 = fltinf;
  goto statement_220;
statement_70218:
  if (noutpr == 0) {
    write(kunit6, "('+SWITCH.',2x,4e10.2)"), gus3, gus4, ck1, a;
  }
  if (a == 0.0f) {
    goto statement_220;
  }
  if (atemp == 3333.f) {
    goto statement_220;
  }
  adelay(kswtch) = std::abs(gus4);
statement_220:
  kmswit(kswtch) = n1;
  ndx2 = kswtch + lswtch;
  kmswit(ndx2) = n2;
  if (it2 >= 11 && it2 <= 13) {
    goto statement_209;
  }
  icheck = 11;
  if (a == 0.0f) {
    goto statement_216;
  }
  if (atemp == 3333.f) {
    goto statement_216;
  }
  gus4 = std::abs(a);
  icheck = 10;
  if (gus3 >= 0.f) {
    goto statement_216;
  }
  gus3 = 0.f;
  if (iprsup >= 1) {
    write(lunit6, "(16x,'TCLOSE CHANGED TO ZERO')");
  }
statement_216:
  if (j > 0) {
    icheck = -icheck;
  }
  kpos(kswtch) = icheck;
  kswtyp(kswtch) = it2;
  tclose(kswtch) = gus3;
  topen(kswtch) = gus4;
  crit(kswtch) = ck1;
  read(abuff, "(a80)"), buffer;
  n98 = fem::index(buffer, "   STATISTICS");
  n99 = fem::index(buffer, "   ST");
  if (n98 == 52 || n99 == 0) {
    goto statement_3920;
  }
  if (n99 < 30 || n99 > 60) {
    goto statement_3920;
  }
  write(lunit6,
    "(' Temporary error stop in  OVER5.   The user\"s',"
    "' data is for a Monte Carlo simulation,',/,"
    "' but  \"STATISTICS\"  in columns 55-64 of the',"
    "' last-read data card has been misspelled.',/,"
    "' The defective 80-column card image =',a80)"),
    buffer;
  FEM_STOP(0);
statement_3920:
  if (bus3 != text5) {
    goto statement_3260;
  }
  if (bus4 == text6) {
    goto statement_3360;
  }
statement_3260:
  if (bus3 != text7) {
    goto statement_605;
  }
  if (bus4 != text8) {
    goto statement_605;
  }
  sigmax = 0.0f;
  idist = 0;
  if (nenerg < 0) {
    goto statement_615;
  }
  kill = 141;
  lstat(19) = 3260;
  goto statement_9200;
statement_605:
  goto statement_209;
statement_3360:
  if (nenerg > 0) {
    goto statement_615;
  }
  kill = 141;
  lstat(19) = 3360;
  goto statement_9200;
statement_615:
  adelay(kswtch) = +44444.f;
  if (a != 3333.f) {
    goto statement_3344;
  }
  adelay(kswtch) = -44444.f;
  ndx1 = lswtch + 1 - kswtch;
  if (ck1 <= 0.0f) {
    goto statement_4674;
  }
  //C     PATCH TO ALLOW CURRENT MARGIN WITH RANDOM OPENING (SUBTS1):       M35. 849
  if (ndx1 > kswtch) {
    goto statement_4668;
  }
  write(lunit6,
    "(' OVERFLOW ERROR STOP, LIST 6.  RANDOM',' OPENING WITH CURRENT MARGIN.',"
    "'   NDX1, KSWTCH, LSWTCH =',3i8)"),
    ndx1, kswtch, lswtch;
  stoptp(cmn);
statement_4668:
  crit(ndx1) = ck1;
  if (iprsup >= 1) {
    write(lunit6, "(5x,'I, KSWTCH, CK1 =',2i8,e15.5)"), i, kswtch, ck1;
  }
statement_4674:
  topen(kswtch) = tclose(kswtch);
  tclose(kswtch) = -1.0f;
statement_3344:
  kpass++;
  if (bus5 != text17) {
    goto statement_34605;
  }
  kloaep = kswtch;
  goto statement_225;
statement_34605:
  n5 = 0;
  n6 = 0;
  FEM_DO_SAFE(i, 1, ntot) {
    if (bus5 == bus(i)) {
      n5 = i;
    }
    if (bus6 == bus(i)) {
      n6 = i;
    }
  }
  if (n5 * n6 == 1) {
    goto statement_225;
  }
  n7 = kswtch - 1;
  if (n7 <= 0) {
    goto statement_7245;
  }
  FEM_DO_SAFE(i, 1, n7) {
    if (n5 != kmswit(i)) {
      goto statement_245;
    }
    ndx3 = lswtch + i;
    if (n6 != kmswit(ndx3)) {
      goto statement_245;
    }
    kdepsw(kswtch) = i;
    goto statement_225;
  statement_245:;
  }
statement_7245:
  kill = 110;
  lstat(19) = 245;
  lstat(15) = n5;
  lstat(16) = n6;
  goto statement_9200;
statement_225:
  tdns(kswtch) = ck1;
  crit(kswtch) = gus3;
  if (gus4 < 0.0f) {
    goto statement_620;
  }
  ndxi = kswtch + lswtch;
  topen(ndxi) = gus4;
  if (it2 == 9976 || idist == 1) {
    topen(ndxi) = -gus4;
  }
  goto statement_209;
statement_617:
  kill = 94;
  flstat(14) = ststat;
  flstat(15) = ssigma;
  goto statement_9200;
statement_618:
  kill = 95;
  flstat(14) = ststat;
  flstat(15) = ssigma;
  goto statement_9200;
statement_620:
  kill = 89;
  lstat(19) = 620;
  flstat(15) = crit(kswtch);
  flstat(16) = gus4;
  goto statement_9200;
statement_213:
  if (nenerg == 0) {
    goto statement_8299;
  }
  FEM_DO_SAFE(i, 1, kswtch) {
    if (std::abs(adelay(i)) != 44444.f) {
      goto statement_8211;
    }
    j = i;
    ststat = 0.0f;
    ssigma = 0.0f;
  statement_4632:
    ndxj = j + lswtch;
    targ = crit(j);
    jk = kdepsw(j);
    if (kloaep != 0 && jk == 0) {
      targ = crit(kloaep);
    }
    ststat += targ;
    ssigma = sqrtz(ssigma * ssigma + topen(ndxj) * topen(ndxj));
    if (jk == 0) {
      goto statement_4682;
    }
    j = jk;
    goto statement_4632;
  statement_4682:
    if (ststat >= 0.0f) {
      goto statement_4688;
    }
    lstat(14) = i;
    lstat(15) = 4433;
    goto statement_620;
  statement_4688:
    if (nenerg < 0) {
      goto statement_8222;
    }
    if (idist == 1 || kswtyp(i) == 9976) {
      goto statement_616;
    }
    timchk = ststat - sigmax * ssigma;
    if (timchk < 0.0f) {
      goto statement_617;
    }
    goto statement_614;
  statement_8222:
    abc = 1.0f - itest;
    if (kloaep == 0 || kloaep == i) {
      goto statement_8303;
    }
    ndxk = lswtch + kloaep;
    ststat = ststat - 0.5f * abc * topen(ndxk) * (tdns(kloaep) - 1.f);
    abc = 1.0f;
  statement_8303:
    timchk = ststat - 0.5f * abc * topen(ndxj) * (tdns(j) - 1.f);
    if (timchk < 0.f) {
      goto statement_618;
    }
    goto statement_614;
  statement_616:
    timchk = ststat - 1.732050808f * ssigma;
    if (timchk < 0.0f) {
      goto statement_618;
    }
  statement_614:
    if (timchk < tenerg) {
      tenerg = timchk;
    }
  statement_8211:;
  }
statement_8299:
  if (noutpr == 0) {
    write(kunit6, "('+BLANK CARD TERMINATING SWITCH CARDS.')");
  }
  move0(ipntv, ll10);
  if (tenerg >= 1.e+19f) {
    goto statement_1642;
  }
  if (tenerg < cmn.tmax) {
    goto statement_1642;
  }
  if (nenerg == 1) {
    goto statement_1642;
  }
  kill = 207;
  lstat(19) = 1642;
  goto statement_9200;
statement_1642:
  numref = 0;
  if (nenerg == 0) {
    goto statement_640;
  }
  n1 = 1;
  FEM_DO_SAFE(i, 1, kswtch) {
    if (std::abs(adelay(i)) != 44444.f) {
      goto statement_625;
    }
    if (kdepsw(i) != 0) {
      goto statement_625;
    }
    numref++;
    if (numref <= 10) {
      goto statement_500;
    }
    kill = 112;
    lstat(14) = i;
    lstat(19) = 500;
    n1 = kmswit(i);
    ndx4 = lswtch + i;
    n2 = kmswit(ndx4);
    bus1 = bus(n1);
    bus2 = bus(n2);
    goto statement_9200;
  statement_500:
    if (nenerg > 0) {
      goto statement_510;
    }
    n1 = n1 * tdns(i);
  statement_510:
    ipntv(numref) = i;
    if (kloaep != i) {
      goto statement_625;
    }
    cmn.iloaep = numref;
  statement_625:;
  }
  if (nenerg > 0) {
    goto statement_640;
  }
  n2 = fem::iabs(nenerg);
  if (n1 == n2) {
    goto statement_640;
  }
  kill = 113;
  lstat(19) = 625;
  lstat(12) = n1;
  j = 0;
  FEM_DO_SAFE(i, 1, kswtch) {
    if (std::abs(adelay(i)) != 44444.f) {
      goto statement_520;
    }
    if (kdepsw(i) != 0) {
      goto statement_520;
    }
    j++;
    ipntv(j) = tdns(i);
  statement_520:;
  }
  goto statement_9200;
statement_640:
  if (nenerg <= 0) {
    goto statement_643;
  }
  if (isw != 4444) {
    goto statement_643;
  }
  runtym(d1, d2);
  flstat(1) += d1;
  flstat(2) += d2;
  flstat(5) = flstat(5) - d1;
  flstat(6) = flstat(6) - d2;
  lastov = nchain;
  nchain = 12;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
statement_643:
  lstat(21) = ntot;
  lstat(26) = kswtch;
  lstat(38) = npower;
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' MISC. SCALARS, IN  ''OVER5''  AFTER COMPLETING SWITCH INPUT.',/,"
      "1x,'     IBR   INONL  KSWTCH      NV  NPOWER    NTOT      IT   IFDEP   "
      "NUM99   ICHAR     KNT',/,1x,11i8)"),
      cmn.ibr, inonl, kswtch, nv, npower, ntot, cmn.it, ifdep,
      cmn.num99, ichar, knt;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6, format_8026);
      FEM_DO_SAFE(i, 1, npower) {
        wloop, koutvp(i);
      }
    }
  }
  ndx1 = maxpe + 1;
  ndx2 = maxpe + npower;
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6, format_8026);
      FEM_DO_SAFE(i, ndx1, ndx2) {
        wloop, koutvp(i);
      }
    }
  }
  cmn.ipunch = cmn.ipun;
  cmn.iout = cmn.ioutin;
  //C     CODE FOR INPUT OF EMTP SOURCES IS IN  "OVER5A" .                  M28.3865
  over5a(cmn);
  if (ktab == 0) {
    goto statement_3636;
  }
  ndx1 = kxtcs + nuk;
  sptacs(ndx1 + 5) = omega;
  sptacs(ndx1 + 4) = omega / cmn.twopi;
statement_3636:
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  if (kill == 0) {
    goto statement_99999;
  }
  goto statement_9200;
statement_9000:
  lstat(16) = iprint;
  kill = 1;
statement_9200:
  lastov = nchain;
  nchain = 51;
  lstat(18) = 5;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
statement_99999:;

} // over5

void vecisv(
  common& cmn,
  arr_ref<int> karr,
  int const& n13,
  int const& n2)
{
  karr(dimension(n13));
  common_write write(cmn);
  const auto& nbyte = cmn.nbyte;
  int& iprsup = cmn.iprsup;
  int& kntvec = cmn.kntvec;
  auto& kofvec = cmn.kofvec;
  //
  auto& lunit6 = cmn.lunit6;
  int n4 = fem::int0;
  int k = fem::int0;
  //arr_1d<1, double> farray(fem::fill0);
  int n14 = fem::int0;
  //C     MODULE FOR VECTOR DUMPING/RESTORING OF "OVER6", "OVER8", ETC.     M37. 949
  //C     THIS IS UNIVERSAL FOR VIRTUAL COMPUTERS WHICH CHOSE TO            M37. 950
  //C     USE /C29B01/ SPACE FOR THIS, AS WELL AS ALL OF "LABCOM".          M37. 951
  //C     ALSO NEEDED ARE UNCOUNTED HOLLERITH.  PARALLEL TO "VECISV".       M37. 952
  //C!w EQUIVALENCE  ( KARRAY(1),  FARRAY(1) )
  //C     BLOCK /VECCOM/ IS SHARED WITH "VECRSV" (SEE FOR MORE INFO)        M34.  61
  auto farray = ArraySpan(reinterpret_cast<double* const>(cmn.karray.begin()), cmn.karray.size() / 2);
  if (iprsup >= 1) {
    write(lunit6, "(' BEGIN \"VECISV\".  N13, N2 =',2i8)"), n13, n2;
  }
  if (n2 == 1) {
    goto statement_1471;
  }
  //C     BEGIN CODE TO RESTORE  (KARR(K), K=1, N13)  FROM TANK:            M34.  67
  kntvec++;
  n4 = kofvec(kntvec);
  if (iprsup >= 2) {
    write(lunit6, "(' READY TO RESTORE.  KNTVEC, N4 =',2i10)"), kntvec, n4;
  }
  FEM_DO_SAFE(k, 1, n13) {
    karr(k) = farray(n4);
    n4++;
  }
  goto statement_9000;
  //C     BEGIN CODE TO DUMP  (KARR(K), K=1, N13)  INTO TANK:               M34.  77
statement_1471:
  if (kntvec > 0) {
    goto statement_1474;
  }
  //C RELATIVE LENGTHS  REAL/INTEGER
  n14 = nbyte(3) / nbyte(4);
  kofvec(1) = (cmn.ltlabl + 1) / n14 + 51;
  if (iprsup >= 1) {
    write(lunit6, "(' INITIALIZE KOFVEC(1) =',i10)"), kofvec(1);
  }
statement_1474:
  kntvec++;
  n4 = kofvec(kntvec);
  if (iprsup >= 1) {
    write(lunit6, "(' READY TO DUMP.  KNTVEC, N4 =',2i10)"), kntvec, n4;
  }
  //C CORRECT INTEGER-VECTOR BEGINNING
  kofvec(kntvec) = n4;
  FEM_DO_SAFE(k, 1, n13) {
    farray(n4) = karr(k);
    n4++;
  }
  //C IF /VECCOM/ STORAGE EXCEEDED,
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  if (kntvec >= 20) {
    stoptp(cmn);
  }
  kofvec(kntvec + 1) = n4;
  if (iprsup >= 1) {
    write(lunit6, "(' DEFINE KOFVEC(KNTVEC+1) =',i10)"), kofvec(kntvec + 1);
  }
statement_9000:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT \"VECISV\".  KARR(1;2;N13) =',3i10)"),
      karr(1), karr(2), karr(n13);
  }
  if (iprsup >= 2) {
    write(lunit6, "(' KOFVEC =',20i6)"), kofvec;
  }
}


void insert(
  common& cmn,
  int const& irrr,
  int const& icc)
{
  int& iofgnd = cmn.iofgnd;
  int& iofbnd = cmn.iofbnd;
  int& kill = cmn.kill;
  auto& loc = cmn.loc;
  auto& kownt = cmn.kownt;
  auto& korder = cmn.korder;
  auto& kolum = cmn.kolum;
  //
  int i = fem::int0;
  int ir = fem::int0;
  int irr = fem::int0;
  int ic = fem::int0;
  int irn = fem::int0;
  int n2 = fem::int0;
  int n1 = fem::int0;
  int isubs1 = fem::int0;
  //C     FOLLOWING CARRIES "NEXT" AMONG OVER6, INSERT, OVER7, & OVER9:     M37.2895
  //C!EQUIVALENCE  ( LOOPSS(11), NEXT )
  auto& next = cmn.loopss(11);
  if (irrr <= 1) {
    return;
  }
  if (icc <= 1) {
    return;
  }
  if (irrr == icc) {
    return;
  }
  if (kill > 0) {
    return;
  }
  i = 0;
  ir = irrr;
  irr = irrr;
  ic = icc;
statement_99:
  irn = loc(ir);
  if (irn == 0) {
    goto statement_1;
  }
  n2 = irn + iofgnd;
  n1 = ic - kolum(n2);
  if (n1 > 0) {
    goto statement_2;
  }
  if (n1 == 0) {
    goto statement_5;
  }
statement_1:
  loc(ir) = next;
  goto statement_4;
statement_2:
  ir = irn;
  isubs1 = iofbnd + ir;
  irn = korder(isubs1);
  if (irn == 0) {
    goto statement_3;
  }
  n2 = irn + iofgnd;
  n1 = ic - kolum(n2);
  if (n1 > 0) {
    goto statement_2;
  }
  if (n1 == 0) {
    goto statement_5;
  }
statement_3:
  isubs1 = iofbnd + ir;
  korder(isubs1) = next;
statement_4:
  isubs1 = iofbnd + next;
  korder(isubs1) = irn;
  isubs1 = iofgnd + next;
  kolum(isubs1) = ic;
  if (next < cmn.last) {
    goto statement_2486;
  }
  kill = 200;
  return;
statement_2486:
  next++;
  if (kownt(irr) < 0) {
    goto statement_5;
  }
  kownt(irr)++;
statement_5:
  if (i == 1) {
    return;
  }
  i = 1;
  ir = icc;
  irr = icc;
  ic = irrr;
  goto statement_99;
}

// NETWORK CONNECTIVITY OUTPUT. SETUP OF TRANSIENT-NETWORK
// RENUMBERING TABLES.
void over6(
  common& cmn)
{
  common_write write(cmn);
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& trash = cmn.trash;
  fem::str<8>& terra = cmn.terra;
  auto& lunit2 = cmn.lunit2;
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  int& inonl = cmn.inonl;
  int& kwtspy = cmn.kwtspy;
  int& lswtch = cmn.lswtch;
  int& last = cmn.last;
  int& iv = cmn.iv;
  auto& ktrlsw = cmn.ktrlsw;
  int& num99 = cmn.num99;
  int& kpartb = cmn.kpartb;
  int& lastov = cmn.lastov;
  int& noutpr = cmn.noutpr;
  int& kburro = cmn.kburro;
  int& lsiz23 = cmn.lsiz23;
  int& idoubl = cmn.idoubl;
  //int& iofgnd = cmn.iofgnd;
  //int& iofbnd = cmn.iofbnd;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& kswtch = cmn.kswtch;
  int& it = cmn.it;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  //auto& loopss = cmn.loopss;
  auto& r = static_cast<common_c0b064&>(cmn).r;
  auto& x = static_cast<common_c0b001&>(cmn).x;
  auto& norder = cmn.norder;
  const auto& isourc = cmn.isourc;
  const auto& nltype = cmn.nltype;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  const auto& nonlk = cmn.nonlk;
  const auto& nonlm = cmn.nonlm;
  const auto& imodel = cmn.imodel;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& kodsem = cmn.kodsem;
  const auto& node = cmn.node;
  const auto& tstart = cmn.tstart;
  const auto& kmswit = cmn.kmswit;
  const auto& kode = cmn.kode;
  auto& volt = cmn.volt;
  const auto& bus = cmn.bus;
  auto& ich1 = cmn.ich1;
  auto& loc = cmn.loc;
  auto& kownt = cmn.kownt;
  auto& korder = cmn.korder;
  auto& kolum = cmn.kolum;
  
  //int iofkol = fem::int0;
  //int iofkor = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int n3 = fem::int0;
  double d1 = fem::double0;
  int n7 = fem::int0;
  int i = fem::int0;
  int k = fem::int0;
  int m = fem::int0;
  int j = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  int n11 = fem::int0;
  int n17 = fem::int0;
  int ndx1 = fem::int0;
  int ltest = fem::int0;
  int ipass = fem::int0;
  int lleft = fem::int0;
  int isubs1 = fem::int0;
  int jleft = fem::int0;
  int jtest = fem::int0;
  int moon = 0;
  int n22 = fem::int0;
  arr_1d<20, fem::str<8> > buff(fem::fill0);
  int n9 = fem::int0;
  int nz = fem::int0;
  int L = fem::int0;
  int l1 = fem::int0;
  int l3 = fem::int0;
  int l2 = fem::int0;
  int il = fem::int0;
  int ir = fem::int0;
  int ndx2 = fem::int0;
  int icas = fem::int0;
  static const char* format_1337 = "(i6,4i16)";
  static const char* format_4568 = "('  \"EXIT  MODULE OVER6.\"')";
  static const char* format_5266 =
    "(' --------------+-------------------------------------------------------"
    "---------------------------------------------------')";
  //C     FOLLOWING CARRIES "NEXT" AMONG OVER6, INSERT, OVER7, & OVER9:     M37.2893
  auto& next = cmn.loopss(11);
  auto& iofkol = cmn.iofgnd;
  auto& iofkor = cmn.iofbnd;
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER6.\"')");
  }
  cmn.ntot1 = ntot - 1;
  n3 = 0;
  d1 = 1.0f / (100.f * cmn.flzero);
  //C     1ST REMOVE MINUS SIGN OF "KPARTB" IF PRESENT AS FLAG              M32.2937
  //C     INDICATING "RENUMBER BYPASS".   THEN REDEFINE VALUE OF            M32.2938
  //C     THIS LOFTY RESISTANCE IF USER HAD A "HIGH RESISTANCE"             M32.2939
  //C     REQUEST (KNOWN BY N7 .NE. DEFAULT VALUE OF 1000 IN OVER1):        M32.2940
  n7 = fem::iabs(kpartb);
  if (n7 < 1000) {
    d1 = fem::pow(10.0f, n7);
  }
  i = inonl;
statement_54147:
  if (i == 0) {
    goto statement_54180;
  }
  if (nltype(i) > 0) {
    goto statement_54174;
  }
  k = nonlk(i);
  m = fem::iabs(nonlm(i));
  FEM_DO_SAFE(j, 1, ibr) {
    n1 = fem::iabs(kbus(j));
    n2 = fem::iabs(mbus(j));
    if (n1 != k) {
      goto statement_54154;
    }
    if (n2 == m) {
      goto statement_54174;
    }
    goto statement_54155;
  statement_54154:
    if (n2 != k) {
      goto statement_54155;
    }
    if (n1 == m) {
      goto statement_54174;
    }
  statement_54155:;
  }
  ibr++;
  if (ibr <= cmn.lbrnch) {
    goto statement_4716;
  }
  lstat(19) = 4716;
  kill = 1;
  lstat(16) = 2;
  goto statement_9200;
statement_4716:
  kbus(ibr) = k;
  mbus(ibr) = m;
  if (n3 > 0) {
    goto statement_54162;
  }
  j1 = k;
  j2 = m;
  it++;
  tr(it) = d1;
  tx(it) = 0.0f;
  c(it) = 0.0f;
statement_54162:
  nr(ibr) = -it;
  length(ibr) = 1;
  if (n3 > 0) {
    length(ibr) = -1;
  }
  n7 = -nltype(i);
  if (n7 != 98) {
    n7 = 99;
  }
  if (noutpr == 0 && n3 > 0) {
    write(lunit6,
      "(' HIGH RES. ADDED BY EMTP ACROSS TYPE-',i2,' ELEM.',i3,1x,2x,'1 0',"
      "4a6)"),
      n7, i, bus(k), bus(m), bus(j1), bus(j2);
  }
  if (n3 == 0 && noutpr == 0) {
    write(lunit6,
      "(' HIGH RES. ADDED BY EMTP ACROSS TYPE-',i2,' ELEM.',i3,1x,2x,'1 0',"
      "2a6,12x,e6.1)"),
      n7, i, bus(k), bus(m), tr(it);
  }
  n3 = 1;
statement_54174:
  i = i - 1;
  if (i > 0) {
    goto statement_54147;
  }
statement_54180:
  lstat(24) = kconst;
  lstat(23) = it;
  cmn.it1 = ibr;
  iv = locint(c(1)) - locint(x(1));
  if (kburro == 1) {
    goto statement_4802;
  }
  last = (iv - 1) / (3 * nbyte(3) / nbyte(4));
  lstat(14) = lsiz23;
  lsiz23 = last;
  cmn.iofgnd = last;
  cmn.iofbnd = 2 * last;
  goto statement_4803;
statement_4802:
  last = lsiz23;
  cmn.iofgnd = 0;
  cmn.iofbnd = 0;
statement_4803:
  n11 = 1;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' IN \"OVER6\", KBURRO =',i3,' .   COMPUTE IV, LAST =',2i8)"),
      kburro, iv, last;
  }
  cmn.io.rewind(lunit2);
  //w tapsav(cmn, x(1), lunit2, iv, n11);
  n17 = 0;
  vecrsv(cmn, volt(1), n17, n17);
  vecrsv(cmn, c(1), it, n11);
  vecrsv(cmn, tr(1), it, n11);
  vecrsv(cmn, tx(1), it, n11);
  vecrsv(cmn, r(1), it, n11);
  vecisv(cmn, nr(1), ibr, n11);
  vecisv(cmn, length(1), ibr, n11);
  ktrlsw(7) = it;
  ktrlsw(8) = ibr;
  move0(kolum, ibr);
  //C     OUTPUT NETWORK-CONNECTIVITY TABLE IF SO REQUESTED (IDOUBL=1).     M42.4465
  if (idoubl <= 0) {
    goto statement_5324;
  }
  move0(loc, ntot);
  next = 1;
  i = 1;
statement_5010:
  if (i > ibr) {
    goto statement_5040;
  }
  k = fem::iabs(kbus(i));
  m = fem::iabs(mbus(i));
  if (bus(k) == trash) {
    goto statement_5020;
  }
  if (bus(m) == trash) {
    goto statement_5020;
  }
  moon = 1; // FEM_THROW_UNHANDLED("executable assign: assign5020tomoon");
  goto statement_5200;
statement_5020:
  i++;
  goto statement_5010;
statement_5040:
  i = 1;
statement_5045:
  if (i > inonl) {
    goto statement_5060;
  }
  k = fem::iabs(nonlk(i));
  m = fem::iabs(nonlm(i));
  moon = 2; // FEM_THROW_UNHANDLED("executable assign: assign5050tomoon");
  goto statement_5200;
statement_5050:
  i++;
  goto statement_5045;
statement_5060:
  i = 1;
statement_5065:
  if (i > kswtch) {
    goto statement_5250;
  }
  ndx1 = lswtch + i;
  k = kmswit(i);
  m = kmswit(ndx1);
  ltest = isourc(i);
  if (ltest <= 0) {
    goto statement_5080;
  }
  k = fem::iabs(node(ltest + 1));
statement_5080:
  if (bus(k) == trash) {
    goto statement_5085;
  }
  if (bus(m) == trash) {
    goto statement_5085;
  }
  moon = 3; // FEM_THROW_UNHANDLED("executable assign: assign5085tomoon");
  goto statement_5200;
statement_5085:
  i++;
  goto statement_5065;
statement_5200:
  if (k > ntot || m > ntot) {
    goto statement_5240;
  }
  ipass = 0;
statement_5204:
  lleft = loc(k);
  if (lleft > 0) {
    goto statement_5214;
  }
  ltest = 0;
statement_5208:
  loc(k) = next;
  goto statement_5235;
statement_5214:
  isubs1 = iofkol + lleft;
  jleft = kolum(isubs1);
  if (m > jleft) {
    goto statement_5222;
  }
  ltest = lleft;
  goto statement_5208;
statement_5222:
  isubs1 = iofkor + lleft;
  ltest = korder(isubs1);
  if (ltest == 0) {
    goto statement_5228;
  }
  isubs1 = iofkol + ltest;
  jtest = kolum(isubs1);
  if (jtest >= m) {
    goto statement_5228;
  }
  lleft = ltest;
  goto statement_5222;
statement_5228:
  isubs1 = iofkor + lleft;
  korder(isubs1) = next;
statement_5235:
  isubs1 = iofkol + next;
  kolum(isubs1) = m;
  isubs1 = iofkor + next;
  korder(isubs1) = ltest;
  if (next < last) {
    goto statement_5237;
  }
  kill = 192;
  lstat(19) = 5237;
  goto statement_9200;
statement_5237:
  next++;
  if (ipass > 0) {
    goto statement_5240;
  }
  ipass = k;
  k = m;
  m = ipass;
  goto statement_5204;
statement_5240:
  switch (moon) {
  case 1: goto statement_5020;
  case 2: goto statement_5050;
  case 3: goto statement_5085;
  default: break;
  }
statement_5250:
  write(lunit6,
    "(/,/,' LIST OF INPUT ELEMENTS CONNECTED TO EACH BUS.',/,10x,"
    "'1) ONLY THE PHYSICAL CONNECTIONS OF MULTIPHASE LINES ARE SHOWN (CAPACITI"
    "VE AND INDUCTIVE COUPLING IGNORED)',/,10x,"
    "'2) REPEATED ENTRIES IMPLY PARALLEL CONNECTIONS',/,10x,"
    "'3) SOURCES ARE OMITTED, ALTHOUGH SWITCHES',' ARE INCLUDED;',/,10x,"
    "'4) U.M. USAGE PRODUCES EXTRA, INTERNALLY-',"
    "'DEFINED NODES \"UM\?\?\?\?\" (1ST 2 LETTERS \"UM\").')");
  write(lunit6, "(' FROM BUS NAME 1 NAMES OF ALL ADJACENT BUSSES')");
  write(lunit6, format_5266);
  n22 = kwtspy;
  ipass = 0;
  k = 2;
statement_5268:
  if (loc(k) == 0) {
    goto statement_5294;
  }
  bus5 = bus(k);
statement_5270:
  ltest = loc(k);
  if (ltest == 0) {
    goto statement_5294;
  }
statement_5272:
  isubs1 = iofkol + ltest;
  m = kolum(isubs1);
  ipass++;
  buff(ipass) = bus(m);
  if (m == 1) {
    buff(ipass) = terra;
  }
  if (ipass < 15) {
    goto statement_5285;
  }
statement_5277:
  {
    write_loop wloop(cmn, lunit6, "(9x,a6,'1',15(a6,'*'))");
    wloop, bus5;
    FEM_DO_SAFE(m, 1, ipass) {
      wloop, buff(m);
    }
  }
  bus5 = cmn.blank;
  ipass = 0;
  if (ltest == 0) {
    goto statement_5294;
  }
statement_5285:
  isubs1 = iofkor + ltest;
  ltest = korder(isubs1);
  if (ltest > 0) {
    goto statement_5272;
  }
  goto statement_5277;
statement_5294:
  k++;
  if (idoubl == 0) {
    goto statement_5324;
  }
  if (cmn.m4plot == 1) {
    emtspy(cmn);
  }
  if (k == 2) {
    goto statement_5320;
  }
  if (k <= ntot) {
    goto statement_5268;
  }
  bus5 = terra;
  k = 1;
  goto statement_5270;
statement_5320:
  write(lunit6, format_5266);
  write(lunit6, format_1337);
  if (n22 >= 2) {
    kwtspy = 1;
  }
statement_5324:
  if (cmn.tmax > 0.0f) {
    goto statement_5344;
  }
  FEM_DO_SAFE(i, 1, ntot) {
    ich1(i) = i;
    norder(i) = i;
  }
  goto statement_40013;
  //C     RENUMBER NODES BASED ON SPARSITY OF COEFF MATRIX OF TRANSIENT     M42.4541
  //C     NETWORK SOLUTION.                                                 M42.4542
statement_5344:
  if (iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6, "(/,' BUS NAMES',/(1x,10a12))");
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, bus(i);
      }
    }
  }
  if (kpartb > 0) {
    goto statement_5351;
  }
  //C     NEGATIVE SIGN ON "KPARTB" IS FOR "RENUMBER BYPASS":               M32.2978
  norder(1) = 1;
  n9 = 1;
  FEM_DO_SAFE(i, 2, ntot) {
    if (kode(i) < 0) {
      goto statement_5345;
    }
    n9++;
    norder(i) = n9;
    ich1(n9) = i;
  statement_5345:;
  }
  FEM_DO_SAFE(i, 2, ntot) {
    if (kode(i) == 0) {
      goto statement_5346;
    }
    if (tstart(i) != -9988.f) {
      goto statement_5346;
    }
    n9++;
    norder(i) = n9;
    ich1(n9) = i;
  statement_5346:;
  }
  kpartb = n9;
  FEM_DO_SAFE(i, 2, ntot) {
    if (kode(i) == 0) {
      goto statement_5348;
    }
    if (tstart(i) == -9988.f) {
      goto statement_5348;
    }
    n9++;
    norder(i) = n9;
    ich1(n9) = i;
  statement_5348:;
  }
  goto statement_40013;
statement_5351:
  next = 1;
  nz = 0;
  move0(loc, ntot);
  move0(kownt, ntot);
  i = 1;
statement_41001:
  L = fem::iabs(length(i));
  //C      IF (KODSEM(I) .NE. 0 .AND. IMODEL(I) .NE. -2                     M31. 905
  //C     1                     .AND. IMODEL(I) .NE. -4) L = IABS(KODEBR(I))M43. 850
  if (kodsem(i) != 0 && imodel(i) >= 0) {
    L = fem::iabs(kodebr(i));
  }
  if (L > 1) {
    goto statement_41002;
  }
  insert(cmn, kbus(i), fem::iabs(mbus(i)));
  goto statement_40004;
statement_41002:
  l1 = i + L - 2;
  l3 = l1 + 1;
  FEM_DO_SAFE(j1, i, l1) {
    k = fem::iabs(kbus(j1));
    m = fem::iabs(mbus(j1));
    l2 = j1 + 1;
    FEM_DO_SAFE(j2, l2, l3) {
      insert(cmn, k, fem::iabs(kbus(j2)));
      insert(cmn, m, fem::iabs(mbus(j2)));
    }
  }
  if (kbus(i) < 0) {
    goto statement_40004;
  }
  FEM_DO_SAFE(j1, i, l3) {
    k = fem::iabs(kbus(j1));
    FEM_DO_SAFE(j2, i, l3) {
      insert(cmn, k, fem::iabs(mbus(j2)));
    }
  }
statement_40004:
  if (kill == 0) {
    goto statement_5372;
  }
  lstat(19) = 5372;
  lstat(14) = i;
  goto statement_9200;
statement_5372:
  i += L;
  if (i <= ibr) {
    goto statement_41001;
  }
  if (num99 <= 0) {
    goto statement_73535;
  }
  FEM_DO_SAFE(i, 1, inonl) {
    if (nltype(i) > 0) {
      goto statement_73530;
    }
    k = nonlk(i);
    m = fem::iabs(nonlm(i));
    insert(cmn, k, m);
  statement_73530:;
  }
statement_73535:
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' IN  ''OVER6'' ,   NZ, IOFKOL, IOFKOR =',3i10,/,1x,"
      "'   ROW            KODE           KOLUM',"
      "'           KODER           KOWNT')"),
      nz, iofkol, iofkor;
  }
  FEM_DO_SAFE(i, 1, 10) {
    il = i + iofkol;
    ir = i + iofkor;
    if (iprsup >= 3) {
      write(lunit6, format_1337), i, kode(i), kolum(il), korder(ir), kownt(i);
    }
  }
  if (kswtch < 1) {
    goto statement_40015;
  }
  FEM_DO_SAFE(i, 1, kswtch) {
    ndx2 = lswtch + i;
    k = kmswit(i);
    m = kmswit(ndx2);
    insert(cmn, k, m);
  }
statement_40015:
  FEM_DO_SAFE(i, 2, ntot) {
    if (kode(i) == 0) {
      goto statement_40006;
    }
    if (kownt(i) == (-1)) {
      goto statement_40006;
    }
    nz++;
    kownt(i) = -1;
  statement_40006:;
  }
  kownt(1) = 0;
  if (kill == 0) {
    goto statement_5379;
  }
  lstat(19) = 5379;
  lstat(14) = 0;
  goto statement_9200;
statement_5379:
  kpartb = ntot - nz;
  FEM_DO_SAFE(i, next, last) {
    isubs1 = iofkol + i;
    kolum(isubs1) = 0;
    isubs1 = iofkor + i;
    korder(isubs1) = i + 1;
  }
  isubs1 = iofkor + last;
  if (isubs1 <= korder.size())
    korder(isubs1) = 0;
  icas = 0;
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' SCALARS AT END OF  ''OVER6'' .',/,"
      "'    NEXT    LAST    NTOT  KSWTCH  KCONST',"
      "'      NV     IBR   INONL  NPOWER      IT',"
      "'  ISTEAD   NUM99      NZ      IV',/,1x,14i8)"),
      next, last, ntot, kswtch, kconst, cmn.nv, ibr, inonl,
      cmn.npower, it, cmn.istead, num99, nz, iv;
  }
  cmn.ncurr = ntot - nz;
  lastov = nchain;
  nchain = 7;
  goto statement_9988;
statement_40013:
  lastov = nchain;
  nchain += 2;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
statement_9200:
  lastov = nchain;
  lstat(18) = 6;
  nchain = 51;
statement_9988:
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
statement_99999:;
} // over6


void subscr(
  common& cmn,
  int const& j,
  int const& limit,
  int const& istat,
  int const& n1)
{
  common_write write(cmn);
  auto& lunit6 = cmn.lunit6;
  //C     MODULE USED TO CHECK OUT-OF-BOUNDS SUBSCRIPTS FOR "OVER7"         M31.1137
  //C     SPECIAL N1=99 CASE IS FOR SUBSCRIPTS WHICH ARE USED ONLY          M31.1138
  //C     IF POSITIVE (WSM CHANGES TO WALKER'S CODE).                       M31.1139
  if (j >= 1 && j <= limit) {
    goto statement_9000;
  }
  if (j <= 0 && n1 == 99) {
    goto statement_9000;
  }
  write(lunit6,
    "(' OUT-OF-BOUNDS SUBSCRIPT =',i6,' .   LIMIT =',i6,' .   BELOW S.N.',i6,"
    "'   WITH SEQUENCE NO.',i2,' .')"),
    j, limit, istat, n1;
statement_9000:
  if (cmn.iprsup >= 99) {
    write(lunit6, "(' TRACE.  J, LIMIT, ISTAT, N1 =',4i8)"), j,
      limit, istat, n1;
  }

}

// NETWORK NODE RENUMBERING ROUTINE (JOHN WALKER'S OLD           
// SUBROUTINE NUMBER).                                           
void over7(
  common& cmn)
{
  common_write write(cmn);
  auto& lstat = cmn.lstat;
  int& lbus = cmn.lbus;
  int& last = cmn.last;
  int& lastov = cmn.lastov;
  int& lsiz23 = cmn.lsiz23;
  int& jst = cmn.jst;
  int& ncurr = cmn.ncurr;
  int& ioffd = cmn.ioffd;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& ntot = cmn.ntot;
  const auto& nr = cmn.nr;
  const auto& length = cmn.length;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& node = cmn.node;
  const auto& tstart = cmn.tstart;
  const auto& kmswit = cmn.kmswit;
  auto& e = cmn.e;
  const auto& kode = cmn.kode;
  auto& norder = cmn.norder;
  auto& index = cmn.index;
  auto& iloc = cmn.iloc;
  auto& ich1 = cmn.ich1;
  auto& ich2 = cmn.ich2;
  auto& loc = cmn.loc;
  auto& kownt = cmn.kownt;
  auto& korder = cmn.korder;
  auto& kolum = cmn.kolum;
  //
  auto& lunit6 = cmn.lunit6;
  int ischm = fem::int0;
  int i = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int ndx1 = fem::int0;
  double td = fem::double0;
  double zzza = fem::double0;
  int lastxx = fem::int0;
  int nz = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  int jsub = fem::int0;
  int nelim = fem::int0;
  int ncn = fem::int0;
  int mext = fem::int0;
  int icon = fem::int0;
  int ii = fem::int0;
  int isubs1 = fem::int0;
  int L = fem::int0;
  int ist = fem::int0;
  int ib = fem::int0;
  int jb = fem::int0;
  int jbs = fem::int0;
  int isubs2 = fem::int0;
  int n13 = fem::int0;
  int jbt = fem::int0;
  int m = fem::int0;
  int js = fem::int0;
  int ks = fem::int0;
  int ls = fem::int0;
  int kb = fem::int0;
  static const char* format_4568 = "('  \"EXIT  MODULE OVER7.\"')";
  static const char* format_47881 =
    "(/,' (NORDER(I), I=1, NTOT)   AFTER TRANSIENT-NETWORK RENUMBERING .',"
    "/(1x,20i6))";
  //C     FOLLOWING CARRIES "NEXT" AMONG OVER6, INSERT, OVER7, & OVER9:     M37.2897
  auto& next = cmn.loopss(11);
  auto& iofkol = cmn.iofgnd;
  auto& iofkor = cmn.iofbnd;
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER7.\"')");
  }
  ischm = 2;
  if (iprsup < 4) {
    goto statement_4054;
  }
  write(lunit6,
    "(/,' SCALARS UPON ENTRY INTO RENUMBERING,  ''OVER7'' .     ISCHM    NTOT "
    "   NEXT  IOFKOL  IOFKOR   NCURR',/,50x,6i8)"),
    ischm, ntot, next, iofkol, iofkor, ncurr;
  write(lunit6,
    "(' INTEGER ARRAYS UPON ENTRY INTO RENUMBERING,  ''OVER7'' .',/,"
    "'     ROW   KOLUM  KORDER   KOWNT     LOC   KODE     KBUS    MBUS      NR"
    "  LENGTH   BUS1     BUS2')");
  FEM_DO_SAFE(i, 1, next) {
    n1 = i + iofkol;
    n2 = i + iofkor;
    ndx1 = cmn.lswtch + i;
    write(lunit6, "(12i8)"), i, kolum(n1), korder(n2), kownt(i), loc(i),
      kode(i), kbus(i), mbus(i), nr(i), length(i), kmswit(i), kmswit(
        ndx1);
  }
statement_4054:
  ioffd = 0;
  td = 0.0f;
  zzza = 0.0f;
  lastxx = last;
  //C     N1 = LBUS + 1  // USE LBUS, NOT THIS N1,  IN FOLLOWING:               M32.3023
  move0(e, lbus);
  nz = ncurr;
  i = 0;
statement_140:
  i++;
  if (ischm == 3) {
    goto statement_1510;
  }
  j = kownt(i);
  subscr(cmn, i, lbus, 150, 1);
  if (j == (-1)) {
    goto statement_170;
  }
statement_155:
  k = e(j + 1);
  jsub = j + 1;
  subscr(cmn, jsub, lbus, 155, 1);
  ich1(i) = k;
  subscr(cmn, i, lbus, 155, 2);
  if (k > 0) {
    ich2(k) = i;
  }
  subscr(cmn, k, lbus, 155, 99);
  e(j + 1) = i;
  ich2(i) = 0;
  norder(i) = 0;
  goto statement_180;
statement_170:
  nz++;
  norder(i) = nz;
  subscr(cmn, i, lbus, 170, 1);
statement_180:
  if (i < ntot) {
    goto statement_140;
  }
  if (nz == ntot) {
    goto statement_190;
  }
  lstat(19) = 190;
  nelim = 0;
  goto statement_453;
statement_190:
  ncn = 0;
  //C     NEXT DELETE OBVIOUSLY ZERO-CELL ZEROING OF VECTORS:               M31. 917
  nelim = 1;
statement_200:
  if (ncn >= lbus) {
    goto statement_220;
  }
  jsub = ncn + 1;
  subscr(cmn, jsub, lbus, 200, 1);
  if (e(ncn + 1) != 0) {
    goto statement_220;
  }
  ncn++;
  goto statement_200;
statement_220:
  if (ncurr < nelim) {
    goto statement_229;
  }
  jsub = ncn + 1;
  subscr(cmn, jsub, lbus, 220, 1);
  i = e(ncn + 1);
  index(nelim) = ioffd + 1;
  subscr(cmn, nelim, lbus, 220, 2);
  if (iprsup <= 25) {
    goto statement_222;
  }
  write(lunit6,
    "(' PREPARE TO RENUMBER NEXT NETWORK NODE IN  ''OVER7'' .     NELIM     NC"
    "N   IOFFD    NTOT   NCURR    NEXT    MEXT    ICON',/,54x,8i8)"),
    nelim, ncn, ioffd, ntot, ncurr, next, mext, icon;
  if (iprsup <= 34) {
    goto statement_222;
  }
  write(lunit6,
    "(' RENUMBERING ARRAYS.       ROW   KOLUM  KORDER   KOWNT     LOC    ICH1 "
    "   ICH2    NDEX')");
  FEM_DO_SAFE(ii, 1, 15) {
    n1 = ii + iofkol;
    n2 = ii + iofkor;
    write(lunit6, "(22x,8i8)"), ii, kolum(n1), korder(n2), kownt(ii),
      loc(ii), ich1(ii), ich2(ii), e(ii);
  }
statement_222:
  j = ich1(i);
  subscr(cmn, i, lbus, 222, 1);
  e(ncn + 1) = j;
  jsub = ncn + 1;
  subscr(cmn, jsub, lbus, 222, 2);
  if (j > 0) {
    ich2(j) = 0;
  }
  subscr(cmn, j, lbus, 222, 99);
  norder(i) = nelim;
  goto statement_240;
statement_229:
  FEM_DO_SAFE(i, 1, ntot) {
    j = norder(i);
    subscr(cmn, j, lbus, 229, 1);
    ich2(j) = i;
  }
  if (iprsup >= 3) {
    write(lunit6,
      "(/,' FINAL RENUMBERING ARRAYS AT THE END OF  ''OVER7'' .     ROW  NORDE"
      "R   INDEX    ILOC  LORDER   KOWNT     LOC   KOLUM  KORDER')");
  }
  FEM_DO_SAFE(i, 1, 20) {
    n1 = i + iofkol;
    n2 = i + iofkor;
    if (iprsup >= 3) {
      write(lunit6, "(50x,9i8)"), i, norder(i), index(i), iloc(i),
        ich2(i), kownt(i), loc(i), kolum(n1), korder(n2);
    }
  }
  if (ioffd <= 0) {
    goto statement_233;
  }
  FEM_DO_SAFE(i, 1, ioffd) {
    subscr(cmn, i, lsiz23, 5235, 1);
    j = iloc(i);
    subscr(cmn, j, lbus, 5235, 2);
    j = norder(j);
    iloc(i) = j;
  }
statement_233:
  if (nelim > ntot) {
    goto statement_5236;
  }
  FEM_DO_SAFE(i, nelim, ntot) {
    subscr(cmn, i, lbus, 233, 1);
    index(i) = ioffd + 1;
    k = ich2(i);
    subscr(cmn, k, lbus, 233, 2);
    j = loc(k);
  statement_234:
    if (j == 0) {
      goto statement_236;
    }
    subscr(cmn, j, lsiz23, 234, 1);
    isubs1 = iofkol + j;
    k = kolum(isubs1);
    subscr(cmn, k, lbus, 234, 2);
    L = norder(k);
    if (i > L) {
      goto statement_235;
    }
    ioffd++;
    subscr(cmn, ioffd, lsiz23, 234, 3);
    iloc(ioffd) = L;
  statement_235:
    isubs1 = iofkor + j;
    subscr(cmn, j, lsiz23, 235, 1);
    j = korder(isubs1);
    goto statement_234;
  statement_236:;
  }
statement_5236:
  index(ntot + 1) = ioffd + 1;
  jsub = ntot + 1;
  subscr(cmn, jsub, lbus, 5236, 1);
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' ARRAYS UPON EXIT FROM  ''OVER7'' .     ROW  NORDER   INDEX    IL"
        "OC',/(33x,4i8))");
      FEM_DO_SAFE(i, 1, 20) {
        wloop, i, norder(i), index(i), iloc(i);
      }
    }
  }
  if (ioffd > lstat(43)) {
    lstat(43) = ioffd;
  }
statement_5276:
  if (lastov > nchain) {
    goto statement_5283;
  }
  if (iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6, format_47881);
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, norder(i);
      }
    }
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' BEFORE ''OVER8'' .    NEXT    LAST    NTOT  KSWTCH  KCONST      NV"
      "     IBR   INONL  NPOWER      IT  ISTEAD  NOR(1)   NCURR',/,17x,13i8)"),
      next, last, ntot, cmn.kswtch, kconst, cmn.nv, cmn.ibr,
      cmn.inonl, cmn.npower, cmn.it, cmn.istead, norder(1), ncurr;
  }
  if (norder(1) == 1) {
    goto statement_14;
  }
  if (cmn.noutpr == 0) {
    {
      write_loop wloop(cmn, lunit6, format_47881);
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, norder(i);
      }
    }
  }
  if (iprsup > 0) {
    write(lunit6,
      "(' NOTE ---- THE PRECEDING PRINTOUT SHOWS THAT GROUND WAS NOT RENUMBERE"
      "D FIRST IN THE TRANSIENT-NETWORK RENUMBERING.',/,11x,"
      "'WE WILL SWAP THE NEW NUMBERS BETWEEN GROUND AND WHATEVER NODE WAS RENU"
      "MBERED FIRST, IN ORDER TO GET A LEGITIMATE',/,11x,"
      "'NUMBERING FOR THE REST OF THE EMTP CALCULATIONS.')");
  }
  FEM_DO_SAFE(i, 1, ntot) {
    if (norder(i) == 1) {
      goto statement_32;
    }
  }
  stoptp(cmn);
statement_32:
  norder(i) = norder(1);
  norder(1) = 1;
statement_14:
  FEM_DO_SAFE(i, 1, ntot) {
    j = norder(i);
    ich1(j) = i;
  }
  if (kconst == 0) {
    goto statement_73820;
  }
  n1 = 0;
  j = 1;
  FEM_DO_SAFE(i, 2, ntot) {
    k = ich1(i);
    if (kode(k) == 0) {
      goto statement_73775;
    }
    FEM_DO_SAFE(L, 1, kconst) {
      if (iprsup >= 3) {
        write(lunit6,
          "(' AT 6049 OF \"OVER7\".  I, K, KODE(K), ETC. =',7i8,e20.10)"),
          i, k, kode(k), n1, j, L, node(L), tstart(L);
      }
      //C     S.M.  SOURCE NODE MUST PRECEDE REGULAR VOLTAGE SOURCE NODES.      M32.3065
      //C     ALTER RENUMBERING MAP TO PRODUCE THIS, IF  TSTART  .EQ.  -9988.   M32.3066
      if (tstart(L) != -9988.f) {
        goto statement_6051;
      }
      if (node(L) == k) {
        goto statement_73775;
      }
    statement_6051:;
    }
    n1++;
    norder(n1) = k;
    goto statement_73780;
  statement_73775:
    j++;
    ich1(j) = k;
  statement_73780:;
  }
  cmn.kpartb = j;
  if (n1 <= 0) {
    goto statement_73820;
  }
  FEM_DO_SAFE(i, 1, n1) {
    j++;
    k = norder(i);
    ich1(j) = k;
  }
  FEM_DO_SAFE(i, 1, ntot) {
    j = ich1(i);
    norder(j) = i;
  }
statement_73820:
  lastov = nchain;
  nchain++;
  goto statement_5294;
statement_5283:
  n1 = nchain;
  nchain = lastov + 1;
  lastov = n1;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
statement_5294:
  goto statement_99999;
statement_240:
  nelim++;
  if (ischm == 1) {
    goto statement_200;
  }
  subscr(cmn, i, lbus, 240, 1);
  if (loc(i) == 0) {
    goto statement_200;
  }
  ist = loc(i);
  subscr(cmn, i, lbus, 260, 1);
  jst = ist;
  goto statement_290;
statement_270:
  isubs1 = iofkor + jst;
  subscr(cmn, jst, lsiz23, 270, 1);
  jst = korder(isubs1);
  if (jst != 0) {
    goto statement_290;
  }
  if (ischm == 3) {
    goto statement_1110;
  }
  goto statement_200;
statement_290:
  ib = ist;
  subscr(cmn, jst, lsiz23, 290, 1);
  isubs1 = iofkol + jst;
  j = kolum(isubs1);
  subscr(cmn, j, lbus, 290, 2);
  jb = loc(j);
  icon = -1;
  jbs = 0;
  if (jb == 0) {
    goto statement_200;
  }
  ioffd++;
  subscr(cmn, ioffd, lsiz23, 300, 1);
  iloc(ioffd) = j;
statement_310:
  isubs1 = iofkol + ib;
  isubs2 = iofkol + jb;
  subscr(cmn, ib, lsiz23, 310, 1);
  subscr(cmn, jb, lsiz23, 310, 2);
  n13 = kolum(isubs1) - kolum(isubs2);
  if (n13 > 0) {
    goto statement_500;
  }
  if (n13 < 0) {
    goto statement_360;
  }
  //C     IF (KOLUM(ISUBS1)    - KOLUM(ISUBS2)   ) 360, 320, 500            M31. 951
  //C 320 ISUBS1 =  IOFKOR+IB                                               M31. 952
  isubs1 = iofkor + ib;
  if (korder(isubs1) == 0) {
    goto statement_430;
  }
  isubs1 = iofkor + ib;
  subscr(cmn, ib, lsiz23, 330, 1);
  ib = korder(isubs1);
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 340, 1);
  if (korder(isubs1) == 0) {
    goto statement_700;
  }
  jbs = jb;
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 350, 1);
  jb = korder(isubs1);
  goto statement_310;
statement_360:
  isubs1 = iofkol + ib;
  subscr(cmn, ib, lsiz23, 360, 1);
  if (kolum(isubs1) == j) {
    goto statement_410;
  }
  isubs1 = iofkol + next;
  subscr(cmn, next, lsiz23, 370, 1);
  isubs2 = iofkol + ib;
  subscr(cmn, ib, lsiz23, 370, 2);
  kolum(isubs1) = kolum(isubs2);
  mext = next;
  if (next == lastxx) {
    goto statement_375;
  }
  subscr(cmn, next, lsiz23, 370, 3);
  isubs1 = iofkor + next;
  next = korder(isubs1);
  isubs1 = iofkor + mext;
  subscr(cmn, mext, lsiz23, 370, 4);
  korder(isubs1) = jb;
  jbt = jbs;
  jbs = mext;
  icon++;
  goto statement_380;
statement_375:
  kill = 16;
  lstat(19) = 375;
  lstat(16) = last;
  lstat(15) = nelim;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_9999;
statement_380:
  if (jbt == 0) {
    goto statement_400;
  }
  isubs1 = iofkor + jbt;
  subscr(cmn, jbt, lsiz23, 390, 1);
  korder(isubs1) = mext;
  goto statement_410;
statement_400:
  loc(j) = mext;
  subscr(cmn, j, lbus, 400, 1);
statement_410:
  isubs1 = iofkor + ib;
  subscr(cmn, ib, lsiz23, 410, 1);
  ib = korder(isubs1);
  if (ib != 0) {
    goto statement_310;
  }
statement_430:
  isubs1 = iofkol + jb;
  subscr(cmn, jb, lsiz23, 430, 1);
  //C     IF (KOLUM(ISUBS1)    -I) 440, 470, 790                            M31. 966
  //C 440 JBS = JB                                                          M31. 967
  n13 = kolum(isubs1) - i;
  if (n13 == 0) {
    goto statement_470;
  }
  if (n13 > 0) {
    goto statement_790;
  }
  jbs = jb;
  isubs1 = iofkor + jb;
  jb = korder(isubs1);
  if (jb != 0) {
    goto statement_430;
  }
  lstat(19) = 450;
statement_453:
  kill = 25;
  lstat(16) = nelim;
  lstat(15) = jbs;
  lstat(14) = i;
  lstat(13) = ib;
  lstat(12) = mext;
  lstat(11) = next;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_9999;
statement_470:
  isubs1 = iofkor + lastxx;
  subscr(cmn, lastxx, lsiz23, 470, 1);
  korder(isubs1) = jb;
  lastxx = jb;
  if (jbs == 0) {
    goto statement_490;
  }
  isubs1 = iofkor + jbs;
  isubs2 = iofkor + jb;
  subscr(cmn, jbs, lsiz23, 480, 1);
  subscr(cmn, jb, lsiz23, 480, 2);
  korder(isubs1) = korder(isubs2);
  goto statement_790;
statement_490:
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 490, 1);
  loc(j) = korder(isubs1);
  subscr(cmn, j, lbus, 490, 2);
  goto statement_790;
statement_500:
  isubs1 = iofkol + jb;
  subscr(cmn, jb, lsiz23, 500, 1);
  //C     IF (KOLUM(ISUBS1)    -I) 510, 540, 520                            M31. 978
  //C 510 JBS = JB                                                          M31. 979
  n13 = kolum(isubs1) - i;
  if (n13 == 0) {
    goto statement_540;
  }
  if (n13 > 0) {
    goto statement_520;
  }
  jbs = jb;
  isubs1 = iofkor + jb;
  jb = korder(isubs1);
  goto statement_310;
statement_520:
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 520, 1);
  if (korder(isubs1) == 0) {
    goto statement_700;
  }
  jbs = jb;
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 530, 1);
  jb = korder(isubs1);
  goto statement_310;
statement_540:
  if (jbs == 0) {
    goto statement_580;
  }
  isubs1 = iofkor + jbs;
  isubs2 = iofkor + jb;
  subscr(cmn, jbs, lsiz23, 550, 1);
  subscr(cmn, jb, lsiz23, 550, 2);
  korder(isubs1) = korder(isubs2);
  isubs1 = iofkor + lastxx;
  subscr(cmn, lastxx, lsiz23, 550, 3);
  korder(isubs1) = jb;
  lastxx = jb;
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 560, 1);
  if (korder(isubs1) != 0) {
    goto statement_575;
  }
  jb = jbs;
  goto statement_700;
statement_575:
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 575, 1);
  jb = korder(isubs1);
  goto statement_310;
statement_580:
  isubs1 = iofkor + lastxx;
  subscr(cmn, lastxx, lsiz23, 580, 1);
  korder(isubs1) = jb;
  lastxx = jb;
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 580, 2);
  if (korder(isubs1) == 0) {
    goto statement_600;
  }
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 590, 1);
  subscr(cmn, j, lbus, 590, 2);
  loc(j) = korder(isubs1);
  isubs1 = iofkor + jb;
  jb = korder(isubs1);
  goto statement_310;
statement_600:
  isubs1 = iofkol + ib;
  subscr(cmn, ib, lsiz23, 600, 1);
  if (kolum(isubs1) == j) {
    goto statement_620;
  }
statement_610:
  loc(j) = next;
  subscr(cmn, j, lbus, 610, 1);
  jb = next;
  mext = next;
  //C     IF (NEXT .EQ. LASTXX)   GO TO 615                                 M31. 997
  if (next == lastxx) {
    goto statement_375;
  }
  isubs1 = iofkor + next;
  subscr(cmn, next, lsiz23, 610, 2);
  next = korder(isubs1);
  icon++;
  isubs1 = iofkol + jb;
  isubs2 = iofkol + ib;
  subscr(cmn, jb, lsiz23, 610, 3);
  subscr(cmn, ib, lsiz23, 610, 4);
  kolum(isubs1) = kolum(isubs2);
  //C     GO TO 650     ELIMINATE "CONTINUE";  USE NEXT LINE:               M31.1002
  goto statement_660;
  //C 615 GO TO 375    THERE WAS ONLY ONE TRANSFER TO 615                   M31.1004
statement_620:
  isubs1 = iofkor + ib;
  subscr(cmn, ib, lsiz23, 620, 1);
  ib = korder(isubs1);
  if (ib != 0) {
    goto statement_610;
  }
  loc(j) = 0;
  subscr(cmn, j, lbus, 640, 1);
  goto statement_790;
  //C 650 CONTINUE      ELIMINATE "CONTINUE" NOT END OF DO LOOP             M31.1007
statement_660:
  isubs1 = iofkor + ib;
  subscr(cmn, ib, lsiz23, 660, 1);
  if (korder(isubs1) == 0) {
    goto statement_690;
  }
  isubs1 = iofkor + ib;
  subscr(cmn, ib, lsiz23, 670, 1);
  ib = korder(isubs1);
  isubs1 = iofkol + next;
  isubs2 = iofkol + ib;
  subscr(cmn, next, lsiz23, 670, 2);
  subscr(cmn, ib, lsiz23, 670, 3);
  kolum(isubs1) = kolum(isubs2);
  goto statement_680;
  //C 675 GO TO 375        CONVERT "GO TO 675"  TO  "GO TO 375"             M31.1012
statement_680:
  mext = next;
  //C     IF (NEXT .EQ. LASTXX)   GO TO 675    ELIMINATE 675 GO TO 375      M31.1013
  if (next == lastxx) {
    goto statement_375;
  }
  isubs1 = iofkor + next;
  subscr(cmn, next, lsiz23, 680, 1);
  next = korder(isubs1);
  icon++;
  //C     GO TO 650     ELIMINATE "650 CONTINUE";  USE NEXT LINE:           M31.1016
  goto statement_660;
statement_690:
  isubs1 = iofkor + mext;
  subscr(cmn, mext, lsiz23, 690, 1);
  korder(isubs1) = 0;
  goto statement_790;
statement_700:
  isubs1 = iofkol + ib;
  subscr(cmn, ib, lsiz23, 700, 1);
  //C     IF (KOLUM(ISUBS1)    -J) 710, 760, 780                            M31.1020
  //C 710 ISUBS1 =  IOFKOL+NEXT                                             M31.1021
  n13 = kolum(isubs1) - j;
  if (n13 == 0) {
    goto statement_760;
  }
  if (n13 > 0) {
    goto statement_780;
  }
  isubs1 = iofkol + next;
  subscr(cmn, next, lsiz23, 700, 2);
  isubs2 = iofkol + ib;
  kolum(isubs1) = kolum(isubs2);
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 700, 3);
  korder(isubs1) = next;
statement_720:
  mext = next;
  //C     IF (NEXT .EQ. LASTXX)   GO TO 725       "725 GO TO 375"           M31.1028
  if (next == lastxx) {
    goto statement_375;
  }
  isubs1 = iofkor + next;
  subscr(cmn, next, lsiz23, 720, 1);
  next = korder(isubs1);
  icon++;
  isubs1 = iofkor + ib;
  subscr(cmn, ib, lsiz23, 720, 2);
  ib = korder(isubs1);
  goto statement_730;
  //C 725 GO TO 375    CONVERT  "GO TO 725"  TO  "GO TO 375"                M31.1032
statement_730:
  isubs1 = iofkol + ib;
  subscr(cmn, ib, lsiz23, 730, 1);
  //C     IF (KOLUM(ISUBS1)    -J) 750, 650, 740    WITH 650>>>660          M31.1034
  //C 740 KILL = 26                                                         M31.1035
  n13 = kolum(isubs1) - j;
  if (n13 < 0) {
    goto statement_750;
  }
  if (n13 == 0) {
    goto statement_660;
  }
  kill = 26;
  lstat(19) = 730;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_9999;
statement_750:
  isubs1 = iofkol + next;
  isubs2 = iofkol + ib;
  subscr(cmn, next, lsiz23, 750, 1);
  subscr(cmn, ib, lsiz23, 750, 2);
  kolum(isubs1) = kolum(isubs2);
  goto statement_720;
statement_760:
  isubs1 = iofkor + ib;
  subscr(cmn, ib, lsiz23, 760, 1);
  if (korder(isubs1) == 0) {
    goto statement_790;
  }
  isubs1 = iofkor + ib;
  subscr(cmn, ib, lsiz23, 770, 1);
  ib = korder(isubs1);
statement_780:
  isubs1 = iofkol + next;
  isubs2 = iofkol + ib;
  subscr(cmn, next, lsiz23, 780, 1);
  subscr(cmn, ib, lsiz23, 780, 2);
  kolum(isubs1) = kolum(isubs2);
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 780, 3);
  korder(isubs1) = next;
  goto statement_680;
statement_790:
  if (ischm != 2) {
    goto statement_270;
  }
  if (kownt(j) == (-1)) {
    goto statement_270;
  }
  //C 800 IF (ICON) 810, 270, 830                                           M31.1048
  //C 810 IF (KOWNT(J) +ICON .GE. NCN)   GO TO 830                          M31.1049
  if (icon == 0) {
    goto statement_270;
  }
  subscr(cmn, j, lbus, 800, 1);
  //C     THIS CHECK HERE ALSO ENSURE "J" AT S.N. 830 IS OK:                M31.1052
  if (icon > 0) {
    goto statement_830;
  }
  n13 = kownt(j) + icon;
  if (n13 >= ncn) {
    goto statement_830;
  }
  ncn = kownt(j) + icon;
  subscr(cmn, j, lbus, 820, 1);
  //C     CALL SUBSCR  NOT NEEDED HERE (J IS OK;  SEE BELOW 800):           M31.1057
statement_830:
  if (ich2(j) == 0) {
    goto statement_850;
  }
  L = ich2(j);
  k = ich1(j);
  subscr(cmn, j, lbus, 840, 1);
  subscr(cmn, k, lbus, 840, 99);
  subscr(cmn, L, lbus, 840, 3);
  ich1(L) = k;
  if (k > 0) {
    ich2(k) = L;
  }
  m = kownt(j) + icon;
  goto statement_860;
statement_850:
  k = ich1(j);
  subscr(cmn, j, lbus, 850, 1);
  subscr(cmn, k, lbus, 850, 99);
  if (k > 0) {
    ich2(k) = 0;
  }
  m = kownt(j);
  jsub = m + 1;
  subscr(cmn, jsub, lbus, 850, 3);
  e(m + 1) = k;
  m += icon;
statement_860:
  kownt(j) = m;
  subscr(cmn, j, lbus, 860, 1);
  jsub = m + 1;
  subscr(cmn, jsub, lbus, 860, 2);
  k = e(m + 1);
  e(m + 1) = j;
  ich1(j) = k;
  subscr(cmn, k, lbus, 860, 99);
  if (k > 0) {
    ich2(k) = j;
  }
  ich2(j) = 0;
  goto statement_270;
statement_1110:
  js = loc(i);
  subscr(cmn, i, lbus, 1110, 1);
  goto statement_1130;
statement_1120:
  isubs1 = iofkor + js;
  subscr(cmn, js, lsiz23, 1120, 1);
  js = korder(isubs1);
statement_1130:
  icon = 0;
  if (js == 0) {
    goto statement_200;
  }
  isubs1 = iofkol + js;
  subscr(cmn, js, lsiz23, 1150, 1);
  j = kolum(isubs1);
  subscr(cmn, j, lbus, 1150, 2);
  if (kownt(j) < 0) {
    goto statement_1120;
  }
  ks = loc(j);
  ls = ks;
  goto statement_1170;
statement_1160:
  isubs1 = iofkor + ks;
  subscr(cmn, ks, lsiz23, 1160, 1);
  ks = korder(isubs1);
statement_1170:
  if (ks != 0) {
    goto statement_1190;
  }
  icon = icon / 2;
  goto statement_1410;
statement_1190:
  isubs1 = iofkol + ks;
  subscr(cmn, ks, lsiz23, 1190, 1);
  k = kolum(isubs1);
  jb = ls;
  subscr(cmn, k, lbus, 1190, 2);
  kb = loc(k);
statement_1200:
  isubs1 = iofkol + jb;
  isubs2 = iofkol + kb;
  //C     IF (KOLUM(ISUBS1)    -KOLUM(ISUBS2)   ) 1210, 1250, 1270          M31.1079
  //C1210 ISUBS1 =  IOFKOL+JB                                               M31.1080
  subscr(cmn, jb, lsiz23, 1200, 1);
  subscr(cmn, kb, lsiz23, 1200, 2);
  n13 = kolum(isubs1) - kolum(isubs2);
  if (n13 == 0) {
    goto statement_1250;
  }
  if (n13 > 0) {
    goto statement_1270;
  }
  isubs1 = iofkol + jb;
  if (kolum(isubs1) == k) {
    goto statement_1230;
  }
  icon++;
statement_1230:
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 1230, 1);
  jb = korder(isubs1);
  if (jb != 0) {
    goto statement_1200;
  }
  goto statement_1160;
statement_1250:
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 1250, 1);
  if (korder(isubs1) == 0) {
    goto statement_1160;
  }
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 1260, 1);
  jb = korder(isubs1);
statement_1270:
  isubs1 = iofkor + kb;
  subscr(cmn, kb, lsiz23, 1270, 1);
  if (korder(isubs1) == 0) {
    goto statement_1290;
  }
  isubs1 = iofkor + kb;
  subscr(cmn, kb, lsiz23, 1280, 1);
  kb = korder(isubs1);
  goto statement_1200;
statement_1290:
  isubs1 = iofkol + jb;
  subscr(cmn, jb, lsiz23, 1290, 1);
  if (kolum(isubs1) == k) {
    goto statement_1310;
  }
  icon++;
statement_1310:
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 1310, 1);
  if (korder(isubs1) == 0) {
    goto statement_1160;
  }
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 1320, 1);
  jb = korder(isubs1);
  goto statement_1290;
  //C1410 IF (KOWNT(J) -ICON) 1440, 1120, 1420                              M31.1095
  //C1420 IF (NCN .LE. ICON)   GO TO 1440                                   M31.1096
statement_1410:
  subscr(cmn, j, lbus, 1410, 1);
  n13 = kownt(j) - icon;
  if (n13 < 0) {
    goto statement_1440;
  }
  if (n13 == 0) {
    goto statement_1120;
  }
  if (ncn <= icon) {
    goto statement_1440;
  }
  ncn = icon;
statement_1440:
  if (ich2(j) == 0) {
    goto statement_1460;
  }
  //C     NO CHECK OF "J" NEEDED AT 1440 ABOVE, SINCE ONLY THRU 1410        M31.1102
  //C     CALL SUBSCR ( J, LBUS,  ----- NOT NEEDED.                         M31.1103
  L = ich2(j);
  k = ich1(j);
  subscr(cmn, j, lbus, 1450, 1);
  subscr(cmn, L, lbus, 1450, 2);
  subscr(cmn, k, lbus, 1450, 3);
  ich1(L) = k;
  ich2(k) = L;
  m = icon;
  goto statement_1470;
statement_1460:
  k = ich1(j);
  subscr(cmn, j, lbus, 1460, 1);
  subscr(cmn, k, lbus, 1460, 2);
  ich2(k) = 0;
  m = kownt(j);
  jsub = m + 1;
  subscr(cmn, jsub, lbus, 1460, 3);
  e(m + 1) = k;
  m = icon;
statement_1470:
  kownt(j) = m;
  jsub = m + 1;
  subscr(cmn, jsub, lbus, 1470, 1);
  subscr(cmn, j, lbus, 1470, 2);
  k = e(m + 1);
  e(m + 1) = j;
  ich1(j) = k;
  ich2(k) = j;
  subscr(cmn, k, lbus, 1470, 3);
  ich2(j) = 0;
  goto statement_1120;
statement_1510:
  icon = 0;
  subscr(cmn, i, lbus, 1510, 1);
  if (kownt(i) < 0) {
    goto statement_170;
  }
  ks = loc(i);
  ls = ks;
statement_1520:
  if (ks != 0) {
    goto statement_1540;
  }
  j = icon / 2;
  subscr(cmn, i, lbus, 1530, 1);
  kownt(i) = j;
  goto statement_155;
statement_1540:
  isubs1 = iofkol + ks;
  subscr(cmn, ks, lsiz23, 1540, 1);
  k = kolum(isubs1);
  jb = ls;
  kb = loc(k);
  subscr(cmn, k, lbus, 1540, 2);
statement_1550:
  isubs1 = iofkol + jb;
  isubs2 = iofkol + kb;
  subscr(cmn, jb, lsiz23, 1550, 1);
  subscr(cmn, kb, lsiz23, 1550, 2);
  //C     IF (KOLUM(ISUBS1)    -KOLUM(ISUBS2)   ) 1600, 1560, 1580          M31.1121
  //C1560 ISUBS1 =  IOFKOR+JB                                               M31.1122
  n13 = kolum(isubs1) - kolum(isubs2);
  if (n13 < 0) {
    goto statement_1600;
  }
  if (n13 > 0) {
    goto statement_1580;
  }
  isubs1 = iofkor + jb;
  if (korder(isubs1) == 0) {
    goto statement_1680;
  }
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 1570, 1);
  jb = korder(isubs1);
statement_1580:
  isubs1 = iofkor + kb;
  subscr(cmn, kb, lsiz23, 1580, 1);
  if (korder(isubs1) == 0) {
    goto statement_1640;
  }
  isubs1 = iofkor + kb;
  subscr(cmn, kb, lsiz23, 1590, 1);
  kb = korder(isubs1);
  goto statement_1550;
statement_1600:
  isubs1 = iofkol + jb;
  subscr(cmn, jb, lsiz23, 1600, 1);
  if (kolum(isubs1) == k) {
    goto statement_1620;
  }
  icon++;
statement_1620:
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 1620, 1);
  jb = korder(isubs1);
  if (jb != 0) {
    goto statement_1550;
  }
  goto statement_1680;
statement_1640:
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 1640, 1);
  if (korder(isubs1) == k) {
    goto statement_1660;
  }
  icon++;
statement_1660:
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 1660, 1);
  if (korder(isubs1) == 0) {
    goto statement_1680;
  }
  isubs1 = iofkor + jb;
  subscr(cmn, jb, lsiz23, 1670, 1);
  jb = korder(isubs1);
  goto statement_1640;
statement_1680:
  isubs1 = iofkor + ks;
  subscr(cmn, ks, lsiz23, 1680, 1);
  ks = korder(isubs1);
  goto statement_1520;
statement_9999:
  if (lastov > nchain) {
    goto statement_9996;
  }
  kill = 0;
  write(lunit6,
    "(/,' WARNING ---- NODE RENUMBERING OF THE TRANSIENTS NETWORK HAS BROKEN D"
    "OWN, PRESUMABLY DUE TO TABLE OVERFLOW',/,"
    "' (I.E., THE NETWORK IS TOO BIG AND/OR TOO DENSE FOR THE PRESENT EMTP DIM"
    "ENSIONING).   THE NEXT TIME THAT THE USER',/,"
    "' REDIMENSIONS THE EMTP, HE IS ADVISED TO INCREASE THE SIZE OF LIST NUMBE"
    "R  5  AND/OR  8 .   BOTH OF THESE LISTS',/,"
    "' CONTRIBUTE FULLY (100 PER CENT) TO DEPENDENT LIST NUMBER  99 ,   WHICH "
    "IS WHAT HAS ACTUALLY OVERFLOWED AT THIS POINT.')");
  nelim = nelim - 1;
  write(lunit6,
    "(1x,i4,' NODES OUT OF TOTAL OF ',i4,"
    "' WERE RENUMBERED BEFORE BREAKDOWN IN THE RENUMBERING OVERLAY.',/,"
    "' HAD WE MADE IT TO',i6,"
    "'   NODES, THE OPERATION WOULD HAVE TERMINATED NORMALLY (SINCE THE REMAIN"
    "ING ONES',/,"
    "' ARE ALWAYS FORCED LAST WITHOUT REGARD TO SPARSITY CONSIDERATIONS).')"),
    nelim, ntot, ncurr;
  FEM_DO_SAFE(i, 1, ntot) {
    if (norder(i) > 0) {
      goto statement_2236;
    }
    nelim++;
    norder(i) = nelim;
  statement_2236:;
  }
  write(lunit6,
    "(/,' ANYWAY, THE EMTP WILL TRY TO CONTINUE WITH EXECUTION OF THIS DATA CA"
    "SE, AS BEST IT CAN.   NODES WHICH WERE',/,"
    "' NOT RENUMBERED BEFORE THE OVERFLOW LIMIT WAS REACHED WILL NOW SIMPLY BE"
    " RENUMBERED IN THEIR ORIGINAL RELATIVE',/,"
    "' ORDER, WITHOUT REGARD TO SPARSITY CONSIDERATIONS.   RECALL THAT THE ORI"
    "GINAL NODE ORDER COMES FROM THE ORDER OF DATA',/,"
    "' INPUT (THE ORDER IN WHICH NODE NAMES ARE ENCOUNTERED, AS THE EMTP DATA "
    "CARDS ARE READ).')");
  {
    write_loop wloop(cmn, lunit6,
      "(' THE FINAL RENUMBERING MAP   (NORDER(I), I=1, NTOT)   WILL THEN APPEA"
      "R AS FOLLOWS ....',/(1x,20i6))");
    FEM_DO_SAFE(i, 1, ntot) {
      wloop, norder(i);
    }
  }
  write(lunit6,
    "(' THE  K-TH  SUCH ENTRY GIVES THE ROW (AND COLUMN) POSITION OF OLD VARIA"
    "BLE  K  IN THE REORDERED MATRIX.',/,1x)");
  goto statement_5276;
statement_9996:
  lstat(18) = 7;
  lastov = nchain;
  nchain = 51;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
statement_99999:;

} // over7


void frqchk(
  common& cmn)
{
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  auto& lstat = cmn.lstat;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  const auto& length = cmn.length;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& iform = cmn.iform;
  const auto& tclose = cmn.tclose;
  const auto& adelay = cmn.adelay;
  const auto& node = cmn.node;
  const auto& tstart = cmn.tstart;
  const auto& sfreq = cmn.sfreq;
  const auto& kmswit = cmn.kmswit;
  auto& kssfrq = cmn.kssfrq;
  auto& kpsour = cmn.kpsour;
  const auto& bus = cmn.bus;
  //
  auto& lunit6 = cmn.lunit6;
  int n13 = fem::int0;
  int n11 = fem::int0;
  int n14 = fem::int0;
  double d12 = fem::double0;
  int n16 = fem::int0;
  int i = fem::int0;
  int n4 = fem::int0;
  int k = fem::int0;
  int n8 = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  int j = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int n12 = fem::int0;
  int n5 = fem::int0;
  int n10 = fem::int0;
  int n15 = fem::int0;
  int n20 = fem::int0;
  int ndx1 = fem::int0;
  int n17 = fem::int0;
  int n9 = fem::int0;
  int n18 = fem::int0;
  int n19 = fem::int0;
  static const char* format_1482 = "(' KPSOUR:',20i5)";
  //C     MODULE CALLED IN TWO PLACES BY "OVER8" TO DETERMINE WHICH         M31.1318
  //C     NODES ARE EXCITED BY WHICH SOURCES (SUBNETWORK BOUNDING),         M31.1319
  //C     WITH ERROR STOP IF THERE IS FREQUENCY MIXING.                     M31.1320
  if (iprsup >= 1) {
    write(lunit6,
      "(' TOP OF \"FRQCHK\".','    NTOT  KCONST     IBR  KSWTCH      IT',/,"
      "17x,8i8)"),
      ntot, kconst, ibr, kswtch, cmn.it;
  }
  //C     FIRST DETERMINE THE PHASOR FREQUENCY OF EACH NETWORK NODE:        M31.1328
  move0(kssfrq, ntot);
  n13 = 0;
  n11 = 0;
  n14 = 0;
  d12 = 0.0f;
  n16 = 0;
  FEM_DO_SAFE(i, 1, kconst) {
    n4 = fem::iabs(node(i));
    kpsour(i) = i;
    if (kssfrq(n4) > 0) {
      goto statement_1438;
    }
    if (fem::iabs(iform(i)) != 14) {
      goto statement_1438;
    }
    if (tstart(i) == 5432.f) {
      goto statement_1434;
    }
    if (tstart(i) >= 0.0f) {
      goto statement_1438;
    }
  statement_1434:
    kssfrq(n4) = i;
    if (iform(i + 1) != 18) {
      goto statement_1436;
    }
    n4 = node(i + 1);
    kssfrq(n4) = i;
  statement_1436:
    if (n13 == 0) {
      n13 = i;
    }
    if (d12 == 0.0f) {
      d12 = sfreq(i);
    }
    if (sfreq(i) == d12) {
      goto statement_1438;
    }
    n16 = 1;
  statement_1438:;
  }
  if (n16 == 0) {
    goto statement_1480;
  }
statement_1441:
  k = 1;
  n8 = 0;
statement_1446:
  n6 = fem::iabs(length(k));
  n7 = k;
  FEM_DO_SAFE(j, 1, n6) {
    n1 = fem::iabs(kbus(n7));
    n2 = fem::iabs(mbus(n7));
    if (kssfrq(n1) == 0) {
      goto statement_1453;
    }
    if (n1 == 1) {
      goto statement_1453;
    }
    n12 = kssfrq(n1);
    goto statement_1458;
  statement_1453:
    if (kssfrq(n2) == 0) {
      goto statement_1456;
    }
    if (n2 == 1) {
      goto statement_1456;
    }
    n12 = kssfrq(n2);
    goto statement_1458;
  statement_1456:
    n7++;
  }
  k += n6;
  goto statement_1469;
statement_1458:
  d12 = sfreq(n12);
  FEM_DO_SAFE(j, 1, n6) {
    n2 = 0;
    n1 = fem::iabs(kbus(k));
  statement_1461:
    n16 = kssfrq(n1);
    if (n1 <= 1) {
      goto statement_2465;
    }
    if (n16 <= 0) {
      goto statement_1464;
    }
    if (sfreq(n16) == d12) {
      goto statement_1462;
    }
    kill = 222;
    n11++;
    if (n11 > 1) {
      goto statement_1462;
    }
    n5 = k;
    n10 = n12;
    n15 = fem::iabs(kbus(k));
    n20 = fem::iabs(mbus(k));
    bus1 = bus(n1);
    bus2 = bus(n2);
  statement_1462:
    if (kpsour(n12) < kpsour(n16)) {
      goto statement_1463;
    }
    kpsour(n12) = kpsour(n16);
    goto statement_2465;
  statement_1463:
    kpsour(n16) = kpsour(n12);
    goto statement_2465;
  statement_1464:
    kssfrq(n1) = n12;
    n8++;
  statement_2465:
    if (n2 > 0) {
      goto statement_1467;
    }
    n2 = 1;
    n1 = fem::iabs(mbus(k));
    goto statement_1461;
  statement_1467:
    k++;
  }
  if (iprsup >= 6) {
    write(lunit6, "(' K, LENGTH(K), N6, N8, N12, D12 =',5i6,f10.2)"),
      k, length(k), n6, n8, n12, d12;
  }
statement_1469:
  if (k <= ibr) {
    goto statement_1446;
  }
  if (kswtch <= 0) {
    goto statement_1475;
  }
  FEM_DO_SAFE(j, 1, kswtch) {
    if (adelay(j) == -44444.f) {
      goto statement_1470;
    }
    if (tclose(j) >= 0.0f) {
      goto statement_1474;
    }
    if (adelay(j) == 44444.f) {
      goto statement_1474;
    }
  statement_1470:
    n1 = fem::iabs(kmswit(j));
    ndx1 = cmn.lswtch + j;
    n2 = fem::iabs(kmswit(ndx1));
    if (n1 == 1) {
      goto statement_1474;
    }
    if (n2 == 1) {
      goto statement_1474;
    }
    n16 = kssfrq(n1);
    n17 = kssfrq(n2);
    if (n16 + n17 == 0) {
      goto statement_1474;
    }
    if (n16 * n17 == 0) {
      goto statement_1473;
    }
    if (sfreq(n16) == sfreq(n17)) {
      goto statement_1471;
    }
    kill = 223;
    n14++;
    if (n14 > 1) {
      goto statement_1471;
    }
    n9 = j;
    bus3 = bus(n1);
    bus4 = bus(n2);
    n18 = kssfrq(n1);
    n19 = kssfrq(n2);
  statement_1471:
    if (kpsour(n16) < kpsour(n17)) {
      kpsour(n17) = kpsour(n16);
    }
    if (kpsour(n16) > kpsour(n17)) {
      kpsour(n16) = kpsour(n17);
    }
    goto statement_1474;
  statement_1473:
    n8++;
    if (kssfrq(n1) == 0) {
      kssfrq(n1) = kssfrq(n2);
    }
    if (kssfrq(n2) == 0) {
      kssfrq(n2) = kssfrq(n1);
    }
  statement_1474:;
  }
statement_1475:
  if (iprsup >= 5) {
    {
      write_loop wloop(cmn, lunit6,
        "(' ADDITIONAL FREQUENCY SPREADING.   N8 =',i5,"
        "'      (KSSFRQ(J), J=1, NTOT)  FOLLOWS ....',/(1x,20i4))");
      wloop, n8;
      FEM_DO_SAFE(j, 1, ntot) {
        wloop, kssfrq(j);
      }
    }
  }
  if (iprsup >= 5) {
    {
      write_loop wloop(cmn, lunit6, "(' KPSOUR:',20i5)");
      FEM_DO_SAFE(j, 1, kconst) {
        wloop, kpsour(j);
      }
    }
  }
  if (n8 > 0) {
    goto statement_1441;
  }
statement_1480:
  FEM_DO_SAFE(i, 1, ntot) {
    if (kssfrq(i) == 0) {
      kssfrq(i) = -n13;
    }
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6, format_1482);
      FEM_DO_SAFE(j, 1, kconst) {
        wloop, kpsour(j);
      }
    }
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(' FINAL  (KSSFRQ(J), J=1, NTOT)  FOLLOWS ...',/(1x,20i4))");
      FEM_DO_SAFE(j, 1, ntot) {
        wloop, kssfrq(j);
      }
    }
  }
  FEM_DO_SAFE(k, 1, kconst) {
    if (kpsour(k) < 0) {
      goto statement_1497;
    }
    n16 = k;
    n2 = kpsour(k);
    if (k == kconst) {
      goto statement_1494;
    }
    n7 = k + 1;
    FEM_DO_SAFE(j, n7, kconst) {
      if (kpsour(j) != n2) {
        goto statement_1492;
      }
      kpsour(n16) = -j;
      n16 = j;
    statement_1492:;
    }
  statement_1494:
    kpsour(n16) = -k;
  statement_1497:;
  }
  FEM_DO_SAFE(k, 1, kconst) {
    kpsour(k) = -kpsour(k);
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6, format_1482);
      FEM_DO_SAFE(j, 1, kconst) {
        wloop, kpsour(j);
      }
    }
  }
  if (kill != 222) {
    goto statement_9202;
  }
  lstat(19) = 1462;
  lstat(14) = n5;
  lstat(15) = n10;
  n1 = n15;
  n2 = n20;
  goto statement_9204;
statement_9202:
  if (kill != 223) {
    goto statement_9204;
  }
  lstat(19) = 1471;
  lstat(14) = n9;
  bus1 = bus3;
  bus2 = bus4;
  lstat(15) = n18;
  lstat(16) = n19;
statement_9204:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT \"FRQCHK\".')");
  }
}

void umrnu2(
  common& cmn,
  arr_ref<double> reacl,
  arr_ref<double> gpar,
  arr_ref<double> fpar,
  arr_ref<double> hist,
  arr_ref<double> umcurp,
  arr_ref<int> nodvo1,
  arr_cref<int> jtype,
  arr_ref<int> nodom,
  arr_ref<int> jtmtac,
  arr_ref<double> thetam,
  int& imach,
  arr_cref<double> reamdu,
  arr_cref<double> reamqu,
  arr_ref<int> nodvo2,
  arr_cref<int> nppair,
  arr_cref<double> rotmom,
  arr_cref<int> ncld,
  arr_ref<int> jcltac,
  int& kcl,
  arr_cref<int> nclq,
  arr_ref<double> epsom,
  arr_cref<double> /* dcoef */,
  arr_cref<int> kcoil,
  arr_ref<double> voltum,
  arr_ref<double> anglum,
  arr_cref<int> nodfum,
  arr_ref<int> nodmum,
  arr_ref<double> umoutp)
{
  reacl(dimension(1));
  gpar(dimension(1));
  fpar(dimension(1));
  hist(dimension(1));
  umcurp(dimension(1));
  nodvo1(dimension(1));
  jtype(dimension(1));
  nodom(dimension(1));
  jtmtac(dimension(1));
  thetam(dimension(1));
  reamdu(dimension(1));
  reamqu(dimension(1));
  nodvo2(dimension(1));
  nppair(dimension(1));
  rotmom(dimension(1));
  ncld(dimension(1));
  jcltac(dimension(1));
  nclq(dimension(1));
  epsom(dimension(1));
  kcoil(dimension(1));
  voltum(dimension(1));
  anglum(dimension(1));
  nodfum(dimension(1));
  nodmum(dimension(1));
  umoutp(dimension(1));
  common_write write(cmn);
  double& d4 = cmn.d4;
  double& d10 = cmn.d10;
  double& d11 = cmn.d11;
  double& d12 = cmn.d12;
  double& d13 = cmn.d13;
  double& d14 = cmn.d14;
  double& d15 = cmn.d15;
  double& d16 = cmn.d16;
  int& lfim3 = cmn.lfim3;
  int& lfim4i = cmn.lfim4i;
  int& ncomcl = cmn.ncomcl;
  int& ncomum = cmn.ncomum;
  int& kcld1 = cmn.kcld1;
  int& kclq1 = cmn.kclq1;
  int& nminum = cmn.nminum;
  double& slip = cmn.slip;
  double& epsiln = cmn.epsiln;
  auto& twopi = cmn.twopi;
  double& xopt = cmn.xopt;
  int& istep = cmn.istep;
  int& lexct = cmn.lexct;
  int& numum = cmn.numum;
  int& numout = cmn.numout;
  int& numsub = cmn.numsub;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& it = cmn.it;
  int& ibr = cmn.ibr;
  int& kssout = cmn.kssout;
  auto& loopss = cmn.loopss;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  auto& tstop = cmn.tstop;
  auto& ksub = cmn.ksub;
  auto& msub = cmn.msub;
  auto& isubeg = cmn.isubeg;
  auto& vinp = cmn.vinp;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  auto& iform = cmn.iform;
  auto& node = cmn.node;
  auto& crest = cmn.crest;
  auto& time1 = cmn.time1;
  auto& tstart = cmn.tstart;
  auto& sfreq = cmn.sfreq;
  const auto& kssfrq = cmn.kssfrq;
  const auto& kpsour = cmn.kpsour;
  const auto& norder = cmn.norder;
  const auto& bus = cmn.bus;
  int& ncltot = cmn.ncltot;
  auto& ndum = cmn.ndum;
  int& ksubum = cmn.ksubum;
  //
  int i = fem::int0;
  int n9 = fem::int0;
  int n10 = fem::int0;
  int n11 = fem::int0;
  int n1 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int nummec = fem::int0;
  int j = fem::int0;
  int kclj = fem::int0;
  int n4 = fem::int0;
  int n2 = fem::int0;
  int n5 = fem::int0;
  int n3 = fem::int0;
  int n8 = fem::int0;
  int n6 = fem::int0;
  int n15 = fem::int0;
  int k = fem::int0;
  int ncl = fem::int0;
  int kcle = fem::int0;
  double d3 = fem::double0;
  int n19 = fem::int0;
  int n18 = fem::int0;
  int n20 = fem::int0;
  int n13 = fem::int0;
  int n14 = fem::int0;
  int n7 = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double d17 = fem::double0;
  int n12 = fem::int0;
  int n17 = fem::int0;
  static const char* format_1904 =
    "(' UM NUMBER',i4,' :',28x,'NODE TO NODE   IBR',4x,'IT',8x,'TR(IT)',8x,"
    "'TX(IT)',2x,'KCONST',9x,'SFREQ',9x,'CREST')";
  static const char* format_2052 =
    "(' *********',' IM MAIN IND BRANCHE FOR LD-FLOW',2x,i4,4x,i4,2i6,2e14.5)";
  static const char* format_2054 =
    "(' *********',' PARALL RESIST. FOR POWER COILS',3x,i4,4x,i4,2i6,2e14.5)";
  static const char* format_6783 =
    "(' OVERFLOW LIST 4 IN \"UMRENU\".  LEXCT =',i5,'     STOP LOCALLY.')";
  static const char* format_82245 =
    "(/,' ERROR STOP. UM NUMBER',i4,' HAS MORE THAN',"
    "' 40 EXCITATION BRANCHES OR SOURCES. OVERFLOW',"
    "' IS AVOIDED BY INCREASING THE DIMENSION OF',/,"
    "' THE ARRAYS \"VINP\" AND \"NDUM\" IN UMDECK TO BE',"
    "' ONE HIGHER THAN THESE USED ELEMENTS.')";
  //C!w added z to void name crash
  //C   "FIRST PART" OF UMRENU CODE IS ENTERED TWICE IF LOAD-FLOW           M42.5005
  //C       IS REQUESTED (LOOPSS(10) = 1 OR 2). THIS IS NEEDED TO           M42.5006
  //C       LET THE LOAD-FLOW DO ITS WORK TO ADJUST THE SOURCES.            M42.5007
  //C       HOWEVER, IF UM TYPE-3 IS PRESENT, THE FIRST PART WILL           M42.5008
  //C       BE ENTERED ONE ADDITIONAL PASS PRIOR TO THE TWO                 M42.5009
  //C       MENTIONED PASSES IN ORDER TO FIND THE THEV PARAMETERS OF        M42.5010
  //C       THE UM TYPE-3 EXCITATION CIRCUITS (LOOPSS(10) = 3).             M42.5011
  //C.  ....... CODE FOR UM STEADY-STATE INITIALIZATION ............        M42.5012
  //C. "FIRST PART" OF CODE : SET UP OF VECTORS ********************        M42.5013
  //C     NOTE: THIS PART TILL STMT 1400 IS ONLY ENTERED IF ISTART=0        M42.5014
  if (loopss(10) > 1) {
    goto statement_1400;
  }
  if (cmn.istart > 0) {
    return;
  }
  loopss(9) = 0;
  imach = 0;
  //C   RENUMBERING MECHANICAL NODES :                                      M42.5019
  FEM_DO_SAFE(i, 1, numum) {
    n9 = nodom(i);
    nodom(i) = norder(n9);
  }
  FEM_DO_SAFE(i, 1, numum) {
    kcl = kcoil(i);
    if (jtmtac(i) > 0) {
      goto statement_1250;
    }
    //C. FIND THE UM'S CONNECTED TO SAME MECHANICAL NETWORK :                 M42.5027
    //C    (INITIALIZE JCLTAC(KCL AND KCL+1) AND IDENTIFYING NODMUM)          M42.5028
    n10 = nodom(i);
    n10 = kssfrq(n10);
    if (n10 < 0) {
      goto statement_1250;
    }
    n11 = n10;
    n1 = 0;
  statement_1246:
    n1++;
    ndum(n1) = n10;
    n10 = kpsour(n10);
    if (n10 != n11) {
      goto statement_1246;
    }
    if (n1 == 1) {
      goto statement_1250;
    }
    if (n1 <= 40) {
      goto statement_81246;
    }
    write(lunit6,
      "(/,' ERROR STOP. THERE ARE ',i2,' TYPE-14',"
      "' SOURCES PRESENT IN MECHANICAL NETWORK OF',' UM NUMBER',i4,"
      "'.  THIS NUMBER OVERFLOWS THE',/,"
      "' LIMIT OF 40. INCREASING THIS LIMIT CAN BE',"
      "' DONE BY INCREASING THE DIMENSION OF ARRAY',"
      "' \"NDUM\" WHICH IS DIMENSIONED IN \"UMDECK\".')"),
      n1, i;
    stoptp(cmn);
  statement_81246:
    nummec = 0;
    FEM_DO_SAFE(j, 1, numum) {
      if (j == i) {
        goto statement_1248;
      }
      kclj = kcoil(j);
      n4 = nodom(j);
      n4 = kssfrq(n4);
      if (n4 < 0) {
        goto statement_1248;
      }
      FEM_DO_SAFE(n2, 1, n1) {
        if (ndum(n2) != n4) {
          goto statement_1247;
        }
        nummec++;
        if (nummec == 1) {
          jcltac(kcl) = j;
        }
        if (nummec == 2) {
          jcltac(kcl + 1) = j;
        }
        if (j > i) {
          nodmum(j) = nodmum(i);
        }
        goto statement_1248;
      statement_1247:;
      }
    statement_1248:;
    }
    if (nummec <= 2) {
      goto statement_1250;
    }
    n2 = nummec - 1;
    write(lunit6,
      "(/,' ERROR STOP. UM NUMBER',i4,' IS CONNECTED',' MECHANICALLY TO ',i2,"
      "' OTHER UM''S. THIS',' CAN NOT BE HONORED BECAUSE AT THE MOST ONLY',/,"
      "' 3 UM''S CAN BE CONNECTED TO A SAME MECHANICAL',"
      "' NETWORK. YOU MAY RESOLVE THIS PROBLEM BY',"
      "' INSERTING STUB LINES IN ORDER TO SEPERATE')"),
      i, n2;
    write(lunit6, "(' THE MECHANICAL NETWORK',' FROM THE REMAINING UM''S.')");
    stoptp(cmn);
    //C. DEFAULT VALUE FOR EPSOM(I) :                                         M42.5077
  statement_1250:
    if (epsom(i) != 0.0f) {
      goto statement_1260;
    }
    epsom(i) = 0.001f;
    if (jtype(i) == 13) {
      goto statement_1255;
    }
    if (cmn.inpu == 1) {
      goto statement_1260;
    }
  statement_1255:
    epsom(i) = 0.001f * rotmom(i) / nppair(i);
  statement_1260:
    if (jtype(i) > 2 && jtype(i) < 8) {
      imach = 1;
    }
    if (jtype(i) == 3 && loopss(10) == 1) {
      loopss(10) = 3;
    }
    //C   RENUMBERING ELECTRICAL NODES :                                      M42.5085
    if (jtmtac(i) >= 0) {
      goto statement_1262;
    }
    n9 = -jtmtac(i);
    jtmtac(i) = -norder(n9);
  statement_1262:
    if (jtype(i) != 13) {
      goto statement_1270;
    }
    if (fpar(kcl + 3) >= 0.0f) {
      goto statement_1270;
    }
    n5 = fpar(kcl + 4);
    fpar(kcl + 4) = norder(n5);
    n5 = fpar(kcl + 5);
    fpar(kcl + 5) = norder(n5);
  statement_1270:
    n2 = 3 * (i - 1);
    FEM_DO_SAFE(n1, 1, 3) {
      n3 = umcurp(n1 + n2);
      n3 = norder(n3);
      umcurp(n1 + n2) = n3;
    }
  }
  if (imach == 1 && loopss(8) == 1) {
    loopss(9) = 1;
  }
  FEM_DO_SAFE(i, 1, ncltot) {
    n8 = nodvo1(i);
    nodvo1(i) = norder(n8);
    n9 = nodvo2(i);
    nodvo2(i) = norder(n9);
  }
  //C  RENUMBERING IN CASE OF TACS TRANSFER WITH SM TYPE-59 DATA :          M42.5108
  if (cmn.nsmach == 0) {
    goto statement_1340;
  }
  n5 = umoutp(numout + 1);
  if (n5 != -9999.0f) {
    goto statement_1340;
  }
  n5 = numout + 4;
  n6 = umoutp(numout + 3) - 2;
statement_1330:
  if (n5 > n6) {
    goto statement_1338;
  }
  n8 = umoutp(n5);
  if (n8 == -2) {
    goto statement_1332;
  }
  if (n8 == -3) {
    goto statement_1332;
  }
  if (n8 == -5) {
    goto statement_1332;
  }
  if (n8 > -298) {
    goto statement_1334;
  }
statement_1332:
  n9 = umoutp(n5 + 1);
  umoutp(n5 + 1) = norder(n9);
  n5 += 3;
  if (n8 <= -299) {
    n5 += 5;
  }
  goto statement_1330;
statement_1334:
  n5++;
  goto statement_1330;
statement_1338:
  n5 = umoutp(numout + 3);
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' UM OUTPUT TABLE UMOUTP(NUMOUT+NSMTAC+3)',"
        "' WITH SOME ENTRIES RENUMBERED BECAUSE OF',"
        "' TACS INTERFACE FOR SM-59 DATA INPUT :',/,6(6x,e14.5),/(6(6x,"
        "e14.5)))");
      FEM_DO_SAFE(i, 1, n5) {
        wloop, umoutp(i);
      }
    }
  }
statement_1340:
  if (iprsup < 1) {
    goto statement_1350;
  }
  write(lunit6, "(/,' UM NODES AFTER RENUMBERING :')");
  {
    write_loop wloop(cmn, lunit6, "(' NODVO1(1:NCLTOT) :',20i5)");
    FEM_DO_SAFE(i, 1, ncltot) {
      wloop, nodvo1(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(' NODVO2(1:NCLTOT) :',20i5)");
    FEM_DO_SAFE(i, 1, ncltot) {
      wloop, nodvo2(i);
    }
  }
  n5 = 3 * numum;
  {
    write_loop wloop(cmn, lunit6, "(' UMCURP(1:3NUMUM) :',20f5.1)");
    FEM_DO_SAFE(i, 1, n5) {
      wloop, umcurp(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(' KCOIL(1:NUMUM)   :',20i5)");
    FEM_DO_SAFE(i, 1, numum) {
      wloop, kcoil(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(' NODOM(1:NUMUM)   :',20i5)");
    FEM_DO_SAFE(i, 1, numum) {
      wloop, nodom(i);
    }
  }
  //C.   IF USER DOES NOT REQUEST FOR AUTOMATIC INITIALIZATION :            M42.5148
statement_1350:
  if (cmn.initum == 0) {
    return;
  }
  //C.   SETTING OF ALL FLAGS (IF NOT INCLUDED, THEN THEY ARE 0):           M42.5150
  loopss(3) = kconst;
  loopss(5) = ibr;
  loopss(12) = loopss(5);
  loopss(7) = kssout;
  hist(kcl + 1) = numsub;
  kssout = 0;
  //C  ******* POINT OF ENTRANCE AT SECOND PASS THRU "FIRST PART".          M42.5157
statement_1400:
  if (loopss(10) != 3) {
    goto statement_1480;
  }
  if (istep == -4567) {
    goto statement_1480;
  }
  loopss(10) = 1;
  istep = -4567;
  lfim3 = 1;
statement_1480:
  if (loopss(10) != 2) {
    goto statement_1500;
  }
  kconst = loopss(3);
  ibr = loopss(12);
  it = -nr(ibr);
  numsub = hist(kcl + 1);
statement_1500:
  n15 = 0;
  ncomcl = 0;
  ncomum = 0;
  //C   ************** START MACHINE DO-LOOP ***************                M42.5171
  FEM_DO_SAFE(k, 1, numum) {
    lfim4i = 0;
    kcl = kcoil(k);
    ncl = 3 + ncld(k) + nclq(k);
    kcld1 = kcl + 3;
    kclq1 = kcld1 + ncld(k);
    if (jtype(k) == 4) {
      ncl++;
    }
    kcle = kcl - 1 + ncl;
    if (k == 1) {
      ksubum = numsub + 1;
    }
    imach = 1;
    if (jtype(k) < 3) {
      imach = 0;
    }
    if (jtype(k) > 7) {
      imach = 0;
    }
    if (imach == 1) {
      slip = voltum(k) / 100.0f;
    }
    if (loopss(10) != 3) {
      goto statement_1900;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' ***************************************',"
        "' PREPARING THEVENIN CALCULATION FOR UM TYPE-3',"
        "' EXCITATION CIRCUITS DUE TO LD-FLOW REQUEST:')");
    }
    goto statement_2008;
  statement_1900:
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' ***************************************',"
        "' MOMENTARY CREATION OF ADDITIONAL EMTP',"
        "' ELEMENTS (PERMANENT BRANCHES IF POWER',/,"
        "' ***************************************',"
        "' COILS ARE NON-COMP.) FOR STEADY-STATE',' CALCULATIONS OF')");
    }
    if (iprsup >= 1) {
      write(lunit6, format_1904), k;
    }
    if (jtype(k) == 4 && loopss(10) == 1) {
      lfim4i = 1;
    }
    if (jtype(k) == 4 && loopss(10) == 2) {
      lfim4i = 2;
    }
    //C  BRING THE IM TYPE-4 EXCITATION  SOURCES BACK TO SLIP-FREQ AT         M42.5204
    //C       PASS FOR WHICH LOOPSS(10) = 2 AND UM = IM TYPE-4 :              M42.5205
    //C  NOTE : THIS IS NOT NECESSARY FOR THE ROTOR RESISTANCES               M42.5206
    //C         BECAUSE OF THE "RESTORE" FEATURE FOR R,L,C BRANCHES.          M42.5207
    if (lfim4i != 2) {
      goto statement_2000;
    }
    if (loopss(10) != 2) {
      goto statement_2000;
    }
    d3 = slip;
    if (d3 < 0.0f) {
      d3 = -d3;
    }
    n19 = fpar(kcl + 1);
    n18 = ncl - 3;
    n20 = n19 - 1 + n18;
    FEM_DO_SAFE(n13, 1, n18) {
      n14 = kcl + 2 + n13;
      n2 = nodvo1(n14);
      if (n2 == 1) {
        n2 = nodvo2(n14);
      }
      if (n2 == 1) {
        goto statement_1970;
      }
      n3 = kssfrq(n2);
      n4 = n3;
      if (n3 >= n19 && n3 <= n20) {
        sfreq(n3) = d3 * sfreq(n3);
      }
    statement_1950:
      if (n3 >= n19 && n3 <= n20) {
        goto statement_1960;
      }
      if (node(n3) < 0) {
        goto statement_1960;
      }
      crest(n3) = -slip * crest(n3);
      sfreq(n3) = d3 * sfreq(n3);
      if (slip < 0.0f) {
        time1(n3) = -time1(n3);
      }
      d4 = time1(n3) * 360.0f / twopi;
      n6 = node(n3);
      if (n13 == 1) {
        write(lunit6,
          "(/,' ON COMPLETION OF THE LOAD-FLOW CALCULATIONS,',"
          "' THE ARGUMENTS OF THE TYPE-14 SOURCES USED TO',"
          "' REPRESENT THE EXTERNAL VOLTAGE SOURCES IN',/,"
          "' THE EXCITATION NETWORK OF UM NUMBER',i4,"
          "',  ARE ADJUSTED BY THE PROGRAM AS :')"),
          k;
      }
      if (n13 == 1) {
        write(lunit6,
          "(' BUS NAME',2x,'  AMPLITUDE(V)',2x,' FREQUENCY(HZ)',2x,"
          "'   ANGLE(DEGR)')");
      }
      write(lunit6, "(3x,a6,3e16.5)"), bus(n6), crest(n3), sfreq(n3), d4;
      if (n13 == n18) {
        write(lunit6, "(/)");
      }
    statement_1960:
      n3 = kpsour(n3);
      if (n3 != n4) {
        goto statement_1950;
      }
    statement_1970:;
    }
    //C  ERROR STOP IF LOAD FLOW OF IM WHICH IS NOT OF TYPE 4 AND NOT         M42.5248
    //C    SYMMETRICAL ROUND ROTOR :                                          M42.5249
  statement_2000:
    if (loopss(10) == 0) {
      goto statement_2008;
    }
    if (lfim4i == 0) {
      goto statement_2008;
    }
    if (jtype(k) != 4) {
      goto statement_2002;
    }
    if (reamdu(k) == reamqu(k)) {
      goto statement_2008;
    }
  statement_2002:
    write(lunit6,
      "(/,' ERROR STOP . YOU HAVE REQUESTED A LOAD-FLOW',"
      "' OF A NETWORK CONTAINING AN INDUCTION MACHINE',"
      "' WHICH IS EITHER NOT OF TYPE 4 OR WHICH IS',/,"
      "' OF TYPE 4 BUT IS NOT A SYMMETRICAL MACHINE',"
      "' WITH A ROUND ROTOR. THE CURRENT EMTP VERSION',"
      "' IS NOT CAPABLE OF HONORING YOUR LOAD FLOW',/,' REQUEST.')");
    stoptp(cmn);
    //C  COMPENSATION CODE ************************************* :            M42.5263
  statement_2008:
    if (loopss(10) == 1) {
      goto statement_2048;
    }
    if (imach != 1) {
      goto statement_2048;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(' * * * * * * * * * * * * * * * * * * * * * *',"
        "' BEGIN COMPENSATION FOR IND.MACHINES:',' UM NUMBER',i4,3x,"
        "' NUMSUB =',i4)"),
        k, numsub;
    }
    n1 = 0;
    n18 = 0;
    n2 = ncomcl;
    if (loopss(8) == 1) {
      goto statement_2021;
    }
    n5 = kcoil(k);
    n9 = n5 + 2;
  statement_2018:
    numsub++;
    isubeg(numsub) = n15 + 1;
    FEM_DO_SAFE(j, n5, n9) {
      if (nodvo1(j) == nodvo2(j)) {
        goto statement_2020;
      }
      n15++;
      ncomcl++;
      n18++;
      ksub(n15) = nodvo1(j);
      msub(n15) = nodvo2(j);
    statement_2020:;
    }
    if (n1 == 1) {
      goto statement_2025;
    }
  statement_2021:
    n7 = kcle - kcoil(k) + 1;
    n9 = kcle;
    if (n7 > 6) {
      n9 = kcoil(k) + 5;
    }
    n5 = kcoil(k) + 3;
    n1 = 1;
    if (loopss(8) == 1) {
      goto statement_2022;
    }
    if (ncomcl != n2) {
      goto statement_2022;
    }
    isubeg(numsub) = isubeg(numsub) - n15 - 1;
    numsub = numsub - 1;
  statement_2022:
    n18 = 0;
    goto statement_2018;
  statement_2025:
    if (n18 != 0) {
      goto statement_2030;
    }
    isubeg(numsub) = isubeg(numsub) - n15 - 1;
    numsub = numsub - 1;
  statement_2030:
    if (n7 <= 6) {
      goto statement_2045;
    }
    n5 = kcoil(k) + 6;
    FEM_DO_SAFE(j, n5, kcle) {
      if (nodvo1(j) == nodvo2(j)) {
        goto statement_2040;
      }
      ncomcl++;
      numsub++;
      isubeg(numsub) = n15 + 1;
      n15++;
      ksub(n15) = nodvo1(j);
      msub(n15) = nodvo2(j);
    statement_2040:;
    }
  statement_2045:
    if (iprsup >= 1) {
      write(lunit6,
        "(' * * * * * * * * * * * * * * * * * * * * * *',"
        "' * * * * * * * * * * * * * * *',"
        "' * END COMPENSATION FOR IND.MACH. NUMSUB =',i4)"),
        numsub;
    }
  statement_2048:
    ncomum = ncomcl;
    if (loopss(10) == 3) {
      goto statement_2087;
    }
    //C.  SET TYPE 14 CURRENT SOURCES AND PARALLEL R FOR POWER COILS:         M42.5318
    //C     NOTE : IF LOOPSS(8)=0, MOMENTARY R FOR SM AND DM ONLY TILL        M42.5319
    //C              COMPLETION OF ALL STEADY-STATE UMRENU PASSES.            M42.5320
    //C            IF LOOPSS(8)=1, PERMANENT BRANCHES FOR ALL UM TYPES        M42.5321
    if (imach == 1) {
      goto statement_2050;
    }
    if (loopss(10) == 1) {
      d10 = voltum(k);
    }
    if (loopss(10) == 2) {
      voltum(k) = crest(kconst + 1);
    }
    if (loopss(10) == 2) {
      anglum(k) = time1(kconst + 1) * 360.0f / cmn.t;
    }
  statement_2050:
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + kcoil(k) - 1;
      n4 = 3 * (k - 1);
      if (nodvo1(n2) == nodvo2(n2)) {
        goto statement_2080;
      }
      if (loopss(8) == 0 && imach == 1) {
        goto statement_2055;
      }
      ibrinc(cmn);
      it++;
      kbus(ibr) = nodvo1(n2);
      mbus(ibr) = nodvo2(n2);
      length(ibr) = 1;
      nr(ibr) = -it;
      tr(it) = epsiln;
      tx(it) = 0.0f;
      c(it) = 0.0f;
      if (n1 == 3) {
        hist(kcl) = ibr;
      }
      //C  LOAD-FLOW PREPARATION OF MAIN INDUCTANCE OF IM TYPE-4 :              M42.5341
      //C  NOTE : AFTER COMPLETION OF PROCESSING THE LOAD-FLOW, THESE           M42.5342
      //C         BRANCHES SERVE AS THE POWER RESISTANCE BRANCHE ACROSS         M42.5343
      //C         THE TERMINALS OF THE MACHINE. THE FULLY COMPENSATED IM        M42.5344
      //C         WILL BE PROVIDED WITH THESE BRANCHES ONLY DURING THE          M42.5345
      //C         LOAD-FLOW PROCESS AND ARE CREATED FURTHER DOWN. THEY          M42.5346
      //C         WILL BE WIPED OUT AUTOMATICALLY AFTER COMPLETION OF           M42.5347
      //C         THE LD-FLOW SINCE IN REENTERING THE "FIRST PART" OF           M42.5348
      //C         UMRENU IBR WILL BE RESTORED TO ITS VALUE AS DETERMINED        M42.5349
      //C         IN UMDATA.                                                    M42.5350
      if (lfim4i != 1) {
        goto statement_2053;
      }
      tr(it) = 0.0f;
      tx(it) = reamqu(k) * 1.0e+3;
      if (xopt != 0.0f) {
        tx(it) = reamqu(k) * twopi * xopt;
      }
      if (iprsup >= 1) {
        write(lunit6, format_2052), kbus(ibr), mbus(ibr), ibr, it, tr(it),
          tx(i);
      }
      goto statement_2055;
      //C   SET PARALLEL RESISTANCES FOR SM AND DM AND PREDICTED IM :           M42.5363
    statement_2053:
      if (kbus(ibr) != 1 && mbus(ibr) != 1) {
        tr(it) = epsiln;
      }
      if (loopss(10) == 1) {
        tr(it) = 1.0e+6;
      }
      if (imach == 1) {
        tr(it) = 1.0f;
      }
      if (iprsup >= 1) {
        write(lunit6, format_2054), kbus(ibr), mbus(ibr), ibr, it, tr(it),
          tx(it);
      }
      if (loopss(10) == 1) {
        goto statement_2055;
      }
      d10 = voltum(k) / tr(it);
      //C   SET SOURCES REPRESENTING THE UM POWER COILS :                       M42.5375
    statement_2055:
      if (imach == 1) {
        d10 = 0.0f;
      }
      FEM_DO_SAFE(n3, 1, 2) {
        if (n3 == 2) {
          goto statement_2060;
        }
        if (nodvo1(n2) == 1) {
          goto statement_2070;
        }
        kconst++;
        if (kconst <= lexct) {
          goto statement_6785;
        }
        write(lunit6, format_6783), lexct;
        stoptp(cmn);
      statement_6785:
        n10 = nodvo1(n2);
        node(kconst) = -nodvo1(n2);
        if (loopss(10) != 1) {
          goto statement_2058;
        }
        if (imach == 1) {
          goto statement_2058;
        }
        node(kconst) = umcurp(n4 + n1);
      statement_2058:
        crest(kconst) = d10;
        goto statement_2062;
      statement_2060:
        if (nodvo2(n2) == 1) {
          goto statement_2070;
        }
        kconst++;
        if (kconst <= lexct) {
          goto statement_6786;
        }
        write(lunit6, format_6783), lexct;
        stoptp(cmn);
      statement_6786:
        n10 = nodvo2(n2);
        node(kconst) = -nodvo2(n2);
        if (loopss(10) != 1) {
          goto statement_2061;
        }
        if (imach == 1) {
          goto statement_2061;
        }
        node(kconst) = umcurp(n4 + n1);
      statement_2061:
        crest(kconst) = -d10;
      statement_2062:
        iform(kconst) = 14;
        if (lfim3 == 1 && n1 == 1) {
          hist(kcl + 2) = kconst;
        }
        d1 = anglum(k) * twopi / 360.0f;
        if (n1 != 2) {
          goto statement_2064;
        }
        d2 = d1 - twopi / 3.0f;
        if (jtype(k) == 2) {
          d2 = d1;
        }
        d1 = d2;
        goto statement_2065;
      statement_2064:
        if (n1 != 3) {
          goto statement_2065;
        }
        d2 = d1 + twopi / 3.0f;
        if (jtype(k) == 2) {
          d2 = d1 + twopi / 4.0f;
        }
        if (jtype(k) == 5) {
          d2 = d1 + twopi / 4.0f;
        }
        d1 = d2;
      statement_2065:
        if (imach == 1) {
          d1 = 0.0f;
        }
        if (loopss(10) == 2) {
          goto statement_2066;
        }
        time1(kconst) = d1;
        tstart(kconst) = -1.0f;
        tstop(kconst) = 0.0f;
        n10 = kssfrq(n10);
        if (n10 > 0) {
          goto statement_92066;
        }
        sfreq(kconst) = rotmom(k) / twopi;
        goto statement_2066;
      statement_92066:
        sfreq(kconst) = sfreq(n10);
        //C   FOR LOAD-FLOW THE SM ALWAYS PROVIDE A VOLTAGE SOURCE TO             M42.5427
        //C    REPRESENT MACHINE, WHEREAS IM PROVIDES A DUMMY CURRENT             M42.5428
        //C    SOURCE WHICH WILL BE INITIALIZED AT A LATER PASS AFTER             M42.5429
        //C    DESTRUCTION OF THE IM LOAD-FLOW NETWORK CONFIGURATION.             M42.5430
      statement_2066:
        if (loopss(10) == 0) {
          goto statement_2068;
        }
        if (imach == 1) {
          goto statement_2068;
        }
        if (iprsup >= 1) {
          write(lunit6,
            "(' *********',' VOLTAGE SOURCE FOR POWER COIL',4x,i4,50x,i6,"
            "e14.5,1x,e13.5)"),
            node(kconst), kconst, sfreq(kconst), crest(kconst);
        }
        goto statement_2070;
      statement_2068:
        if (iprsup >= 1) {
          write(lunit6,
            "(' *********',' CURRENT SOURCE FOR POWER COIL',4x,i4,50x,i6,"
            "e14.5,1x,e13.5)"),
            node(kconst), kconst, sfreq(kconst), crest(kconst);
        }
      statement_2070:;
      }
      //C   FOR SM AND DM : MAKE LEAKAGE INDUCTANCE ZERO IN EMTP                M42.5447
      //C    NETWORK FOR THIS NEXT ROUND OF SS CALCULATION BECAUSE              M42.5448
      //C    USER SUPPLIED TERMINAL VOLTAGE SPECIFICATION NEEDS TO              M42.5449
      //C    BE MATCHED. ON THE NEXT ROUND THEY WILL BE RESTORED.               M42.5450
      //C    NOTE: IF LOAD-FLOW IS REQUESTED, THIS ZEROING WILL BE DONE         M42.5451
      //C          ON THE SECOND PASS THROUGH THE FIRST PART OF THE             M42.5452
      //C          UMRENU CODE.                                                 M42.5453
      //C          IF IND MACH IS PRESENT AND NO LOAD-FLOW REQUESTED , T        M42.5454
      //C          THEN THIS PROCEDURE IS TO BE DONE IF LOOPSS(9) = 2,          M42.5455
      //C          I.E. IN "SECOND PART" OF THE UMRENU CODE.                    M42.5456
      if (loopss(10) == 1) {
        goto statement_2076;
      }
      if (imach == 1) {
        goto statement_2076;
      }
      if (loopss(9) != 0) {
        goto statement_2076;
      }
      n10 = fpar(kcl) + n1 - 1;
      n5 = -nr(n10);
      if (n5 < 0) {
        n5 = -n5;
      }
      tx(n5) = epsiln * 1.0e+3;
      if (xopt != 0.0f) {
        tx(n5) = epsiln * twopi * xopt;
      }
      if (iprsup >= 1) {
        write(lunit6,
          "(' *********  LEAKAGE IND. CHANGE:',12x,i4,4x,i4,2i6,2e14.5)"),
          kbus(n10), mbus(n10), n10, n5, tr(n5), tx(n5);
      }
      //C  LOAD-FLOW PREPARATION OF IM TYPE-4 POWER SERIES BRANCHE :            M42.5470
    statement_2076:
      if (lfim4i != 1) {
        goto statement_2080;
      }
      n10 = fpar(kcl) + n1 - 1;
      n5 = -nr(n10);
      if (n5 < 0) {
        n5 = -n5;
      }
      tr(n5) = 1.0f / gpar(kcl + 2);
      if (iprsup >= 1) {
        write(lunit6,
          "(' ********* IM POWER BRANCHE FOR LD-FLOW',5x,i4,4x,i4,2i6,2e14.5)"),
          kbus(n10), mbus(n10), n10, n5, tr(n5), tx(n5);
      }
    statement_2080:;
    }
    //C  STORING PERMANENTLY CREATED BRANCHES (IF FULL COMPENSATION IS        M42.5482
    //C   REQUESTED, THEN ALL CREATED BRANCHES IN UMRENU ARE JUST             M42.5483
    //C   TEMPORARILY)                                                        M42.5484
    if (loopss(8) == 0) {
      goto statement_2081;
    }
    if (loopss(10) != 1) {
      loopss(5) = ibr;
    }
    //C   INITIALIZATION IF INDUCTION MACHINES                                M42.5487
    //C     NOTE : FOR IM WE CHOOSE THE TORQUE ANGLE = 0.0                    M42.5488
  statement_2081:
    if (loopss(10) == 2) {
      goto statement_2082;
    }
    if (imach == 1) {
      thetam(k) = twopi / (4.0f * nppair(k));
    }
    //C.  SET TYPE 14 SOURCES FOR UM = SM & DM EXCITATION COILS               M42.5491
    //C    (IM EXCITATION COIL SOURCES WERE CREATED IN OVER5)                 M42.5492
  statement_2082:
    n5 = kcoil(k) + 3;
    if (imach == 1) {
      goto statement_2087;
    }
    if (nodvo1(n5) == nodvo2(n5)) {
      goto statement_2100;
    }
    FEM_DO_SAFE(n1, 1, 2) {
      if (n1 == 2) {
        goto statement_2083;
      }
      if (nodvo1(n5) == 1) {
        goto statement_2086;
      }
      kconst++;
      if (kconst <= lexct) {
        goto statement_6787;
      }

    statement_6787:
      node(kconst) = -nodvo1(n5);
      goto statement_2084;
    statement_2083:
      if (nodvo2(n5) == 1) {
        goto statement_2086;
      }
      kconst++;
      if (kconst > lexct) {
        goto statement_6788;
      }
      node(kconst) = -nodvo2(n5);
    statement_2084:
      iform(kconst) = 14;
      crest(kconst) = 0.0f;
      time1(kconst) = 0.0f;
      tstart(kconst) = -1.0f;
      tstop(kconst) = 0.0f;
      n10 = nodfum(k);
      sfreq(kconst) = sfreq(n10);
      if (iprsup >= 1) {
        write(lunit6,
          "(' *********',' CURRENT SOURCE FOR EXCIT COILS',3x,i4,50x,i6,e14.5,"
          "1x,e13.5)"),
          node(kconst), kconst, sfreq(kconst), crest(kconst);
      }
    statement_2086:;
    }
  statement_6788:
    write(lunit6, format_6783), lexct;
    stoptp(cmn);
    goto statement_2100;
    //C  TREATMENT OF  EXCITATION SOURCES OF IM :                             M42.5524
  statement_2087:
    if (loopss(10) == 2) {
      goto statement_2100;
    }
    d3 = slip;
    if (d3 < 0.0f) {
      d3 = -d3;
    }
    d1 = d3 * rotmom(k) / twopi;
    if (lfim4i != 0) {
      d1 = rotmom(k) / twopi;
    }
    n19 = fpar(kcl + 1);
    n20 = n19 - 1 + ncld(k) + nclq(k);
    if (jtype(k) == 4) {
      n20 = n19 + 2;
    }
    nminum = 10000;
    n18 = 0;
    FEM_DO_SAFE(j, kcld1, kcle) {
      n2 = nodvo2(j);
      if (n2 == 1) {
        n2 = nodvo1(j);
      }
      n3 = kssfrq(n2);
      if (n3 < 0) {
        goto statement_2094;
      }
      n4 = n3;
      sfreq(n3) = d1;
      if (n3 >= n19 && n3 <= n20) {
        goto statement_2090;
      }
      n18++;
      if (j == kcld1) {
        d10 = time1(n3);
      }
      if (j == kclq1) {
        d11 = time1(n3);
      }
      //C  REVERSE EXCITATION VOLTAGE POLARITY DUE TO UM SIGN CONVENTION        M42.5546
      if (node(n3) < 0) {
        goto statement_2090;
      }
      if (lfim4i == 0) {
        goto statement_2090;
      }
      crest(n3) = -crest(n3) / slip;
      //C  NEGATIVE SEQUENCE CONVERSION TO POSITIVE IF SLIP .LT. 0.0 :          M42.5550
      if (slip < 0.0f) {
        time1(n3) = -time1(n3);
      }
    statement_2090:
      if (iprsup >= 1) {
        write(lunit6,
          "(' *********',' ADJUSTED IM EXCITATION SOURCES',3x,i4,50x,i6,e14.5,"
          "1x,e13.5)"),
          node(n3), n3, sfreq(n3), crest(n3);
      }
    statement_2089:
      n3 = kpsour(n3);
      if (n3 == n4) {
        goto statement_2094;
      }
      sfreq(n3) = d1;
      if (n3 >= n19 && n3 <= n20) {
        goto statement_2093;
      }
      n18++;
      if (j == kcld1) {
        d10 = time1(n3);
      }
      if (j == kclq1) {
        d11 = time1(n3);
      }
      if (node(n3) < 0) {
        goto statement_2089;
      }
      if (lfim4i == 0) {
        goto statement_2089;
      }
      crest(n3) = -crest(n3) / slip;
      if (slip < 0.0f) {
        time1(n3) = -time1(n3);
      }
      if (nminum > n3) {
        nminum = n3;
      }
    statement_2093:
      goto statement_2090;
    statement_2094:;
    }
    //C  CHECK FOR CORRECT PHASE SEQUENCE OF EXTERNAL EXC SOURCES :           M42.5571
    if (imach != 1) {
      goto statement_2097;
    }
    if (n18 == 0) {
      goto statement_2097;
    }
    d12 = d10 - d11;
    d13 = twopi / 36.0f;
    d14 = twopi / 3.0f;
    if (jtype(k) == 3) {
      d14 = -twopi / 4.0f;
    }
    d15 = 2.0f * d14;
    if (jtype(k) == 3) {
      d15 = -d14;
    }
    if (slip > 0.0f) {
      goto statement_2096;
    }
    d16 = -d14 - d13;
    d17 = -d14 + d13;
    if (d12 > d16&& d12 < d17) {
      goto statement_2097;
    }
    d16 = d15 - d13;
    d17 = d15 + d13;
    if (d12 > d16&& d12 < d17) {
      goto statement_2097;
    }
    write(lunit6,
      "(/,' ERROR STOP. UM NUMBER',i4,' IS AN IND. MACH',"
      "' AND IS REQUESTED TO BE INITIALIZED WITH A',"
      "' NEGATIVE SLIP VALUE. THE PHASE SEQUENCE OF',/,"
      "' THE SPECIFIED EXTERNAL EXCITATION SOURCES IS',"
      "' INCORRECT. IT SHOULD BE NEGATIVE SEQUENCE',"
      "' RATHER THAN POSITIVE SEQUENCE.')"),
      k;
    stoptp(cmn);
  statement_2096:
    d16 = d14 - d13;
    d17 = d14 + d13;
    if (d12 > d16&& d12 < d17) {
      goto statement_2097;
    }
    d16 = -d15 - d13;
    d17 = -d15 + d13;
    if (d12 > d16&& d12 < d17) {
      goto statement_2097;
    }
    write(lunit6,
      "(/,' ERROR STOP. UM NUMBER',i4,' IS AN IND. MACH',"
      "' AND IS REQUESTED TO BE INITIALIZED WITH A',"
      "' POSITIVE SLIP VALUE. THE PHASE SEQUENCE OF',/,"
      "' THE SPECIFIED EXTERNAL EXCITATION SOURCES IS',"
      "' INCORRECT. IT SHOULD BE POSITIVE SEQUENCE',"
      "' RATHER THAN NEGATIVE SEQUENCE.')"),
      k;
    stoptp(cmn);
  statement_2097:
    if (nminum >= 10000) {
      goto statement_2100;
    }
    if (node(nminum) > 0) {
      goto statement_2100;
    }
    if (lfim4i == 0) {
      goto statement_2100;
    }
    write(lunit6,
      "(/,' WARNING :   YOU HAVE REQUESTED A LOAD-FLOW',"
      "' FOR A NETWORK CONTAINING AN INDUCTION',"
      "' MACHINE. YOU CHOSE THE EXCITER SOURCES AS',/,"
      "' CURRENT SOURCES AND WILL THEREFORE NOT BE',"
      "' ADJUSTED BY THE LOAD-FLOW MODULE.',/)");
  statement_2100:
    if (jtmtac(k) <= 0) {
      goto statement_2150;
    }
    write(lunit6, "('0PROGRAM STOP BECAUSE OF',' CONFLICTING REQUEST, I.E.')");
    write(lunit6, "(' NO INITIALIZATION IF NO MECHANICAL',' NETWORK OPTION')");
    stoptp(cmn);
    //C   CREATING TEMPORARY SPEED-SOURCE FOR EACH UM MASS :                  M42.5626
  statement_2150:
    if (loopss(10) == 3) {
      goto statement_2200;
    }
    kconst++;
    if (kconst >= lexct) {
      goto statement_6788;
    }
    iform(kconst) = 14;
    node(kconst) = nodom(k);
    n1 = jcltac(kcl);
    n2 = jcltac(kcl + 1);
    if (n1 == 0 && n2 == 0) {
      goto statement_2154;
    }
    n4 = k;
    if (n1 != 0 && k > n1) {
      n4 = n1;
    }
    if (n2 != 0 && n4 > n2) {
      n4 = n2;
    }
    if (k == n4) {
      goto statement_2154;
    }
    node(kconst) = -jtmtac(k);
  statement_2154:
    tstart(kconst) = -1.0f;
    tstop(kconst) = 0.0f;
    n10 = nodmum(k);
    sfreq(kconst) = sfreq(n10);
    crest(kconst) = 0.0f;
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********',' UM MASS SPEED-SOURCE',13x,i4,50x,i6,e14.5,1x,e13.5)"),
        node(kconst), kconst, sfreq(kconst), crest(kconst);
    }
  statement_2200:;
  }
  //C  LOAD-FLOW PREPARATION OF IM TYPE-4 TEMPORARY BRANCHES, WHICH         M42.5652
  //C   ARE TO BE WIPED OUT IN THE SECOND PART OF THE UMRENU CODE :         M42.5653
  if (loopss(10) != 1) {
    goto statement_2250;
  }
  FEM_DO_SAFE(k, 1, numum) {
    if (jtype(k) < 3) {
      goto statement_2248;
    }
    if (jtype(k) > 4) {
      goto statement_2248;
    }
    slip = voltum(k) / 100.0f;
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' ***************************************',"
        "' MOMENTARY CHANGES OR CREATION OF MOMENTARY',"
        "' ELEMENTS FOR LOAD-FLOW INVOLVING IND. MACH.')");
    }
    if (iprsup >= 1) {
      write(lunit6, format_1904), k;
    }
    kcl = kcoil(k);
    ncl = ncld(k) + nclq(k);
    if (jtype(k) == 3) {
      goto statement_2226;
    }
    if (jtype(k) == 4) {
      ncl++;
    }
    //C  SET TEMPORARY IM ROTOR BRANCHES FOR LD-FLOW :                        M42.5668
    ndum(31) = nodvo1(kcl + 5);
    ndum(32) = nodvo1(kcl + 3);
    ndum(33) = nodvo1(kcl + 4);
    ndum(34) = nodvo2(kcl + 5);
    ndum(35) = nodvo2(kcl + 3);
    ndum(36) = nodvo2(kcl + 4);
    FEM_DO_SAFE(n1, 31, 33) {
      n3 = ndum(n1);
      n4 = ndum(n1 + 3);
      ibrinc(cmn);
      it++;
      n5 = kcl + n1 - 31;
      kbus(ibr) = nodvo1(n5);
      if (nodvo1(n5) == 1) {
        kbus(ibr) = nodvo2(n5);
      }
      mbus(ibr) = n3;
      if (n4 != 1) {
        mbus(ibr) = n4;
      }
      length(ibr) = 1;
      nr(ibr) = -it;
      tr(it) = 1.0f / (gpar(kcl + 4) * slip);
      c(it) = 0.0f;
      tx(it) = reacl(kcl + 4) * 1.0e+3;
      if (xopt != 0.0f) {
        tx(it) = reacl(kcl + 4) * twopi * xopt;
      }
      if (iprsup >= 1) {
        write(lunit6,
          "(' *********',' IM ROTOR BRANCHE JUST FOR LD-FLOW',i4,4x,i4,2i6,"
          "2e14.5)"),
          kbus(ibr), mbus(ibr), ibr, it, tr(it), tx(it);
      }
    }
    if (ndum(33) != 1 && ndum(36) != 1) {
      goto statement_2222;
    }
    if (nodvo1(kcl) == 1 || nodvo2(kcl) == 1) {
      goto statement_2226;
    }
  statement_2222:
    write(lunit6,
      "(/,' ERROR STOP. YOU HAVE REQUESTED A LOAD-FLOW',"
      "' OF A NETWORK CONTAINING AN INDUCTION MACHINE',"
      "' WITH UNGROUNDED POWER COILS AND/OR',/,"
      "' EXCITATION COILS. THIS REQUEST IS NOT',"
      "' HONORED IN THE CURRENT EMTP VERSION. THESE',"
      "' COILS ARE BOTH TO BE Y-CONNECTED WITH',' GROUNDED NEUTRALS.')");
    stoptp(cmn);
    //C  SET TEMPORARY BRANCHES FOR IM MAIN INDUCTANCES IF FULL COMP :        M42.5709
  statement_2226:
    if (loopss(8) != 0) {
      goto statement_2230;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + kcl - 1;
      ibrinc(cmn);
      it++;
      if (n1 == 3) {
        hist(kcl) = ibr;
      }
      kbus(ibr) = nodvo1(n2);
      mbus(ibr) = nodvo2(n2);
      length(ibr) = 1;
      nr(ibr) = -it;
      tr(it) = 0.0f;
      c(it) = 0.0f;
      if (jtype(k) != 3) {
        goto statement_2227;
      }
      tr(it) = epsiln;
      tx(it) = 0.0f;
      if (iprsup >= 1) {
        write(lunit6, format_2054), kbus(ibr), mbus(ibr), ibr, it, tr(it),
          tx(i);
      }
      goto statement_2228;
    statement_2227:
      tx(it) = reamqu(k) * 1.0e+3;
      if (xopt != 0.0f) {
        tx(it) = reamqu(k) * twopi * xopt;
      }
      if (iprsup >= 1) {
        write(lunit6, format_2052), kbus(ibr), mbus(ibr), ibr, it, tr(it),
          tx(i);
      }
    statement_2228:;
    }
    if (jtype(k) == 3) {
      goto statement_2250;
    }
    //C  ADJUSTING EXTERNAL EXCITATION NETWORK RESISTANCES OF IM INTO         M42.5736
    //C    STATOR FREQUENCY DOMAIN IN CASE OF LOAD-FLOW REQUEST :             M42.5737
  statement_2230:
    FEM_DO_SAFE(n1, 1, 40) {
      ndum(n1) = 0;
    }
    n1 = 0;
    FEM_DO_SAFE(n13, 1, ncl) {
      n14 = kcl + 2 + n13;
      n2 = nodvo1(n14);
      if (n2 == 1) {
        n2 = nodvo2(n14);
      }
      if (n2 == 1) {
        goto statement_2248;
      }
      n3 = kssfrq(n2);
      n4 = n3;
    statement_2240:
      n1++;
      ndum(n1) = n3;
      n3 = kpsour(n3);
      if (n3 != n4) {
        goto statement_2240;
      }
    }
    n13 = loopss(5);
    vinp(1) = 0.0f;
    n18 = 1;
    if (n1 < 40) {
      goto statement_82242;
    }
    write(lunit6, format_82245), k;
    stoptp(cmn);
  statement_82242:
    FEM_DO_SAFE(n10, 1, n13) {
      n11 = kbus(n10);
      if (n11 < 0) {
        n11 = -n11;
      }
      n12 = mbus(n10);
      if (n12 < 0) {
        n12 = -n12;
      }
      n3 = kssfrq(n11);
      //C   NOW DETERMINE BRANCHES IN EXC SUBNETWORK WITH SOURCES NDUM          M42.5765
      FEM_DO_SAFE(n8, 1, n1) {
        if (n3 != ndum(n8)) {
          goto statement_2244;
        }
        n9 = nr(n10);
        if (n9 < 0) {
          n9 = -n9;
        }
        //C   AVOID REINITIALIZATION OF REFERENCED EXCIT BRANCHES :               M42.5770
        n17 = 0;
        FEM_DO_SAFE(n19, 1, n18) {
          n20 = vinp(n19);
          if (n9 == n20) {
            n17 = 1;
          }
        }
        if (n17 == 1) {
          goto statement_82244;
        }
        n18++;
        vinp(n18) = n9;
        tr(n9) = tr(n9) / slip;
      statement_82244:
        if (n18 < 40) {
          goto statement_82246;
        }
        write(lunit6, format_82245), k;
        stoptp(cmn);
      statement_82246:
        if (iprsup >= 1) {
          write(lunit6,
            "(' *********',' CHANGE EXT EXC R JUST FOR LD-FLOW',i4,4x,i4,2i6,"
            "2e14.5)"),
            n11, n12, n10, n9, tr(n9), tx(n9);
        }
        goto statement_2245;
      statement_2244:;
      }
    statement_2245:;
    }
  statement_2248:;
  }
  //C  LD-FLOW CONDITIONS IF LD-FLOW NOT YET CONDUCTED ******** :           M42.5797
  //C  (A) CONDITION OF FIRST UMRENU PASS, UNLESS UM TYPE-3 IS PRESE        M42.5798
  //C      WHICH WOULD MAKE IT THE SECOND PASS.                             M42.5799
statement_2250:
  if (loopss(10) != 1) {
    goto statement_2260;
  }
  loopss(10) = 2;
  if (lfim3 == 1) {
    return;
  }
  goto statement_2400;
  //C  (B) CONDITION OF FIRST PASS THROUGH "FIRST PART" IF UM TYPE-3        M42.5804
  //C      IS PRESENT.                                                      M42.5805
statement_2260:
  if (loopss(10) != 3) {
    goto statement_2280;
  }
  istep = 0;
statement_2280:
  if (ncomum == 0) {
    ksubum = ksubum - numsub - 1;
  }
  if (ncomum == 0) {
    goto statement_2300;
  }
  loopss(2) = 3 * cmn.ntot;
  isubeg(numsub + 1) = n15 + 1;
statement_2300:
  if (loopss(10) == 3) {
    goto statement_2400;
  }
  if (loopss(10) == 2) {
    loopss(10) = 0;
  }
  //C  DETECTING PRESENCE OF ZERO COMPONENT CURRENT :                       M42.5814
  if (loopss(8) == 0) {
    goto statement_2400;
  }
  FEM_DO_SAFE(n5, 1, numum) {
    n1 = -9999;
    n3 = kcoil(n5);
    if (nodvo2(n3 + 2) == 1) {
      n1 = 0;
    }
    if (nodvo1(n3 + 2) == 1) {
      n1 = 0;
    }
    if (n1 == 0) {
      goto statement_2350;
    }
    FEM_DO_SAFE(n2, 1, ibr) {
      if (kbus(n2) != nodvo2(n3 + 2)) {
        goto statement_2310;
      }
      if (mbus(n2) == nodvo1(n3 + 2)) {
        goto statement_2310;
      }
      n1 = mbus(n2);
    statement_2310:;
    }
    if (n1 == -9999) {
      gpar(n3) = 0.0f;
    }
    if (n1 == -9999) {
      reacl(n3) = 0.0f;
    }
  statement_2350:;
  }
statement_2400:;
}

void umrenu(
  common& cmn,
  arr_ref<double> reacl,
  arr_ref<double> gpar,
  arr_ref<double> fpar,
  arr_ref<double> hist,
  arr_ref<double> umcurp,
  arr_ref<int> nodvo1,
  arr_ref<int> nodvo2,
  arr_ref<int> jcltac,
  arr_cref<int> /* jclout */,
  arr_ref<int> jtype,
  arr_ref<int> nodom,
  arr_ref<int> jtmtac,
  arr_cref<double> /* histom */,
  arr_ref<double> omegm,
  arr_ref<double> omold,
  arr_ref<double> thetam,
  arr_cref<double> reamdu,
  arr_cref<double> reamds,
  arr_cref<double> flxds,
  arr_ref<double> flxdr,
  arr_ref<double> reamqu,
  arr_ref<double> flxqs,
  arr_ref<double> flxqr,
  arr_cref<int> jcdsat,
  arr_cref<int> jcqsat,
  arr_ref<double> flxd,
  arr_ref<double> flxq,
  arr_cref<int> nppair,
  arr_cref<double> rotmom,
  arr_cref<int> ncld,
  arr_cref<int> nclq,
  arr_cref<int> /* jtqout */,
  arr_cref<int> /* jomout */,
  arr_cref<int> /* jthout */,
  arr_ref<double> reamqs,
  arr_ref<double> epsom,
  arr_cref<double> dcoef,
  arr_cref<int> kcoil,
  arr_ref<double> voltum,
  arr_ref<double> anglum,
  arr_cref<int> nodfum,
  arr_ref<int> nodmum,
  arr_cref<int> /* kumout */,
  arr_cref<int> /* jumout */,
  arr_ref<double> umoutp)
{
  reacl(dimension(1));
  gpar(dimension(1));
  fpar(dimension(1));
  hist(dimension(1));
  umcurp(dimension(1));
  nodvo1(dimension(1));
  nodvo2(dimension(1));
  jcltac(dimension(1));
  jtype(dimension(1));
  nodom(dimension(1));
  jtmtac(dimension(1));
  omegm(dimension(1));
  omold(dimension(1));
  thetam(dimension(1));
  reamdu(dimension(1));
  reamds(dimension(1));
  flxds(dimension(1));
  flxdr(dimension(1));
  reamqu(dimension(1));
  flxqs(dimension(1));
  flxqr(dimension(1));
  jcdsat(dimension(1));
  jcqsat(dimension(1));
  flxd(dimension(1));
  flxq(dimension(1));
  nppair(dimension(1));
  rotmom(dimension(1));
  ncld(dimension(1));
  nclq(dimension(1));
  reamqs(dimension(1));
  epsom(dimension(1));
  dcoef(dimension(1));
  kcoil(dimension(1));
  voltum(dimension(1));
  anglum(dimension(1));
  nodfum(dimension(1));
  nodmum(dimension(1));
  umoutp(dimension(1));
  common_write write(cmn);
  double& d4 = cmn.d4;
  double& d5 = cmn.d5;
  double& d6 = cmn.d6;
  double& d7 = cmn.d7;
  double& d8 = cmn.d8;
  double& d10 = cmn.d10;
  double& d11 = cmn.d11;
  double& d12 = cmn.d12;
  double& d13 = cmn.d13;
  double& d14 = cmn.d14;
  double& d15 = cmn.d15;
  double& d16 = cmn.d16;
  double& d18 = cmn.d18;
  int& lfim3 = cmn.lfim3;
  int& kcld1 = cmn.kcld1;
  int& kclq1 = cmn.kclq1;
  double& slip = cmn.slip;
  double& epsiln = cmn.epsiln;
  auto& twopi = cmn.twopi;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  int& istep = cmn.istep;
  int& lexct = cmn.lexct;
  int& numum = cmn.numum;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  auto& loopss = cmn.loopss;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  const auto& nr = cmn.nr;
  const auto& length = cmn.length;
  auto& tstop = cmn.tstop;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& kodsem = cmn.kodsem;
  auto& iform = cmn.iform;
  auto& node = cmn.node;
  auto& crest = cmn.crest;
  auto& time1 = cmn.time1;
  auto& tstart = cmn.tstart;
  auto& sfreq = cmn.sfreq;
  const auto& e = cmn.e;
  const auto& solr = cmn.solr;
  const auto& soli = cmn.soli;
  const auto& kssfrq = cmn.kssfrq;
  const auto& kpsour = cmn.kpsour;
  const auto& norder = cmn.norder;
  auto& vinp = cmn.vinp;
  auto& ptheta = cmn.ptheta;
  auto& zthevr = cmn.zthevr;
  auto& zthevs = cmn.zthevs;
  auto& umcur = cmn.umcur;
  auto& con = cmn.con;
  auto& dumvec = cmn.dumvec;
  auto& dummat = cmn.dummat;
  double& sroot2 = cmn.sroot2;
  double& sroot3 = cmn.sroot3;
  int& inpu = cmn.inpu;
  auto& ndum = cmn.ndum;
  int& initum = cmn.initum;
  int& istart = cmn.istart;
  //
  auto& lunit6 = cmn.lunit6;
  int imach = fem::int0;
  int kcl = fem::int0;
  int nclout = fem::int0;
  int lpss9 = fem::int0;
  int jm = fem::int0;
  int numibr = fem::int0;
  int lfim3i = fem::int0;
  int ntyp59 = fem::int0;
  int inpust = fem::int0;
  double zthrr = fem::double0;
  double zthri = fem::double0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  arr_2d<3, 3, double> zths3(fem::fill0);
  arr_2d<3, 3, double> zths3i(fem::fill0);
  double seltat = fem::double0;
  int kclde = fem::int0;
  int kclqe = fem::int0;
  int kcle = fem::int0;
  int ncl = fem::int0;
  double d1 = fem::double0;
  int n10 = fem::int0;
  int n11 = fem::int0;
  double d2 = fem::double0;
  double d19 = fem::double0;
  double d20 = fem::double0;
  double d17 = fem::double0;
  double d3 = fem::double0;
  int n13 = fem::int0;
  int n12 = fem::int0;
  int n3 = fem::int0;
  int n4 = fem::int0;
  double cdsat = fem::double0;
  double cqsat = fem::double0;
  double flxda = fem::double0;
  double flxqa = fem::double0;
  double flxdrr = fem::double0;
  double flxqrr = fem::double0;
  double sflxd = fem::double0;
  double sflxq = fem::double0;
  double curmt = fem::double0;
  int norton = fem::int0;
  int n20 = fem::int0;
  int n17 = fem::int0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  int n8 = fem::int0;
  int n9 = fem::int0;
  int n19 = fem::int0;
  int jacob = fem::int0;
  double stored = fem::double0;
  double storeq = fem::double0;
  arr_1d<4, double> fjv(fem::fill0);
  arr_2d<4, 4, double> fjm(fem::fill0);
  arr_2d<6, 7, double> gmat(fem::fill0);
  int jgauss = fem::int0;
  int n15 = fem::int0;
  arr_2d<3, 3, double> dumma1(fem::fill0);
  arr_2d<3, 3, double> dumma2(fem::fill0);
  int nclind = fem::int0;
  double tqgen = fem::double0;
  int nshare = fem::int0;
  int n14 = fem::int0;
  int itcap = fem::int0;
  int i = fem::int0;
  static const char* format_13114 =
    "(' SHARE A COMMON MECHANICAL NETWORK, BUT DO',"
    "' NOT HAVE EQUAL MECHANICAL MACHINE-SPEEDS. IS',"
    "' THIS INTENTIONAL OR HAVE YOU MADE AN ERROR',/,"
    "' IN DESIGNING YOUR MECHANICAL NETWORK ? THESE',"
    "' SPEEDS (RAD/SEC) ARE EQUAL TO (1-SLIP) TIMES',"
    "' ANGULAR FREQ OF ELECTRIC POWER GRID DEVIDED')";
  static const char* format_13122 =
    "(' ****** EXCT SLACK BUS SOURCE:',2x,i6,2x,i6,5e14.5)";
  static const char* format_13123 =
    "(' ****** MECH SLACK BUS SOURCE:',2x,i6,2x,i6,5e14.5)";
  static const char* format_8310 =
    "(/,' WARNING : UMBALANCED ELECTRIC POWER',' NETWORK ELEMENTS OR SOURCES',"
    "' CONNECTED TO UM -',i3,'.   STEADY-STATE',"
    "' SOLUTION WILL NOT BE EXACT.',/)";
  static const char* format_8860 = "(' ********** CHANGED:',2x,i6,2e14.5)";
  static const char* format_8862 = "(' ********** CHANGED:',38x,i6,4e14.5)";
  static const char* format_93116 =
    "(' BY THE NR OF POLE-PAIRS. THE SLIP HERE',"
    "' IS IN ABS. VALUES AND IN STEADY-STATE CAN',"
    "' OBVIOUSLY ONLY BE NONZERO FOR INDUCTION',' MACHINES.',/)";
  //C!w added z to void name crash
  //C     KCONST IS THE ENTRY OF THE SOURCE TYPE 14 VECTOR                  M31.1493
  //C     NUMSUB IS THE ENTRY OF THE SUBNETWORK VECTOR                      M31.1494
  //C     ISUBEG(NUMSUB) IS THE FIRST NODE OF SUBNETWORK NUMSUB             M31.1495
  //C     N15 IS THE ENTRY OF THE COMPENSATION VECTOR                       M31.1496
  //C     KBUS(N15) AND MBUS(N15) ARE THE PAIR OF NODES OF                  M38.1654
  //C                            COMPENSATION VECTOR ENTRY N15.             M31.1498
  //C     KSUBUM STORES THE FIRST SUBNETWORK CONNECTED TO UM.               M31.1499
  //C     KSSFRQ(N) IS THE ENTRY KCONST OF THE TYPE 14 SOURCE TABLE         M33. 626
  //C       WHICH IS IN THE SAME SUBNETWORK AS THAT OF NODE N.              M37.2968
  //C     KPSOUR(KCONST) IS THE NEXT TYPE 14 SOURCE (IF ANY) WHICH          M33. 628
  //C       IS IN THE SAME SUBNETWORK AS TYPE 14 SOURCE KCONST.             M33. 629
  //C  **************** UMRENU CODING STRATEGY *********************        M37.2969
  //C   "FIRST PART" OF UMRENU CODE IS ENTERED TWICE IF LOAD-FLOW           M37.2970
  //C       IS REQUESTED (LOOPSS(10) = 1 OR 2). THIS IS NEEDED TO           M38.1655
  //C       LET THE LOAD-FLOW DO ITS WORK TO ADJUST THE SOURCES.            M38.1656
  //C       HOWEVER, IF UM TYPE-3 IS PRESENT, THE FIRST PART WILL           M38.1657
  //C       BE ENTERED ONE ADDITIONAL PASS PRIOR TO THE TWO                 M38.1658
  //C       MENTIONED PASSES IN ORDER TO FIND THE THEV PARAMETERS OF        M38.1659
  //C       THE UM TYPE-3 EXCITATION CIRCUITS (LOOPSS(10) = 3).             M38.1660
  //C   "SECOND PART" OF UMRENU CODE IS ENTERED TWICE IF ONE OF THE         M37.2977
  //C       UM IS AN INDUCTION MACHINE AND PREDICTION OPTION IS             M37.2978
  //C       REQUESTED (LOOPSS(9)=2) SINCE NORTON EQUIVALENT OF IND.         M37.2979
  //C       MACH. WOULD BE NEEDED, OTHERWISE IT IS ONLY PASSED ONCE.        M37.2980
  //C   "SLACK BUS" CALCULATIONS (2 PASSES) ARE CONDUCTED TO ADJUST         M37.2984
  //C       THE EXTERNAL EXCITATION AND MECHANICAL SOURCES SO AS TO         M37.2985
  //C       ACCOMMODATE THE UM CURRENTS FOUND IN PREVIOUS PASSES.           M37.2986
  //C   EMTP RESTORE FEATURE : BEFORE EACH REENTRANCE OF UMRENU AS          M37.2987
  //C       WELL AS AFTER PERMANENT EXIT OF UMRENU, THE EMTP                M37.2988
  //C       R,L,C BRANCHE ELEMENTS CREATED IN UMDATA ARE RESTORED           M37.2989
  //C       TO THE VALUES AS INITIALIZED IN UMDATA. HOWEVER, THE            M37.2990
  //C       BRANCHES CREATED IN UMRENU ARE NOT RESTORED, THEY WILL          M37.2991
  //C       MAINTAIN  VALUES AS INITIALIZED AT ANY DESIRED PASS             M37.2992
  //C       THROUGH UMRENU.                                                 M37.2993
  //C       THE VECTORS KPSOUR AND KSSFRQ WHICH ARE USED TO SCAN            M37.2994
  //C       THE CONNECTIVITY OF THE SUBNETWORKS, ARE ALSO RESTORED          M37.2995
  //C       BEFORE EACH REENTRANCE OF UMRENU. THUS ONLY THE                 M37.2996
  //C       NETWORK CONFIGURATION AS DETERMINED IN UMDATA WILL BE           M37.2997
  //C       OBSERVED BY THESE TWO VECTORS.                                  M37.2998
  //C   OVER11 IS ENTERED PERMANENTLY AFTER SLACK BUS CALCULATIONS.         M31.1504
  //C   LOOPSS(1) .GT. 0 = REQUEST TO GO BACK FROM OVER11 TO OVER8          M31.1505
  //C                      FOR MULTIPLE SS CALCULATIONS.                    M33. 630
  //C           (ON PERMANENT EXIT OF UMRENU, SET LOOPSS(1) = -1,           M33. 631
  //C            AND AFTER COMPLETION OF THIS LAST SS CALCULATION           M33. 632
  //C            IN OVER11, THEN THERE LOOPSS(1) IS SET TO 7766).           M33. 633
  //C   LOOPSS(2) = 3*NTOT = REQUEST TO SOLVE THEV VARIABLES, ELSE 0        M31.1507
  //C   LOOPSS(3) = USED TO STORE FIRST TYPE 14 SOURCE SET BY UM            M31.1508
  //C   LOOPSS(4) .GT. 0 = REQUEST TO SET SLACK BUSES AND UM                M38.1661
  //C                      STEADY-STATE EQNS ARE TOTALLY SKIPPED.           M36. 720
  //C             .EQ. 3 = UMRENU IS NEVER TO BE CALLED AGAIN               M31.1510
  //C   NOTE :  ALL BRANCHES CREATED IN UMRENU WILL BE WIPED                M33. 634
  //C           OUT AFTER TOTAL COMPLETION OF SS-CALCULATION.               M33. 635
  //C           HOWEVER, IF OPTION FOR NON-COMPENSATED POWER                M36. 721
  //C           COILS IS USED, CREATED BRANCHES ARE PERMANENT.              M36. 722
  //C   LOOPSS(5) IS TO STORE THE LAST BRANCH WHICH IS CREATED              M37.2999
  //C     CREATED PERMANENTLY BY UMRENU. TEMPORARY BRANCHES ARE NOT         M38.1662
  //C     INCLUDED TO LOOPSS(5)                                             M38.1663
  //C   LOOPSS(6) IS USED TO STORE KCONST BEFORE ADDITIONAL SOURCES         M38.1664
  //C      ARE CREATED DURING THE SLACK BUS CALCULATIONS                    M38.1665
  //C   LOOPSS(7) = USED TO STORE MISC. DATA PARAMETER "KSSOUT"             M31.1513
  //C   LOOPSS(8) WAS SET TO 1 IN UMDATA IF USER REQUESTED FOR              M36. 723
  //C     THE OPTION OF USING THE UM PREDICTION CODE (POWER COILS)          M36. 724
  //C   LOOPSS(9) IS SET TO 1 IN FIRST PART OF UMRENU IF LOOPSS(8)          M33. 638
  //C              WAS SET TO 1 AND IF ONE OF UM IS AN INDUCT. MACH.        M33. 639
  //C       THEN IN "SECOND PART" IF LOOPSS(9)=1, LOOPSS(9) IS SET          M37.3005
  //C          TO 2 TO REQUEST IS FOR NORTON PAR CALCULATIONS OF            M37.3006
  //C          IND. MACH AND DUMMY RUN FOR SM IF SM ALSO PRESENT.           M37.3007
  //C          HOWEVER : LOOPSS(9) IS SET IMMEDIATELY TO 3 IF LOAD-         M37.3008
  //C          IS REQUESTED, THUS BYPASSING NORTON CALCULATIONS.            M37.3009
  //C       THEN AT NEXT PASS IF LOOPSS(9)=2, LOOPSS(9) IS SET TO 3         M37.3010
  //C         INDICATING FINAL PASS THRU "SECOND PART" OF UMRENU,           M37.3011
  //C         AND IN THIS PASS THE UM POWER RESISTANCES ARE PLACED          M36. 727
  //C         ON THE STATOR IF UM PREDICTION IS REQUESTED.                  M36. 728
  //C   LOOPSS(10) IS SET TO 1 IF ISTEP = -4567 , INDICATING REQUEST        M37.3012
  //C         FOR LOAD FLOW INTERFACING.                                    M37.3013
  //C         LOOPSS(10)=1 , PASS THROUGH "FIRST PART" FOR PREPARING        M38.1666
  //C                        UM LOAD-FLOW EQUIVALENT.                       M38.1667
  //C         LOOPSS(10)=2 , PASS THROUGH "FIRST AND SECOND PART"           M38.1668
  //C                        FOR PROCESSING LOAD-FLOW OUTPUT AND            M38.1669
  //C                        PREPARING SS-CALCULATIONS.                     M38.1670
  //C                        ON COMPLETION OF THIS PASS, LOOPSS(10)         M38.1671
  //C                        IS RESET TO 0 ON EXIT OF "FIRST PASS".         M38.1672
  //C         LOOPSS(10)=3 , IF LD-FLOW WITH UM TYPE-3 IS REQUESTED.        M38.1673
  //C                        THIS RESULTS IN AN ADDITIONAL PASS THRU        M38.1674
  //C                        UMRENU PRIOR TO THE PASSES MENTIONED AS        M38.1675
  //C                        PASSES WITH LOOPSS(10) = 1 AND 2.              M38.1676
  //C                        AFTER COMPLETION OF THIS PASS WITH             M38.1677
  //C                        LOOPSS(10)=3, WE RESET LOOPSS(10) TO 1         M38.1678
  //C   LOOPSS(11) IS USED FOR PASSING "NEXT" IN OVER 5,6,7,8.              M37.3017
  //C   LOOPSS(12) IS USED FOR TEMPORARY STORAGE OF LOOPSS(5) IF            M37.3018
  //C      "FIRST PART" NEEDS TO BE ENTERED TWICE                           M37.3019
  //C   ISTART .EQ. 0 = RUN HAS NOT GONE THROUGH SECOND PART CODE           M31.1514
  //C      ISTART IS USED TO COUNT THE NUMBER OF UMRENU PASSES.             M38.1679
  //C   INITUM .EQ. 0 = NO STEADY STATE INITIALIZATION                      M31.1515
  //C               1 = USER'S REQUEST FOR SS INITIALIZATION                M31.1516
  //C   HIST(KCL) IS USED TEMPORARILY IN FIRST AND SECOND PART OF           M37.3020
  //C        UMRENU TO STORE ADDRESS IBR OF POWER RESIST. BRANCHE.          M37.3021
  //C   HIST(KCL+1) IS BORROWED TO STORE NUMSUB AS NEEDED FOR LD-           M38.1680
  //C        FLOW PROCESSING WITH UM TYPE-3. IT IS RELEASED AFTER           M38.1681
  //C        UMRENU IS REENTERED WHEN THE LD-FLOW IS COMPLETED.             M38.1682
  //C   HIST(KCL+2) IS BORROWED TO STORE KCONST OF POWER COIL SOURCE        M38.1683
  //C        IF THE LOAD-FLOW INVOLVES A UM TYPE-3 .                        M38.1684
  //C   FPAR(KCL) IS USED TO STORE ADDRESS IBR OF LEAKAGE                   M37.3022
  //C        INDUCTANCES (INITIALIZED IN UMDATA).                           M37.3023
  //C   FPAR(KCL+1) IS USED TO STORE FIRST SOURCE KCONST WHICH              M37.3024
  //C      REPRESENTS AN IM EXCITATION COIL (INITILIZED IN UMDATA).         M37.3025
  //C   FPAR(KCL+2) IS USED TO STORE IT ADDRESS OF THE SPEED                M39.1334
  //C      CAPACITOR (INITIALIZED IN UMDATA)                                M39.1335
  //C   FPAR(KCL+3) WAS INITIALIZED IN UMDATA AND IS - KCONST OF            M38.1685
  //C      THE EXCITER TORQUE SOURCE.                                       M38.1686
  //C   FPAR(KCL+4) AND FPAR(KCL+5) ARE BOTH INITIALIZED IN UMDATA          M38.1687
  //C      AND USED TO STORE RESP THE EXCITER MASS AND FIELD NODES.         M38.1688
  //C   JCLTAC(KCL AND KCL+1) WILL BE BORROWED TO STORE                     M38.1689
  //C      RESPECTIVELY 2 POTENTIAL UM'S CONNECTED TO THE SAME              M38.1690
  //C      MECHANICAL NETWORK AS THE UM WITH KCOIL(JM)=KCL                  M38.1691
  //C   JTMTAC(JM) WAS INITIALIZED IN UMDATA TO THE NEGATIVE VALUE          M39.1336
  //C      OF THE NODE NR OF THE SPEED CAPACITOR (THUS IF INITUM=1).        M39.1337
  //C      IT WILL BE RESET TO ZERO HERE AFTER ITS USE.                     M39.1338
  //C.  ENTRANCE CODE OF UMRENU ************************************        M31.1517
  if (initum == 0) {
    goto statement_305;
  }
  if (istep == -4567) {
    loopss(10) = 1;
  }
  loopss(1) = 1;
statement_305:
  lfim3 = 0;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' BEGIN  \"UMRENU\" .',"
      "'   NUMUM  NCLTOT  NUMOUT  ISTART  KCONST     IBR',"
      "'  LOPSS1  LOPSS2  LOPSS4  LOPSS8  LOPSS9  LOPSS10',/,18x,11i8,1x,i8)"),
      numum, cmn.ncltot, cmn.numout, istart, kconst, ibr, loopss(1),
      loopss(2), loopss(4), loopss(8), loopss(9), loopss(10);
  }
  if (loopss(4) > 0) {
    goto statement_13100;
  }
  //C.  ....... CODE FOR UM STEADY-STATE INITIALIZATION ............        M31.1525
  umrnu2(cmn, reacl, gpar, fpar, hist, umcurp, nodvo1, jtype, nodom,
    jtmtac, thetam, imach, reamdu, reamqu, nodvo2, nppair, rotmom,
    ncld, jcltac, kcl, nclq, epsom, dcoef, kcoil, voltum, anglum,
    nodfum, nodmum, umoutp);
  if (istart > 0) {
    goto statement_7000;
  }
  if (initum == 0) {
    goto statement_14000;
  }
  if (lfim3 == 1) {
    goto statement_7000;
  }
  //C  NOW GO OUT OF MODULE TO CALCULATE CURRENTS FOR UM POWER COILS        M31.1716
  goto statement_13500;
  //C.  SECOND PART OF CODE : UMSSEQ = STEADY STATE EQUATIONS ******        M31.1718
  //C   THIS PART OF CODE IS ENTERED ONLY IF ISTART .GE. 1                  M31.1719
statement_7000:
  nclout = loopss(3) + 1;
  //C  STORING LOOPSS(9) IN CASE OF UM TYPE-3 PRESENCE :                    M38.2026
  if (lfim3 != 1) {
    goto statement_7060;
  }
  lpss9 = loopss(9);
  loopss(9) = 2;
  goto statement_7090;
  //C  NORMAL CONTROL OF LOOPSS(9) :                                        M38.2031
statement_7060:
  if (loopss(9) == 2) {
    loopss(9) = 3;
  }
  if (loopss(9) == 1) {
    loopss(9) = 2;
  }
  //C.  START MACHINE DO-LOOP **************************************        M31.1721
statement_7090:
  FEM_DO_SAFE(jm, 1, numum) {
    kcl = kcoil(jm);
    numibr = hist(kcl);
    lfim3i = 0;
    if (lfim3 != 1) {
      goto statement_7098;
    }
    if (jtype(jm) == 3) {
      lfim3i = 1;
    }
    if (lfim3i == 0) {
      goto statement_13050;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' *************************************',"
        "' NORTON EQUIVALENT OF UM TYPE-3 EXCITATION',"
        "' CIRCUITS FOR LD-FLOW WITH UM NUMBER',i5,':')"),
        jm;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(' *******************',5x,'IBR',8x,'TR(IT)',8x,'TX(IT)',2x,'KCONST',"
        "9x,'SFREQ',9x,'CREST',9x,'TIME1',9x,'TSTOP')");
    }
    goto statement_8002;
  statement_7098:
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' *************************************',"
        "' CHANGES TO CREATED EMTP',"
        "' ELEMENTS FOR STEADY-STATE CALCULATIONS OF',' UM NUMBER',i4,' :')"),
        jm;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(' ********** CHANGED:',5x,'IBR',8x,'TR(IT)',8x,'TX(IT)',2x,'KCONST',"
        "9x,'SFREQ',9x,'CREST',9x,'TIME1',9x,'TSTOP')");
    }
    //C  IN CASE OF SM TYPE-59 DATA INPUT                                     M32.3239
    ntyp59 = 0;
    if (jtype(jm) != 13) {
      goto statement_8002;
    }
    ntyp59 = 1;
    jtype(jm) = 1;
    inpust = inpu;
    inpu = 0;
  statement_8002:
    imach = 1;
    if (jtype(jm) < 3) {
      imach = 0;
    }
    if (jtype(jm) > 7) {
      imach = 0;
    }
    if (imach == 1) {
      slip = voltum(jm) / 100.0f;
    }
    zthrr = 0.0f;
    zthri = 0.0f;
    FEM_DO_SAFE(n1, 1, 40) {
      vinp(n1) = 0.0f;
      zthevs(n1) = 0.0f;
      umcur(n1) = 0.0f;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        zths3(n1, n2) = 0.0f;
        zths3i(n1, n2) = 0.0f;
      }
    }
    //C  NO SOURCE INITIALIZATION FOR SM IF NORTON CALCULATIONS ARE           M37.3423
    //C    REQUESTED FOR IM (THIS IS OF COURSE FOR MULTI-MACH CASE):          M37.3424
    if (loopss(9) != 2) {
      goto statement_8009;
    }
    if (imach != 0) {
      goto statement_8009;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + kcoil(jm) - 1;
      if (nodvo1(n2) == nodvo2(n2)) {
        goto statement_8008;
      }
      if (nodvo1(n2) != 1) {
        nclout++;
      }
      if (nodvo2(n2) != 1) {
        nclout++;
      }
    statement_8008:;
    }
  statement_8009:
    FEM_DO_SAFE(n1, 1, 10) {
      con(n1) = 0.0f;
    }
    n1 = jtype(jm);
    if (n1 > 12) {
      goto statement_14000;
    }
    switch (n1) {
    case 1: goto statement_8011;
    case 2: goto statement_8012;
    case 3: goto statement_8011;
    case 4: goto statement_8011;
    case 5: goto statement_8012;
    case 6: goto statement_8013;
    case 7: goto statement_8013;
    case 8: goto statement_8014;
    case 9: goto statement_8014;
    case 10: goto statement_8014;
    case 11: goto statement_8014;
    case 12: goto statement_8014;
    default: break;
    }
  statement_8011:
    con(3) = 1.0f;
    goto statement_8020;
  statement_8012:
    con(2) = 1.0f;
    goto statement_8020;
  statement_8013:
    con(1) = 1.0f;
    goto statement_8020;
  statement_8014:
    con(8) = 1.0f;
  statement_8020:
    seltat = rotmom(jm);
    if (inpu == 1) {
      seltat = 1.0f;
    }
    if (jtype(jm) <= 7) {
      goto statement_8100;
    }
    if (jtype(jm) > 12) {
      goto statement_8100;
    }
    seltat = omegm(jm) * nppair(jm);
    //C.  COIL MARKINGS                                                       M31.1760
  statement_8100:
    kcld1 = kcl + 3;
    kclde = kcld1 + ncld(jm) - 1;
    kclq1 = kclde + 1;
    kclqe = kclq1 + nclq(jm) - 1;
    kcle = kcl + 2 + ncld(jm) + nclq(jm);
    ncl = 3 + ncld(jm) + nclq(jm);
    if (jtype(jm) == 4) {
      kcle++;
    }
    if (jtype(jm) == 4) {
      ncl++;
    }
    //C.  SM AND DM EQUATIONS CODE ***********************************        M31.1770
    //C.  INPUT INTERFACE ELECT NETW WITH SM AND DM POWER SIDE *******        M31.1771
    if (imach == 1) {
      goto statement_10000;
    }
    //C  MAKE LEAKAGE INDUCTANCE ZERO FOR THIS NEXT ROUND OF SS               M36. 817
    //C   CALCULATION IF LOOPSS(9)=2 SINCE OTHERWISE IT WOULD BE              M37.3430
    //C   RESTORED TO VALUES OF UMDATA (SEE COMMENTS NEAR FORTRAN             M37.3431
    //C   STMT 2070)                                                          M37.3432
    if (loopss(9) != 2) {
      goto statement_8204;
    }
    d1 = epsiln * 1.0e+3;
    if (xopt != 0.0f) {
      d1 = epsiln * twopi * xopt;
    }
    FEM_DO_SAFE(n10, 1, 3) {
      n1 = kcl - 1 + n10;
      if (nodvo1(n1) == nodvo2(n1)) {
        goto statement_8203;
      }
      n11 = fpar(kcl) + n10 - 1;
      n2 = -nr(n11);
      if (n2 < 0) {
        n2 = -n2;
      }
      tx(n2) = d1;
      if (iprsup >= 1) {
        write(lunit6, format_8860), n11, tr(n2), tx(n2);
      }
    statement_8203:;
    }
    goto statement_9045;
  statement_8204:
    d1 = anglum(jm) * twopi / 360.0f;
    dumvec(1) = d1 * con(3);
    dumvec(2) = (dumvec(1) - twopi / 3.0f) * con(3);
    dumvec(2) += d1 * con(2);
    dumvec(3) = (dumvec(1) + twopi / 3.0f) * con(3);
    dumvec(3) += (dumvec(2) + twopi / 4.0f) * con(2);
    d2 = epsiln;
    n1 = nodvo1(kcl + 2);
    n2 = nodvo2(kcl + 2);
    if (n1 != 1 && n2 != 1) {
      d2 = epsiln * 1.0e+3;
    }
    FEM_DO_SAFE(n10, 1, 3) {
      d1 = dumvec(n10);
      n11 = n10 + kcl - 1;
      n1 = nodvo1(n11);
      n1 = norder(n1);
      n2 = nodvo2(n11);
      n2 = norder(n2);
      vinp(n10) = 0.0f;
      vinp(n10 + 20) = 0.0f;
      umcur(n10) = 0.0f;
      umcur(n10 + 20) = 0.0f;
      if (n1 == n2) {
        goto statement_8210;
      }
      vinp(n10) = voltum(jm) * cosz(d1);
      vinp(n10 + 20) = voltum(jm) * sinz(d1);
      umcur(n10) = vinp(n10) - solr(n1) + solr(n2);
      umcur(n10) = umcur(n10) / d2;
      umcur(n10 + 20) = vinp(n10 + 20) - soli(n1) + soli(n2);
      umcur(n10 + 20) = umcur(n10 + 20) / d2;
    statement_8210:;
    }
    if (con(1) == 1) {
      goto statement_8800;
    }
    if (con(8) == 1) {
      goto statement_8800;
    }
    d1 = vinp(1) + vinp(2) + vinp(3);
    d2 = vinp(21) + vinp(22) + vinp(23);
    d1 = d1 * d1;
    d1 += d2 * d2;
    d1 = sqrtz(d1);
    if (d1 < epsiln) {
      goto statement_8800;
    }
    write(lunit6, format_8310), jm;
    //C.  CALCULATION OF POWER SIDE POS SEQUENCE INPUT VOLT AND CURR:         M31.1798
  statement_8800:
    d10 = con(1) + con(4);
    vinp(1) = con(3) * vinp(1) + con(2) * vinp(2) + d10 * vinp(3);
    vinp(21) = con(3) * vinp(21) + con(2) * vinp(22) + d10 * vinp(23);
    umcur(1) = con(3) * umcur(1) + con(2) * umcur(2) + d10 * umcur(3);
    umcur(21) = con(3) * umcur(21) + con(2) * umcur(22);
    umcur(21) += d10 * umcur(23);
    //C.  INCLUDING MACH RESISTANCES AND RESTORE LEAKAGE INDUCTANCES          M36. 836
    //C       TO POWER NETWORK; IN CASE OF COMPENSATED POWER COILS            M37.3443
    //C       THE RESISTANCES ARE KEPT IN THE UM MODULES.                     M37.3444
    d19 = vinp(1);
    d20 = vinp(21);
    d17 = reacl(kcl + 2);
    if (d17 > reacl(kcl + 1)) {
      d17 = reacl(kcl + 1);
    }
    if (jtype(jm) > 7) {
      goto statement_8840;
    }
    d18 = d17 * seltat;
    d19 = d19 - d18 * umcur(21);
    d20 += d18 * umcur(1);
  statement_8840:
    n11 = -nr(numibr);
    if (n11 < 0) {
      n11 = -n11;
    }
    d1 = 1.0f / tr(n11);
    if (loopss(8) == 1) {
      d1 = gpar(kcl + 2);
    }
    d11 = d19 * d1 + umcur(1);
    d12 = d20 * d1 + umcur(21);
    d10 = d11 * d11 + d12 * d12;
    d10 = sqrtz(d10);
    d1 = d12 / d11;
    d1 = std::atan(d1);
    if (d11 < 0.0f) {
      d1 += twopi / 2.0f;
    }
    d2 = con(2) * d1 + con(3) * (d1 - twopi / 3.0f);
    d3 = con(2) * (d1 + twopi / 4.0f) + con(3) * (d1 + twopi / 3.0f);
    d3 += con(1) * d1;
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + kcl - 1;
      n11 = 3 * (jm - 1);
      n13 = 3 * (numum + jm - 1);
      if (nodvo1(n2) == nodvo2(n2)) {
        goto statement_8510;
      }
      if (loopss(8) != 1) {
        goto statement_8870;
      }
      n12 = numibr - 3 + n1;
      n10 = -nr(n12);
      if (n10 < 0) {
        n10 = -n10;
      }
      tr(n10) = 1.0f / gpar(kcl + 2);
      if (iprsup >= 1) {
        write(lunit6, format_8860), n12, tr(n10), tx(n10);
      }
    statement_8870:
      d15 = d1;
      if (n1 == 2) {
        d15 = d2;
      }
      if (n1 == 3) {
        d15 = d3;
      }
      if (nodvo1(n2) == 1) {
        goto statement_8500;
      }
      crest(nclout) = d10;
      time1(nclout) = d15;
      if (iprsup >= 1) {
        write(lunit6, format_8862), nclout, sfreq(nclout), crest(nclout),
          time1(nclout), tstop(nclout);
      }
      nclout++;
    statement_8500:
      if (nodvo2(n2) == 1) {
        goto statement_8505;
      }
      crest(nclout) = -d10;
      time1(nclout) = d15;
      if (iprsup >= 1) {
        write(lunit6, format_8862), nclout, sfreq(nclout), crest(nclout),
          time1(nclout), tstop(nclout);
      }
      nclout++;
    statement_8505:
      n3 = fpar(kcl) + n1 - 1;
      n4 = -nr(n3);
      if (n4 < 0) {
        n4 = -n4;
      }
      tx(n4) = d17 * 1.0e+3;
      if (xopt != 0.0f) {
        tx(n4) = d17 * twopi * xopt;
      }
      if (iprsup >= 1) {
        write(lunit6, format_8860), n3, tr(n4), tx(n4);
      }
    statement_8510:;
    }
    //C   UM DOMAIN POS SEQUENCE VOLT AND CURRENT :                           M33. 767
    d10 = con(3) * sroot3 + con(2) * sroot2 + con(1) + con(8);
    vinp(1) = d10 * vinp(1);
    vinp(21) = d10 * vinp(21);
    umcur(1) = d10 * umcur(1);
    umcur(21) = d10 * umcur(21);
    if (jcdsat(jm) != 5) {
      goto statement_9002;
    }
    reamqu(jm) = reamdu(jm);
    reamqs(jm) = reamds(jm);
    flxqr(jm) = flxdr(jm);
    flxqs(jm) = flxds(jm);
  statement_9002:
    cdsat = 0.0f;
    cqsat = 0.0f;
    flxda = 0.0f;
    flxqa = 0.0f;
    flxdrr = 0.0f;
    flxqrr = 0.0f;
    sflxd = 1.0f;
    sflxq = 1.0f;
    n2 = 0;
    //C.  DM EXCITATION CODE *****************************************        M31.1836
    d2 = 1.0f / gpar(kcl + 2);
    thetam(jm) = twopi / (4.0f * nppair(jm));
    vinp(1) += d2 * umcur(1);
    //C   STORING UMCUR AND VINP FROM EMTP NETWORK :                          M36. 881
  statement_9004:
    d11 = umcur(1);
    d12 = umcur(21);
    d13 = vinp(1);
    d14 = vinp(21);
    umcur(2) = 0.0f;
    umcur(3) = d11;
    if (jtype(jm) > 7) {
      goto statement_9006;
    }
    //C.  SM EXCITATION CODE *****************************************        M31.1843
    d1 = (1.0f - cqsat) * reamqu(jm) + cqsat * reamqs(jm);
    d1 = (d1 + reacl(kcl + 2)) * seltat;
    d13 = d13 - d1 * d12;
    d14 += d2 * d12 + d1 * d11;
    d3 = d14 / d13;
    d3 = std::atan(d3);
    if (d13 < 0.0f) {
      d3 += twopi / 2.0f;
    }
    d8 = (d13 * d13 + d14 * d14) / 2.0f;
    d8 = sqrtz(d8);
    d7 = cqsat * sflxq * flxqa * seltat;
    d7 += (1.0f - cqsat) * sflxq * flxqrr * seltat;
    if (d7 == 0.0f) {
      goto statement_9005;
    }
    d6 = d8 * d8 - d7 * d7;
    d6 = sqrtz(d6);
    d6 = -d7 / d6;
    d6 = std::atan(d6);
    d3 = d3 - d6;
    d8 = d8 * cosz(d6);
  statement_9005:
    d4 = cosz(d3);
    d5 = sinz(d3);
    thetam(jm) = (d3 + twopi / 4.0f) / nppair(jm);
    umcur(3) = (d4 * d11 + d5 * d12) / sroot2;
    umcur(2) = (d4 * d12 - d5 * d11) / sroot2;
  statement_9006:
    d1 = (1.0f - cdsat) * reamdu(jm) - (1.0f - cqsat) * reamqu(jm);
    d1 += cdsat * reamds(jm) - cqsat * reamqs(jm);
    d1 = d1 * umcur(2);
    d3 = (reacl(kcl + 1) - reacl(kcl + 2)) * umcur(2);
    d1 += d3;
    umcur(4) = d8 / seltat - cdsat * sflxd * flxda - d1;
    umcur(4) = umcur(4) - (1.0f - cdsat) * sflxd * flxqrr;
    d3 = (1.0f - cdsat) * reamdu(jm) + cdsat * reamds(jm);
    umcur(4) = umcur(4) / d3;
    vinp(4) = umcur(4) / gpar(kcld1);
    if (n2 > 0) {
      goto statement_9015;
    }
    //C   SATURATION CHECK :                                                  M36. 909
    n1 = jcdsat(jm) + jcqsat(jm);
    if (n1 == 0) {
      goto statement_9015;
    }
    if (inpu == 2) {
      goto statement_9009;
    }
    flxdr(jm) = 0.0f;
    flxqr(jm) = 0.0f;
    goto statement_9010;
    //C  IF REMANENT FLUX OPTION IS REQUESTED (INPU = 2) :                    M36. 916
  statement_9009:
    if (flxdr(jm) < 0.0f) {
      flxdr(jm) = -flxdr(jm);
    }
    if (flxqr(jm) < 0.0f) {
      flxqr(jm) = -flxqr(jm);
    }
  statement_9010:
    if (jcdsat(jm) != 5) {
      goto statement_9011;
    }
    flxdrr = flxdr(jm);
    flxqrr = flxdrr;
    goto statement_9015;
  statement_9011:
    flxdrr = flxdr(jm);
    flxqrr = flxqr(jm);
  statement_9015:
    d10 = umcur(2) + umcur(4);
    d15 = umcur(3);
    if (n1 == 0) {
      goto statement_89028;
    }
    if (jcdsat(jm) == 5) {
      goto statement_9016;
    }
    if (n2 == 0) {
      goto statement_9020;
    }
    goto statement_89028;
    //C  CODE FOR THE CASE OF TOTAL SATURATION (JCDSAT = 5) :                 M38.2079
  statement_9016:
    curmt = d10 * d10 + d15 * d15;
    if (curmt == 0.0f) {
      goto statement_89028;
    }
    curmt = sqrtz(curmt);
    d19 = d10 * flxds(jm) / curmt;
    d20 = d15 * flxqs(jm) / curmt;
    if (d19 < 0.0f) {
      d19 = -d19;
    }
    if (d20 < 0.0f) {
      d20 = -d20;
    }
    if (reamdu(jm) == 0.0f) {
      goto statement_9018;
    }
    d18 = reamds(jm) / reamdu(jm);
    flxda = d19 + d18 * (flxdrr - d19);
  statement_9018:
    flxqa = d20 + d18 * (flxqrr - d20);
    if (n2 > 0) {
      goto statement_89028;
    }
    goto statement_9027;
    //C  CODE FOR THE CASE OF NON-TOTAL SATURATION :                          M38.2086
  statement_9020:
    if (jcdsat(jm) == 0) {
      goto statement_9024;
    }
    if (reamdu(jm) == 0.0f) {
      goto statement_9024;
    }
    d11 = flxds(jm) / reamdu(jm);
    d12 = -d11;
    if (d10 > d11) {
      cdsat = 1.0f;
    }
    if (d10 < d12) {
      cdsat = 1.0f;
    }
    flxda = (reamds(jm) / reamdu(jm)) * (flxdrr - flxds(jm));
    flxda += flxds(jm);
  statement_9024:
    if (jcqsat(jm) == 0) {
      goto statement_9027;
    }
    d16 = flxqs(jm) / reamqu(jm);
    d17 = -d16;
    if (d15 > d16) {
      cqsat = 1.0f;
    }
    if (d15 < d17) {
      cqsat = 1.0f;
    }
    flxqa = (reamqs(jm) / reamqu(jm)) * (flxqrr - flxqs(jm));
    flxqa += flxqs(jm);
  statement_9027:
    n2 = 1;
    if (d10 < 0.0f) {
      sflxd = -1.0f;
    }
    if (d15 < 0.0f) {
      sflxq = -1.0f;
    }
    d1 = cdsat + cqsat;
    if (d1 != 0.0f) {
      goto statement_9004;
    }
    //C   CALCULATIONS OF MAIN FLUXES :                                       M38.2103
  statement_89028:
    if (cdsat == 1.0f) {
      goto statement_89030;
    }
    flxd(jm) = reamdu(jm) * d10 + sflxd * flxdrr;
    goto statement_89032;
  statement_89030:
    flxd(jm) = reamds(jm) * d10 + sflxd * flxda;
  statement_89032:
    if (cqsat == 1.0f) {
      goto statement_89034;
    }
    flxq(jm) = reamqu(jm) * d15 + sflxq * flxqrr;
    goto statement_9028;
  statement_89034:
    flxq(jm) = reamqs(jm) * d15 + sflxq * flxqa;
    //C.  OUTPUT FOR UM = SM AND DM :                                         M31.1860
  statement_9028:
    umcur(1) = 0.0f;
    if (jtype(jm) > 7) {
      goto statement_9029;
    }
    omegm(jm) = seltat / nppair(jm);
  statement_9029:
    omold(jm) = omegm(jm);
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = kcl - 1 + n1;
      hist(n2) = umcur(n1);
    }
    hist(kcld1) = -umcur(4);
    //C   ZEROING OF INTERNAL UM LEAKAGE SINCE LEAKAGE INDUCTANCES            M37.3466
    //C        ARE MOVED TO THE EMTP NETWORK.                                 M37.3467
    d17 = reacl(kcl + 2);
    if (reacl(kcl) > d17) {
      reacl(kcl) = reacl(kcl) - d17;
    }
    reacl(kcl + 1) = reacl(kcl + 1) - d17;
    reacl(kcl + 2) = 0.0f;
    n1 = kcld1 + 1;
    FEM_DO_SAFE(n3, n1, kcle) {
      hist(n3) = 0.0f;
    }
    //C.  OUTPUT INTERFACE OF SM AND DM EXCITATION WITH ELECT. NETW.          M31.1873
    voltum(jm) = vinp(4);
    if (ntyp59 == 1) {
      voltum(jm) = vinp(4) / dcoef(jm);
    }
  statement_9045:
    if (nodvo1(kcl + 3) == 1) {
      goto statement_9050;
    }
    if (loopss(9) == 2) {
      goto statement_9046;
    }
    crest(nclout) = -umcur(4);
    if (ntyp59 == 1) {
      crest(nclout) = -umcur(4) * dcoef(jm);
    }
    if (iprsup >= 1) {
      write(lunit6, format_8862), nclout, sfreq(nclout), crest(nclout),
        time1(nclout), tstop(nclout);
    }
  statement_9046:
    nclout++;
  statement_9050:
    if (nodvo2(kcl + 3) == 1) {
      goto statement_9060;
    }
    if (loopss(9) == 2) {
      goto statement_9052;
    }
    crest(nclout) = +umcur(4);
    if (ntyp59 == 1) {
      crest(nclout) = +umcur(4) * dcoef(jm);
    }
    if (iprsup >= 1) {
      write(lunit6, format_8862), nclout, sfreq(nclout), crest(nclout),
        time1(nclout), tstop(nclout);
    }
  statement_9052:
    nclout++;
  statement_9060:
    if (loopss(9) == 2) {
      goto statement_12100;
    }
    //C  IN CASE OF SM TYPE-59 AND EXCITER MASS IS PRESENT :                  M38.2113
    if (ntyp59 != 1) {
      goto statement_12000;
    }
    if (fpar(kcl + 3) >= 0.0f) {
      goto statement_12000;
    }
    n3 = -fpar(kcl + 3);
    d1 = umcur(4) * umcur(4);
    crest(n3) = -2.0f * d1 / (gpar(kcld1) * omegm(jm));
    goto statement_12000;
    //C.  IM EQUATIONS CODE *****************************************         M31.1882
    //C.  INPUT INTERFACE ELECT NETW WITH IM POWER SIDE **************        M31.1883
    //C     NORTON=0 MEANS NO NORTON CALCULATIONS                             M33. 781
    //C     NORTON=1 MEANS CALCULATION OF I - NORTON                          M33. 782
    //C     NORTON=2 MEANS CALCULATION OF Y - NORTON                          M33. 783
    //C  NOTE : NORTON PARAMETER CALCULATIONS ARE ONLY PERFORMED              M36. 999
    //C         IN THE PASS WITH LOOPSS(9) = 2                                M36.1000
  statement_10000:
    norton = 0;
    if (loopss(9) == 2) {
      norton = 1;
    }
    if (norton == 1) {
      goto statement_10080;
    }
    FEM_DO_SAFE(n10, 1, 3) {
      n11 = n10 + kcl - 1;
      if (nodvo1(n11) == nodvo2(n11)) {
        goto statement_10020;
      }
      n1 = nodvo1(n11);
      n1 = norder(n1);
      n2 = nodvo2(n11);
      n2 = norder(n2);
      dumvec(n10) = solr(n1) - solr(n2);
      dumvec(n10 + 3) = soli(n1) - soli(n2);
    statement_10020:;
    }
    if (con(1) == 1) {
      goto statement_10024;
    }
    if (con(8) == 1) {
      goto statement_10024;
    }
    if (loopss(9) == 2) {
      goto statement_10024;
    }
    d1 = dumvec(1) + dumvec(2) + dumvec(3);
    d2 = dumvec(4) + dumvec(5) + dumvec(6);
    d1 = d1 * d1;
    d1 += d2 * d2;
    d1 = sqrtz(d1);
    if (d1 < epsiln) {
      goto statement_10024;
    }
    write(lunit6, format_8310), jm;
    //C   POS SEQUENCE REAL AND IMAGINARY POWER THEV VOLTAGES :               M31.1894
  statement_10024:
    vinp(1) = sroot3 * con(3) * dumvec(1) + sroot2 * con(2) * dumvec(2);
    vinp(1) += con(1) * dumvec(3);
    vinp(21) = sroot3 * con(3) * dumvec(4) + sroot2 * con(2) * dumvec(5);
    vinp(21) += con(1) * dumvec(6);
    if (loopss(8) == 1) {
      goto statement_10080;
    }
    n10 = 0;
    n20 = 2;
    if (nodvo1(kcl) == nodvo2(kcl)) {
      n20 = 1;
    }
  statement_10030:
    n1 = nodvo1(kcl + 1);
    n1 = norder(n1) + n20 * ntot;
    n2 = nodvo2(kcl + 1);
    n2 = norder(n2) + n20 * ntot;
    //C   POS SEQUENCE REAL AND IMAGINARY POWER THEV IMPEDANCES :             M31.1908
    zthrr = -zthrr + solr(n1) - solr(n2);
    zthri = -zthri + soli(n1) - soli(n2);
    if (n10 == 1) {
      goto statement_10040;
    }
    n20++;
    n10 = 1;
    goto statement_10030;
  statement_10040:
    if (con(1) != 1.0f) {
      goto statement_10080;
    }
    n1 = nodvo1(kcl + 2);
    n1 = norder(n1);
    n2 = nodvo2(kcl + 2);
    n2 = norder(n2);
    zthrr = -solr(n1 + ntot) + solr(n2 + ntot);
    zthri = -soli(n1 + ntot) + soli(n2 + ntot);
    //C.  FORMATION OF CONSTANT SWITCH MATRIX PTHETA :                        M31.1922
  statement_10080:
    FEM_DO_SAFE(n1, 1, 3) {
      ptheta(3, n1) = 1.0f / sroot3;
    }
    ptheta(1, 1) = -1.0f / (sroot2 * sroot3);
    ptheta(1, 3) = sroot2 / sroot3;
    ptheta(1, 2) = ptheta(1, 1);
    ptheta(2, 1) = -1.0f / sroot2;
    ptheta(2, 2) = -ptheta(2, 1);
    ptheta(2, 3) = 0.0f;
    //C.  INPUT INTERFACE IM EXCITATION AND ELECT.NETW. (THEV VARIABLES):     M31.1931
    n17 = kcle - kcl - 2;
    if (ncl > 6) {
      n17 = 3;
    }
    FEM_DO_SAFE(n1, 1, 9) {
      ndum(n1) = 0;
    }
    FEM_DO_SAFE(n1, 1, n17) {
      n2 = kcl + 2 + n1;
      n3 = nodvo1(n2);
      ndum(n1) = norder(n3);
      n3 = nodvo2(n2);
      ndum(n1 + 3) = norder(n3);
      ndum(n1 + 6) = nodvo1(n2) - nodvo2(n2);
    }
    FEM_DO_SAFE(n1, 1, n17) {
      n2 = ndum(n1);
      n3 = ndum(n1 + 3);
      n4 = n1 + 6;
      if (ndum(n4) == 0) {
        goto statement_10130;
      }
      vinp(n1 + 3) = -solr(n2) + solr(n3);
      vinp(n1 + 23) = -soli(n2) + soli(n3);
      if (slip < 0.0f) {
        vinp(n1 + 23) = -vinp(n1 + 23);
      }
    statement_10130:;
    }
    n20 = 1;
    FEM_DO_SAFE(n1, 1, n17) {
      n2 = ndum(n1) + n20 * ntot;
      n3 = ndum(n1 + 3) + n20 * ntot;
      n5 = ndum(n1) + ntot;
      n6 = ndum(n1 + 3) + ntot;
      n7 = n1 + 6;
      n8 = ndum(1) + n20 * ntot;
      n9 = ndum(4) + n20 * ntot;
      if (ndum(n7) == 0) {
        goto statement_10140;
      }
      n20++;
      zths3(n1, n1) = -solr(n2) + solr(n3);
      zths3i(n1, n1) = -soli(n2) + soli(n3);
      if (n17 == 1) {
        goto statement_10200;
      }
      if (n1 == 1) {
        goto statement_10140;
      }
      if (ndum(7) == 0) {
        goto statement_10140;
      }
      zths3(1, n1) = -solr(n8) + solr(n9);
      zths3i(1, n1) = -soli(n8) + soli(n9);
      zths3(n1, 1) = -solr(n5) + solr(n6);
      zths3i(n1, 1) = -soli(n5) + soli(n6);
    statement_10140:;
    }
    if (slip > 0.0f) {
      goto statement_10146;
    }
    FEM_DO_SAFE(n1, 1, n17) {
      FEM_DO_SAFE(n2, 1, n17) {
        zths3i(n1, n2) = -zths3i(n1, n2);
      }
    }
  statement_10146:
    if (n17 < 3) {
      goto statement_10200;
    }
    n19 = 0;
    n20 = 1;
    n1 = ndum(8) * ndum(9);
    if (n1 == 0) {
      goto statement_10170;
    }
    if (ndum(7) != 0) {
      n20 = 2;
    }
    n1 = 3;
  statement_10150:
    n2 = ndum(n1) + n20 * ntot;
    n3 = ndum(n1 + 3) + n20 * ntot;
    if (n19 == 1) {
      goto statement_10160;
    }
    zths3(3, 2) = -solr(n2) + solr(n3);
    zths3i(3, 2) = -soli(n2) + soli(n3);
    n20++;
    n19 = 1;
    n1 = 2;
    goto statement_10150;
  statement_10160:
    zths3(2, 3) = -solr(n2) + solr(n3);
    zths3i(2, 3) = -soli(n2) + soli(n3);
  statement_10170:
    if (ncl <= 6) {
      goto statement_10200;
    }
    n17 = kcld1 + 3;
    FEM_DO_SAFE(n1, n17, kcle) {
      n2 = nodvo1(n1);
      n2 = norder(n2);
      n4 = n2 + ntot;
      n3 = nodvo2(n1);
      n3 = norder(n3);
      n5 = n3 + ntot;
      n10 = n1 - kcl + 1;
      if (nodvo1(n1) == nodvo2(n1)) {
        goto statement_10180;
      }
      zthevs(n10) = -solr(n4) + solr(n5);
      zthevs(n10 + 20) = -soli(n4) + soli(n5);
      vinp(n10) = -solr(n2) + solr(n3);
      vinp(n10 + 20) = -soli(n2) + soli(n3);
    statement_10180:;
    }
    //C.  TRANSFORMATION OF THEV VARIABLES IF UM TYPE 4 :                     M31.2007
  statement_10200:
    if (jtype(jm) != 4) {
      goto statement_10580;
    }
    FEM_DO_SAFE(n1, kcld1, kcle) {
      if (nodvo1(n1) != nodvo2(n1)) {
        goto statement_10504;
      }
    }
    goto statement_10580;
  statement_10504:
    n3 = 0;
  statement_10505:
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + 3;
      if (n3 == 1) {
        n2 = n1 + 23;
      }
      dumvec(n1) = vinp(n2);
    }
    matvec(ptheta, dumvec);
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + 3;
      if (n3 == 1) {
        n2 = n1 + 23;
      }
      vinp(n2) = dumvec(n1);
    }
    if (n3 == 1) {
      goto statement_10525;
    }
    n3 = 1;
    goto statement_10505;
  statement_10525:
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = ptheta(n2, n1);
      }
    }
    matmul(zths3, dummat);
    matmul(zths3i, dummat);
    n3 = 0;
  statement_10540:
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = ptheta(n1, n2);
      }
    }
    if (n3 == 1) {
      goto statement_10565;
    }
    matmul(dummat, zths3);
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        zths3(n1, n2) = dummat(n1, n2);
      }
    }
    n3 = 1;
    goto statement_10540;
  statement_10565:
    matmul(dummat, zths3i);
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        zths3i(n1, n2) = dummat(n1, n2);
      }
    }
    //C.  START CALCULATIONS OF Y - NORTON :                                  M33. 802
  statement_10580:
    if (norton != 2) {
      goto statement_10588;
    }
    vinp(1) = con(3) * sroot3 + con(2) * sroot2 + con(1);
    vinp(21) = 0.0f;
    FEM_DO_SAFE(n1, kcld1, kcle) {
      n10 = n1 - kcl + 1;
      vinp(n10) = 0.0f;
      vinp(n10 + 20) = 0.0f;
    }
    //C.  CALCULATION OF IM MAIN FLUXES :                                     M31.2050
    //C.       REAL AND IMAGINARY FLUX : FLXD, STORED, FLXQ, STOREQ           M35.1153
  statement_10588:
    jacob = 1;
    flxd(jm) = 1.0f;
    stored = 0.0f;
    flxq(jm) = 0.0f;
    storeq = 0.0f;
    goto statement_11000;
  statement_10600:
    FEM_DO_SAFE(n1, 1, 4) {
      fjm(n1, 1) = fjv(n1);
    }
    jacob = 2;
    flxd(jm) = 0.0f;
    stored = 1.0f;
    goto statement_11000;
  statement_10610:
    FEM_DO_SAFE(n1, 1, 4) {
      fjm(n1, 2) = fjv(n1);
    }
    jacob = 3;
    stored = 0.0f;
    flxq(jm) = 1.0f;
    goto statement_11000;
  statement_10620:
    FEM_DO_SAFE(n1, 1, 4) {
      fjm(n1, 3) = fjv(n1);
    }
    jacob = 4;
    flxq(jm) = 0.0f;
    storeq = 1.0f;
    goto statement_11000;
  statement_10630:
    FEM_DO_SAFE(n1, 1, 4) {
      fjm(n1, 4) = fjv(n1);
    }
    jacob = 5;
    storeq = 0.0f;
    goto statement_11000;
  statement_10640:
    jacob = 6;
    goto statement_10700;
  statement_10650:
    fjv(1) = umcur(2);
    fjv(2) = umcur(22);
    fjv(3) = umcur(3);
    fjv(4) = umcur(23);
    if (kcld1 > kclde) {
      goto statement_10670;
    }
    FEM_DO_SAFE(n1, kcld1, kclde) {
      n2 = n1 - kcl + 1;
      n3 = n2 + 20;
      fjv(1) += umcur(n2);
      fjv(2) += umcur(n3);
    }
  statement_10670:
    if (kclq1 > kclqe) {
      goto statement_10690;
    }
    FEM_DO_SAFE(n1, kclq1, kclqe) {
      n2 = n1 - kcl + 1;
      n3 = n2 + 20;
      fjv(3) += umcur(n2);
      fjv(4) += umcur(n3);
    }
  statement_10690:
    switch (jacob) {
    case 1: goto statement_10600;
    case 2: goto statement_10610;
    case 3: goto statement_10620;
    case 4: goto statement_10630;
    case 5: goto statement_10640;
    default: break;
    }
    //C.  NOW CALCULATE REAL AND IMAGINARY FLUXES BY GAUSSIAN                 M31.2100
    //C    ELIMINATION AT STMT. NR. 11625 . POINT OF RETURN = 10750           M31.2101
  statement_10700:
    FEM_DO_SAFE(n1, 1, 4) {
      FEM_DO_SAFE(n2, 1, 4) {
        fjm(n1, n2) = fjm(n1, n2) - fjv(n1);
      }
    }
    FEM_DO_SAFE(n1, 1, 2) {
      n2 = n1 + 2;
      fjm(n1, n1) = fjm(n1, n1) - 1.0f / reamdu(jm);
      fjm(n2, n2) = fjm(n2, n2) - 1.0f / reamqu(jm);
    }
    FEM_DO_SAFE(n1, 1, 4) {
      FEM_DO_SAFE(n2, 1, 4) {
        gmat(n1, n2) = -fjm(n1, n2);
      }
    }
    FEM_DO_SAFE(n1, 1, 4) {
      gmat(n1, 5) = fjv(n1);
    }
    jgauss = 1;
    n5 = 4;
    goto statement_11625;
  statement_10750:
    jgauss = 0;
    flxd(jm) = dumvec(1);
    stored = dumvec(2);
    flxq(jm) = dumvec(3);
    storeq = dumvec(4);
    //C.   CALCULATION OF UMCUR FOR IM *******************************        M31.2124
    //C.   UMCUR POWER :                                                      M31.2125
  statement_11000:
    d10 = reacl(kcl + 1) * seltat;
    d11 = reacl(kcl + 2) * seltat;
    d11 += zthri + (d10 - d11) / 2.0f;
    d12 = zthrr + 1.0f / gpar(kcl + 2);
    d13 = 2.0f * (d11 * d11 + d12 * d12);
    d17 = (flxd(jm) + storeq) * seltat;
    d18 = (stored - flxq(jm)) * seltat;
    d1 = -sroot2 * vinp(1);
    d1 += d17;
    d2 = -sroot2 * vinp(21);
    d2 += d18;
    umcur(1) = 0.0f;
    umcur(21) = 0.0f;
    umcur(2) = (d2 * d12 - d1 * d11) / d13;
    umcur(3) = (d1 * d12 + d2 * d11) / d13;
    umcur(22) = -umcur(3);
    umcur(23) = +umcur(2);
    //C.  UMCUR EXCITATION BECAUSE OF INPUT VOLTAGE                           M31.2141
    if (jacob < 6) {
      goto statement_11100;
    }
    if (loopss(9) != 2) {
      goto statement_11100;
    }
    if (slip != 0.0f) {
      goto statement_11100;
    }
    goto statement_11720;
  statement_11100:
    FEM_DO_SAFE(n10, kcld1, kcle) {
      d1 = slip * seltat * reacl(n10) * gpar(n10);
      d2 = 1.0f + d1 * d1;
      fpar(n10) = 1.0f / d2;
      n5 = n10 - kcl + 1;
      n6 = n5 + 20;
      d3 = fpar(n10) * gpar(n10);
      umcur(n5) = -d3 * (vinp(n5) + d1 * vinp(n6));
      umcur(n6) = -d3 * (vinp(n6) - d1 * vinp(n5));
    }
    //C.  UMCUR EXCITATION BECAUSE OF FLUXES                                  M31.2152
    if (ncld(jm) == 0) {
      goto statement_11530;
    }
    FEM_DO_SAFE(n10, kcld1, kclde) {
      n5 = n10 - kcl + 1;
      n6 = n5 + 20;
      d1 = slip * seltat * gpar(n10) * reacl(n10);
      d2 = slip * seltat * gpar(n10) * fpar(n10);
      umcur(n5) += d2 * (stored - d1 * flxd(jm));
      umcur(n6) = umcur(n6) - d2 * (d1 * stored + flxd(jm));
    }
  statement_11530:
    if (nclq(jm) == 0) {
      goto statement_11550;
    }
    FEM_DO_SAFE(n10, kclq1, kclqe) {
      n5 = n10 - kcl + 1;
      n6 = n5 + 20;
      d1 = slip * seltat * gpar(n10) * reacl(n10);
      d2 = slip * seltat * gpar(n10) * fpar(n10);
      umcur(n5) += d2 * (storeq - d1 * flxq(jm));
      umcur(n6) = umcur(n6) - d2 * (d1 * storeq + flxq(jm));
    }
    //C.  UMCUR EXCITATION BECAUSE OF THEV IMPEDANCES :                       M31.2171
  statement_11550:
    FEM_DO_SAFE(n1, kcld1, kcle) {
      if (nodvo1(n1) != nodvo2(n1)) {
        goto statement_11554;
      }
    }
    goto statement_11720;
  statement_11554:
    n15 = kcle;
    if (ncl > 6) {
      n15 = kcl + 5;
    }
    FEM_DO_SAFE(n10, 1, 3) {
      FEM_DO_SAFE(n11, 1, 3) {
        zthevr(n10, n11) = 0.0f;
        dummat(n10, n11) = 0.0f;
      }
    }
    n7 = kcl + 3;
    FEM_DO_SAFE(n10, n7, n15) {
      n6 = n10 - kcl - 2;
      zthevr(n6, n6) = gpar(n10) * fpar(n10);
      dummat(n6, n6) = zthevr(n6, n6);
    }
    matmul(dummat, zths3);
    matmul(zthevr, zths3i);
    FEM_DO_SAFE(n10, 1, 3) {
      FEM_DO_SAFE(n11, 1, 3) {
        dumma1(n10, n11) = dummat(n10, n11);
        dumma2(n10, n11) = zthevr(n10, n11);
      }
    }
    FEM_DO_SAFE(n10, 1, 3) {
      n12 = n10 + kcl + 2;
      d1 = slip * seltat * reacl(n12) * gpar(n12);
      FEM_DO_SAFE(n11, 1, 3) {
        zthevr(n10, n11) = d1 * zthevr(n10, n11);
        dummat(n10, n11) = d1 * dummat(n10, n11);
      }
    }
    FEM_DO_SAFE(n10, 1, 3) {
      FEM_DO_SAFE(n11, 1, 3) {
        dumma1(n10, n11) += zthevr(n10, n11);
        dumma2(n10, n11) = dumma2(n10, n11) - dummat(n10, n11);
      }
    }
    FEM_DO_SAFE(n10, 1, 3) {
      n12 = n10 + 3;
      FEM_DO_SAFE(n11, 1, 3) {
        n13 = n11 + 3;
        gmat(n10, n11) = +dumma1(n10, n11);
        gmat(n12, n13) = +dumma1(n10, n11);
        gmat(n10, n13) = -dumma2(n10, n11);
        gmat(n12, n11) = +dumma2(n10, n11);
      }
    }
    FEM_DO_SAFE(n10, 1, 6) {
      gmat(n10, n10) += 1.0f;
    }
    FEM_DO_SAFE(n10, 1, 3) {
      n11 = n10 + 3;
      n12 = n11 + 20;
      gmat(n10, 7) = umcur(n11);
      gmat(n11, 7) = umcur(n12);
    }
    jgauss = 0;
    n5 = 6;
    //C.  GAUSSIAN ELIMINATION FOR INPUT : N5 AND GMAT(N5,N5+1) *****         M31.2222
    //C             OUTPUT IS STORED IN  : DUMVEC(N5)                         M31.2223
  statement_11625:
    n6 = n5 + 1;
    FEM_DO_SAFE(n1, 1, n5) {
      n2 = n1 + 1;
      if (n2 > n5) {
        goto statement_11650;
      }
      FEM_DO_SAFE(n10, n2, n5) {
        n8 = n6 - n1;
        FEM_DO_SAFE(n9, 1, n8) {
          n11 = n6 + 1 - n9;
          d1 = gmat(n10, n1) * gmat(n1, n11) / gmat(n1, n1);
          gmat(n10, n11) = gmat(n10, n11) - d1;
        }
        n11 = n6 - n8;
        gmat(n10, n11) = 0.0f;
      }
    }
  statement_11650:
    FEM_DO_SAFE(n10, 1, n5) {
      n7 = n5 + 1 - n10;
      dumvec(n7) = gmat(n7, n6) / gmat(n7, n7);
      FEM_DO_SAFE(n12, 1, n5) {
        n13 = n7 + n12;
        if (n13 > n5) {
          goto statement_11670;
        }
        dumvec(n7) = dumvec(n7) - gmat(n7, n13) * dumvec(n13) / gmat(n7, n7);
      }
    statement_11670:;
    }
    //C.  END OF GAUSSIAN ELIMINATION ********************************        M31.2245
    if (jgauss == 1) {
      goto statement_10750;
    }
    FEM_DO_SAFE(n10, 1, 3) {
      n11 = n10 + 3;
      n12 = n11 + 20;
      umcur(n11) = dumvec(n10);
      umcur(n12) = dumvec(n11);
    }
    if (ncl <= 6) {
      goto statement_11720;
    }
    n15 = kcl + 6;
    FEM_DO_SAFE(n10, n15, kcle) {
      n11 = n10 - kcl + 1;
      n12 = n11 + 20;
      zthevs(n11) = gpar(n10) * fpar(n10) * zthevs(n11);
      zthevs(n12) = gpar(n10) * fpar(n10) * zthevs(n12);
      d1 = slip * seltat * gpar(n10) * reacl(n10);
      d2 = zthevs(n11);
      zthevs(n11) = 1.0f + zthevs(n11) + d1 * zthevs(n12);
      zthevs(n12) = +zthevs(n12) - d1 * d2;
      d3 = zthevs(n11) * zthevs(n11);
      d3 += zthevs(n12) * zthevs(n12);
      d3 = 1.0f / d3;
      d1 = umcur(n11);
      umcur(n11) = zthevs(n11) * umcur(n11) + zthevs(n12) * umcur(n12);
      umcur(n11) = d3 * umcur(n11);
      umcur(n12) = -zthevs(n12) * d1 + zthevs(n11) * umcur(n12);
      umcur(n12) = d3 * umcur(n12);
    }
  statement_11720:
    if (jacob < 6) {
      goto statement_10650;
    }
    //C.  OUTPUT FOR UM = IM                                                  M31.2272
    if (loopss(9) == 2) {
      goto statement_11800;
    }
    omegm(jm) = (1.0f - slip) * seltat / nppair(jm);
    omold(jm) = omegm(jm);
    FEM_DO_SAFE(n10, 1, 3) {
      n11 = kcl - 1 + n10;
      hist(n11) = umcur(n10);
    }
    FEM_DO_SAFE(n10, kcld1, kcle) {
      n11 = n10 - kcl + 1;
      hist(n10) = -umcur(n11);
    }
    //C.  BACK TRANSFORMATION FOR UM TYPE 4 EXCITATION CURRENTS               M31.2282
    if (jtype(jm) != 4) {
      goto statement_11800;
    }
    n13 = 0;
  statement_11760:
    FEM_DO_SAFE(n10, 1, 3) {
      n12 = n10 + 3 + n13 * 20;
      dumvec(n10) = umcur(n12);
      FEM_DO_SAFE(n11, 1, 3) {
        dummat(n10, n11) = ptheta(n11, n10);
      }
    }
    matvec(dummat, dumvec);
    FEM_DO_SAFE(n10, 1, 3) {
      n11 = n10 + 3 + n13 * 20;
      umcur(n11) = dumvec(n10);
    }
    if (n13 == 1) {
      goto statement_11800;
    }
    n13 = 1;
    goto statement_11760;
    //C.  OUTPUT INTERFACE OF IM AND ELECT. NETWORK :                         M31.2298
  statement_11800:
    d14 = con(3) / (sroot2 * sroot3) + con(2) / 2.0f + con(1);
    d15 = con(3) / sroot3 + con(2) / sroot2 + con(1);
    d11 = (-umcur(22) + umcur(3)) * d14;
    d12 = (+umcur(2) + umcur(23)) * d14;
    //C  ADJUSTING CURRENT OUTPUT TO INCLUDE POWER RESISTANCE TO EMTP         M37.3599
    //C   FOR THE CASE OF PREDICTION REQUEST :                                M37.3600
    if (loopss(9) != 3) {
      goto statement_11806;
    }
    d11 += vinp(1) * gpar(kcl + 2) * d15;
    d12 += vinp(21) * gpar(kcl + 2) * d15;
  statement_11806:
    d10 = d11 * d11 + d12 * d12;
    if (d10 != 0.0f) {
      goto statement_11810;
    }
    d11 = 0.0f;
    d2 = 0.0f;
    d3 = 0.0f;
    goto statement_11815;
  statement_11810:
    if (norton == 2) {
      d5 = -d11 / d10;
    }
    if (norton == 2) {
      d6 = +d12 / d10;
    }
    d10 = sqrtz(d10);
    d1 = d12 / d11;
    d1 = std::atan(d1);
    if (d11 < 0.0f) {
      d1 += twopi / 2.0f;
    }
    d2 = con(2) * d1 + con(3) * (d1 - twopi / 3.0f);
    d3 = con(2) * (d1 + twopi / 4.0f) + con(3) * (d1 + twopi / 3.0f);
    d3 += con(1) * d1;
  statement_11815:
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + kcl - 1;
      n11 = 3 * (jm - 1);
      if (nodvo1(n2) == nodvo2(n2)) {
        goto statement_11824;
      }
      //C      INCLUDING MACH RESISTANCES TO POWER NETWORK AT                   M33. 834
      //C      LAST PASS THROUGH THIS PART OF CODE FOR NON -                    M33. 835
      //C      COMPENSATED POWER COILS.                                         M33. 836
      if (lfim3i != 0) {
        goto statement_11818;
      }
      if (loopss(8) != 1) {
        goto statement_11821;
      }
    statement_11818:
      n11 = numibr - 3 + n1;
      n12 = -nr(n11);
      if (n12 < 0) {
        n12 = -n12;
      }
      tr(n12) = 1.0f / gpar(kcl + 2);
      tx(n12) = 0.0f;
      if (norton != 2) {
        goto statement_11821;
      }
      tr(n12) = d5;
      tx(n12) = d6 * 1.0e+3 / seltat;
      if (xopt != 0.0f) {
        tx(n12) = d6 * xopt * twopi / seltat;
      }
      goto statement_11823;
    statement_11821:
      d11 = d1;
      if (n1 == 2) {
        d11 = d2;
      }
      if (n1 == 3) {
        d11 = d3;
      }
      if (n1 == 1 && lfim3i != 0) {
        nclout = hist(kcl + 2);
      }
      if (nodvo1(n2) == 1) {
        goto statement_11822;
      }
      crest(nclout) = d10;
      time1(nclout) = d11;
      if (iprsup >= 1) {
        write(lunit6, format_8862), nclout, sfreq(nclout), crest(nclout),
          time1(nclout), tstop(nclout);
      }
      nclout++;
    statement_11822:
      if (nodvo2(n2) == 1) {
        goto statement_11823;
      }
      crest(nclout) = -d10;
      time1(nclout) = d11;
      if (iprsup >= 1) {
        write(lunit6, format_8862), nclout, sfreq(nclout), crest(nclout),
          time1(nclout), tstop(nclout);
      }
      nclout++;
    statement_11823:
      if (loopss(8) == 0 && lfim3i == 0) {
        goto statement_11824;
      }
      if (iprsup >= 1 && norton != 1) {
        write(lunit6, format_8860), n11, tr(n12), tx(n12);
      }
    statement_11824:;
    }
    if (loopss(9) != 2) {
      goto statement_11825;
    }
    if (norton == 2) {
      goto statement_11825;
    }
    norton = 2;
    goto statement_10580;
  statement_11825:
    if (lfim3i != 0) {
      goto statement_13050;
    }
    nclind = fpar(kcl + 1);
    FEM_DO_SAFE(n10, 4, ncl) {
      n11 = n10 + 20;
      n12 = n10 + kcl - 1;
      if (slip < 0.0f) {
        umcur(n11) = -umcur(n11);
      }
      if (nodvo1(n12) == nodvo2(n12)) {
        goto statement_11840;
      }
      if (loopss(9) == 2) {
        goto statement_11828;
      }
      d2 = umcur(n10) * umcur(n10) + umcur(n11) * umcur(n11);
      d2 = sqrtz(d2);
      d3 = umcur(n11) / umcur(n10);
      d3 = std::atan(d3);
      if (umcur(n10) < 0.0f) {
        d3 += twopi / 2.0f;
      }
    statement_11828:
      if (nodvo1(n12) == 1) {
        goto statement_11830;
      }
      if (loopss(9) == 2) {
        goto statement_11829;
      }
      crest(nclind) = -d2;
      time1(nclind) = d3;
      if (iprsup >= 1) {
        write(lunit6, format_8862), nclind, sfreq(nclind), crest(nclind),
          time1(nclind), tstop(nclind);
      }
    statement_11829:
      nclind++;
    statement_11830:
      if (nodvo2(n12) == 1) {
        goto statement_11840;
      }
      if (loopss(9) == 2) {
        goto statement_11832;
      }
      crest(nclind) = +d2;
      time1(nclind) = d3;
      if (iprsup >= 1) {
        write(lunit6, format_8862), nclind, sfreq(nclind), crest(nclind),
          time1(nclind), tstop(nclind);
      }
    statement_11832:
      nclind++;
    statement_11840:;
    }
    //C.  CALCULATION OF MECH. VARIABLES *****************************        M31.2343
    //C   NOTE : THIS SECOND PART OF UMRENU IS ENTERED ONLY AT THE            M37.3665
    //C          LAST PASS THROUGH SECOND PART OF CODE. HERE WE               M37.3666
    //C          WILL USE ANGLUM(JM) TO STORE TQGEN FOR THE SLACK-BUS         M37.3667
    //C          CALCULATION.                                                 M37.3668
    if (loopss(9) == 2) {
      goto statement_12100;
    }
  statement_12000:
    d1 = 3.0f * con(3) + 2.0f * con(2) + con(8) + con(1);
    d2 = (reacl(kcl + 1) - reacl(kcl + 2)) * umcur(2) * umcur(3);
    d3 = umcur(2) * flxq(jm);
    d4 = umcur(3) * flxd(jm);
    tqgen = (d2 - d3 + d4) * nppair(jm);
    if (inpu == 1) {
      tqgen = tqgen / d1;
    }
    //C.  OUTPUT INTERFACE OF UM WITH MECHANICAL NETWORK :                    M31.2350
    anglum(jm) = +tqgen;
    crest(nclout) = omegm(jm);
    if (loopss(10) != 3) {
      jtmtac(jm) = 0;
    }
    if (iprsup >= 1) {
      write(lunit6, format_8862), nclout, sfreq(nclout), crest(nclout),
        time1(nclout), tstop(nclout);
    }
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, lunit6, "(/,' HIST(1:NCL) ='(1x,6e15.6))");
        FEM_DO_SAFE(n1, 1, ncl) {
          wloop, hist(n1);
        }
      }
    }
    if (iprsup >= 1) {
      write(lunit6, "(/,' TQGEN =',1x,e15.6)"), tqgen;
    }
  statement_12100:
    nclout++;
    //C  FINAL STATEMENTS OF MACHINE DO-LOOP                                  M32.3252
    if (ntyp59 == 1) {
      jtype(jm) = 13;
    }
    if (ntyp59 == 1) {
      inpu = inpust;
    }
    if (loopss(9) == 2) {
      hist(kcl) = numibr;
    }
  statement_13050:;
  }
  if (lfim3 == 1) {
    loopss(9) = lpss9;
  }
  if (lfim3 == 1) {
    goto statement_13500;
  }
  if (loopss(9) == 2) {
    goto statement_13500;
  }
  loopss(2) = 0;
  loopss(6) = kconst;
  //C.  CALCULATION OF SLACK BUSES :                                        M31.2356
statement_13100:
  kconst = loopss(6);
  FEM_DO_SAFE(jm, 1, numum) {
    kcl = kcoil(jm);
    n1 = jcltac(kcl);
    n2 = jcltac(kcl + 1);
    nshare = n1 + n2;
    if (nshare != 0) {
      nshare = 1;
    }
    //C  NOTE : IF NSHARE=0 THEN NO MULTI UM SHARING MECH NETW                M39.1410
    if (n1 != 0 && jm > n1) {
      nshare = 10;
    }
    if (n2 != 0 && jm > n2) {
      nshare = 10;
    }
    //C  NOTE: IF NSHARE=10, NO MECH SLACK BUS CALC BUT SPEED CAPACITOR       M39.1413
    //C         AND TORQUE SOURCE OF UM NR. N1 AND UM NR. N2 TO BE SET        M39.1414
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' *************************',"
        "' START ADJUSTMENT OF SLACK BUSES IN THE',"
        "' EMTP NETWORKS CONNECTED TO UM NUMBER',i4,' :')"),
        jm;
    }
    //C  CHECKING SPEEDS FOR MULTI-MACH SHARING COMMON NETWORK :              M39.1415
    if (loopss(4) > 0) {
      goto statement_13118;
    }
    if (nshare == 0) {
      goto statement_13118;
    }
    if (nshare == 10) {
      goto statement_13118;
    }
    if (omegm(jm) != omegm(n1)) {
      goto statement_13112;
    }
    if (n2 == 0) {
      goto statement_13118;
    }
    if (omegm(jm) != omegm(n2)) {
      goto statement_13112;
    }
    goto statement_13118;
  statement_13112:
    if (n2 == 0) {
      goto statement_13115;
    }
    write(lunit6,
      "(/,' ********************************************',"
      "' ********************************************',' WARNING : UM NUMBER',"
      "i4,', ',i4,', AND',i4)"),
      jm, n1, n2;
    write(lunit6, format_13114);
    write(lunit6, format_93116);
  statement_13115:
    write(lunit6,
      "(/,' ********************************************',"
      "' ********************************************',' WARNING : UM NUMBER',"
      "i4,', AND',i4)"),
      jm, n1;
    write(lunit6, format_13114);
    write(lunit6, format_93116);
  statement_13118:
    if (iprsup >= 1) {
      write(lunit6,
        "(' *********** SLACK BUS SOURCE:',2x,'KCONST',4x,'NODE',9x,'SFREQ',"
        "9x,'CREST',9x,'TIME1',8x,'TSTART',9x,'TSTOP')");
    }
    imach = 1;
    if (jtype(jm) < 3) {
      imach = 0;
    }
    if (jtype(jm) > 7) {
      imach = 0;
    }
    if (imach != 1) {
      n10 = nodfum(jm);
    }
    if (loopss(4) > 0) {
      goto statement_13130;
    }
    if (imach != 1) {
      crest(n10) = voltum(jm);
    }
    if (imach != 1 && iprsup >= 1) {
      write(lunit6, format_13122), n10, node(n10), sfreq(n10), crest(n10),
        time1(n10), tstart(n10), tstop(n10);
    }
    if (nshare == 10) {
      goto statement_13170;
    }
    goto statement_13370;
    //C  COIL TERMINAL VOLTAGE AND MECHANICAL SPEED FOR GIVEN CREST:          M31.2367
    //C   TEMPORARY STORAGE OF VOLTAGE IN FLXD(JM) AND VOLTUM(JM)             M31.2368
    //C   TEMPORARY STORAGE FOR TORQUE IN FLXQ(JM) AND ANGLUM(JM)             M37.3681
    //C  NOTE: SOLR IS HERE NODE VOLTAGE SINCE NO COMPENSATION ON             M31.2370
    //C        THE UM TERMINALS WHICH ARE CONSIDERED HERE.                    M31.2371
    //C  CODE FOR LOOPSS(4) = 1 AND 2 ********************************        M38.2151
  statement_13130:
    n11 = nodmum(jm);
    if (imach == 1) {
      goto statement_13140;
    }
    n5 = kcl + 3;
    n1 = nodvo1(n5);
    n1 = norder(n1);
    n2 = nodvo2(n5);
    n2 = norder(n2);
    d1 = solr(n1) - solr(n2);
  statement_13140:
    n12 = nodom(jm);
    n3 = norder(n12);
    d3 = -e(n3);
    //C  CODE FOR LOOPSS(4) = 1  *************************************        M38.2161
    if (loopss(4) > 1) {
      goto statement_13150;
    }
    if (imach != 1) {
      flxd(jm) = d1;
    }
    if (imach != 1) {
      crest(n10) = 0.0f;
    }
    if (imach != 1 && iprsup >= 1) {
      write(lunit6, format_13122), n10, node(n10), sfreq(n10), crest(n10),
        time1(n10), tstart(n10), tstop(n10);
    }
    if (nshare == 10) {
      goto statement_13170;
    }
    flxq(jm) = d3;
    tstop(n11) = crest(n11);
    crest(n11) = 0.0f;
    if (iprsup >= 1) {
      write(lunit6, format_13123), n11, node(n11), sfreq(n11), crest(n11),
        time1(n11), tstart(n11), tstop(n11);
    }
    n13 = kssfrq(n12);
    if (n13 < 0) {
      goto statement_13370;
    }
    n14 = n13;
  statement_13142:
    if (n13 == n11) {
      goto statement_13144;
    }
    if (tstart(n13) != -7777.f) {
      goto statement_13144;
    }
    tstop(n13) = crest(n13);
    crest(n13) = 0.0f;
    if (iprsup >= 1) {
      write(lunit6, format_13123), n13, node(n13), sfreq(n13), crest(n13),
        time1(n13), tstart(n13), tstop(n13);
    }
  statement_13144:
    n13 = kpsour(n13);
    if (n14 != n13) {
      goto statement_13142;
    }
    goto statement_13370;
    //C  CODE FOR LOOPSS(4) = 2 (FINAL UMRENU PASS) ******************        M38.2170
  statement_13150:
    if (imach == 1) {
      goto statement_13160;
    }
    d5 = voltum(jm) - d1;
    d5 = d5 / (flxd(jm) - d1);
    crest(n10) = d5 * voltum(jm);
    if (iprsup >= 1) {
      write(lunit6, format_13122), n10, node(n10), sfreq(n10), crest(n10),
        time1(n10), tstart(n10), tstop(n10);
    }
  statement_13160:
    if (nshare == 10) {
      goto statement_13170;
    }
    d5 = anglum(jm) - d3;
    d5 = d5 / (flxq(jm) - d3);
    crest(n11) = d5 * tstop(n11);
    tstop(n11) = 9999.f;
    if (iprsup >= 1) {
      write(lunit6, format_13123), n11, node(n11), sfreq(n11), crest(n11),
        time1(n11), tstart(n11), tstop(n11);
    }
    n13 = kssfrq(n12);
    if (n13 < 0) {
      goto statement_13370;
    }
    n14 = n13;
  statement_13162:
    if (n13 == n11) {
      goto statement_13164;
    }
    if (tstart(n13) != -7777.f) {
      goto statement_13164;
    }
    crest(n13) = d5 * tstop(n13);
    tstop(n13) = 9999.f;
    if (iprsup >= 1) {
      write(lunit6, format_13123), n13, node(n13), sfreq(n13), crest(n13),
        time1(n13), tstart(n13), tstop(n13);
    }
  statement_13164:
    n13 = kpsour(n13);
    if (n14 != n13) {
      goto statement_13162;
    }
    //C  SET SPEED CAPACITORS AND SOURCES FOR TQGEN (FOR UM'S WITH            M38.2177
    //C    NO SLACK BUS CALCULATIONS, I.E. JM GT THAN JCLTAC(KCL) AND         M38.2178
    //C    FOR JM GT JCLTAC(KCL+1) .                                          M38.2179
  statement_13170:
    if (nshare != 10) {
      goto statement_13370;
    }
    n2 = fpar(kcl + 2);
    c(n2) = 1.0e+8;
    if (copt != 0.0f) {
      c(itcap) = c(itcap) * copt * twopi;
    }
    tr(n2) = 0.0f;
    kconst++;
    if (kconst <= lexct) {
      goto statement_6784;
    }
    write(lunit6,
      "(' OVERFLOW LIST 4 IN \"UMRENU\".  LEXCT =',i5,'     STOP LOCALLY.')"),
      lexct;
    stoptp(cmn);
  statement_6784:
    node(kconst) = -nodom(jm);
    iform(kconst) = 14;
    crest(kconst) = -anglum(jm);
    time1(kconst) = 0.0f;
    tstart(kconst) = -1.0f;
    tstop(kconst) = 0.0f;
    n5 = nodmum(jm);
    sfreq(kconst) = sfreq(n5);
    if (iprsup >= 1) {
      write(lunit6,
        "(' ****** TEMPORARY TQGEN SOURCE:',1x,i6,2x,i6,5e14.5)"),
        kconst, node(kconst), sfreq(kconst), crest(kconst), time1(kconst),
        tstart(kconst), tstop(kconst);
    }
  statement_13370:;
  }
  loopss(4)++;
  if (loopss(4) < 3) {
    goto statement_13500;
  }
  //C.  PERMANENT EXIT OF UMRENU IF LOOPSS(4) .GE. 3                        M38.2199
  loopss(1) = -1;
  cmn.kssout = loopss(7);
  istart = 0;
  if (iprsup >= 1) {
    write(lunit6, "(/,' PERMANENT EXIT OF UMRENU **************')");
  }
  goto statement_14000;
statement_13500:
  istart++;
  if (iprsup < 4) {
    goto statement_14000;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' BRANCH TABLE VECTORS',/,"
      "'       ROW      KBUS      MBUS        NR    LENGTH    KODEBR    KODSEM"
      "',/(1x,7i10))");
    FEM_DO_SAFE(i, 1, ibr) {
      wloop, i, kbus(i), mbus(i), nr(i), length(i), kodebr(i), kodsem(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' SOURCE TABLE VECTORS',/,'       ROW     IFORM      NODE',15x,"
      "'CREST',15x,'TIME1',14x,'TSTART',15x,'SFREQ',/(3i10,4e20.10))");
    FEM_DO_SAFE(i, 1, kconst) {
      wloop, i, iform(i), node(i), crest(i), time1(i), tstart(i), sfreq(i);
    }
  }
statement_14000:
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' *************************',' SETTING AT THIS UMRENU EXIT :',/,"
      "'  ISTART   ISTEP  LOPSS1  LOPSS2  LOPSS4  LOPSS8',"
      "'  LOPSS9 LOPSS10  KCONST     IBR   INONL  KSWTCH','  ISTEAD',8x,"
      "'OMEGRF',/,13i8,e14.5,/)"),
      istart, istep, loopss(1), loopss(2), loopss(4), loopss(8), loopss(9),
      loopss(10), kconst, ibr, cmn.inonl, cmn.kswtch, cmn.istead,
      cmn.omegrf;
  }
}

void equiv(
  common& cmn,
  arr_ref<double> req,
  arr_ref<double> xeq,
  arr_ref<double> geq,
  arr_ref<double> beq,
  arr_cref<double> z,
  arr_cref<double> r,
  arr_cref<double> tau,
  double const& w,
  int const& n)
{
  req(dimension(n));
  xeq(dimension(n));
  geq(dimension(n));
  beq(dimension(n));
  z(dimension(n));
  r(dimension(n));
  tau(dimension(n));
  common_write write(cmn);
  int L = fem::int0;
  int j = fem::int0;
  double a = fem::double0;
  double zs = fem::double0;
  double rs = fem::double0;
  auto& lunit6 = cmn.lunit6;
  double denr = fem::double0;
  double denx = fem::double0;
  double piov2 = fem::double0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  double rzero = fem::double0;
  double xzero = fem::double0;
  double e = fem::double0;
  double ypos = fem::double0;
  double yneg = fem::double0;
  double cosha = fem::double0;
  double sinha = fem::double0;
  double sinb = fem::double0;
  double cosb = fem::double0;
  double sinhgr = fem::double0;
  double sinhgi = fem::double0;
  double anumr = fem::double0;
  double anumx = fem::double0;
  double c = fem::double0;
  double d = fem::double0;
  double e2 = fem::double0;
  double c2 = fem::double0;
  double e2div8 = fem::double0;
  double epos = fem::double0;
  double eneg = fem::double0;
  double tden = fem::double0;
  //C!w      EQUIVALENCE    (ANUMR, RZERO),    (ANUMX, XZERO),                 M42.5832
  //C!w     1 (YPOS, SINB),     (YNEG, COSB),     (EPOS, SINHGR),              M42.5833
  //C!w     2 (ENEG, SINHGI),     (C, COSHA),     (D, SINHA)                   M42.5834
  //C
  FEM_DO_SAFE(L, 1, n) {
    j = L;
    a = w * tau(j);
    zs = z(j);
    rs = r(j);
    if (cmn.iprsup >= 3) {
      write(lunit6,
        "(/,' WITHIN L-LOOP OF  ''EQUIV'' .','       L       N',15x,'W',10x,"
        "'TAU(J)',14x,'ZS',14x,'RS',/,28x,2i8,4e16.7)"),
        L, n, w, tau(j), zs, rs;
    }
    if (rs >= 0.0f) {
      goto statement_1;
    }
    rs = -rs;
    denr = a * zs;
    denx = a / zs;
    piov2 = cmn.twopi * 0.25f;
    d1 = sqrtz(fem::pow2(rs) + fem::pow2(denr));
    d2 = std::atan2(denr, rs);
    d3 = 0.5f * (d2 - piov2);
    d4 = sqrtz(d1 / denx);
    rzero = d4 * cosz(d3);
    xzero = d4 * sinz(d3);
    d3 += piov2;
    d4 = sqrtz(d1 * denx);
    e = d4 * cosz(d3);
    a = d4 * sinz(d3);
    ypos = expz(e);
    yneg = 1.0f / ypos;
    cosha = (ypos + yneg) / 2.0f;
    sinha = cosha - yneg;
    sinb = sinz(a);
    cosb = cosz(a);
    sinhgr = sinha * cosb;
    sinhgi = cosha * sinb;
    denr = rzero * sinhgr - xzero * sinhgi;
    denx = rzero * sinhgi + xzero * sinhgr;
    anumr = cosha * cosb - 1.0f;
    anumx = sinha * sinb;
    goto statement_2;
  statement_1:
    e = rs / zs;
    if (zs < 0.f) {
      goto statement_3;
    }
    a = a / 2.0f;
    c = sinz(a);
    d = cosz(a);
    e2 = fem::pow2(e);
    c2 = fem::pow2(c);
    denr = (48.f + e2) / 32.f;
    denr = (1.0f - c2 * denr) * rs;
    e2div8 = e2 / 8.0f;
    denx = (3.0f * e2div8 + 2.0f) * c * d * zs;
    anumr = (-2.0f - e2div8) * c2;
    anumx = e * c * d;
  statement_2:
    e = fem::pow2(denr) + fem::pow2(denx);
    req(L) = denr;
    xeq(L) = denx;
  statement_4:
    geq(L) = (anumr * denr + anumx * denx) / e;
    beq(L) = (anumx * denr - anumr * denx) / e;
    goto statement_5;
  statement_3:
    e = e / 2.0f;
    c = sinz(a);
    d = cosz(a);
    ypos = expz(-e);
    yneg = 1.0f / ypos;
    epos = ypos + yneg;
    eneg = ypos - yneg;
    anumr = d * epos - 2.f;
    anumx = c * eneg;
    denr = d * eneg;
    denx = c * epos;
    tden = (denr * denr + denx * denx);
    e = -zs / 2.0f;
    req(L) = e * denr;
    xeq(L) = e * denx;
    e = -zs * tden;
    goto statement_4;
  statement_5:;
  }
}

void cxred8(
  arr_ref<double> a,
  arr_ref<double> c,
  int const& n,
  int const& m)
{
  a(dimension(n * (n+1) / 2));
  c(dimension(n * (n+1) / 2));
  int j = fem::int0;
  double w = fem::double0;
  int ij = fem::int0;
  double h1 = fem::double0;
  double g1 = fem::double0;
  double x = fem::double0;
  arr_1d<30, double> b(fem::fill0);
  arr_1d<30, double> d(fem::fill0);
  int k = fem::int0;
  int ik = fem::int0;
  int i1 = fem::int0;
  int i = fem::int0;
  double h2 = fem::double0;
  double g2 = fem::double0;
  int i2 = fem::int0;
  int L = fem::int0;
  double y = fem::double0;
  //C)    ELIMINATION OF VARIABLES M+1,...N IN SYMMETRIC COMPLEX MATRIX WITHM29.1588
  //C)    A=REAL PART, C=IMAGINARY PART. A AND C ARE                        M29.1589
  //C)    STORED AS TRIANGLE (1 ELEMENT FOR 1.COLUMN,2 FOR 2.COLUMN ETC.).  M29.1590
  //C)    RESULT IS REDUCED MATRIX IN COLUMNS 1,...M IN CASE OF REDUCTION   M29.1591
  //C)    (M UNEQUAL 0) OR NEGATIVE INVERSE MATRIX IN COLUMNS 1,...N IN CASEM29.1592
  //C)    OF INVERSION (M=0).                                               M29.1593
  j = n + 1;
  w = 1.0f;
  if (m > 0) {
    w = -w;
  }
  ij = n * j / 2;
statement_3:
  j = j - 1;
  if (j == m) {
    return;
  }
  h1 = a(ij);
  g1 = c(ij);
  x = 1.0f / (h1 * h1 + g1 * g1);
  h1 = -h1 * x;
  g1 = g1 * x;
  b(j) = h1;
  d(j) = g1;
  ij = ij - j;
  k = 0;
  ik = 0;
  //C                                   BEGIN K-LOOP                        M29.1611
statement_4:
  ik += k;
  i1 = ik + 1;
  k++;
  if (k > n) {
    goto statement_3;
  }
  if (k < j) {
    goto statement_9;
  }
  if (w < 0.f) {
    goto statement_3;
  }
  if (k == j) {
    goto statement_7;
  }
  i = ik + j;
statement_5:
  h2 = a(i);
  g2 = c(i);
  b(k) = h2 * h1 - g2 * g1;
  d(k) = h2 * g1 + g2 * h1;
  //C                                   BEGIN I-LOOP                        M29.1624
  i2 = ik + k;
  L = 0;
  FEM_DO_SAFE(i, i1, i2) {
    L++;
    x = b(L);
    y = d(L);
    a(i) += x * h2 - y * g2;
    c(i) += x * g2 + y * h2;
  }
  if (k < j) {
    goto statement_4;
  }
  i = ik + j;
  a(i) = b(k);
  c(i) = d(k);
  goto statement_4;
  //C                                   END I-LOOP                          M29.1638
statement_7:
  i = ij;
  FEM_DO_SAFE(L, 1, j) {
    i++;
    c(i) = d(L);
    a(i) = b(L);
  }
  goto statement_4;
  //C                                   END K-LOOP                          M29.1645
statement_9:
  i = ij + k;
  goto statement_5;
}

// CONVERT TABLES TO NEW NODE NUMBERS. FIND STEADY-STATE       
// PHASOR EQUIVALENTS FOR DISTRIBUTED BRANCHES.                  
void over8(
  common& cmn)
{
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  double& delta2 = cmn.delta2;
  auto& twopi = cmn.twopi;
  double& tmax = cmn.tmax;
  double& omega = cmn.omega;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  double& fminfs = cmn.fminfs;
  double& delffs = cmn.delffs;
  double& fmaxfs = cmn.fmaxfs;
  auto& begmax = cmn.begmax;
  double& unity = cmn.unity;
  double& onehaf = cmn.onehaf;
  auto& flstat = cmn.flstat;
  //auto& moncar = cmn.moncar;
  auto& lunit2 = cmn.lunit2;
  auto& lunit9 = cmn.lunit9;
  auto& lstat = cmn.lstat;
  int& inonl = cmn.inonl;
  int& it2 = cmn.it2;
  int& istead = cmn.istead;
  int& ldata = cmn.ldata;
  int& lbrnch = cmn.lbrnch;
  int& nv = cmn.nv;
  int& numsm = cmn.numsm;
  int& iv = cmn.iv;
  auto& ktrlsw = cmn.ktrlsw;
  int& lastov = cmn.lastov;
  int& lhist = cmn.lhist;
  int& numum = cmn.numum;
  int& lsiz26 = cmn.lsiz26;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& kswtch = cmn.kswtch;
  int& it = cmn.it;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  const auto& loopss = cmn.loopss;
  auto& x = static_cast<common_c0b001&>(cmn).x;
  auto& xk = cmn.xk;
  auto& xm = cmn.xm;
  auto& cnvhst = cmn.cnvhst;
  auto& sfd = cmn.sfd;
  auto& qfd = cmn.qfd;
  auto& semaux = cmn.semaux;
  const auto& sconst = cmn.sconst;
  const auto& nonlad = cmn.nonlad;
  const auto& nonle = cmn.nonle;
  const auto& vnonl = cmn.vnonl;
  const auto& curr = cmn.curr;
  const auto& anonl = cmn.anonl;
  const auto& namenl = cmn.namenl;
  const auto& vzer5 = cmn.vzer5;
  const auto& ilast = cmn.ilast;
  const auto& nltype = cmn.nltype;
  const auto& xoptbr = cmn.xoptbr;
  const auto& coptbr = cmn.coptbr;
  const auto& cchar = cmn.cchar;
  const auto& vchar = cmn.vchar;
  const auto& gslope = cmn.gslope;
  auto& ktrans = cmn.ktrans;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& r = static_cast<common_c0b064&>(cmn).r;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  const auto& cik = cmn.cik;
  const auto& ci = cmn.ci;
  const auto& ck = cmn.ck;
  auto& ismdat = cmn.ismdat;
  auto& ibrnch = cmn.ibrnch;
  auto& jbrnch = cmn.jbrnch;
  auto& nonlk = cmn.nonlk;
  auto& nonlm = cmn.nonlm;
  auto& spum = cmn.spum;
  auto& imodel = cmn.imodel;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  auto& kodebr = cmn.kodebr;
  const auto& litype = cmn.litype;
  const auto& cki = cmn.cki;
  const auto& ckkjm = cmn.ckkjm;
  const auto& indhst = cmn.indhst;
  const auto& namebr = cmn.namebr;
  auto& kodsem = cmn.kodsem;
  const auto& iform = cmn.iform;
  auto& node = cmn.node;
  auto& time1 = cmn.time1;
  auto& sfreq = cmn.sfreq;
  auto& kmswit = cmn.kmswit;
  auto& tclose = cmn.tclose;
  auto& kssfrq = cmn.kssfrq;
  const auto& kode = cmn.kode;
  auto& kpsour = cmn.kpsour;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;
  auto& voltk = static_cast<common_c0b124&>(cmn).voltk;
  auto& volt = cmn.volt;
  auto& bus = cmn.bus;
  const auto& norder = cmn.norder;
  const auto& ich1 = cmn.ich1;
  auto& ich2 = cmn.ich2;
  int& kexact = cmn.kexact;
  int& nsolve = cmn.nsolve;
  double& fminsv = cmn.fminsv;
  int& numrun = cmn.numrun;
  //
  //int knt = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int isecti = fem::int0;
  int n7 = fem::int0;
  int n12 = fem::int0;
  int m7 = fem::int0;
  int m8 = fem::int0;
  int i = fem::int0;
  int k = fem::int0;
  int m = fem::int0;
  int L = fem::int0;
  int j = fem::int0;
  int nsave = fem::int0;
  int n3 = fem::int0;
  int ndx1 = fem::int0;
  int n6 = fem::int0;
  int j30 = fem::int0;
  int iji = fem::int0;
  int j31 = fem::int0;
  int ksma = fem::int0;
  int n20 = fem::int0;
  int n15 = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  int itadd = fem::int0;
  int iprint = fem::int0;
  int n1 = fem::int0;
  double omltem = fem::double0;
  double omctem = fem::double0;
  int n16 = fem::int0;
  double h3 = fem::double0;
  int im1 = fem::int0;
  double dum = fem::double0;
  double ycharm = fem::double0;
  double ychara = fem::double0;
  double alpha = fem::double0;
  double beta = fem::double0;
  double ypos = fem::double0;
  double yneg = fem::double0;
  double cosha = fem::double0;
  double sinha = fem::double0;
  double sinhgr = fem::double0;
  double sinhgi = fem::double0;
  double d9 = fem::double0;
  double cc1 = fem::double0;
  double cc2 = fem::double0;
  double d7 = fem::double0;
  int n9sq = fem::int0;
  int n2 = fem::int0;
  int n5 = fem::int0;
  int n4 = fem::int0;
  int ii = fem::int0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  double d8 = fem::double0;
  double d10 = fem::double0;
  double d13 = fem::double0;
  double d11 = fem::double0;
  double d12 = fem::double0;
  double d4 = fem::double0;
  double d3 = fem::double0;
  double dtemp = fem::double0;
  int npz = fem::int0;
  int npa = fem::int0;
  int n8 = fem::int0;
  int nhst = fem::int0;
  double gjl = fem::double0;
  int jgl = fem::int0;
  double dd1 = fem::double0;
  double dd2 = fem::double0;
  double dd3 = fem::double0;
  int jkl = fem::int0;
  double akr = fem::double0;
  double aki = fem::double0;
  double apr = fem::double0;
  double api = fem::double0;
  double dkr = fem::double0;
  double dki = fem::double0;
  double dqq3 = fem::double0;
  double ddd3 = fem::double0;
  double ddd4 = fem::double0;
  double dqq4 = fem::double0;
  double ccc3 = fem::double0;
  double ccc4 = fem::double0;
  double xr1 = fem::double0;
  double xi1 = fem::double0;
  double xr2 = fem::double0;
  double xi2 = fem::double0;
  double d = fem::double0;
  double br = fem::double0;
  double bi = fem::double0;
  int n11 = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  int koff1 = fem::int0;
  int koff2 = fem::int0;
  int koff3 = fem::int0;
  int koff4 = fem::int0;
  int koff5 = fem::int0;
  int koff6 = fem::int0;
  int koff7 = fem::int0;
  int koff8 = fem::int0;
  int koff9 = fem::int0;
  int koff10 = fem::int0;
  double csihre = fem::double0;
  double csihim = fem::double0;
  double ctahre = fem::double0;
  double ctahim = fem::double0;
  double gus1 = fem::double0;
  double gus2 = fem::double0;
  double gus3 = fem::double0;
  int n3tst = fem::int0;
  double gus4 = fem::double0;
  int ip = fem::int0;
  int nn3 = fem::int0;
  int jip = fem::int0;
  int iip = fem::int0;
  double h1 = fem::double0;
  double h2 = fem::double0;
  double hh3 = fem::double0;
  double h4 = fem::double0;
  int ll0 = fem::int0;
  int inoff2 = fem::int0;
  int inoff1 = fem::int0;
  int nq1 = fem::int0;
  int koff13 = fem::int0;
  int koff14 = fem::int0;
  int koff15 = fem::int0;
  int koff16 = fem::int0;
  int koff17 = fem::int0;
  int koff18 = fem::int0;
  int koff19 = fem::int0;
  int koff20 = fem::int0;
  int kqvv = fem::int0;
  int nphs2 = fem::int0;
  int kqv = fem::int0;
  int nteq = fem::int0;
  int lq = fem::int0;
  int nq2 = fem::int0;
  int nq3 = fem::int0;
  int ik = fem::int0;
  int nn1 = fem::int0;
  int nn2 = fem::int0;
  int iqy = fem::int0;
  int kqy = fem::int0;
  int km1 = fem::int0;
  double dyrk = fem::double0;
  double dyik = fem::double0;
  int ij = fem::int0;
  int jqy = fem::int0;
  int jk = fem::int0;
  double qrjk = fem::double0;
  double qijk = fem::double0;
  int ikq = fem::int0;
  double qrik = fem::double0;
  double qiik = fem::double0;
  int it0 = fem::int0;
  int n13 = fem::int0;
  int j0 = fem::int0;
  static const char* format_8002 = "(/,2x,i5,8(1x,e15.7),/(7x,8(1x,e15.7)))";
  static const char* format_8003 = "(7x,8(1x,e15.7))";
  static const char* format_8201 =
    "(' N1, N2, N3, SCONST(N2 ... N2+2), D1, D2 = ',3i10,/,5(1x,e15.8))";
  static const char* format_8311 =
    "('  N2, N3, SCONST(N2 ... N2+1), D5,','D6, D1, D2 = ',2i10,/,6(1x,e15.8))";
  //C %INCLUDE  '//c/tsu/cables.INS.FTN'                                    M43. 852
  //C 9-PHASE AS LIMIT FOR LMFS TEST
  //C
  auto& knt = cmn.moncar(1);
  if (iprsup >= 1) {
    write(lunit6,
      "(' TOP OF \"OVER8\".   LOOPSS(1)',' IV, IT, TMAX =',3i8,e15.5)"),
      loopss(1), iv, it, tmax;
  }
  isecti = 400;
  n7 = 1;
  if (tmax <= 0.0f && nchain > lastov) {
    goto statement_40014;
  }
  n7 = 2;
  cmn.io.rewind(lunit2);
  //w tapsav(cmn, x(1), lunit2, iv, n7);
  n12 = 0;
  vecrsv(cmn, volt(1), n12, n12);
  n12 = ktrlsw(7);
  vecrsv(cmn, c(1), n12, n7);
  vecrsv(cmn, tr(1), n12, n7);
  vecrsv(cmn, tx(1), n12, n7);
  vecrsv(cmn, r(1), n12, n7);
  n12 = ktrlsw(8);
  vecisv(cmn, nr(1), n12, n7);
  vecisv(cmn, length(1), n12, n7);
  if (numum == 0 || lastov < nchain) {
    goto statement_6123;
  }
  if (loopss(1) == 7766) {
    goto statement_6121;
  }
  vecisv(cmn, kssfrq(1), ntot, n7);
  vecisv(cmn, kpsour(1), ntot, n7);
  goto statement_6123;
statement_6121:
  m7 = 0;
  m8 = 8;
  vecrsv(cmn, volt(1), m8, m7);
statement_6123:
  if (ktrlsw(5) == 1 && lastov > nchain) {
    vecrsv(cmn, cnvhst(1), lhist, n7);
  }
  if (loopss(1) != 7766) {
    goto statement_3489;
  }
  //C     BACK FROM "OVER11" AFTER FINAL PHASOR SOLUTION, SO EXIT:          M32.3123
  lastov = nchain;
  nchain = 12;
  lstat(22) = ibr;
  goto statement_9600;
  //C     2ND OR LATER PASS SKIPS RENUMBERING OF 3RD PARTITION LABCOM:      M32.3127
statement_3489:
  if (lastov > nchain) {
    goto statement_40014;
  }
  if (inonl == 0) {
    goto statement_4141;
  }
  FEM_DO_SAFE(i, 1, inonl) {
    k = nonlk(i);
    m = nonlm(i);
    L = fem::iabs(k);
    nonlk(i) = norder(L);
    if (k < 0) {
      nonlk(i) = -nonlk(i);
    }
    L = fem::iabs(m);
    nonlm(i) = norder(L);
    if (m < 0) {
      nonlm(i) = -nonlm(i);
    }
  }
statement_4141:
  FEM_DO_SAFE(i, 1, ibr) {
    k = kbus(i);
    m = mbus(i);
    L = fem::iabs(k);
    kbus(i) = norder(L);
    if (k < 0) {
      kbus(i) = -kbus(i);
    }
    L = fem::iabs(m);
    mbus(i) = norder(L);
    if (m < 0) {
      mbus(i) = -mbus(i);
    }
  }
  FEM_DO_SAFE(i, 2, ntot) {
    ich2(i) = i;
  }
  FEM_DO_SAFE(i, 2, ntot) {
  statement_3442:
    L = ich2(i);
    j = norder(L);
    if (j == i) {
      goto statement_3456;
    }
    bus1 = bus(j);
    nsave = ktrans(j);
    n3 = ich2(j);
    bus(j) = bus(i);
    ktrans(j) = ktrans(i);
    ich2(j) = ich2(i);
    bus(i) = bus1;
    ktrans(i) = nsave;
    ich2(i) = n3;
    goto statement_3442;
  statement_3456:;
  }
  if (iprsup > 1) {
    write(lunit6,
      "(/,/,' FINAL RENUMBERING MAPS.  KPARTB=',i5,5x,'NTOT=',i3,/,9x,'I',4x,"
      "'BUS(I)',3x,'NORDER(I)',5x,'ICH1(I)',5x,'KODE(I)')"),
      cmn.kpartb, ntot;
  }
  if (iprsup > 1) {
    {
      write_loop wloop(cmn, lunit6, "(i10,4x,a6,3i12)");
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, i, bus(i), norder(i), ich1(i), kode(i);
      }
    }
  }
  if (kswtch < 1) {
    goto statement_40017;
  }
  FEM_DO_SAFE(i, 1, kswtch) {
    ndx1 = cmn.lswtch + i;
    k = kmswit(i);
    m = kmswit(ndx1);
    kmswit(i) = norder(k);
    kmswit(ndx1) = norder(m);
  }
statement_40017:
  if (kconst < 1) {
    goto statement_40011;
  }
  FEM_DO_SAFE(i, 1, kconst) {
    k = node(i);
    L = fem::iabs(k);
    node(i) = norder(L);
    if (k < 0) {
      node(i) = -node(i);
    }
    if (iform(i) != 18) {
      goto statement_40009;
    }
    n6 = time1(i);
    time1(i) = norder(n6);
  statement_40009:;
  }
statement_40011:
  if (nv == 0) {
    goto statement_40013;
  }
  FEM_DO_SAFE(i, 1, nv) {
    k = ibrnch(i);
    ibrnch(i) = norder(k);
    m = jbrnch(i);
    jbrnch(i) = norder(m);
  }
statement_40013:
  if (numsm == 0) {
    goto statement_40014;
  }
  //C  TRANSIENT RENUMBERING OF SYNCHRONOUS MACHINE NODES                   M16.1325
  j30 = 2;
  FEM_DO_SAFE(i, 1, numsm) {
    FEM_DO_SAFE(iji, 1, 3) {
      j31 = j30 + iji;
      ksma = ismdat(j31);
      ismdat(j31) = norder(ksma);
    }
    j30 += 30;
  }
statement_40014:
  if (numum == 0 || nchain < lastov) {
    goto statement_6666;
  }
  frqchk(cmn);
  n20 = 0;
  if (cmn.istart == 0 && loopss(10) == 0) {
    n20 = 1;
  }
  if (n20 == 1 && cmn.initum == 0) {
    n20 = 2;
  }
  if (numum > 0 && n20 == 1) {
    kill = 0;
  }
  if (kill > 0) {
    goto statement_9200;
  }
  m7 = 1;
  vecisv(cmn, kssfrq(1), ntot, m7);
  vecisv(cmn, kpsour(1), ntot, m7);
statement_6666:
  if (nchain > lastov) {
    goto statement_2236;
  }
  vecrsv(cmn, tclose(1), kswtch, n7);
  n12 = -1;
  if (ktrlsw(5) == 1) {
    n12 = -2;
  }
  n15 = 0;
  vecrsv(cmn, volt(1), n12, n15);
  //C     PRECEDING CALL TO "FRQCHK" SHOWS USER-DEFINED SOURCES             M31.1165
  //C     IDENTIFIED BY SUBNETWORK FOR USE IN FOLLOWING "UMRENU",           M31.1166
  //C     FOR CASES HAVING ONE OR MORE U.M. (NUMUM .GT. 0).                 M31.1167
statement_2236:
  if (numum > 0) {
    //w 
    //umrenu(cmn, spum(cmn.iureac), spum(cmn.iugpar), spum(cmn.iufpar),
    //  spum(cmn.iuhist), spum(cmn.iuumrp), spum(cmn.iunod1), spum(cmn.iunod2),
    //  spum(cmn.iujclt), spum(cmn.iujclo), spum(cmn.iujtyp), spum(cmn.iunodo),
    //  spum(cmn.iujtmt), spum(cmn.iuhism), spum(cmn.iuomgm), spum(cmn.iuomld),
    //  spum(cmn.iutham), spum(cmn.iuredu), spum(cmn.iureds), spum(cmn.iuflds),
    //  spum(cmn.iufldr), spum(cmn.iurequ), spum(cmn.iuflqs), spum(cmn.iuflqr),
    //  spum(cmn.iujcds), spum(cmn.iujcqs), spum(cmn.iuflxd), spum(cmn.iuflxq),
    //  spum(cmn.iunppa), spum(cmn.iurotm), spum(cmn.iuncld), spum(cmn.iunclq),
    //  spum(cmn.iujtqo), spum(cmn.iujomo), spum(cmn.iujtho), spum(cmn.iureqs),
    //  spum(cmn.iuepso), spum(cmn.iudcoe), spum(cmn.iukcoi), spum(cmn.iuvolt),
    //  spum(cmn.iuangl), spum(cmn.iunodf), spum(cmn.iunodm), spum(cmn.iukumo),
    //  spum(cmn.iujumo), spum(cmn.iuumou));
  }
  if (kill > 0) {
    goto statement_9200;
  }
  if (istead == 0) {
    goto statement_9500;
  }
  if (fmaxfs == 0.0f) {
    goto statement_1413;
  }
  if (knt == 1) {
    goto statement_3224;
  }
  ibr = cmn.it1;
  if (fminfs <= fmaxfs) {
    goto statement_3234;
  }
  if (kexact != 88333) {
    goto statement_2240;
  }
  nsolve++;
  if (nsolve > 1) {
    goto statement_2238;
  }
  fminfs = fminsv;
  //C KBRNUM is replaced by '1', 2/21/90, THL.
  kodsem(1) = 0;
  imodel(1) = 0;
  kbus(1) = -2;
  kodebr(1) = 0;
  length(1) = cmn.nphlmt;
  knt = 1;
  lastov = 8;
  nchain = 44;
  goto statement_9600;
statement_2238:
  if (numrun == 3) {
    goto statement_2240;
  }
  if (numrun == 2 && length(1) <= 3) {
    goto statement_2240;
  }
  nsolve = 0;
  cmn.llbuff = -3333;
  cmn.io.rewind(5);
  //C  go to datain to regenerate data input for LMFS t
  datain(cmn);
  lastov = nchain;
  //C program generated 2nd & 3rd LMFS data
  nchain = 1;
  goto statement_9600;
statement_2240:
  begmax(1) = 0.0f;
  lastov = nchain;
  nchain = 20;
  runtym(d1, d2);
  flstat(3) += d1;
  flstat(4) += d2;
  flstat(7) = flstat(7) - d1;
  flstat(8) = flstat(8) - d2;
  tmax = fminfs;
  goto statement_9600;
statement_3234:
  if (delffs < 0.0f) {
    goto statement_3218;
  }
  fminfs += delffs;
  goto statement_3224;
statement_3218:
  fminfs = fminfs * (-delffs);
statement_3224:
  FEM_DO_SAFE(j, 1, kconst) {
    if (iform(j) == 18) {
      goto statement_3225;
    }
    sfreq(j) = fminfs;
  statement_3225:;
  }
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' BEGIN NEXT FREQ.     KNT  LTLABL',9x,'FMINFS',9x,'FMAXFS',/,17x,"
      "2i8,2e15.6)"),
      knt, cmn.ltlabl, fminfs, fmaxfs;
  }
statement_1413:
  if (iprsup >= 1) {
    write(lunit6,
      "(1x,'  KCONST     IBR   INONL  KSWTCH  ISTEAD',11x,'XOPT',11x,'COPT',"
      "10x,'TWOPI',/,1x,5i8,3e15.6)"),
      kconst, ibr, inonl, kswtch, istead, xopt, copt, twopi;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, "(' X/COPTBR =',10f12.2)");
      FEM_DO_SAFE(j, 1, ibr) {
        wloop, xoptbr(j), coptbr(j);
      }
    }
  }
  //C     BEFORE STARTING STEADY-STATE SOLUTION FOR INITIAL CONDITIONS, WE  M42.4895
  //C     MUST FIND PI-EQUIVALENTS FOR DISTRIBUTED BRANCHES.                M42.4896
  itadd = it + 1;
  //C     NEXT MAKE SURE OF FREQUENCY SEPARATION WITHIN SUBNETWORKS         M31.1190
  //C     FOR PHASOR SOLUTION BY CALL TO "FRQCHK" :                         M31.1191
  frqchk(cmn);
  if (kill > 0) {
    goto statement_9200;
  }
  iprint = 3;
  k = 1;
  //C     ENTER TOP OF LOOP OVER BRANCHES (INDEX "K") FOR PI-EQUIV:         M31.1195
statement_401:
  n1 = length(k);
  it2 = fem::iabs(n1);
  n15 = fem::iabs(kbus(k));
  if (n15 == 1) {
    n15 = fem::iabs(mbus(k));
  }
  xopt = xoptbr(k);
  copt = coptbr(k);
  omltem = 1000.f / twopi;
  omctem = 1000.f * omltem;
  if (xopt > 0.0f) {
    omltem = xopt * cmn.tenm3 * twopi * omltem;
  }
  if (copt > 0.0f) {
    omctem = copt * twopi * omctem;
  }
  n16 = fem::iabs(kssfrq(n15));
  d2 = omltem / sfreq(n16);
  h3 = omctem / sfreq(n16);
  omega = twopi * sfreq(n16);
  if (kbus(k) > 0) {
    goto statement_411;
  }
  im1 = imodel(k);
  if (nsolve < 1) {
    goto statement_40002;
  }
  if (k != 1) {
    goto statement_40002;
  }
  if (kexact == 88333 && fminfs == fminsv && nsolve == 1) {
    cmn.io.rewind(lunit9);
  }
  FEM_DO_SAFE(i, 1, it2) {
    read(lunit9, fem::unformatted), dum, ycharm, ychara, alpha, beta;
    if (iprsup >= 1) {
      write(lunit6, star), "F,YCHARM,YCHARA,ALPHA,BETA=", dum,
        ycharm, ychara, alpha, beta;
    }
    ypos = expz(alpha);
    yneg = 1.0f / ypos;
    cosha = 0.5f * (ypos + yneg);
    sinha = cosha - yneg;
    sinhgr = sinha * cosz(beta);
    sinhgi = cosha * sinz(beta);
    d9 = 1.0f / ycharm;
    volti(i) = d9 * (cosz(ychara) * sinhgr + sinz(ychara) * sinhgi);
    voltk(i) = d9 * (-sinz(ychara) * sinhgr + cosz(ychara) * sinhgi);
    cc1 = cosha * cosz(beta) - 1.f;
    cc2 = sinha * sinz(beta);
    d7 = fem::pow2(volti(i)) + fem::pow2(voltk(i));
    volt(i) = (volti(i) * cc1 + voltk(i) * cc2) / d7;
    volt(i + lsiz26) = (volti(i) * cc2 - voltk(i) * cc1) / d7;
    if (iprsup >= 1) {
      write(lunit6, star), " For mode ", i,
        " Pi-equiv. Zseres, 1/2 Yshunt=", volti(i), voltk(i), volt(i),
        volt(i + lsiz26);
    }
  }
  n9sq = it2 * it2;
  {
    read_loop rloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(i, 1, n9sq) {
      rloop, qfd(i);
    }
    FEM_DO_SAFE(i, 1, n9sq) {
      rloop, sfd(i);
    }
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, star);
      wloop, " QFD AND SFD READ FROM LUNIT9.";
      FEM_DO_SAFE(i, 1, n9sq) {
        wloop, qfd(i);
      }
      FEM_DO_SAFE(i, 1, n9sq) {
        wloop, sfd(i);
      }
    }
  }
  n2 = 1;
  goto statement_460;
statement_40002:
  length(k) = it2;
  if (iprsup >= 1) {
    write(lunit6, star),
      " over8.  k, imodel(k), it2, omega, h3, d2 =", k, imodel(k),
      it2, omega, h3, d2;
  }
  //C      IF ( KEXACT .EQ. 88333  .AND. NSOLVE .EQ. 0)  KBRNUM = K
  if (kodsem(k) == 0 || im1 == -2) {
    goto statement_5136;
  }
  if (im1 == -4) {
    goto statement_1536;
  }
  it2 = fem::iabs(kodebr(k));
  //C  Formation of phase symmetric PI matrices for components reperesented M23.1293
  //C  by recursive convolution.  For lumped elements the steady-state modalM23.1294
  //C  values of the symmetric PI are stored in SCONST(J+0 ... J+3).  for   M23.1295
  //C  transmiddion lines, SCONST(J+0 ... J+3) holds the modal series Z and M23.1296
  //C  shunt Y.  (not per unit length)                                      M23.1297
  //C                                                                       M23.1298
  //C     (ZPI) = (S)*(DIAG(...SQRT(Z/Y)*SINH(SQRT(Z*Y))...))*(Q)**(-1)     M23.1299
  //C                                                                       M23.1300
  //C     (YPI) = (Q)*(DIAG(...SQRT(Y/Z)*TANH(SQRT(Z*Y)/2)...))*(S)**(-1)   M23.1301
  //C                                                                       M23.1302
  //C  S(Q) is the mode to phase voltage(current) transformation matrix.    M23.1303
  //C  Note.  Transpose(S) = Q**(-1)                                        M23.1304
  if (iprsup < 6) {
    goto statement_8009;
  }
  n1 = std::abs(cik(k)) - 1.0f;
  n5 = it2 * it2;
  n3 = n1 + n5;
  n4 = n3 + n5;
  write(lunit6, "(/,/,5x,'SFD(',f4.0,') ...',/)"), cik(k);
  FEM_DO_SAFE(i, 1, it2) {
    n2 = i + n1;
    {
      write_loop wloop(cmn, lunit6, format_8002);
      wloop, i;
      FEM_DOSTEP(j, n2, n3, it2) {
        wloop, sfd(j);
      }
    }
    n2 = i + n3;
    {
      write_loop wloop(cmn, lunit6, format_8003);
      FEM_DOSTEP(j, n2, n4, it2) {
        wloop, sfd(j);
      }
    }
  }
  write(lunit6, "(/,/,/,5x,'QFD(',f4.0,') ...',/)"), cik(k);
  FEM_DO_SAFE(i, 1, it2) {
    n2 = i + n1;
    {
      write_loop wloop(cmn, lunit6, format_8002);
      wloop, i;
      FEM_DOSTEP(j, n2, n3, it2) {
        wloop, qfd(j);
      }
    }
    n2 = i + n3;
    {
      write_loop wloop(cmn, lunit6, format_8003);
      FEM_DOSTEP(j, n2, n4, it2) {
        wloop, qfd(j);
      }
    }
  }
statement_8009:
  FEM_DO_SAFE(i, 1, it2) {
    ii = i + k - 1;
    length(ii) = it2;
    n1 = indhst(ii);
    if (ci(ii) > 0.0f) {
      n1++;
    }
    if (cnvhst(n1 + 4) > 0.0f) {
      goto statement_8700;
    }
    n2 = fem::iabs(kodsem(ii)) + 1;
    n3 = ci(ii);
    d1 = 0.0f;
    d2 = 0.0f;
    switch (fem::if_arithmetic(n3)) {
    case -1: goto statement_8300;
    case  0: goto statement_8400;
    default: goto statement_8200;
    }
  statement_8200:
    if (iprsup >= 9) {
      write(lunit6, format_8201), n1, n2, n3, sconst(n2), sconst(n2 + 1),
        sconst(n2 + 2), d1, d2;
    }
    if (n3 <= 0) {
      goto statement_8250;
    }
    switch (fem::if_arithmetic(sconst(n2))) {
    case -1: goto statement_8210;
    case  0: goto statement_8220;
    default: goto statement_8230;
    }
  statement_8210:
    d5 = sconst(n2 - 3);
    d6 = -sconst(n2 + 1);
    d7 = sconst(n2 - 2);
    d8 = -sconst(n2 + 2);
    goto statement_8240;
  statement_8220:
    d5 = sconst(n2 + 1);
    d6 = 0.0f;
    d7 = sconst(n2 + 2);
    d8 = 0.0f;
    goto statement_8240;
  statement_8230:
    d5 = sconst(n2 + 1);
    d6 = sconst(n2 - 3);
    d7 = sconst(n2 + 2);
    d8 = sconst(n2 - 2);
  statement_8240:
    n3 = n3 - 1;
    n2 += 5;
    d9 = d5 * d7 - d6 * d8;
    d8 = d5 * d8 + d6 * d7;
    d7 = d9;
    d6 += omega;
    d9 = expz(-d5 * cnvhst(n1 - 1));
    d10 = -d9 * sinz(d6 * cnvhst(n1 - 1));
    d9 = d9 * cosz(d6 * cnvhst(n1 - 1));
    d13 = d5 * d5 + d6 * d6;
    d11 = (d9 * d5 + d10 * d6) / d13;
    d12 = (-d9 * d6 + d10 * d5) / d13;
    d1 += d7 * d11 - d8 * d12;
    d2 += d7 * d12 + d8 * d11;
    goto statement_8200;
  statement_8250:
    d4 = d1 * d1 + d2 * d2;
    d3 = d1 / d4;
    d4 = -d2 / d4;
    goto statement_8400;
  statement_8300:
    d5 = 0.0f;
  statement_8310:
    if (iprsup >= 9) {
      write(lunit6, format_8311), n2, n3, sconst(n2), sconst(n2 + 1),
        d5, d6, d1, d2;
    }
    if (n3 >= 0) {
      goto statement_8320;
    }
    n3++;
    d6 = -omega * sconst(n2);
    d5 = sconst(n2 + 1) - d5;
    d1 += d5 * cosz(d6);
    d2 += d5 * sinz(d6);
    d5 = sconst(n2 + 1);
    n2 += 2;
    goto statement_8310;
  statement_8320:
    d6 = -omega * tmax;
    d1 = (d1 - d5 * cosz(d6)) / omega;
    d2 = -(d2 - d5 * sinz(d6)) / omega;
    d4 = d1 * d1 + d2 * d2;
    d3 = d2 / d4;
    d4 = -d1 / d4;
  statement_8400:
    n3 = ck(ii);
    d1 = 0.0f;
    d2 = 0.0f;
    switch (fem::if_arithmetic(n3)) {
    case -1: goto statement_8500;
    case  0: goto statement_8700;
    default: goto statement_8420;
    }
  statement_8420:
    if (iprsup >= 9) {
      write(lunit6, format_8201), n1, n2, n3, sconst(n2), sconst(n2 + 1),
        sconst(n2 + 2), d1, d2;
    }
    if (n3 <= 0) {
      goto statement_8470;
    }
    switch (fem::if_arithmetic(sconst(n2))) {
    case -1: goto statement_8430;
    case  0: goto statement_8440;
    default: goto statement_8450;
    }
  statement_8430:
    d5 = sconst(n2 - 2);
    d6 = -sconst(n2 + 1);
    d7 = sconst(n2 - 1);
    d8 = -sconst(n2 + 2);
    goto statement_8460;
  statement_8440:
    d5 = sconst(n2 + 1);
    d6 = 0.0f;
    d7 = sconst(n2 + 2);
    d8 = 0.0f;
    goto statement_8460;
  statement_8450:
    d5 = sconst(n2 + 1);
    d6 = sconst(n2 + 5);
    d7 = sconst(n2 + 2);
    d8 = sconst(n2 + 6);
  statement_8460:
    n3 = n3 - 1;
    n2 += 4;
    d11 = d5 * d7 - d6 * d8;
    d12 = d5 * d8 + d6 * d7;
    d6 += omega;
    d9 = d5 * d5 + d6 * d6;
    d1 += (d11 * d5 + d12 * d6) / d9;
    d2 += (-d11 * d6 + d12 * d5) / d9;
    goto statement_8420;
  statement_8470:
    n3 = fem::iabs(kodsem(ii));
    d1 += sconst(n3);
    d10 = d1 * d1 + d2 * d2;
    d9 = d1 / d10;
    d10 = -d2 / d10;
    goto statement_8600;
  statement_8500:
    d5 = 0.0f;
    if (iprsup >= 9) {
      write(lunit6, format_8311), n2, n3, sconst(n2), sconst(n2 + 1),
        d5, d6, d1, d2;
    }
    if (n3 >= 0) {
      goto statement_8320;
    }
    n3++;
    d6 = -omega * sconst(n2);
    d5 = sconst(n2 + 1) - d5;
    d1 += d5 * cosz(d6);
    d2 += d5 * sinz(d6);
    d5 = sconst(n2 + 1);
    n2 += 2;
    goto statement_8520;
  statement_8520:
    d5 = -omega * tmax;
    n3 = fem::iabs(kodsem(ii));
    d1 = (d1 - d5 * cosz(d6)) / omega;
    d2 = sconst(n3) - (d2 - d5 * sinz(d6)) / omega;
    d10 = d1 * d1 + d2 * d2;
    d9 = d2 / d10;
    d10 = -d1 / d10;
  statement_8600:
    cnvhst(n1 + 0) = d9 * d9 - d10 * d10;
    cnvhst(n1 + 1) = 2.0f * d9 * d10;
    cnvhst(n1 + 2) = unity;
    cnvhst(n1 + 3) = 0.0f;
    cnvhst(n1 + 4) = omega;
    goto statement_8070;
  statement_8700:
    if (std::abs(cnvhst(n1 + 4) - omega) < 0.0001f) {
      goto statement_8020;
    }
    n2 = -kbus(ii);
    n3 = fem::iabs(mbus(ii));
    write(lunit6,
      "(/,/,"
      "' WARNING...  STEADY STATE MODAL PARAMETERS FOR RECURSIVE-CONVOLUTION C"
      "OMPONENT CONNECTING NODES ''',a6,''' AND ''',a6,'''',/,13x,'FOR MODE ',"
      "i2,' ARE DETERMINED AT ANGULAR FREQUENCY OF ',e12.5,"
      "' RADIANS/SEC.  THE STEADY-STATE SOLUTION FREQUENCY ',/,13x,"
      "'BEING USED IS ',e12.5,' RADIANS/SEC. ')"),
      bus(n2), bus(n3), i, cnvhst(n1 + 4), omega;
  statement_8020:
    if (kodsem(k) > 0) {
      goto statement_8030;
    }
    volt(i) = cnvhst(n1 + 0);
    volti(i) = cnvhst(n1 + 1) * d2;
    voltk(i) = cnvhst(n1 + 2);
    ndx1 = lsiz26 + i;
    volt(ndx1) = cnvhst(n1 + 3) * h3;
    goto statement_8080;
  statement_8030:
    d3 = cnvhst(n1 + 0) * cnvhst(n1 + 2) - cnvhst(n1 + 1) * cnvhst(n1 + 3);
    d4 = cnvhst(n1 + 0) * cnvhst(n1 + 3) + cnvhst(n1 + 1) * cnvhst(n1 + 2);
    d5 = sqrtz(d3 * d3 + d4 * d4);
    if (d3 < 0.0f) {
      goto statement_8040;
    }
    d5 = sqrtz((d3 + d5) * onehaf);
    d6 = onehaf * d4 / d5;
    goto statement_8050;
  statement_8040:
    d6 = sqrtz((-d3 + d5) * onehaf);
    if (d4 >= 0.0f) {
      goto statement_18050;
    }
    dtemp = -d6;
    d5 = onehaf * d4 / dtemp;
    goto statement_8050;
  statement_18050:
    d5 = onehaf * d4 / d6;
  statement_8050:
    d4 = expz(d5);
    d3 = d4 * cosz(d6);
    d4 = d4 * sinz(d6);
    d8 = fem::pow2(cnvhst(n1 + 2)) + fem::pow2(cnvhst(n1 + 3));
    d7 = (cnvhst(n1 + 0) * cnvhst(n1 + 2) + cnvhst(n1 + 1) * cnvhst(
      n1 + 3)) / d8;
    d8 = (-cnvhst(n1 + 0) * cnvhst(n1 + 3) + cnvhst(n1 + 1) * cnvhst(
      n1 + 2)) / d8;
    d9 = sqrtz(d7 * d7 + d8 * d8);
    if (d7 < 0.0f) {
      goto statement_8060;
    }
    d9 = sqrtz((d7 + d9) * onehaf);
    d10 = onehaf * d8 / d9;
    goto statement_8070;
  statement_8060:
    d10 = sqrtz((-d7 + d9) * onehaf);
    if (d8 < 0.0f) {
      d10 = -d10;
    }
    d9 = onehaf * d8 / d10;
  statement_8070:
    d11 = d3 * d3 + d4 * d4;
    d5 = onehaf * (d3 - d3 / d11);
    d6 = onehaf * (d4 + d4 / d11);
    volt(i) = d9 * d5 - d10 * d6;
    volti(i) = d9 * d6 + d10 * d5;
    d3 = onehaf * (d3 + d3 / d11) - unity;
    d4 = onehaf * (d4 - d4 / d11);
    d11 = fem::pow2(volt(i)) + fem::pow2(volti(i));
    voltk(i) = (volt(i) * d3 + volti(i) * d4) / d11;
    ndx1 = lsiz26 + i;
    volt(ndx1) = (volt(i) * d4 - volti(i) * d3) / d11;
  statement_8080:
    if (iprsup <= 6) {
      goto statement_8090;
    }
    n2 = -kbus(ii);
    n3 = fem::iabs(mbus(ii));
    write(lunit6,
      "(/,5x,a6,' TO ',a6,5x,'BR. INDEX = ',i3,5x,'N1 = ',i3,/,1x,"
      "'CNVHST(N1) ... CNVHST(N1+4) =',5(1x,e15.7),/,1x,"
      "'D3, D4, D5, D6, D7, D8 = ',6(1x,e15.7),/,1x,"
      "'D9, D10, VOLT, VOLTI, VOLTK, VIM =',6(1x,e15.7))"),
      bus(n2), bus(n3), ii, n1, cnvhst(n1 + 0), cnvhst(n1 + 1),
      cnvhst(n1 + 2), cnvhst(n1 + 3), cnvhst(n1 + 4), d3, d4, d5, d6,
      d7, d8, d9, d10, volt(i), volti(i), voltk(i), volt(ndx1);
  statement_8090:;
  }
  n1 = std::abs(cik(k)) - 1.0f;
  n2 = n1 + it2 * it2;
  n6 = 4 * it2;
  FEM_DO_SAFE(i, 1, it2) {
    n3 = n1 + i;
    n4 = n2 + i;
    n5 = 1;
    ndx1 = lsiz26;
    FEM_DO_SAFE(j, 1, it2) {
      semaux(n5 + 0) = volt(j) * sfd(n3) - volti(j) * sfd(n4);
      semaux(n5 + 1) = volt(j) * sfd(n4) + volti(j) * sfd(n3);
      ndx1++;
      semaux(n5 + 2) = voltk(j) * qfd(n3) - volt(ndx1) * qfd(n4);
      semaux(n5 + 3) = voltk(j) * qfd(n4) + volt(ndx1) * qfd(n3);
      n3 += it2;
      n4 += it2;
      n5 += 4;
    }
    ii = i + k - 1;
    nr(ii) = itadd;
    FEM_DO_SAFE(j, 1, i) {
      d3 = 0.0f;
      d4 = 0.0f;
      d5 = 0.0f;
      d6 = 0.0f;
      n3 = n1 + j;
      n4 = n2 + j;
      FEM_DOSTEP(L, 1, n6, 4) {
        d3 += semaux(L + 0) * sfd(n3) - semaux(L + 1) * sfd(n4);
        d4 += semaux(L + 0) * sfd(n4) + semaux(L + 1) * sfd(n3);
        d5 += semaux(L + 2) * qfd(n3) - semaux(L + 3) * qfd(n4);
        d6 += semaux(L + 2) * qfd(n4) + semaux(L + 3) * qfd(n3);
        n3 += it2;
        n4 += it2;
      }
      if (itadd > ldata) {
        goto statement_9000;
      }
      tr(itadd) = d3;
      tx(itadd) = d4 * d2;
      r(itadd) = d5;
      c(itadd) = d6 * h3;
      itadd++;
    }
    if (iprsup < 6) {
      goto statement_8130;
    }
    n3 = itadd - 1;
    n4 = nr(ii);
    {
      write_loop wloop(cmn, lunit6,
        "(/,/,5x,'N4 = ',i4,5x,'NR(II) = ',i4,5x,'II = ',i4,5x,"
        "'(TR(J), TX(J), R(J), C(J), J=N3, N4)  ....  ',/(8(1x,e15.8)))");
      wloop, n4, nr(ii), ii;
      FEM_DO_SAFE(j, n4, n3) {
        wloop, tr(j), tx(j), r(j), c(j);
      }
    }
  statement_8130:;
  }
  it2 = 1;
statement_8140:
  if (cki(k) < 0.0f) {
    goto statement_407;
  }
  k++;
  goto statement_8140;
statement_1536:
  n1 = it2;
  n2 = litype(k);
  //C      IF ( KEXACT .EQ. 88333  .AND. NSOLVE .EQ. 0)  KBRNUM = K
  if (im1 != -4) {
    goto statement_5137;
  }
  //C      KTRLSW(5) = 1                                                    M43. 873
  if (iprsup >= 1) {
    write(lunit6,
      "(' THE FOLLOWING LINES ARE FREQUENCY DEPENDENT',' PARAMETERS AT ',"
      "f10.3,' RADIANS/SEC.',/,' BUS1',7x,'BUS2',14x,'SURGE IMPEDANCE',20x,"
      "' PROPAGATION FUNCTION',12x,'TRAVEL TIME')"),
      omega;
  }
  FEM_DO_SAFE(i, 1, it2) {
    j = i + k - 1;
    npz = cki(j);
    npa = ckkjm(j);
    n3 = kodsem(j);
    n8 = indhst(j);
    nhst = n8 + 15;
    //C      IF ( CNVHST(NHST) .GT. 0.) GO TO 2015                            M44. 233
    cnvhst(n8 + 1) = sconst(n3);
    cnvhst(n8 + 2) = 0.0f;
    gjl = 56789.0f;
    jgl = 0;
    if (iprsup >= 1) {
      write(6,
        "('NPZ   II   N4    SCONST(N4)    SCONST(N5)',"
        "'  CNVHST(N8+1)  CNVHST(N8+2)')");
    }
    FEM_DO_SAFE(ii, 1, npz) {
      n4 = n3 + ii;
      if (imodel(j) == -4) {
        goto statement_8015;
      }
      if (std::abs(sconst(n4)) < 0.1e17f) {
        goto statement_8015;
      }
      jgl++;
      if (jgl < 2) {
        gjl = 56789.0f;
      }
      if (jgl >= 2) {
        gjl = 98765.0f;
      }
      if (jgl == 2) {
        jgl = 0;
      }
      if (std::abs(sconst(n4)) >= 0.1e15f && gjl == 98765.0f) {
        goto statement_30001;
      }
      d1 = sconst(n4);
      dd1 = sconst(n4 + 1);
      n5 = npz + n4;
      dd2 = sconst(n5);
      dd3 = sconst(n5 + 1);
      dd3 += omega;
      d3 = fem::pow2(dd2) + fem::pow2(dd3);
      d1 = d1 * dd2 + dd1 * dd3;
      cnvhst(n8 + 1) += d1 * 2 / d3;
      goto statement_30001;
    statement_8015:
      d1 = sconst(n4);
      n5 = npz + n4;
      dd2 = sconst(n5);
      d3 = fem::pow2(dd2) + fem::pow2(omega);
      cnvhst(n8 + 1) += d1 * dd2 / d3;
      cnvhst(n8 + 2) = cnvhst(n8 + 2) - omega * d1 / d3;
      if (iprsup >= 1) {
        write(6, "(1x,i2,2x,i3,2x,i6,2x,4e26.9)"), npz, ii, n4,
          sconst(n4), sconst(n5), cnvhst(n8 + 1), cnvhst(n8 + 2);
      }
    statement_30001:;
    }
    cnvhst(n8 + 3) = 0.0f;
    cnvhst(n8 + 4) = 0.0f;
    jkl = 0;
    if (iprsup >= 1) {
      write(6,
        "('NPA   II   N6    SCONST(N6)    SCONST(N7)',"
        "'  CNVHST(N8+3)  CNVHST(N8+4)')");
    }
    FEM_DO_SAFE(ii, 1, npa) {
      n6 = n5 + ii;
      n7 = n6 + npa;
      if (std::abs(sconst(n6)) >= 1.e+13f) {
        goto statement_1989;
      }
      d1 = sconst(n6);
      dd2 = sconst(n7);
      d3 = fem::pow2(dd2) + fem::pow2(omega);
      cnvhst(n8 + 3) += d1 * dd2 / d3;
      cnvhst(n8 + 4) = cnvhst(n8 + 4) - omega * d1 / d3;
      goto statement_1993;
    statement_1989:
      jkl++;
      if (jkl == 2) {
        goto statement_5486;
      }
      akr = sconst(n6) / 1.e+15f;
      aki = sconst(n6 + 1) / 1.e+15f;
      apr = sconst(n7) / 1.e+15f;
      api = sconst(n7 + 1) / 1.e+15f;
      dkr = apr * akr - api * aki;
      dki = apr * aki + api * akr;
      akr = dkr;
      aki = dki;
      dqq3 = fem::pow2(apr) + fem::pow2((omega + api));
      ddd3 = (akr * apr + aki * (omega + api)) / dqq3;
      ddd4 = (aki * apr - akr * (omega + api)) / dqq3;
      dqq4 = fem::pow2(apr) + fem::pow2((omega - api));
      ccc3 = (akr * apr - aki * (omega - api)) / dqq4;
      ccc4 = (akr * (omega - api) + aki * apr) / dqq4;
      cnvhst(n8 + 3) += ddd3 + ccc3;
      cnvhst(n8 + 4) += ddd4 - ccc4;
      //C      CNVHST(N8+3) = CNVHST(N8+3) + DDD3                               M44. 288
      //C      CNVHST(N8+4) = CNVHST(N8+4) + DDD4                               M44. 289
      if (jkl == 1) {
        goto statement_1993;
      }
    statement_5486:
      jkl = 0;
    statement_1993:
      if (iprsup >= 1) {
        write(6, "(1x,i2,2x,i3,2x,i6,2x,6e19.9)"), npa, ii, n6,
          sconst(n6), sconst(n6 + 1), sconst(n7), sconst(n7 + 1),
          cnvhst(n8 + 3), cnvhst(n8 + 4);
      }
    }
    goto statement_2022;
    nhst = indhst(k);
    n1 = nhst + 15;
    d3 = cnvhst(n1 + 0) * cnvhst(n1 + 2) - cnvhst(n1 + 1) * cnvhst(n1 + 3);
    d4 = cnvhst(n1 + 0) * cnvhst(n1 + 3) + cnvhst(n1 + 1) * cnvhst(n1 + 2);
    d5 = sqrtz(d3 * d3 + d4 * d4);
    if (d3 < 0.0f) {
      goto statement_2017;
    }
    d5 = sqrtz((d3 + d5) * onehaf);
    d6 = onehaf * d4 / d5;
    goto statement_2018;
  statement_2017:
    d6 = sqrtz((-d3 + d5) * onehaf);
    if (d4 >= 0.0f) {
      goto statement_2019;
    }
    dtemp = -d6;
    d5 = onehaf * d4 / dtemp;
    //w goto statement_8050;
  statement_2019:
    d5 = onehaf * d4 / d6;
  statement_2018:
    d4 = expz(d5);
    d5 = onehaf * d4 / d6;
    d4 = expz(d5);
    d3 = d4 * cosz(d6);
    d4 = d4 * sinz(d6);
    d8 = fem::pow2(cnvhst(n1 + 2)) + fem::pow2(cnvhst(n1 + 3));
    d7 = (cnvhst(n1 + 0) * cnvhst(n1 + 2) + cnvhst(n1 + 1) * cnvhst(
      n1 + 3)) / d8;
    d8 = (-cnvhst(n1 + 0) * cnvhst(n1 + 3) + cnvhst(n1 + 1) * cnvhst(
      n1 + 2)) / d8;
    d9 = sqrtz(d7 * d7 + d8 * d8);
    if (d7 < 0.0f) {
      goto statement_2020;
    }
    d9 = sqrtz((d7 + d9) * onehaf);
    d10 = onehaf * d8 / d9;
    goto statement_2021;
  statement_2020:
    d10 = sqrtz((-d7 + d9) * onehaf);
    if (d8 < 0.0f) {
      d10 = -d10;
    }
    d9 = onehaf * d8 / d10;
  statement_2021:
    d11 = d3 * d3 + d4 * d4;
    d5 = onehaf * (d3 - d3 / d11);
    d6 = onehaf * (d4 + d4 / d11);
    volt(i) = d9 * d5 - d10 * d6;
    volti(i) = d9 * d6 + d10 * d5;
    d3 = onehaf * (d3 + d3 / d11) - unity;
    d4 = onehaf * (d4 - d4 / d11);
    d11 = fem::pow2(volt(i)) + fem::pow2(volti(i));
    voltk(i) = (volt(i) * d3 + volti(i) * d4) / d11;
    ndx1 = lsiz26 + i;
    volt(ndx1) = (volt(i) * d4 - volti(i) * d3) / d11;
    if (iprsup <= 6) {
      goto statement_2022;
    }
    n2 = -kbus(ii);
    n3 = fem::iabs(mbus(ii));
    write(lunit6,
      "(/,5x,a6,' TO ',a6,5x,'BR. INDEX = ',i3,5x,'N1 = ',i3,/,1x,"
      "'CNVHST(N1) ... CNVHST(N1+4) =',5(1x,e15.7),/,1x,"
      "'D3, D4, D5, D6, D7, D8 = ',6(1x,e15.7),/,1x,"
      "'D9, D10, VOLT, VOLTI, VOLTK, VIM =',6(1x,e15.7))"),
      bus(n2), bus(n3), ii, n1, cnvhst(n1 + 0), cnvhst(n1 + 1),
      cnvhst(n1 + 2), cnvhst(n1 + 3), cnvhst(n1 + 4), d3, d4, d5, d6,
      d7, d8, d9, d10, volt(i), volti(i), voltk(i), volt(ndx1);
  statement_2022:
    d4 = cnvhst(n8);
    d9 = omega * d4;
    d1 = std::cos(d9);
    dd2 = -std::sin(d9);
    d3 = cnvhst(n8 + 3) * d1 - cnvhst(n8 + 4) * dd2;
    d5 = cnvhst(n8 + 4) * d1 + cnvhst(n8 + 3) * dd2;
    cnvhst(n8 + 3) = d3;
    cnvhst(n8 + 4) = d5;
    //C                                                                       M43. 916
    xr1 = 1.0f - d3;
    xi1 = -d5;
    xr2 = 1.0f + d3;
    xi2 = d5;
    d = fem::pow2(xr2) + fem::pow2(xi2);
    br = (xr1 * xr2 + xi1 * xi2) / d;
    bi = (-xr1 * xi2 + xi1 * xr2) / d;
    //C                                                                       M43. 924
    d = fem::pow2(br) + fem::pow2(bi);
    xr1 = .5e0 * (br / d - br);
    xi1 = .5e0 * (-bi / d - bi);
    n11 = fem::iabs(kbus(j));
    n12 = fem::iabs(mbus(j));
    j1 = n8 + 1;
    j2 = n8 + 4;
    if (iprsup >= 2) {
      {
        write_loop wloop(cmn, lunit6,
          "(' ',a6,5x,a6,5x,2f15.10,5x,2f15.10,5x,f15.10)");
        wloop, bus(n11), bus(n12);
        FEM_DO_SAFE(L, j1, j2) {
          wloop, cnvhst(L);
        }
        wloop, d4;
      }
    }
    koff1 = 900;
    koff2 = koff1 + isecti;
    koff3 = koff2 + isecti;
    koff4 = koff3 + isecti;
    koff5 = koff4 + isecti;
    koff6 = koff5 + isecti;
    koff7 = koff6 + isecti;
    koff8 = koff7 + isecti;
    koff9 = koff8 + isecti;
    koff10 = koff9 + isecti;
    //C                                                                       M43. 947
    //C           (1/b-b)*yc/2                                                M43. 948
    //C                                                                       M43. 949
    semaux(koff7 + i) = xr1 * cnvhst(n8 + 1) - xi1 * cnvhst(n8 + 2);
    semaux(koff9 + i) = xr1 * cnvhst(n8 + 2) + xi1 * cnvhst(n8 + 1);
    //C                                                                       M43. 954
    //C           b*yc                                                        M43. 955
    //C                                                                       M43. 956
    semaux(koff8 + i) = br * cnvhst(n8 + 1) - bi * cnvhst(n8 + 2);
    ndx1 = lsiz26 + i;
    semaux(koff10 + i) = br * cnvhst(n8 + 2) + bi * cnvhst(n8 + 1);
    if (iprsup >= 1) {
      write(lunit6,
        "(' MARTI''S PI-EQUIV(R,X,G,B) PRINTOUT IN OVER8: MODE',i10,3x,"
        "4e15.6)"),
        i, semaux(koff7 + i), semaux(koff9 + i), semaux(koff8 + i),
        semaux(koff10 + i);
    }
  }
  //CCCC  DO 952 I=1, IT2                                                   M43. 967
  //CCCC  IMODEL(I) = -4                                                    M43. 968
  //CCCC 952   CONTINUE                                                     M43. 969
  goto statement_640;
  //C   5136 IF ( KEXACT .EQ. 88333  .AND. NSOLVE .EQ. 0 )  KBRNUM = K
statement_5136:
  n1 = it2;
  n2 = litype(k);
  if (im1 != -2) {
    goto statement_5137;
  }
  ktrlsw(5) = 1;
  if (iprsup >= 1) {
    write(lunit6,
      "(' THE FOLLOWING LINES ARE FREQUENCY DEPENDENT',' PARAMETERS AT ',"
      "f10.3,' RADIANS/SEC.',/,' BUS1',7x,'BUS2',14x,'SURGE IMPEDANCE',20x,"
      "' PROPAGATION FUNCTION',12x,'TRAVEL TIME')"),
      omega;
  }
  FEM_DO_SAFE(i, 1, it2) {
    j = i + k - 1;
    npz = cki(j);
    npa = ckkjm(j);
    n3 = kodsem(j);
    n8 = indhst(j);
    cnvhst(n8 + 1) = sconst(n3);
    cnvhst(n8 + 2) = 0.0f;
    FEM_DO_SAFE(ii, 1, npz) {
      n4 = n3 + ii;
      d1 = sconst(n4);
      n5 = npz + n4;
      dd2 = sconst(n5);
      d3 = fem::pow2(dd2) + fem::pow2(omega);
      cnvhst(n8 + 1) += d1 * dd2 / d3;
      cnvhst(n8 + 2) = cnvhst(n8 + 2) - omega * d1 / d3;
    }
    cnvhst(n8 + 3) = 0.0f;
    cnvhst(n8 + 4) = 0.0f;
    FEM_DO_SAFE(ii, 1, npa) {
      n6 = n5 + ii;
      d1 = sconst(n6);
      n7 = n6 + npa;
      dd2 = sconst(n7);
      d3 = fem::pow2(dd2) + fem::pow2(omega);
      cnvhst(n8 + 3) += d1 * dd2 / d3;
      cnvhst(n8 + 4) = cnvhst(n8 + 4) - omega * d1 / d3;
    }
    d4 = cnvhst(n8);
    d9 = -omega * d4;
    d1 = cosz(d9);
    dd2 = sinz(d9);
    d3 = cnvhst(n8 + 3) * d1 - cnvhst(n8 + 4) * dd2;
    d5 = cnvhst(n8 + 3) * dd2 + cnvhst(n8 + 4) * d1;
    cnvhst(n8 + 3) = d3;
    cnvhst(n8 + 4) = d5;
    n11 = fem::iabs(kbus(j));
    n12 = fem::iabs(mbus(j));
    j1 = n8 + 1;
    j2 = n8 + 4;
    if (iprsup >= 2) {
      {
        write_loop wloop(cmn, lunit6,
          "(' ',a6,5x,a6,5x,2f15.10,5x,2f15.10,5x,f15.10)");
        wloop, bus(n11), bus(n12);
        FEM_DO_SAFE(L, j1, j2) {
          wloop, cnvhst(L);
        }
        wloop, d4;
      }
    }
    d9 = fem::pow2(cnvhst(n8 + 3)) + fem::pow2(cnvhst(n8 + 4));
    csihre = cnvhst(n8 + 3) * (1 / d9 - 1.f) * onehaf;
    csihim = -cnvhst(n8 + 4) * (1 / d9 + 1.f) * onehaf;
    d3 = 1 + d9 + 2.f * cnvhst(n8 + 3);
    ctahre = (1.f - d9) / d3;
    ctahim = -2.f * cnvhst(n8 + 4) / d3;
    volti(i) = cnvhst(n8 + 1) * csihre - cnvhst(n8 + 2) * csihim;
    voltk(i) = cnvhst(n8 + 1) * csihim + cnvhst(n8 + 2) * csihre;
    d8 = fem::pow2(cnvhst(n8 + 1)) + fem::pow2(cnvhst(n8 + 2));
    volt(i) = (ctahre * cnvhst(n8 + 1) + ctahim * cnvhst(n8 + 2)) / d8;
    ndx1 = lsiz26 + i;
    volt(ndx1) = (-ctahre * cnvhst(n8 + 2) + ctahim * cnvhst(n8 + 1)) / d8;
    if (iprsup >= 1) {
      write(lunit6,
        "(' MARTI''S PI-EQUIV(R,X,G,B) PRINTOUT IN OVER8: MODE',i10,3x,"
        "4e15.6)"),
        i, volti(i), voltk(i), volt(i), volt(ndx1);
    }
  }
  goto statement_460;
statement_5137:
  equiv(cmn, volti(1), voltk(1), volt(1), volt(lsiz26 + 1), ci(k), ck(k),
    cik(k), omega, n1);
statement_460:
  n3 = itadd;
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' B4 DO 464, VOLTI,VOLTK, VOLT, AND VIM FOR I=1 TO',i3,'ARE',/(1x,"
        "8e15.6))");
      wloop, it2;
      FEM_DO_SAFE(i, 1, it2) {
        wloop, volti(i), voltk(i), volt(i), volt(i + lsiz26);
      }
    }
  }
  FEM_DO_SAFE(i, 1, it2) {
    gus1 = volti(i);
    gus2 = voltk(i);
    gus3 = gus1 * gus1 + gus2 * gus2;
    volti(i) = gus1 / gus3;
    voltk(i) = -gus2 / gus3;
  }
  //C *** Z INVERTED AND STORED IN VOLTI & VOLTK                            M29.1548
  if (iprsup >= 1) {
    write(lunit6,
      "(' AT 1465, K, LITYPE(K), IT2, ITADD, N3, ARE ',10x,5i10)"),
      k, litype(k), it2, itadd, n3;
  }
  n3tst = n3 + it2 * (it2 + 1) / 2 - 1;
  if (n3tst > ldata) {
    goto statement_9000;
  }
  FEM_DO_SAFE(i, 1, it2) {
    FEM_DO_SAFE(j, 1, i) {
      gus1 = 0.f;
      gus2 = 0.f;
      gus3 = 0.f;
      gus4 = 0.f;
      FEM_DO_SAFE(ip, 1, it2) {
        nn3 = (ip - 1) * it2 + n2 - 1;
        jip = nn3 + j;
        iip = nn3 + i;
        h1 = qfd(iip);
        h2 = qfd(jip);
        hh3 = sfd(iip);
        h4 = sfd(jip);
        d1 = volti(ip) * h2 - voltk(ip) * h4;
        dd2 = volti(ip) * h4 + voltk(ip) * h2;
        //C  evaluates the matrix product Y = Q * D * Qt                          M43. 971
        d8 = gus1 + h1 * d1 - hh3 * dd2;
        d9 = gus2 + h1 * dd2 + hh3 * d1;
        gus1 = d8;
        gus2 = d9;
        ndx1 = lsiz26 + ip;
        d3 = volt(ip) * h2 - volt(ndx1) * h4;
        d4 = volt(ip) * h4 + volt(ndx1) * h2;
        d8 = gus3 + h1 * d3 - hh3 * d4;
        d9 = gus4 + h1 * d4 + hh3 * d3;
        gus3 = d8;
        gus4 = d9;
      }
      //C *** CALCULATION OF PI CIRCUIT PARAMETERS (ONLY UPPER PART OF SYMMETRICM29.1569
      //C     MATRIX IS CALCULATED)                                             M29.1570
      r(itadd) = gus3;
      c(itadd) = gus4;
      tr(itadd) = gus1;
      tx(itadd) = gus2;
      if (iprsup >= 1) {
        write(lunit6,
          "(' GUS3, GUS4, GUS1 AND GUS2 AT 1462 FOR ITADD =',i3,'ARE',4e15.6)"),
          itadd, gus3, gus4, gus1, gus2;
      }
      itadd++;
    }
    nr(k) = itadd - i;
    k++;
  }
  n4 = itadd - 1;
  ll0 = 0;
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' B4 CALL CXRED8, TR AND TX FOR I =1 TO',i4,' ARE',/(1x,8e15.6))");
      wloop, n3;
      FEM_DO_SAFE(i, 1, n3) {
        wloop, tr(i), tx(i);
      }
    }
  }
  cxred8(tr(n3), tx(n3), it2, ll0);
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' AFTER CALL CXRED8, TR AND TX FOR I =1 TO',i4,' ARE',/(1x,8e15.6))");
      wloop, n3;
      FEM_DO_SAFE(i, 1, n3) {
        wloop, tr(i), tx(i);
      }
    }
  }
  //C *** CONVERT X & C TO CONFORM TO XOPT & COPT OPTIONS                   M29.1581
  FEM_DO_SAFE(i, n3, n4) {
    tr(i) = -tr(i);
    tx(i) = -tx(i) * d2;
    c(i) = c(i) * h3;
  }
  it2 = 0;
  goto statement_407;
  //C                                                                       M43. 973
statement_640:
  inoff2 = 2 * lbrnch;
  inoff1 = lbrnch;
  nq1 = namebr(inoff2 + k);
  koff13 = koff10 + isecti;
  koff14 = koff13 + isecti;
  koff15 = koff14 + isecti;
  koff16 = koff15 + isecti;
  koff17 = koff16 + isecti;
  koff18 = koff17 + isecti;
  koff19 = koff18 + isecti;
  koff20 = koff19;
  kqvv = namebr(inoff1 + k);
  nphs2 = it2 * it2;
  FEM_DO_SAFE(kqv, 1, nphs2) {
    nteq = semaux(koff20 + kqvv);
    xk(kqv) = sconst(nq1);
    xm(kqv) = 0.e0;
    if (iprsup >= 1) {
      write(6,
        "('kQV NTEQ    NQ1    NQ2    NQ3   SCONST(NQ1)',"
        "'   SCONST(NQ2)   SCONST(NQ3)       QR(KQV)')");
    }
    FEM_DO_SAFE(lq, 1, nteq) {
      nq2 = nq1 + lq;
      nq3 = nq2 + nteq;
      if (std::abs(sconst(nq2)) >= 1.e+13f) {
        goto statement_3000;
      }
      d = fem::pow2(omega) + fem::pow2(sconst(nq3));
      xk(kqv) += sconst(nq2) * sconst(nq3) / d;
      xm(kqv) = xm(kqv) - sconst(nq2) * omega / d;
      goto statement_3001;
    statement_3000:
      jkl++;
      if (jkl == 2) {
        goto statement_3002;
      }
      akr = sconst(nq2) / 1.e+15f;
      aki = sconst(nq2 + 1) / 1.e+15f;
      apr = sconst(nq3) / 1.e+15f;
      api = sconst(nq3 + 1) / 1.e+15f;
      dqq3 = fem::pow2(apr) + fem::pow2((omega + api));
      ddd3 = (akr * apr + aki * (omega + api)) / dqq3;
      ddd4 = (aki * apr - akr * (omega + api)) / dqq3;
      xk(kqv) += 2 * ddd3;
      if (jkl == 1) {
        //w goto statement_1993;
      }
    statement_3002:
      jkl = 0;
    statement_3001:
      if (iprsup >= 1) {
        write(6, "(1x,i2,3x,i2,2x,i5,2x,i5,2x,i5,4e14.5)"), kqv,
          nteq, nq1, nq2, nq3, sconst(nq1), sconst(nq2), sconst(nq3),
          xk(kqv);
      }
      nq2++;
      nq3++;
    }
    nq1 += 2 * nteq + 1;
    kqvv++;
  }
  if (iprsup >= 1) {
    write(lunit6, star), "Following are QR(k) by rows____________";
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, "('+ Qr-I:',3e14.5)");
      FEM_DO_SAFE(j, 1, nphs2) {
        wloop, xk(j);
      }
    }
  }
  if (iprsup >= 1) {
    write(lunit6, star), "Following are QI(k) by rows____________";
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, "('+ Qi-I:',3e14.5)");
      FEM_DO_SAFE(j, 1, nphs2) {
        wloop, xm(j);
      }
    }
  }
  //C                                                                       M43.1027
  FEM_DO_SAFE(ik, 1, nphs2) {
    if (iprsup >= 3) {
      write(lunit6, "('NPHS2 & QR(IK) & QI(IK)=',i3,2x,2e15.6)"),
        nphs2, xk(ik), xm(ik);
    }
  }
  //C                                                                       M43.1033
  //C        Evaluate     Ypi = Q * b*yc * Qt                               M43.1034
  //C                 Zpi**-1 = Q * (1/b-b)*yc/2 * Qt                       M43.1035
  //C                                                                       M43.1036
  nn1 = it2 * (it2 + 1) / 2;
  nn2 = itadd - 1;
  FEM_DO_SAFE(iqy, 1, nn1) {
    r(nn2 + iqy) = 0.e0;
    c(nn2 + iqy) = 0.e0;
  }
  FEM_DO_SAFE(kqy, 1, it2) {
    km1 = (kqy - 1) * it2;
    dyrk = semaux(koff8 + kqy);
    dyik = semaux(koff10 + kqy);
    ij = 0;
    FEM_DO_SAFE(jqy, 1, it2) {
      jk = km1 + jqy;
      qrjk = xk(jk);
      qijk = xm(jk);
      FEM_DO_SAFE(iqy, 1, jqy) {
        ij++;
        ikq = km1 + iqy;
        qrik = xk(ikq);
        qiik = xm(ikq);
        br = qrik * qrjk - qiik * qijk;
        bi = qrik * qijk + qiik * qrjk;
        r(nn2 + ij) += dyrk * br - dyik * bi;
        c(nn2 + ij) += dyrk * bi + dyik * br;
      }
    }
  }
  FEM_DO_SAFE(iqy, 1, nn1) {
    tr(nn2 + iqy) = 0.e0;
    tx(nn2 + iqy) = 0.e0;
  }
  FEM_DO_SAFE(kqy, 1, it2) {
    km1 = (kqy - 1) * it2;
    dyrk = semaux(koff7 + kqy);
    dyik = semaux(koff9 + kqy);
    ij = 0;
    FEM_DO_SAFE(jqy, 1, it2) {
      jk = km1 + jqy;
      qrjk = xk(jk);
      qijk = xm(jk);
      FEM_DO_SAFE(iqy, 1, jqy) {
        ij++;
        ikq = km1 + iqy;
        qrik = xk(ikq);
        qiik = xm(ikq);
        br = qrik * qrjk - qiik * qijk;
        bi = qrik * qijk + qiik * qrjk;
        tr(nn2 + ij) += dyrk * br - dyik * bi;
        tx(nn2 + ij) += dyrk * bi + dyik * br;
      }
    }
  }
  it0 = it2 * (it2 + 1) / 2;
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(7x,'ROW',13x,'TR',13x,'TX',14x,'R',14x,'C',/(i10,4e15.5))");
      FEM_DO_SAFE(i, itadd, itadd + it0) {
        wloop, i, tr(i), tx(i), r(i), c(i);
      }
    }
  }
  FEM_DO_SAFE(ik, 1, it2) {
    nr(k) = itadd + (ik - 1) * ik / 2;
    k++;
  }
  itadd += it0;
  //C                                                                       M43.1105
  goto statement_393;
statement_411:
  if (n1 < 0) {
    goto statement_407;
  }
  i = nr(k);
  if (i < 0) {
    goto statement_407;
  }
  n2 = i + it2 * (it2 + 1) / 2 - 1;
  FEM_DO_SAFE(L, i, n2) {
    c(L) = c(L) * onehaf;
  }
statement_407:
  k += it2;
statement_393:
  if (k <= ibr) {
    goto statement_401;
  }
  n13 = 1;
  if (ktrlsw(5) == 1) {
    vecrsv(cmn, cnvhst(1), lhist, n13);
  }
  i = it + 1;
  j0 = itadd - 1;
  if (lastov == nchain - 1 || iprsup >= 1) {
    write(lunit6,
      "(' PI-EQUIV BRANCHES OF DISTRIB LINES IN TR, TX, ETC.  BETWEEN LIMITS '"
      ",2i6)"),
      i, j0;
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(7x,'ROW',13x,'TR',13x,'TX',14x,'R',14x,'C',/(i10,4e15.5))");
      FEM_DO_SAFE(i, 1, j0) {
        wloop, i, tr(i), tx(i), r(i), c(i);
      }
    }
  }
  if (inonl == 0) {
    goto statement_414;
  }
  if (cmn.noutpr == 0) {
    write(lunit6,
      "(' NONLINEAR AND TIME-VARYING RESISTANCES IGNORED IN STEADY STATE SOLUT"
      "ION. NONLINEAR INDUCTANCES INCLUDED WITH LINEAR PART')");
  }
  d2 = 1000.0f;
  if (xopt > 0.0f) {
    d2 = xopt * twopi;
  }
  if (iprsup <= 1) {
    goto statement_4265;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' NONLINEAR ELEMENT TABLE.',/,"
      "' ROW  NAMENL  NLTYPE   NONLK   NONLM','  NONLAD   NONLE   ILAST',10x,"
      "'VNONL',11x,'CURR',10x,'ANONL',10x,'VZERO',/(1x,i3,7i8,4e15.6))");
    FEM_DO_SAFE(i, 1, inonl) {
      wloop, i, namenl(i), nltype(i), nonlk(i), nonlm(i), nonlad(i),
        nonle(i), ilast(i), vnonl(i), curr(i), anonl(i), vzer5(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' NONLINEAR ELEMENT CHARACTERISTICS.     ROW',10x,'CCHAR',10x,"
      "'VCHAR',9x,'GSLOPE',/(35x,i8,3e15.6))");
    FEM_DO_SAFE(i, 1, cmn.ichar) {
      wloop, i, cchar(i), vchar(i), gslope(i);
    }
  }
statement_4265:
  iprint = 2;
  FEM_DO_SAFE(i, 1, inonl) {
    if (nltype(i) > 0) {
      goto statement_4269;
    }
    if (nltype(i) == -98 || nltype(i) == -96) {
      goto statement_4269;
    }
    if (anonl(i) >= 0.0f) {
      goto statement_413;
    }
    goto statement_4272;
  statement_4269:
    j0 = nonle(i);
    if (j0 > 0) {
      goto statement_413;
    }
    if (vzer5(i) == 0.f) {
      goto statement_413;
    }
    if (anonl(i) > 0.0f) {
      goto statement_4272;
    }
    kill = 14;
    lstat(19) = 406;
    flstat(16) = anonl(i);
    n1 = nonlk(i);
    n2 = fem::iabs(nonlm(i));
    bus1 = bus(n1);
    cmn.bus2 = bus(n2);
    goto statement_9200;
  statement_4272:
    ibrinc(cmn);
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6,
          "(' BRANCH TABLE INTEGERS AT 65457.',/(1x,6i10))");
        FEM_DO_SAFE(k, 1, ibr) {
          wloop, k, kbus(k), mbus(k), nr(k), length(k), kodebr(k);
        }
      }
    }
    lstat(19) = 4272;
    if (ibr > lbrnch) {
      goto statement_9000;
    }
    nr(ibr) = -itadd;
    length(ibr) = 1;
    kbus(ibr) = nonlk(i);
    mbus(ibr) = fem::iabs(nonlm(i));
    if (nltype(i) != -97 && nltype(i) != -99) {
      goto statement_65464;
    }
    L = nonlad(i);
    tr(itadd) = 1.0f / gslope(L);
    tx(itadd) = 0.0f;
    goto statement_65468;
  statement_65464:
    tr(itadd) = 0.0f;
    tx(itadd) = anonl(i) / vzer5(i) * d2;
  statement_65468:
    c(itadd) = 0.0f;
    itadd++;
  statement_413:;
  }
statement_414:
  lastov = nchain;
  nchain++;
  lstat(23) = itadd - 1;
  lstat(22) = ibr;
  if (fmaxfs > 0.0f && knt > 1) {
    goto statement_9600;
  }
  goto statement_8900;
statement_9500:
  if (kconst < cmn.lexct) {
    goto statement_1517;
  }
  //C     TEMPORARY ERROR STOP --- UNABLE TO ADD ANOTHER SOURCE.            M32.3183
  write(lunit6, "(' TOO MANY SOURCES.  S.N. 1514 \"FRQCHK\".')");
  stoptp(cmn);
statement_1517:
  n13 = kconst + 1;
  sfreq(n13) = 1.0f;
  copyi(n13, kssfrq(1), ntot);
  if (tmax > -delta2) {
    goto statement_1534;
  }
  kill = 74;
  lstat(19) = 1517;
  flstat(15) = tmax + delta2;
  lstat(16) = kconst;
  goto statement_9200;
statement_1534:
  lastov = nchain;
  nchain = 12;
statement_8900:
  runtym(d1, d2);
  flstat(1) += d1;
  flstat(2) += d2;
  flstat(3) = flstat(3) - d1;
  flstat(4) = flstat(4) - d2;
  goto statement_9600;
statement_9000:
  lstat(16) = iprint;
  kill = 1;
statement_9200:
  lastov = nchain;
  nchain = 51;
  lstat(18) = 8;
statement_9600:
  if (iprsup >= 1) {
    write(lunit6,
      "(' EXIT \"OVER8\".  ',' NCHAIN, KCONST, KILL, ITADD, FMAXFS =',4i8,"
      "e14.4)"),
      nchain, kconst, kill, itadd, fmaxfs;
  }
}

// SET UP STEADY-STATE PHASOR NETWORK RENUMBERING TABLES.        
void over9(
  common& cmn)
{
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& blank = cmn.blank;
  const auto& abuff = cmn.abuff;
  auto& twopi = cmn.twopi;
  double& fltinf = cmn.fltinf;
  auto& lstat = cmn.lstat;
  int& lbus = cmn.lbus;
  int& lswtch = cmn.lswtch;
  int& last = cmn.last;
  int& lastov = cmn.lastov;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  auto& loopss = cmn.loopss;
  const auto& length = cmn.length;
  auto& texvec = cmn.texvec;
  auto& tstop = cmn.tstop;
  const auto& imodel = cmn.imodel;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& kodsem = cmn.kodsem;
  auto& iform = cmn.iform;
  auto& node = cmn.node;
  auto& crest = cmn.crest;
  auto& time1 = cmn.time1;
  auto& tstart = cmn.tstart;
  auto& sfreq = cmn.sfreq;
  const auto& kmswit = cmn.kmswit;
  const auto& tclose = cmn.tclose;
  const auto& adelay = cmn.adelay;
  const auto& kssfrq = cmn.kssfrq;
  auto& kode = cmn.kode;
  const auto& bus = cmn.bus;
  auto& loc = cmn.loc;
  auto& kownt = cmn.kownt;
  auto& korder = cmn.korder;
  auto& kolum = cmn.kolum;
  auto& nekfix = cmn.nekfix;
  auto& fixbu1 = cmn.fixbu1;
  auto& fixbu2 = cmn.fixbu2;
  auto& fixbu3 = cmn.fixbu3;
  auto& fixbu4 = cmn.fixbu4;
  auto& fixbu5 = cmn.fixbu5;
  auto& fixbu6 = cmn.fixbu6;
  auto& fixbu7 = cmn.fixbu7;
  auto& fixbu8 = cmn.fixbu8;
  auto& fixbu9 = cmn.fixbu9;
  //
  int i = fem::int0;
  int j = fem::int0;
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int next = fem::int0;
  int iofkol = fem::int0;
  int iofkor = fem::int0;
  int nkr = fem::int0;
  int nk = fem::int0;
  int k = fem::int0;
  int k1 = fem::int0;
  int n1 = fem::int0;
  int j1 = fem::int0;
  int jbrt = fem::int0;
  int isubs1 = fem::int0;
  int ii = fem::int0;
  int iswbob = fem::int0;
  int jsw = fem::int0;
  int L = fem::int0;
  int m = fem::int0;
  int kf = fem::int0;
  int ma = fem::int0;
  int ik = fem::int0;
  int il = fem::int0;
  int lastm1 = fem::int0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  int istate = fem::int0;
  int jj = fem::int0;
  int ndx3 = fem::int0;
  int nx = fem::int0;
  int isubs2 = fem::int0;
  int icas = fem::int0;
  //C     FOLLOWING CARRIES "NEXT" AMONG OVER6, INSERT, OVER7, & OVER9:     M37.3694
  //locatn(i, j) = (j * j - j) / 2 + i;
  next = loopss(11);
  iofkol = cmn.iofgnd;
  iofkor = cmn.iofbnd;
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER9.\"')");
  }
  if (iprsup > 0) {
    write(lunit6,
      "(' STEADY-STATE PHASOR SOLUTION BEGINS',"
      "' (TOP OF \"OVER9\").   KCONST, LAST =',2i8)"),
      kconst, last;
  }
  if (cmn.istep != -4567) {
    goto statement_1024;
  }
  nkr = 0;
  lstat(70) = kconst;
statement_1111:
  cimage(cmn);
  read(abuff, "(i2,a6)"), nk, bus1;
  if (bus1 == blank) {
    goto statement_2200;
  }
  nkr++;
  if (nkr >= cmn.lexct) {
    goto statement_9393;
  }
  read(abuff, "(i2,3a6,2e16.0,2e8.0,2e6.0)"), nekfix(nkr), fixbu1(nkr),
    fixbu2(nkr), fixbu3(nkr), fixbu5(nkr), fixbu8(nkr), fixbu7(nkr),
    fixbu9(nkr), fixbu4(nkr), fixbu6(nkr);
  if (fixbu9(nkr) == 0.0f) {
    fixbu9(nkr) = fltinf;
  }
  if (fixbu4(nkr) == 0.0f) {
    fixbu4(nkr) = -fltinf;
  }
  if (fixbu6(nkr) == 0.0f) {
    fixbu6(nkr) = fltinf;
  }
  write(kunit6, "('+FIX.',4e11.3)"), fixbu5(nkr), fixbu8(nkr), fixbu7(nkr),
    fixbu9(nkr);
  goto statement_1111;
statement_9393:
  kill = 227;
  write(lunit6,
    "(' THE NUMBER OF FIX SOURCES',i5,2x,"
    "' SHOULD BE LESS THAN THE NUMBER OF ALL SOURCES')"),
    nkr;
  goto statement_9999;
statement_2200:
  lstat(69) = nkr;
  if (cmn.tmax > 0.0f) {
    goto statement_1024;
  }
  FEM_DO_SAFE(i, 1, nkr) {
    texvec(1) = fixbu1(i);
    FEM_DO_SAFE(k, 1, kconst) {
      k1 = fem::iabs(node(k));
      if (bus(k1) == texvec(1)) {
        goto statement_3131;
      }
    }
    n1 = 1;
    kconst++;
    crest(kconst) = (fixbu7(i) + fixbu9(i)) * 0.5f;
    time1(kconst) = (fixbu4(i) + fixbu6(i)) * twopi / 720.f;
  statement_1911:
    FEM_DO_SAFE(j, 2, ntot) {
      if (bus(j) == texvec(1)) {
        goto statement_5757;
      }
    }
    kill = 500;
    goto statement_9999;
  statement_5757:
    node(kconst) = j;
    j1 = kssfrq(j);
    sfreq(kconst) = sfreq(j1);
    iform(kconst) = 14;
    tstop(kconst) = 1.0f;
    tstart(kconst) = -1.0f;
    switch (n1) {
    case 1: goto statement_3131;
    case 2: goto statement_3333;
    case 3: goto statement_3535;
    default: break;
    }
  statement_3131:
    texvec(1) = fixbu2(i);
    if (texvec(1) == blank) {
      goto statement_3535;
    }
    FEM_DO_SAFE(k, 1, kconst) {
      k1 = fem::iabs(node(k));
      if (bus(k1) == fixbu2(i)) {
        goto statement_3333;
      }
    }
    n1 = 2;
    kconst++;
    crest(kconst) = crest(kconst - 1);
    time1(kconst) = time1(kconst - 1) - twopi / 3.0f;
    goto statement_1911;
  statement_3333:
    texvec(1) = fixbu3(i);
    if (texvec(1) == blank) {
      goto statement_3535;
    }
    FEM_DO_SAFE(k, 1, kconst) {
      k1 = fem::iabs(node(k));
      if (bus(k1) == fixbu3(i)) {
        goto statement_3535;
      }
    }
    n1 = 3;
    kconst++;
    crest(kconst) = crest(kconst - 1);
    time1(kconst) = time1(kconst - 1) - twopi / 3.0f;
    goto statement_1911;
  statement_3535:;
  }
statement_1024:
  if (kconst == 0) {
    goto statement_1034;
  }
  FEM_DO_SAFE(i, 1, kconst) {
    if (fem::iabs(iform(i)) != 14) {
      goto statement_1030;
    }
    if (tstart(i) >= 0.0f) {
      goto statement_1030;
    }
    goto statement_1050;
  statement_1030:;
  }
statement_1034:
  write(lunit6,
    "(/,' COMMENT ---- NO SINUSOIDAL SOURCES REQUESTED FOR STEADY-STATE SOLUTI"
    "ON.   THUS THIS SOLUTION IS BYPASSED.')");
  lastov = nchain;
  nchain = 12;
  goto statement_9990;
statement_1050:
  next = 1;
  loopss(11) = next;
  jbrt = last;
  isubs1 = iofkor + 1;
  move0(korder, isubs1, jbrt);
  move0(loc, ntot);
  i = 1;
  goto statement_1160;
statement_1150:
  i = ii + 1;
statement_1160:
  if (i > cmn.ibr) {
    goto statement_1500;
  }
  ii = i + fem::iabs(length(i)) - 1;
  //C      IF (KODSEM(I) .NE. 0  .AND. IMODEL(I) .NE. -2                    M31.2432
  //C     1                      .AND. IMODEL(I) .NE. -4)                   M43.1110
  if (kodsem(i) != 0 && imodel(i) >= 0) {
    ii = i + fem::iabs(kodebr(i)) - 1;
  }
  iswbob = 1;
  j = i;
  goto statement_1250;
statement_1220:
  j++;
  if (iswbob == 0) {
    goto statement_1320;
  }
  if (j > ii) {
    goto statement_1330;
  }
statement_1250:
  k = fem::iabs(kbus(j));
statement_1260:
  if (k == 0) {
    goto statement_1220;
  }
  jsw = 1;
  L = i;
  goto statement_1290;
statement_1280:
  L++;
statement_1290:
  if (L > ii) {
    goto statement_1350;
  }
  m = fem::iabs(kbus(L));
  if (m == k || m == 0) {
    goto statement_1280;
  }
  goto statement_1400;
statement_1320:
  if (j > ii) {
    goto statement_1150;
  }
  goto statement_1340;
statement_1330:
  iswbob = 0;
  j = i;
statement_1340:
  k = fem::iabs(mbus(j));
  goto statement_1260;
statement_1350:
  jsw = 2;
  L = i;
  goto statement_1370;
statement_1360:
  L++;
statement_1370:
  if (L > ii) {
    goto statement_1220;
  }
  m = fem::iabs(mbus(L));
  if (m == k || m < 1) {
    goto statement_1360;
  }
statement_1400:
  kf = loc(k);
  if (kf == 0) {
    goto statement_1420;
  }
  goto statement_1440;
statement_1420:
  loc(k) = next;
  goto statement_1480;
statement_1430:
  isubs1 = iofkor + kf;
  kf = korder(isubs1);
statement_1440:
  isubs1 = iofkol + kf;
  n1 = m - kolum(isubs1);
  if (n1 > 0) {
    goto statement_1460;
  }
  if (n1 == 0) {
    goto statement_1490;
  }
  isubs1 = iofkol + kf;
  ma = kolum(isubs1);
  isubs1 = iofkol + kf;
  kolum(isubs1) = m;
  m = ma;
statement_1460:
  isubs1 = iofkor + kf;
  if (korder(isubs1) != 0) {
    goto statement_1430;
  }
  isubs1 = iofkor + kf;
  korder(isubs1) = next;
statement_1480:
  isubs1 = iofkol + next;
  kolum(isubs1) = m;
  if (next < last) {
    goto statement_1495;
  }
  kill = 220;
  lstat(19) = 1495;
  lstat(15) = i;
  goto statement_9999;
statement_1495:
  next++;
  loopss(11) = next;
statement_1490:
  switch (jsw) {
  case 1: goto statement_1280;
  case 2: goto statement_1360;
  default: break;
  }
statement_1500:
  FEM_DO_SAFE(i, 2, ntot) {
    ik = 0;
    il = loc(i);
  statement_1530:
    if (il == 0) {
      goto statement_1550;
    }
    ik++;
    isubs1 = iofkor + il;
    il = korder(isubs1);
    goto statement_1530;
  statement_1550:
    kownt(i) = ik;
  }
  //C     PREVENT VAX I/O INTERRUPT ON KOWNT(1) GARBAGE (NOV, 81):          M31.2434
  if (fem::iabs(kownt(1)) > 99999) {
    kownt(1) = 0;
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (KOWNT(I), I=1, NTOT)   IN  ''OVER9'' ,  AFTER BRANCH TABLE HAS "
        "BEEN PUT INTO STEADY-STATE RENUMBERING ARRAYS.',/(1x,20i6))");
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, kownt(i);
      }
    }
  }
  lastm1 = last - 1;
  FEM_DO_SAFE(i, next, lastm1) {
    isubs1 = iofkor + i;
    korder(isubs1) = i + 1;
  }
  isubs1 = iofkor + last;
  korder(isubs1) = 0;
  move0(kode, ntot);
  if (kswtch == 0) {
    goto statement_1940;
  }
  i = 0;
statement_1631:
  i++;
  if (adelay(i) == -44444.f) {
    goto statement_1650;
  }
  if (tclose(i) >= 0.f) {
    goto statement_1640;
  }
  if (adelay(i) == 44444.f) {
    goto statement_1640;
  }
  goto statement_1650;
statement_1640:
  if (i < kswtch) {
    goto statement_1631;
  }
  goto statement_1940;
statement_1650:
  j = kmswit(i);
  ndx1 = lswtch + i;
  k = kmswit(ndx1);
  if (k > j) {
    goto statement_1655;
  }
  ndx2 = k;
  k = j;
  j = ndx2;
statement_1655:
  if (kode(j) != 0) {
    goto statement_1760;
  }
  if (kode(k) != 0) {
    goto statement_1690;
  }
  kode(j) = k;
  kode(k) = j;
  goto statement_1640;
statement_1690:
  L = k;
  goto statement_1710;
statement_1700:
  L = kode(L);
statement_1710:
  if (kode(L) > L) {
    goto statement_1700;
  }
  m = kode(L);
statement_1730:
  if (m > j) {
    goto statement_1750;
  }
  L = m;
  m = kode(m);
  goto statement_1730;
statement_1750:
  kode(j) = m;
  kode(L) = j;
  goto statement_1640;
statement_1760:
  if (kode(k) != 0) {
    goto statement_1820;
  }
  L = j;
  goto statement_1790;
statement_1780:
  L = kode(L);
statement_1790:
  if (kode(L) >= k) {
    goto statement_1810;
  }
  if (kode(L) > L) {
    goto statement_1780;
  }
statement_1810:
  m = kode(L);
  kode(L) = k;
  kode(k) = m;
  goto statement_1640;
statement_1820:
  if (kode(j) <= j) {
    goto statement_1840;
  }
  j = kode(j);
  goto statement_1820;
statement_1840:
  if (kode(k) <= k) {
    goto statement_1860;
  }
  k = kode(k);
  goto statement_1840;
statement_1860:
  L = j;
  if (L < k) {
    L = k;
  }
  j = kode(j);
  k = kode(k);
statement_1870:
  if (j > k) {
    goto statement_1910;
  }
  if (j == k) {
    goto statement_1640;
  }
  kode(L) = j;
  L = j;
  j = kode(j);
  if (j > L) {
    goto statement_1870;
  }
  j = 10000;
  goto statement_1870;
statement_1910:
  kode(L) = k;
  L = k;
  k = kode(k);
  if (k > L) {
    goto statement_1870;
  }
  k = 10000;
  goto statement_1870;
statement_1940:
  i = 1;
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (KODE(I), NODE(I), I=1, NTOT)   AFTER STEADY-STATE SWITCH-CHAIN "
        "SETUP IN  ''OVER9'' .',/(1x,20i6))");
      FEM_DO_SAFE(k, 1, ntot) {
        wloop, kode(k), node(k);
      }
    }
  }
  k = 0;
statement_1950:
  if (fem::iabs(iform(i)) != 14) {
    goto statement_2040;
  }
  if (iform(i + 1) == 18) {
    goto statement_2040;
  }
  if (tstart(i) != 5432.f) {
    goto statement_1972;
  }
  //C     CURRENT SOURCE TREATED AS VOLTAGE SOURCE FOR S.S. :               M31.2438
  j = fem::iabs(node(i));
  if (iprsup >= 1) {
    write(lunit6, "(' CHARGE. I, K, J, KODE(J), KOWNT(J) =',5i6)"),
      i, k, j, kode(j), kownt(j);
  }
  goto statement_1980;
statement_1972:
  if (tstart(i) >= 0.0f) {
    goto statement_2040;
  }
  j = fem::iabs(node(i));
  if (node(i) <= 0) {
    goto statement_2040;
  }
statement_1980:
  if (kode(j) > 0) {
    goto statement_2020;
  }
  if (kode(j) < 0) {
    goto statement_2000;
  }
  kode(j) = -j;
  kownt(j) = -1;
  k++;
  goto statement_2040;
statement_2000:
  istate = 2000;
  jj = node(i);
  write(lunit6,
    "(/,' NOTICE. ---- TWO OR MORE SINUSOIDAL VOLTAGE SOURCES ARE PRESENT ON N"
    "ODE ''',a6,''' DURING THE STEADY-STATE',/,14x,"
    "'SOLUTION.   AS PER THE USER''S MANUAL, THESE VOLTAGES WILL ALL BE ADDED "
    "TOGETHER TO GET A TOTAL NODE VALUE.')"),
    bus(jj);
  goto statement_2040;
statement_2010:
  j = L;
statement_2020:
  L = kode(j);
  kode(j) = -L;
  kownt(j) = -1;
  k++;
  if (kode(L) > 0) {
    goto statement_2010;
  }
statement_2040:
  if (i > kconst) {
    goto statement_2050;
  }
  i++;
  if (i <= kconst) {
    goto statement_1950;
  }
  j = 1;
  goto statement_1980;
statement_2050:
  cmn.ncurr = ntot - k;
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (KOWNT(I), I=1, NTOT)   IN  ''OVER9'' ,  AFTER KNOWN VOLTAGE NOD"
        "ES ARE FORCED LAST.',/(1x,20i6))");
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, kownt(i);
      }
    }
  }
  i = 3 * lbus;
  if (i < cmn.intinf) {
    goto statement_2054;
  }
  kill = 80;
  lstat(19) = 2054;
  goto statement_9999;
statement_2054:
  ii = 2 * lbus;
  if (kconst == 0) {
    goto statement_2113;
  }
  FEM_DO_SAFE(i, 1, kconst) {
    if (fem::iabs(iform(i)) != 14) {
      goto statement_2110;
    }
    if (tstart(i) >= 0.0f) {
      goto statement_2110;
    }
    j = fem::iabs(node(i));
    if (node(i) > 0) {
      goto statement_2110;
    }
    if (kode(j) >= 0) {
      goto statement_2110;
    }
    jj = fem::iabs(node(i));
    write(lunit6,
      "(/,' NOTE. ---- NODE ''',a6,"
      "''' HAS BOTH VOLTAGE AND CURRENT SOURCES ON IT.   THE CURRENT SOURCE HA"
      "S NO EFFECT',/,12x,'ON THE SOLUTION, THEN, AND COULD BE OMITTED.')"),
      bus(jj);
    node(i) = node(i) - ii;
  statement_2110:;
  }
statement_2113:
  if (kswtch == 0) {
    goto statement_3000;
  }
  FEM_DO_SAFE(ii, 1, kswtch) {
    if (adelay(ii) == -44444.f) {
      goto statement_2523;
    }
    if (tclose(ii) >= 0.0f) {
      goto statement_2730;
    }
    if (adelay(ii) == 44444.f) {
      goto statement_2730;
    }
  statement_2523:
    i = kmswit(ii);
    ndx3 = lswtch + ii;
    j = kmswit(ndx3);
    if (i > j) {
      i = j;
    }
  statement_2530:
    j = fem::iabs(kode(i));
  statement_2540:
    L = loc(i);
    if (L != 0) {
      goto statement_2560;
    }
    isubs1 = iofkor + next;
    nx = korder(isubs1);
    isubs1 = iofkol + next;
    kolum(isubs1) = j;
    isubs1 = iofkor + next;
    korder(isubs1) = 0;
    loc(i) = next;
    next = nx;
    loopss(11) = next;
    if (kode(i) >= 0) {
      kownt(i) = 1;
    }
    goto statement_2610;
  statement_2550:
    isubs1 = iofkor + L;
    L = korder(isubs1);
  statement_2560:
    isubs1 = iofkol + L;
    k = kolum(isubs1);
    if (k > j) {
      goto statement_2590;
    }
    if (k == j) {
      goto statement_2690;
    }
    isubs1 = iofkor + L;
    if (korder(isubs1) != 0) {
      goto statement_2550;
    }
    isubs1 = iofkor + next;
    nx = korder(isubs1);
    isubs1 = iofkol + next;
    kolum(isubs1) = j;
    isubs1 = iofkor + next;
    korder(isubs1) = 0;
    isubs1 = iofkor + L;
    korder(isubs1) = next;
    next = nx;
    loopss(11) = next;
    goto statement_2600;
  statement_2590:
    isubs1 = iofkor + next;
    nx = korder(isubs1);
    isubs1 = iofkol + next;
    isubs2 = iofkol + L;
    kolum(isubs1) = kolum(isubs2);
    isubs1 = iofkor + next;
    isubs2 = iofkor + L;
    korder(isubs1) = korder(isubs2);
    isubs1 = iofkor + L;
    korder(isubs1) = next;
    isubs1 = iofkol + L;
    kolum(isubs1) = j;
    next = nx;
    loopss(11) = next;
  statement_2600:
    if (kownt(i) != (-1)) {
      kownt(i)++;
    }
  statement_2610:
    L = loc(j);
    if (L != 0) {
      goto statement_2630;
    }
    isubs1 = iofkor + next;
    nx = korder(isubs1);
    isubs1 = iofkol + next;
    kolum(isubs1) = i;
    isubs1 = iofkor + next;
    korder(isubs1) = 0;
    loc(j) = next;
    next = nx;
    loopss(11) = next;
    if (kode(j) >= 0) {
      kownt(j) = 1;
    }
    goto statement_2690;
  statement_2620:
    isubs1 = iofkor + L;
    L = korder(isubs1);
  statement_2630:
    isubs1 = iofkol + L;
    k = kolum(isubs1);
    if (k > i) {
      goto statement_2670;
    }
    if (k < i) {
      goto statement_2650;
    }
    kill = 15;
    lstat(19) = 2650;
    lstat(16) = ii;
    lstat(15) = next;
    goto statement_9999;
  statement_2650:
    isubs1 = iofkor + L;
    if (korder(isubs1) != 0) {
      goto statement_2620;
    }
    isubs1 = iofkor + next;
    nx = korder(isubs1);
    isubs1 = iofkol + next;
    kolum(isubs1) = i;
    isubs1 = iofkor + next;
    korder(isubs1) = 0;
    isubs1 = iofkor + L;
    korder(isubs1) = next;
    next = nx;
    loopss(11) = next;
    goto statement_2680;
  statement_2670:
    isubs1 = iofkor + next;
    nx = korder(isubs1);
    isubs1 = iofkol + next;
    isubs2 = iofkol + L;
    kolum(isubs1) = kolum(isubs2);
    isubs1 = iofkor + next;
    isubs2 = iofkor + L;
    korder(isubs1) = korder(isubs2);
    isubs1 = iofkor + L;
    korder(isubs1) = next;
    isubs1 = iofkol + L;
    kolum(isubs1) = i;
    next = nx;
    loopss(11) = next;
  statement_2680:
    if (kownt(j) != (-1)) {
      kownt(j)++;
    }
  statement_2690:
    if (fem::iabs(kode(j)) <= j) {
      goto statement_2710;
    }
    j = fem::iabs(kode(j));
    goto statement_2540;
  statement_2710:
    i = fem::iabs(kode(i));
    if (i != j) {
      goto statement_2530;
    }
  statement_2730:;
  }
  if (iprsup > 0) {
    write(lunit6,
      "(/,' AT END OF  ''OVER9'' ,  JUST BEFORE STEADY-STATE RENUMBERING,',i5,"
      "' OF TOTAL OF ',i5,' CELLS OF KOLUM, KORDER ARE FILLED')"),
      next, last;
  }
statement_3000:
  icas = 1;
  lastov = nchain;
  nchain = 7;
  goto statement_9990;
statement_9999:
  lastov = nchain;
  nchain = 51;
  lstat(18) = 9;
statement_9990:
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE OVER9.\"')");
  }
} // over9

void addmxd(
  arr_cref<double> a,
  double const& b,
  arr_ref<double> c,
  int const& n)
{
  int jt = n * (n + 1) / 2;
  a(dimension(jt));   // only upper trangular
  c(dimension(jt));
  //C)    SUBROUTINE  ADDMXD  FORMS MATRIX   (C) = (A) + B(U)  , WHERE (A), M15. 322
  //C)    AND (C)  ARE N BY N MATRICES,  B  IS A SCALAR, AND (U) IS THE     M15. 323
  //C)    IDENTITY MATRIX.   ARRAY (C) MAY BE THE SAME AS (A), IF DESIRED.  M15. 324
  //C)    SEE SUBR.  MULT  FOR SYMMETRIC-MATRIC STORAGE SCHEME ASSUMED.     M15. 325
  int k = 1;
  int j = 1;
  int L = fem::int0;
  FEM_DO_SAFE(L, 1, jt) {
    c(L) = a(L);
    if (L < k) {
      goto statement_3010;
    }
    c(L) += b;
    j++;
    k += j;
  statement_3010:;
  }
}

void sseqiv(
  common& cmn,
  int& ikf,
  int& isfd,
  double const& omegal,
  double const& omegac)
{
  common_write write(cmn);
  int& iprsup = cmn.iprsup;
  const auto& rmfd = cmn.rmfd;
  const auto& imfd = cmn.imfd;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;

  arr_ref<double> voltk(static_cast<common_c0b124&>(cmn).voltk,
    dimension(3000));
  //
  int idk = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int kb = fem::int0;
  int kc = fem::int0;
  int isf = fem::int0;
  int ist = fem::int0;
  int isu = fem::int0;
  int ka = fem::int0;
  double ar1 = fem::double0;
  double al1 = fem::double0;
  double ac1 = fem::double0;
  double arl = fem::double0;
  double azr = fem::double0;
  double azi = fem::double0;
  double den = fem::double0;
  //C!DIMENSION  UR(1), UI(1)
  //C!EQUIVALENCE ( VOLTI(1), UR(1) ), ( VOLTK(1), UI(1) )
  //C     THIS ROUTINE PRODUCES A S.S. EQUIVALENT OF THE BRANCHES.THIS      M32.3370
  //C     EQUIVALENT IS INSERTED INTO THE TR AND TX TABLES *   *   *   *   *M32.3371
  idk = 2 * ikf;
  ikf++;
  if (iprsup > 0) {
    write(lunit6,
      "(' INTEGER COUNTERS AT START OF SSEQIV.....',10x,7x,'IKF',6x,'ISFD',6x,"
      "'IZFD',6x,'IPFD',/,51x,4i10)"),
      ikf, isfd, imfd(idk + 1), imfd(idk + 2);
  }
  FEM_DO_SAFE(kb, 1, 2) {
    voltk(kb) = 0.f;
    volti(kb) = 0.f;
    kc = idk + kb;
    isf = imfd(kc);
    ist = isfd + 1;
    isu = isfd + isf * 5;
    FEM_DOSTEP(ka, ist, isu, 5) {
      //C     CALCULATE BRANCH IMPEDANCE   *   *   *   *   *   *   *   *   *   *M32.3386
      ar1 = rmfd(ka);
      al1 = rmfd(ka + 1) * omegal;
      ac1 = rmfd(ka + 2) * omegac;
      arl = rmfd(ka + 3);
      azr = 0.f;
      azi = al1;
      if (ac1 != 0.0f) {
        ac1 = 1.0f / ac1;
      }
      //C     PROCESS THE PARALLEL R AND L CONNECTION, FIRST   *   *   *   *   *M32.3394
      if (arl == 0.0f) {
        goto statement_2;
      }
      den = 1.0f / (arl * arl + al1 * al1);
      azr = arl * (al1 * al1) * den;
      azi = al1 * (arl * arl) * den;
    statement_2:
      azr += ar1;
      azi = azi - ac1;
      //C     INVERT IMPEDANCE TO SUM ADMITTANCES  *   *   *   *   *   *   *    M32.3401
      den = 1.0f / (azr * azr + azi * azi);
      volti(kb) += azr * den;
      voltk(kb) = voltk(kb) - azi * den;
    }
    if (iprsup > 0) {
      write(lunit6,
        "(' EQUIVALENT MODAL ADMITTANCE FOR MODE NO.',i6,10x,2e22.10)"),
        kb, volti(kb), voltk(kb);
    }
    isfd = isu;
    //C     CONVERT MODAL ADMITTANCE TO IMPEDANCE*   *   *   *   *   *   *   *M32.3410
    den = 1.0f / (volti(kb) * volti(kb) + voltk(kb) * voltk(kb));
    volti(kb) = volti(kb) * den;
    voltk(kb) = -voltk(kb) * den / omegal;
  }
}

void multmx(
  arr_cref<double> a,
  arr_cref<double> b,
  arr_ref<double> c,
  arr_ref<double> temp,
  int const& n)
{
  a(dimension(n * n));
  b(dimension(n * n));
  c(dimension(n * n));
  temp(dimension(n+n));
  int ll0 = fem::int0;
  int ii = fem::int0;
  int j = fem::int0;
  int i = fem::int0;
  int L = fem::int0;
  int m = fem::int0;
  //C)    SUBROUTINE MULTMX  FORMS THE MATRIX PRODUCT   (C) = (A)(B)   WHEREM15. 326
  //C)    MATRICES  (A), (B), AND (C)  ARE ALL  N BY N  SQUARE ARRAYS.      M15. 327
  //C)    ARRAY  'TEMP'  IS A SCRATCH WORKING AREA OF NOT LESS THAN  2N     M15. 328
  //C)    CELLS.   ARRAYS  (B)  AND  (C)  MAY BE IDENTICAL, THEREBY PLACING M15. 329
  //C)    THE PRODUCT   (A)(B)   BACK INTO  (B) .    SEE SUBROUTINE  'MULT' M15. 330
  //C)    WHICH IS CALLED HEREIN, FOR DETAILS ABOUT THE STORAGE SCHEME USED M15. 331
  //C)    FOR THESE REAL, SYMMETRIC MATRICES.                               M15. 332
  ll0 = 0;
  ii = 0;
  FEM_DO_SAFE(j, 1, n) {
    FEM_DO_SAFE(i, 1, n) {
      if (i <= j) {
        goto statement_3420;
      }
      L += (i - 1);
      goto statement_3430;
    statement_3420:
      L = ii + i;
    statement_3430:
      temp(i) = b(L);
    }
    m = n + 1;
    mult(a(1), temp(1), temp(m), n, ll0);
    mover(temp(m), c(ii + 1), j);
    ii += j;
  }
}

void fxsour(
  common& cmn)
{
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& blank = cmn.blank;
  const auto& abuff = cmn.abuff;
  double& tolmat = cmn.tolmat;
  double& onehaf = cmn.onehaf;
  const auto& lstat = cmn.lstat;
  int& ncurr = cmn.ncurr;
  int& ioffd = cmn.ioffd;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& ntot = cmn.ntot;
  const auto& loopss = cmn.loopss;
  const auto& node = cmn.node;
  auto& crest = cmn.crest;
  auto& time1 = cmn.time1;
  auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  const auto& kode = cmn.kode;
  auto& volt = cmn.volt;
  const auto& bus = cmn.bus;
  const auto& norder = cmn.norder;
  const auto& index = cmn.index;
  const auto& bnd = cmn.bnd;
  const auto& iloc = cmn.iloc;
  const auto& gnd = cmn.gnd;
  const auto& nekfix = cmn.nekfix;
  const auto& fixbu1 = cmn.fixbu1;
  const auto& fixbu2 = cmn.fixbu2;
  const auto& fixbu3 = cmn.fixbu3;
  const auto& fixbu4 = cmn.fixbu4;
  const auto& fixbu5 = cmn.fixbu5;
  const auto& fixbu6 = cmn.fixbu6;
  const auto& fixbu7 = cmn.fixbu7;
  const auto& fixbu8 = cmn.fixbu8;
  const auto& fixbu9 = cmn.fixbu9;
  auto& solr = cmn.solr;
  auto& soli = cmn.soli;
  auto& jndex = cmn.jndex;
  auto& diagg = cmn.diagg;
  auto& diabb = cmn.diabb;
  auto& solrsv = static_cast<common_c10b04&>(cmn).solrsv;
  auto& solisv = static_cast<common_c10b05&>(cmn).solisv;
  auto& gndd = cmn.gndd;
  auto& bndd = cmn.bndd;
  auto& fxtem1 = cmn.fxtem1;
  auto& fxtem2 = cmn.fxtem2;
  auto& fxtem3 = cmn.fxtem3;
  auto& fxtem4 = cmn.fxtem4;
  auto& fxtem5 = cmn.fxtem5;
  auto& fxtem6 = cmn.fxtem6;
  auto& fixb10 = cmn.fixb10;
  auto& fixb11 = cmn.fixb11;
  auto& kndex = cmn.kndex;
  //
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int llm1 = fem::int0;
  int ll0 = fem::int0;
  int ll1 = fem::int0;
  int ll2 = fem::int0;
  int nekstp = fem::int0;
  double cc1 = fem::double0;
  double cc2 = fem::double0;
  int nnnout = fem::int0;
  int nitera = fem::int0;
  int nflout = fem::int0;
  int nprint = fem::int0;
  double ralchk = fem::double0;
  double cfitev = fem::double0;
  double cfitea = fem::double0;
  int nkr = fem::int0;
  double eknom1 = fem::double0;
  int i = fem::int0;
  double pmax = fem::double0;
  double qmax = fem::double0;
  int nekite = fem::int0;
  double picon = fem::double0;
  int n14 = fem::int0;
  int np = fem::int0;
  int jj = fem::int0;
  int mm = fem::int0;
  int ixx = fem::int0;
  int n3 = fem::int0;
  int n15 = fem::int0;
  int nekcc = fem::int0;
  int npp = fem::int0;
  arr_1d<20, double> vdiff(fem::fill0);
  int ip = fem::int0;
  double vr = fem::double0;
  double vi = fem::double0;
  int kkk = fem::int0;
  int j = fem::int0;
  double der = fem::double0;
  double dei = fem::double0;
  double ekitev = fem::double0;
  double ekfact = fem::double0;
  double psum = fem::double0;
  double qsum = fem::double0;
  int nekn1 = fem::int0;
  int k = fem::int0;
  double ekdif1 = fem::double0;
  double ekdif2 = fem::double0;
  double ekn1 = fem::double0;
  double angel = fem::double0;
  double ekdgr = fem::double0;
  int nekn4 = fem::int0;
  int nkode = fem::int0;
  double cchanr = fem::double0;
  double cchani = fem::double0;
  int nflknt = fem::int0;
  int ii = fem::int0;
  int isubs1 = fem::int0;
  int isubs2 = fem::int0;
  int m = fem::int0;
  int n = fem::int0;
  int nfix = fem::int0;
  static const char* format_3500 = "(1x,i5,i6,1x,a6,e17.6,f11.4,e18.6,e17.6)";
  static const char* format_8484 = "('  @@@@@@@@  TIME =  ',2e20.5)";
  //C     THIS MODULE OF OVERLAY 10 IS CALLED ONLY ONCE, IF AND ONLY        M36.1077
  //C     IF THE DATA CASE INVOLVES PHASOR POWER (P+JQ, ETC.)               M36.1078
  //C     CONSTRAINTS.  THIS IS EMTP LOAD FLOW OF "FIX SOURCE" REQUEST.     M36.1079
  //C
  if (iprsup >= 2) {
    write(lunit6, "(/,' TOP OF FXSOUR = LOAD FLOW MODULE')");
  }
  llm1 = -1;
  ll0 = 0;
  ll1 = 1;
  ll2 = 2;
  nekstp = 0;
  if (iprsup <= 0) {
    goto statement_2000;
  }
  runtym(cc1, cc2);
  write(lunit6, format_8484), cc1, cc2;
statement_2000:
  read(abuff, "(8x,4i8,3e8.0)"), nnnout, nitera, nflout, nprint,
    ralchk, cfitev, cfitea;
  if (nitera == 0) {
    nitera = 500;
  }
  //C     NEXT ONLY ALLOW NFLOUT = 1, 2, 4, 5, 10, OR 20 VALUES             M36.1110
  if (nflout <= 0 || nflout > 20) {
    nflout = 20;
  }
statement_2256:
  if (20 / nflout * nflout == 20) {
    goto statement_2259;
  }
  nflout++;
  goto statement_2256;
statement_4567:
  write(lunit6, "(' ***** NO FIX SOURCE *****')");
  goto statement_9000;
statement_2259:
  if (ralchk == 0.0f) {
    ralchk = 0.01f;
  }
  if (cfitev == 0.0f) {
    cfitev = 0.2f;
  }
  if (cfitea == 0.0f) {
    cfitea = 2.5f;
  }
  if (cmn.noutpr == 0) {
    write(kunit6, "('+ LAST FIX SOURCE CARD.',i6,f14.8)"), nitera, ralchk;
  }
  nkr = lstat(69);
  if (nkr == 0) {
    goto statement_4567;
  }
  eknom1 = 0.0f;
  FEM_DO_SAFE(i, 1, nkr) {
    pmax = std::abs(fixbu5(i));
    qmax = std::abs(fixbu8(i));
    if (eknom1 < pmax) {
      eknom1 = pmax;
    }
    if (eknom1 < qmax) {
      eknom1 = qmax;
    }
  }
  nekite = 0;
  picon = 360.f / cmn.twopi;
  n14 = ntot + loopss(2);
  np = ncurr + 1;
  FEM_DO_SAFE(i, 1, ntot) {
    jj = norder(i);
    jndex(jj) = i;
  }
  mm = 0;
  FEM_DO_SAFE(jj, np, ntot) {
    if (jj == norder(1)) {
      goto statement_1030;
    }
    if (kode(jj) > jj) {
      goto statement_1030;
    }
    i = jndex(jj);
    mm++;
    fxtem1(mm) = bus(i);
    kndex(mm) = i;
    FEM_DO_SAFE(ixx, 1, kconst) {
      if (fem::iabs(node(ixx)) != i) {
        goto statement_1039;
      }
      if (crest(ixx) != 0) {
        fxtem6(mm) = 1.0f / crest(ixx);
      }
    statement_1039:;
    }
  statement_1030:;
  }
  mover(solr(1), solrsv(1), n14);
  mover(soli(1), solisv(1), n14);
  goto statement_3466;
  //C     BEGIN CALCULATION OF NODE CURRENTS                                M36.1143
statement_1000:
  n3 = 2;
  vecrsv(cmn, diagg(1), ntot, n3);
  vecrsv(cmn, diabb(1), ntot, n3);
  if (cmn.kburro == 1) {
    goto statement_4372;
  }
  if (ioffd <= lstat(14)) {
    goto statement_4372;
  }
  write(lunit6,
    "(' NO ENOUGH SPACE FOR LOAD FLOW .  IOFFD =',i8,"
    "' BUT THE LIMIT SPACE IS LSIZ23 = ',i8)"),
    ioffd, lstat(14);
  FEM_STOP(0);
statement_4372:
  vecrsv(cmn, gndd(1), ioffd, n3);
  vecrsv(cmn, bndd(1), ioffd, n3);
  n3 = -4;
  n15 = 0;
  vecrsv(cmn, volt(1), n3, n15);
  nekcc = 0;
  vdiff(npp) = 0.0f;
  if (ncurr <= 0) {
    ncurr = 1;
  }
  FEM_DO_SAFE(ip, 1, ntot) {
    e(ip) = 0.0f;
    f(ip) = 0.0f;
  }
  i = 1;
statement_7350:
  if (i > ntot) {
    goto statement_7390;
  }
  vr = solr(i);
  vi = soli(i);
  jj = index(i);
  kkk = index(i + 1);
  e(i) += diagg(i) * vr - diabb(i) * vi;
  f(i) += diagg(i) * vi + diabb(i) * vr;
  goto statement_7370;
statement_7360:
  jj++;
statement_7370:
  if (jj >= kkk) {
    goto statement_7380;
  }
  j = iloc(jj);
  der = gndd(jj) * vr - bndd(jj) * vi;
  dei = gndd(jj) * vi + bndd(jj) * vr;
  e(j) += der;
  f(j) += dei;
  e(i) += gndd(jj) * solr(j) - bndd(jj) * soli(j);
  f(i) += gndd(jj) * soli(j) + bndd(jj) * solr(j);
  goto statement_7360;
statement_7380:
  i++;
  goto statement_7350;
statement_7390:
  i = ncurr + 1;
statement_7405:
  if (i > ntot) {
    goto statement_8888;
  }
  if (i == norder(1)) {
    goto statement_7440;
  }
  j = kode(i);
  if (j <= i) {
    goto statement_7410;
  }
  e(j) += e(i);
  f(j) += f(i);
  goto statement_7440;
  //C     BEGIN CALCULATION OF  P,Q,V FOR VOLTAGE SOURCES                   M36.1187
statement_7410:
  nekcc++;
  fxtem5(nekcc) = sqrtz(fem::pow2(solr(i)) + fem::pow2(soli(i)));
  fxtem4(nekcc) = 0.0f;
  if (fxtem5(nekcc) > 0.0f) {
    fxtem4(nekcc) = picon * std::atan2(soli(i), solr(i));
  }
  fxtem2(nekcc) = (solr(i) * e(i) + soli(i) * f(i)) * onehaf;
  fxtem3(nekcc) = (soli(i) * e(i) - solr(i) * f(i)) * onehaf;
  if (iprsup > 8) {
    write(lunit6, "(' BUS,P,Q,ANGLE,V(PEAK)',a6,2x,4e13.4)"), fxtem1(nekcc),
      fxtem2(nekcc), fxtem3(nekcc), fxtem4(nekcc), fxtem5(nekcc);
  }
statement_7440:
  i++;
  goto statement_7405;
  //C     BEGIN TO CHECK P,Q,V, ANGLE, CORRECTION OF THEM                   M36.1200
statement_8888:
  nekstp = 1;
  ekitev = (nitera - nekite) * (nitera - nekite);
  ekfact = nitera * nitera;
  ekitev = ekitev / ekfact;
  ekfact = ekitev * cfitea;
  ekitev = ekitev * cfitev;
  FEM_DO_SAFE(i, 1, nkr) {
    psum = 0.0f;
    qsum = 0.0f;
    nekn1 = 0;
    FEM_DO_SAFE(k, 1, nekcc) {
      if (fxtem1(k) == fixbu1(i)) {
        goto statement_7171;
      }
      if (fxtem1(k) == fixbu2(i)) {
        goto statement_7171;
      }
      if (fxtem1(k) != fixbu3(i)) {
        goto statement_7030;
      }
    statement_7171:
      psum += fxtem2(k);
      qsum += fxtem3(k);
      nekn1++;
      if (nekn1 == 3) {
        goto statement_7272;
      }
    statement_7030:;
    }
    if (nekn1 != 0) {
      goto statement_7272;
    }
    write(lunit6,
      "(' ERROR IN TABLE, NODE NAME ON FIX SOURCE CARD',"
      "' DOES NOT FIT ANY NODE NAME ON SOURCE CARDS',/,' FIX SOURCE NUMBER',"
      "i4,' WILL BE IGNORED')"),
      i;
    goto statement_7010;
  statement_7272:
    if (iprsup >= 2) {
      write(lunit6, "(' FIX SOURCE, PSUM, QSUM :',i6,2x,2e13.4)"), i,
        psum, qsum;
    }
    fixb10(i) = psum;
    fixb11(i) = qsum;
    //C     DENOMINATOR IS CALCULATED                                         M36.1229
    //C     EKNOM1 = ONEHAF * ( ABSZ (PSUM) + ABSZ( FIXBU5(I) ) )             M39.1550
    //C     EKNOM2 = ONEHAF * ( ABSZ (QSUM) + ABSZ( FIXBU8(I) ) )             M39.1551
    ekdif1 = 0.0f;
    ekdif2 = 0.0f;
    if (nekfix(i) == 2) {
      goto statement_8110;
    }
    if (eknom1 < tolmat) {
      eknom1 = tolmat;
    }
    ekdif1 = (psum - fixbu5(i)) / eknom1;
    if (nekfix(i) == 1) {
      goto statement_8112;
    }
  statement_8110:
    ekdif2 = (qsum - fixbu8(i)) / eknom1;
    //C     THE RELATIVE DIFFERENCE CHECK FOR P AND Q                         M36.1240
  statement_8112:
    if (std::abs(ekdif1) <= ralchk && std::abs(ekdif2) <= ralchk) {
      goto statement_3434;
    }
    //C     THE ABSOLUTE DIFFERENCE CHECK FOR P AND Q                         M36.1243
    //C     IF ( ABSZ( PSUM - FIXBU5(I) )  .LT.  ABSCHK   .AND.               M39.1553
    //C    1  ABSZ(QSUM - FIXBU8(I)) .LT. ABSCHK )  GO TO 3434                M39.1554
    nekstp = 0;
    //C     CHANGE PEAK VOLTAGE AND ANGLE                                     M36.1247
  statement_3434:
    ekdif1 = ekdif1 * ekfact;
    if (ekdif1 > 1.0f) {
      ekdif1 = 1.0f;
    }
    if (ekdif1 < -1.0f) {
      ekdif1 = -1.0f;
    }
    ekdif2 = ekdif2 * ekitev;
    if (ekdif2 > 0.01f) {
      ekdif2 = 0.01f;
    }
    if (ekdif2 < -0.01f) {
      ekdif2 = -0.01f;
    }
    if (iprsup > 1) {
      write(lunit6, "('  VOLTAGE AND ANGLE CHANGE = ',2e20.6)"), ekdif1, ekdif2;
    }
    FEM_DO_SAFE(np, 1, 3) {
      switch (np) {
      case 1: goto statement_4141;
      case 2: goto statement_4242;
      case 3: goto statement_4343;
      default: break;
      }
    statement_4141:
      FEM_DO_SAFE(mm, 1, nekcc) {
        if (fxtem1(mm) == fixbu1(i)) {
          goto statement_8181;
        }
      }
      goto statement_7010;
    statement_4242:
      if (fixbu2(i) == blank) {
        goto statement_7010;
      }
      FEM_DO_SAFE(mm, 1, nekcc) {
        if (fxtem1(mm) == fixbu2(i)) {
          goto statement_8282;
        }
      }
      goto statement_7010;
    statement_4343:
      if (fixbu3(i) == blank) {
        goto statement_7010;
      }
      FEM_DO_SAFE(mm, 1, nekcc) {
        if (fxtem1(mm) == fixbu3(i)) {
          goto statement_8383;
        }
      }
      goto statement_7010;
    statement_8181:
      ekn1 = 0.0f;
    statement_6769:
      angel = fxtem4(mm) - ekdif1;
      if (angel <= fixbu6(i) && angel >= fixbu4(i)) {
        goto statement_6363;
      }
      ekdif1 = 0.1f * ekdif1;
      //C         From Ma Ren-ming.   Installed March, 1987.                    VAX.1225
      if (std::abs(ekdif1) > cmn.epsiln) {
        goto statement_6769;
      }
      ekdif1 = 0.0f;
      goto statement_6363;
    statement_8282:
      ekn1 = -120.0f;
      goto statement_6363;
    statement_8383:
      ekn1 = 120.0f;
    statement_6363:
      if (nekfix(i) == 2) {
        fxtem4(mm) = fixbu5(i) + ekn1;
      }
      if (nekfix(i) == 2) {
        goto statement_8400;
      }
      //C     CORRECTION OF ANGLES                                              M36.1267
      fxtem4(mm) = fxtem4(mm) - ekdif1;
      //C     VOLTAGE                                                           M36.1269
      if (nekfix(i) == 1) {
        fxtem5(mm) = fixbu8(i);
      }
      if (nekfix(i) == 1) {
        goto statement_8510;
      }
      //C     CORRECTION OF VOLTAGES                                            M36.1272
    statement_8400:
      fxtem5(mm) = fxtem5(mm) * (1.0f - ekdif2);
      //C     CHECK FOR MIN/MAX VOLTAGE                                         M36.1274
      if (fxtem5(mm) > fixbu9(i)) {
        fxtem5(mm) = fixbu9(i);
      }
      if (fxtem5(mm) < fixbu7(i)) {
        fxtem5(mm) = fixbu7(i);
      }
      //C     NEW VOLTAGE IS CALCULATED                                         M36.1277
    statement_8510:
      ekdgr = fxtem4(mm) / picon;
      nekn4 = kndex(mm);
      nekn4 = norder(nekn4);
      solrsv(nekn4) = fxtem5(mm) * cosz(ekdgr);
      solisv(nekn4) = fxtem5(mm) * sinz(ekdgr);
      nkode = kode(nekn4);
    statement_8585:
      if (nkode == nekn4) {
        goto statement_8787;
      }
      solrsv(nkode) = solrsv(nekn4);
      solisv(nkode) = solisv(nekn4);
      nkode = kode(nkode);
      goto statement_8585;
      //C     CALCULATION OF VOLTAGE CHANGE                                     M36.1289
    statement_8787:
      cchanr = solrsv(nekn4) - solr(nekn4);
      cchani = solisv(nekn4) - soli(nekn4);
      if (std::abs(cchani) > std::abs(cchanr)) {
        cchanr = cchani;
      }
      cchanr = cchanr * fxtem6(mm);
      if (std::abs(cchanr) <= std::abs(vdiff(npp))) {
        goto statement_7777;
      }
      vdiff(npp) = cchanr;
      jndex(npp) = i;
    statement_7777:
      if (iprsup >= 4) {
        write(lunit6,
          "(' BUSNAME,SOLR(NEKN4),SOLI(NEKN4)',a6,2e16.6,"
          "'   THE NEW VALUE IS ',2e16.6)"),
          fxtem1(mm), solr(nekn4), soli(nekn4), solrsv(nekn4), solisv(
            nekn4);
      }
    }
  statement_7010:;
  }
  if (nekstp == 1) {
    goto statement_2121;
  }
  if (nflknt > 0) {
    goto statement_2222;
  }
statement_2121:
  {
    write_loop wloop(cmn, lunit6, "('+VCHANG(K)= ',20f6.3)");
    FEM_DO_SAFE(k, 1, npp) {
      wloop, vdiff(k);
    }
  }
  if (npp < 20 && nekstp != 1) {
    goto statement_3476;
  }
  if (nnnout == 1) {
    {
      write_loop wloop(cmn, lunit6, "(' FIX SOURCE ',20i6)");
      FEM_DO_SAFE(k, 1, npp) {
        wloop, jndex(k);
      }
    }
  }
statement_3466:
  write(lunit6, "(1x)");
  npp = 0;
statement_3476:
  nflknt = nflout;
statement_2222:
  if (nekstp == 1) {
    goto statement_6789;
  }
  if (nekite >= nitera) {
    goto statement_8900;
  }
  nflknt = nflknt - 1;
  FEM_DO_SAFE(ip, 1, n14) {
    solr(ip) = solrsv(ip);
    soli(ip) = solisv(ip);
  }
  nekite++;
  npp++;
  i = ncurr;
statement_5510:
  if (i == 0) {
    goto statement_1000;
  }
  if (kode(i) > i) {
    goto statement_5560;
  }
  ii = index(i);
statement_5540:
  if (ii == index(i + 1)) {
    goto statement_5570;
  }
  j = iloc(ii);
  isubs1 = cmn.iofgnd + ii;
  isubs2 = cmn.iofbnd + ii;
  solr(i) = solr(i) - gnd(isubs1) * solr(j) + bnd(isubs2) * soli(j);
  soli(i) = soli(i) - gnd(isubs1) * soli(j) - bnd(isubs2) * solr(j);
  ii++;
  goto statement_5540;
statement_5560:
  j = kode(i);
  solr(i) = solr(j);
  soli(i) = soli(j);
statement_5570:
  i = i - 1;
  goto statement_5510;
statement_8900:
  write(lunit6,
    "(/,' WARNING : THE NUMBER OF LOAD-FLOW ITERATIONS',' EXCEEDS',i8,"
    "', BUT THE SOLUTION IS NOT CONVERGING',' TO THE DESIRED RESULT.',/,"
    "' THE ITERATION PROCESS WILL BE STOPPED AT THIS',"
    "' POINT TO CONTINUE WITH THE INITIALIZATION PROCESS.')"),
    nitera;
  //C     DONE WITH ALL ITERATIONS, REDEFINE VECTOR CREST AND TIME1         M37.3770
statement_6789:
  write(lunit6,
    "(/,' NUMBER OF LOAD FLOW ITERATIONS USED =',i5,"
    "'. STATUS OF THE SOURCES AFTER THE LAST',' ITERATION :')"),
    nekite;
  if (iprsup >= 1 || nprint == 1) {
    write(lunit6,
      "('  ROW  NODE   NAME',10x,'VOLTAGE',4x,'DEGREES',8x,'REAL POWER',3x,"
      "'REACTIVE POWER')");
  }
  FEM_DO_SAFE(m, 1, nkr) {
    bus1 = fixbu1(m);
    n = 1;
  statement_1199:
    if (bus1 == blank) {
      goto statement_3300;
    }
    FEM_DO_SAFE(j, 1, nekcc) {
      if (fxtem1(j) != bus1) {
        goto statement_3000;
      }
      i = kndex(j);
      FEM_DO_SAFE(nfix, 1, kconst) {
        if (fem::iabs(node(nfix)) == i) {
          goto statement_3939;
        }
      }
      goto statement_3000;
    statement_3939:
      crest(nfix) = fxtem5(j);
      time1(nfix) = fxtem4(j) / picon;
      if (iprsup < 9 && nprint != 1) {
        goto statement_3000;
      }
      if (n > 1) {
        goto statement_3739;
      }
      write(lunit6, format_3500), nfix, i, bus(i), crest(nfix),
        fxtem4(j), fixb10(m), fixb11(m);
      goto statement_3000;
    statement_3739:
      write(lunit6, format_3500), nfix, i, bus(i), crest(nfix), fxtem4(j);
    statement_3000:;
    }
    switch (n) {
    case 1: goto statement_2345;
    case 2: goto statement_3456;
    case 3: goto statement_3300;
    default: break;
    }
  statement_2345:
    bus1 = fixbu2(m);
    n = 2;
    goto statement_1199;
  statement_3456:
    bus1 = fixbu3(m);
    n = 3;
    goto statement_1199;
  statement_3300:;
  }
  if (iprsup <= 0) {
    goto statement_9000;
  }
  runtym(cc1, cc2);
  write(lunit6, format_8484), cc1, cc2;
  if (iprsup <= 6) {
    goto statement_9000;
  }
  FEM_DO_SAFE(i, 1, kconst) {
    write(lunit6, "(/,' I,NODE(I),CREST(I),TIME1(I) ',2i4,2e18.6)"),
      i, node(i), crest(i), time1(i);
  }
statement_9000:
  if (iprsup >= 2) {
    write(lunit6, "(' EXIT FXSOUR = LOAD FLOW MODULE',/)");
  }

}

// FORM THE STEADY-STATE ADMITTANCE MATRIX (Y). SOLVE FOR
// STEADY-STATE PHASOR VOLTAGES.
void over10(
  common& cmn)
{
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  double& tolmat = cmn.tolmat;
  auto& twopi = cmn.twopi;
  double& omega = cmn.omega;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  auto& flstat = cmn.flstat;
  auto& lstat = cmn.lstat;
  int& istep = cmn.istep;
  int& lbus = cmn.lbus;
  int& lastov = cmn.lastov;
  int& nphcas = cmn.nphcas;
  int& numsub = cmn.numsub;
  int& iofgnd = cmn.iofgnd;
  int& iofbnd = cmn.iofbnd;
  int& ncurr = cmn.ncurr;
  int& ioffd = cmn.ioffd;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& it = cmn.it;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  const auto& loopss = cmn.loopss;
  const auto& xoptbr = cmn.xoptbr;
  const auto& coptbr = cmn.coptbr;
  const auto& c = cmn.c;
  const auto& r = static_cast<common_c0b064&>(cmn).r;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  const auto& nr = cmn.nr;
  const auto& length = cmn.length;
  const auto& ksub = cmn.ksub;
  const auto& msub = cmn.msub;
  const auto& isubeg = cmn.isubeg;
  const auto& imodel = cmn.imodel;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& kodsem = cmn.kodsem;
  const auto& iform = cmn.iform;
  auto& node = cmn.node;
  const auto& crest = cmn.crest;
  const auto& time1 = cmn.time1;
  const auto& tstart = cmn.tstart;
  const auto& sfreq = cmn.sfreq;
  auto& tclose = cmn.tclose;
  auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  const auto& kssfrq = cmn.kssfrq;
  auto& kode = cmn.kode;
  const auto& volti = static_cast<common_c0b123&>(cmn).volti;
  auto& voltk = static_cast<common_c0b124&>(cmn).voltk;
  auto& volt = cmn.volt;
  const auto& bus = cmn.bus;
  const auto& norder = cmn.norder;
  const auto& index = cmn.index;
  auto& diag = cmn.diag;
  auto& diab = cmn.diab;
  auto& bnd = cmn.bnd;
  auto& gnd = cmn.gnd;
  auto& solr = cmn.solr;
  auto& soli = cmn.soli;
  auto& iloc = cmn.iloc;
  //
  auto& lunit6 = cmn.lunit6;
  int n14 = fem::int0;
  int ia = fem::int0;
  int ib = fem::int0;
  int ic = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int ikf = fem::int0;
  int isfd = fem::int0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  double omltem = fem::double0;
  double omctem = fem::double0;
  int n16 = fem::int0;
  double omegal = fem::double0;
  double omegac = fem::double0;
  int ig = fem::int0;
  double rr = fem::double0;
  int in = fem::int0;
  int im = fem::int0;
  double xx = fem::double0;
  double dd = fem::double0;
  double gg = fem::double0;
  double bb = fem::double0;
  int isubs1 = fem::int0;
  int is = fem::int0;
  int nt = fem::int0;
  int jt = fem::int0;
  int k = fem::int0;
  int m = fem::int0;
  int n = fem::int0;
  int L = fem::int0;
  double cz = fem::double0;
  double azr = fem::double0;
  double azi = fem::double0;
  int lk = fem::int0;
  int lb = fem::int0;
  int kb = fem::int0;
  int ka = fem::int0;
  double xa = fem::double0;
  int js = fem::int0;
  int ne = fem::int0;
  int ja = fem::int0;
  double xr = fem::double0;
  double xi = fem::double0;
  int la = fem::int0;
  int ll = fem::int0;
  double vr = fem::double0;
  double vi = fem::double0;
  int ke = fem::int0;
  double xtr = fem::double0;
  double xti = fem::double0;
  int je = fem::int0;
  int ky = fem::int0;
  int jc = fem::int0;
  int lc = fem::int0;
  int kkk = fem::int0;
  double vvr = fem::double0;
  double vvi = fem::double0;
  int ii = fem::int0;
  int iendd = fem::int0;
  int na1 = fem::int0;
  int na2 = fem::int0;
  int nb1 = fem::int0;
  int nb2 = fem::int0;
  int mna1b1 = fem::int0;
  int mxa1b1 = fem::int0;
  int mna1b2 = fem::int0;
  int mxa1b2 = fem::int0;
  int mna2b1 = fem::int0;
  int mxa2b1 = fem::int0;
  int mna2b2 = fem::int0;
  int mxa2b2 = fem::int0;
  int locy11 = fem::int0;
  int ix = fem::int0;
  int nrow1 = fem::int0;
  int nnpos = fem::int0;
  int ix2 = fem::int0;
  int ixx = fem::int0;
  int nrow2 = fem::int0;
  int istart = fem::int0;
  int istop = fem::int0;
  int iy = fem::int0;
  int n3 = fem::int0;
  int n12 = fem::int0;
  int n15 = fem::int0;
  int il = fem::int0;
  int mk = fem::int0;
  int kmm = fem::int0;
  int itp = fem::int0;
  int n7 = fem::int0;
  double d8 = fem::double0;
  int n10 = fem::int0;
  int n5 = fem::int0;
  int isubs2 = fem::int0;
  int isubs3 = fem::int0;
  int isubs4 = fem::int0;
  int jj = fem::int0;
  int nl = fem::int0;
  int n13 = fem::int0;
  double so = fem::double0;
  double yy = fem::double0;
  int n23 = fem::int0;
  double gj = fem::double0;
  double bj = fem::double0;
  int ik = fem::int0;
  int jk = fem::int0;

  static const char* format_4568 = "('  \"EXIT  MODULE OVER10.\"')";

  auto itemp = ArraySpan(reinterpret_cast<int*>(&voltk(1)), voltk.size()*2);
  arr<int, 2> locatn(dimension(1000, 1000), fem::fill0);
  int i = 1;
  int j = 1;
  locatn(i, j) = (j * j - j) / 2 + i;
  if (iprsup >= 1) {
    write(lunit6,
      "(' TOP OF \"OVER10\".   NTOT, IOFFD, LOOPSS(2) =',2i8)"),
      ntot, ioffd, loopss(2);
  }
  n14 = ntot + loopss(2);
  move0(solr, n14);
  //C 3456789012345678901234567890123456789012345678901234567890123456789012M44. 732
  move0(soli, n14);
  FEM_DO_SAFE(i, 1, ntot) {
    ia = index(i);
    lstat(52) = ia;
    goto statement_3003;
  statement_3002:
    ia++;
    lstat(52) = ia;
  statement_3003:
    if (ia == index(i + 1)) {
      goto statement_3009;
    }
    ib = iloc(ia);
    ic = ia;
  statement_3005:
    ic++;
    if (ic == index(i + 1)) {
      goto statement_3002;
    }
    if (ib <= iloc(ic)) {
      goto statement_3005;
    }
    iloc(ia) = iloc(ic);
    iloc(ic) = ib;
    ib = iloc(ia);
    goto statement_3005;
  statement_3009:;
  }
  n1 = 1 + iofgnd;
  n2 = 1 + iofbnd;
  move0(gnd, n1, ioffd);
  move0(bnd, n2, ioffd);
  move0(diag, ntot);
  move0(diab, ntot);
  ia = ntot;
  lstat(52) = ia;
  if (ia < ibr) {
    ia = ibr;
  }
  if (ia < it) {
    ia = it;
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,/,' ARRAYS AT BEGINNING OF  OVER10 .',/,5x,'ROW',2x,'NORDER',3x,"
        "'INDEX',4x,'ILOC',4x,'KBUS',4x,'KODE',4x,'MBUS',6x,'NR',2x,'KODEBR',"
        "2x,'LENGTH',13x,'TR',13x,'TX',14x,'C',/(10i8,3e15.4))");
      FEM_DO_SAFE(i, 1, ia) {
        wloop, i, norder(i), index(i), iloc(i), kbus(i), kode(i),
          mbus(i), nr(i), kodebr(i), length(i), tr(i), tx(i), c(i);
      }
    }
  }
  //C     INITIALIZE COUNTERS FOR THE -666 BRANCHES  * * * * * * * * * * * *M32.3320
  ikf = 0;
  isfd = 0;
  i = 1;
  //C                                                                       M44. 734
  //C                        Beginning of bulding [y] from very first branchM44. 735
  //C                                                                       M44. 736
statement_3080:
  ic = fem::iabs(kbus(i));
  xopt = xoptbr(i);
  copt = coptbr(i);
  d3 = cmn.tenm3;
  d4 = cmn.unity / 1000000.f;
  if (xopt > 0.0f) {
    d3 = 1.0f / (twopi * xopt);
  }
  if (copt > 0.0f) {
    d4 = d4 / (twopi * copt);
  }
  omltem = d3 * twopi;
  omctem = d4 * twopi;
  if (ic == 1) {
    ic = fem::iabs(mbus(i));
  }
  n16 = fem::iabs(kssfrq(ic));
  omegal = omltem * sfreq(n16);
  omegac = omctem * sfreq(n16);
  omega = twopi * sfreq(n16);
  if (iprsup >= 3) {
    write(lunit6,
      "(' NEXT BRANCH.   I, IC, N16, OMEGA, OMEGAL,',' OMEGAC =',3i6,3e15.6)"),
      i, ic, n16, omega, omegal, omegac;
  }
  if (iprsup >= 1) {
    write(lunit6, star), " BND(1) =", bnd(1);
  }
  if (kodsem(i) == 0 && imodel(i) == 0) {
    goto statement_5698;
  }
  if (imodel(i) == -4) {
    omegac = 1.0f;
  }
  if (kodebr(i) == -2 && kodsem(i) == 0) {
    goto statement_43400;
  }
  if (kodebr(i) == -2 && imodel(i) == -2) {
    goto statement_43400;
  }
statement_5698:
  if (fem::iabs(length(i)) > 1) {
    goto statement_3300;
  }
  ic = fem::iabs(kbus(i));
  ic = norder(ic);
  ig = fem::iabs(mbus(i));
  ig = norder(ig);
  j = fem::iabs(nr(i));
  rr = tr(j);
  if (ic > ig) {
    goto statement_3130;
  }
  if (ic < ig) {
    goto statement_3120;
  }
  if (kbus(i) == 1) {
    goto statement_3283;
  }
  lstat(19) = 3112;
  lstat(15) = i;
  n1 = fem::iabs(kbus(i));
  bus1 = bus(n1);
statement_3112:
  kill = 17;
  goto statement_9999;
statement_3120:
  in = ig;
  im = ic;
  goto statement_3140;
statement_3130:
  in = ic;
  im = ig;
statement_3140:
  ia = index(im);
  lstat(52) = ia;
  if (nr(i) >= 0) {
    goto statement_3220;
  }
  if (c(j) == 0.0f) {
    goto statement_3164;
  }
  xx = tx(j) * omegal - 1.0f / (c(j) * omegac);
  goto statement_3168;
statement_3164:
  xx = tx(j) * omegal;
statement_3168:
  dd = rr * rr + xx * xx;
  gg = rr / dd;
  bb = -xx / dd;
  goto statement_3180;
statement_3170:
  ia++;
  lstat(52) = ia;
statement_3180:
  if (ia < index(im + 1)) {
    goto statement_3200;
  }
  lstat(19) = 3180;
  goto statement_3112;
statement_3200:
  if (iloc(ia) != in) {
    goto statement_3170;
  }
  isubs1 = iofgnd + ia;
  gnd(isubs1) = gnd(isubs1) - gg;
  isubs1 = iofbnd + ia;
  bnd(isubs1) = bnd(isubs1) - bb;
  goto statement_3280;
statement_3220:
  xx = tx(j) * omegal;
  gg = rr;
  bb = xx;
  if (imodel(i) == -4) {
    goto statement_3240;
  }
  dd = rr * rr + xx * xx;
  gg = rr / dd;
  bb = -xx / dd;
  goto statement_3240;
statement_3230:
  ia++;
  lstat(52) = ia;
statement_3240:
  if (ia < index(im + 1)) {
    goto statement_3260;
  }
  lstat(19) = 3240;
  goto statement_3112;
statement_3260:
  if (iloc(ia) != in) {
    goto statement_3230;
  }
  isubs1 = iofgnd + ia;
  gnd(isubs1) = gnd(isubs1) - gg;
  isubs1 = iofbnd + ia;
  bnd(isubs1) = bnd(isubs1) - bb;
  bb += c(j) * omegac;
  if (kbus(i) < 0) {
    gg += r(j);
  }
statement_3280:
  diag(im) += gg;
  diab(im) += bb;
  diag(in) += gg;
  diab(in) += bb;
statement_3283:
  i++;
  goto statement_3490;
statement_3300:
  is = fem::iabs(nr(i));
  nt = fem::iabs(length(i));
  if (length(i) < 0) {
    goto statement_3320;
  }
  jt = nt * (nt + 1) / 2;
  if (kodebr(i) <= 0) {
    goto statement_3515;
  }
  if (kodsem(i) != 0 && imodel(i) != -2) {
    goto statement_3515;
  }
  if (jt <= lbus) {
    goto statement_3504;
  }
  kill = 51;
  k = fem::iabs(kbus(i));
  m = fem::iabs(mbus(i));
  lstat(19) = 3504;
  bus1 = bus(k);
  bus2 = bus(m);
  lstat(14) = nt;
  goto statement_9999;
  //C        For case of [A], [B], 1st form unsymmetric  [Q] = -[B] + jw[U]:M44. 749
statement_3504:
  mover(tr(is), f(1), jt);
  n = is + jt - 1;
  FEM_DO_SAFE(j, is, n) {
    tr(j) = -tx(j);
  }
  move0(tx, is, jt);
  addmxd(tx(is), omega, tx(is), nt);
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' AT 3505.   CMR +J CMI BEFORE INVERSION',/(1x,8e16.6))");
      FEM_DO_SAFE(j, is, n) {
        wloop, tr(j), tx(j);
      }
    }
  }
statement_3515:
  L = is;
  m = 1;
  n = 1;
  if (imodel(i) == -3 || imodel(i) == -4) {
    goto statement_3320;
  }
  //C     CHECK FOR THE PRESENCE OF THE  -666 BRANCHES *   *   *   *   *   *M32.3324
  if (length(i + 1) != -666) {
    goto statement_10;
  }
  sseqiv(cmn, ikf, isfd, omegal, omegac);
  //C     CONVERT MODAL DATA TO PHASE COORDINATES  *   *   *   *   *   *   *M32.3327
  cz = nt;
  azr = (volti(1) - volti(2)) / cz;
  azi = (voltk(1) - voltk(2)) / cz;
  lk = L;
  lb = L;
  kb = 1;
  //C     LOAD EQIVALENT IMPEDANCE INTO THE TR AND TX TABLES   *   *   *   *M32.3334
  FEM_DO_SAFE(ka, 1, jt) {
    tr(lk) = azr;
    tx(lk) = azi;
    if (lb != lk) {
      goto statement_2;
    }
    tr(lb) += volti(2);
    tx(lb) += voltk(2);
    kb++;
    lb += kb;
  statement_2:
    lk++;
  }
statement_10:
  FEM_DO_SAFE(j, 1, jt) {
    if (kodebr(i) <= 0) {
      tx(L) = tx(L) * omegal;
    }
    if (kodsem(i) != 0 && imodel(i) != -2) {
      tx(L) = tx(L) * omegal;
    }
    if (iprsup >= 3) {
      write(lunit6, "(' AT 3524 ',5i10,2e20.8)"), i, kbus(i), mbus(i),
        j, L, tr(L), tx(L);
    }
    if (j != n) {
      goto statement_3530;
    }
    e(m) = fem::pow2(tr(L)) + fem::pow2(tx(L));
    m++;
    n += m;
  statement_3530:
    L++;
  }
  xa = tr(is) * tr(is) + tx(is) * tx(is);
  if (xa > tolmat* e(1)) {
    goto statement_3570;
  }
  n = 1;
statement_3560:
  kill = 18;
  lstat(19) = 3560;
  n1 = fem::iabs(kbus(i));
  n2 = fem::iabs(mbus(i));
  lstat(14) = nt;
  bus1 = bus(n1);
  bus2 = bus(n2);
  flstat(13) = tolmat;
  flstat(12) = xa;
  flstat(11) = e(n);
  goto statement_9999;
statement_3570:
  tr(is) = tr(is) / xa;
  tx(is) = -tx(is) / xa;
  if (nt <= 1) {
    goto statement_3320;
  }
  js = is;
  ne = is;
  n1 = is + jt - 1;
  FEM_DO_SAFE(n, 2, nt) {
    FEM_DO_SAFE(m, 1, n) {
      js++;
      solr(m) = tr(js);
      soli(m) = tx(js);
    }
    m = n - 1;
    j = 1;
    ja = is - 1;
  statement_3650:
    k = ja;
    xr = 0.0f;
    xi = 0.0f;
    la = 0;
    FEM_DO_SAFE(L, 1, j) {
      k++;
      la++;
      xr += solr(la) * tr(k) - soli(la) * tx(k);
      xi += solr(la) * tx(k) + soli(la) * tr(k);
    }
    k += j;
    if (m == j) {
      goto statement_3760;
    }
    ja += j;
    j++;
    FEM_DO_SAFE(ll, j, m) {
      la++;
      xr += solr(la) * tr(k) - soli(la) * tx(k);
      xi += soli(la) * tr(k) + solr(la) * tx(k);
      k += ll;
    }
    tr(k) = xr;
    tx(k) = xi;
    goto statement_3650;
  statement_3760:
    tr(k) = xr;
    tx(k) = xi;
    vr = 0.0f;
    vi = 0.0f;
    ke = ne;
    FEM_DO_SAFE(lb, 1, m) {
      ke++;
      vr += solr(lb) * tr(ke) - soli(lb) * tx(ke);
      vi += solr(lb) * tx(ke) + soli(lb) * tr(ke);
    }
    xr = solr(m + 1) - vr;
    xi = soli(m + 1) - vi;
    xa = xr * xr + xi * xi;
    if (xa < tolmat * e(n)) {
      goto statement_3560;
    }
    xtr = xr / xa;
    xti = -xi / xa;
    je = ne;
    ne += n;
    ky = ne;
    tr(ne) = xtr;
    tx(ne) = xti;
    FEM_DO_SAFE(jc, 1, m) {
      lc = n - jc;
      ky = ky - 1;
      kkk = ky;
      vvr = xtr * tr(ky) - xti * tx(ky);
      vvi = xtr * tx(ky) + xti * tr(ky);
      FEM_DO_SAFE(ic, 1, lc) {
        tr(je) += tr(kkk) * vvr - tx(kkk) * vvi;
        tx(je) += tr(kkk) * vvi + tx(kkk) * vvr;
        je = je - 1;
        kkk = kkk - 1;
      }
      tr(ky) = -vvr;
      tx(ky) = -vvi;
    }
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6, "(/,' AT 3897 ',i10,/(1x,8e15.6))");
        wloop, is;
        FEM_DO_SAFE(jc, is, n1) {
          wloop, tr(jc), tx(jc);
        }
      }
    }
  }
  if (kodebr(i) <= 0) {
    goto statement_3320;
  }
  if (kodsem(i) != 0 && imodel(i) != -2) {
    goto statement_3320;
  }
  ll = is + jt - 1;
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' AT 3506.   CMR +J CMI AFTER  INVERSION',/(1x,8e16.6))");
      FEM_DO_SAFE(j, is, ll) {
        wloop, tr(j), tx(j);
      }
    }
  }
  multmx(tr(is), f(1), e(1), solr(1), nt);
  mover(e(1), tr(is), jt);
  multmx(tx(is), f(1), e(1), solr(1), nt);
  mover(e(1), tx(is), jt);
  L = is + jt - 1;
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' AT 3511.   FINAL Y-BRANCH IN TR, TX',/,9x,'J',15x,'TR(J)',15x,"
        "'TX(J)',/(1x,i9,2e20.8))");
      FEM_DO_SAFE(j, is, L) {
        wloop, j, tr(j), tx(j);
      }
    }
  }
  //C                                                                       M44. 754
  //C                      Beginning of Multi-phase branches                M44. 755
  //C                                                                       M44. 756
statement_3320:
  k = is - 1;
  ii = i;
  iendd = i + nt;
statement_3330:
  na1 = fem::iabs(kbus(i));
  na1 = norder(na1);
  na2 = fem::iabs(mbus(i));
  na2 = norder(na2);
  j = ii;
  goto statement_3440;
statement_3430:
  j++;
statement_3440:
  k++;
  if (j == i) {
    goto statement_3340;
  }
  nb1 = fem::iabs(kbus(j));
  nb1 = norder(nb1);
  nb2 = fem::iabs(mbus(j));
  nb2 = norder(nb2);
  n1 = na1 - nb1;
  if (n1 > 0) {
    goto statement_4030;
  }
  if (n1 == 0) {
    goto statement_4020;
  }
  mna1b1 = na1;
  mxa1b1 = nb1;
  goto statement_4040;
statement_4020:
  diag(na1) += tr(k) * 2.0f;
  if (kbus(i) < 0) {
    diag(na1) += r(k) * 2.0f;
  }
  diab(na1) += tx(k) * 2.0f + c(k) * 2.0f * omegac;
  goto statement_4110;
statement_4030:
  mna1b1 = nb1;
  mxa1b1 = na1;
statement_4040:
  L = index(mna1b1);
  goto statement_4060;
statement_4050:
  L++;
statement_4060:
  if (L < index(mna1b1 + 1)) {
    goto statement_4080;
  }
  kill = 19;
  lstat(19) = 4080;
  goto statement_9999;
statement_4080:
  m = iloc(L);
  if (m != mxa1b1) {
    goto statement_4050;
  }
  isubs1 = iofgnd + L;
  gnd(isubs1) += tr(k);
  isubs1 = iofbnd + L;
  bnd(isubs1) += tx(k) + c(k) * omegac;
  isubs1 = iofgnd + L;
  if (kbus(i) < 0) {
    gnd(isubs1) += r(k);
  }
  if (iprsup >= 1) {
    write(lunit6, star), " Below 4080. L, BND(ISUBS1) =", L, bnd(isubs1);
  }
statement_4110:
  n1 = na1 - nb2;
  if (n1 > 0) {
    goto statement_4140;
  }
  if (n1 == 0) {
    goto statement_4130;
  }
  mna1b2 = na1;
  mxa1b2 = nb2;
  goto statement_4150;
statement_4130:
  diag(na1) = diag(na1) - tr(k) * 2.0f;
  diab(na1) = diab(na1) - tx(k) * 2.0f;
  goto statement_4220;
statement_4140:
  mna1b2 = nb2;
  mxa1b2 = na1;
statement_4150:
  L = index(mna1b2);
  goto statement_4170;
statement_4160:
  L++;
statement_4170:
  if (L < index(mna1b2 + 1)) {
    goto statement_4190;
  }
  lstat(19) = 4170;
  goto statement_3112;
statement_4190:
  m = iloc(L);
  if (m != mxa1b2) {
    goto statement_4160;
  }
  isubs1 = iofgnd + L;
  gnd(isubs1) = gnd(isubs1) - tr(k);
  isubs1 = iofbnd + L;
  bnd(isubs1) = bnd(isubs1) - tx(k);
  if (iprsup >= 1) {
    write(lunit6, star), " Below 4190.   L, BND(ISUBS1) =", L, bnd(isubs1);
  }
statement_4220:
  n1 = na2 - nb1;
  if (n1 > 0) {
    goto statement_4250;
  }
  if (n1 == 0) {
    goto statement_4240;
  }
  mna2b1 = na2;
  mxa2b1 = nb1;
  goto statement_4260;
statement_4240:
  diag(na2) = diag(na2) - tr(k) * 2.0f;
  diab(na2) = diab(na2) - tx(k) * 2.0f;
  goto statement_4330;
statement_4250:
  mna2b1 = nb1;
  mxa2b1 = na2;
statement_4260:
  L = index(mna2b1);
  goto statement_4280;
statement_4270:
  L++;
statement_4280:
  if (L < index(mna2b1 + 1)) {
    goto statement_4300;
  }
  lstat(19) = 4280;
  goto statement_3112;
statement_4300:
  m = iloc(L);
  if (m != mxa2b1) {
    goto statement_4270;
  }
  isubs1 = iofgnd + L;
  gnd(isubs1) = gnd(isubs1) - tr(k);
  isubs1 = iofbnd + L;
  bnd(isubs1) = bnd(isubs1) - tx(k);
  if (iprsup >= 1) {
    write(lunit6, star), " Below 4300.   L, BND(ISUBS1) =", L, bnd(isubs1);
  }
statement_4330:
  n1 = na2 - nb2;
  if (n1 > 0) {
    goto statement_4360;
  }
  if (n1 == 0) {
    goto statement_4350;
  }
  mna2b2 = na2;
  mxa2b2 = nb2;
  goto statement_4370;
statement_4350:
  diag(na2) += tr(k) * 2.0f;
  if (kbus(i) < 0) {
    diag(na2) += r(k) * 2.0f;
  }
  diab(na2) += tx(k) * 2.0f + c(k) * 2.0f * omegac;
  goto statement_3430;
statement_4360:
  mna2b2 = nb2;
  mxa2b2 = na2;
statement_4370:
  L = index(mna2b2);
  goto statement_4390;
statement_4380:
  L++;
statement_4390:
  if (L < index(mna2b2 + 1)) {
    goto statement_4410;
  }
  kill = 20;
  lstat(19) = 4410;
  goto statement_9999;
statement_4410:
  m = iloc(L);
  if (m != mxa2b2) {
    goto statement_4380;
  }
  isubs1 = iofgnd + L;
  gnd(isubs1) += tr(k);
  isubs1 = iofbnd + L;
  bnd(isubs1) += tx(k) + c(k) * omegac;
  isubs1 = iofgnd + L;
  if (kbus(i) < 0) {
    gnd(isubs1) += r(k);
  }
  if (iprsup >= 1) {
    write(lunit6, star), " Below 4410.   L, BND(ISUBS1) =", L, bnd(isubs1);
  }
  if (iprsup >= 1 && L == 1) {
    write(lunit6, star), " k, tx(k), c(k), omegac =", k, tx(k), c(k), omegac;
  }
  goto statement_3430;
  //C                                                      end of [y] budingM44. 761
statement_3340:
  n1 = na2 - na1;
  if (n1 > 0) {
    goto statement_3360;
  }
  if (n1 < 0) {
    goto statement_3370;
  }
  lstat(19) = 3360;
  goto statement_3112;
statement_3360:
  in = na2;
  im = na1;
  goto statement_3380;
statement_3370:
  in = na1;
  im = na2;
statement_3380:
  ia = index(im);
  lstat(52) = ia;
  gg = tr(k);
  bb = tx(k);
  goto statement_3400;
statement_3390:
  ia++;
  lstat(52) = ia;
statement_3400:
  if (ia < index(im + 1)) {
    goto statement_3410;
  }
  lstat(19) = 3400;
  goto statement_3112;
statement_3410:
  if (iloc(ia) != in) {
    goto statement_3390;
  }
  isubs1 = iofgnd + ia;
  gnd(isubs1) = gnd(isubs1) - gg;
  isubs1 = iofbnd + ia;
  bnd(isubs1) = bnd(isubs1) - bb;
  bb += c(k) * omegac;
  if (kbus(i) < 0) {
    gg += r(k);
  }
  diag(im) += gg;
  diab(im) += bb;
  diag(in) += gg;
  diab(in) += bb;
  i++;
  if (i < iendd) {
    goto statement_3330;
  }
  goto statement_3490;
  //C                                                                       M44. 762
  //C                                                                       M44. 763
statement_43400:
  nphcas = fem::iabs(length(i));
  locy11 = nr(i) - 1;
  FEM_DO_SAFE(ix, 1, nphcas) {
    n1 = ix + i - 1;
    nrow1 = kbus(n1);
    nrow1 = norder(nrow1);
    nnpos = locatn(ix, ix) + locy11;
    diag(nrow1) += tr(nnpos);
    diab(nrow1) += tx(nnpos);
    ix2 = ix + 1;
    if (ix2 > nphcas) {
      goto statement_43430;
    }
    FEM_DO_SAFE(ixx, ix2, nphcas) {
      n2 = ixx + i - 1;
      nrow2 = kbus(n2);
      nrow2 = norder(nrow2);
      if (nrow1 > nrow2) {
        goto statement_43420;
      }
      istart = index(nrow1);
      istop = index(nrow1 + 1) - 1;
      FEM_DO_SAFE(iy, istart, istop) {
        if (nrow2 == iloc(iy)) {
          goto statement_43404;
        }
      }
    statement_43420:
      istart = index(nrow2);
      istop = index(nrow2 + 1) - 1;
      FEM_DO_SAFE(iy, istart, istop) {
        if (nrow1 == iloc(iy)) {
          goto statement_43404;
        }
      }
    statement_43404:
      nnpos = locatn(ix, ixx) + locy11;
      isubs1 = iofgnd + iy;
      gnd(isubs1) += tr(nnpos);
      isubs1 = iofbnd + iy;
      bnd(isubs1) += tx(nnpos);
    }
  statement_43430:
    FEM_DO_SAFE(ixx, 1, nphcas) {
      n3 = ixx + i - 1;
      nrow2 = mbus(n3);
      nrow2 = norder(nrow2);
      if (nrow1 > nrow2) {
        goto statement_43412;
      }
      istart = index(nrow1);
      istop = index(nrow1 + 1) - 1;
      FEM_DO_SAFE(iy, istart, istop) {
        if (nrow2 == iloc(iy)) {
          goto statement_43406;
        }
      }
    statement_43412:
      istart = index(nrow2);
      istop = index(nrow2 + 1) - 1;
      FEM_DO_SAFE(iy, istart, istop) {
        if (nrow1 == iloc(iy)) {
          goto statement_43406;
        }
      }
    statement_43406:
      nnpos = locatn(ix, ixx + nphcas) + locy11;
      isubs1 = iofgnd + iy;
      gnd(isubs1) += tr(nnpos);
      isubs1 = iofbnd + iy;
      bnd(isubs1) += tx(nnpos);
    }
  }
  FEM_DO_SAFE(ix, 1, nphcas) {
    n1 = ix + i - 1;
    nrow1 = mbus(n1);
    nrow1 = norder(nrow1);
    nnpos = locatn(ix + nphcas, ix + nphcas) + locy11;
    diag(nrow1) += tr(nnpos);
    diab(nrow1) += tx(nnpos);
    ix2 = ix + 1;
    if (ix2 > nphcas) {
      goto statement_43407;
    }
    FEM_DO_SAFE(ixx, ix2, nphcas) {
      n2 = ixx + i - 1;
      nrow2 = mbus(n2);
      nrow2 = norder(nrow2);
      if (nrow1 > nrow2) {
        goto statement_43415;
      }
      istart = index(nrow1);
      istop = index(nrow1 + 1) - 1;
      FEM_DO_SAFE(iy, istart, istop) {
        if (nrow2 == iloc(iy)) {
          goto statement_43409;
        }
      }
    statement_43415:
      istart = index(nrow2);
      istop = index(nrow2 + 1) - 1;
      FEM_DO_SAFE(iy, istart, istop) {
        if (nrow1 == iloc(iy)) {
          goto statement_43409;
        }
      }
    statement_43409:
      nnpos = locatn(ix + nphcas, ixx + nphcas) + locy11;
      isubs1 = iofgnd + iy;
      gnd(isubs1) += tr(nnpos);
      isubs1 = iofbnd + iy;
      bnd(isubs1) += tx(nnpos);
    }
  statement_43407:;
  }
  i += nphcas;
statement_3490:
  if (i <= ibr) {
    goto statement_3080;
  }
  //C                                                                       M44. 764
  //C                                                    end of [y] buildingM44. 765
  //C                                                                       M44. 766
  FEM_DO_SAFE(i, 1, ntot) {
    e(i) = fem::pow2(diag(i)) + fem::pow2(diab(i));
    if (kode(i) > 0) {
      kode(i) = -kode(i);
    }
  }
  n3 = 1;
  vecrsv(cmn, tclose(1), cmn.kswtch, n3);
  vecrsv(cmn, diag(1), ntot, n3);
  vecrsv(cmn, diab(1), ntot, n3);
  vecrsv(cmn, gnd(iofgnd + 1), ioffd, n3);
  vecrsv(cmn, bnd(iofbnd + 1), ioffd, n3);
  n12 = -4;
  n15 = 0;
  vecrsv(cmn, volt(1), n12, n15);
  if (iprsup < 3) {
    goto statement_4517;
  }
  write(lunit6,
    "(/,' Y-MATRIX OF S.S. PHASOR SOLUTION, B4 STARTING ELIMINATION.    NTOT, "
    "IOFFD = ',2i8,/,9x,'I',6x,'ILOC',5x,'INDEX',17x,'GND',17x,'BND',21x,"
    "'DIAG',16x,'DIAB')"),
    ntot, ioffd;
  n3 = ntot + 1;
  if (ioffd > n3) {
    n3 = ioffd;
  }
  n1 = iofgnd + 1;
  n2 = iofbnd + 1;
  FEM_DO_SAFE(i, 1, n3) {
    write(lunit6, "(3i10,2e20.8,5x,2e20.8)"), i, iloc(i), index(i),
      gnd(n1), bnd(n2), diag(i), diab(i);
    n1++;
    n2++;
  }
statement_4517:
  FEM_DO_SAFE(i, 1, ntot) {
    if (kode(i) > 0) {
      goto statement_4570;
    }
    j = i;
    im = -kode(j);
  statement_4530:
    if (im > 0) {
      in = norder(im);
    }
    il = norder(j);
    if (im == 0) {
      in = il;
    }
    im = -kode(il);
    kode(il) = in;
    j = il;
    if (j != i) {
      goto statement_4530;
    }
  statement_4570:;
  }
  FEM_DO_SAFE(i, 1, ntot) {
    j = kode(i);
    if (j >= i) {
      goto statement_4820;
    }
  statement_4610:
    j = kode(j);
    n1 = j - i;
    if (n1 < 0) {
      goto statement_4610;
    }
    if (n1 == 0) {
      goto statement_4820;
    }
    j = i;
    k = 0;
  statement_4640:
    k++;
    if (k > cmn.lsiz26) {
      goto statement_4670;
    }
    itemp(k) = j;
    j = kode(j);
    if (j != i) {
      goto statement_4640;
    }
    if (k > 1) {
      goto statement_4680;
    }
    lstat(19) = 4670;
    goto statement_3112;
  statement_4670:
    kill = 21;
    lstat(19) = 4670;
    goto statement_9999;
  statement_4680:
    mk = k - 1;
    FEM_DO_SAFE(m, 1, mk) {
      kmm = k - m;
      FEM_DO_SAFE(n, 1, kmm) {
        n1 = itemp(n) - itemp(n + 1);
        if (n1 > 0) {
          goto statement_4740;
        }
        if (n1 < 0) {
          goto statement_4750;
        }
        lstat(19) = 4740;
        goto statement_3112;
      statement_4740:
        itp = itemp(n);
        itemp(n) = itemp(n + 1);
        itemp(n + 1) = itp;
      statement_4750:;
      }
    }
    j = itemp(1);
    FEM_DO_SAFE(m, 2, k) {
      L = itemp(m);
      kode(j) = L;
      j = L;
    }
    kode(j) = itemp(1);
  statement_4820:;
  }
  move0(solr, n14);
  move0(soli, n14);
  if (numsub <= 0) {
    goto statement_4905;
  }
  //C     ASSIGN UNIT CURRENT SOURCES TO BEGIN THEVENIN CALCULATION:        M31.2482
  if (iprsup >= 1) {
    write(lunit6,
      "(' BEGIN PHASOR THEVENIN CALCULATION.','   NUMSUB, ISUBEG(NUMSUB+1) =',"
      "2i6)"),
      numsub, isubeg(numsub + 1);
  }
  if (iprsup <= 1) {
    goto statement_4837;
  }
  {
    write_loop wloop(cmn, lunit6, "(' ISUBEG:',20i6)");
    FEM_DO_SAFE(i, 1, numsub) {
      wloop, isubeg(i);
    }
  }
  n1 = isubeg(numsub + 1) - 1;
  {
    write_loop wloop(cmn, lunit6, "(' KSUB:',20i6)");
    FEM_DO_SAFE(i, 1, n1) {
      wloop, ksub(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(' MSUB:',20i6)");
    FEM_DO_SAFE(i, 1, n1) {
      wloop, msub(i);
    }
  }
statement_4837:
  L = 1;
  FEM_DO_SAFE(n2, 1, numsub) {
    n1 = ntot;
    n7 = isubeg(n2 + 1);
  statement_4863:
    d8 = -1.0f;
    j = ksub(L);
    FEM_DO_SAFE(n10, 1, 2) {
      if (j == 1) {
        goto statement_4871;
      }
      n12 = norder(j);
      n5 = n12 + n1;
      solr(n5) = d8;
      if (iprsup >= 3) {
        write(lunit6,
          "(' THEVENIN SOURCE.  N5, J, N12, N2, L, D8 =',5i8,e14.3)"),
          n5, j, n12, n2, L, d8;
      }
    statement_4871:
      d8 = 1.0f;
      j = msub(L);
    }
    L++;
    if (L >= n7) {
      goto statement_4892;
    }
    n1 += ntot;
    goto statement_4863;
  statement_4892:;
  }
statement_4905:
  n1 = 2 * lbus;
  if (kconst == 0) {
    goto statement_4977;
  }
  FEM_DO_SAFE(i, 1, kconst) {
    j = node(i);
    if (fem::iabs(iform(i)) != 14) {
      goto statement_4976;
    }
    if (tstart(i) == 5432.f) {
      goto statement_4975;
    }
    if (tstart(i) >= 0.0f) {
      goto statement_4976;
    }
    if (j >= -n1) {
      goto statement_4975;
    }
    node(i) += n1;
    goto statement_4976;
  statement_4975:
    if (iform(i + 1) == 18) {
      j = time1(i + 1);
    }
    j = fem::iabs(j);
    j = norder(j);
    solr(j) += crest(i) * cosz(time1(i));
    soli(j) += crest(i) * sinz(time1(i));
    if (iprsup >= 5) {
      write(lunit6,
        "(/,' I,J,NODE(I),KODE(J),CREST(I),TIME1(I) ',4i4,2e18.6)"),
        i, j, node(i), kode(j), crest(i), time1(i);
    }
    if (iprsup >= 5) {
      write(lunit6, "(15i8)"), isubs1, isubs2, isubs3, isubs4, n1,
        n2, n3, ia, ja, ii, jj, kkk, iy, ib, ix;
    }
    if (j <= ncurr) {
      goto statement_4976;
    }
    k = kode(j);
  statement_4979:
    if (k == j) {
      goto statement_4976;
    }
    solr(k) = solr(j);
    soli(k) = soli(j);
    k = kode(k);
    goto statement_4979;
  statement_4976:;
  }
statement_4977:
  nl = 0;
statement_4972:
  n12 = nl + 1;
  n13 = nl + ntot;
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(' CELLS',i5,'   THROUGH',i5,"
        "'   OF RIGHT HAND SIDE VECTOR (COMPLEX) ....',/(1x,8e16.7))");
      wloop, n12, n13;
      FEM_DO_SAFE(i, n12, n13) {
        wloop, solr(i), soli(i);
      }
    }
  }
  nl += ntot;
  if (nl <= loopss(2)) {
    goto statement_4972;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (KODE(I), I=1, NTOT)   IN  ''OVER10''  JUST BEFORE BEGINNING NET"
        "WORK ELIMINATION ON STEADY-STATE  (Y) .',/(1x,20i6))");
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, kode(i);
      }
    }
  }
  i = 1;
  goto statement_5020;
statement_5010:
  nl = 0;
statement_5013:
  n12 = nl + i;
  so = solr(n12) * diag(i) - soli(n12) * diab(i);
  soli(n12) = solr(n12) * diab(i) + soli(n12) * diag(i);
  solr(n12) = so;
  nl += ntot;
  if (nl <= loopss(2)) {
    goto statement_5013;
  }
  i++;
statement_5020:
  if (i > ncurr) {
    goto statement_5500;
  }
  if (kode(i) > i) {
    goto statement_5170;
  }
  yy = diag(i) * diag(i) + diab(i) * diab(i);
  if (iprsup >= 6) {
    write(lunit6,
      "(' NEW ROW  I  OF STEADY-STATE ELIMINATION.',7x,'I',3x,'NCURR',4x,"
      "'INDEX(I)',2x,'INDEX(I+1)',8x,'DIAG(I)',8x,'DIAB(I)',/,41x,2i8,2i12,"
      "2e20.10)"),
      i, ncurr, index(i), index(i + 1), diag(i), diab(i);
  }
  if (yy > tolmat* e(i)) {
    goto statement_5045;
  }
  FEM_DO_SAFE(n23, 1, ntot) {
    if (norder(n23) == i) {
      goto statement_5043;
    }
  }
  kill = 22;
  lstat(19) = 5042;
  lstat(16) = i;
  goto statement_9999;
statement_5043:
  write(lunit6,
    "(/,' CAUTION. ---- DURING Y-MATRIX ELIMINATION FOR STEADY-STATE SOLUTION "
    "VOLTAGES, A NEAR-ZERO DIAGONAL ELEMENT',/,15x,'FOR NODE ''',a6,"
    "''' EXISTS JUST BEFORE RECIPROCATION.   USING MAGNITUDES SQUARED FOR ALL "
    "3 QUANTITIES, WE HAVE',/,15x,'ORIGINAL DIAGONAL VALUE =',e12.3,"
    "',   QUESTIONABLE VALUE =',e12.3,',   TOLERANCE RATIO =',e12.3,'.',/,15x,"
    "'THE NODE IN QUESTION MAY BE CONNECTED TO OTHER NODES, FORMING A SUBNETWO"
    "RK.   BUT THE SUBNETWORK HAS NO (OR')"),
    bus(n23), e(i), yy, tolmat;
  write(lunit6,
    "(15x,"
    "'VERY WEAK) PATH TO GROUND OR OTHER KNOWN-VOLTAGE NODE IN THE STEADY-STAT"
    "E.   SOLUTION VOLTAGES OF THIS',/,15x,"
    "'SUBNETWORK WILL ALL BE SET TO ZERO.')");
  if (solr(i) != 0.0f) {
    goto statement_5046;
  }
  if (soli(i) == 0.0f) {
    goto statement_5048;
  }
statement_5046:
  kill = 23;
  lstat(19) = 5046;
  bus1 = bus(n23);
  goto statement_9999;
statement_5048:
  diag(i) = 0.0f;
  diab(i) = 0.0f;
  goto statement_15045;
statement_5045:
  diag(i) = diag(i) / yy;
  diab(i) = -diab(i) / yy;
statement_15045:
  ii = index(i);
  goto statement_5060;
statement_5050:
  isubs1 = iofgnd + ii;
  gnd(isubs1) = gj;
  isubs1 = iofbnd + ii;
  bnd(isubs1) = bj;
  ii++;
statement_5060:
  if (ii == index(i + 1)) {
    goto statement_5010;
  }
  j = iloc(ii);
  isubs1 = iofgnd + ii;
  isubs2 = iofbnd + ii;
  gj = gnd(isubs1) * diag(i) - bnd(isubs2) * diab(i);
  isubs1 = iofgnd + ii;
  isubs2 = iofbnd + ii;
  bj = gnd(isubs1) * diab(i) + bnd(isubs2) * diag(i);
  isubs1 = iofgnd + ii;
  isubs2 = iofbnd + ii;
  diag(j) = diag(j) - gj * gnd(isubs1) + bj * bnd(isubs2);
  isubs1 = iofgnd + ii;
  isubs2 = iofbnd + ii;
  diab(j) = diab(j) - gj * bnd(isubs2) - bj * gnd(isubs1);
  isubs1 = iofgnd + ii;
  isubs2 = iofbnd + ii;
  if (iprsup >= 20) {
    write(lunit6,
      "(/,' Y(I,J)/Y(I,I)   AND   Y(J,J) - Y(J,I)*(Y(I,J)/Y(I,I))   AT 5063.  "
      " I, II, J =',3i10,/,1x,8e16.6)"),
      i, ii, j, gj, bj, diag(i), diab(i), diag(j), diab(j), gnd(isubs1),
      bnd(isubs2);
  }
  if (j > ncurr) {
    goto statement_5072;
  }
  nl = 0;
statement_5068:
  n12 = nl + j;
  n13 = nl + i;
  solr(n12) = solr(n12) - gj * solr(n13) + bj * soli(n13);
  soli(n12) = soli(n12) - gj * soli(n13) - bj * solr(n13);
  nl += ntot;
  if (nl <= loopss(2)) {
    goto statement_5068;
  }
statement_5072:
  ja = index(j);
  ia = ii + 1;
  lstat(52) = ia;
statement_5080:
  if (ia == index(i + 1)) {
    goto statement_5050;
  }
  ik = iloc(ia);
  goto statement_5110;
statement_5100:
  ja++;
statement_5110:
  if (ja < index(j + 1)) {
    goto statement_5130;
  }
  lstat(19) = 5110;
  goto statement_3112;
statement_5130:
  jk = iloc(ja);
  if (ik != jk) {
    goto statement_5100;
  }
  isubs1 = iofgnd + ja;
  isubs2 = iofgnd + ia;
  isubs3 = iofbnd + ia;
  gnd(isubs1) = gnd(isubs1) - gj * gnd(isubs2) + bj * bnd(isubs3);
  isubs1 = iofbnd + ja;
  isubs2 = iofbnd + ia;
  isubs3 = iofgnd + ia;
  bnd(isubs1) = bnd(isubs1) - gj * bnd(isubs2) - bj * gnd(isubs3);
  isubs1 = iofgnd + ja;
  isubs2 = iofbnd + ja;
  isubs3 = iofgnd + ia;
  isubs4 = iofbnd + ia;
  if (iprsup >= 20) {
    write(lunit6, "(/,' AT 5134.   JA, JK, IA =',3i10,/,1x,4e20.6)"),
      ja, jk, ia, gnd(isubs1), bnd(isubs2), gnd(isubs3), bnd(isubs4);
  }
  ia++;
  lstat(52) = ia;
  ja++;
  goto statement_5080;
statement_5170:
  ii = index(i);
  j = kode(i);
  jj = index(j);
  goto statement_5190;
statement_5180:
  ii++;
statement_5190:
  if (ii >= index(i + 1)) {
    goto statement_5360;
  }
  ia = iloc(ii);
  lstat(52) = ia;
  n1 = ia - j;
  if (n1 > 0) {
    goto statement_5230;
  }
  if (n1 < 0) {
    goto statement_5300;
  }
  isubs1 = iofgnd + ii;
  diag(j) += diag(i) + 2.f * gnd(isubs1);
  isubs1 = iofbnd + ii;
  diab(j) += diab(i) + 2.f * bnd(isubs1);
  goto statement_5180;
statement_5230:
  if (jj < index(j + 1)) {
    goto statement_5250;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, "(/,' AT 5231 ',/(1x,10i12))");
      FEM_DO_SAFE(i, 1, 40) {
        wloop, index(i), iloc(i);
      }
    }
  }
  lstat(19) = 5231;
  goto statement_3112;
statement_5250:
  ja = iloc(jj);
  if (ia == ja) {
    goto statement_5290;
  }
  jj++;
  goto statement_5230;
statement_5290:
  isubs1 = iofgnd + jj;
  isubs2 = iofgnd + ii;
  gnd(isubs1) += gnd(isubs2);
  isubs1 = iofbnd + jj;
  isubs2 = iofbnd + ii;
  bnd(isubs1) += bnd(isubs2);
  jj++;
  goto statement_5180;
statement_5300:
  kkk = index(ia);
  goto statement_5320;
statement_5310:
  kkk++;
  if (kkk < index(ia + 1)) {
    goto statement_5320;
  }
  kill = 24;
  lstat(19) = 5320;
  lstat(16) = kkk;
  lstat(15) = ia;
  lstat(14) = index(ia + 1);
  goto statement_9999;
statement_5320:
  ka = iloc(kkk);
  if (ka != j) {
    goto statement_5310;
  }
  isubs1 = iofgnd + kkk;
  isubs2 = iofgnd + ii;
  gnd(isubs1) += gnd(isubs2);
  isubs1 = iofbnd + kkk;
  isubs2 = iofbnd + ii;
  bnd(isubs1) += bnd(isubs2);
  goto statement_5180;
statement_5360:
  nl = 0;
statement_5366:
  n12 = nl + j;
  n13 = nl + i;
  solr(n12) += solr(n13);
  soli(n12) += soli(n13);
  nl += ntot;
  if (nl <= loopss(2)) {
    goto statement_5366;
  }
  i++;
  goto statement_5020;
statement_5500:
  if (istep != -4567) {
    goto statement_5757;
  }
  istep = 0;
  fxsour(cmn);
  if (kill > 0) {
    goto statement_9999;
  }
  goto statement_6000;
statement_5757:
  i = ncurr;
statement_5510:
  if (i == 0) {
    goto statement_6000;
  }
  if (kode(i) > i) {
    goto statement_5560;
  }
  ii = index(i);
statement_5540:
  if (ii == index(i + 1)) {
    goto statement_5570;
  }
  j = iloc(ii);
  isubs1 = iofgnd + ii;
  isubs2 = iofbnd + ii;
  nl = 0;
statement_5547:
  n12 = nl + i;
  n13 = nl + j;
  solr(n12) = solr(n12) - gnd(isubs1) * solr(n13) + bnd(isubs2) * soli(n13);
  soli(n12) = soli(n12) - gnd(isubs1) * soli(n13) - bnd(isubs2) * solr(n13);
  if (iprsup >= 20) {
    write(lunit6,
      "(/,' BACKSUBSTITUTION STEP.  NL, I, II, J =',4i9,/,1x,6e20.6)"),
      nl, i, ii, j, solr(n12), soli(n12), solr(n13), soli(n13), gnd(isubs1),
      bnd(isubs2);
  }
  nl += ntot;
  if (nl <= loopss(2)) {
    goto statement_5547;
  }
  ii++;
  goto statement_5540;
statement_5560:
  j = kode(i);
  nl = 0;
statement_5563:
  n12 = nl + i;
  n13 = nl + j;
  solr(n12) = solr(n13);
  soli(n12) = soli(n13);
  nl += ntot;
  if (nl <= loopss(2)) {
    goto statement_5563;
  }
statement_5570:
  i = i - 1;
  goto statement_5510;
statement_6000:
  lastov = nchain;
  nchain = 11;
  nl = 0;
statement_6007:
  n12 = nl + 1;
  n13 = nl + ntot;
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' S.S. SOLUTION AT EXIT FROM \"OVER10\".  NL =',i5,/(1x,10e13.4))");
      wloop, nl;
      FEM_DO_SAFE(i, n12, n13) {
        wloop, solr(i), soli(i);
      }
    }
  }
  nl += ntot;
  if (nl <= loopss(2)) {
    goto statement_6007;
  }
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
statement_9999:
  lastov = nchain;
  nchain = 51;
  lstat(18) = 10;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
statement_99999:;

} // over10


struct over11_save
{
  int nfsout;
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  double text5;
  double text6;

  over11_save() :
    nfsout(fem::int0),
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text5(fem::double0),
    text6(fem::double0)
  {}
};


void ssout(
  common& cmn,
  int const& L,
  double const& erk,
  double const& eik,
  double const& erm,
  double const& eim,
  double const& currk,
  double const& curik,
  double const& currm,
  double const& curim)
{
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& trash = cmn.trash;
  fem::str<8>& terra = cmn.terra;
  double& epsiln = cmn.epsiln;
  int& kol132 = cmn.kol132;
  int& kssout = cmn.kssout;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& bus = cmn.bus;
  //
  auto& lunit6 = cmn.lunit6;
  double picon = fem::double0;
  int k = fem::int0;
  int m = fem::int0;
  double vk = fem::double0;
  double vm = fem::double0;
  double thk = fem::double0;
  double thm = fem::double0;
  double cmk = fem::double0;
  double cmm = fem::double0;
  double cak = fem::double0;
  double cam = fem::double0;
  double pk = fem::double0;
  double pm = fem::double0;
  double qk = fem::double0;
  double qm = fem::double0;
  double ploss = fem::double0;
  double qloss = fem::double0;
  static const char* format_2052 = "(21x,2(5x,e15.7,f15.4),5x,2e15.7)";
  if (cmn.iprsup >= 1) {
    write(lunit6,
      "(' TOP OF \"SSOUT\".  L, ERK, EIK, ERM, EIM =',i6,4e16.5)"),
      L, erk, eik, erm, eim;
  }
  if (cmn.m4plot == 1) {
    emtspy(cmn);
  }
  picon = 360.f / cmn.twopi;
  if (L > 0) {
    goto statement_2020;
  }
  bus1 = cmn.blank;
  goto statement_2030;
statement_2020:
  k = fem::iabs(kbus(L));
  m = fem::iabs(mbus(L));
  if (mbus(L) > 0 && kssout == 3) {
    goto statement_4500;
  }
  bus1 = bus(k);
  if (k == 1) {
    bus1 = terra;
  }
  bus2 = bus(m);
  if (m == 1) {
    bus2 = terra;
  }
  if (bus1 == trash) {
    goto statement_4500;
  }
  if (bus2 == trash) {
    goto statement_4500;
  }
statement_2030:
  vk = sqrtz(fem::pow2(erk) + fem::pow2(eik));
  vm = sqrtz(fem::pow2(erm) + fem::pow2(eim));
  thk = 0.0f;
  thm = 0.0f;
  if (vk > 0.0f) {
    thk = picon * std::atan2(eik, erk);
  }
  if (vm > 0.0f) {
    thm = picon * std::atan2(eim, erm);
  }
  cmk = sqrtz(fem::pow2(currk) + fem::pow2(curik));
  cmm = sqrtz(fem::pow2(currm) + fem::pow2(curim));
  cak = 0.0f;
  cam = 0.0f;
  if (cmk > 0.0f) {
    cak = picon * std::atan2(curik, currk);
  }
  if (cmm > 0.0f) {
    cam = picon * std::atan2(curim, currm);
  }
  pk = (erk * currk + eik * curik) / 2.0f;
  pm = (erm * currm + eim * curim) / 2.0f;
  qk = (-erk * curik + eik * currk) / 2.0f;
  qm = (-erm * curim + eim * currm) / 2.0f;
  ploss = pk + pm;
  qloss = qk + qm;
  if (kssout == 1) {
    goto statement_2032;
  }
  if (vk > 0.0f) {
    goto statement_2032;
  }
  if (vm > 0.0f) {
    goto statement_2032;
  }
  if (cmk > epsiln) {
    goto statement_2032;
  }
  if (cmm > epsiln) {
    goto statement_2032;
  }
  goto statement_4500;
statement_2032:
  if (L > 0) {
    goto statement_2040;
  }
  //C     BEGIN CODE FOR GENERATOR INJECTION (80 OR 132 COLUMNS):           M32.3911
  ploss = sqrtz(fem::pow2(pk) + fem::pow2(qk));
  qloss = 0.0f;
  if (ploss > 0.0f) {
    qloss = pk / ploss;
  }
  if (kol132 == 132) {
    goto statement_3214;
  }
  //C     BEGIN 80-COLUMN CODE FOR GENERATOR INJECTION PRINTOUT:            M32.3913
  write(lunit6, "(1x,a6,13x,4e15.7)"), bus5, vk, cmk, pk, ploss;
  write(lunit6, "(20x,2f15.4,e15.7,f15.10)"), thk, cak, qk, qloss;
  goto statement_4500;
  //C     BEGIN 132-COLUMN CODE FOR GENERATOR INJECTION PRINTOUT:           M32.3919
statement_3214:
  write(lunit6, "(15x,a6,3(5x,2e15.7))"), bus5, erk, vk, currk, cmk, pk, ploss;
  cmn.out_stream << std::string(15, ' ') << std::string(bus5).substr(0, 6)
    << std::string(5, ' ') << SState("e15.6") << erk << SState("e15.6") << vk
    << std::string(5, ' ') << SState("e15.6") << currk << SState("e15.6") << cmk
    << std::string(5, ' ') << SState("e15.6") << pk << SState("e15.6") << ploss << '\n';
  goto statement_2051;
  //C     BEGIN CODE FOR BRANCH FLOWS (80 OR 132 COLUMNS):                  M32.3921
statement_2040:
  if (kol132 == 132) {
    goto statement_2045;
  }
  //C     BEGIN SPECIAL CODE DEDICATED TO 80-COL. BRANCH FLOW:              M32.3924
  write(lunit6, "(/,1x,a6,13x,4e15.7)"), bus1, vk, vm, cmk, pk;
  write(lunit6, "(14x,a6,3f15.4,e15.7)"), bus2, thk, thm, cak, qk;
  goto statement_4500;
  //C     BEGIN 132-COL. CODE FOR FORWARD BRANCH FLOW PRINTOUT:             M32.3930
statement_2045:
  write(lunit6, "(/,1x,a6,14x,3(5x,2e15.7))"), bus1, erk, vk, currk,
    cmk, pk, ploss;
  cmn.out_stream << "\n " << std::string(bus1).substr(0, 6) << std::string(14, ' ')
    << std::string(5, ' ') << SState("e15.6") << erk << SState("e15.6") << vk
    << std::string(5, ' ') << SState("e15.6") << currk << SState("e15.6") << cmk
    << std::string(5, ' ') << SState("e15.6") << pk << SState("e15.6") << ploss << '\n';
statement_2051:
  write(lunit6, format_2052), eik, thk, curik, cak, qk, qloss;
  write(lunit6, format_2052), eik, thk, curik, cak, qk, qloss; // "(21x,2(5x,e15.7,f15.4),5x,2e15.7)"
  cmn.out_stream << std::string(21, ' ') << std::string(5, ' ') << SState("e15.6") << eik << SState("f15.4") << thk
    << std::string(5, ' ') << SState("e15.6") << curik << SState("f15.4") << cak
    << std::string(5, ' ') << SState("e15.6") << qk << SState("e15.6") << qloss << '\n';
  if (L < 0) {
    goto statement_4500;
  }
  //C     BEGIN CODE FOR REVERSE BRANCH FLOW, 132-COLUMN DISPLAY:           M32.3933
  write(lunit6, "(/,15x,a6,3(5x,2e15.7))"), bus2, erm, vm, currm, cmm, pm;
  cmn.out_stream << '\n' << std::string(15, ' ') << std::string(bus2).substr(0, 6)
    << std::string(5, ' ') << SState("e15.6") << erm << SState("e15.6") << vm
    << std::string(5, ' ') << SState("e15.6") << currm << SState("e15.6") << cmm
    << std::string(5, ' ') << SState("e15.6") << pm << '\n';
  write(lunit6, format_2052), eim, thm, curim, cam, qm;
  cmn.out_stream << std::string(21, ' ')
    << std::string(5, ' ') << SState("e15.6") << eim << SState("f15.4") << thm
    << std::string(5, ' ') << SState("e15.6") << curim << SState("f15.4") << cam
    << std::string(5, ' ') << SState("e15.6") << qm << "\n\n";
  write(lunit6, format_2052);
statement_4500:;
}

void reducn(
  arr_ref<double> x,
  arr_ref<double> y,
  int const& m,
  int const& n)
{
  x(dimension(1));
  y(dimension(1));
  int j = fem::int0;
  int ik = fem::int0;
  int nk = fem::int0;
  int m1 = fem::int0;
  double c = fem::double0;
  double d = fem::double0;
  int k = fem::int0;
  int nkk = fem::int0;
  arr_1d<18, double> b1(fem::fill0);
  arr_1d<18, double> a1(fem::fill0);
  int mk = fem::int0;
  int mkj = fem::int0;
  double a = fem::double0;
  double b = fem::double0;
  int i = fem::int0;
  int mkmj = fem::int0;
  j = m;
  ik = m * m;
  nk = ik - m;
  m1 = m + 1;
statement_1:
  c = 1.e0 / (fem::pow2(x(ik)) + fem::pow2(y(ik)));
  d = -y(ik) * c;
  c = x(ik) * c;
  FEM_DO_SAFE(k, 1, m) {
    nkk = nk + k;
    b1(k) = y(nkk);
    a1(k) = x(nkk);
  }
  k = 1;
statement_4:
  mk = (k - 1) * m;
  mkj = mk + j;
  a = -(x(mkj) * c - y(mkj) * d);
  b = -(x(mkj) * d + y(mkj) * c);
  i = 1;
statement_3:
  mk++;
  x(mk) += (a * a1(i) - b * b1(i));
  y(mk) += (a * b1(i) + b * a1(i));
  i++;
  if (i < m1) {
    goto statement_3;
  }
  mkmj = mk - m + j;
  x(mkmj) = a;
  y(mkmj) = b;
  k++;
  if (k == j) {
    k++;
  }
  if (k < m1) {
    goto statement_4;
  }
  FEM_DO_SAFE(k, 1, m) {
    nkk = nk + k;
    x(nkk) = a1(k) * c - b1(k) * d;
    y(nkk) = a1(k) * d + b1(k) * c;
  }
  x(ik) = c;
  y(ik) = d;
  j = j - 1;
  ik = ik - m1;
  nk = nk - m;
  if (j > n) {
    goto statement_1;
  }
}


void uncor(
  common& cmn,
  arr_ref<double> sci,
  int const& i)
{
  sci(dimension(1));
  common_write write(cmn);
  int& iprsup = cmn.iprsup;
  const auto& elp = cmn.elp;
  //
  double cni = fem::double0;
  double cnr = fem::double0;
  double acde = fem::double0;
  double acdf = fem::double0;
  double a19 = fem::double0;
  double tra2 = fem::double0;
  int i26 = fem::int0;
  int n = fem::int0;
  int iwd1 = fem::int0;
  int iwd = fem::int0;
  int iw = fem::int0;
  int j = fem::int0;
  arr_1d<9, double> ax(fem::fill0);
  arr_1d<9, double> ay(fem::fill0);
  double a18 = fem::double0;
  double a1 = fem::double0;
  double a2 = fem::double0;
  double a5 = fem::double0;
  double a3 = fem::double0;
  double a4 = fem::double0;
  arr_1d<3, double> vnr(fem::fill0);
  arr_1d<3, double> vni(fem::fill0);
  int nk = fem::int0;
  int nb = fem::int0;
  int k = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int iwd2 = fem::int0;
  //C     THIS MODULE IS USED ONLY BY BRANDWAJN (TYPE-59) S.M. MODEL        M32.3739
  cni = sci(1);
  cnr = sci(2);
  acde = sci(3);
  acdf = sci(4);
  a19 = sci(5);
  tra2 = sci(6);
  //C     PROCESS FIRST THE D - AXIS       *   *   *   *   *   *   *   *   *M32.3747
  i26 = 101 * i - 100;
  n = 0;
  iwd1 = 2;
  iwd = iwd1;
  if (elp(i26 + 7) == 0.f) {
    iwd = iwd - 1;
  }
  iw = iwd * iwd;
  FEM_DO_SAFE(j, 1, iw) {
    ax(j) = 0.f;
    ay(j) = 0.f;
  }
  a18 = (1.f - acde) * elp(i26 + 20);
  ax(1) = -elp(i26 + 6);
  ay(1) = (elp(i26 + 2) - elp(i26 + 1) * a18) * tra2;
  a1 = elp(i26 + 1) * acde * 2.0f;
  a2 = a19 * a19;
  a5 = 1.f / (a2 + 1.f);
  a2 = a2 * a5;
  a19 = a19 * a5;
  a3 = a1 * a19;
  a4 = a1 * a2;
  vnr(1) = -(a3 * cnr - a4 * cni);
  vni(1) = -(a3 * cni + a4 * cnr);
  if (iwd == 1) {
    goto statement_3;
  }
  ay(2) = elp(i26 + 4) * acde * tra2;
  ay(3) = ay(2);
  ax(4) = -elp(i26 + 7);
  ay(4) = (elp(i26 + 5) - elp(i26 + 3) * a18) * tra2;
  a1 = elp(i26 + 3) * acde * 2.0f;
  a3 = a1 * a19;
  a4 = a1 * a2;
  vnr(2) = -(a3 * cnr - a4 * cni);
  vni(2) = -(a3 * cni + a4 * cnr);
statement_3:
  reducn(ax, ay, iwd, n);
  nk = 2;
  FEM_DO_SAFE(j, 1, iwd1) {
    a3 = 0.f;
    a4 = 0.f;
    nb = j - iwd;
    nk++;
    if (j > iwd) {
      goto statement_14;
    }
    FEM_DO_SAFE(k, 1, iwd) {
      nb += iwd;
      a3 += ax(nb) * vnr(k) - ay(nb) * vni(k);
      a4 += ax(nb) * vni(k) + ay(nb) * vnr(k);
    }
  statement_14:
    if (iprsup > 1) {
      write(lunit6,
        "('  NEGATIVE SEQUENCE CORRECTION FOR',' WINDING NUMBER J =',i5,"
        "'   OF THE D-AXIS.  A3, A4 FOLLOW:',/,2x,2e25.15)"),
        j, a3, a4;
    }
    sci(nk) = a4;
  }
  //C     PROCESS THE Q - AXIS     *   *   *   *   *   *   *   *   *   *   *M32.3797
  iwd2 = 2;
  iwd = iwd2;
  if (elp(i26 + 15) == 0.f) {
    iwd = iwd - 1;
  }
  if (elp(i26 + 14) == 0.f) {
    iwd = iwd - 1;
  }
  if (iwd == 0) {
    goto statement_13;
  }
  iw = iwd * iwd;
  FEM_DO_SAFE(j, 1, iw) {
    ax(j) = 0.f;
    ay(j) = 0.f;
  }
  a18 = (1.f - acdf) * elp(i26 + 20);
  ax(1) = -elp(i26 + 14);
  ay(1) = (elp(i26 + 10) - elp(i26 + 9) * a18) * tra2;
  a1 = elp(i26 + 9) * acdf * 2.0f;
  a3 = a1 * a19;
  a4 = a1 * a2;
  vnr(1) = -(a3 * cnr - a4 * cni);
  vni(1) = -(a3 * cni + a4 * cnr);
  if (iwd == 1) {
    goto statement_8;
  }
  ay(2) = elp(i26 + 12) * acdf * tra2;
  ay(3) = ay(2);
  ax(4) = -elp(i26 + 15);
  ay(4) = (elp(i26 + 13) - elp(i26 + 11) * a18) * tra2;
  a1 = elp(i26 + 11) * acdf * 2.0f;
  a3 = a1 * a19;
  a4 = a1 * a2;
  vnr(2) = -(a3 * cnr - a4 * cni);
  vni(2) = -(a3 * cni + a4 * cnr);
statement_8:
  reducn(ax, ay, iwd, n);
statement_13:
  FEM_DO_SAFE(j, 1, iwd2) {
    a3 = 0.f;
    a4 = 0.f;
    nb = j - iwd;
    nk++;
    if (j > iwd) {
      goto statement_15;
    }
    FEM_DO_SAFE(k, 1, iwd) {
      nb += iwd;
      a3 += ax(nb) * vnr(k) - ay(nb) * vni(k);
      a4 += ax(nb) * vni(k) + ay(nb) * vnr(k);
    }
  statement_15:
    if (iprsup > 1) {
      write(lunit6,
        "('  NEGATIVE SEQUENCE CORRECTION FOR',' WINDING NUMBER J =',i5,"
        "'   OF THE Q-AXIS.  A3, A4 FOLLOW:',/,2x,2e25.15)"),
        j, a3, a4;
    }
    sci(nk) = a3;
  }
  if (iprsup > 1) {
    {
      write_loop wloop(cmn, lunit6,
        "('  NEGATIVE SEQUENCE CORRECTIONS UPON',"
        "' EXIT FROM \"UNCOR\".   SCI(1:NK)','  FOLLOW ....',/(2x,6e21.12))");
      FEM_DO_SAFE(k, 1, nk) {
        wloop, sci(k);
      }
    }
  }
}

void slope(
  double const& sft,
  double const& ssld,
  double const& ssad,
  double& acee)
{
  double adeld = sft / ssld - .9f;
  int n5 = 10.f * adeld;
  n5 = (n5 + 1) / 2;
  double sb = n5;
  sb = sb * .1f;
  double sf4 = ssld * (0.9f + sb);
  double sf5 = ssld * (1.1f + sb);
  double sf6 = sf4 / (1.0f + ssad * (sf4 - ssld));
  double sf7 = sf5 / (1.0f + ssad * (sf5 - ssld));
  acee = (sf7 - sf6) / (sf5 - sf4);
}
 

struct smint_save
{
  fem::str<8> text1;

  smint_save() :
    text1(fem::char0)
  {}
};

void smint(
  common& cmn)
{
  FEM_CMN_SVE(smint);
  common_write write(cmn);
  double& delta2 = cmn.delta2;
  double& epsiln = cmn.epsiln;
  auto& twopi = cmn.twopi;
  double& omega = cmn.omega;
  double& tenm6 = cmn.tenm6;
  double& onehaf = cmn.onehaf;
  auto& lstat = cmn.lstat;
  int& numsm = cmn.numsm;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  auto& elp = cmn.elp;
  auto& histq = cmn.histq;
  const auto& shp = cmn.shp;
  const auto& ismdat = cmn.ismdat;
  const auto& crest = cmn.crest;
  const auto& time1 = cmn.time1;
  const auto& tstart = cmn.tstart;
  const auto& e = cmn.e;
  const auto& f = static_cast<common_c0b119&>(cmn).f;
  const auto& ismtac = cmn.ismtac;
  const auto& kode = cmn.kode;
  const auto& bus = cmn.bus;
  const auto& norder = cmn.norder;
  auto& cu = cmn.cu;
  auto& etac = cmn.etac;
  auto& z = static_cast<common_smach&>(cmn).z;
  auto& x1 = cmn.x1;
  double& sqrt3 = cmn.sqrt3;
  double& asqrt3 = cmn.asqrt3;
  double& sqrt32 = cmn.sqrt32;
  double& thtw = cmn.thtw;
  double& radeg = cmn.radeg;
  double& omdt = cmn.omdt;
  //
  fem::str<8>& text1 = sve.text1;
  if (is_called_first_time) {
    text1 = "  1ST ";
  }
  int karc = fem::int0;
  int lmset = fem::int0;
  int n10 = fem::int0;
  int nwd = fem::int0;
  int n33 = fem::int0;
  int ilmass = fem::int0;
  int ilstor = fem::int0;
  int nn10 = fem::int0;
  int iiter = fem::int0;
  double akm = fem::double0;
  double akn = fem::double0;
  auto& lunit6 = cmn.lunit6;
  int j30 = fem::int0;
  int k = fem::int0;
  int in = fem::int0;
  int ia = fem::int0;
  int L = fem::int0;
  double car = fem::double0;
  double cai = fem::double0;
  int ib = fem::int0;
  double cbr = fem::double0;
  double cbi = fem::double0;
  int ic = fem::int0;
  double ccr = fem::double0;
  double cci = fem::double0;
  double a = fem::double0;
  double b = fem::double0;
  double c1 = fem::double0;
  double d1 = fem::double0;
  double reia1 = fem::double0;
  double aimia1 = fem::double0;
  double adk = fem::double0;
  double ads = fem::double0;
  int idelta = fem::int0;
  double camag = fem::double0;
  double caang = fem::double0;
  double ca = fem::double0;
  double cb = fem::double0;
  double cmzer = fem::double0;
  double cazer = fem::double0;
  double cmneg = fem::double0;
  double caneg = fem::double0;
  int ksm = fem::int0;
  double vamag = fem::double0;
  double vaang = fem::double0;
  double var = fem::double0;
  double vai = fem::double0;
  double vbr = fem::double0;
  double vbi = fem::double0;
  double vcr = fem::double0;
  double vci = fem::double0;
  double vamag1 = fem::double0;
  int ilk = fem::int0;
  double q1 = fem::double0;
  int n2 = fem::int0;
  int n3 = fem::int0;
  int n1 = fem::int0;
  int i75 = fem::int0;
  int k1 = fem::int0;
  double d2 = fem::double0;
  double pt = fem::double0;
  double qt = fem::double0;
  double scn = fem::double0;
  double ptn = fem::double0;
  double qtn = fem::double0;
  double pt0 = fem::double0;
  double qt0 = fem::double0;
  int ik = fem::int0;
  int k14 = fem::int0;
  double arp = fem::double0;
  double aip = fem::double0;
  double camag1 = fem::double0;
  double caang1 = fem::double0;
  int i26 = fem::int0;
  int i30 = fem::int0;
  double es = fem::double0;
  double ds = fem::double0;
  double cs = fem::double0;
  double xl = fem::double0;
  double bs = fem::double0;
  double ssld = fem::double0;
  double ssad = fem::double0;
  double sslq = fem::double0;
  double ssaq = fem::double0;
  double ssd = fem::double0;
  double ssg = fem::double0;
  double b6 = fem::double0;
  double acdf = fem::double0;
  double acde = fem::double0;
  int isact = fem::int0;
  double cid = fem::double0;
  double ciq = fem::double0;
  double vq = fem::double0;
  double cif = fem::double0;
  double adeld = fem::double0;
  int ineg = fem::int0;
  double camneg = fem::double0;
  double can = fem::double0;
  double sf2 = fem::double0;
  double sf3 = fem::double0;
  double sft = fem::double0;
  int ipp = fem::int0;
  int idd = fem::int0;
  double acee = fem::double0;
  double acef = fem::double0;
  double cif1 = fem::double0;
  double cid1 = fem::double0;
  double b1 = fem::double0;
  double b2 = fem::double0;
  double vf = fem::double0;
  double vd = fem::double0;
  double ciq1 = fem::double0;
  double ci0 = fem::double0;
  double cikd = fem::double0;
  double cig = fem::double0;
  double cikq = fem::double0;
  double ca1 = fem::double0;
  double sa1 = fem::double0;
  double tsc1 = fem::double0;
  double tsd1 = fem::double0;
  double cb2 = fem::double0;
  double cc2 = fem::double0;
  double sb2 = fem::double0;
  double sc2 = fem::double0;
  double cz = fem::double0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  double ac1 = fem::double0;
  double ac2 = fem::double0;
  double d22 = fem::double0;
  double q22 = fem::double0;
  int numask = fem::int0;
  int nlocg = fem::int0;
  int nloce = fem::int0;
  double totet = fem::double0;
  int num1 = fem::int0;
  int num2 = fem::int0;
  int num4 = fem::int0;
  int num6 = fem::int0;
  int n4 = fem::int0;
  double totdmp = fem::double0;
  double d5 = fem::double0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  double tot = fem::double0;
  int ilb = fem::int0;
  int il = fem::int0;
  int i = fem::int0;
  int nlocg1 = fem::int0;
  int nloce1 = fem::int0;
  double aye = fem::double0;
  double ayr = fem::double0;
  int n20 = fem::int0;
  double d6 = fem::double0;
  int n21 = fem::int0;
  double d20 = fem::double0;
  int n5 = fem::int0;
  int kmset = fem::int0;
  int ipb = fem::int0;
  int n31 = fem::int0;
  int jmset = fem::int0;
  int n9 = fem::int0;
  int n15 = fem::int0;
  int ii = fem::int0;
  double ajj = fem::double0;
  double adl = fem::double0;
  double adm = fem::double0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  int n12 = fem::int0;
  int j = fem::int0;
  static const char* format_6258 =
    "(/,' AFTER TORQUE INITIALIZATION.',12x,'N10',10x,'NLOCG',10x,'NLOCE',9x,"
    "'NUMASK',/,29x,4(10x,i5))";
  static const char* format_6259 = "(/(1x,5e21.12))";
  static const char* format_6273 =
    "(9x,'TOTAL',15x,'DC-COMPONENT',/,2(1x,e19.7))";
  //C     THIS MODULE IS USED ONLY BY BRANDWAJN (TYPE-59) S.M. MODEL        M31.2684
  karc = 0;
  lmset = 0;
  n10 = 0;
  nwd = 24;
  n33 = 0;
  ilmass = 0;
  ilstor = 0;
  nn10 = ismdat(25);
  iiter = 100;
  akm = cmn.epsuba;
  if (akm < 2.f) {
    akm = 100.0f;
  }
  akn = 2.f / (1.f + delta2 / akm);
  akm = akm / omdt;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' BEGIN  ''SMINT'' .','   NUMSM     NST  DELTA2',/,17x,2i8,e15.6)"),
      numsm, cmn.nst, delta2;
  }
  j30 = 1;
  FEM_DO_SAFE(k, 1, numsm) {
    in = 0;
    ia = ismdat(j30 + 2);
    ia = norder(ia);
    lstat(52) = ia;
  statement_2:
    L = kode(ia);
    if (L <= ia) {
      goto statement_3;
    }
    ia = L;
    goto statement_2;
  statement_3:
    car = e(ia);
    cai = f(ia);
    ib = ismdat(j30 + 3);
    ib = norder(ib);
  statement_4:
    L = kode(ib);
    if (L <= ib) {
      goto statement_5;
    }
    ib = L;
    goto statement_4;
  statement_5:
    cbr = e(ib);
    cbi = f(ib);
    ic = ismdat(j30 + 4);
    ic = norder(ic);
  statement_6:
    L = kode(ic);
    if (L <= ic) {
      goto statement_7;
    }
    ic = L;
    goto statement_6;
  statement_7:
    ccr = e(ic);
    cci = f(ic);
    //C     COMPUTE POSITIVE SEQUENCE CURRENTS    ****************************M33. 901
    z(karc + 1) = car;
    z(karc + 2) = cai;
    z(karc + 3) = cbr;
    z(karc + 4) = cbi;
    z(karc + 5) = ccr;
    z(karc + 6) = cci;
    a = (cbr + ccr) * onehaf;
    b = (cci - cbi) * sqrt32;
    c1 = (cci + cbi) * onehaf;
    d1 = (cbr - ccr) * sqrt32;
    reia1 = (car - a + b) / 3.0f;
    aimia1 = (cai - c1 + d1) / 3.0f;
    adk = 1.0f;
    ads = 0.0f;
    idelta = ismdat(j30 + 1);
    if (idelta == 0) {
      goto statement_423;
    }
    adk = asqrt3;
    ads = twopi / 12.0f;
  statement_423:
    camag = (sqrtz(fem::pow2(reia1) + fem::pow2(aimia1))) * adk;
    caang = std::atan2(aimia1, reia1) + ads;
    if (iprsup >= 1) {
      write(lunit6,
        "('  POSITIVE SEQUENCE:',4x,'AMPL=',2x,e15.8,4x,'ANGLE=',2x,e15.8)"),
        camag, caang;
    }
    //C     COMPUTE ZERO AND NEGATIVE SEQUENCE CURRENTS ********************* M39.1623
    ca = (car + cbr + ccr) / 3.0f;
    cb = (cai + cbi + cci) / 3.0f;
    cmzer = sqrtz(fem::pow2(ca) + fem::pow2(cb));
    cazer = std::atan2(cb, ca);
    if (iprsup >= 1) {
      write(lunit6,
        "(6x,'ZERO SEQUENCE:',4x,'AMPL=',2x,e15.8,4x,'ANGLE=',2x,e15.8)"),
        cmzer, cazer;
    }
    ca = (car - a - b) / 3.0f;
    cb = (cai - c1 - d1) / 3.0f;
    cmneg = (sqrtz(fem::pow2(ca) + fem::pow2(cb))) * adk;
    caneg = std::atan2(cb, ca) - ads;
    if (iprsup >= 1) {
      write(lunit6,
        "('  NEGATIVE SEQUENCE:',4x,'AMPL=',2x,e15.8,4x,'ANGLE=',2x,e15.8)"),
        cmneg, caneg;
    }
    //C     CALCULATE POSITIVE SEQUENCE TERMINAL VOLTAGE ******************** M39.1639
    ksm = kconst + 3 * (k - numsm) - 2;
    vamag = crest(ksm);
    vaang = time1(ksm);
    var = vamag * cosz(vaang);
    vai = vamag * sinz(vaang);
    vamag = crest(ksm + 1);
    vaang = time1(ksm + 1);
    vbr = vamag * cosz(vaang);
    vbi = vamag * sinz(vaang);
    vamag = crest(ksm + 2);
    vaang = time1(ksm + 2);
    vcr = vamag * cosz(vaang);
    vci = vamag * sinz(vaang);
    if (idelta == 0) {
      goto statement_427;
    }
    a = var;
    b = vai;
    var = var - vbr;
    vai = vai - vbi;
    vbr = vbr - vcr;
    vbi = vbi - vci;
    vcr = vcr - a;
    vci = vci - b;
  statement_427:
    a = (vbr + vcr) * onehaf;
    b = (vci - vbi) * sqrt32;
    c1 = (vci + vbi) * onehaf;
    d1 = (vbr - vcr) * sqrt32;
    a = (var - a + b) / 3.0f;
    b = (vai - c1 + d1) / 3.0f;
    vamag = sqrtz(fem::pow2(a) + fem::pow2(b));
    vaang = std::atan2(b, a);
    vamag1 = vamag * thtw;
    ilk = ismdat(j30);
    if (ilk == 1) {
      goto statement_12;
    }
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' IN  ''SMINT'' ,  B4 DUAL CURRENT SPLIT.','       K     ILK',10x,"
        "'VAMAG',10x,'VAANG',/,38x,2i8,2e15.6)"),
        k, ilk, vamag, vaang;
    }
    //C     CALCULATE LOAD ANGLES FOR MULTIPLE GENERATORS ********************M20.2695
    d1 = 0.0f;
    q1 = 0.0f;
    n2 = n10 + 1;
    n3 = n10 + ilk;
    FEM_DO_SAFE(n1, n2, n3) {
      i75 = 101 * k - 74;
      d1 += elp(i75 + 2);
      q1 += elp(i75 + 3);
    }
    if (d1 != 0.0f && q1 != 0.0f) {
      goto statement_351;
    }
    kill = 106;
    k1 = ismdat(j30 + 2);
    cmn.bus1 = bus(k1);
    lstat(14) = k;
    lstat(18) = cmn.nchain;
    lstat(19) = 300;
    return;
  statement_351:
    d2 = vaang - caang;
    pt = camag * cosz(d2) / d1;
    qt = camag * sinz(d2) / q1;
    //C     CALCULATE NEGATIVE AND ZERO SEQUENCE CURRENT SPLIT COEFFICIENTS***M23.1903
    scn = vaang - caneg;
    ptn = cmneg * cosz(scn) / d1;
    qtn = cmneg * sinz(scn) / q1;
    scn = vaang - cazer;
    pt0 = cmzer * cosz(scn) / d1;
    qt0 = cmzer * sinz(scn) / q1;
  statement_11:
    ik = n10 + 1;
    k14 = 4 * ik;
    i75 = 101 * ik - 74;
    arp = elp(i75 + 2);
    aip = elp(i75 + 3);
    d1 = pt * arp;
    q1 = qt * aip;
    camag1 = sqrtz(fem::pow2(d1) + fem::pow2(q1));
    caang1 = vaang - std::atan2(q1, d1);
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' AFTER CURRENT SPLIT.','      N1     ILK',10x,'CAMAG1',10x,"
        "'CAANG1',/,21x,2i8,2e16.6)"),
        n1, ilk, camag1, caang1;
    }
    //C     SPLIT THE NEGATIVE AND ZERO SEQUENCE CURRENTS ********************M23.1904
    d1 = ptn * arp;
    q1 = qtn * aip;
    cmneg = sqrtz(fem::pow2(d1) + fem::pow2(q1));
    caneg = vaang - std::atan2(q1, d1);
    d1 = pt0 * arp;
    q1 = qt0 * aip;
    cmzer = sqrtz(fem::pow2(d1) + fem::pow2(q1));
    cazer = vaang - std::atan2(q1, d1);
    goto statement_13;
  statement_12:
    camag1 = camag;
    caang1 = caang;
  statement_13:
    ccr = camag1 * cosz(caang1);
    cci = camag1 * sinz(caang1);
    write(lunit6,
      "(2x,'TABULATION OF NEG. AND ZERO SEQU. CURRENTS',/,2x,'NEG. SEQ.',"
      "2e20.7,/,2x,'ZER. SEQ.',2e20.7)"),
      cmneg, caneg, cmzer, cazer;
    //C     CALCULATE ELECTRICAL POSITION OF THE D-AXIS   ********************M20.2726
    cai = vamag * sinz(vaang);
    car = vamag * cosz(vaang);
    n1 = n10 + 1;
    i26 = 101 * n1 - 100;
    i75 = i26 + 26;
    i30 = 30 * n1 - 29;
    es = elp(i26);
    ds = elp(i26 + 1);
    cs = elp(i26 + 8);
    xl = elp(i26 + 18);
    bs = elp(i26 + 19);
    ssld = elp(i26 + 21);
    ssad = elp(i26 + 22);
    sslq = elp(i26 + 23);
    ssaq = elp(i26 + 24);
    ssd = es - xl;
    ssg = cs - xl;
    b6 = ssg / ssd;
    acdf = 1.0f;
    acde = 1.0f;
    isact = ismdat(i30 + 8);
    d1 = car + bs * ccr - cs * cci;
    q1 = cai + bs * cci + cs * ccr;
    d1 = std::atan2(q1, d1);
    //C     CALCULATE PARK'S CURRENTS AND VOLTAGES   *************************M20.2737
    q1 = camag1 * thtw;
    d2 = caang1 - d1;
    cid = q1 * sinz(d2);
    ciq = q1 * cosz(d2);
    d2 = vaang - d1;
    vq = vamag1 * cosz(d2);
    cif = (vq + bs * ciq - es * cid) / ds;
    //C     ADD NEGATIVE SEQUENCE CORRECTIONS, IF NEEDED *   *   *   *   *   *M32.3646
    adeld = cmneg * cosz(caneg) / camag1;
    ineg = 0;
    if (std::abs(adeld) > (10.f * epsiln)) {
      ineg = 2;
    }
    camneg = cmneg * thtw;
    n3 = 6;
    move0(x1, n3);
    can = -caneg - d1;
    if (ineg < 1) {
      goto statement_300;
    }
    x1(1) = camneg * sinz(can);
    x1(2) = camneg * cosz(can);
    x1(3) = 1.f;
    x1(4) = 1.f;
    x1(5) = akm;
    x1(6) = akn;
    uncor(cmn, x1(1), n1);
  statement_300:
    acde = 1.f;
    acdf = 1.f;
    //C     CALCULATE THE TOTAL FLUX IN THE AIR-GAP      *   *   *   *   *   *M32.3665
    sf2 = (cid + x1(1)) / elp(i26 + 20) + cif + x1(3) + x1(4);
    sf3 = (ciq + x1(2)) / elp(i26 + 20) + x1(5) + x1(6);
    sft = sqrtz(fem::pow2(sf2) + fem::pow2((sf3 * b6)));
    if (isact == 0) {
      goto statement_306;
    }
    ipp = 0;
    idd = 0;
    acee = 1.f;
    acef = 1.f;
    if (ssld >= sft && sslq >= sft) {
      goto statement_306;
    }
    if (ssld >= sft) {
      goto statement_301;
    }
    acde = (1.0f - ssad * sft) / (1.0f - ssad * ssld);
    if (ineg > 1) {
      slope(sft, ssld, ssad, acee);
    }
  statement_301:
    if (sslq >= sft) {
      goto statement_302;
    }
    acdf = (1.0f - ssaq * sft) / (1.0f - ssaq * sslq);
    if (ineg > 1) {
      slope(sft, sslq, ssaq, acef);
    }
    goto statement_302;
  statement_304:
    cif1 = cif;
    cid1 = d1;
    ipp++;
    sf2 = (cid + x1(1)) / elp(i26 + 20) + cif + x1(3) + x1(4);
    sf3 = (ciq + x1(2)) / elp(i26 + 20) + x1(5) + x1(6);
    sft = sqrtz(fem::pow2(sf2) + fem::pow2((sf3 * b6)));
    acee = 1.f;
    acde = 1.f;
    if (sft <= ssld) {
      goto statement_311;
    }
    acde = 1.0f / (1.0f + ssad * (sft - ssld));
    if (ineg > 1) {
      slope(sft, ssld, ssad, acee);
    }
  statement_311:
    acdf = 1.f;
    acef = 1.f;
    if (sft <= sslq) {
      goto statement_302;
    }
    acdf = 1.0f / (1.0f + ssaq * (sft - sslq));
    if (ineg > 1) {
      slope(sft, sslq, ssaq, acef);
    }
  statement_302:
    ds = elp(i26 + 1) * acde;
    es = ssd * acde + xl;
    cs = ssg * acdf + xl;
    b1 = car + bs * ccr - cs * cci;
    b2 = cai + bs * cci + cs * ccr;
    d1 = std::atan2(b2, b1);
    d2 = caang1 - d1;
    cid = q1 * sinz(d2);
    ciq = q1 * cosz(d2);
    d2 = vaang - d1;
    vq = vamag1 * cosz(d2);
    cif = (vq + bs * ciq - es * cid) / ds;
    can = -caneg - d1;
    if (ineg == 0) {
      goto statement_303;
    }
    x1(1) = camneg * sinz(can);
    x1(2) = camneg * cosz(can);
    x1(3) = acee;
    x1(4) = acef;
    x1(5) = akm;
    x1(6) = akn;
    uncor(cmn, x1(1), n1);
  statement_303:
    if (ipp == 0) {
      goto statement_304;
    }
    if (idd > 0) {
      goto statement_306;
    }
    adeld = std::abs((d1 - cid1) / cid1) + std::abs((cif1 - cif) / cif1);
    if (adeld <= epsiln) {
      goto statement_305;
    }
    if (ipp <= iiter) {
      goto statement_304;
    }
    kill = 210;
    lstat(19) = 306;
    lstat(14) = n1;
    return;
  statement_305:
    idd = 2;
    goto statement_304;
  statement_306:
    vf = -elp(i26 + 6) * cif;
    vd = vamag1 * sinz(d2);
    if (iprsup >= 1) {
      write(lunit6,
        "(/,8x,'TERMINAL',10x,'DELTA',13x,'VD',13x,'VQ',13x,'VF',12x,'CID',"
        "12x,'CIQ',12x,'CIF',/,8x,i8,7e15.6)"),
        n1, d1, vd, vq, vf, cid, ciq, cif;
    }
    //C     STORE THE ELECTRICAL VARIABLES IN CORRESPONDING ARRAYS ***********M20.2753
    cid1 = cid;
    ciq1 = ciq;
    cif1 = cif;
    //C     STORE COEFFICIENTS FOR THE CALCULATION OF EQUIVALENT SATURATED****M23.1969
    //C     INDUCTANCES. THE VALUES STORED HERE WILL BE NECESSRY FOR THE FIRSTM23.1970
    //C     TIME STEP EVEN FOR AN UNSATURATED MACHINE  ***********************M23.1971
    elp(i75 + 2) = acde;
    elp(i75 + 3) = acdf;
    cid += x1(1);
    cu(n33 + 8) = cid;
    can = can - 2.0f * omdt;
    if (ineg == 2) {
      cu(n33 + 8) = cid1 + camneg * sinz(can);
    }
    cu(n33 + 1) = cid;
    ciq += x1(2);
    cu(n33 + 9) = ciq;
    if (ineg == 2) {
      cu(n33 + 9) = ciq1 + camneg * cosz(can);
    }
    cu(n33 + 2) = ciq;
    ci0 = cmzer * cosz(cazer) * sqrt3;
    cu(n33 + 3) = ci0;
    cu(n33 + 11) = vf;
    cif += x1(3);
    cu(n33 + 4) = cif;
    cikd = x1(4);
    cu(n33 + 5) = cikd;
    cig = x1(5);
    cu(n33 + 6) = cig;
    cikq = x1(6);
    cu(n33 + 7) = cikq;
    //C     CONVERT PARK'S CURRENTS TO PHASE QUANTITIES **********************M23.1986
    d1 += twopi / 4.0f;
    ci0 = ci0 * asqrt3;
    ca1 = cosz(d1);
    sa1 = sinz(d1);
    tsc1 = -ca1 * onehaf;
    tsd1 = sa1 * sqrt32;
    cb2 = tsc1 + tsd1;
    cc2 = tsc1 - tsd1;
    tsc1 = -sa1 * onehaf;
    tsd1 = ca1 * sqrt32;
    sb2 = tsc1 - tsd1;
    sc2 = tsc1 + tsd1;
    cu(n33 + 12) = (ca1 * cid + sa1 * ciq) / thtw + ci0;
    cu(n33 + 13) = (cb2 * cid + sb2 * ciq) / thtw + ci0;
    cu(n33 + 14) = (cc2 * cid + sc2 * ciq) / thtw + ci0;
    //C     INITIALIZE THE MECHANICAL VARIABLES.   ***************************M20.2773
    cz = elp(i26 + 25);
    d3 = d1 / cz;
    d4 = omega / cz;
    ac1 = (es * cid + ds * cif + elp(i26 + 3) * acde * cikd) / omega;
    ac2 = (elp(i26 + 9) * cig + elp(i26 + 11) * cikq) * acdf;
    ac2 = (ac2 + cs * ciq) / omega;
    d22 = (ac1 * ciq - ac2 * cid) * cz * tenm6;
    q22 = -(vf * cz * tenm6 * cif) / d4;
    d2 = ((es - cs) * cid1 + ds * cif1) * ciq1;
    d2 = d2 * tenm6 / d4;
    numask = ismdat(i30 + 11);
    nlocg = ismdat(i30 + 12);
    nloce = ismdat(i30 + 13);
    q1 = -(vf * cif1 * cz * tenm6) / d4;
    if (nloce == 0) {
      q1 = 0.0f;
    }
    totet = d2 + q1;
    num1 = numask - 1;
    num2 = numask + numask;
    num4 = num2 + num2;
    num6 = num4 + num2;
    n2 = ilmass * 12 + num2;
    n4 = ilstor + nlocg;
    histq(n4) = d3;
    totdmp = 0.0f;
    d5 = 0.0f;
    n6 = n2 + 1;
    FEM_DO_SAFE(n3, 1, numask) {
      d5 += shp(n6);
      n7 = n6 + num4;
      totdmp += shp(n7);
      n6++;
    }
    tot = (totet + totdmp * d4) / d5;
    //C     INITIALIZE TORQUES FOR GENERATOR NO.N10+1   **********************M20.2801
    ilb = ilstor + num4 + numask;
    FEM_DO_SAFE(il, 1, numask) {
      histq(il + ilb) = shp(il + n2) * tot;
    }
    if (iprsup < 2) {
      goto statement_8818;
    }
    write(lunit6, format_6258), n10, nlocg, nloce, numask;
    n6 = ilb + 1;
    n7 = n6 + num1;
    {
      write_loop wloop(cmn, lunit6, format_6259);
      FEM_DO_SAFE(i, n6, n7) {
        wloop, histq(i);
      }
    }
  statement_8818:
    nlocg1 = ilb + nlocg;
    if (nloce == 0) {
      goto statement_1500;
    }
    nloce1 = ilb + nloce;
    histq(nloce1) = histq(nloce1) - q1;
    aye = histq(nloce1);
  statement_1500:
    histq(nlocg1) = histq(nlocg1) - d2;
    ayr = histq(nlocg1);
    il = nlocg;
    n4 = n4 - nlocg;
    n20 = n2 + 3 * numask;
    if (numask == 1) {
      goto statement_25;
    }
    if (il == 1) {
      goto statement_18;
    }
    //C     CALCULATE  ANGLES TO THE LEFT OF THE ROTOR ***********************M20.2822
    n6 = n2 + num4 + 1;
    n7 = n6 + nlocg - 1;
    d6 = 0.0f;
    FEM_DO_SAFE(n3, n6, n7) {
      d6 = d6 - shp(n3);
    }
    d6 = d6 * d4;
    n6 = ilb;
    FEM_DO_SAFE(ik, 1, il) {
      n6++;
      d6 += histq(n6);
    }
  statement_21:
    ik = il;
    il = il - 1;
    if (il < 1) {
      goto statement_18;
    }
    n3 = n2 + num4 + ik;
    n6 = n4 + ik;
    n21 = n20 + ik;
    d6 += shp(n3) * d4 - histq(ilb + ik);
    histq(n6 - 1) = histq(n6) + d6 / shp(n21 - 1);
    goto statement_21;
  statement_18:
    il = nlocg;
    if (il == numask) {
      goto statement_24;
    }
    //C     CALCULATE  ANGLES TO THE RIGHT OF THE ROTOR  *********************M20.2842
    d6 = 0.0f;
    if (il == 1) {
      goto statement_26;
    }
    n6 = n2 + num4 + 1;
    n7 = n6 + nlocg - 2;
    FEM_DO_SAFE(n3, n6, n7) {
      d6 = d6 - shp(n3);
    }
    d6 = d6 * d4;
    n7 = nlocg - 1;
    n6 = ilb;
    FEM_DO_SAFE(ik, 1, n7) {
      n6++;
      d6 += histq(n6);
    }
  statement_26:
    ik = il;
    il++;
    if (il > numask) {
      goto statement_24;
    }
    n3 = n2 + num4 + ik;
    d6 += histq(ilb + ik) - shp(n3) * d4;
    n6 = n4 + ik;
    n3 = n20 + ik;
    histq(n6 + 1) = histq(n6) - d6 / shp(n3);
    goto statement_26;
  statement_24:
    if (nloce > 0) {
      histq(nloce1) = aye + q1;
    }
  statement_25:
    histq(nlocg1) = ayr + d2;
    d20 = d2;
    //C     STORE INITIAL (SYNCHRONOUS) SPEEDS ****************************** M38.2294
    n5 = n4 + numask + 1;
    n3 = n5 + num1;
    FEM_DO_SAFE(ik, n5, n3) {
      histq(ik) = d4;
    }
    if (numask == 1) {
      goto statement_30;
    }
    //C     CALCULATE TORQUES ON THE SHAFT  **********************************M20.2874
    n6 = ilb - numask;
    FEM_DO_SAFE(ik, 1, num1) {
      n3 = n20 + ik;
      n5 = n4 + ik;
      n6++;
      histq(n6) = (histq(n5) - histq(n5 + 1)) * shp(n3);
    }
    if (iprsup < 2) {
      goto statement_30;
    }
    write(lunit6, format_6258), n10, nlocg, nloce, numask;
    n7 = ilb - 1;
    n6 = n7 - num1 + 1;
    {
      write_loop wloop(cmn, lunit6, format_6259);
      wloop, in;
      FEM_DO_SAFE(i, n6, n7) {
        wloop, histq(i);
      }
    }
  statement_30:
    n10++;
    in++;
    //C     LOAD INITIAL CONDITIONS INTO TACS ARRAYS ************************ M38.2304
    kmset = ismdat(i30 + 14);
    if (kmset == 0) {
      goto statement_970;
    }
    ipb = ilstor + numask;
    n31 = num2 + num1;
    FEM_DO_SAFE(i, 1, kmset) {
      lmset++;
      jmset = ismtac(lmset);
      if (jmset > 0) {
        goto statement_1696;
      }
      jmset = -jmset;
      if (jmset > 7) {
        goto statement_1680;
      }
      etac(lmset) = cu(n33 + jmset);
      goto statement_955;
    statement_1680:
      if (jmset > 8) {
        goto statement_1681;
      }
      etac(lmset) = vd;
      goto statement_955;
    statement_1681:
      if (jmset > 9) {
        goto statement_1682;
      }
      etac(lmset) = vq;
      goto statement_955;
    statement_1682:
      if (jmset > 10) {
        goto statement_1683;
      }
      etac(lmset) = (var + vbr + vcr) * asqrt3;
      goto statement_955;
    statement_1683:
      if (jmset > 11) {
        goto statement_1684;
      }
      etac(lmset) = vf;
      goto statement_955;
    statement_1684:
      if (jmset > 12) {
        goto statement_1685;
      }
      etac(lmset) = sft;
      goto statement_955;
    statement_1685:
      if (jmset > 13) {
        goto statement_1686;
      }
      etac(lmset) = std::atan2(sf3, sf2);
      goto statement_955;
    statement_1686:
      if (jmset > 14) {
        goto statement_1687;
      }
      etac(lmset) = d22;
      goto statement_955;
    statement_1687:
      if (jmset > 15) {
        goto statement_1688;
      }
      etac(lmset) = q22;
      goto statement_955;
    statement_1688:
      if (jmset == 17) {
        goto statement_1689;
      }
      etac(lmset) = ac1;
      goto statement_955;
    statement_1689:
      etac(lmset) = ac2;
      goto statement_955;
    statement_1696:
      if (jmset > num2) {
        goto statement_1697;
      }
      n9 = ilstor + jmset;
      etac(lmset) = histq(n9);
      goto statement_955;
    statement_1697:
      jmset = ilstor + jmset + num2;
      etac(lmset) = histq(jmset);
    statement_955:;
    }
    //C     THE FOLLOWING ROUTINE PRINTS INFO REQUESTED BY USER WHICH EXISTS  M38.2343
    //C     IMMEDIATELY AFTER MACHINE INITIALIZATION                          M38.2344
  statement_970:
    cmn.bus4 = text1;
    if (elp(i75) == 0.0f) {
      goto statement_1201;
    }
    //C     PRINT INDUCTANCE AND RESTANCE VALUES OF MACH. N10 IN PHYSICAL UNITM20.2912
    k1 = ismdat(j30 + 2);
    write(lunit6,
      "(/,/,' MACH ',i2,10x,"
      "'DATA PARAMETERS AND INITIAL CONDITIONS OF NEXT MACHINE FOLLOW.     ---"
      "--------------------------------------------',/,' ''',a6,'''   UNIT',"
      "i3)"),
      n10, bus(k1), in;
    write(lunit6,
      "(/,' MACHINE REACTANCES AND RESISTANCES, IN OHMS  (QUANTITIES LABELED A"
      "S INDUCTANCES ARE ACTUALLY REACTANCES).',/,3x,e15.7,5x,"
      "'LF   = D-AXIS FIELD SELF INDUCTANCE')"),
      elp(i26 + 2);
    write(lunit6,
      "(3x,e15.7,5x,'LAF  = D-AXIS FIELD-ARMATURE MUTUAL INDUCTANCE')"),
      elp(i26 + 1);
    write(lunit6,
      "(3x,e15.7,5x,'LFKD = D-AXIS FIELD-DAMPER MUTUAL INDUCTANCE')"),
      elp(i26 + 4);
    write(lunit6,
      "(3x,e15.7,5x,"
      "'LD   = D-AXIS ARMATURE SELF INDUCTANCE (SYNCHRONOUS REACTANCE)')"),
      elp(i26);
    write(lunit6,
      "(3x,e15.7,5x,'LAKD = D-AXIS ARMATURE-DAMPER MUTUAL INDUCTANCE')"),
      elp(i26 + 3);
    write(lunit6,
      "(3x,e15.7,5x,'LKD  = D-AXIS DAMPER SELF INDUCTANCE')"), elp(
        i26 + 5);
    write(lunit6,
      "(3x,e15.7,5x,'LG   = Q-AXIS CIRCUIT 1 SELF INDUCTANCE')"), elp(
        i26 + 10);
    write(lunit6,
      "(3x,e15.7,5x,'LAG  = Q-AXIS CIRCUIT 1-ARMATURE MUTUAL INDUCTANCE')"),
      elp(i26 + 9);
    write(lunit6,
      "(3x,e15.7,5x,'LGKQ = Q-AXIS CIRCUIT 1-CIRCUIT 2 MUTUAL INDUCTANCE')"),
      elp(i26 + 12);
    write(lunit6,
      "(3x,e15.7,5x,'LQ   = Q-AXIS ARMATURE SELF INDUCTANCE')"), elp(
        i26 + 8);
    write(lunit6,
      "(3x,e15.7,5x,'LAKQ = Q-AXIS CIRCUIT 2-ARMATURE MUTUAL INDUCTANCE')"),
      elp(i26 + 11);
    write(lunit6,
      "(3x,e15.7,5x,'LKQ  = Q-AXIS CIRCUIT 2-SELF INDUCTANCE')"), elp(
        i26 + 13);
    write(lunit6, "(3x,e15.7,5x,'L0   = ZERO SEQUENCE REACTANCE')"),
      elp(i26 + 16);
    write(lunit6, "(3x,e15.7,5x,'R0   = ZERO SEQUENCE RESISTANCE')"),
      elp(i26 + 17);
    write(lunit6,
      "(3x,e15.7,5x,'RF   = RESISTANCE OF FIELD WINDING')"), elp(
        i26 + 6);
    write(lunit6, "(3x,e15.7,5x,'RA   = ARMATURE RESISTANCE')"), elp(i26 + 19);
    write(lunit6, "(3x,e15.7,5x,'RKD  = D-AXIS DAMPER RESISTANCE')"),
      elp(i26 + 7);
    write(lunit6,
      "(3x,e15.7,5x,'RG   = Q-AXIS CIRCUIT-1 RESISTANCE')"), elp(
        i26 + 14);
    write(lunit6,
      "(3x,e15.7,5x,'RKQ  = Q-AXIS CIRCUIT-2 RESISTANCE')"), elp(
        i26 + 15);
    //C     PRINT MECHANICAL DATA OF MACH. N10                                M20.2964
    write(lunit6,
      "(/,' MECHANICAL PARAMETERS OF GENERATOR, IN PHYSICAL UNITS AS SHOWN BY "
      "COLUMN HEADINGS.')");
    write(lunit6,
      "(3x,'MOMENT OF INERTIA',12x,'SELF-DAMPING COEFFICIENTS OF MASS',9x,"
      "'MUTUAL-DAMPING COEFF.',5x,'TORSIONAL SPRING CONSTANT',/,7x,"
      "'OF ROTOR MASS',10x,'SPEED-DEVIATION',6x,'ABSOLUTE-SPEED',9x,"
      "'(WITH FOLLOWING MASS)',9x,'(WITH FOLLOWING MASS)')");
    write(lunit6,
      "(' MILLION (N-M)/(RAD/SEC**2)',17x,'MILLION (N-M)/(RAD/SEC)',7x,"
      "'MILLION (N-M)/(RAD/SEC)',11x,'MILLION (N-M)/(RAD)')");
    n15 = n2 + numask;
    FEM_DO_SAFE(ii, 1, numask) {
      n15++;
      ajj = shp(n15);
      adl = shp(n15 + num4);
      adm = shp(n15 + numask);
      adk = shp(n15 + num2);
      ads = shp(n15 + 3 * numask);
      write(lunit6, "(1x,e21.7,5x,2e20.7,2e30.7)"), ajj, adl, ads, adm, adk;
    }
  statement_1201:
    if (elp(i75 + 1) == 0.0f) {
      goto statement_1218;
    }
    write(lunit6,
      "(/,' TOTAL CURRENT INJECTED INTO NETWORK AT GENERATOR BUS, IN PHASE COO"
      "RDINATES.   FOR A DUAL-MACHINE BUS,',/,"
      "' THIS IS THE TOTAL INJECTION ( ''A'' + ''B'' ).   THE FIRST LINE DISPL"
      "AYS THE CURRENTS AS FOUND BY THE PHASOR NETWORK',/,"
      "' SOLUTION (WHICH MAY BE UNBALANCED, IF THE NETWORK IS).   THE 2ND LINE"
      " SHOWS ONLY THE POSITIVE-SEQUENCE COMPONENT,',/,"
      "'  MAGNITUDES OF THE CURRENTS ARE IN UNITS OF (AMPS) .')");
    adk = 1.0f;
    ads = 0.0f;
    if (idelta == 0) {
      goto statement_429;
    }
    adk = sqrt3;
    ads = twopi / 12.0f;
  statement_429:
    d7 = z(karc + 1);
    d8 = z(karc + 2);
    d1 = sqrtz(fem::pow2(d7) + fem::pow2(d8));
    d2 = std::atan2(d8, d7) * radeg;
    d7 = z(karc + 3);
    d8 = z(karc + 4);
    d3 = sqrtz(fem::pow2(d7) + fem::pow2(d8));
    d4 = std::atan2(d8, d7) * radeg;
    d7 = z(karc + 5);
    d8 = z(karc + 6);
    d5 = sqrtz(fem::pow2(d7) + fem::pow2(d8));
    d6 = std::atan2(d8, d7) * radeg;
    write(lunit6,
      "(18x,' PHASE  ''A''  INJECTION',18x,' PHASE  ''B''  INJECTION',18x,"
      "' PHASE  ''C''  INJECTION',/,3(17x,'MAGNITUDE',7x,'DEGREES'),/,3(11x,"
      "e15.7,2x,f12.7))"),
      d1, d2, d3, d4, d5, d6;
    write(lunit6, "('+ACTUAL')");
    d4 = camag * adk;
    d1 = (caang - ads) * radeg;
    d2 = d1 + 240.f;
    d5 = d2 - 360.f;
    if (d5 > -180.f) {
      d2 = d5;
    }
    d3 = d1 + 120.f;
    d5 = d3 - 360.f;
    if (d5 > -180.f) {
      d3 = d5;
    }
    write(lunit6,
      "(' POS. SEQ. ',e15.7,2x,f12.7,2(11x,e15.7,2x,f12.7))"), d4,
      d1, d4, d2, d4, d3;
    //C     PRINT D,Q, AND 0 CURRENTS                                         M20.3042
    write(lunit6,
      "(/,' ARMATURE CURRENTS OF GENERATOR IN ROTATING REFERENCE FRAME (D-Q-0 "
      "COORDINATES), IN UNITS OF  (AMPS) .')");
    write(lunit6, "(20x,'ID',13x,'IQ',13x,'I0',/,7x,3(e15.7))"), cu(n33 + 1),
      cu(n33 + 2), cu(n33 + 3);
    //C     PRINT A,B,C PHASE CURRENTS (POS. SEQ. COMPONENT)                  M20.3079
    write(lunit6,
      "(/,' POSITIVE-SEQUENCE COMPONENT OF GENERATOR ARMATURE CURRENT IN PHASE"
      " COORDINATES, IN UNITS OF (AMPS) .')");
    d4 = camag1;
    d1 = caang1 * radeg;
    d2 = d1 + 240.f;
    d5 = d2 - 360.f;
    if (d5 > -180.f) {
      d2 = d5;
    }
    d3 = d1 + 120.f;
    d5 = d3 - 360.f;
    if (d5 > -180.f) {
      d3 = d5;
    }
    write(lunit6,
      "(18x,'ARMATURE OF PHASE  ''A''',18x,'ARMATURE OF PHASE  ''B''',18x,"
      "'ARMATURE OF PHASE  ''C''',/,3(17x,'MAGNITUDE',7x,'DEGREES'),/,3(11x,"
      "e15.7,2x,f12.7))"),
      d4, d1, d4, d2, d4, d3;
    //C     PRINT FIELD CURRENT                                               M20.3101
    write(lunit6, "(/,' FIELD CURRENT OF GENERATOR IN UNITS OF  (AMPS) .')");
    write(lunit6, format_6273), cu(n33 + 4), cif1;
    //C     PRINT TORQUE ON GENERATOR ROTOR                                   M20.3108
    write(lunit6,
      "(/,' ELECTROMECHANICAL TORQUE OF GENERATOR, IN UNITS OF  MILLION (N - M"
      ").')");
    write(lunit6, format_6273), d22, d20;
    if (nloce == 0) {
      goto statement_1960;
    }
    write(lunit6,
      "(/,' ELECTROMECHANICAL TORQUE OF EXCITER, IN UNITS OF  MILLION (N - M)."
      "')");
    write(lunit6, format_6273), q22, q1;
  statement_1960:
    write(lunit6,
      "(/,' CRITICAL LEVEL OF TOTAL AIR GAP MMF AT WHICH SATURATION BEGINS, IN"
      " UNITS OF  (AMPERES) .     ',/,1x,2e25.9)"),
      elp(i26 + 21), elp(i26 + 23);
    write(lunit6,
      "(/,' MECHANICAL ANGLES OF ROTOR MASSES, IN UNITS OF  ( DEGREES)  .')");
    FEM_DO_SAFE(ii, 1, numask) {
      n12 = ilstor + ii;
      d4 = histq(n12) * radeg;
      write(lunit6, "(15x,f12.7,4x,'''THETA''  FOR MASS NO.',i3)"), d4, ii;
    }
    //C     PRINT ANGULAR VELOCITIES                                          M20.3165
    write(lunit6,
      "(/,' ANGULAR VELOCITIES OF ROTOR MASSES, IN UNITS OF  (RAD/SEC) .')");
    n12 = ilstor + numask;
    d4 = histq(n12 + 1);
    FEM_DO_SAFE(i, 1, numask) {
      write(lunit6, "(15x,f12.7,4x,'''OMEGA''  FOR MASS NO.',i3)"), d4, i;
    }
    if (num1 == 0) {
      goto statement_1218;
    }
    //C     PRINT SHAFT TORQUES                                               M20.3188
    write(lunit6,
      "(/,' SHAFT TORQUES BETWEEN MASSES, IN UNITS OF  MILLION (N - M).')");
    //C     NOTE- TRANSIENT SHAFT TORQUE INCLUDES A DAMPING TORQUE TERM ALSO  M20.3193
    //C           BUT ABOVE IS CORRECT FOR STEADY STATE                       M20.3194
    n6 = ilstor + num4;
    FEM_DO_SAFE(i, 1, num1) {
      n6++;
      ajj = histq(n6);
      n1 = i + 1;
      write(lunit6,
        "(16x,e15.7,4x,'''T',i2,''' --- TORQUE ON SHAFT BETWEEN MASS',i3,"
        "'  AND MASS',i3)"),
        ajj, i, i, n1;
    }
  statement_1218:
    ilmass += numask;
    ilstor += num6;
    n33 += nwd;
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' AFTER SHAFT-TORQUE CALC. IN  ''SMINT '' .',"
        "'       K     N10   NUMSM  IMDUAL',/,40x,5i8)"),
        k, n10, numsm, ismdat(j30);
    }
    if (in < ilk) {
      goto statement_11;
    }
    j30 += 30;
  }
  //C     ERASE SYNCHRONOUS MACHINES FROM SOURCE TABLES  * * * * * * * * * *M20.3222
  FEM_DO_SAFE(i, 1, kconst) {
    j = i;
    if (tstart(i) == -9988.f) {
      goto statement_915;
    }
  }
  goto statement_918;
statement_915:
  kconst = j - 1;
statement_918:
  if (iprsup >= 1) {
    write(lunit6, "(/,' UPON EXIT  ''SMINIT'' ,  KCONST =',i3)"), kconst;
  }
}






struct pltfil_save
{
  //arr<fem::str<1> > filbyt;
  //arr<double> fkar1;
  //arr<double> fkar2;
  arr<double> forbyt;
  int n13;
  int n17;
  int n7;

  pltfil_save() :
    //filbyt(dimension(1), fem::fill0),
    //fkar1(dimension(1), fem::fill0),
    //fkar2(dimension(1), fem::fill0),
    forbyt(dimension(600), fem::fill0),
    n13(fem::int0),
    n17(fem::int0),
    n7(fem::int0)
  {}
};

void pltfil(
  common& cmn,
  int const& k)
{
  //FEM_CMN_SVE(pltfil);
  common_write write(cmn);
  //int& iprsup = cmn.iprsup;
  //auto& indbuf = cmn.indbuf;
  //auto& indbeg = cmn.indbeg;
  //auto& mflush = cmn.mflush;
  //auto& newvec = cmn.newvec;
  //auto& monitr = cmn.monitr;
  //auto& limbuf = cmn.limbuf;
  //auto& munit6 = cmn.munit6;

  auto& volti = static_cast<common_c0b123&>(cmn).volti;
  auto& numnvo = cmn.numnvo;

  //

  if (450 < k) {
    write(cmn.lunit6,
      "('Error in \"PLTFIL\", the number of output variables ',i3,"
      "' exceeds the limit of 450.')"), k;
    throw std::out_of_range("in \'pltfil\'");
  }

  if (volti(1) < 0) return; // the last item is -9999

  cmn.out_stream << SState("f10.6") << volti[0]; // time
  for (int i = 1; i < k; ++i) {
    cmn.out_stream << ',' << SState("f11.4") << volti[i];
  }
  cmn.out_stream << '\n';






#if 0
  auto& lunit6 = cmn.lunit6;
  arr_ref<double> forbyt(sve.forbyt, dimension(600));

  int j = 0;
  int ll10 = 0;
  int& n17 = sve.n17;
  if (is_called_first_time) {
    n17 = 0;
  }
  auto pltbuf = ArraySpan(reinterpret_cast<double*>(&cmn.karray(1)), cmn.karray.size()/2);
  static const char* format_7311 =
    "('   % % % % % %   Suspended',"
    "' simulation;  plot data space exhausted;  use',"
    "' SPY.   INDBUF, LIMBUF =',2i8)";
  //C     INSTALLATION-DEPENDENT MODULE WHICH IS CALLED FOR                
  //C     OUTPUT-VECTOR DUMPING BY  "SUBTS3"  AND  "OVER20"  IF            
  //C     "M4PLOT" OF  /BLANK/  IS NONZERO.   THIS                         
  //C     IS ALTERNATIVE TO CONVENTIONAL IN-LINE DUMPING ON DISK.          
  //C     MODULE SHOULD BE UNIVERSAL FOR COMPUTERS USING FORTRAN 77        
  //C     COMPILERS AND REAL*4 VARIABLES WHICH GIVE SINGLE PRECISION.      
  //C INITIALIZE ROLLING PLOT FREQ COUNT
  //C SIMULATOR USE
  if (cmn.m4plot == 1) {
    goto statement_7286;
  }
  //C     WE PASS HERE WITH M4PLOT=2, INDICATING DISK STORAGE, BUT       
  //C     SINGLE-PRECISION (REAL*4) NUMBERS ONLY:                          
  if (450 < k) {
    write(lunit6,
      "(' ^^^^^^^^^^^^^^^   ERROR STOP IN \"PLTFIL\"','   ^^^^^^^^^^^^^^',/,"
      "' ^^^^^^  TOO MANY',' OUTPUT VARIABLES (',i3,' )  FOR USE',"
      "' REAL*4 PLOT FILE.   LIMIT = 450.')"), k;
    stoptp(cmn);
  }

  FEM_DO_SAFE(j, 1, k) {
    forbyt(j) = volti(j);
  }
  {
    write_loop wloop(cmn, cmn.lunit4, fem::unformatted);
    FEM_DO_SAFE(j, 1, k) {
      wloop, forbyt(j);
    }
  }
  goto statement_9000;


  //C EXIT MODULE AFTER POSSIBLE DIAGNOSTIC
statement_7286:
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(' TOP OF \"PLTFIL\".  INDBUF, MFLUSH, K,',"
        "' LIMBUF, NEWVEC, NUMCRD =',6i10,/,1x,10e13.4)");
      wloop, indbuf, mflush, k, limbuf, newvec, cmn.numcrd;
      FEM_DO_SAFE(j, 1, 10) {
        wloop, volti(j);
      }
    }
  }
  sve.n7 = 0;
  //C NOT VERY 1ST STEP
  if (indbuf > 0) {
    goto statement_7308;
  }
  //C     PLOT DATA STORAGE BEGINS AFTER "TABLES" USAGE FOR "LABCOM"        M35. 438
  //C     PLUS 50 MISC. CELLS, PLUS EMTP DATA CARDS.  OFFSET IS:            M35. 439
  //C WE HAVE FLUSHED PLTBUF TO DISK ZERO TIMES
  mflush = 0;
  //C PLOT POINTS OFFSET BY "LABCOM"
  indbeg = cmn.ltlabl + 51;
  //C RESET PLOT STORAGE AT BEGINNING
  indbuf = indbeg;
  //C PLOT DATA BEGINS AFTER DATA CARDS
  newvec = indbuf + 1;
  //C NOT FULL YET
statement_7308:
  if (indbuf + k <= limbuf) {
    goto statement_7374;
  }
  write(lunit6, format_7311), indbuf, limbuf;
  write(munit6, format_7311), indbuf, limbuf;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  write(munit6,
    "('   % %  Time-sharing disabled.   Send',"
    "' user-keyed interrupt to silence alarm.')");
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  ll10 = 10;
  //C DISASTER-LEVEL AUDIBLE INDICATION
  honker(cmn, ll10);
  //C REMEMBER PRESENT VALUE, FOR AFTER SPY
  sve.n13 = cmn.kbreak;
  //C ENSURE FORCED STAY IN SPY UNTIL "UNLOCK"
  cmn.lockbr = 1;
  //C REMEMBER OVERFLOW FOR "FLAGER", "SPYINK"
  cmn.lastov = 9911;
  //C TRANSFER CONTROL TO SPY, TO MANAGE SPACE
  emtspy(cmn);
  //C B4 CONTINUE, CHECK THAT USER DID HIS JOB
  goto statement_7308;
  //C TRANSFER EACH CELL J OF OUTPUT VECTOR
statement_7374:
  FEM_DO_SAFE(j, 1, k) {
    //C INDEX TO NEXT UNUSED PLTBUF CELL
    indbuf++;
    //C  END  DO 7389  LOOP OVER "J"
    pltbuf(indbuf) = volti(j);
  }
  //C     FOLLOWING 2 APOLLO CARDS REPLACE 3 PRECEDING VAX ONES:            M38. 126
  //C7374 CALL VEC_$DP_SP ( VOLTI(1), PLTBUF(INDBUF+1), K )                 M38. 127
  //C     INDBUF = INDBUF + K                                               M38. 128
  //C ANOTHER STEP SINCE LAST ROLLING SERVICE
  n17++;
  //C NOT ENOUGH POINTS YET
  if (n17 < cmn.kslowr) {
    goto statement_9000;
  }
  //C RESET COUNTER TO DELAY ROLLING AFTER PRESENT
  n17 = 0;
  //C NO ROLLING VECTOR PLOT
  if (monitr == 0) {
    goto statement_7396;
  }
  //C ADD TO RIGHT EDGE OF PRESENT VECTOR PLOT
  tekplt();
  //C VECTOR ADDITION DONE
  if (monitr != 8765) {
    goto statement_7396;
  }
  //C REGENERATE PLOT, WITH RIGHT HALF ON LEFT
  timval(cmn);
  //C PLOT REGENERATED, SO TURN OFF REQUEST FLAG
  monitr = 1;
  //C ROLLING CHARACTER PLOT
statement_7396:
  if (cmn.monits != 0) {
    chrplt(cmn);
  }

statement_9000:
  if (iprsup >= 4) {
    write(lunit6, "(' EXIT \"PLTFIL\".')");
  }

#endif
}

// OUTPUT STEADY-STATE PHASOR SOLUTION (IF REQUESTED).          
void over11(
  common& cmn)
{
  FEM_CMN_SVE(over11);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& blank = cmn.blank;
  const auto& date1= cmn.date1;
  const auto& tclock= cmn.tclock;
  const auto& abuff = cmn.abuff;
  double& ck1 = cmn.ck1;
  auto& twopi = cmn.twopi;
  double& omega = cmn.omega;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  double& fminfs = cmn.fminfs;
  double& delffs = cmn.delffs;
  double& fmaxfs = cmn.fmaxfs;
  auto& begmax = cmn.begmax;
  double& tenm3 = cmn.tenm3;
  double& onehaf = cmn.onehaf;
  auto& flstat = cmn.flstat;
  //auto& moncar = cmn.moncar;
  auto& lunit4 = cmn.lunit4;
  auto& lstat = cmn.lstat;
  int& icheck = cmn.icheck;
  int& iout = cmn.iout;
  int& kol132 = cmn.kol132;
  int& lswtch = cmn.lswtch;
  int& nv = cmn.nv;
  int& lsiz12 = cmn.lsiz12;
  auto& ktrlsw = cmn.ktrlsw;
  int& lastov = cmn.lastov;
  int& nphcas = cmn.nphcas;
  int& lsiz26 = cmn.lsiz26;
  int& lsiz27 = cmn.lsiz27;
  int& iofgnd = cmn.iofgnd;
  int& iofbnd = cmn.iofbnd;
  int& ncurr = cmn.ncurr;
  int& ioffd = cmn.ioffd;
  int& kill = cmn.kill;
  int& ivolt = cmn.ivolt;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  int& kssout = cmn.kssout;
  auto& loopss = cmn.loopss;
  int& ntot1 = cmn.ntot1;
  int& numnvo = cmn.numnvo;
  const auto& kdepsw = cmn.kdepsw;
  auto& energy = cmn.energy;
  const auto& xoptbr = cmn.xoptbr;
  const auto& coptbr = cmn.coptbr;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& r = static_cast<common_c0b064&>(cmn).r;
  const auto& nr = cmn.nr;
  const auto& length = cmn.length;
  auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  auto& ck = cmn.ck;
  const auto& ibrnch = cmn.ibrnch;
  const auto& jbrnch = cmn.jbrnch;
  const auto& imodel = cmn.imodel;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& cki = cmn.cki;
  const auto& kodsem = cmn.kodsem;
  const auto& iform = cmn.iform;
  const auto& node = cmn.node;
  const auto& crest = cmn.crest;
  const auto& time1 = cmn.time1;
  const auto& tstart = cmn.tstart;
  const auto& sfreq = cmn.sfreq;
  const auto& kmswit = cmn.kmswit;
  auto& nextsw = cmn.nextsw;
  auto& imfd = cmn.imfd;
  auto& tclose = cmn.tclose;
  const auto& adelay = cmn.adelay;
  auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  const auto& kssfrq = cmn.kssfrq;
  const auto& kode = cmn.kode;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;
  auto& voltk = static_cast<common_c0b124&>(cmn).voltk;
  auto& volt = cmn.volt;
  const auto& bus = cmn.bus;
  const auto& norder = cmn.norder;
  auto& index = cmn.index;
  auto& diag = cmn.diag;
  auto& diab = cmn.diab;
  auto& solr = cmn.solr;
  auto& soli = cmn.soli;
  auto& bnd = cmn.bnd;
  const auto& iloc = cmn.iloc;
  auto& gnd = cmn.gnd;
  fem::str<32>& ansi32 = cmn.ansi32;
  auto& a8sw = cmn.a8sw;
  int& kexact = cmn.kexact;
  int& nsolve = cmn.nsolve;
  double& fminsv = cmn.fminsv;
  int& numrun = cmn.numrun;
  //
  int& nfsout = sve.nfsout;
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  double& text5 = sve.text5;
  double& text6 = sve.text6;
  if (is_called_first_time) {
    text1 = "MAG   ";
    text2 = "ANGLE ";
    text3 = "REAL  ";
    text4 = "IMAG  ";
    //w text5 = "PCTMAG";
    //w text6 = "PCTANG";
    nfsout = 0;
  }
  int ll2 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int llm1 = fem::int0;
  int ll0 = fem::int0;
  int ll1 = fem::int0;
  int ib = fem::int0;
  double sfrold = fem::double0;
  int n6 = fem::int0;
  int k = fem::int0;
  int m = fem::int0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  int jb = fem::int0;
  int n16 = fem::int0;
  double omegal = fem::double0;
  double omegac = fem::double0;
  int L = fem::int0;
  int ix = fem::int0;
  int iy = fem::int0;
  int nrow1 = fem::int0;
  int n1 = fem::int0;
  int iz = fem::int0;
  int in = fem::int0;
  int jn = fem::int0;
  double xx = fem::double0;
  double dd = fem::double0;
  double rd = fem::double0;
  double xd = fem::double0;
  double erk = fem::double0;
  double eik = fem::double0;
  double erm = fem::double0;
  double eim = fem::double0;
  double der = fem::double0;
  double dei = fem::double0;
  double currk = fem::double0;
  double curik = fem::double0;
  double currm = fem::double0;
  double curim = fem::double0;
  int kib = fem::int0;
  int mib = fem::int0;
  double yr = fem::double0;
  double yi = fem::double0;
  double yy = fem::double0;
  double ctr = fem::double0;
  double cti = fem::double0;
  double yis = fem::double0;
  double yrs = fem::double0;
  double csr = fem::double0;
  double csi = fem::double0;
  int ibf = fem::int0;
  int ld = fem::int0;
  int ldd = fem::int0;
  double clir = fem::double0;
  double clii = fem::double0;
  double cljr = fem::double0;
  double clji = fem::double0;
  int ia = fem::int0;
  int ja = fem::int0;
  int kd = fem::int0;
  double vr = fem::double0;
  double vi = fem::double0;
  int jj = fem::int0;
  int kkk = fem::int0;
  int isubs1 = fem::int0;
  int isubs2 = fem::int0;
  double d26 = fem::double0;
  int kt = fem::int0;
  int n8 = fem::int0;
  int n9 = fem::int0;
  int n5 = fem::int0;
  int ndx5 = fem::int0;
  int mt = fem::int0;
  int n13 = fem::int0;
  int nt1 = fem::int0;
  int ndx3 = fem::int0;
  int nt2 = fem::int0;
  int n2 = fem::int0;
  int js = fem::int0;
  int k1 = fem::int0;
  int mk = fem::int0;
  int num = fem::int0;
  double ang = fem::double0;
  int ndx4 = fem::int0;
  double d6 = fem::double0;
  double d5 = fem::double0;
  int nn = fem::int0;
  double power = fem::double0;
  double react = fem::double0;
  arr_1d<13, fem::str<8> > aupper(fem::fill0);
  double h1 = fem::double0;
  double h2 = fem::double0;
  double a = fem::double0;
  double gus1 = fem::double0;
  int n15 = fem::int0;
  double d2 = fem::double0;
  double h3 = fem::double0;
  double gus2 = fem::double0;
  double gus3 = fem::double0;
  double gus4 = fem::double0;
  double d1 = fem::double0;
  int n7 = fem::int0;
  int n85 = fem::int0;
  int n71 = fem::int0;
  int n74 = fem::int0;
  int n18 = fem::int0;
  int n19 = fem::int0;
  int n28 = fem::int0;
  int n29 = fem::int0;
  int ltemp = fem::int0;
  int ip = fem::int0;
  int iq = fem::int0;
  int ihalf = fem::int0;
  arr<double> fshold(dimension(30000), fem::fill0);
  int n77 = fem::int0;
  int n899 = fem::int0;
  int n78 = fem::int0;
  int ij = fem::int0;
  int jtemp = fem::int0;
  int ik = fem::int0;
  double dum123 = fem::double0;
  int nf = fem::int0;
  int nref = fem::int0;
  int ijk = fem::int0;
  int jpp = fem::int0;
  int n22 = fem::int0;
  int ndum = fem::int0;
  fem::str<6> chhold = fem::char0;
  int i = fem::int0;
  int j = fem::int0;
  static const char* format_3082 =
    "(20x,"
    "'************************************************************************"
    "*******************')";
  static const char* format_7431 = "(15x,a6)";
  //C 9-PHASE AS LIMIT FOR LMFS TEST
  //C
  //C      PRECEDING "JCH2" USES "IMFD" JUST FOR "FREQUENCY SCAN".          M35.1236
  //C      AS SUCH, THERE MUST BE NO FREQ-DEPEND SOURCES PRESENT.           M35.1237
  //arr<int, 2> locatn(dimension(1000, 1000), fem::fill0); //w
  //locatn(i, j) = (j * j - j) / 2 + i;
  auto& knt = cmn.moncar(1);
  ll2 = 2;
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER11.\"')");
  }
  if (iprsup >= 3) {
    kssout = 1;
  }
  llm1 = -1;
  ll0 = 0;
  ll1 = 1;
  ll2 = 2;
  ib = 1;
  sfrold = -cmn.fltinf;
  if (kssout != 1 && kssout != 3) {
    goto statement_6010;
  }
  n6 = 0;
  FEM_DO_SAFE(k, 1, ibr) {
    j = fem::iabs(kbus(k));
    if (j == 1) {
      j = fem::iabs(mbus(k));
    }
    if (j <= 1) {
      goto statement_1854;
    }
    m = fem::iabs(kssfrq(j));
    if (n6 <= 0) {
      goto statement_1846;
    }
    ndx1 = lsiz26;
    FEM_DO_SAFE(i, 1, n6) {
      ndx1++;
      if (sfreq(m) == volt(ndx1)) {
        goto statement_1854;
      }
    }
  statement_1846:
    n6++;
    ndx1 = lsiz26 + n6;
    volt(ndx1) = sfreq(m);
    if (n6 < lsiz26) {
      goto statement_1854;
    }
    write(lunit6,
      "(' NUMBER OF PHASOR FREQUENCIES EXCEEDS',"
      "' LIST SIZE 26 (WORKING VECTOR USAGE).')"),
      lsiz26;
    kill = 1;
    lstat(19) = 1854;
    lstat(17) = 26;
    goto statement_9800;
  statement_1854:;
  }
  if (kol132 == 132) {
    write(lunit6,
      "(/,/,"
      "' SINUSOIDAL STEADY STATE SOLUTION, BRANCH BY BRANCH.  ALL FLOWS ARE AW"
      "AY FROM BUS, AND REAL PART, MAGNITUDE, OR P',/,"
      "' IS PRINTED ABOVE THE IMAGINARY PART, THE',"
      "' ANGLE, OR Q.   FIRST SOLUTION FREQUENCY =',e18.9,'   HERTZ.')"),
      volt(lsiz26 + 1);
    cmn.out_stream << " SINUSOIDAL STEADY STATE SOLUTION, BRANCH BY BRANCH. ALL FLOWS ARE AWAY FROM BUS, AND REAL PART, MAGNITUDE, OR P\n"
      << " IS PRINTED ABOVE THE IMAGINARY PART, THE ANGLE, OR Q. FIRST SOLUTION FREQUENCY = " << SState("e18.9") << volt(lsiz26 + 1) << "Hertz\n";
  }
  if (kol132 != 132) {
    write(lunit6,
      "(/,' 80-COLUMN PHASOR BRANCH FLOWS.  REVERSE',"
      "' FLOWS OMITTED.  1ST FREQ =',e13.5,/,'  BUS K',13x,'   VK-AMPLITUDE',"
      "'   VM-AMPLITUDE','  IKM-AMPLITUDE','   PKM (WATTS) ',/,15x,'BUS M',"
      "'   VK-DEGREES  ','   VM-DEGREES  ','   IKM-DEGREES ',"
      "'   QKM (VARS)  ')"),
      volt(lsiz26 + 1);
  }
  ndx1 = lsiz26 + 2;
  ndx2 = lsiz26 + n6;
  if (n6 >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(' ADDED SUBNETWORK FREQUENCIES :',6e14.5)");
      FEM_DO_SAFE(i, ndx1, ndx2) {
        wloop, volt(i);
      }
    }
  }
  if (kol132 == 132) {
    write(lunit6,
      "(2x,'BUS K',37x,'NODE VOLTAGE',21x,'BRANCH CURRENT',10x,'POWER FLOW',"
      "5x,'POWER LOSS',/,16x,'BUS M',2(9x,'RECTANGULAR',10x,'POLAR'),5x,2(8x,"
      "'P AND Q'))");
    cmn.out_stream << "  BUS K" << std::string(37, ' ') << "NODE VOLTAGE" << std::string(21, ' ') << "BRANCH CURRENT"
      << std::string(10, ' ') << "POWER FLOW" << std::string(5, ' ') << "POWER LOSS\n"
      << std::string(16, ' ') << "BUS M" << std::string(9, ' ') << "RECTANGULAR" << std::string(10, ' ') << "POLAR"
      << std::string(9, ' ') << "RECTANGULAR" << std::string(10, ' ') << "POLAR" << std::string(13, ' ') << "P AND Q"
      << std::string(8, ' ') << "P AND Q\n";
  }
statement_6010:
  if (ibr < ib) {
    goto statement_6200;
  }
  xopt = xoptbr(ib);
  copt = coptbr(ib);
  d3 = tenm3;
  d4 = cmn.unity / 1000000.f;
  if (xopt > 0.0f) {
    d3 = 1.0f / (twopi * xopt);
  }
  if (copt > 0.0f) {
    d4 = d4 / (twopi * copt);
  }
  jb = fem::iabs(kbus(ib));
  if (jb == 1) {
    jb = fem::iabs(mbus(ib));
  }
  n16 = fem::iabs(kssfrq(jb));
  omegal = d3 * twopi * sfreq(n16);
  omegac = d4 * twopi * sfreq(n16);
  if (imodel(ib) == -4) {
    omegac = 1.0f;
  }
  if (sfreq(n16) == sfrold) {
    goto statement_6017;
  }
  if (kssout != 1 && kssout != 3) {
    goto statement_6016;
  }
  if (ib == 1) {
    goto statement_6016;
  }
  write(lunit6,
    "('      %%%%%  FREQUENCY DISCONTINUITY:','   END',e13.4,'  HZ.,',"
    "'   BEGIN BRANCHES EXCITED AT',e18.9,'   HERTZ.   %%%%%')"),
    sfrold, sfreq(n16);
statement_6016:
  sfrold = sfreq(n16);
statement_6017:
  jb = fem::iabs(nr(ib));
  L = fem::iabs(length(ib));
  if (kodebr(ib) != -2) {
    goto statement_6030;
  }
  if (kodsem(ib) != 0 && imodel(ib) != -2) {
    goto statement_6030;
  }
  nphcas = fem::iabs(length(ib));
  FEM_DO_SAFE(ix, 1, nphcas) {
    iy = ib + ix - 1;
    nrow1 = kbus(iy);
    nrow1 = norder(nrow1);
    e(ix) = solr(nrow1);
    f(ix) = soli(nrow1);
    nrow1 = mbus(iy);
    nrow1 = norder(nrow1);
    n1 = ix + nphcas;
    e(n1) = solr(nrow1);
    f(n1) = soli(nrow1);
  }
  mult(tx(jb), f(1), diag(1), ll2 * nphcas, ll0);
  mult(tr(jb), e(1), diag(1), ll2 * nphcas, llm1);
  mult(tr(jb), f(1), diab(1), ll2 * nphcas, ll0);
  mult(tx(jb), e(1), diab(1), ll2 * nphcas, ll1);
  if (kssout != 1 && kssout != 3) {
    goto statement_7003;
  }
  FEM_DO_SAFE(ix, 1, nphcas) {
    iy = ib + ix - 1;
    iz = ix + nphcas;
    ssout(cmn, iy, e(ix), f(ix), e(iz), f(iz), diag(ix), diab(ix),
      diag(iz), diab(iz));
  }
statement_7003:
  ib += nphcas;
  goto statement_6010;
statement_6030:
  if (nr(ib) >= 0) {
    goto statement_6060;
  }
  //C              SERIES   R - L - C   CALCULATIONS                           10190
  in = fem::iabs(kbus(ib));
  in = norder(in);
  jn = fem::iabs(mbus(ib));
  jn = norder(jn);
  if (c(jb) == 0.0f) {
    goto statement_6044;
  }
  xx = tx(jb) * omegal - 1.0f / (c(jb) * omegac);
  goto statement_6048;
statement_6044:
  xx = tx(jb) * omegal;
statement_6048:
  dd = tr(jb) * tr(jb) + xx * xx;
  rd = tr(jb) / dd;
  xd = -xx / dd;
  erk = solr(in);
  eik = soli(in);
  erm = solr(jn);
  eim = soli(jn);
  der = erk - erm;
  dei = eik - eim;
  currk = rd * der - xd * dei;
  curik = rd * dei + xd * der;
  ci(ib) = -currk;
  ck(ib) = 0.0f;
  if (c(jb) != 0.0f) {
    ck(ib) = curik / (c(jb) * omegac);
  }
  currm = -currk;
  curim = -curik;
  if (kssout == 1 || kssout == 3) {
    ssout(cmn, ib, erk, eik, erm, eim, currk, curik, currm, curim);
  }
  cik(ib) = 0.0f;
  ib++;
  goto statement_6010;
statement_6060:
  if (L > 1) {
    goto statement_6080;
  }
  //C              SINGLE  PI  SECTION  CALCULATIONS                           10221
  kib = fem::iabs(kbus(ib));
  in = norder(kib);
  mib = fem::iabs(mbus(ib));
  jn = norder(mib);
  yr = tr(jb);
  yi = tx(jb);
  if (iprsup >= 4) {
    write(6, star), "I, JB, TR(JB), TX(JB), IMODEL(IB)= ", i, jb, tr(jb),
      tx(jb), imodel(ib);
  }
  if (imodel(ib) == -4) {
    goto statement_6067;
  }
  yi = tx(jb) * omegal;
  yy = tr(jb) * tr(jb) + yi * yi;
  yr = tr(jb) / yy;
  yi = -yi / yy;
statement_6067:
  erk = solr(in);
  eik = soli(in);
  erm = solr(jn);
  eim = soli(jn);
  der = erk - erm;
  dei = eik - eim;
  ctr = yr * der - yi * dei;
  cti = yr * dei + yi * der;
  yis = c(jb) * omegac;
  if (kbus(ib) >= 0) {
    goto statement_6076;
  }
  yrs = r(jb);
  csr = yrs * erk - yis * eik;
  csi = yrs * eik + yis * erk;
  currk = ctr + csr;
  curik = cti + csi;
  tr(jb) = currk;
  tx(jb) = curik;
  csr = yrs * erm - yis * eim;
  csi = yrs * eim + yis * erm;
  currm = csr - ctr;
  curim = csi - cti;
  r(jb) = currm;
  c(jb) = curim;
  goto statement_6078;
statement_6076:
  cik(ib) = ctr;
  currk = -yis * eik;
  curik = yis * erk;
  currm = -yis * eim;
  curim = yis * erm;
  ci(ib) = currk;
  ck(ib) = currm;
  currk += ctr;
  curik += cti;
  currm = currm - ctr;
  curim = curim - cti;
statement_6078:
  if (kssout == 1 || kssout == 3) {
    ssout(cmn, ib, erk, eik, erm, eim, currk, curik, currm, curim);
  }
  ib++;
  goto statement_6094;
  //C              MULTIPLE  PI  SECTION  CALCULATIONS                         10268
statement_6080:
  ibf = ib - 1;
  ld = jb - 1;
  ldd = jb - 1;
statement_6090:
  jb = ibf;
  clir = 0.0f;
  clii = 0.0f;
  cljr = 0.0f;
  clji = 0.0f;
  ctr = 0.0f;
  cti = 0.0f;
statement_6100:
  ld++;
  jb++;
  ia = fem::iabs(kbus(jb));
  ia = norder(ia);
  lstat(52) = ia;
  ja = fem::iabs(mbus(jb));
  ja = norder(ja);
  der = solr(ia) - solr(ja);
  dei = soli(ia) - soli(ja);
  csr = omegac * c(ld);
  ctr += tr(ld) * der - tx(ld) * dei;
  cti += tr(ld) * dei + tx(ld) * der;
  clir = clir - csr * soli(ia);
  clii += csr * solr(ia);
  cljr = cljr - csr * soli(ja);
  clji += csr * solr(ja);
  if (kbus(jb) >= 0) {
    goto statement_6110;
  }
  clir += r(ld) * solr(ia);
  clii += r(ld) * soli(ia);
  cljr += r(ld) * solr(ja);
  clji += r(ld) * soli(ja);
statement_6110:
  if (jb < ib) {
    goto statement_6100;
  }
  kd = ld;
  erk = solr(ia);
  eik = soli(ia);
  erm = solr(ja);
  eim = soli(ja);
statement_6140:
  if (jb == ibf + L) {
    goto statement_6160;
  }
  kd += jb - ibf;
  jb++;
  ia = fem::iabs(kbus(jb));
  ia = norder(ia);
  lstat(52) = ia;
  ja = fem::iabs(mbus(jb));
  ja = norder(ja);
  der = solr(ia) - solr(ja);
  dei = soli(ia) - soli(ja);
  csr = omegac * c(kd);
  ctr += tr(kd) * der - tx(kd) * dei;
  cti += tr(kd) * dei + tx(kd) * der;
  clir = clir - csr * soli(ia);
  clii += csr * solr(ia);
  cljr = cljr - csr * soli(ja);
  clji += csr * solr(ja);
  if (kbus(jb) >= 0) {
    goto statement_6140;
  }
  clir += r(kd) * solr(ia);
  clii += r(kd) * soli(ia);
  cljr += r(kd) * solr(ja);
  clji += r(kd) * soli(ja);
  goto statement_6140;
statement_6160:
  currk = ctr + clir;
  curik = cti + clii;
  currm = -ctr + cljr;
  curim = -cti + clji;
  if (kbus(ib) >= 0) {
    goto statement_6164;
  }
  ldd++;
  tr(ldd) = currk;
  tx(ldd) = curik;
  r(ldd) = currm;
  c(ldd) = curim;
  goto statement_6166;
statement_6164:
  cik(ib) = ctr;
  ci(ib) = clir;
  ck(ib) = cljr;
statement_6166:
  if (kssout == 1 || kssout == 3) {
    ssout(cmn, ib, erk, eik, erm, eim, currk, curik, currm, curim);
  }
  ib++;
  if (ib <= ibf + L) {
    goto statement_6090;
  }
statement_6094:
  if (kodsem(ib - 1) == 0 || imodel(ib - 1) == -2) {
    goto statement_6010;
  }
  if (imodel(ib - 1) == -4) {
    goto statement_6010;
  }
statement_6095:
  if (cki(ib - 1) < 0.0f) {
    goto statement_6010;
  }
  ib++;
  goto statement_6095;
statement_6200:
  n1 = 2;
  vecrsv(cmn, diag(1), ntot, n1);
  vecrsv(cmn, diab(1), ntot, n1);
  vecrsv(cmn, gnd(iofgnd + 1), ioffd, n1);
  vecrsv(cmn, bnd(iofbnd + 1), ioffd, n1);
  if (ncurr <= 0) {
    ncurr = 1;
  }
  move0(e, ntot);
  move0(f, ntot);
  FEM_DO_SAFE(i, 1, ntot) {
    vr = solr(i);
    vi = soli(i);
    jj = index(i);
    kkk = index(i + 1);
    e(i) += diag(i) * vr - diab(i) * vi;
    f(i) += diag(i) * vi + diab(i) * vr;
    goto statement_7370;
  statement_7360:
    jj++;
  statement_7370:
    if (jj >= kkk) {
      goto statement_7380;
    }
    j = iloc(jj);
    isubs1 = iofgnd + jj;
    isubs2 = iofbnd + jj;
    der = gnd(isubs1) * vr - bnd(isubs2) * vi;
    dei = gnd(isubs1) * vi + bnd(isubs2) * vr;
    e(j) += der;
    f(j) += dei;
    e(i) += gnd(isubs1) * solr(j) - bnd(isubs2) * soli(j);
    f(i) += gnd(isubs1) * soli(j) + bnd(isubs2) * solr(j);
    goto statement_7360;
  statement_7380:;
  }
  if (kssout == 0) {
    goto statement_7394;
  }
  d26 = 0.0f;
  FEM_DO_SAFE(i, 1, ntot) {
    d26 += e(i) * solr(i) + f(i) * soli(i);
  }
  d26 = d26 * onehaf;
  write(lunit6,
    "(/,8x,'TOTAL NETWORK LOSS \"PLOSS\" BY SUMMING NODAL INJECTIONS =',"
    "e20.10)"),
    d26;
  cmn.out_stream << "\n TOTAL NETWORK LOSS \"PLOSS\" BY SUMMING NODAL INJECTIONS = " << SState("e20.10") << d26 << '\n';
statement_7394:
  if (kswtch <= 0) {
    goto statement_7396;
  }
  FEM_DO_SAFE(i, 1, kconst) {
    if (node(i) > 0) {
      goto statement_6009;
    }
    if (tstart(i) >= 0) {
      goto statement_6009;
    }
    if (fem::iabs(iform(i)) != 14) {
      goto statement_6009;
    }
    kt = fem::iabs(node(i));
    k = norder(kt);
    e(k) = e(k) - crest(i) * cosz(time1(i));
    f(k) = f(k) - crest(i) * sinz(time1(i));
  statement_6009:;
  }
  move0(nextsw, kswtch);
  move0(energy, kswtch);
  FEM_DO_SAFE(i, 1, kswtch) {
    if (adelay(i) == 44444.f) {
      goto statement_6111;
    }
    if (tclose(i) < 0.0f) {
      nextsw(i) = 88;
    }
  statement_6111:;
  }
  n8 = 0;
statement_8516:
  n9 = 0;
  n5 = 0;
  FEM_DO_SAFE(i, 1, kswtch) {
    if (nextsw(i) == 87) {
      goto statement_8657;
    }
    if (nextsw(i) == 88) {
      goto statement_8521;
    }
    n9++;
    goto statement_8657;
  statement_8521:
    kt = kmswit(i);
    k = norder(kt);
    ndx5 = lswtch + i;
    mt = kmswit(ndx5);
    m = norder(mt);
    n13 = k;
  statement_4511:
    if (n13 == norder(1)) {
      goto statement_4544;
    }
    FEM_DO_SAFE(j, 1, kswtch) {
      if (nextsw(j) < 88) {
        goto statement_4522;
      }
      if (i == j) {
        goto statement_4522;
      }
      nt1 = kmswit(j);
      n1 = norder(nt1);
      ndx3 = lswtch + j;
      nt2 = kmswit(ndx3);
      n2 = norder(nt2);
      if (n13 == n1) {
        goto statement_4544;
      }
      if (n13 == n2) {
        goto statement_4544;
      }
    statement_4522:;
    }
    FEM_DO_SAFE(j, 1, kconst) {
      if (node(j) < 0) {
        goto statement_4533;
      }
      js = norder(node(j));
      if (js != n13) {
        goto statement_4533;
      }
      if (tstart(j) >= 0.0f) {
        goto statement_4533;
      }
      if (fem::iabs(iform(j)) != 14) {
        goto statement_4533;
      }
      goto statement_4544;
    statement_4533:;
    }
    if (iprsup >= 4) {
      write(lunit6, "(' CURRENT.  I, K, N13 =',3i8)"), i, k, n13;
    }
    tclose(i) = e(n13);
    energy(i) = f(n13);
    e(n13) = 0.0f;
    f(n13) = 0.0f;
    nextsw(i) = 87;
    n8++;
    n5 = 1;
    if (n13 == m) {
      m = k;
    }
    e(m) += tclose(i);
    f(m) += energy(i);
    m = norder(mt);
    if (n13 == m) {
      goto statement_7657;
    }
    tclose(i) = -tclose(i);
    energy(i) = -energy(i);
  statement_7657:
    k1 = kdepsw(lswtch + i);
    if (k1 != 8888) {
      goto statement_8657;
    }
    mk = -adelay(i);
    if (mk <= 0.0f) {
      goto statement_8657;
    }
    num = kssfrq(kt);
    ang = twopi * sfreq(num) * cmn.deltat;
    a8sw(mk + 6) = tclose(i) * cosz(ang) - energy(i) * sinz(ang);
    goto statement_8657;
  statement_4544:
    if (n13 == m) {
      goto statement_8657;
    }
    n13 = m;
    goto statement_4511;
  statement_8657:;
  }
  if (iprsup >= 2) {
    write(lunit6, "(' BELOW 8657.  N5, N8, N9 =',3i8)"), n5, n8, n9;
  }
  if (n5 == 0) {
    goto statement_8669;
  }
  goto statement_8516;
statement_8669:
  n8 += n9;
  if (n8 == kswtch) {
    goto statement_8681;
  }
  write(lunit6,
    "('ILLEGAL SWITCH/SOURCE CONNECTION. N8, KSWTCH =',2i8)"), n8,
    kswtch;
  kill = 64;
  lstat(19) = 8669;
  bus1 = cmn.trash;
  goto statement_9800;
statement_8681:
  if (kssout == 0) {
    goto statement_8715;
  }
  if (kol132 == 132) {
    write(lunit6,
      "(' OUTPUT FOR STEADY STATE SWITCH CURRENT',/,7x,'NODE-K',4x,'NODE-M',"
      "10x,'I-REAL',12x,'I-IMAG',12x,'I-MAGN',10x,'DEGREES',8x,'POWER ',10x,"
      "'REACTIVE')");
    cmn.out_stream << " OUTPUT FOR STEADY STATE SWITCH CURRENT\n"
      << std::string(7, ' ') << "NODE-K" << std::string(4, ' ') << "NODE-M" << std::string(10, ' ') << "I-REAL"
      << std::string(12, ' ') << "I-IMAG" << std::string(12, ' ') << "I-MAGN" << std::string(10, ' ') << "DEGREES"
      << std::string(8, ' ') << "POWER" << std::string(10, ' ') << "REACTIVE\n";
  }
  if (kol132 == 80) {
    write(lunit6,
      "(' OUTPUT FOR STEADY STATE SWITCH CURRENT',/,1x,'NODE-K',2x,'NODE-M',"
      "10x,'I-REAL',10x,'I-IMAG',10x,'I-MAGN',9x,'DEGREES')");
  }
  FEM_DO_SAFE(i, 1, kswtch) {
    ndx4 = lswtch + i;
    k = kmswit(i);
    m = kmswit(ndx4);
    if (nextsw(i) != 87) {
      goto statement_8695;
    }
    d6 = fem::pow2(tclose(i)) + fem::pow2(energy(i));
    d4 = sqrtz(d6);
    d5 = std::atan2(energy(i), tclose(i));
    d5 = d5 * 360.f / twopi;
    nn = norder(k);
    power = onehaf * (solr(nn) * tclose(i) + soli(nn) * energy(i));
    react = onehaf * (soli(nn) * tclose(i) - solr(nn) * energy(i));
    if (kol132 == 132) {
      write(lunit6, "(5x,2a10,3e18.8,f13.4,2e18.8)"), bus(k), bus(m),
        tclose(i), energy(i), d4, d5, power, react;
      cmn.out_stream << std::string(5, ' ') << std::setw(10) << std::string(bus(k)) << std::setw(10) << std::string(bus(m))
        << SState("e18.8") << tclose(i) << SState("e18.8") << energy(i) << SState("e18.8") << d4 << SState("f13.4") << d5
        << SState("e18.8") << power << SState("e18.8") << react << '\n';
    }
    if (kol132 == 80) {
      write(lunit6, "(1x,a6,2x,a6,3e16.7,f16.6)"), bus(k), bus(m),
        tclose(i), energy(i), d4, d5;
    }
    goto statement_8713;
  statement_8695:
    if (adelay(i) == 44444.f) {
      goto statement_8703;
    }
    if (tclose(i) > 0.0f) {
      goto statement_8703;
    }
    if (kol132 == 132) {
      write(lunit6, "(5x,2a10,2(5x,'CLOSE AT T=0+'))"), bus(k), bus(m);
      cmn.out_stream << std::string(5, ' ') << std::setw(10) << std::string(bus(k)) << std::setw(10) << std::string(bus(m))
        << "     CLOSE AT T=0+" << "     CLOSE AT T=0+\n";
    }
    if (kol132 == 80) {
      write(lunit6, "(1x,a6,2x,a6,2(5x,'CLOSE AT T=0+'))"), bus(k), bus(m);
    }
    goto statement_8713;
  statement_8703:
    if (kol132 == 132) {
      write(lunit6, "(5x,2a10,4(10x,'OPEN',6x),8x,'OPEN')"), bus(k), bus(m);
      cmn.out_stream << std::string(5, ' ') << std::setw(10) << std::string(bus(k)) << std::setw(10) << std::string(bus(m))
        << "          OPEN      " << "          OPEN      " << "          OPEN      " << "          OPEN      "
        << "        OPEN\n";
    }
    if (kol132 == 80) {
      write(lunit6, "(1x,a6,2x,a6,3(12x,'OPEN'))"), bus(k), bus(m);
    }
  statement_8713:;
  }
statement_8715:
  ktrlsw(1) = 8877;
statement_7396:
  if (kssout <= 0) {
    goto statement_8350;
  }
  if (kol132 == 132) {
    write(lunit6,
      "(/,' SOLUTION AT NODES WITH KNOWN VOLTAGE.     NODES SHORTED TOGETHER B"
      "Y SWITCHES ARE SHOWN AS A GROUP OF NAMES, WITH',/,"
      "' THE PRINTED RESULT APPLYING TO THE COMPOSITE GROUP.   THE ENTRY ''MVA"
      "'' IS  SQRT(P**2 + Q**2)  IN UNITS OF POWER,',/,"
      "' WHILE  ''P.F.''  IS THE ASSOCIATED POWER FACTOR.',/,17x,'NODE',16x,"
      "'SOURCE NODE VOLTAGE',12x,'INJECTED SOURCE CURRENT',14x,"
      "'INJECTED SOURCE POWER',/,17x,'NAME',2(9x,'RECTANGULAR',10x,'POLAR'),"
      "13x,'P AND Q',3x,'MVA AND P.F.')");
    cmn.out_stream << "\nSOLUTION AT NODES WITH KNOWN VOLTAGE. NODES SHORTED TOGETHER BY SWITCHES ARE SHOWN AS A GROUP OF NAMES, WITH\n"
      << "THE PRINTED RESULT APPLYING TO THE COMPOSITE GROUP. THE ENTRY 'MVA' IS SQRT(P**2 + Q**2) IN UNITS OF POWER,\n"
      << " WHILE 'P.F.' IS THE ASSOCIATED POWER FACTOR.\n" << std::string(17, ' ') << "NODE" << std::string(16, ' ')
      << "SOURCE NODE VOLTAGE" << std::string(12, ' ') << "INJECTED SOURCE CURRENT" << std::string(14, ' ') << "INJECTED SOURCE POWER\n"
      << std::string(17, ' ') << "NAME" << std::string(9, ' ') << "RECTANGULAR" << std::string(10, ' ') << "POLAR"
      << std::string(9, ' ') << "RECTANGULAR" << std::string(10, ' ') << "POLAR" << std::string(13, ' ') << "P AND Q   MVA AND P.F.\n";
  }
  if (kol132 != 132) {
    write(lunit6,
      "(' 80-COLUMN INJECTION PRINTOUT AT NODES',' WITH KNOWN VOLTAGE.',/,16x,"
      "'NODE','  VK-MAGNITUDE ','  IK-MAGNITUDE ','    PK (WATTS) ',"
      "'  MVA (WATTS)  ',/,16x,'NAME','  VK-DEGREES   ','  IK-DEGREES   ',"
      "'    QK (VARS)  ','  POWER FACTOR ')");
  }
statement_8350:
  FEM_DO_SAFE(k, 1, ntot) {
    j = norder(k);
    index(j) = k;
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,1x,'     ROW  NORDER   INDEX    KODE',14x,'E',14x,'F',11x,'DIAG',"
        "11x,'DIAB',/(1x,4i8,4e15.6))");
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, i, norder(i), index(i), kode(i), e(i), f(i), diag(i), diab(i);
      }
    }
  }
  i = ncurr + 1;
statement_7405:
  if (i > ntot) {
    goto statement_7456;
  }
  j = kode(i);
  if (j <= i) {
    goto statement_7410;
  }
  e(j) += e(i);
  f(j) += f(i);
  goto statement_7440;
statement_7410:
  L = 1;
  kkk = index(i);
  if (kkk == 1) {
    goto statement_7440;
  }
  aupper(1) = bus(kkk);
statement_7420:
  if (j >= i) {
    goto statement_7430;
  }
  if (L < 13) {
    L++;
  }
  kkk = index(j);
  aupper(L) = bus(kkk);
  if (aupper(L) == blank) {
    aupper(L) = cmn.terra;
  }
  j = kode(j);
  goto statement_7420;
statement_7430:
  if (kssout == 0) {
    goto statement_7440;
  }
  write(lunit6, format_7431);
  cmn.out_stream << '\n';
  n13 = L - 1;
  if (n13 > 0) {
    {
      write_loop wloop(cmn, lunit6, format_7431);
      FEM_DO_SAFE(j, 1, n13) {
        wloop, aupper(j);
        cmn.out_stream << std::string(15, ' ') << std::setw(6) << std::string(aupper(j)) << '\n';
      }
    }
  }
  cmn.bus5 = aupper(L);
  ib = -1;
  rd = 1.0f;
  ssout(cmn, ib, solr(i), soli(i), rd, rd, e(i), f(i), rd, rd);
statement_7440:
  i++;
  goto statement_7405;
statement_7456:
  if (loopss(1) <= 0) {
    goto statement_7452;
  }
  lastov = nchain;
  nchain = 8;
  write(lunit6,
    "(' COMPLETE ANOTHER INTERNAL PHASOR SOLUTION',"
    "' FOR U.M.   EXIT \"OVER11\", BACK TO \"OVER8\".')");
  goto statement_9900;
statement_7452:
  if (loopss(1) == 0) {
    goto statement_7453;
  }
  kconst = loopss(3);
  ibr = loopss(5);
  //C     WORK ON SYNCHRONOUS MACHINE STEADY-STATE SOLUTION OUTPUT, PLUS    M31.2654
  //C     CALCULATION OF INITIAL CONDITIONS FOR TIME  T = 0.0   .           M31.2655
statement_7453:
  if (cmn.numsm == 0) {
    goto statement_6207;
  }
  smint(cmn);
  if (kill > 0) {
    goto statement_9800;
  }
statement_6207:
  FEM_DO_SAFE(i, 1, ntot) {
    j = norder(i);
    e(i) = solr(j);
    f(i) = soli(j);
  }
  if (iprsup > 0) {
    write(lunit6, "(' STEADY-STATE PHASOR NETWORK SOLUTION NOW COMPLETE.')");
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' (BUS(I), I=1, NTOT)  IN  OVER11.',/(1x,10a8))");
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, bus(i);
      }
    }
  }
  if (cmn.tmax > 0.0f) {
    goto statement_9700;
  }
  if (fmaxfs == 0.0f) {
    goto statement_7027;
  }
  if (knt == 1 && nsolve == 0) {
    goto statement_7027;
  }
  goto statement_8102;
statement_7027:
  numnvo = 0;
  //C     READ INPUT CARD USING CIMAGE.                                        10437
statement_7030:
  cimage(cmn);
  read(abuff, "(i2,13a6)"), ivolt, aupper;
  if (ivolt == 1) {
    goto statement_7050;
  }
  if (ivolt != 0) {
    goto statement_7030;
  }
  n1 = 0;
  FEM_DO_SAFE(k, 1, 13) {
    bus1 = aupper(k);
    if (bus1 != blank) {
      goto statement_6847;
    }
  }
  write(lunit6, "('+BLANK CARD ENDING NODE NAMES FOR VOLTAGE OUTPUT.')");
  goto statement_8102;
statement_6847:
  write(lunit6, "('+CARD OF BUS NAMES FOR NODE-VOLTAGE OUTPUT.')");
  k = 1;
statement_7048:
  if (k > 13) {
    goto statement_7030;
  }
  bus1 = aupper(k);
  if (bus1 == blank) {
    goto statement_7040;
  }
  FEM_DO_SAFE(i, 2, ntot) {
    if (bus1 == bus(i)) {
      goto statement_7043;
    }
  }
  write(lunit6,
    "(5x,'REQUESTED OUTPUT FOR NONEXISTENT NODE  ''',a6,"
    "'''  WILL BE IGNORED.')"),
    bus1;
  goto statement_7040;
statement_7043:
  numnvo++;
  if (numnvo > lsiz27 || numnvo > lsiz12) {
    goto statement_8080;
  }
  imfd(numnvo) = i;
statement_7040:
  k++;
  goto statement_7048;
statement_8080:
  write(lunit6,
    "(' THE NUMBER OF REQUESTS FOR NODE VOLTAGE',"
    "' OUTPUTS EXCEEDS THE MAXIMUM NUMBER  OF',"
    "' NODE VOLTAGE OUTPUTS (\"LSIZ12\"), OR THE SIZE',/,"
    "' OF LIST 27 (\"LSIZ27\").  TEMPORARY ERROR',"
    "' STOP AT S.N. 8080 OF \"OVER11\".',3i8)"),
    numnvo, lsiz12, lsiz27;
  stoptp(cmn);
statement_7050:
  write(lunit6, "('+REQUEST FOR OUTPUT OF ALL NODE VOLTAGES.')");
  if (ntot1 > lsiz27 || ntot1 > lsiz12) {
    goto statement_8080;
  }
  FEM_DO_SAFE(i, 2, ntot) {
    imfd(i - 1) = i;
  }
  numnvo = ntot1;
  if (aupper(1) != blank) {
    goto statement_7030;
  }
statement_8102:
  if (fmaxfs == 0.0f) {
    write(lunit6,
      "(/,/,"
      "' BEGIN STEADY-STATE PRINTOUT OF EMTP OUTPUT VARIABLES.   NODE VOLTAGE "
      "OUTPUT FOLLOWS.',/,7x,'BUS',14x,'PHASOR',7x,'ANGLE IN',16x,'REAL',11x,"
      "'IMAGINARY',/,6x,'NAME',11x,'MAGNITUDE',8x,'DEGREES',16x,'PART',16x,"
      "'PART')");
    cmn.out_stream << "\nBEGIN STEADY-STATE PRINTOUT OF EMTP OUTPUT VARIABLES. NODE VOLTAGE OUTPUT FOLLOWS.\n"
      << std::string(7, ' ') << "BUS" << std::string(14, ' ') << "PHASOR" << std::string(7, ' ') << "ANGLE IN"
      << std::string(16, ' ') << "REAL" << std::string(11, ' ') << "IMAGINARY\n"
      << std::string(6, ' ') << "NAME" << std::string(11, ' ') << "MAGNITUDE" << std::string(8, ' ') << "DEGREES"
      << std::string(16, ' ') << "PART" << std::string(16, ' ') << "PART\n";
  }
  if (cmn.istead == 0) {
    goto statement_8100;
  }
  if (numnvo == 0) {
    goto statement_8100;
  }
  FEM_DO_SAFE(k, 1, numnvo) {
    i = imfd(k);
    h1 = e(i);
    h2 = f(i);
    a = sqrtz(fem::pow2(h1) + fem::pow2(h2));
    gus1 = h1;
    if (a == 0.f) {
      gus1 = 1.0f;
    }
    ck1 = std::atan2(h2, gus1) * 360.f / twopi;
    if (fmaxfs == 0) {
      write(lunit6, "(4x,a6,e20.8,f15.6,2e20.8)"), bus(i), a, ck1, h1, h2;
      cmn.out_stream << "    " << std::string(bus(i)).substr(0, 6) << SState("e20.7") << a << SState("f15.6") << ck1
        << SState("e20.7") << h1 << SState("e20.7") << h1 << '\n';
    }
    solr(k) = a;
    soli(k) = ck1;
    voltk(k) = h1;
    volt(k) = h2;
    if (k < lsiz26) {
      goto statement_8105;
    }
    write(lunit6,
      "(/,' PERMANENT ERROR STOP DUE TO OVERFLOW',"
      "' OF LIST-26 VECTORS \"VOLTK\", \"VOLT\".',i8)"),
      lsiz26;
    kill = 1;
    lstat(19) = 8105;
    lstat(17) = 26;
    goto statement_9800;
  statement_8105:;
  }
statement_8100:
  if (fmaxfs > 0.0f) {
    goto statement_8120;
  }
  write(lunit6,
    "(/,' EMTP BRANCH-CURRENT OUTPUT FOLLOWS',/,8x,'FROM',10x,'TO',11x,"
    "'MAGNITUDE',7x,'ANGLE IN',16x,'REAL',11x,'IMAGINARY',/,9x,'BUS',9x,'BUS',"
    "11x,'OF PHASOR',8x,'DEGREES',2(16x,'PART'))");
  FEM_DO_SAFE(i, 1, ibr) {
    icheck = mbus(i);
    if (icheck >= 0) {
      goto statement_8110;
    }
    n1 = kbus(i);
    n2 = fem::iabs(nr(i));
    h1 = tr(n2);
    icheck = -icheck;
    n15 = icheck;
    if (n15 == 1) {
      n15 = fem::iabs(n1);
    }
    xopt = xoptbr(i);
    copt = coptbr(i);
    n16 = fem::iabs(kssfrq(n15));
    omega = twopi * sfreq(n16);
    d2 = omega * tenm3;
    h3 = 1000.f / d2;
    if (xopt > 0.0f) {
      d2 = omega / (xopt * twopi);
    }
    if (copt > 0.0f) {
      h3 = 1000000.f * copt * twopi / omega;
    }
    if (n1 > 0) {
      goto statement_8107;
    }
    n1 = -n1;
    h2 = tx(n2);
    goto statement_8108;
  statement_8107:
    h2 = tx(n2) * d2;
    a = c(n2);
    if (a > 0.0f) {
      h2 = h2 - h3 / a;
    }
    a = fem::pow2(h1) + fem::pow2(h2);
    gus1 = h1 / a;
    gus2 = -h2 / a;
    gus3 = e(n1) - e(icheck);
    gus4 = f(n1) - f(icheck);
    h1 = gus1 * gus3 - gus2 * gus4;
    h2 = gus1 * gus4 + gus2 * gus3;
  statement_8108:
    a = sqrtz(fem::pow2(h1) + fem::pow2(h2));
    gus1 = h1;
    if (a == 0.f) {
      gus1 = 1.0f;
    }
    ck1 = std::atan2(h2, gus1) * 360.f / twopi;
    write(lunit6, "(6x,a6,6x,a6,e20.8,f15.6,2e20.8)"), bus(n1), bus(icheck),
      a, ck1, h1, h2;
  statement_8110:;
  }
  if (nv == 0) {
    goto statement_8120;
  }
  write(lunit6,
    "(/,' EMTP BRANCH-VOLTAGE OUTPUT FOLLOWS',' (COLUMN-80 PUNCHES ONLY)',/,"
    "8x,'FROM',10x,'TO',11x,'MAGNITUDE',7x,'ANGLE IN',16x,'REAL',11x,"
    "'IMAGINARY',/,9x,'BUS',9x,'BUS',11x,'OF PHASOR',8x,'DEGREES',2(16x,"
    "'PART'))");
  FEM_DO_SAFE(i, 1, nv) {
    n1 = ibrnch(i);
    n2 = jbrnch(i);
    d1 = e(n1) - e(n2);
    d2 = f(n1) - f(n2);
    d3 = sqrtz(fem::pow2(d1) + fem::pow2(d2));
    d4 = d1;
    if (d3 == 0.0f) {
      d4 = 1.0f;
    }
    d5 = std::atan2(d2, d4) * 360.f / twopi;
    write(lunit6, "(6x,a6,6x,a6,e20.8,f15.6,2e20.8)"), bus(n1), bus(n2),
      d3, d5, d1, d2;
  }
statement_8120:
  if (fmaxfs == 0.0f) {
    goto statement_7481;
  }
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' END FREQ. SCAN LOOP IN  ''OVER11'' .','     KNT  KCONST',9x,"
      "'FMINFS',9x,'DELFFS',9x,'FMAXFS',/,35x,2i8,3e15.6)"),
      knt, kconst, fminfs, delffs, fmaxfs;
  }
  d4 = fminfs;
  if (delffs < 0) {
    d4 = alog1z(d4);
  }
  if (knt > 1 || kexact == 88333) {
    goto statement_7473;
  }
  write(lunit6,
    "(/,' THE   ''FREQUENCY SCAN''   OUTPUT VECTOR HAS THE FOLLOWING FORMAT.  "
    " CELL NUMBER ONE CONTAINS THE FREQUENCY',/,"
    "' OF THE PHASOR SOLUTION (OR THE BASE-10 LOGARITHM OF THIS, IN THE CASE O"
    "F GEOMETRIC FREQUENCY SPACING).   CELLS',/,"
    "' NUMBERED TWO ONWARD CONTAIN THE PAIRS OF MAGNITUDE AND ANGLE OF THE PHA"
    "SOR NODE VOLTAGES.   THESE PAIRS ARE IN THE',/,"
    "' ORDER REQUESTED BY THE USER ON THE CARD FOR SELECTIVE NODE VOLTAGE OUTP"
    "UT.   FOR PLOTTING PURPOSES, THESE OUTPUT')");
  write(lunit6,
    "(' VARIABLES ARE TREATED AS THOUGH THEY WERE ORDINARY EMTP BRANCH CURRENT"
    "S (PLOT TYPE-CODE  ''9'' ).   BOTH THE',/,"
    "' MAGNITUDE AND THE ANGLE USE THE ACTUAL NODE NAME FOR THE FIRST IDENTIFY"
    "ING VARIABLE,  AND THEN EITHER   ''MAG   ''   OR',/,"
    "' ''ANGLE''   FOR THE SECOND.        IN RESPONSE',"
    "' TO AN IREQ REQUEST DURING MAY OF 1981,',/,"
    "' RECTANGULAR OUTPUTS (USING ''REAL'' AND ''IMAG'' AS',"
    "' SECOND IDENTIFYING NAMES FOR PLOTTING) HAVE',/,"
    "' BEEN APPENDED.   IN THE PRINTED OUTPUT, THIS',"
    "' ALTERNATE RECTANGULAR OUTPUT VECTOR FOLLOWS THE')");
  write(lunit6,
    "(' ORIGINAL POLAR ONE, WITH THE SAME NODE ORDERING',"
    "' (ONLY WITH ''REAL'' TAKING THE PLACE OF ''MAG''',/,"
    "' AND ''IMAG'' TAKING THE PLACE OF ''ANGLE'').',"
    "'   THERE IS COLUMN ALIGNMENT (THE RECTANGULAR',/,"
    "' OUTPUT FOR ANY NODE IS LOCATED VERTICALLY',"
    "' BELOW THE CORRESPONDING POLAR OUTPUT).')");
  if (ivolt == 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' ACTUALLY, THE USER REQUESTED THE OUTPUT OF ALL NODE VOLTAGES BY ME"
        "ANS OF A  ''1''-PUNCH IN COLUMN NUMBER TWO.',/,"
        "' IN THIS CASE, THE ORDERING OF NODES FOR OUTPUT PURPOSES IS AS FOLLO"
        "WS ....',/(1x,20a6))");
      FEM_DO_SAFE(i, ll2, ntot) {
        wloop, bus(i);
      }
    }
  }
  write(lunit6, "(1x)");
statement_7473:
  if (cmn.iplot < 0) {
    goto statement_7462;
  }
  if (knt > 1) {
    goto statement_7459;
  }
  if (nsolve == 1) {
    goto statement_7459;
  }
  n7 = ntot + 4;
  if (kexact == 88333) {
    n7 += 2;
  }
  n6 = 0;
  n5 = 4 * numnvo;
  n85 = n5;
  if (kexact == 88333) {
    n85 = 2 * n5;
  }
  n71 = 2 * numnvo;
  n74 = 0;
  if (kexact == 88333) {
    n74 = numnvo;
  }
  lstat(32) = n5;
  if (kexact == 88333) {
    lstat(32) = n85 + n71;
  }
  begmax(1) = 0.0f;
  cmn.io.rewind(lunit4);
  if (kexact != 88333) {
    {
      write_loop wloop(cmn, lunit4, fem::unformatted);
      wloop, date1, tclock, n7, n6, n5, n85;
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, bus(i);
      }
      wloop, text1, text2, text3, text4;
    }
  }
  if (kexact == 88333) {
    {
      write_loop wloop(cmn, lunit4, fem::unformatted);
      wloop, date1, tclock, n7, n6, n5 + n71, n85 + n71;
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, bus(i);
      }
      wloop, text1, text2, text3, text4, text5, text6;
    }
  }
  n8 = ntot + 1;
  n9 = ntot + 2;
  n18 = ntot + 3;
  n19 = ntot + 4;
  n28 = ntot + 5;
  n29 = ntot + 6;
  ltemp = 1;
  if (kexact == 88333) {
    ltemp = 2;
  }
  //C!w     2 (((N8, N9, I=1, NUMNVO),(N18, N19, I=1, NUMNVO)),JJ=1,LTEMP),
  {
    write_loop wloop(cmn, lunit4, fem::unformatted);
    FEM_DO_SAFE(jj, 1, ltemp) {
      FEM_DO_SAFE(i, 1, numnvo) {
        wloop, imfd(i), imfd(i);
      }
    }
    FEM_DO_SAFE(jj, 1, ltemp) {
      FEM_DO_SAFE(i, 1, numnvo) {
        wloop, imfd(i), imfd(i);
      }
    }
    FEM_DO_SAFE(i, 1, n74) {
      wloop, imfd(i), imfd(i);
    }
    FEM_DO_SAFE(jj, 1, ltemp) {
      FEM_DO_SAFE(i, 1, numnvo) {
        wloop, n8, n9;
      }
    }
    FEM_DO_SAFE(jj, 1, ltemp) {
      FEM_DO_SAFE(i, 1, numnvo) {
        wloop, n18, n19;
      }
    }
    FEM_DO_SAFE(i, 1, n74) {
      wloop, n28, n29;
    }
    FEM_DO_SAFE(i, 1, n74) {
      wloop, n28, n29;
    }
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' LUNIT4 HEADER RECORD.',"
        "'      N5      N6      N7      N8      N9  NUMNVO',/,22x,6i8,5x,"
        "'(IMFD(I), I=1, NUMNVO)  FOLLOW ...',/(1x,20i6))");
      wloop, n5, n6, n7, n8, n9, numnvo;
      FEM_DO_SAFE(i, 1, numnvo) {
        wloop, imfd(i);
      }
    }
  }
statement_7459:
  if (cmn.m4plot == 0) {
    goto statement_7461;
  }
  if (kexact == 88333) {
    goto statement_3010;
  }
statement_3070:
  volti(1) = d4;
  ip = 1;
  if (kexact != 88333) {
    goto statement_3075;
  }
  iq = (knt - 1) * 4 * numnvo;
  ihalf = iq + 2 * numnvo;
  j = 1;
  FEM_DO_SAFE(i, 1, numnvo) {
    volti(ip + 1) = fshold(iq + j);
    volti(ip + 2) = fshold(iq + j + 1);
    j += 2;
    ip += 2;
  }
  k = 1;
  FEM_DO_SAFE(i, 1, numnvo) {
    volti(ip + 1) = fshold(ihalf + k);
    volti(ip + 2) = fshold(ihalf + k + 1);
    k += 2;
    ip += 2;
  }
statement_3075:
  FEM_DO_SAFE(i, 1, numnvo) {
    volti(ip + 1) = solr(i);
    volti(ip + 2) = soli(i);
    ip += 2;
  }
  FEM_DO_SAFE(i, 1, numnvo) {
    volti(ip + 1) = voltk(i);
    volti(ip + 2) = volt(i);
    ip += 2;
  }
  if (kexact != 88333) {
    goto statement_3066;
  }
  n78 = n77 * 2 * n899 + (knt - 1) * 2 * numnvo;
  j = 1;
  FEM_DO_SAFE(i, 1, numnvo) {
    volti(ip + 1) = (volti(j + 1) / volti(j + n77 + 1) - 1.f) * 100.f;
    fshold(n78 + j) = volti(ip + 1);
    volti(ip + 2) = (volti(j + 2) / volti(j + n77 + 2) - 1.f) * 100.f;
    fshold(n78 + j + 1) = volti(ip + 2);
    j += 2;
    ip += 2;
  }
statement_3066:
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6, star);
      wloop, " AFTER DO 17460, IP,VOLTI, FSHOLD=", ip;
      FEM_DO_SAFE(ij, 1, ip) {
        wloop, volti(ij);
      }
      FEM_DO_SAFE(ij, n78 + 1, n78 + j) {
        wloop, fshold(ij);
      }
    }
  }
  pltfil(cmn, ip);
  goto statement_7462;
statement_3010:
  jtemp = knt;
  if (nsolve == 1 && knt == 1) {
    n899 = alogz(fmaxfs / fminsv) / alogz(-delffs) + 2.5f;
  }
  if (nsolve == 1) {
    jtemp = knt + n899;
  }
  n77 = 4 * numnvo;
  ik = (jtemp - 1) * n77;
  FEM_DO_SAFE(i, 1, numnvo) {
    fshold(ik + 1) = solr(i);
    fshold(ik + 2) = soli(i);
    ik += 2;
  }
  FEM_DO_SAFE(i, 1, numnvo) {
    fshold(ik + 1) = voltk(i);
    fshold(ik + 2) = volt(i);
    ik += 2;
  }
  if (nsolve == 0) {
    goto statement_7462;
  }
  goto statement_3070;
statement_7461:
  {
    write_loop wloop(cmn, lunit4, fem::unformatted);
    wloop, d4;
    FEM_DO_SAFE(i, 1, numnvo) {
      wloop, solr(i), soli(i);
    }
    FEM_DO_SAFE(i, 1, numnvo) {
      wloop, voltk(i), volt(i);
    }
  }
statement_7462:
  if (kexact == 88333 && iprsup < 1) {
    goto statement_375;
  }
  if (iout == 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' OUTPUT VECTOR FOR STEP NUMBER',i5,' .   FREQUENCY =',e15.6,"
        "' HZ.',/(1x,8e16.7))");
      wloop, knt, fminfs;
      FEM_DO_SAFE(i, 1, numnvo) {
        wloop, solr(i), soli(i);
      }
    }
  }
  if (iout == 1) {
    {
      write_loop wloop(cmn, lunit6, "(1x,8e16.7)");
      FEM_DO_SAFE(i, 1, numnvo) {
        wloop, voltk(i), volt(i);
      }
    }
  }
statement_375:
  knt++;
  lastov = nchain;
  nchain = 8;
  if (kexact != 88333 || nsolve == 0) {
    goto statement_9900;
  }
  if (nfsout == 3179) {
    goto statement_9750;
  }
  if (knt == 2) {
    dum123 = fminsv * (fem::pow((-delffs), (n899 - 2)));
  }
  if ((fminfs / dum123 + cmn.epsiln - 1.f) >= 0) {
    goto statement_3080;
  }
  goto statement_9900;
statement_3080:
  write(lunit6, "(/,/,/,/,/)");
  write(lunit6, format_3082);
  write(lunit6,
    "(20x,'*',89x,'*',/,20x,'*',89x,'*',/,20x,'*',18x,"
    "'LINE MODEL FREQUENCY SCAN COMPARISON TABLE',12x,2a4,9x,'*')"),
    date1;
  if (numrun == 1) {
    write(lunit6, "(20x,'*',25x,'ZERO-SEQUENCE IMPEDANCE TEST',36x,'*')");
  }
  if (numrun == 2) {
    write(lunit6, "(20x,'*',23x,'POSITIVE-SEQUENCE IMPEDANCE TEST',34x,'*')");
  }
  if (numrun == 3) {
    write(lunit6, "(20x,'*',28x,'MUTUAL IMPEDANCE TEST',47x,'*')");
  }
  write(lunit6, "(20x,'*',89x,'*',/,20x,'*',89x,'*')");
  write(lunit6, format_3082);
  write(lunit6,
    "(/,/,/,31x,'LINE MODEL BEING TESTED',29x,'EXACT-PI MODEL',22x,"
    "' % ERROR ',/,/,/,'  FREQUENCY',2x,'NODE',6x,'MAG',8x,'ANG',8x,'REAL',8x,"
    "'IMAG',10x,'MAG',8x,'ANG',8x,'REAL',7x,'IMAG',9x,'PCTMAG  PCTANG')");
  nfsout = 3179;
  fminfs = fminsv;
  nf = n899 - 1;
  nref = 2 * numnvo;
  ijk = 0;
  FEM_DO_SAFE(i, 1, nf) {
    k = (i - 1) * 4 * numnvo;
    L = k + n899 * 4 * numnvo;
    jpp = n899 * 4 * nref + (i - 1) * nref;
    if (i == 1) {
      goto statement_3086;
    }
    fminfs = fminfs * (-delffs);
    n22 = (i - 1) % iout; //w jmod(i - 1, iout);
    //C  THL, 10/30/89
    if (n22 != 0) {
      goto statement_3100;
    }
  statement_3086:
    ijk++;
    if (ijk > 101) {
      goto statement_9900;
    }
    FEM_DO_SAFE(j, 1, numnvo) {
      ndum = imfd(j);
      n6 = 6;
      fltopt(cmn, fshold(jpp + 1), n6);
      chhold = ansi32(27, 32);
      n6 = 6;
      fltopt(cmn, fshold(jpp + 2), n6);
      if (j != 1) {
        goto statement_3089;
      }
      {
        write_loop wloop(cmn, lunit6,
          "(/,/,1p,1x,e10.3,1x,a6,1x,e10.3,1x,e10.3,2x,e10.3,1x,e10.3,4x,"
          "e10.3,1x,e10.3,2x,e10.3,1x,e10.3,5x,0p,a6,3x,a6)");
        wloop, fminfs, bus(ndum);
        FEM_DO_SAFE(m, 1, 2) {
          wloop, fshold(k + m);
        }
        FEM_DO_SAFE(m, 1, 2) {
          wloop, fshold(k + nref + m);
        }
        FEM_DO_SAFE(m, 1, 2) {
          wloop, fshold(L + m);
        }
        FEM_DO_SAFE(m, 1, 2) {
          wloop, fshold(L + nref + m);
        }
        wloop, chhold, ansi32(27, 32);
      }
      goto statement_3092;
    statement_3089:
      {
        write_loop wloop(cmn, lunit6,
          "(1p,12x,a6,1x,e10.3,1x,e10.3,2x,e10.3,1x,e10.3,4x,e10.3,1x,e10.3,"
          "2x,e10.3,1x,e10.3,5x,0p,a6,3x,a6)");
        wloop, bus(ndum);
        FEM_DO_SAFE(m, 1, 2) {
          wloop, fshold(k + m);
        }
        FEM_DO_SAFE(m, 1, 2) {
          wloop, fshold(k + nref + m);
        }
        FEM_DO_SAFE(m, 1, 2) {
          wloop, fshold(L + m);
        }
        FEM_DO_SAFE(m, 1, 2) {
          wloop, fshold(L + nref + m);
        }
        wloop, chhold, ansi32(27, 32);
      }
    statement_3092:
      k += 2;
      L += 2;
      if (iprsup >= 3) {
        {
          write_loop wloop(cmn, lunit6, star);
          wloop, " FSHOLD FOR % ERROR:", jpp;
          FEM_DO_SAFE(m, 1, 2) {
            wloop, fshold(jpp + m);
          }
        }
      }
      jpp += 2;
    }
  statement_3100:;
  }
  goto statement_9900;
statement_7481:
  icheck = 0;
  if (kexact == 88333 && nsolve == 1) {
    goto statement_3080;
  }
  //C     READ INPUT CARD USING CIMAGE                                         10545
statement_8121:
  cimage(cmn);
  read(abuff, "(13a6)"), aupper;
  FEM_DO_SAFE(i, 1, 13) {
    if (aupper(i) != blank) {
      goto statement_8123;
    }
  }
  write(lunit6, "('+BLANK CARD TERMINATING PLOT SPEC. CARDS.')");
  goto statement_9205;
statement_8123:
  icheck = 1;
  write(lunit6, "('+PLOT CARD DISCARDED IN SEARCH FOR BLANK CARD.')");
  goto statement_8121;
statement_9205:
  lastov = nchain;
  nchain = 51;
  runtym(d1, d2);
  flstat(3) += d1;
  flstat(4) += d2;
  flstat(9) = d1;
  flstat(10) = d2;
  goto statement_9900;
statement_9700:
  lastov = nchain;
  nchain = 8;
  loopss(1) = 7766;
  goto statement_9900;
  //C reset NFSOUT for 2nd and 3rd LMFS data cases
statement_9750:
  nfsout = 0;
  goto statement_9900;
statement_9800:
  lastov = nchain;
  nchain = 51;
  lstat(18) = 11;
statement_9900:
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE OVER11.\"')");
  }

} // over11

void csupdc(
  common& cmn,
  int const& L)
{
  common_write write(cmn);
  const auto& lstat = cmn.lstat;
  auto& sptacs = cmn.sptacs;
  //
  int kjsup = fem::int0;
  int kksup = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int n = fem::int0;
  int nnn = fem::int0;
  double a = fem::double0;
  int nn = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  double b = fem::double0;
  int m = fem::int0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  int ndx3 = fem::int0;
  int ndx4 = fem::int0;
  double d9 = fem::double0;
  int n7 = fem::int0;
  double contss = fem::double0;
  int ji = fem::int0;
  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;

  auto& kspvar = isptacs(6);
  auto& kprsup = isptacs(9);
  auto& kxtcs =  isptacs(17);
  auto& kksus =  isptacs(21);
  auto& kalksu = isptacs(22);
  auto& kinsup = isptacs(23);
  auto& nuk =  lstat(51);
  auto& nsup = lstat(55);
  auto& karg = lstat(56);
  auto& kpar = lstat(57);
  kjsup = kinsup + lstat(65);
  kksup = kjsup + lstat(65);
  if (cmn.iprsup < 6) {
    goto statement_1000;
  }
  write(lunit6,
    "('0ENTERING SUBROUTINE  CSUPDC  AT  T=',e13.6,/,'0E NSUP=',i6,'   KARG=',"
    "i8,'   KPAR=',i6)"),
    cmn.t, nsup, karg, kpar;
  {
    write_loop wloop(cmn, lunit6,
      "('  NUMBER  SUPVAR    JSUP    KSUP',/(4i8))");
    FEM_DO_SAFE(i, 1, nsup) {
      wloop, i, ivarb(i + kspvar), ivarb(i + kjsup), ivarb(i + kksup);
    }
  }
  write(lunit6,
    "('  KARG = ',i8,/,'       N  IOPSUP  IFNSUP',"
    "'  IRGSUP    IDEV     KDJ     KDK  ILDEV1  ILDEV2')"),
    karg;
  FEM_DO_SAFE(i, 1, nsup) {
    n1 = ivarb(kjsup + i);
    if (n1 < 0) {
      goto statement_2014;
    }
    n2 = ivarb(kksup + i);
    {
      write_loop wloop(cmn, lunit6, "(4i8)");
      FEM_DOSTEP(n, n1, n2, 3) {
        wloop, n, ivarb(n + 1), ivarb(n + 2), ivarb(n + 2);
      }
    }
    goto statement_2034;
  statement_2014:
    n1 = -n1;
    write(lunit6, "(i8,24x,5i8)"), n1, ivarb(n1), ivarb(n1 + 1),
      ivarb(n1 + 2), ivarb(n1 + 3), ivarb(n1 + 4);
  statement_2034:;
  }
  if (kpar != 0) {
    {
      write_loop wloop(cmn, lunit6,
        "('0E',5x,'PARSUP ...',/(' E ',5(i3,1x,e15.6,3x)))");
      FEM_DO_SAFE(i, 1, kpar) {
        wloop, i, sptacs(i + kprsup);
      }
    }
  }
statement_1000:
  nnn = kxtcs + nuk + lstat(64);
  i = L;
statement_1234:
  a = 0.0f;
  n1 = -ivarb(kjsup + i);
  n2 = ivarb(kksup + i);
  if (n1 < 0) {
    goto statement_10;
  }
  nn = ivarb(n1);
  if (n2 == 60 || n2 == 61) {
    goto statement_602;
  }
  if (n2 == 63 || n2 == 67) {
    goto statement_602;
  }
  j = ivarb(n1 + 1);
  k = ivarb(n1 + 2);
  b = 0.0f;
  FEM_DO_SAFE(n, j, k) {
    m = kxtcs + ivarb(kalksu + n);
    b += sptacs(m) * ivarb(kksus + n);
  }
statement_602:
  n2 = n2 - 49;
  switch (n2) {
  case 1: goto statement_10;
  case 2: goto statement_651;
  case 3: goto statement_651;
  case 4: goto statement_653;
  case 5: goto statement_10;
  case 6: goto statement_655;
  case 7: goto statement_656;
  case 8: goto statement_10;
  case 9: goto statement_10;
  case 10: goto statement_10;
  case 11: goto statement_660;
  case 12: goto statement_661;
  case 13: goto statement_662;
  case 14: goto statement_10;
  case 15: goto statement_664;
  case 16: goto statement_10;
  case 17: goto statement_666;
  case 18: goto statement_667;
  default: break;
  }
  //C     ---  RELAYS AND LEVEL-TRIGGERS  ---                               M39.2414
statement_651:
  if (sptacs(nn) != 0.0f) {
    b = b * sptacs(nn);
  }
  if (sptacs(nn + 2) > -1.f) {
    goto statement_10;
  }
  a = b;
  goto statement_11;
  //C     ---  VARIABLE TRANSPORT DELAY  ---                                M39.2419
statement_653:
  if (sptacs(nn + 3) == 0.0f) {
    goto statement_10;
  }
  a = b;
  goto statement_11;
  //C     ---  DIGITIZER  ---                                               M39.2423
statement_655:
  if (sptacs(nn + 1) != 1.0f) {
    goto statement_10;
  }
  m = ivarb(n1 + 3);
  n = ivarb(n1 + 4);
  if (sptacs(nn) != 0.0f) {
    b = b * sptacs(nn);
  }
  ndx1 = kprsup + m;
  a = sptacs(ndx1);
  if (m == n) {
    goto statement_11;
  }
  j = m + 1;
  FEM_DO_SAFE(k, j, n) {
    m = n - k + j;
    ndx1 = kprsup + m;
    if (b >= sptacs(ndx1)) {
      goto statement_65501;
    }
  }
  goto statement_11;
statement_65501:
  ndx1 = kprsup + m;
  a = sptacs(ndx1);
  goto statement_11;
  //C     ---  POINT-BY-POINT NON-LINEARITY  ---                            M39.2441
statement_656:
  if (sptacs(nn + 1) != 1.0f) {
    goto statement_10;
  }
  m = ivarb(n1 + 3);
  n = ivarb(n1 + 4);
  if (sptacs(nn) != 0.0f) {
    b = b * sptacs(nn);
  }
  ndx1 = kprsup + m + 1;
  a = sptacs(ndx1);
  if (n <= m + 1) {
    goto statement_11;
  }
  ndx1 = kprsup + m;
  if (b <= sptacs(ndx1)) {
    goto statement_11;
  }
  j = m + 2;
  FEM_DOSTEP(k, j, n, 2) {
    ndx1 = kprsup + k;
    if (b <= sptacs(ndx1)) {
      goto statement_65601;
    }
  }
  ndx1 = kprsup + n;
  a = sptacs(ndx1);
  goto statement_11;
statement_65601:
  ndx1 = kprsup + k + 1;
  ndx2 = kprsup + k - 1;
  ndx3 = kprsup + k;
  ndx4 = kprsup + k - 2;
  d9 = (sptacs(ndx1) - sptacs(ndx2)) / (sptacs(ndx3) - sptacs(ndx4));
  a = sptacs(ndx2) + d9 * (b - sptacs(ndx4));
  goto statement_11;
  //C     ---  INPUT  IF - BLOCK  ---                                       M39.2466
statement_660:
  n7 = sptacs(nn + 1);
  if (n7 < 1 || n7 > 3) {
    goto statement_10;
  }
  j = ivarb(n1 + 1) - n7 + 3;
  ndx4 = kxtcs + ivarb(kalksu + j);
  a = sptacs(ndx4) * ivarb(kksus + j);
  goto statement_11;
  //C     ---  INPUT  SIGNAL  SELECTOR  ---                                 M39.2473
statement_661:
  n7 = sptacs(nn);
  if (n7 <= 0 || n7 > 8) {
    goto statement_10;
  }
  switch (n7) {
  case 1: goto statement_6611;
  case 2: goto statement_6611;
  case 3: goto statement_6611;
  case 4: goto statement_6611;
  case 5: goto statement_6611;
  case 6: goto statement_6616;
  case 7: goto statement_6617;
  case 8: goto statement_6618;
  default: break;
  }
statement_6611:
  j = ivarb(n1 + 1) - n7 + 5;
  m = ivarb(kalksu + j);
  if (m == 0) {
    goto statement_11;
  }
  a = sptacs(kxtcs + m) * ivarb(kksus + j);
  goto statement_11;
statement_6616:
  ndx3 = ivarb(n1 + 3);
  if (ndx3 == 0) {
    goto statement_11;
  }
  a = sptacs(kxtcs + ndx3);
  goto statement_11;
statement_6617:
  a = sptacs(nn + 2);
  goto statement_11;
statement_6618:
  a = sptacs(nn + 1);
  goto statement_11;
  //C     ---  TRACK  AND  SAMPLE  ---                                      M39.2490
statement_662:
  contss = sptacs(nn + 1);
  if (contss < 0.5f) {
    goto statement_10;
  }
  a = sptacs(nn + 2);
  if (contss > 1.5f) {
    a = b;
  }
  goto statement_11;
  //C     --- MIN/MAX TRACKING, CONTROLLED ACCUMULATOR OR COUHTER ---       M39.2496
statement_664:
  if (sptacs(nn) == 0.0f) {
    goto statement_10;
  }
  if (sptacs(nn) == 99999.f) {
    sptacs(nn) = 0.0f;
  }
  a = b + sptacs(nn) * sptacs(nn + 1);
  goto statement_11;
statement_666:
  FEM_DO_SAFE(ji, 1, k) {
    a += sptacs(nn + ji);
  }
  a = sqrtz(a * sptacs(nn) + b * b);
  goto statement_11;
statement_667:
  a = 1.0f;
statement_11:
  ndx1 = nnn + i;
  sptacs(ndx1) = a;
statement_10:
  i = ivarb(kinsup + i);
  if (i > 0) {
    goto statement_1234;
  }
}

void
csupac(
  common& cmn,
  int const& L,
  double const& omegar)
{
  const auto& lstat = cmn.lstat;
  auto& sptacs = cmn.sptacs;
  //
  int i = fem::int0;
  double a = fem::double0;
  double ai = fem::double0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int nn = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  double b = fem::double0;
  double bi = fem::double0;
  int n = fem::int0;
  int m = fem::int0;
  int mi = fem::int0;
  double aa = fem::double0;
  int n7 = fem::int0;
  int ndx4 = fem::int0;
  int ndx5 = fem::int0;
  int ndx3 = fem::int0;
  double contss = fem::double0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;

  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;

  auto& kxar =   isptacs(16);
  auto& kksus =  isptacs(21);
  auto& kalksu = isptacs(22);
  auto& kinsup = isptacs(23);

  auto& nuk = lstat(51);

  int kjsup = kinsup + lstat(65);
  int kksup = kjsup + lstat(65);
  int nnn = kxar + nuk + lstat(64);
  i = L;
statement_1234:
  a = 0.0f;
  ai = 0.0f;
  n1 = -ivarb(kjsup + i);
  n2 = ivarb(kksup + i);
  if (n1 < 0) {
    goto statement_10;
  }
  nn = ivarb(n1);
  if (n2 == 60 || n2 == 61) {
    goto statement_602;
  }
  if (n2 == 63 || n2 == 67) {
    goto statement_602;
  }
  j = ivarb(n1 + 1);
  k = ivarb(n1 + 2);
  b = 0.0f;
  bi = 0.0f;
  FEM_DO_SAFE(n, j, k) {
    m = kxar + ivarb(kalksu + n);
    mi = m + lstat(68);
    b += sptacs(m) * ivarb(kksus + n);
    bi += sptacs(mi) * ivarb(kksus + n);
  }
statement_602:
  n2 = n2 - 49;
  switch (n2) {
  case 1: goto statement_10;
  case 2: goto statement_651;
  case 3: goto statement_651;
  case 4: goto statement_653;
  case 5: goto statement_10;
  case 6: goto statement_10;
  case 7: goto statement_10;
  case 8: goto statement_10;
  case 9: goto statement_10;
  case 10: goto statement_659;
  case 11: goto statement_660;
  case 12: goto statement_661;
  case 13: goto statement_662;
  case 14: goto statement_10;
  case 15: goto statement_664;
  case 16: goto statement_10;
  case 17: goto statement_10;
  case 18: goto statement_10;
  default: break;
  }
  //C     ---  RELAYS AND LEVEL-TRIGGERS  ---                               M39.2540
statement_651:
  if (sptacs(nn + 2) > -1.f) {
    goto statement_10;
  }
  if (sptacs(nn) == 0.0f) {
    goto statement_6511;
  }
  b = b * sptacs(nn);
  bi = bi * sptacs(nn);
statement_6511:
  a = b;
  ai = bi;
  goto statement_11;
  //C     ---  VARIABLE TRANSPORT DELAY  ---                                M39.2548
statement_653:
  if (sptacs(nn + 3) == 0.0f) {
    goto statement_10;
  }
  aa = omegar * cmn.deltat * sptacs(nn + 2);
  a = b * cosz(aa) + bi * sinz(aa);
  ai = bi * cosz(aa) - b * sinz(aa);
  goto statement_11;
  //C       --- SIMPLE DERIVATIVE ---                                       M39.2554
statement_659:
  if (sptacs(nn + 2) != 1.0f) {
    goto statement_10;
  }
  a = -bi * omegar;
  ai = b * omegar;
  goto statement_11;
  //C     ---  INPUT  IF - BLOCK  ---                                       M39.2559
statement_660:
  n7 = sptacs(nn + 1);
  if (n7 < 1 || n7 > 3) {
    goto statement_10;
  }
  j = ivarb(n1 + 1) - n7 + 3;
  ndx4 = kxar + ivarb(kalksu + j);
  ndx5 = ndx4 + lstat(68);
  a = sptacs(ndx4) * ivarb(kksus + j);
  ai = sptacs(ndx5) * ivarb(kksus + j);
  goto statement_11;
  //C     ---  INPUT  SIGNAL  SELECTOR  ---                                 M39.2568
statement_661:
  n7 = sptacs(nn);
  if (n7 <= 0 || n7 > 8) {
    goto statement_10;
  }
  switch (n7) {
  case 1: goto statement_6611;
  case 2: goto statement_6611;
  case 3: goto statement_6611;
  case 4: goto statement_6611;
  case 5: goto statement_6611;
  case 6: goto statement_6616;
  case 7: goto statement_6617;
  case 8: goto statement_6618;
  default: break;
  }
statement_6611:
  j = ivarb(n1 + 1) - n7 + 5;
  m = ivarb(kalksu + j);
  if (m == 0) {
    goto statement_11;
  }
  a = sptacs(kxar + m) * ivarb(kksus + j);
  ai = sptacs(kxar + m + lstat(68)) * ivarb(kksus + j);
  goto statement_11;
statement_6616:
  ndx3 = ivarb(n1 + 3);
  if (ndx3 == 0) {
    goto statement_11;
  }
  a = sptacs(kxar + ndx3);
  ai = sptacs(kxar + ndx3 + lstat(68));
  goto statement_11;
statement_6617:
  a = sptacs(nn + 2);
  goto statement_11;
statement_6618:
  a = sptacs(nn + 1);
  goto statement_11;
  //C     ---  TRACK  AND  SAMPLE  ---                                      M39.2587
statement_662:
  contss = sptacs(nn + 1);
  if (contss < 1.5f) {
    goto statement_10;
  }
  a = b;
  ai = bi;
statement_11:
  ndx1 = nnn + i;
  ndx2 = ndx1 + lstat(68);
  sptacs(ndx1) = a;
  sptacs(ndx2) = ai;
  goto statement_10;
  //C     --- MIN/MAX TRACKING, CONTROLLED ACCUMULATOR OR COUHTER ---       M39.2597
statement_664:
  if (sptacs(nn) != 99999.f) {
    goto statement_10;
  }
  sptacs(nn) = sqrtz(b * b + bi * bi);
statement_10:
  i = ivarb(kinsup + i);
  if (i > 0) {
    goto statement_1234;
  }
}

struct sandnm_save
{
  int L;

  sandnm_save() :
    L(fem::int0)
  {}
};

double sandnm(
  common& cmn,
  double const& x)
{
  double return_value = fem::double0;
  FEM_CMN_SVE(sandnm);
  common_write write(cmn);
  const auto& moncar = cmn.moncar;
  int& kswtch = cmn.kswtch;
  //
  int& L = sve.L;
  if (is_called_first_time) {
    L = 0;
  }
  int knt = fem::int0;
  arr_1d<100, double> a(fem::fill0);
  int n1 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  //C)    THIS VERSION OF  'RANDNM'  IS USED FOR TESTING OF THE             M27. 389
  //C)    STATISTICAL OVERVOLTAGE CAPABILITY OF THE EMTP ONLY.   IT USES    M27. 390
  //C)    BUILT-IN RANDOM NUMBERS, SO AS TO PRODUCE IDENTICAL RESULTS       M27. 391
  //C)    ON ALL COMPUTER SYSTEMS, THEREBY PERMITTING COMPARATIVE           M27. 392
  //C)    VERIFICATION OF RESULTS EXACTLY AS FOR CONVENTIONAL TEST CASES.   M27. 393
  //C)    IN ORDER TO AVOID RE-USE OF RANDOM NUMBERS, THE NUMBER OF         M27. 394
  //C)    ENERGIZATIONS  'NENERG'  TIMES THE NUMBER OF SWITCHES  'KSWTCH'   M27. 395
  //C)    MUST NOT EXCEED THE DIMENSION OF ARRAY  'A' .                     M27. 396
  //C     IF  'STATISTICS'  MISCELLANEOUS DATA PARAMETER  'XMAXMX'          M27. 397
  //C     IS INPUT BY THE USER WITH NEGATIVE VALUE, THE EMTP TAKES          M27. 398
  //C     THIS TO MEAN THAT "SANDNM" IS TO BE USED FOR RANDOM               M27. 399
  //C     NUMBERS RATHER THAN "RANDNM" .                                    M27. 400
  //C!EQUIVALENCE  ( MONCAR(1), KNT )
  //C     BURROUGHS: PRESERVE LOCAL VARIABLE BETWEEN MODULE CALLS:          M32. 247
  knt = moncar(1);
  //C     BEGINNING OF ASSIGNMENT OF RANDOM NUMBERS TO ARRAY  'A' .         M27. 403
  a(1) = .1445312506618f;
  a(2) = .8477795260409f;
  a(3) = .8267723125831f;
  a(4) = .6660710406131f;
  a(5) = .7152322826372f;
  a(6) = .3239128029543f;
  a(7) = .5051959208554f;
  a(8) = .3805491872180f;
  a(9) = .5609474043286f;
  a(10) = .5996361115942f;
  a(11) = .4159594349328f;
  a(12) = .6756609755246f;
  a(13) = .0995378032610f;
  a(14) = .6033780421273f;
  a(15) = .4515533431030f;
  a(16) = .0020932062778f;
  a(17) = .9161858062074f;
  a(18) = .3434229008090f;
  a(19) = .7876940045781f;
  a(20) = .2760908032985f;
  a(21) = .3665660303205f;
  a(22) = .8204300122029f;
  a(23) = .2413831265551f;
  a(24) = .1246653115746f;
  a(25) = .2802441882439f;
  a(26) = .0466535013838f;
  a(27) = .4742772736449f;
  a(28) = .9477027545777f;
  a(29) = .2260144770748f;
  a(30) = .2987460629005f;
  a(31) = .5203589181526f;
  a(32) = .8981967037721f;
  a(33) = .3873885562436f;
  a(34) = .5780913804991f;
  a(35) = .1280852320759f;
  a(36) = .3327754064471f;
  a(37) = .4043867414456f;
  a(38) = .9490362532099f;
  a(39) = .6261391859471f;
  a(40) = .3291406705415f;
  a(41) = .3366864607083f;
  a(42) = .9438413593777f;
  a(43) = .9369008057740f;
  a(44) = .0713971670442f;
  a(45) = .6500854844946f;
  a(46) = .9737952005663f;
  a(47) = .6485758973471f;
  a(48) = .7724301318424f;
  a(49) = .9676692044394f;
  a(50) = .5163953619955f;
  a(51) = .5788464270596f;
  a(52) = .7758933795560f;
  a(53) = .0910635448877f;
  a(54) = .0439510552688f;
  a(55) = .0707223001462f;
  a(56) = .9379043319315f;
  a(57) = .0052391978463f;
  a(58) = .9420572226295f;
  a(59) = .5932597508799f;
  a(60) = .6466146627873f;
  a(61) = .4395400252824f;
  a(62) = .1972895298303f;
  a(63) = .5017482047726f;
  a(64) = .1503404202877f;
  a(65) = .9624699228977f;
  a(66) = .0098276069324f;
  a(67) = .6571365402082f;
  a(68) = .4233003554891f;
  a(69) = .1203194365765f;
  a(70) = .7436871629477f;
  a(71) = .8136524161969f;
  a(72) = .7311319136405f;
  a(73) = .0594772166524f;
  a(74) = .2374863512189f;
  a(75) = .2450459940689f;
  a(76) = .4326371816340f;
  a(77) = .3562832359564f;
  a(78) = .3723442477773f;
  a(79) = .1694432139356f;
  a(80) = .3735622812899f;
  a(81) = .0610718353086f;
  a(82) = .2782657746530f;
  a(83) = .5137050416289f;
  a(84) = .4340395038268f;
  a(85) = .5766543446808f;
  a(86) = .4413641042052f;
  a(87) = .9812390285872f;
  a(88) = .2625281459037f;
  a(89) = .9554345097074f;
  a(90) = .4741647690234f;
  a(91) = .9906793757886f;
  a(92) = .7820837820369f;
  a(93) = .2206664815389f;
  a(94) = .0901816247992f;
  a(95) = .7625227133400f;
  a(96) = .4434728419824f;
  a(97) = .7905859532294f;
  a(98) = .9796097207935f;
  a(99) = .7599602497147f;
  a(100) = .1154361048406f;
  //C     END       OF ASSIGNMENT OF RANDOM NUMBERS TO ARRAY  'A' .         M27. 504
  if (x == 0.0f) {
    goto statement_2614;
  }
  L = (knt - 1) * kswtch + 1;
  goto statement_2632;
statement_2614:
  L++;
statement_2632:
  n1 = (L - 1) / 100;
  if (cmn.iprsup >= 1) {
    write(lunit6,
      "(/,' VARIABLES IN  ''SANDNM'' ,   THE RANDOM-NUMBER GENERATOR WITH 100 "
      "BUILT-IN NUMBERS.       L     KNT  KSWTCH      N1',14x,'X',/,82x,4i8,"
      "e15.5)"),
      L, knt, kswtch, n1, x;
  }
  if (n1 > 0) {
    L = L - 100 * n1;
  }
  return_value = a(L);
  return return_value;
}

double randnm(
  common& cmn,
  double const& x)
{
  double return_value = fem::double0;
  const auto& moncar = cmn.moncar;
  //
  int knt = fem::int0;
  int n14 = fem::int0;
  //C)                                                                      M23. 145
  //C)    THIS IS A RANDOM NUMBER GENERATING FUNCTION, WHOSE PURPOSE IS TO  M23. 146
  //C)    RETURN WITH A VALUE FOR A RANDOM VARIABLE WHICH IS UNIFORMLY-     M23. 147
  //C)    DISTRIBUTED OVER THE INTERVAL FROM ZERO TO UNITY.                 M23. 148
  //C)    A TYPICAL CALL IS    Y = RANDNM(X)  ,    WHERE  'X'  IS A         M23. 149
  //C)    FLOATING-POINT VARIABLE WHICH IS PRESENT ONLY BECAUSE 'RANDOM'    M23. 150
  //C)    NUMBER-GENERATING ALGORITHMS ARE NEVER TRULY RANDOM, AND GENERALLYM23. 151
  //C)    REQUIRE SOME SORT OF 'RANDOM' INITIALIZATION TO EVEN GET STARTED. M23. 152
  //C)    SINCE SUCH NUMBER-GENERATING ALGORITHMS ARE ACTUALLY CYCLIC IF A  M23. 153
  //C)    LARGE ENOUGH SAMPLING IS TAKEN, IT IS ALSO DESIRABLE TO           M23. 154
  //C)    RE-INITIALIZE THE ALGORITHM PERIODICALLY, BY MEANS OF A 'RANDOM'  M23. 155
  //C)    EXTERNAL INPUT.   VARIABLE  'X'  IS THIS 'RANDOM' INPUT, WHOSE    M23. 156
  //C)    PURPOSE IS TO RANDOMLY RE-INITIALIZE THE ALGORITHM, AS FOLLOWS ...M23. 157
  //C)         1.  IF  'X'  IS IDENTICALLY ZERO, THERE IS NO INITIALIZATION.M23. 158
  //C)             THE NEXT RANDOM NUMBER IS SIMPLY RETURNED THROUGH THE    M23. 159
  //C)             FUNCTION NAME.                                           M23. 160
  //C)         2.  IF  'X'  IS POSITIVE, THE RANDOM NUMBER GENERATING       M23. 161
  //C)             ALGORITHM IS TO BE INITIALIZED.   EMTP USAGE HAS  'X'    M28. 281
  //C)             AS THE WALL-CLOCK TIME IN SECONDS SINCE MIDNIGHT, AN     M23. 163
  //C)             INTEGER (THOUGH STORED IN FLOATING-POINT MODE, NOTE).    M23. 164
  //C)             IN THIS CASE, NO RANDOM NUMBER NEED BE RETURNED WITH THE M23. 165
  //C)             FUNCTION NAME, SINCE THE EMTP WILL NOT USE IT.           M28. 282
  //C)    IF A NON-CDC USER HAS ACCESS TO A RANDOM NUMBER GENERATING        M23. 167
  //C)    FUNCTION WHICH DOES NOT REQUIRE INITIALIZATION, HE MAY SIMPLY     M23. 168
  //C)    IGNORE  'X' ,   AND RETURN THE RANDOM NUMBER THROUGH THE FUNCTION M23. 169
  //C)    NAME EVERY TIME THIS MODULE IS CALLED.                            M23. 170
  //C)                                                                      M23. 171
  //C     A MINUS SIGN APPENDED TO VARIABLE  'XMAXMX'  OF   /BLANK/  IS A   M27. 380
  //C     FLAG THAT THE USER WANTS TO EMPLOY THE STANDARD TABLE OF RANDOM   M27. 381
  //C     NUMBERS WHICH IS BUILT INTO MODULE  'SANDNM' .                    M27. 382
  //C                                                                       M27. 383
  //C     INSTALLATION-DEPENDENT  EMTP  MODULE WRITTEN FOR THE  DEC         M24. 298
  //C     VAX-11/780.    'RAN'  IS A  DEC  SYSTEM SUBROUTINE WHICH          M24. 299
  //C     RETURNS A RANDOM NUMBER UNIFORMLY DISTRIBUTED OVER  (0, 1) .      M24. 300
  //C!EQUIVALENCE (MONCAR(1), KNT)
  knt = moncar(1);
  if (cmn.xmaxmx < 0.0f) {
    goto statement_7265;
  }
  if (x == 0.0f) {
    goto statement_4213;
  }
  //C SKIP 2ND OR LATER SEED
  if (knt > 1) {
    goto statement_9800;
  }
  n14 = x;
  if (n14 / 2 * 2 == n14) {
    n14++;
  }
  //C 29 Dec 1987, change from  (N1, N2)
  statement_4213:
  return_value = std::rand(); //w ran(n14);
  goto statement_9800;
  statement_7265:
  return_value = sandnm(cmn, x);
  statement_9800:
  return return_value;
}


void tacs2(
  common& cmn)
{
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  auto& vstacs= cmn.vstacs;
  double& deltat = cmn.deltat;
  double& epsiln = cmn.epsiln;
  double& t = cmn.t;
  auto& twopi = cmn.twopi;
  double& epsuba = cmn.epsuba;
  auto& begmax = cmn.begmax;
  double& fltinf = cmn.fltinf;
  double& flzero = cmn.flzero;
  auto& flstat = cmn.flstat;
  auto& moncar = cmn.moncar;
  const auto& kprchg = cmn.kprchg;
  const auto& multpr = cmn.multpr;
  auto& lstat = cmn.lstat;
  int& iout = cmn.iout;
  int& istep = cmn.istep;
  int& m4plot = cmn.m4plot;
  int& iplot = cmn.iplot;
  int& numsm = cmn.numsm;
  int& nstacs = cmn.nstacs;
  int& lastov = cmn.lastov;
  int& noutpr = cmn.noutpr;
  int& ktab = cmn.ktab;
  int& iofgnd = cmn.iofgnd;
  int& isplot = cmn.isplot;
  int& isprin = cmn.isprin;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& ntot = cmn.ntot;
  int& kssout = cmn.kssout;
  int& limstp = cmn.limstp;
  int& indstp = cmn.indstp;
  int& nenerg = cmn.nenerg;
  auto& sptacs = cmn.sptacs;
  const auto& energy = cmn.energy;
  const auto& cu = cmn.cu;
  const auto& ismdat = cmn.ismdat;
  const auto& texvec = cmn.texvec;
  const auto& kmswit = cmn.kmswit;
  const auto& nextsw = cmn.nextsw;
  const auto& tclose = cmn.tclose;
  const auto& e = cmn.e;
  const auto& f = static_cast<common_c0b119&>(cmn).f;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;

  const auto& bus = cmn.bus;
  const auto& etac = cmn.etac;
  const auto& ismtac = cmn.ismtac;

  int& ntotac = cmn.ntotac;
  //
  auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  double picon = fem::double0;
  double epslon = fem::double0;
  int ite = fem::int0;
  int niunrs = fem::int0;
  int ma1 = fem::int0;
  int ma2 = fem::int0;
  int ntcsexnstacs = fem::int0;
  int kxai = fem::int0;
  int kbtcs = fem::int0;
  int kbwkcs = fem::int0;
  int kjsup = fem::int0;
  int kksup = fem::int0;
  int ndy5 = fem::int0;
  int ndx1 = fem::int0;
  double d1tttt = fem::double0;
  int n1tttt = fem::int0;
  int j = fem::int0;
  int nuki = fem::int0;
  int nukr = fem::int0;
  int k = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  double f2 = fem::double0;
  double f1 = fem::double0;
  int ndx2 = fem::int0;
  int ll = fem::int0;
  int n3 = fem::int0;
  arr_1d<10, double> dum9(fem::fill0);
  int k2 = fem::int0;
  int k1 = fem::int0;
  int i1 = fem::int0;
  int k3 = fem::int0;
  int kj = fem::int0;
  int mm = fem::int0;
  int ndx3 = fem::int0;
  int idctcs = fem::int0;
  int iac = fem::int0;
  int n6 = fem::int0;
  int m = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  double prx = fem::double0;
  double pru = fem::double0;
  int n = fem::int0;
  int nn = fem::int0;
  double b = fem::double0;
  int mtot = fem::int0;
  int n14 = fem::int0;
  arr_1d<5, fem::str<8> > texnam(fem::fill0);
  int ip = fem::int0;
  arr_1d<9, fem::str<8> > dumj(fem::fill0);
  int ia = fem::int0;
  int nukj = fem::int0;
  int nuks = fem::int0;
  double dpd = fem::double0;
  int krowcs = fem::int0;
  int L = fem::int0;
  double d1 = fem::double0;
  int jlk = fem::int0;
  int ndx4 = fem::int0;
  double d2 = fem::double0;
  int jm = fem::int0;
  int n33 = fem::int0;
  int i30 = fem::int0;
  int jmset = fem::int0;
  int mj = fem::int0;
  double bb = fem::double0;
  int nj = fem::int0;
  int ndxi = fem::int0;
  int ipass = fem::int0;
  double xtcsav = fem::double0;
  int nkk = fem::int0;
  int nkk1 = fem::int0;
  int ilk = fem::int0;
  double defr = fem::double0;
  double critia = fem::double0;
  int n5 = fem::int0;
  int n7 = fem::int0;
  int ndx6 = fem::int0;
  int ndx5 = fem::int0;
  int mjm = fem::int0;
  int ma3 = fem::int0;
  int i2 = fem::int0;
  int ma4 = fem::int0;
  int i3 = fem::int0;
  int jcm = fem::int0;
  int n22 = fem::int0;
  int mdy5 = fem::int0;
  int mrm = fem::int0;
  double freqhz = fem::double0;
  double omegar = fem::double0;
  int ndy1 = fem::int0;
  int ndy2 = fem::int0;
  double d4 = fem::double0;
  double d3 = fem::double0;
  double xarsav = fem::double0;
  double xaisav = fem::double0;
  double defi = fem::double0;
  double real = fem::double0;
  double rima = fem::double0;
  double amax = fem::double0;
  double angl = fem::double0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  int ndxj = fem::int0;
  int kh = fem::int0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  int mk = fem::int0;
  double br = fem::double0;
  double bi = fem::double0;
  double a = fem::double0;
  int ndy0 = fem::int0;
  static const char* format_2023 =
    "('0',/,' IA=',i4,8x,'NEXT IS IROWCS(1,2,...,NUK)',/(1x,30i4))";
  static const char* format_235 = "(/,17x,9(6x,a6))";
  static const char* format_4737 = "(5(3x,a6,e16.7))";
  static const char* format_7798 =
    "(' ---- ITERATION IS BEYOND ',i4,' TIMES, BUT THE',"
    "' RESULT IS NOT CONVERGENT YET, PROGRAM WILL CONTINUE  ----')";
  //C!EQUIVALENCE  (MONCAR(2),  KBASE),   (MONCAR(3), LTDELT)
  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;

  auto& kcolcs = isptacs(5);
  auto& katcs =  isptacs(7);
  auto& kprsup = isptacs(9);
  auto& kivarb = isptacs(10);
  auto& kaliu =  isptacs(11);
  auto& kjout =  isptacs(12);
  auto& kiuty =  isptacs(13);
  auto& kud1 =   isptacs(14);
  auto& kawkcs = isptacs(15);
  auto& kxar =   isptacs(16);
  auto& kxtcs =  isptacs(17);
  auto& klntab = isptacs(18);
  auto& kisblk = isptacs(19);
  auto& krsblk = isptacs(20);
  auto& kksus =  isptacs(21);
  auto& kalksu = isptacs(22);
  auto& kinsup = isptacs(23);

  auto& nuk = lstat(51);
  auto& nsu = lstat(53);
  auto& niu = lstat(54);
  auto& nsup = lstat(55);
  auto& kxic = lstat(58);
  auto& ioutcs = lstat(59);
  auto& kbase = moncar(2);
  auto& ltdelt = moncar(3);
  if (iprsup >= 1) {
    write(lunit6, "(' ENTER \"TACS2\".  LASTOV, M4PLOT =',2i6)"),
      lastov, m4plot;
  }
  FEM_DO_SAFE(i, 1, 8) {
    lstat(i) = lstat(i + 60);
  }
  picon = 360.f / twopi;
  epslon = epsiln * 100.f;
  ite = 0;
  niunrs = ivarb(kiuty + 1);
  ma1 = ivarb(kiuty + 7);
  ma2 = ivarb(kiuty + 8);
  if (iprsup < 1) {
    goto statement_6219;
  }
  write(lunit6,
    "(/,1x,'  IOUTCS   IPLOT  IPRSUP  NTCSEX  NSTACS    KTAB',"
    "'     NIU     NUK  NENERG  INFEXP',/,10i8)"),
    ioutcs, iplot, iprsup, ntcsexnstacs, ktab, niu, nuk, nenerg,
    ivarb(kiuty + 11);
  write(lunit6,
    "(1x,14x,'T',10x,'TWOPI',9x,'FLTINF',11x,'XOPT',11x,'COPT',/,1x,8e15.6)"),
    t, twopi, fltinf, cmn.xopt, cmn.copt;
statement_6219:
  kxai = kxar + lstat(68);
  kbtcs = katcs + lstat(62);
  kbwkcs = kawkcs + lstat(68);
  kjsup = kinsup + lstat(65);
  kksup = kjsup + lstat(65);
  ndy5 = kud1 - 5;
  ndx1 = kxtcs + nuk;
  sptacs(ndx1 + 3) = deltat;
  sptacs(ndx1 + 6) = 0.0f;
  sptacs(ndx1 + 7) = 1.0f;
  sptacs(ndx1 + 8) = -1.0f;
  sptacs(ndx1 + 9) = 1.0f;
  sptacs(ndx1 + 10) = fltinf;
  sptacs(ndx1 + 11) = twopi / 2.0f;
  FEM_DO_SAFE(i, niunrs, niu) {
    ndy5 += 5;
    if (ivarb(kiuty + i) != 14) {
      goto statement_6223;
    }
    sptacs(ndx1 + 4) = sptacs(ndy5 + 3);
    sptacs(ndx1 + 5) = twopi * sptacs(ndy5 + 3);
    goto statement_6224;
  statement_6223:;
  }
  //C                                               $$$  STEADY - STATE  $$$M13.1568
statement_6224:
  d1tttt = t;
  n1tttt = istep;
  istep = 0;
  t = 0.0f;
  //C     ******  LINKAGE FOR  'TACS EMTP SOURCES'  NAMES   ********        M13.1603
  if (nstacs == 0) {
    goto statement_480;
  }
  FEM_DO_SAFE(i, 1, nstacs) {
    if (vstacs(i) == cmn.blank) {
      goto statement_483;
    }
    FEM_DO_SAFE(j, 1, ktab) {
      ndx1 = ivarb(klntab + j);
      if (vstacs(i) == texvec(ndx1)) {
        goto statement_490;
      }
    }
    kill = 124;
    bus1 = vstacs(i);
    lstat(14) = i;
    lstat(19) = 490;
    write(lunit6,
      "('0ERROR.  EMTP SOURCE =',a6,'= (TYPE ',i2,"
      "') IS NOT A RECOGNIZABLE VARIABLE NAME IN TACS.')"),
      vstacs(i), i;
    goto statement_9000;
    //C!VSTACS(I) = J
  statement_490:
    write(vstacs(i), star), j;
    goto statement_482;
    //C!VSTACS(I) = 0.0
  statement_483:
    write(vstacs(i), star), 0;
  statement_482:;
  }
statement_480:
  nuki = kisblk - 8;
  nukr = krsblk - 4;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    nukr += 4;
    if (ivarb(nuki + 2) == 1) {
      goto statement_215;
    }
    j = ivarb(nuki + 3);
    k = ivarb(nuki + 2);
    n1 = j + 8;
    n2 = j - 1 + k * 6;
    f2 = 2.0f / deltat;
    f1 = 1.0f;
    ndx2 = kprsup + j + 2;
    if (sptacs(ndx2) == 0.0f) {
      goto statement_4061;
    }
    sptacs(nukr + 1) = sptacs(ndx2 + 1) / sptacs(ndx2);
  statement_4061:
    FEM_DOSTEP(ll, n1, n2, 6) {
      f1 = f1 * f2;
      ndx1 = kprsup + ll;
      sptacs(ndx1) = sptacs(ndx1) * f1;
      sptacs(ndx2) += sptacs(ndx1);
      sptacs(ndx1 + 1) = sptacs(ndx1 + 1) * f1;
      sptacs(ndx2 + 1) += sptacs(ndx1 + 1);
      n3 = (ll - j) / 6;
      dum9(n3) = 1.0f;
    }
    f1 = 1.0f;
    k2 = j + 2;
    k1 = j + 8;
    i1 = k;
  statement_4072:
    i1 = i1 - 1;
    if (i1 == 0) {
      goto statement_215;
    }
    f1 = -2.0f * f1;
    k3 = k2;
    k2 = k1;
    k1 += 6;
    ndx1 = kprsup + k2;
    if (i1 == 1) {
      goto statement_4091;
    }
    FEM_DO_SAFE(ll, 2, i1) {
      dum9(ll) += dum9(ll - 1);
    }
    FEM_DOSTEP(kj, k1, n2, 6) {
      mm = (kj - k3) / 6;
      ndx3 = kprsup + kj;
      sptacs(ndx1) += dum9(mm) * sptacs(ndx3);
      sptacs(ndx1 + 1) += dum9(mm) * sptacs(ndx3 + 1);
    }
  statement_4091:
    ndx2 = kprsup + k3;
    sptacs(ndx1) = sptacs(ndx2) + f1 * sptacs(ndx1);
    sptacs(ndx1 + 1) = sptacs(ndx2 + 1) + f1 * sptacs(ndx1 + 1);
    goto statement_4072;
  statement_215:;
  }
  //C     ******  T A C S   S O U R C E S   90  AND  91  ******             M13.1622
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (VSTACS(I), I=1, NSTACS)  IN  ''TACS2'' .',/(1x,10e13.4))");
      FEM_DO_SAFE(i, 1, nstacs) {
        wloop, vstacs(i);
      }
    }
  }
  idctcs = 0;
  iac = 0;
  if (niu < niunrs) {
    goto statement_405;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' NTOTAC =',i4,"
        "' .   ( ISMTAC( J ),  J = 1, NTOTAC )  FOLLOWS .  ',/(12(1x,i5)))");
      wloop, ntotac;
      FEM_DO_SAFE(n6, 1, ntotac) {
        wloop, ismtac(n6);
      }
    }
  }
  ndy5 = kud1;
  FEM_DO_SAFE(i, niunrs, niu) {
    ndx1 = ivarb(kaliu + i);
    bus1 = texvec(ndx1);
    n1 = ivarb(kiuty + i);
    if (n1 != 90) {
      goto statement_475;
    }
    FEM_DO_SAFE(j, 2, ntot) {
      if (bus1 == bus(j)) {
        goto statement_479;
      }
    }
    kill = 125;
    lstat(19) = 475;
    write(lunit6,
      "('0ERROR.  TYPE 90 SOURCE =',a6,"
      "'= IS NOT A RECOGNIZABLE NODE NAME IN EMTP.')"),
      bus1;
    goto statement_9000;
  statement_475:
    if (n1 != 91 && n1 != 93) {
      goto statement_54474;
    }
    FEM_DO_SAFE(j, 1, cmn.kswtch) {
      k = fem::iabs(kmswit(j));
      ndx2 = cmn.lswtch + j;
      m = fem::iabs(kmswit(ndx2));
      if (bus1 == bus(k)) {
        goto statement_479;
      }
      if (bus1 == bus(m)) {
        goto statement_479;
      }
    }
    kill = 126;
    if (n1 == 93) {
      kill = 144;
    }
    lstat(19) = 479;
    goto statement_9000;
  statement_54474:
    goto statement_474;
  statement_479:
    sptacs(ndy5 + 2) = j;
  statement_474:
    ndy5 += 5;
  }
  //C     000  CHECK FOR ACTIVE SOURCES IN STEADY-STATE  0000000000000000000M14.1778
  ndy5 = kud1;
  FEM_DO_SAFE(i, niunrs, niu) {
    ndx1 = kiuty + i;
    j = ivarb(ndx1);
    if (sptacs(ndy5 + 4) >= 0.0f) {
      goto statement_407;
    }
    if (j == 11 || j == 92 || j == 93) {
      idctcs = 1;
    }
    if (j == 14) {
      iac = 1;
    }
    if (j != 90 && j != 91) {
      goto statement_407;
    }
    if (sptacs(ndy5 + 1) == 0.0f) {
      iac = 1;
    }
    if (sptacs(ndy5 + 1) == 1.0f) {
      idctcs = 1;
    }
  statement_407:
    ndy5 += 5;
  }
  if (iac == 1) {
    goto statement_3000;
  }
statement_405:
  if (iac == 0 || nuk == 0) {
    goto statement_414;
  }
  nuki = kisblk;
  FEM_DO_SAFE(i, 1, nuk) {
    if (ivarb(nuki + 2) == 1) {
      goto statement_3738;
    }
    n1 = kprsup + ivarb(nuki + 3);
    if (sptacs(n1 + 1) != 0.0f) {
      goto statement_3738;
    }
    j = ivarb(nuki + 4);
    sptacs(kxtcs + j) = sptacs(kxtcs + j) - sptacs(kxar + j);
  statement_3738:
    nuki += 8;
  }
statement_414:
  if (idctcs == 1) {
    goto statement_256;
  }
  //C     000  FORM COEFFICIENTS TO S-BLOCKS FOR TRANSIENTS  000000000000000M39.1882
statement_406:
  if (nuk == 0) {
    goto statement_271;
  }
  nuki = kisblk - 8;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    if (ivarb(nuki + 2) == 1) {
      goto statement_4747;
    }
    j1 = kprsup + ivarb(nuki + 3);
    k = ivarb(nuki + 2) - 1;
    j2 = j1 + k * 6;
    FEM_DOSTEP(j, j1, j2, 6) {
      sptacs(j) = sptacs(j + 2);
      sptacs(j + 1) = sptacs(j + 3);
    }
  statement_4747:;
  }
  if (idctcs == 0 && kxic == 0 && iac == 0) {
    goto statement_271;
  }
  //C     000  INITIALIZE HISTORY ON S-BLOCKS FOR DC STEADY-STATE  000000000M14.1806
  idctcs = 0;
  nuki = kisblk - 8;
  nukr = krsblk - 4;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    nukr += 4;
    if (ivarb(nuki + 2) == 1) {
      goto statement_238;
    }
    j = ivarb(nuki + 4);
    prx = sptacs(kxtcs + j);
    pru = sptacs(nukr + 1) * prx;
    if (sptacs(nukr + 1) != 999999.99f) {
      goto statement_245;
    }
    prx = 0.0f;
    pru = 0.0f;
    j = fem::iabs(ivarb(nuki + 1));
    k = fem::iabs(ivarb(nuki + 9)) - 1;
    if (i == nuk) {
      k = nsu;
    }
    FEM_DO_SAFE(m, j, k) {
      ndx1 = kalksu + m;
      ndx2 = kxtcs + ivarb(ndx1);
      ndx1 = kksus + m;
      pru += sptacs(ndx2) * ivarb(ndx1);
    }
  statement_245:
    k = ivarb(nuki + 2) - 1;
    j = kprsup + ivarb(nuki + 3) + k * 6;
    sptacs(j - 2) = sptacs(j) * pru - sptacs(j + 1) * prx;
  statement_4510:
    if (k == 1) {
      goto statement_270;
    }
    k = k - 1;
    j = j - 6;
    sptacs(j - 2) = (sptacs(j) * pru - sptacs(j + 1) * prx + sptacs(j + 4)) / 2;
    goto statement_4510;
  statement_270:
    if (iprsup < 2) {
      goto statement_238;
    }
    n1 = kprsup + ivarb(nuki + 3);
    n2 = n1 + ivarb(nuki + 2) * 6 - 6;
    {
      write_loop wloop(cmn, lunit6,
        "('   FUNCTION NUMBER',i8,/,'  PN    ',8e15.6)");
      wloop, i;
      FEM_DOSTEP(n, n1, n2, 6) {
        wloop, sptacs(n);
      }
    }
    {
      write_loop wloop(cmn, lunit6, "('  PD    ',8e15.6)");
      FEM_DOSTEP(n, n1, n2, 6) {
        wloop, sptacs(n + 1);
      }
    }
    n2 = n2 - 6;
    {
      write_loop wloop(cmn, lunit6, "('  HST   ',8e15.6)");
      FEM_DOSTEP(n, n1, n2, 6) {
        wloop, sptacs(n + 2);
      }
    }
  statement_238:;
  }
statement_271:
  kxic = kivarb;
  lstat(58) = kxic;
  if (nsup == 0) {
    goto statement_2222;
  }
  FEM_DO_SAFE(i, 1, nsup) {
    n1 = -ivarb(kjsup + i);
    if (n1 < 0) {
      goto statement_2121;
    }
    n2 = ivarb(kksup + i);
    if (n2 != 66) {
      goto statement_2121;
    }
    nn = ivarb(n1);
    n = ivarb(n1 + 3);
    b = 0.0f;
    FEM_DO_SAFE(j, 1, n) {
      j1 = nn + j;
      sptacs(j1) = sptacs(j1) * sptacs(j1);
      b += sptacs(j1);
    }
    n = kxtcs + nuk + i + lstat(64);
    sptacs(n) = sqrtz(b * sptacs(nn));
  statement_2121:;
  }
statement_2222:
  if (iprsup < 1 && kssout == 0) {
    goto statement_2566;
  }
  write(lunit6,
    "(/,' TACS DC STEADY-STATE SOLUTION FOLLOWS ...',/,5(3x,'-NAME-',11x,"
    "'VALUE'))");
  mtot = ioutcs;
  if (kssout == 1) {
    mtot = ktab;
  }
  j1 = nuk + niu;
  j2 = nuk + lstat(64);
  n14 = 0;
  FEM_DO_SAFE(i, 1, mtot) {
    j = ivarb(kjout + i);
    if (kssout == 1) {
      j = i;
    }
    if (j > j1&& j <= j2) {
      goto statement_4848;
    }
    i1 = ivarb(klntab + j);
    n14++;
    texnam(n14) = texvec(i1);
    volti(n14) = sptacs(kxtcs + j);
    if (n14 < 5) {
      goto statement_4848;
    }
    {
      write_loop wloop(cmn, lunit6, format_4737);
      FEM_DO_SAFE(ip, 1, n14) {
        wloop, texnam(ip), volti(ip);
      }
    }
    n14 = 0;
  statement_4848:;
  }
  if (n14 > 0) {
    {
      write_loop wloop(cmn, lunit6, format_4737);
      FEM_DO_SAFE(ip, 1, n14) {
        wloop, texnam(ip), volti(ip);
      }
    }
  }
statement_2566:
  if (lastov > 1) {
    goto statement_256;
  }
  n = 9;
  if (ioutcs < 9) {
    n = ioutcs;
  }
  FEM_DO_SAFE(i, 1, n) {
    k1 = ivarb(kjout + i);
    k1 = ivarb(klntab + k1);
    dumj(i) = texvec(k1);
  }
  {
    write_loop wloop(cmn, lunit6, "(/,' STEP',5x,'TIME',3x,9(6x,a6))");
    FEM_DO_SAFE(i, 1, n) {
      wloop, dumj(i);
    }
  }
statement_32201:
  if (n >= ioutcs) {
    goto statement_233;
  }
  k = n + 1;
  n += 9;
  if (n > ioutcs) {
    n = ioutcs;
  }
  j = 0;
  FEM_DO_SAFE(i, k, n) {
    j++;
    k1 = ivarb(kjout + i);
    k1 = ivarb(klntab + k1);
    dumj(j) = texvec(k1);
  }
  {
    write_loop wloop(cmn, lunit6, format_235);
    FEM_DO_SAFE(i, 1, j) {
      wloop, dumj(i);
    }
  }
  goto statement_32201;
statement_233:
  write(lunit6, format_235);
  //C                                         $$$  FORM  SPARSE  MATRIX  $$$M13.1773
statement_256:
  if (iac == 1 && idctcs == 0) {
    goto statement_3042;
  }
  ia = 0;
  lstat(52) = ia;
  nuki = kisblk - 8;
  nukr = krsblk - 4;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    nukr += 4;
    ivarb(nuki + 8) = ia + 1;
    ndx1 = kawkcs + 1;
    move0(sptacs, ndx1, ktab);
    nukj = kisblk - 8;
    nuks = krsblk - 4;
    FEM_DO_SAFE(j, 1, nuk) {
      nukj += 8;
      nuks += 4;
      if (ivarb(nukj + 4) != i) {
        goto statement_222;
      }
      j1 = fem::iabs(ivarb(nukj + 1));
      k1 = fem::iabs(ivarb(nukj + 9)) - 1;
      if (j == nuk) {
        k1 = nsu;
      }
      if (ivarb(nukj + 2) == 1) {
        goto statement_218;
      }
      n = kprsup + ivarb(nukj + 3);
      ndx1 = kawkcs + i;
      dpd = sptacs(n + 1);
      if (dpd != 0.0f || idctcs == 0) {
        goto statement_2911;
      }
      ndx1 = krowcs + i;
      ivarb(nuki + 8) = 0;
      goto statement_260;
    statement_2911:
      sptacs(ndx1) = dpd;
      FEM_DO_SAFE(m, j1, k1) {
        L = ivarb(kalksu + m);
        ndx1 = kawkcs + L;
        ndx3 = kksus + m;
        sptacs(ndx1) = -sptacs(n) * ivarb(ndx3);
      }
      goto statement_221;
    statement_218:
      ndx1 = kawkcs + i;
      sptacs(ndx1) = 1.0f;
      FEM_DO_SAFE(m, j1, k1) {
        L = ivarb(kalksu + m);
        ndx1 = kawkcs + L;
        ndx3 = kksus + m;
        sptacs(ndx1) = -sptacs(nuks + 1) * ivarb(ndx3);
      }
      goto statement_221;
    statement_222:;
    }
  statement_221:
    if (iprsup >= 4) {
      {
        write_loop wloop(cmn, lunit6, "('0ROW ',i3(1x,6(i3,': ',e13.6,2x)))");
        wloop, i;
        FEM_DO_SAFE(j, 1, ktab) {
          wloop, j, sptacs(kawkcs + j);
        }
      }
    }
    //C                                    $$$  TRIANGULARIZE  EACH  ROW  $$$ M13.1806
    d1 = sptacs(kawkcs + i);
    if (d1 == 0.0f) {
      goto statement_7261;
    }
    if (i == 1) {
      goto statement_261;
    }
    m = i - 1;
    FEM_DO_SAFE(k, 1, m) {
      ndx1 = kawkcs + k;
      if (sptacs(ndx1) == 0.0f) {
        goto statement_262;
      }
      n = k + 1;
      ndx1 = kisblk + k * 8;
      k1 = ivarb(ndx1) - 1;
      if (k1 < 0) {
        goto statement_262;
      }
    statement_4545:
      k2 = ivarb(ndx1 + 8);
      if (k2 > 0) {
        goto statement_263;
      }
      ndx1 += 8;
      goto statement_4545;
    statement_263:
      k1++;
      if (k1 == k2) {
        goto statement_262;
      }
      j = ivarb(kcolcs + k1);
      jlk = ivarb(kisblk + j * 8);
      if (j < n && jlk != 0) {
        goto statement_263;
      }
      ndx1 = kawkcs + j;
      ndx3 = kawkcs + k;
      ndx4 = katcs + k1;
      sptacs(ndx1) = sptacs(ndx1) - sptacs(ndx3) * sptacs(ndx4);
      goto statement_263;
    statement_262:;
    }
  statement_261:
    ndx1 = kawkcs + i;
    d2 = sptacs(ndx1);
    if (std::abs(d2 / d1) > epsiln) {
      goto statement_265;
    }
  statement_7261:
    kill = 128;
    ndx1 = ivarb(klntab + i);
    bus1 = texvec(ndx1);
    lstat(14) = i;
    flstat(14) = d1;
    flstat(15) = d2;
    lstat(19) = 7261;
    write(lunit6,
      "('0ERROR.  YOUR SYSTEM IS UNSTABLE.  YOU WILL FIND THE ERROR IN A FEEDB"
      "ACK LOOP INVOLVING BLOCK =',a6,'=.')"),
      bus1;
    goto statement_9000;
  statement_265:
    ndx3 = kawkcs + i;
    sptacs(ndx3) = 1.0f / sptacs(ndx3);
    //C                               $$$  APPEND  TO  COMPACTED  VECTOR  $$$ M13.1839
    FEM_DO_SAFE(j, 1, ktab) {
      if (sptacs(kawkcs + j) == 0.0f) {
        goto statement_268;
      }
      ia++;
      lstat(52) = ia;
      if (ia <= lstat(62)) {
        goto statement_8122;
      }
      kill = 122;
      lstat(16) = lstat(62);
      lstat(17) = 2;
      lstat(19) = 8122;
      goto statement_9000;
    statement_8122:
      ndx1 = kcolcs + ia;
      ivarb(ndx1) = jm;
      ndx1 = katcs + ia;
      ndx2 = kawkcs + j;
      sptacs(ndx1) = sptacs(ndx2);
      jlk = ivarb(kisblk + j * 8);
      if (j <= i && jlk != 0) {
        goto statement_268;
      }
      sptacs(ndx1) = sptacs(ndx1) * sptacs(ndx3);
    statement_268:;
    }
  statement_260:;
  }
  if (iprsup <= 1) {
    goto statement_250;
  }
  {
    write_loop wloop(cmn, lunit6, format_2023);
    wloop, ia;
    FEM_DO_SAFE(n, 1, nuk) {
      wloop, ivarb(kisblk + n * 8);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "('0ICOLCS AND ATCS',/(1x,6(i3,e15.6,2x)))");
    FEM_DO_SAFE(m, 1, ia) {
      wloop, ivarb(kcolcs + m), sptacs(katcs + m);
    }
  }
  //C                                       $$$  UPDATE  INPUT  SOURCES  $$$M13.1861
statement_250:
  ndx1 = kxtcs + nuk;
  sptacs(ndx1 + 1) = t;
  sptacs(ndx1 + 2) = istep;
  if (idctcs == 0 && t == 0.0f) {
    goto statement_317;
  }
  //C     ---  I.C. ON DEVICES  ---                                         M28.4409
  if (istep != 1 || nsup == 0) {
    goto statement_25050;
  }
  FEM_DO_SAFE(i, 1, nsup) {
    n1 = -ivarb(kjsup + i);
    if (n1 < 0) {
      goto statement_5051;
    }
    n2 = ivarb(kksup + i) - 49;
    nn = ivarb(n1);
    j = nuk + lstat(64) + i;
    switch (n2) {
    case 1: goto statement_5051;
    case 2: goto statement_5051;
    case 3: goto statement_5051;
    case 4: goto statement_5051;
    case 5: goto statement_5051;
    case 6: goto statement_5051;
    case 7: goto statement_5051;
    case 8: goto statement_5051;
    case 9: goto statement_658;
    case 10: goto statement_659;
    case 11: goto statement_5051;
    case 12: goto statement_5051;
    case 13: goto statement_662;
    case 14: goto statement_5051;
    case 15: goto statement_664;
    case 16: goto statement_664;
    case 17: goto statement_5051;
    case 18: goto statement_5051;
    default: break;
    }
  statement_658:
    sptacs(nn) = (sptacs(nn + 1) - sptacs(nn + 2)) / 2.0f * sptacs(kxtcs + j);
    goto statement_5051;
  statement_659:
    j = ivarb(n1 + 1);
    k = ivarb(n1 + 2);
    b = 0.0f;
    FEM_DO_SAFE(n, j, k) {
      m = kxtcs + ivarb(kalksu + n);
      b += sptacs(m) * ivarb(kksus + n);
    }
    sptacs(nn + 1) = b;
    goto statement_5051;
  statement_662:
    sptacs(nn + 2) = sptacs(kxtcs + j);
    goto statement_5051;
  statement_664:
    sptacs(nn) = sptacs(kxtcs + j);
  statement_5051:;
  }
statement_25050:
  if (idctcs == 1) {
    goto statement_6513;
  }
  if (cmn.ntcsex + nstacs <= 0) {
    goto statement_6513;
  }
  t = d1tttt;
  istep = n1tttt;
  indstp = 1;
  sptacs(ndx1 + 1) = 0.0f;
  sptacs(ndx1 + 2) = 0.0f;
  if (nsup == 0 || numsm == 0) {
    goto statement_9000;
  }
  n33 = 0;
  FEM_DO_SAFE(i, 1, numsm) {
    i30 = 30 * i - 29;
    jmset = ismdat(i30 + 15);
    if (jmset <= 0) {
      goto statement_909;
    }
    jmset = -ivarb(kinsup + lstat(65) + jmset - lstat(64) - nuk);
    jmset = ivarb(jmset);
    sptacs(jmset) = cu(n33 + 11);
  statement_909:
    n33 += 24;
  }
  FEM_DO_SAFE(i, 1, nsup) {
    n1 = -ivarb(kjsup + i);
    if (n1 <= 0) {
      goto statement_5457;
    }
    n2 = ivarb(kksup + i);
    if (n2 != 67) {
      goto statement_5457;
    }
    nn = ivarb(n1);
    if (sptacs(nn) >= sptacs(nn + 1)) {
      goto statement_4499;
    }
  statement_4477:
    kill = 500;
    write(lunit6,
      "(' ***** THE CREST OF FIELD WINDING VOLTAGE SOURCE OF',"
      "' #59 MACHINE IS BEYOND ITS LIMIT ***** ',/,"
      "' STOP AT TACS2 OF OVER12 NEAR STATEMENT 4499 ')");
    goto statement_9000;
  statement_4499:
    if (sptacs(nn) > sptacs(nn + 2)) {
      goto statement_4477;
    }
    b = 0.0f;
    j = ivarb(n1 + 1);
    k = ivarb(n1 + 2);
    FEM_DO_SAFE(mj, j, k) {
      n = kksus + mj;
      if (ivarb(n) == 9) {
        goto statement_1166;
      }
      m = kalksu + mj;
      bb = sptacs(kxtcs + ivarb(m)) * ivarb(n);
      nj = mj;
    statement_1144:
      nj = nj - 1;
      n = n - 1;
      m = m - 1;
      if (nj < j) {
        goto statement_1155;
      }
      if (ivarb(n) != 9) {
        goto statement_1155;
      }
      bb = bb * sptacs(kxtcs + ivarb(m));
      goto statement_1144;
    statement_1155:
      b += bb;
    statement_1166:;
    }
    sptacs(nn + 3) = 1.0f / b;
    ndx1 = kxtcs + nuk + lstat(64) + i;
    sptacs(ndx1) = 1.0f;
  statement_5457:;
  }
  goto statement_9000;
statement_6513:
  if (niu < niunrs) {
    goto statement_505;
  }
  if (ltdelt != -6789) {
    goto statement_1768;
  }
  //C     POSTPROCESSING USAGE DEFINES TACS SOURCES FROM OLD                M28.4466
  //C     PLOT FILE THAT IS CONNECTED TO UNIT "LUNIT2" .                    M28.4467
  FEM_DO_SAFE(i, 1, cmn.iofbnd) {
    if (m4plot == 0) {
      goto statement_1761;
    }
    pltlu2(cmn, d1, volti(1));
    goto statement_1762;
  statement_1761:
    {
      read_loop rloop(cmn, cmn.lunit2, fem::unformatted);
      rloop, d1;
      FEM_DO_SAFE(j, 1, iofgnd) {
        rloop, volti(j);
      }
    }
  statement_1762:
    if (d1 == -9999.f) {
      goto statement_900;
    }
  }
  t = d1;
  ndx1 = kxtcs + nuk;
  sptacs(ndx1 + 1) = t;
  sptacs(ndx1 + 3) = t - epsuba;
  epsuba = t;
  ndx1 += niunrs;
  mover(volti(1), sptacs(ndx1), iofgnd);
  goto statement_505;
statement_1768:
  ndy5 = kud1 - 5;
  FEM_DO_SAFE(i, niunrs, niu) {
    ndy5 += 5;
    j = i + nuk;
  statement_510:
    ndxi = kxtcs + j;
    sptacs(ndxi) = 0.0f;
    ndx1 = kiuty + i;
    n1 = ivarb(ndx1);
    if (t < sptacs(ndy5 + 4) - flzero * 10.f) {
      goto statement_500;
    }
    if (t >= sptacs(ndy5 + 5) - flzero * 10.f) {
      goto statement_500;
    }
    if (t == 0.0f && sptacs(ndy5 + 4) >= 0.0f) {
      goto statement_500;
    }
    if (iac == 1 && n1 == 14) {
      goto statement_500;
    }
    if (n1 >= 90 && t > 0.0f) {
      goto statement_500;
    }
    if (n1 < 90) {
      goto statement_501;
    }
    k = sptacs(ndy5 + 2);
    if (n1 > 93) {
      goto statement_500;
    }
    n2 = n1 - 89;
    switch (n2) {
    case 1: goto statement_502;
    case 2: goto statement_508;
    case 3: goto statement_504;
    case 4: goto statement_506;
    default: break;
    }
  statement_502:
    if (sptacs(ndy5 + 1) == 1.0f) {
      sptacs(ndxi) = e(k);
    }
    goto statement_500;
  statement_504:
    sptacs(ndxi) = etac(k);
    goto statement_500;
  statement_506:
    if (nextsw(k) == 87) {
      sptacs(ndxi) = 1.0f;
    }
    goto statement_500;
  statement_508:
    if (nextsw(k) == 87 && sptacs(ndy5 + 1) == 1.0f) {
      sptacs(ndxi) = tclose(k);
    }
    goto statement_500;
  statement_501:
    sptacs(ndxi) = sptacs(ndy5 + 1);
    if (n1 == 11) {
      goto statement_500;
    }
    if (n1 != 14) {
      goto statement_511;
    }
    sptacs(ndxi) = sptacs(ndxi) * cosz(twopi * sptacs(ndy5 + 3) * t +
      sptacs(ndy5 + 2));
  statement_511:
    if (t == 0.0f) {
      goto statement_500;
    }
    if (n1 != 23) {
      goto statement_512;
    }
    if (t < sptacs(ndy5 + 4) + sptacs(ndy5 + 2) - flzero * 10.f) {
      goto statement_500;
    }
    sptacs(ndy5 + 4) += sptacs(ndy5 + 3);
    goto statement_510;
  statement_512:
    if (n1 != 24) {
      goto statement_500;
    }
    if (t < sptacs(ndy5 + 4) + sptacs(ndy5 + 3) - flzero * 10.f) {
      goto statement_513;
    }
    sptacs(ndy5 + 4) += sptacs(ndy5 + 3);
    goto statement_512;
  statement_513:
    sptacs(ndxi) = sptacs(ndxi) * (t - sptacs(ndy5 + 4)) / sptacs(ndy5 + 3);
    if (std::abs(sptacs(ndxi)) <= 10.f * flzero) {
      sptacs(ndxi) = 0.0f;
    }
  statement_500:;
  }
statement_505:
  L = ivarb(kiuty + 4);
  if (t > 0.0f) {
    goto statement_5555;
  }
  if (L > 0) {
    csupdc(cmn, L);
  }
  ipass = 0;
  ite++;
  if (ite < 100) {
    goto statement_327;
  }
  write(lunit6, format_7798), ite;
  goto statement_3177;
statement_5555:
  if (L > 0) {
    csup(cmn, L);
  }
  //C                                                 $$$  FORM  RHSIDE  $$$M13.1881
  nukr = krsblk - 4;
  FEM_DO_SAFE(i, 1, nuk) {
    nukr += 4;
    sptacs(nukr + 4) = 0.0f;
  }
  nuki = kisblk - 8;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    if (ivarb(nuki + 2) == 1) {
      goto statement_304;
    }
    j = krsblk + ivarb(nuki + 4) * 4;
    k = kprsup + ivarb(nuki + 3) + 4;
    sptacs(j) += sptacs(k);
  statement_304:;
  }
  //C                                          $$$  FORWARD  ON  RHSIDE  $$$M13.1888
  nuki = kisblk - 8;
  nukr = krsblk - 4;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    nukr += 4;
    m = ivarb(nuki + 8);
  statement_301:
    ndx1 = kcolcs + m;
    k = ivarb(ndx1);
    if (k >= i) {
      goto statement_306;
    }
    ndx3 = katcs + m;
    ndx4 = krsblk + k * 4;
    sptacs(nukr + 4) = sptacs(nukr + 4) - sptacs(ndx3) * sptacs(ndx4);
    m++;
    goto statement_301;
  statement_306:
    ndx3 = katcs + m;
    sptacs(nukr + 4) = sptacs(nukr + 4) * sptacs(ndx3);
  }
  //C                                           $$$  BACKWARD  ON  XTCS  $$$M13.1897
statement_327:
  mm = 1;
  nuki = kisblk - 8;
  nukr = krsblk - 4;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    nukr += 4;
    j = nuk + 1 - i;
    nukj = kisblk + j * 8 - 8;
    nuks = krsblk + j * 4 - 4;
    m = ivarb(nukj + 8);
    ndx1 = kxtcs + j;
    xtcsav = sptacs(ndx1);
    if (m == 0) {
      goto statement_308;
    }
    n = ia;
    sptacs(ndx1) = sptacs(nuks + 4);
    if (j == nuk) {
      goto statement_309;
    }
    nkk = ivarb(nukj + 16);
    nkk1 = 1;
    if (nkk > 0) {
      goto statement_3091;
    }
  statement_2850:
    if (j == nuk - nkk1) {
      goto statement_309;
    }
    nkk = ivarb(nukj + nkk1 * 8 + 16);
    if (nkk > 0) {
      goto statement_3091;
    }
    nkk1++;
    goto statement_2850;
  statement_3091:
    n = nkk - 1;
  statement_309:
    if (m > n) {
      goto statement_324;
    }
    k = ivarb(kcolcs + m);
    ilk = ivarb(kisblk + k * 8);
    if (k <= j && ilk != 0) {
      goto statement_334;
    }
    ndx3 = katcs + m;
    ndx4 = kxtcs + k;
    sptacs(ndx1) = sptacs(ndx1) - sptacs(ndx3) * sptacs(ndx4);
  statement_334:
    m++;
    goto statement_309;
  statement_324:
    if (iac == 1) {
      goto statement_308;
    }
    j1 = ivarb(nukj + 5);
    k1 = ivarb(nukj + 6);
    ndx2 = kxtcs + j1;
    if (j1 > 0) {
      sptacs(nuks + 2) = sptacs(ndx2);
    }
    ndx2 = kxtcs + k1;
    if (k1 > 0) {
      sptacs(nuks + 3) = sptacs(ndx2);
    }
    if (t > 0.0f) {
      goto statement_337;
    }
    if (sptacs(ndx1) >= sptacs(nuks + 2) && sptacs(ndx1) <= sptacs(nuks + 3)) {
      goto statement_308;
    }
    if (ivarb(kiuty + 3) == 0) {
      goto statement_337;
    }
    ivarb(kiuty + 3) = ivarb(kiuty + 3) - 1;
    ndx2 = ivarb(klntab + j);
    write(lunit6,
      "('0WARNING.  BLOCK ''',a6,"
      "''' HAS ITS LIMITER OPERATING DURING THE TACS DC STEADY-STATE SOLUTION."
      "',/,11x,"
      "'DOUBLE-CHECK THE PROGRAM OUTPUT FOR  T = 0.0  FOR ANY MISUNDERSTANDING"
      " BETWEEN THE PROGRAM AND THE USER.',/,1x)"),
      texvec(ndx2);
  statement_337:
    if (sptacs(ndx1) < sptacs(nuks + 2)) {
      sptacs(ndx1) = sptacs(nuks + 2);
    }
    if (sptacs(ndx1) > sptacs(nuks + 3)) {
      sptacs(ndx1) = sptacs(nuks + 3);
    }
    if (sptacs(nuks + 2) <= sptacs(nuks + 3)) {
      goto statement_308;
    }
    if (ivarb(kiuty + 3) == 0) {
      goto statement_308;
    }
    ndx2 = ivarb(klntab + j);
    write(lunit6,
      "('0WARNING. LIMITS AT BLOCK =',a6,"
      "'= HAVE CRISS-CROSSED.    EXPECT PUZZLING RESULTS.',/,"
      "' THIS WARNING MESSAGE WILL NOT BE REPEATED.  REFER TO TACS USER''S MAN"
      "UAL. ')"),
      texvec(ndx2);
    ivarb(kiuty + 3) = ivarb(kiuty + 3) - 1;
  statement_308:
    L = ivarb(nukj + 7);
    if (t > 0.0f) {
      goto statement_3077;
    }
    if (L > 0) {
      csupdc(cmn, L);
    }
    defr = std::abs(xtcsav - sptacs(ndx1));
    critia = std::abs(sptacs(ndx1)) * 0.001f;
    if (critia < epslon) {
      critia = epslon;
    }
    if (defr > critia) {
      ipass = 1;
    }
    goto statement_3088;
  statement_3077:
    if (L > 0) {
      csup(cmn, L);
    }
  statement_3088:;
  }
  if (ipass == 1 && ivarb(kiuty + 9) == 1) {
    goto statement_505;
  }
  //C                                                       $$$  OUTPUT  $$$M13.1934
statement_3177:
  if (t == 0.0f && iac == 1) {
    goto statement_4066;
  }
statement_317:
  FEM_DO_SAFE(i, 1, nsup) {
    n1 = -ivarb(kjsup + i);
    if (n1 < 0) {
      goto statement_1010;
    }
    if (ivarb(kksup + i) != 53) {
      goto statement_1010;
    }
    j = ivarb(n1 + 1);
    k = ivarb(n1 + 2);
    b = 0.0f;
    FEM_DO_SAFE(n, j, k) {
      m = ivarb(kalksu + n);
      b += sptacs(kxtcs + m) * ivarb(kksus + n);
    }
    nn = ivarb(n1);
    n5 = sptacs(nn);
    n6 = sptacs(nn + 2);
    n7 = ivarb(n1 + 4);
    ndx6 = kprsup + n7;
    sptacs(ndx6) = b;
    n7++;
    if (n7 == n5 + n6) {
      n7 = n5;
    }
    ivarb(n1 + 4) = n7;
  statement_1010:;
  }
  if (ioutcs == 0) {
    goto statement_310;
  }
  if (t > deltat) {
    goto statement_335;
  }
  if (t > 0.0f) {
    goto statement_3335;
  }
  if (begmax(1) == 1.0f) {
    goto statement_316;
  }
  if (isprin == 0) {
    goto statement_316;
  }
  if (isplot > 0) {
    goto statement_310;
  }
statement_316:
  FEM_DO_SAFE(i, 1, ioutcs) {
    j = ivarb(kjout + i);
    ndx1 = kbtcs + i;
    sptacs(ndx1) = sptacs(kxtcs + j);
  }
  goto statement_3318;
statement_3335:
  FEM_DO_SAFE(i, 1, ioutcs) {
    ndx1 = kbtcs + i;
    ndx2 = kxar + i;
    ndx3 = kxai + i;
    ndx4 = kawkcs + i;
    ndx5 = kbwkcs + i;
    sptacs(ndx2) = sptacs(ndx1);
    sptacs(ndx3) = sptacs(ndx1);
    sptacs(ndx4) = 0.0f;
    sptacs(ndx5) = 0.0f;
  }
statement_335:
  FEM_DO_SAFE(i, 1, ioutcs) {
    j = ivarb(kjout + i);
    ndx1 = kbtcs + i;
    ndx2 = kxar + i;
    ndx3 = kxai + i;
    sptacs(ndx1) = sptacs(kxtcs + j);
    if (sptacs(ndx1) >= sptacs(ndx3)) {
      goto statement_319;
    }
    sptacs(ndx3) = sptacs(ndx1);
    ndx4 = kbwkcs + i;
    goto statement_3333;
  statement_319:
    if (sptacs(ndx1) <= sptacs(ndx2)) {
      goto statement_318;
    }
    sptacs(ndx2) = sptacs(ndx1);
    ndx4 = kawkcs + i;
  statement_3333:
    sptacs(ndx4) = t;
  statement_318:;
  }
statement_3318:
  if (istep < limstp) {
    goto statement_4321;
  }
  isprin = 0;
  iout = multpr(indstp);
  indstp++;
  limstp = kprchg(indstp);
statement_4321:
  if (isprin > 0) {
    goto statement_320;
  }
  if (lastov > 1) {
    goto statement_320;
  }
  isprin = iout;
  ndx1 = kbtcs + 1;
  ndx2 = kbtcs + 9;
  if (ioutcs < 9) {
    ndx2 = kbtcs + ioutcs;
  }
  {
    write_loop wloop(cmn, lunit6, "(1x,i5,e13.5,9e12.5)");
    wloop, istep, t;
    FEM_DO_SAFE(i, ndx1, ndx2) {
      wloop, sptacs(i);
    }
  }
  ndx1 = kbtcs + ioutcs;
statement_32819:
  if (ndx2 >= ndx1) {
    goto statement_320;
  }
  ndx3 = ndx2 + 1;
  ndx2 += 9;
  if (ndx2 > ndx1) {
    ndx2 = ndx1;
  }
  {
    write_loop wloop(cmn, lunit6, "(19x,9e12.5)");
    FEM_DO_SAFE(i, ndx3, ndx2) {
      wloop, sptacs(i);
    }
  }
  goto statement_32819;
statement_320:
  if (isplot > 0) {
    goto statement_310;
  }
  if (ntot >= 2) {
    goto statement_310;
  }
  ndx1 = kbtcs + 1;
  if (m4plot == 0) {
    goto statement_1648;
  }
  volti(1) = t;
  mover(sptacs(ndx1), volti(2), ioutcs);
  ndx2 = ioutcs + 1;
  pltfil(cmn, ndx2);
  goto statement_1649;
statement_1648:
  ndx2 = kbtcs + ioutcs;
  {
    write_loop wloop(cmn, cmn.lunit4, fem::unformatted);
    wloop, t;
    FEM_DO_SAFE(i, ndx1, ndx2) {
      wloop, sptacs(i);
    }
  }
statement_1649:
  isplot = iplot;
  //C                                                $$$  TIME  CONTROL  $$$M13.1972
statement_310:
  if (t > cmn.tmax) {
    goto statement_900;
  }
  if (iprsup >= 3) {
    write(lunit6,
      "(/,' IN  ''TACS2'' ,   INCREMENT  ''ISTEP'' .',"
      "'   ISTEP  ISPRIN  ISPLOT     IAC  IDCTCS',/,37x,7i8)"),
      istep, isprin, isplot, iac, idctcs;
  }
  istep++;
  t = istep * deltat;
  if (t < sptacs(29)) {
    goto statement_1945;
  }
  sptacs(29) = fltinf;
  ivarb(kiuty + 3) = ivarb(kiuty + 2);
statement_1945:
  isprin = isprin - 1;
  isplot = isplot - 1;
  if (iac == 1) {
    goto statement_350;
  }
  if (idctcs == 0) {
    goto statement_328;
  }
statement_4066:
  if (nsup == 0) {
    goto statement_406;
  }
  FEM_DO_SAFE(i, 1, nsup) {
    n1 = -ivarb(kjsup + i);
    if (n1 < 0) {
      goto statement_3037;
    }
    mjm = ivarb(kksup + i);
    if (mjm != 53 && mjm != 66) {
      goto statement_3037;
    }
    j = ivarb(n1 + 1);
    k = ivarb(n1 + 2);
    b = 0.0f;
    FEM_DO_SAFE(n, j, k) {
      m = ivarb(kalksu + n);
      n2 = ivarb(kksus + n);
      b += sptacs(kxtcs + m) * n2;
    }
    nn = ivarb(n1);
    m = sptacs(nn);
    n = sptacs(nn + 2);
    if (mjm == 53) {
      goto statement_4058;
    }
    n = ivarb(n1 + 3);
  statement_4058:
    FEM_DO_SAFE(j, 1, n) {
      ndx1 = kprsup + m + n - j;
      if (mjm == 66) {
        ndx1 = nn + n - j + 1;
      }
      sptacs(ndx1) += b;
    }
  statement_3037:;
  }
  goto statement_406;
statement_350:
  iac = 0;
  goto statement_256;
  //C                                                  $$$  UPDATE  HST  $$$M13.1983
statement_328:
  nuki = kisblk - 8;
  nukr = krsblk - 4;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    nukr += 4;
    if (ivarb(nuki + 2) == 1) {
      goto statement_3111;
    }
    L = ivarb(nuki + 4);
    prx = sptacs(kxtcs + L);
    j = fem::iabs(ivarb(nuki + 1));
    k = fem::iabs(ivarb(nuki + 9)) - 1;
    if (i == nuk) {
      k = nsu;
    }
    if (ivarb(nuki + 1) > 0) {
      goto statement_2345;
    }
    FEM_DO_SAFE(i1, ma1, ma2) {
      if (ivarb(i1) != -i) {
        goto statement_3456;
      }
      ma3 = i1 + 1;
      FEM_DO_SAFE(i2, ma3, ma2) {
        if (ivarb(i2) < 0) {
          goto statement_2345;
        }
        ma4 = i2;
      }
      goto statement_2345;
    statement_3456:;
    }
  statement_2345:
    pru = 0.0f;
    FEM_DO_SAFE(m, j, k) {
      n = ivarb(kalksu + m);
      if (ivarb(nuki + 1) > 0) {
        goto statement_5678;
      }
      n1 = n - lstat(64) - nuk;
      FEM_DO_SAFE(i3, ma3, ma4) {
        if (ivarb(i3) != n1) {
          goto statement_6789;
        }
        n += lstat(68);
        goto statement_5678;
      statement_6789:;
      }
    statement_5678:
      ndx1 = kxtcs + n;
      ndx2 = kksus + m;
      pru += sptacs(ndx1) * ivarb(ndx2);
    }
    jcm = kprsup + ivarb(nuki + 3);
    k = ivarb(nuki + 2) - 1;
    j = jcm + k * 6 - 2;
    ndx1 = krsblk + L * 4 - 2;
    ndx2 = ndx1 + 1;
    if (prx == sptacs(ndx1) || prx == sptacs(ndx2)) {
      goto statement_2810;
    }
    if (k == 1) {
      goto statement_330;
    }
    n22 = jcm + 6;
    FEM_DOSTEP(n, n22, j, 6) {
      sptacs(n - 2) = sptacs(n) * pru - sptacs(n + 1) * prx - sptacs(
        n - 2) + sptacs(n + 4);
    }
  statement_330:
    sptacs(j) = sptacs(j + 2) * pru - sptacs(j + 3) * prx;
    goto statement_311;
    //C                               $$$  DYNAMIC  LIMITER  HST  $$$         M42.6622
  statement_2810:
    n = j;
    sptacs(j) = sptacs(j + 2) * pru - sptacs(j + 3) * prx;
  statement_2840:
    if (k == 1) {
      goto statement_311;
    }
    k = k - 1;
    n = n - 6;
    sptacs(n) = (sptacs(n + 2) * pru - sptacs(n + 3) * prx + sptacs(
      n + 6)) / 2.0f;
    goto statement_2840;
  statement_311:
    if (iprsup >= 4) {
      {
        write_loop wloop(cmn, lunit6, "('  FUNCTION',i5,'  HST ',7e14.6)");
        wloop, i;
        FEM_DOSTEP(n, jcm, j, 6) {
          wloop, sptacs(n + 4);
        }
      }
    }
  statement_3111:;
  }
  ndx1 = kxtcs + nuk + lstat(64) + 1;
  ndx2 = ndx1 + lstat(68);
  mover(sptacs(ndx1), sptacs(ndx2), nsup);
  goto statement_250;
  //C                                                  $$$  TERMINATION  $$$M13.2011
statement_900:
  if (iprsup >= 1) {
    write(lunit6, "('0NORMAL TERMINATION WITHIN  ''TACS2'' .')");
  }
  if (istep == 1) {
    goto statement_903;
  }
  if (ioutcs == 0) {
    goto statement_903;
  }
  if (begmax(1) <= 0.0f) {
    goto statement_903;
  }
  if (noutpr != 0) {
    goto statement_903;
  }
  if (begmax(1) == 0.0f) {
    write(lunit6, "(/,' MINIMA AND MAXIMA OF ALL TACS OUTPUT VARIABLES')");
  }
  if (begmax(1) == 1.0f) {
    write(lunit6,
      "(/,' MINIMA AND MAXIMA OF ALL TACS OUTPUT',"
      "' VARIABLES  (EXTREMA OVER ALL',"
      "' SOLUTION POINTS, SINCE  ''MAXOUT''  IS 1)')");
  }
  if (begmax(1) == 2.0f) {
    write(lunit6,
      "(/,' MINIMA AND MAXIMA OF ALL TACS OUTPUT',"
      "' VARIABLES  (EXTREMA OVER JUST',' PRINTED OR PLOTTED POINTS, SINCE',"
      "'\"MAXOUT\"  IS 2)')");
  }
  write(lunit6,
    "(7x,'ROW',6x,'NAME',8x,'MAXIMUM',8x,'MINIMUM',9x,'TIME OF MAX',4x,"
    "'TIME OF MIN')");
  FEM_DO_SAFE(i, 1, ioutcs) {
    ndx1 = ivarb(kjout + i);
    ndx1 = ivarb(klntab + ndx1);
    ndx2 = kxar + i;
    ndx3 = kxai + i;
    ndx4 = kawkcs + i;
    ndx5 = kbwkcs + i;
    write(lunit6, "(i10,4x,a6,2e15.6,5x,2f15.6)"), i, texvec(ndx1),
      sptacs(ndx2), sptacs(ndx3), sptacs(ndx4), sptacs(ndx5);
  }
statement_903:
  lastov = nchain;
  nchain = 20;
  lstat(32) = ioutcs;
  nenerg = 0;
  kbase = 0;
  moncar(2) = kbase;
  begmax(1) = 0.0f;
  cmn.ipunch = 0;
  goto statement_9000;
  //C                                           $$$  AC  STEADY - STATE  $$$M13.2048
  //C     ***  FORM  PAC  ***                                               M13.2049
statement_3000:
  mdy5 = kud1 - 5;
  FEM_DO_SAFE(mjm, niunrs, niu) {
    mdy5 += 5;
    if (sptacs(mdy5 + 4) >= 0.0f) {
      goto statement_8888;
    }
    if (sptacs(mdy5 + 3) <= 0.0f) {
      goto statement_8888;
    }
    mrm = ivarb(kiuty + mjm);
    if (mrm != 14 && mrm != 90 && mrm != 91) {
      goto statement_8888;
    }
    freqhz = sptacs(mdy5 + 3);
    omegar = freqhz * twopi;
    ndx1 = kxar + 1;
    ndx2 = lstat(68) + lstat(68);
    move0(sptacs, ndx1, ndx2);
    nuki = kisblk - 8;
    nukr = krsblk - 4;
    FEM_DO_SAFE(i, 1, nuk) {
      nuki += 8;
      nukr += 4;
      if (ivarb(nuki + 2) == 1) {
        goto statement_3002;
      }
      j = kprsup + ivarb(nuki + 3);
      m = ivarb(nuki + 2) * 6 + j - 4;
      ndx1 = kxar + i;
      sptacs(ndx1) = sptacs(j);
      ndx3 = kxai + i;
      sptacs(ndx3) = 0.0f;
      ndx2 = ndx1 + nuk;
      sptacs(ndx2) = sptacs(j + 1);
      ndx4 = ndx3 + nuk;
      sptacs(ndx4) = 0.0f;
      n1 = 0;
      d1 = 1.0f;
      n22 = j + 6;
      FEM_DOSTEP(k, n22, m, 6) {
        d1 = d1 * omegar;
        if (n1 == 0) {
          goto statement_13000;
        }
        n1 = 0;
        d1 = -d1;
        sptacs(ndx1) += sptacs(k) * d1;
        sptacs(ndx2) += sptacs(k + 1) * d1;
        goto statement_3332;
      statement_13000:
        n1 = 1;
        sptacs(ndx3) += sptacs(k) * d1;
        sptacs(ndx4) += sptacs(k + 1) * d1;
      statement_3332:;
      }
    statement_3002:;
    }
    if (iprsup <= 1) {
      goto statement_3004;
    }
    {
      write_loop wloop(cmn, lunit6,
        "(/,' ''TACS2'' TABLES BEFORE AC STEADY-STATE.  NUK =',i4,/,1x,"
        "'     ROW    KFST     KNI',10x,'XAR-1',10x,'XAI-1',10x,'XAR-2',10x,"
        "'XAI-2',/(1x,3i8,4e15.6))");
      wloop, nuk;
      FEM_DO_SAFE(i, 1, nuk) {
        wloop, i, ivarb(nuki + 3), ivarb(nuki + 2), sptacs(kxar + i),
          sptacs(kxai + i), sptacs(kxar + nuk + i), sptacs(kxai +
            nuk + i);
      }
    }
    //C     ***  FORM  SPARSE  MATRIX  ***                                    M13.2082
  statement_3004:
    ia = 0;
    lstat(52) = ia;
    nuki = kisblk - 8;
    FEM_DO_SAFE(i, 1, nuk) {
      nuki += 8;
      ivarb(nuki + 8) = ia + 1;
      ndx1 = kawkcs + 1;
      move0(sptacs, ndx1, ktab);
      ndx1 = kbwkcs + 1;
      move0(sptacs, ndx1, ktab);
      nukj = kisblk - 8;
      nuks = krsblk - 4;
      FEM_DO_SAFE(j, 1, nuk) {
        nukj += 8;
        nuks += 4;
        k1 = ivarb(nukj + 4);
        if (k1 != i) {
          goto statement_3222;
        }
        j1 = fem::iabs(ivarb(nukj + 1));
        k1 = fem::iabs(ivarb(nukj + 9)) - 1;
        if (j == nuk) {
          k1 = nsu;
        }
        if (ivarb(nukj + 2) == 1) {
          goto statement_3218;
        }
        ndx1 = kawkcs + i;
        ndx2 = kxar + nuk + j;
        sptacs(ndx1) = sptacs(ndx2);
        ndx1 = kbwkcs + i;
        ndx2 = kxai + nuk + j;
        sptacs(ndx1) = sptacs(ndx2);
        ndy1 = kxar + j;
        ndy2 = kxai + j;
        FEM_DO_SAFE(m, j1, k1) {
          L = ivarb(kalksu + m);
          d1 = ivarb(kksus + m);
          ndx1 = kawkcs + L;
          sptacs(ndx1) = -sptacs(ndy1) * d1;
          ndx1 = kbwkcs + L;
          sptacs(ndx1) = -sptacs(ndy2) * d1;
        }
        goto statement_3221;
      statement_3218:
        ndx1 = kawkcs + i;
        sptacs(ndx1) = 1.0f;
        ndx1 = kbwkcs + i;
        sptacs(ndx1) = 0.0f;
        d1 = sptacs(nuks + 1);
        FEM_DO_SAFE(m, j1, k1) {
          L = ivarb(kalksu + m);
          ndx1 = kawkcs + L;
          ndx2 = kksus + m;
          sptacs(ndx1) = -d1 * ivarb(ndx2);
          ndx1 = kbwkcs + L;
          sptacs(ndx1) = 0.0f;
        }
        goto statement_3221;
      statement_3222:;
      }
    statement_3221:
      if (iprsup >= 2) {
        write(lunit6,
          "(/,' AT 43219',"
          "'       I       J      IA    KTAB     NUK      J1      K1',/,9x,"
          "7i8)"),
          i, j, ia, ktab, nuk, j1, k1;
      }
      if (iprsup >= 2) {
        {
          write_loop wloop(cmn, lunit6,
            "('0ROW ',i3(1x,3(i3,': ',e13.6,'  + J ',e13.6)))");
          wloop, i;
          FEM_DO_SAFE(j, 1, ktab) {
            wloop, j, sptacs(kawkcs + j), sptacs(kbwkcs + j);
          }
        }
      }
      //C     ***  TRIANGULARIZE EACH ROW  ***                                  M13.2130
      ndx1 = kawkcs + i;
      ndx2 = kbwkcs + i;
      d4 = fem::pow2(sptacs(ndx1)) + fem::pow2(sptacs(ndx2));
      if (i == 1) {
        goto statement_3261;
      }
      m = i - 1;
      FEM_DO_SAFE(k, 1, m) {
        ndx1 = kawkcs + k;
        if (sptacs(ndx1) != 0.0f) {
          goto statement_13263;
        }
        ndx1 = kbwkcs + k;
        if (sptacs(ndx1) == 0.0f) {
          goto statement_3262;
        }
      statement_13263:
        n = k + 1;
        ndx1 = kisblk + k * 8;
        k1 = ivarb(ndx1) - 1;
        k2 = ivarb(ndx1 + 8);
      statement_3263:
        k1++;
        if (k1 == k2) {
          goto statement_3262;
        }
        ndx1 = kcolcs + k1;
        if (ivarb(ndx1) < n) {
          goto statement_3263;
        }
        ndx1 = kcolcs + k1;
        j = ivarb(ndx1);
        ndx1 = kawkcs + k;
        d1 = sptacs(ndx1);
        ndx1 = kbwkcs + k;
        d2 = sptacs(ndx1);
      statement_3264:
        ndx1 = kawkcs + j;
        ndx3 = katcs + k1;
        ndx4 = kbtcs + k1;
        sptacs(ndx1) = sptacs(ndx2) - (d1 * sptacs(ndx3) - d2 * sptacs(ndx4));
        ndx1 = kbwkcs + j;
        sptacs(ndx1) = sptacs(ndx1) - (d1 * sptacs(ndx3) + d2 * sptacs(ndx4));
        k1++;
        if (k1 == k2) {
          goto statement_3262;
        }
        ndx1 = kcolcs + k1;
        j = ivarb(ndx1);
        goto statement_3264;
      statement_3262:;
      }
    statement_3261:
      ndx1 = kawkcs + i;
      ndx2 = kbwkcs + i;
      d2 = fem::pow2(sptacs(ndx1)) + fem::pow2(sptacs(ndx2));
      if (d4 == 0.0f) {
        goto statement_13261;
      }
      if (d2 / d4 > cmn.tolmat) {
        goto statement_3265;
      }
    statement_13261:
      kill = 129;
      ndx1 = ivarb(klntab + i);
      bus1 = texvec(ndx1);
      lstat(14) = i;
      flstat(14) = d4;
      flstat(15) = d2;
      lstat(19) = 3265;
      write(lunit6,
        "('0ERROR.  YOUR SYSTEM IS UNSTABLE IN STEADY-STATE.  YOU WILL FIND TH"
        "E ERROR IN A FEEDBACK LOOP INVOLVING BLOCK =',a6,'=.')"),
        bus1;
      goto statement_9000;
    statement_3265:
      ndx1 = kawkcs + i;
      d3 = sptacs(ndx1) / d2;
      ndx1 = kbwkcs + i;
      d4 = -sptacs(ndx1) / d2;
      ndx1 = kawkcs + i;
      sptacs(ndx1) = d3;
      ndx1 = kbwkcs + i;
      sptacs(ndx1) = d4;
      //C     ***  APPEND TO COMPACTED VECTOR  ***                              M13.2170
      FEM_DO_SAFE(j, 1, ktab) {
        ndx1 = kawkcs + j;
        if (sptacs(ndx1) != 0.0f) {
          goto statement_13265;
        }
        ndx1 = kbwkcs + j;
        if (sptacs(ndx1) == 0.0f) {
          goto statement_3268;
        }
      statement_13265:
        ia++;
        lstat(52) = ia;
        if (ia <= lstat(62)) {
          goto statement_8127;
        }
        kill = 122;
        lstat(16) = lstat(62);
        lstat(17) = 2;
        lstat(19) = 8127;
        goto statement_9000;
      statement_8127:
        ndx1 = kcolcs + ia;
        ivarb(ndx1) = jm;
        ndx1 = katcs + ia;
        ndx2 = kawkcs + j;
        sptacs(ndx1) = sptacs(ndx2);
        ndx1 = kbtcs + ia;
        ndx2 = kbwkcs + j;
        sptacs(ndx1) = sptacs(ndx2);
        if (j <= i) {
          goto statement_3268;
        }
        ndx1 = katcs + ia;
        ndx2 = kbtcs + ia;
        d1 = sptacs(ndx1) * d3 - sptacs(ndx2) * d4;
        sptacs(ndx2) = sptacs(ndx1) * d4 + sptacs(ndx2) * d3;
        sptacs(ndx1) = d1;
      statement_3268:;
      }
    }
    if (iprsup <= 1) {
      goto statement_3019;
    }
    {
      write_loop wloop(cmn, lunit6, format_2023);
      wloop, ia;
      FEM_DO_SAFE(n, 1, nuk) {
        wloop, ivarb(kisblk + n * 8);
      }
    }
    {
      write_loop wloop(cmn, lunit6,
        "(/,' ICOLCS, ATCS, BTCS',/(1x,3(i3,': ',e13.6,'  + J ',e13.6)))");
      FEM_DO_SAFE(m, 1, ia) {
        wloop, ivarb(kcolcs + m), sptacs(katcs + m), sptacs(kbtcs + m);
      }
    }
    write(lunit6,
      "(/,/,' CALC. OF PHASOR FORCING FUNCTIONS.',/,1x,"
      "'     ROW       J  IDCTCS     NIU',9x,'XAR(J)',9x,'XAI(J)')");
    //C     ***  SET  INPUTS  ***                                             M13.2199
  statement_3019:
    ndx1 = kxar + 1;
    move0(sptacs, ndx1, ktab);
    ndx1 = kxai + 1;
    move0(sptacs, ndx1, ktab);
    ndy5 = kud1 - 5;
    FEM_DO_SAFE(i, niunrs, niu) {
      ndy5 += 5;
      if (sptacs(ndy5 + 4) >= 0.0f) {
        goto statement_3020;
      }
      if (sptacs(ndy5 + 3) != freqhz) {
        goto statement_3020;
      }
      sptacs(ndy5 + 3) = -sptacs(ndy5 + 3);
      j = i + nuk;
      ndxi = ivarb(kiuty + i);
      ndx2 = kxai + j;
      ndx3 = kxar + j;
      if (ndxi == 14) {
        goto statement_3003;
      }
      if (ndxi == 90 || ndxi == 91) {
        goto statement_3001;
      }
      goto statement_3020;
    statement_3001:
      k = sptacs(ndy5 + 2);
      if (ndxi == 91) {
        goto statement_3131;
      }
      sptacs(ndx3) = e(k);
      sptacs(ndx2) = f(k);
      goto statement_3030;
    statement_3131:
      if (nextsw(k) != 87) {
        goto statement_3020;
      }
      sptacs(ndx3) = tclose(k);
      sptacs(ndx2) = energy(k);
      goto statement_3030;
    statement_3003:
      d1 = sptacs(ndy5 + 1);
      d2 = sptacs(ndy5 + 2);
      sptacs(ndx3) = d1 * cosz(d2);
      sptacs(ndx2) = d1 * sinz(d2);
    statement_3030:
      if (iprsup >= 1) {
        write(lunit6, "(1x,4i8,2e15.6)"), i, j, idctcs, niu, sptacs(ndx3),
          sptacs(ndx2);
      }
    statement_3020:;
    }
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, lunit6,
          "(/,' (XAR(I), XAI(I), I=1, KTAB)',/(1x,8e16.6))");
        FEM_DO_SAFE(i, 1, ktab) {
          wloop, sptacs(kxar + i), sptacs(kxai + i);
        }
      }
    }
  statement_3412:
    ite++;
    ipass = 0;
    if (ite <= 100) {
      goto statement_3515;
    }
    write(lunit6, format_7798), ite;
    goto statement_3618;
  statement_3515:
    L = ivarb(kiuty + 4);
    if (L > 0) {
      csupac(cmn, L, omegar);
    }
    //C     ***  BACKWARD ON XA  ***                                          M13.2221
    nuki = kisblk - 8;
    FEM_DO_SAFE(i, 1, nuk) {
      nuki += 8;
      j = nuk + 1 - i;
      nukj = kisblk + j * 8 - 8;
      ndx1 = kxar + j;
      xarsav = sptacs(ndx1);
      sptacs(ndx1) = 0.0f;
      ndx2 = kxai + j;
      xaisav = sptacs(ndx2);
      sptacs(ndx2) = 0.0f;
      m = ivarb(nukj + 8);
      n = ia;
      if (j != nuk) {
        n = ivarb(nukj + 16) - 1;
      }
    statement_3309:
      ndx3 = kcolcs + m;
      if (ivarb(ndx3) == j) {
        goto statement_3334;
      }
      m++;
      goto statement_3309;
    statement_3334:
      m++;
      if (m > n) {
        goto statement_3024;
      }
      k = ivarb(kcolcs + m);
      if (k > nuk + niu) {
        goto statement_3024;
      }
      d1 = sptacs(kxar + k);
      d2 = sptacs(kxai + k);
      ndx3 = katcs + m;
      ndx4 = kbtcs + m;
      sptacs(ndx1) = sptacs(ndx1) - (sptacs(ndx3) * d1 - sptacs(ndx4) * d2);
      sptacs(ndx2) = sptacs(ndx2) - (sptacs(ndx3) * d2 + sptacs(ndx4) * d1);
      if (iprsup >= 2) {
        write(lunit6, "(' AT 13334',5i8,4e20.6)"), i, j, k, m, n, d1,
          d2, sptacs(ndx1), sptacs(ndx2);
      }
      goto statement_3334;
    statement_3024:
      L = ivarb(nukj + 7);
      if (L > 0) {
        csupac(cmn, L, omegar);
      }
      defr = std::abs(xarsav - sptacs(ndx1));
      defi = std::abs(xaisav - sptacs(ndx2));
      critia = 0.001f * sqrtz(fem::pow2(sptacs(ndx1)) + fem::pow2(
        sptacs(ndx2)));
      if (critia < epslon) {
        critia = epslon;
      }
      if (defr <= critia && defi <= critia) {
        goto statement_7224;
      }
      ipass = 1;
    statement_7224:;
    }
    if (ipass == 1 && ivarb(kiuty + 9) == 1) {
      goto statement_3412;
    }
  statement_3618:
    if (iprsup < 1 && kssout == 0) {
      goto statement_2389;
    }
    write(lunit6,
      "(/,'   AC STEADY STATA SOLUTION,  FREQUENCY = ',e16.6,/,"
      "'    NAME         REAL PART  IMAGINARY PART',"
      "'       MAGNITUDE           ANGLE')"),
      freqhz;
    mtot = ioutcs;
    if (kssout == 1) {
      mtot = ktab;
    }
    j1 = nuk + niu;
    j2 = nuk + lstat(64);
    FEM_DO_SAFE(i, 1, mtot) {
      j = ivarb(kjout + i);
      if (kssout == 1) {
        j = i;
      }
      if (j > j1&& j <= j2) {
        goto statement_2378;
      }
      i1 = ivarb(klntab + j);
      real = sptacs(kxar + j);
      rima = sptacs(kxai + j);
      amax = sqrtz(fem::pow2(real) + fem::pow2(rima));
      angl = 0.0f;
      if (amax > 0.0f) {
        angl = picon * std::atan2(rima, real);
      }
      write(lunit6, "(2x,a6,3e16.6,f16.6)"), texvec(i1), real, rima, amax, angl;
    statement_2378:;
    }
  statement_2389:
    ndx1 = kxtcs + lstat(68);
    FEM_DO_SAFE(i, 1, ktab) {
      ndx2 = ndx1 + i;
      sptacs(ndx2) += sptacs(kxar + i);
    }
    //C     ***  HISTORIES  ***                                               M13.2263
    d1 = omegar * deltat;
    d2 = cosz(d1);
    d3 = -sinz(d1);
    d1 = d2 + 1.0f;
    d4 = fem::pow2(d1) + fem::pow2(d3);
    d5 = d1 / d4;
    d6 = -d3 / d4;
    if (iprsup >= 1) {
      write(lunit6,
        "(/,5x,'KTAB',9x,'OMEGAR',9x,'DELTAT',13x,'D2',13x,'D3',13x,'D5',13x,"
        "'D6',/,1x,i8,6e15.6,/,1x)"),
        ktab, omegar, deltat, d2, d3, d5, d6;
    }
    nuki = kisblk - 8;
    FEM_DO_SAFE(i, 1, nuk) {
      nuki += 8;
      if (ivarb(nuki + 2) == 1) {
        goto statement_3032;
      }
      k1 = ivarb(nuki + 4);
      j = fem::iabs(ivarb(nuki + 1));
      k = fem::iabs(ivarb(nuki + 9)) - 1;
      if (i == nuk) {
        k = nsu;
      }
      ndxi = kawkcs + i;
      sptacs(ndxi) = 0.0f;
      ndxj = kbwkcs + i;
      sptacs(ndxj) = 0.0f;
      if (iprsup >= 4) {
        write(lunit6,
          "(/,9x,'       I       M       J       K       N',18x,'D1',12x,"
          "'AWKCS(I)',12x,'BWKCS(I)')");
      }
      FEM_DO_SAFE(m, j, k) {
        n = ivarb(kalksu + m);
        d1 = ivarb(kksus + m);
        sptacs(ndxi) += sptacs(kxar + n) * d1;
        sptacs(ndxj) += sptacs(kxai + n) * d1;
        if (iprsup >= 4) {
          write(lunit6, "(' AT 13033',5i8,3e20.6)"), i, m, j, k, n,
            d1, sptacs(ndxi), sptacs(ndxj);
        }
      }
      kh = ivarb(nuki + 2);
      k = kh - 1;
      j = ivarb(nuki + 3) + k * 6;
      if (iprsup >= 4) {
        write(lunit6,
          "(/,9x,'       I       M       J       K      J1      M1',12x,"
          "'HSTR(M1)',12x,'HSTI(M1)')");
      }
      FEM_DO_SAFE(m, 1, k) {
        ndy1 = kprsup + j;
        d7 = sptacs(ndy1 + 2);
        d8 = sptacs(ndy1 + 3);
        ndx1 = katcs + kh - m;
        ndx3 = kxar + k1;
        sptacs(ndx1) = d7 * sptacs(ndxi) - d8 * sptacs(ndx3);
        ndx4 = kbtcs + kh - m;
        ndx3 = kxai + k1;
        sptacs(ndx4) = d7 * sptacs(ndxj) - d8 * sptacs(ndx3);
        if (iprsup >= 4) {
          write(lunit6, "(' AT 23033',4i8,2e20.6)"), i, j, k, kh,
            sptacs(ndx1), sptacs(ndx4);
        }
        j = j - 6;
        if (m == 1) {
          goto statement_3034;
        }
        ndx2 = ndx1 + 1;
        d7 = sptacs(ndx2);
        ndx3 = ndx4 + 1;
        d8 = sptacs(ndx3);
        d1 = sptacs(ndx1) + d7 * d2 - d8 * d3;
        d4 = sptacs(ndx4) + d7 * d3 + d8 * d2;
        sptacs(ndx1) = d1 * d5 - d4 * d6;
        sptacs(ndx4) = d1 * d6 + d4 * d5;
        if (iprsup >= 4) {
          write(lunit6, "(57x,2e20.6)"), sptacs(ndx1), sptacs(ndx4);
        }
      statement_3034:
        sptacs(ndy1 - 1) += sptacs(ndx1);
      }
    statement_3032:;
    }
    if (nsup == 0) {
      goto statement_8888;
    }
    FEM_DO_SAFE(i, 1, nsup) {
      n1 = -ivarb(kjsup + i);
      if (n1 < 0) {
        goto statement_7037;
      }
      mk = ivarb(kksup + i);
      if (mk != 53 && mk != 66) {
        goto statement_7037;
      }
      j = ivarb(n1 + 1);
      k = ivarb(n1 + 2);
      br = 0.0f;
      bi = 0.0f;
      FEM_DO_SAFE(n, j, k) {
        m = ivarb(kalksu + n);
        n2 = ivarb(kksus + n);
        br += sptacs(kxar + m) * n2;
        bi += sptacs(kxai + m) * n2;
      }
      nn = ivarb(n1);
      m = sptacs(nn);
      n = sptacs(nn + 2);
      a = omegar * deltat;
      if (mk == 66) {
        n = ivarb(n1 + 3);
      }
      FEM_DO_SAFE(j, 1, n) {
        ndx1 = kprsup + m + n - j;
        if (mk == 66) {
          ndx1 = nn + n - j + 1;
        }
        sptacs(ndx1) += br * cosz(a * j) + bi * sinz(a * j);
      }
    statement_7037:;
    }
  statement_8888:
    ite = 0;
  }
  mdy5 = kud1 - 5;
  FEM_DO_SAFE(i, niunrs, niu) {
    mdy5 += 5;
    if (sptacs(mdy5 + 3) < 0.0f) {
      sptacs(mdy5 + 3) = -sptacs(mdy5 + 3);
    }
  }
  goto statement_405;
  //C     ***  SUPERIMPOSING DC STEADY-STATE  ***                           M39.2343
statement_3042:
  ndx1 = kxtcs + lstat(68);
  FEM_DO_SAFE(i, 1, ktab) {
    ndx2 = kxtcs + i;
    sptacs(ndx2) += sptacs(ndx1 + i);
  }
  nuki = kisblk - 8;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    k = ivarb(nuki + 2) - 1;
    if (k == 0) {
      goto statement_6678;
    }
    ndy1 = kprsup + ivarb(nuki + 3);
    ndy0 = ndy1 + 4;
    FEM_DO_SAFE(j, 1, k) {
      sptacs(ndy1 + 4) += sptacs(ndy1 + 5);
      ndy1 += 6;
    }
    if (iprsup > 2) {
      {
        write_loop wloop(cmn, lunit6, "('  FUNCTION ',i5,'  HST ',7e14.6)");
        wloop, j;
        FEM_DOSTEP(n, ndy0, ndy1, 6) {
          wloop, sptacs(n);
        }
      }
    }
  statement_6678:;
  }
  nukr = krsblk - 4;
  FEM_DO_SAFE(i, 1, nuk) {
    nukr += 4;
    ndx1 = kxtcs + i;
    if (sptacs(ndx1) >= sptacs(nukr + 2) && sptacs(ndx1) <= sptacs(nukr + 3)) {
      goto statement_3035;
    }
    ndx1 = ivarb(klntab + i);
    if (ivarb(kiuty + 3) == 0) {
      goto statement_3035;
    }
    ivarb(kiuty + 3) = ivarb(kiuty + 3) - 1;
    if (noutpr == 0) {
      write(lunit6,
        "('0WARNING.  TACS VARIABLE ''',a6,"
        "''' IS ALLOWED TO OPERATE OUTSIDE ITS LIMITS DURING THE STEADY-STATE "
        "SOLUTION.',/,1x)"),
        texvec(ndx1);
    }
  statement_3035:;
  }
  goto statement_317;
statement_9000:
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' EXIT  ''TACS2'' .','   ISTEP  NCHAIN  IOUTCS',14x,'T',/,16x,3i8,"
      "e15.5)"),
      istep, nchain, ioutcs, t;
  }
}

void reduce(
  arr_ref<double> x1,
  int const& m,
  int const& n)
{
  x1(dimension(m*m));
  int j = fem::int0;
  int ik = fem::int0;
  int nk = fem::int0;
  double c = fem::double0;
  arr_1d<20, double> a1(fem::fill0);
  int k = fem::int0;
  int mk = fem::int0;
  int n9 = fem::int0;
  double b = fem::double0;
  int i = fem::int0;
  //C     GAUSS-JORDAN ELIMINATION PROCESS PERFORMED ON A SQUARE MATRIX X   M20.3799
  //C)    THIS ROUTINE CAN ALSO BE USED FOR MATRIX INVERSION * * * * * * * *M20.3800
  //C     MAXIMUM ORDER OF MATRIX X IS 20                                   M20.3801
  j = m;
  ik = fem::pow2(m);
  nk = ik - m;
statement_1:
  c = x1(ik);
  c = 1.0f / c;
  mover(x1(nk + 1), a1(1), m);
  k = 1;
statement_4:
  mk = (k - 1) * m;
  n9 = mk + j;
  b = -x1(n9) * c;
  i = 1;
statement_3:
  mk++;
  x1(mk) += b * a1(i);
  i++;
  if (i <= m) {
    goto statement_3;
  }
  n9 = mk + j - m;
  x1(n9) = b;
  k++;
  if (k == j) {
    k++;
  }
  if (k <= m) {
    goto statement_4;
  }
  FEM_DO_SAFE(k, 1, m) {
    n9 = nk + k;
    x1(n9) = a1(k) * c;
  }
  x1(ik) = c;
  j = j - 1;
  ik = ik - m - 1;
  nk = nk - m;
  if (j > n) {
    goto statement_1;
  }
}






void elecyy(
  common& cmn)
{
  common_write write(cmn);
  double& omega = cmn.omega;
  int& numsm = cmn.numsm;
  int& iprsup = cmn.iprsup;
  int& it = cmn.it;
  int& ibr = cmn.ibr;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  auto& ck = cmn.ck;
  auto& elp = cmn.elp;
  auto& cu = cmn.cu;
  const auto& histq = cmn.histq;
  auto& ismdat = cmn.ismdat;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  auto& z = static_cast<common_smach&>(cmn).z;
  auto& x1 = cmn.x1;
  double& omdt = cmn.omdt;
  //
  int imech = fem::int0;
  int ilk = fem::int0;
  int n07 = fem::int0;
  int nwd = fem::int0;
  int ll36 = fem::int0;
  double fact = fem::double0;
  double akm = fem::double0;
  double akn = fem::double0;
  int j30 = fem::int0;
  int juk = fem::int0;
  int k1 = fem::int0;
  int idelta = fem::int0;
  int i26 = fem::int0;
  int i75 = fem::int0;
  int i30 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  double xl = fem::double0;
  double rat1 = fem::double0;
  double a = fem::double0;
  double acde = fem::double0;
  double acdf = fem::double0;
  double b6 = fem::double0;
  double sf3 = fem::double0;
  double sf2 = fem::double0;
  double sf8 = fem::double0;
  double d7 = fem::double0;
  int is = fem::int0;
  double sb = fem::double0;
  double sf4 = fem::double0;
  double sf5 = fem::double0;
  double sf9 = fem::double0;
  double sf6 = fem::double0;
  double sf7 = fem::double0;
  double ra = fem::double0;
  int k = fem::int0;
  int n2 = fem::int0;
  int n1 = fem::int0;
  int i = fem::int0;
  int ll7 = fem::int0;
  int ll3 = fem::int0;
  double b = fem::double0;
  double sum = fem::double0;
  double etot = fem::double0;
  int ll1 = fem::int0;
  int idt = fem::int0;
  int ids = fem::int0;
  int iu = fem::int0;
  int ii = fem::int0;
  double afd = fem::double0;
  double afq = fem::double0;
  int in = fem::int0;
  int ibk = fem::int0;
  int ik = fem::int0;
  int ibl = fem::int0;
  static const char* format_6703 = "(/,' NEW COLUMN',i6,/(1x,7e17.8))";
  static const char* format_6706 = "(8x,5i10)";
  static const char* format_6707 = "(3x,8e15.7)";
  //C     THIS MODULE IS USED ONLY BY BRANDWAJN (TYPE-59) S.M. MODEL        M31.2776
  //C     THIS ROUTINE CALCULATES THE MATRICES OF THE ELECTRICAL PART  *****M20.3540
  ibr = cmn.ibrold;
  it = cmn.itold;
  imech = 0;
  ilk = 0;
  n07 = 0;
  nwd = 24;
  ll36 = 36;
  fact = 1.0f / (omega * cmn.delta2);
  akm = cmn.epsuba;
  if (akm < 2.f) {
    akm = 100.0f;
  }
  akm = 1.f / akm;
  akn = 1.f / (1.f + akm);
  akm = 1.f - 2.0f * akn * akm;
  fact = fact * akn;
  cmn.damrat = akm;
  cmn.factom = fact * omega;
  cmn.om2 = omega * cmn.onehaf;
  j30 = 1;
  FEM_DO_SAFE(juk, 1, numsm) {
    k1 = ismdat(j30);
    //C     BUILD BRANCH TERMINAL INFORMATION ******************************* M39.2604
    idelta = ismdat(j30 + 1);
    if (idelta == 1) {
      goto statement_401;
    }
    ismdat(j30 + 5) = 1;
    ismdat(j30 + 6) = 1;
    ismdat(j30 + 7) = 1;
    goto statement_402;
  statement_401:
    ismdat(j30 + 5) = ismdat(j30 + 3);
    ismdat(j30 + 6) = ismdat(j30 + 4);
    ismdat(j30 + 7) = ismdat(j30 + 2);
  statement_402:
    ilk++;
    i26 = ilk * 101 - 100;
    i75 = i26 + 26;
    i30 = ilk * 30 - 29;
    k1 = k1 - 1;
    //C     FILL-IN THE A11 SUBMATRIX OF GENERATOR NO. ILK   *****************M20.3553
    move0(z, ll36);
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' COMPANION NETWORK MODEL FOR GENERATOR NO.',i5,i8)"),
        ilk, numsm;
    }
    //C     CHANGE  STORAGE  ARRANGEMENT   FOR  THE   INDUCTANCES, I.E. STORE*M23.2095
    //C     SEPARATELY LEAKAGES AND MAIN REACTANCES ************************* M37.4581
    xl = elp(i26 + 18);
    elp(i26) = elp(i26) - xl;
    elp(i26 + 8) = elp(i26 + 8) - xl;
    z(65) = elp(i26 + 1) * fact;
    z(66) = elp(i26 + 3) * fact;
    elp(i26 + 4) = elp(i26 + 4) * fact;
    z(67) = elp(i26 + 9) * fact;
    z(68) = elp(i26 + 11) * fact;
    elp(i26 + 12) = elp(i26 + 12) * fact;
    rat1 = elp(i26 + 20);
    z(61) = z(65) * rat1;
    z(62) = z(66) * rat1;
    z(63) = z(67) * rat1;
    z(64) = z(68) * rat1;
    elp(i26 + 2) = elp(i26 + 2) * fact - z(61);
    elp(i26 + 5) = elp(i26 + 5) * fact - z(62);
    elp(i26 + 10) = elp(i26 + 10) * fact - z(63);
    elp(i26 + 13) = elp(i26 + 13) * fact - z(64);
    a = elp(i26 + 16) * fact;
    elp(i26 + 16) = a + elp(i26 + 17);
    elp(i26 + 17) = a - elp(i26 + 17) * akm;
    acde = 1.0f;
    acdf = 1.0f;
    rat1 = 1.0f / rat1;
    elp(i26 + 20) = rat1;
    b6 = elp(i26 + 8) / elp(i26);
    ismdat(i30 + 9) = 0;
    ismdat(i30 + 10) = 0;
    if (ismdat(i30 + 8) == 0) {
      goto statement_404;
    }
    sf3 = cu(n07 + 1) * rat1 + cu(n07 + 4) + cu(n07 + 5);
    sf2 = (cu(n07 + 2) * rat1 + cu(n07 + 6) + cu(n07 + 7)) * b6;
    sf3 = sqrtz(fem::pow2(sf3) + fem::pow2(sf2));
    sf8 = elp(i26 + 21);
    if (sf8 >= sf3) {
      goto statement_403;
    }
    //C     D - AXIS SATURATED  **********************************************M23.2126
    d7 = sf3 / sf8 - 0.9f;
    is = 10.0f * d7;
    is = (is + 1) / 2;
    ismdat(i30 + 9) = is;
    sb = is;
    sb = sb * 0.1f;
    sf4 = sf8 * (0.9f + sb);
    sf5 = sf8 * (1.1f + sb);
    sf9 = elp(i26 + 22);
    sf6 = sf4 / (1.0f + sf9 * (sf4 - sf8));
    sf7 = sf5 / (1.0f + sf9 * (sf5 - sf8));
    acde = (sf7 - sf6) / (sf5 - sf4);
  statement_403:
    sf8 = elp(i26 + 23);
    if (sf8 >= sf3) {
      goto statement_404;
    }
    //C     Q - AXIS SATURATED  **********************************************M23.2138
    d7 = sf3 / sf8 - 0.9f;
    is = 10.0f * d7;
    is = (is + 1) / 2;
    ismdat(i30 + 10) = is;
    sb = is;
    sb = sb * 0.1f;
    sf4 = sf8 * (0.9f + sb);
    sf5 = sf8 * (1.1f + sb);
    sf9 = elp(i26 + 24);
    sf6 = sf4 / (1.0f + sf9 * (sf4 - sf8));
    sf7 = sf5 / (1.0f + sf9 * (sf5 - sf8));
    acdf = (sf7 - sf6) / (sf5 - sf4);
  statement_404:
    write(lunit6,
      "(1x,'***',10x,'MACHINE NO.',i6,10x,'BEGIN OPERATION ON SEGMENTS NO.',"
      "2x,2i10)"),
      ilk, ismdat(i30 + 9), ismdat(i30 + 10);
    z(50) = (elp(i26) * acde + xl) * fact;
    z(51) = (elp(i26 + 8) * acdf + xl) * fact;
    z(52) = elp(i26 + 2) + z(61) * acde;
    z(53) = elp(i26 + 5) + z(62) * acde;
    z(54) = elp(i26 + 10) + z(63) * acdf;
    z(55) = elp(i26 + 13) + z(64) * acdf;
    //C     FILL IN  THE  THE  TRANSFORMER TERMS   OF  THE RESISTIVE HISTORY**M23.2155
    //C     MATRIX OF  THE  GENERATOR*****************************************M23.2156
    ra = elp(i26 + 19);
    z(1) = z(50) + ra;
    z(8) = z(51) + ra;
    z(15) = z(52) + elp(i26 + 6);
    z(22) = z(53) + elp(i26 + 7);
    z(29) = z(54) + elp(i26 + 14);
    z(36) = z(55) + elp(i26 + 15);
    z(11) = z(67) * acdf;
    z(26) = z(11);
    z(12) = z(68) * acdf;
    z(32) = z(12);
    z(30) = elp(i26 + 12) * acdf;
    z(35) = z(30);
    z(3) = z(65) * acde;
    z(13) = z(3);
    z(4) = z(66) * acde;
    z(19) = z(4);
    z(16) = elp(i26 + 4) * acde;
    z(21) = z(16);
    //C     CHANGE REACTANCES (AT STATFR HZ ) TO  INDUCTANCES ****************M33.1092
    elp(i26) = elp(i26) / omega;
    elp(i26 + 1) = elp(i26 + 1) / omega;
    elp(i26 + 3) = elp(i26 + 3) / omega;
    elp(i26 + 8) = elp(i26 + 8) / omega;
    elp(i26 + 9) = elp(i26 + 9) / omega;
    elp(i26 + 11) = elp(i26 + 11) / omega;
    xl = xl / omega;
    elp(i26 + 18) = xl;
    if (iprsup < 1) {
      goto statement_406;
    }
    FEM_DO_SAFE(k, 1, 6) {
      n2 = 6 * k;
      n1 = n2 - 5;
      {
        write_loop wloop(cmn, lunit6, format_6703);
        wloop, k;
        FEM_DO_SAFE(i, n1, n2) {
          wloop, z(i);
        }
      }
    }
  statement_406:
    mover(z(1), x1(1), ll36);
    ll7 = 6;
    ll3 = 2;
    reduce(x1(1), ll7, ll3);
    if (iprsup >= 1) {
      write(lunit6, "(/,' REDUCED NETWORK MODEL.',i10)"), ilk;
    }
    if (iprsup < 1) {
      goto statement_408;
    }
    FEM_DO_SAFE(k, 1, 6) {
      n2 = 6 * k;
      n1 = n2 - 5;
      {
        write_loop wloop(cmn, lunit6, format_6703);
        wloop, k;
        FEM_DO_SAFE(i, n1, n2) {
          wloop, x1(i);
        }
      }
    }
    //C     STORE CONSTANT TERMS FOR INSERTION INTO THE TRANSIENTS PROGRAM    M20.3617
  statement_408:
    a = x1(1);
    b = x1(8);
    sf8 = a;
    sf9 = b;
    sum = a;
    x1(8) = b - a;
    //C     SUM=(A+B) * ONEHAF                                                M37.4664
    //C     A=A-SUM                                                           M37.4665
    //C     X1(1)=A                                                           M37.4666
    //C     X1( 8 ) = -A                                                      M37.4667
    etot = elp(i26 + 16);
    elp(i26 + 16) = 1.0f / etot;
    //C     THE VALUES ''A'' AND ''B'' ARE TO BE INSERTED INTO THE TRANSIENTS M20.3625
    b = (etot - sum) / 3.0f;
    a = (etot + 2.0f * sum) / 3.0f;
    if (iprsup >= 2) {
      write(lunit6, "(/,' CORRECTION TERMS.',/,1x,6e20.12)"), a, b;
    }
    //C     ADD TO THE BRANCH TABLES TR,TX,C,KBUS,MBUS,LENGTH,NR * * * * * * *M20.3631
    //C     NOTE THAT THE INVERSE MATRIX AI HAS BEEN CALCULATED IN PARK'S     M20.3632
    //C     DQ0  COORDINATES.THIS SIMPLIFIES THE CALCULATIONS                 M20.3633
    it++;
    tr(it) = a;
    tx(it) = 0.0f;
    c(it) = 0.0f;
    length(ibr + 1) = 3;
    nr(ibr + 1) = it;
    cik(ibr + 1) = 0.0f;
    ci(ibr + 1) = 0.0f;
    ck(ibr + 1) = 0.0f;
    kbus(ibr + 1) = ismdat(j30 + 2);
    mbus(ibr + 1) = ismdat(j30 + 5);
    it++;
    kbus(ibr + 2) = ismdat(j30 + 3);
    mbus(ibr + 2) = ismdat(j30 + 6);
    nr(ibr + 2) = it;
    length(ibr + 2) = -555;
    ck(ibr + 2) = 0.0f;
    ci(ibr + 2) = 0.0f;
    cik(ibr + 2) = 0.0f;
    tr(it) = b;
    tx(it) = 0.0f;
    c(it) = 0.0f;
    it++;
    tr(it) = a;
    tx(it) = 0.0f;
    c(it) = 0.0f;
    it++;
    kbus(ibr + 3) = ismdat(j30 + 4);
    mbus(ibr + 3) = ismdat(j30 + 7);
    nr(ibr + 3) = it;
    cik(ibr + 3) = 0.0f;
    ck(ibr + 3) = 0.0f;
    ci(ibr + 3) = 0.0f;
    length(ibr + 3) = -2;
    ibr += 3;
    tr(it) = b;
    tx(it) = 0.0f;
    c(it) = 0.0f;
    it++;
    tr(it) = b;
    tx(it) = 0.0f;
    c(it) = 0.0f;
    it++;
    tr(it) = a;
    tx(it) = 0.0f;
    c(it) = 0.0f;
    if (iprsup < 1) {
      goto statement_1408;
    }
    ll1 = ibr - 2;
    {
      write_loop wloop(cmn, lunit6, format_6706);
      FEM_DO_SAFE(i, ll1, ibr) {
        wloop, nr(i);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_6706);
      FEM_DO_SAFE(i, ll1, ibr) {
        wloop, length(i);
      }
    }
    ll1 = it - 5;
    {
      write_loop wloop(cmn, lunit6, format_6707);
      FEM_DO_SAFE(i, ll1, it) {
        wloop, tr(i);
      }
    }
  statement_1408:
    a = 1.0f / sum;
    b = 1.0f / etot;
    sum = (b + 2.0f * a) / 3.0f;
    etot = (b - a) / 3.0f;
    elp(i75) = sum;
    elp(i75 + 1) = etot;
    elp(i75 + 53) = a * cmn.athtw;
    elp(i75 + 54) = b * cmn.asqrt3;
    if (iprsup > 0) {
      write(lunit6, format_6707), elp(i75), elp(i75 + 1), elp(i75 + 53),
        elp(i75 + 54);
    }
    //C     CORRECTION TERMS FOR VOLTAGE AND CURRENT CALCULATIONS*************M20.3705
    //C     NOTE THAT ONLY THE NONZERO TERMS ARE TO BE STORED *************** M20.3706
    elp(i75 + 4) = b6;
    elp(i75 + 5) = x1(3);
    elp(i75 + 6) = x1(4);
    elp(i75 + 7) = x1(11);
    elp(i75 + 8) = x1(12);
    elp(i75 + 9) = x1(15);
    elp(i75 + 10) = x1(21);
    elp(i75 + 11) = x1(16);
    elp(i75 + 12) = x1(22);
    elp(i75 + 13) = x1(29);
    elp(i75 + 14) = x1(35);
    elp(i75 + 15) = x1(30);
    elp(i75 + 16) = x1(36);
    elp(i75 + 43) = x1(13);
    elp(i75 + 44) = x1(19);
    elp(i75 + 45) = x1(26);
    elp(i75 + 46) = x1(32);
    elp(i75 + 47) = 1.0f / sf8;
    elp(i75 + 48) = xl / sf8;
    elp(i75 + 49) = sf9;
    elp(i75 + 50) = 0.0f;
    elp(i75 + 51) = 0.0f;
    elp(i75 + 52) = x1(8);
    if (iprsup < 2) {
      goto statement_409;
    }
    write(lunit6,
      "(5x,' ARRAYS FOR MACH NO.',i5,'  IN ORDER OF AC ',1x,'A21 ',1x,'A22 ',"
      "1x)"),
      ilk;
    write(lunit6, format_6707), elp(i75 + 2), elp(i75 + 3), elp(i75 + 51),
      elp(i75 + 52);
    idt = i75 + 5;
    ids = idt + 3;
    {
      write_loop wloop(cmn, lunit6, format_6707);
      FEM_DO_SAFE(iu, idt, ids) {
        wloop, elp(iu);
      }
    }
    ids++;
    idt = ids + 7;
    {
      write_loop wloop(cmn, lunit6, format_6707);
      FEM_DO_SAFE(iu, ids, idt) {
        wloop, elp(iu);
      }
    }
    //C     CALCULATE THE RESISTIVE HISTORY MATRIX ************************** M38.2779
  statement_409:
    elp(i75 + 17) = z(50) - ra * akm;
    elp(i75 + 18) = z(13);
    elp(i75 + 19) = z(19);
    elp(i75 + 20) = z(51) - ra * akm;
    elp(i75 + 21) = z(26);
    elp(i75 + 22) = z(32);
    elp(i75 + 23) = z(3);
    elp(i75 + 24) = z(52) - elp(i26 + 6) * akm;
    elp(i75 + 25) = z(21);
    elp(i75 + 26) = z(4);
    elp(i75 + 27) = z(16);
    elp(i75 + 28) = z(53) - elp(i26 + 7) * akm;
    elp(i75 + 29) = z(11);
    elp(i75 + 30) = z(54) - elp(i26 + 14) * akm;
    elp(i75 + 31) = z(35);
    elp(i75 + 32) = z(12);
    elp(i75 + 33) = z(30);
    elp(i75 + 34) = z(55) - elp(i26 + 15) * akm;
    //C     STORE ADDITIONAL ELEMENTS FOR FUTURE CALCULTIONS OF INCREMENTAL***M23.2295
    //C     INDUCTANCES AND UPDATING OF THE MATRIX /YS/ **********************M23.2296
    FEM_DO_SAFE(ii, 35, 42) {
      elp(i75 + ii) = z(ii + 26);
    }
    //C     STORE FLUX LINKAGES FOR SYNCHRONOUS FRAME*************************M36.1418
    a = elp(i26) * cu(n07 + 1) + elp(i26 + 1) * cu(n07 + 4) + elp(
      i26 + 3) * cu(n07 + 5);
    afd = a * elp(i75 + 2) + xl * cu(n07 + 1);
    a = elp(i26 + 8) * cu(n07 + 2) + elp(i26 + 9) * cu(n07 + 6) + elp(
      i26 + 11) * cu(n07 + 7);
    afq = a * elp(i75 + 3) + xl * cu(n07 + 2);
    cu(n07 + 15) = afd;
    cu(n07 + 16) = afd;
    cu(n07 + 17) = afq;
    cu(n07 + 18) = afq;
    //C     STORE MECHANICAL VARIABLES FOR THE ITERATION LOOP *************** M38.2810
    idt = imech + ismdat(i30 + 12);
    cu(n07 + 19) = histq(idt) * elp(i26 + 25);
    cu(n07 + 20) = cosz(cu(n07 + 19));
    cu(n07 + 21) = sinz(cu(n07 + 19));
    imech += 6 * ismdat(i30 + 11);
    //C     STORE ROTOR POSITION 1 AND 2 TIME-STEPS BACK IN TIME**************M37.4720
    cu(n07 + 22) = cu(n07 + 19) - omdt;
    cu(n07 + 23) = cu(n07 + 22) - omdt;
    cu(n07 + 24) = omega;
    n07 += nwd;
    if (iprsup < 1) {
      goto statement_412;
    }
    write(lunit6, "(/,' HISTORY MATRIX FOR GENERATOR NO.',i5)"), ilk;
    in = i75 + 9;
    FEM_DO_SAFE(k, 1, 5) {
      in += 7;
      n2 = in + 7;
      n1 = in + 1;
      {
        write_loop wloop(cmn, lunit6, "(1x,'NEW  ROW    ',i6,/(1x,7e17.9))");
        wloop, in;
        FEM_DO_SAFE(i, n1, n2) {
          wloop, elp(i);
        }
      }
    }
  statement_412:
    if (k1 > 0) {
      goto statement_402;
    }
    j30 += 30;
  }
  if (iprsup < 2) {
    goto statement_2500;
  }
  ibk = 0;
  FEM_DO_SAFE(ik, 1, ilk) {
    ibl = ibk + 1;
    ibk += 101;
    {
      write_loop wloop(cmn, lunit6, "(/(1x,6e20.12))");
      FEM_DO_SAFE(i, ibl, ibk) {
        wloop, elp(i);
      }
    }
  }
statement_2500:;
}

void premec(
  common& cmn)
{
  common_write write(cmn);
  double& delta2 = cmn.delta2;
  int& iprsup = cmn.iprsup;
  const auto& elp = cmn.elp;
  auto& shp = cmn.shp;
  auto& histq = cmn.histq;
  const auto& ismdat = cmn.ismdat;
  int& nst = cmn.nst;
  //
  int imk = fem::int0;
  int n17 = fem::int0;
  int ilk = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int i30 = fem::int0;
  int numask = fem::int0;
  int num2 = fem::int0;
  int num4 = fem::int0;
  int num = fem::int0;
  int num8 = fem::int0;
  int iml = fem::int0;
  int l2 = fem::int0;
  int l4 = fem::int0;
  int ic = fem::int0;
  int n2 = fem::int0;
  int n21 = fem::int0;
  int n22 = fem::int0;
  int n24 = fem::int0;
  int n4 = fem::int0;
  int k = fem::int0;
  int n3 = fem::int0;
  double zyn = fem::double0;
  int n6 = fem::int0;
  int n23 = fem::int0;
  int id = fem::int0;
  int ik = fem::int0;
  int ii = fem::int0;
  int n7 = fem::int0;
  int n25 = fem::int0;
  int i26 = fem::int0;
  double csp = fem::double0;
  int n8 = fem::int0;
  static const char* format_902 =
    "(2x,'MATRIX Y(I), I =',i5,2x,'TO',i5,/,2x(2x,6e21.12))";
  //C     THIS MODULE IS USED ONLY BY BRANDWAJN (TYPE-59) S.M. MODEL        M31.2774
  //C     CONSTRUCT THE CONSTANT MATRICES OF COEFFICIENTS  **************** M37.4503
  imk = 0;
  n17 = 0;
  FEM_DO_SAFE(ilk, 1, nst) {
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' BEGIN NEXT GEN IN  ''PREMEC'' .     ILK',/,30x,i8)"),
        ilk;
    }
    i30 = 30 * ilk - 29;
    numask = ismdat(i30 + 11);
    num2 = numask + numask;
    num4 = num2 + num2;
    num = num2 + num4;
    num8 = num4 + num4;
    iml = imk + 1;
    move0(shp, iml, num2);
    iml += num8;
    move0(shp, iml, num4);
    if (iprsup > 0) {
      write(lunit6, "(2x,'IN PREMEC B4 708',/,2x,13i10)"), numask,
        num2, num4, imk, nst;
    }
    //C     LOWER SUBDIAGONAL AND DIAGONAL   * * * * * * * * * * * * * * * * *M30. 239
    l2 = imk;
    l4 = l2 + num8;
    ic = l4;
    n2 = l2 + num2;
    n21 = n2 + numask;
    n22 = n21 + num2;
    n24 = n21 + num4;
    if (numask == 1) {
      goto statement_710;
    }
    n4 = n22 - 1;
    FEM_DO_SAFE(k, 2, numask) {
      l4 += 4;
      l2 += 2;
      n3 = n4 + k;
      zyn = -(shp(n3) * delta2 + shp(n3 - numask));
      shp(l2) = zyn;
      shp(l2 + 1) = -zyn;
      shp(l4 - 2) = -2.0f * shp(n3);
      shp(l4) = zyn;
      shp(l4 + 1) = -shp(l4 - 2);
      shp(l4 + 3) = -zyn;
    }
    //C     DIAGONAL   ****************************************************** M37.4534
    n6 = numask - 1;
    l2 = imk;
    l4 = ic;
    FEM_DO_SAFE(k, 1, n6) {
      l2 += 2;
      l4 += 4;
      shp(l2 - 1) = shp(l2 - 1) - shp(l2);
      shp(l4 - 3) = shp(l4 - 3) - shp(l4 - 2);
      shp(l4 - 1) = shp(l4 - 1) - shp(l4);
    }
    //C     COMPLETE THE CALCULATION OF THE DIAGONAL ELEMENTS  * * * * * * * *M30. 267
  statement_710:
    l2 = imk;
    l4 = ic;
    FEM_DO_SAFE(k, 1, numask) {
      n24++;
      n22 = n21 + k;
      n23 = n24 - numask;
      l2 += 2;
      l4 += 4;
      shp(l2 - 1) += shp(n23) + shp(n24) + shp(n22) / delta2;
      shp(l4 - 1) += shp(n23) + shp(n24) - shp(n22) / delta2;
    }
    if (iprsup <= 0) {
      goto statement_712;
    }
    write(lunit6, "(2x,'CONSTANT MATRICES FOR GENERATOR NO.',i5)"), ilk;
    id = ic + 1;
    ik = ic + num4;
    {
      write_loop wloop(cmn, lunit6, format_902);
      wloop, id, ik;
      FEM_DO_SAFE(ii, id, ik) {
        wloop, shp(ii);
      }
    }
    id = imk + 1;
    ik = imk + num2;
    {
      write_loop wloop(cmn, lunit6, format_902);
      wloop, id, ik;
      FEM_DO_SAFE(ii, id, ik) {
        wloop, shp(ii);
      }
    }
  statement_712:
    n7 = n17 + numask + num4;
    n25 = n24 - numask;
    i26 = 101 * ilk - 75;
    csp = cmn.omega / elp(i26);
    FEM_DO_SAFE(k, 1, numask) {
      n8 = n7 + k;
      histq(n8) = histq(n8) * csp;
      n8 = n25 + k;
      shp(n8) = shp(n8) * 2.0f * csp;
    }
    imk += num + num;
    n17 += num;
    if (iprsup < 1) {
      goto statement_1;
    }
    n7 = n17 - numask + 1;
    {
      write_loop wloop(cmn, lunit6,
        "(2x,'ARRAY POWER FROM',i6,'  TO',i6,/(2x,6e20.11))");
      wloop, n7, n17;
      FEM_DO_SAFE(k, n7, n17) {
        wloop, histq(k);
      }
    }
  statement_1:;
  }
}

void dteqiv(
  common& cmn,
  int& ikf,
  int& isfd,
  double const& d2,
  double& azr,
  double& azi)
{
  common_write write(cmn);
  double& delta2 = cmn.delta2;
  int& iprsup = cmn.iprsup;
  auto& rmfd = cmn.rmfd;
  const auto& imfd = cmn.imfd;
  //
  int idk = fem::int0;
  auto& lunit6 = cmn.lunit6;
  double d21 = fem::double0;
  int kb = fem::int0;
  arr_1d<2, double> ur(fem::fill0);
  int kc = fem::int0;
  int isf = fem::int0;
  int ist = fem::int0;
  int isu = fem::int0;
  int ka = fem::int0;
  double ar1 = fem::double0;
  double arl = fem::double0;
  double ac1 = fem::double0;
  double al1 = fem::double0;
  double a1 = fem::double0;
  //C     THIS ROUTINE PRODUCES THE COMPANION MODEL TO BE INSERTED INTO THE M32.4178
  //C     TR TABLES. IT ALSO NORMALIZES THE L AND C DATA TO HENRY AND FARAD M32.4179
  idk = 2 * ikf;
  ikf++;
  if (iprsup > 0) {
    write(lunit6,
      "(' INTEGER COUNTERS AT START OF DTEQIV.....',17x,'IKF',6x,'ISFD',6x,"
      "'IZKF',6x,'IPKF',/,51x,4i10)"),
      ikf, isfd, imfd(idk + 1), imfd(idk + 2);
  }
  d21 = d2 * delta2;
  FEM_DO_SAFE(kb, 1, 2) {
    ur(kb) = 0.f;
    kc = kb + idk;
    isf = imfd(kc);
    ist = isfd + 1;
    isu = isfd + isf * 5;
    //C     PROCESS BRANCH DATA FOR THE APPROPRIATE MODE *   *   *   *   *   *M32.4193
    FEM_DOSTEP(ka, ist, isu, 5) {
      ar1 = rmfd(ka);
      arl = rmfd(ka + 3);
      //C     NORMALIZE L AND C DATA   *   *   *   *   *   *   *   *   *   *   *M32.4197
      ac1 = rmfd(ka + 2) * cmn.ci1;
      al1 = rmfd(ka + 1) * d2;
      rmfd(ka + 1) = rmfd(ka + 1) * d21;
      rmfd(ka + 2) = ac1 * delta2;
      if (ac1 != 0.0f) {
        ac1 = 1.f / ac1;
      }
      //C     CALCULATE BRANCH IMPEDANCE   *   *   *   *   *   *   *   *   *   *M32.4203
      //C     PROCESS THE PARALLEL R AND L CONNECTION  *   *   *   *   *   *   *M32.4204
      a1 = al1;
      if (arl == 0.f || al1 == 0.f) {
        goto statement_3;
      }
      a1 = (al1 * arl) / (al1 + arl);
      //C     ACCUMULATE BRANCH ADMITTANCE *   *   *   *   *   *   *   *   *   *M32.4208
    statement_3:
      ur(kb) += 1.f / (ar1 + ac1 + a1);
    }
    isfd = isu;
    //C     INVERT THE EQUIVALENT BRANCH ADMITTANCE  *   *   *   *   *   *   *M32.4211
    ur(kb) = 1.f / ur(kb);
  }
  azr = ur(1);
  azi = ur(2);
  if (iprsup > 0) {
    write(lunit6,
      "(' EQUIVALENT BRANCH IMPEDANCES (MODAL)',4x,2e22.10)"), azr,
      azi;
  }
}

void reduct(
  arr_ref<double> a,
  int const& n,
  int const& m)
{
  a(dimension(n* (n + 1) / 2));
  int j = fem::int0;
  double w = fem::double0;
  int ij = fem::int0;
  double h1 = fem::double0;
  arr_1d<100, double> b(fem::fill0);
  int k = fem::int0;
  int ik = fem::int0;
  int i1 = fem::int0;
  int i = fem::int0;
  double h2 = fem::double0;
  int i2 = fem::int0;
  int L = fem::int0;
  //C)    THIS SUBROUTINE CAN BE USED FOR EITHER PARTIAL REDUCTION OR FOR   M15. 913
  //C)    COMPLETE INVERSION OF A REAL  N BY N  SYMMETRIC MATRIX  'A' .     M15. 914
  //C)    STORAGE FOR MATRIX ELEMENTS IS IN THE IMPLIED ORDER   (1,1),      M15. 915
  //C)    (1,2), (2,2), (1,3), (2,3), (3,3), (1,4),  ETC.,  FOR THE         M15. 916
  //C)    COMPLETE UPPER TRIANGLE.   VARIABLES  M+1, ...., N  ARE TO BE     M15. 917
  //C)    ELIMINATED (WHICH IS THE DEFINITION OF VARIABLE  'M', NOTE).      M15. 918
  //C)    RESULT IS REDUCED MATRIX IN COLUMNS 1,...M IN CASE OF REDUCTION   M15. 919
  //C)    (M UNEQUAL 0) OR NEGATIVE INVERSE MATRIX IN COLUMNS 1,...N IN CASEM15. 920
  //C)    OF INVERSION (M=0).                                               M15. 921
  j = n + 1;
  w = 1.0f;
  if (m > 0) {
    w = -w;
  }
  ij = n * j / 2;
statement_3:
  j = j - 1;
  if (j == m) {
    return;
  }
  h1 = -1.0f / a(ij);
  b(j) = h1;
  ij = ij - j;
  k = 0;
  ik = 0;
  //C                                   BEGIN K-LOOP                           11041
statement_4:
  ik += k;
  i1 = ik + 1;
  k++;
  if (k > n) {
    goto statement_3;
  }
  if (k < j) {
    goto statement_9;
  }
  if (w < 0.f) {
    goto statement_3;
  }
  if (k == j) {
    goto statement_7;
  }
  i = ik + j;
statement_5:
  h2 = a(i);
  b(k) = h2 * h1;
  //C                                   BEGIN I-LOOP                           11052
  i2 = ik + k;
  L = 0;
  FEM_DO_SAFE(i, i1, i2) {
    L++;
    a(i) += b(L) * h2;
  }
  if (k < j) {
    goto statement_4;
  }
  i = ik + j;
  a(i) = b(k);
  goto statement_4;
  //C                                   END I-LOOP                             11062
statement_7:
  i = ij;
  FEM_DO_SAFE(L, 1, j) {
    i++;
    a(i) = b(L);
  }
  goto statement_4;
  //C                                   END K-LOOP                             11068
statement_9:
  i = ij + k;
  goto statement_5;
}




// BRANCH-TABLE AND SWITCH-TABLE PROCESSING, AS PREPARATION
// FOR THE INTEGRATION IN TIME-STEP LOOP.                       
void over12(
  common& cmn)
{
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  double& deltat = cmn.deltat;
  double& delta2 = cmn.delta2;
  double& aincr = cmn.aincr;
  double& t = cmn.t;
  auto& twopi = cmn.twopi;
  double& omega = cmn.omega;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  double& sigmax = cmn.sigmax;
  double& unity = cmn.unity;
  double& onehaf = cmn.onehaf;
  double& degmin = cmn.degmin;
  double& statfr = cmn.statfr;
  auto& flstat = cmn.flstat;
  double& angle = cmn.angle;
  auto& moncar = cmn.moncar;
  auto& lunit3 = cmn.lunit3;
  int lunit5 = cmn.lunit5;
  auto& lunit9 = cmn.lunit9;
  auto& lunt10 = cmn.lunt10;
  auto& lunt12 = cmn.lunt12;
  const auto& kprchg = cmn.kprchg;
  const auto& multpr = cmn.multpr;
  const auto& ipntv = cmn.ipntv;
  auto& indtv = cmn.indtv;
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  int& icheck = cmn.icheck;
  int& iline = cmn.iline;
  int& iout = cmn.iout;
  int& it1 = cmn.it1;
  int& it2 = cmn.it2;
  int& istead = cmn.istead;
  int& lbrnch = cmn.lbrnch;
  int& lswtch = cmn.lswtch;
  int& lastov = cmn.lastov;
  int& inecho = cmn.inecho;
  int& noutpr = cmn.noutpr;
  int& ktab = cmn.ktab;
  int& numum = cmn.numum;
  int& lsiz23 = cmn.lsiz23;
  int& ltlabl = cmn.ltlabl;
  int& ioutin = cmn.ioutin;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& intinf = cmn.intinf;
  int& kswtch = cmn.kswtch;
  int& it = cmn.it;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  const auto& loopss = cmn.loopss;
  int& numref = cmn.numref;
  int& nword1 = cmn.nword1;
  int& nword2 = cmn.nword2;
  int& indstp = cmn.indstp;
  int& nenerg = cmn.nenerg;
  int& nswtpe = cmn.nswtpe;
  int& newtac = cmn.newtac;
  auto& x = static_cast<common_c0b001&>(cmn).x;
  const auto& iskip = cmn.iskip;
  const auto& zinf = cmn.zinf;
  const auto& nhist = cmn.nhist;
  const auto& cnvhst = cmn.cnvhst;
  auto& sconst = cmn.sconst;
  auto& semaux = cmn.semaux;
  const auto& kswtyp = cmn.kswtyp;
  auto& topen = cmn.topen;
  auto& crit = cmn.crit;
  const auto& kdepsw = cmn.kdepsw;
  const auto& tdns = cmn.tdns;
  const auto& kpos = cmn.kpos;
  const auto& isourc = cmn.isourc;
  const auto& energy = cmn.energy;
  const auto& xoptbr = cmn.xoptbr;
  const auto& coptbr = cmn.coptbr;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& r = static_cast<common_c0b064&>(cmn).r;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  auto& ck = cmn.ck;
  auto& kks = cmn.kks;
  auto& kknonl = cmn.kknonl;
  const auto& imodel = cmn.imodel;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& cki = cmn.cki;
  const auto& ckkjm = cmn.ckkjm;
  const auto& indhst = cmn.indhst;
  const auto& kodsem = cmn.kodsem;
  const auto& sfreq = cmn.sfreq;
  const auto& kmswit = cmn.kmswit;
  auto& tclose = cmn.tclose;
  auto& adelay = cmn.adelay;
  const auto& e = cmn.e;
  const auto& f = static_cast<common_c0b119&>(cmn).f;
  const auto& kssfrq = cmn.kssfrq;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;

  auto& volt = cmn.volt;
  const auto& bus = cmn.bus;
  auto& frandn = cmn.frandn;
  auto& irandn = cmn.irandn;
  int& kbrser = cmn.kbrser;
  int& kbreak = cmn.kbreak;
  int& koff1 = cmn.koff1;
  int& koff2 = cmn.koff2;
  int& koff3 = cmn.koff3;
  int& koff4 = cmn.koff4;
  int& koff5 = cmn.koff5;
  int& koff6 = cmn.koff6;
  int& koff7 = cmn.koff7;
  int& koff8 = cmn.koff8;
  int& koff9 = cmn.koff9;
  int& koff10 = cmn.koff10;
  int& koff13 = cmn.koff13;
  int& koff14 = cmn.koff14;
  int& koff15 = cmn.koff15;
  int& koff16 = cmn.koff16;
  int& koff17 = cmn.koff17;
  int& koff18 = cmn.koff18;
  int& koff19 = cmn.koff19;
  int& koff20 = cmn.koff20;
  int& koff21 = cmn.koff21;
  int& koff22 = cmn.koff22;
  int& koff23 = cmn.koff23;
  int& koff24 = cmn.koff24;
  int& nqtt = cmn.nqtt;
  int& nqtw = cmn.nqtw;
  //
  auto& lunit6 = cmn.lunit6;
  int nph = fem::int0;
  int jglnn = fem::int0;
  int isecti = fem::int0;
  double seedr = fem::double0;
  int ll0 = fem::int0;
  int ll4 = fem::int0;
  int ll6 = fem::int0;
  double one = fem::double0;
  int ikf = fem::int0;
  int isfd = fem::int0;
  int i = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  int n4 = fem::int0;
  int n8 = fem::int0;
  int j = fem::int0;
  int n1 = fem::int0;
  int iprout = fem::int0;
  int ip = fem::int0;
  int n = fem::int0;
  double tma = fem::double0;
  double tmb = fem::double0;
  double tmc = fem::double0;
  double tmt = fem::double0;
  int ii = fem::int0;
  int ncompt = fem::int0;
  int nhalf = fem::int0;
  int n3 = fem::int0;
  int iofcnt = fem::int0;
  int ioftab = fem::int0;
  int mxpair = fem::int0;
  int n2 = fem::int0;
  int L = fem::int0;
  arr_1d<2, fem::str<8> > atim(fem::fill0);
  double seed = fem::double0;
  double d8 = fem::double0;
  double bias = fem::double0;
  double secfrq = fem::double0;
  double window = fem::double0;
  double zerofl = fem::double0;
  double d14 = fem::double0;
  double ranoff = fem::double0;
  double dum9 = fem::double0;
  double bias2 = fem::double0;
  int ksw = fem::int0;
  int ndxi = fem::int0;
  double timev = fem::double0;
  double rng = fem::double0;
  double d9 = fem::double0;
  double d7 = fem::double0;
  double eh = fem::double0;
  double xn = fem::double0;
  double xd = fem::double0;
  double xq = fem::double0;
  int n17 = fem::int0;
  int k1 = fem::int0;
  int k = fem::int0;
  int npair = fem::int0;
  int irbase = fem::int0;
  double tstatj = fem::double0;
  int j1 = fem::int0;
  int ni = fem::int0;
  double tdiff = fem::double0;
  double tstati = fem::double0;
  double tmean = fem::double0;
  double sumdt = fem::double0;
  double fsigma = fem::double0;
  int n6 = fem::int0;
  int ndx1 = fem::int0;
  int k2 = fem::int0;
  int k3 = fem::int0;
  int ndx2 = fem::int0;
  int k4 = fem::int0;
  int l1 = fem::int0;
  int n7 = fem::int0;
  double total = fem::double0;
  int m = fem::int0;
  double az = fem::double0;
  int n9 = fem::int0;
  int iprint = fem::int0;
  arr_1d<50, int> lastxx(fem::fill0);
  int klorow = fem::int0;
  int ilorow = fem::int0;
  int nj = fem::int0;
  int ns2 = fem::int0;
  int ns1 = fem::int0;
  double tstbeg = fem::double0;
  int n24 = fem::int0;
  int ndx3 = fem::int0;
  double d22 = fem::double0;
  double azr = fem::double0;
  double azi = fem::double0;
  double cz = fem::double0;
  int lb = fem::int0;
  int ka = fem::int0;
  int kb = fem::int0;
  int ndx4 = fem::int0;
  int ndx5 = fem::int0;
  int nn1 = fem::int0;
  int n15 = fem::int0;
  int n16 = fem::int0;
  int itadd = fem::int0;
  int n5 = fem::int0;
  int jt = fem::int0;
  double gus1 = fem::double0;
  double gus2 = fem::double0;
  double a = fem::double0;
  int kf = fem::int0;
  double h2 = fem::double0;
  double h3 = fem::double0;
  int jlk = fem::int0;
  int nwww = fem::int0;
  int iq = fem::int0;
  int nrz = fem::int0;
  int nra = fem::int0;
  int nn8 = fem::int0;
  int nn9 = fem::int0;
  int nk1 = fem::int0;
  double fac1 = fem::double0;
  double fac2 = fem::double0;
  double hi = fem::double0;
  int jgl = fem::int0;
  double dblpr2 = fem::double0;
  double fac3 = fem::double0;
  double fac4 = fem::double0;
  double fac5 = fem::double0;
  double dblpr3 = fem::double0;
  double dblpr4 = fem::double0;
  double dblpr1 = fem::double0;
  double d18 = fem::double0;
  int nn10 = fem::int0;
  int nn11 = fem::int0;
  int nn12 = fem::int0;
  int nn13 = fem::int0;
  int nn14 = fem::int0;
  int nn15 = fem::int0;
  double sk1r = fem::double0;
  double sk1i = fem::double0;
  double rll = fem::double0;
  double sll = fem::double0;
  double yll = fem::double0;
  double xll = fem::double0;
  double yx = fem::double0;
  static const char* format_2721 =
    "(/,' UNIT 2 READ/WRITE INDICES.','      N4  NWORD1  NWORD2  LTLABL',"
    "'    KTAB     ISW  LUNIT2      IV','  LBRNCH',/,27x,9i8)";
  static const char* format_4372 = "(5e15.6)";
  static const char* format_4568 = "(' EXIT MODULE \"OVER12\".')";
  static const char* format_4624 =
    "(/,' AT 4624 OF  ''OVER12'' .',"
    "'     KNT   KBASE  KLOAEP   MTAPE  NENERG  JSEEDR  LTDELT  KSWTCH',10x,"
    "'SEEDR',9x,'RANOFF',/,23x,8i8,2e15.5,/(4x,8e16.6))";
  //C     DC-48 HAD "LASTSW" CLOBBERED ON 2ND ENERGIZATION; CHANGE         
  //C     DUMMY USAGE OF THIS VECTOR TO "LASTXX" TEMPORARILY (12 SEP       

  //arr_1d<50, double> cmr((7756 / 2), fem::fill0);

  auto& knt = moncar(1);
  auto& kbase = moncar(2);
  auto& ltdelt = moncar(3);
  auto& isw = moncar(4);
  auto& idist = moncar(5);
  auto& itest = moncar(6);
  auto& jseedr = moncar(8);
  auto& kloaep = moncar(9);
  auto& mtape = moncar(10);

  auto cmr = ArraySpan(reinterpret_cast<double*>(&kks(1)), kks.size()/2);
  auto cmi = ArraySpan(reinterpret_cast<double*>(&kknonl(1)), kknonl.size()/2); 

  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER12.\"')");
  }
  nph = 0;
  nqtt = 0;
  nqtw = 0;
  jglnn = 0;
  //C This variable should be in COMMON,thl.3/21/90
  isecti = 400;
  seedr = 7 * twopi;
  inecho = 0;
  ll0 = 0;
  ll4 = 4;
  ll6 = 6;
  one = 1.0f;
  //C     INITIALIZE COUNTERS FOR THE -666 BRANCHES*   *   *   *   *   *   *M32.3946
  ikf = 0;
  isfd = 0;
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' AT BEGINNING  ''OVER12'' .','  KSWTCH   KBASE     ISW  NENERG',"
        "/,25x,4i8,/,' (KDEPSW(I), I=1, KSWTCH)  FOLLOW ...',/(1x,20i6))");
      wloop, kswtch, kbase, isw, nenerg;
      FEM_DO_SAFE(i, 1, kswtch) {
        wloop, kdepsw(i);
      }
    }
  }
  //C     DEFINE LSTAT(15) AS A FLAG FOR OMIT BASE CASE IN A STAT. RUN      M36.1413
  if (kbase == intinf) {
    lstat(15) = intinf;
  }
  if (lastov == 1) {
    goto statement_13000;
  }
  if (iprsup >= 1) {
    write(lunit6, format_4624), knt, kbase, kloaep, mtape, nenerg,
      jseedr, ltdelt, kswtch;
  }
  if (kbase == 2) {
    goto statement_164;
  }
  runtym(d1, d2);
  flstat(3) += d1;
  flstat(4) += d2;
  flstat(5) = flstat(5) - d1;
  flstat(6) = flstat(6) - d2;
statement_164:
  if (isw == 4444) {
    goto statement_4088;
  }
  if (kbase != 2) {
    goto statement_76403;
  }
  if (iprsup >= 1) {
    write(lunit6, format_2721), n4, nword1, nword2, ltlabl;
  }
  tables(cmn);
  cmn.io.rewind(lunt10);
  read(lunt10, fem::unformatted), n8;
  if (n8 <= 0) {
    goto statement_7246;
  }
  FEM_DO_SAFE(i, 1, n8) {
    read(lunt10, fem::unformatted), j, adelay(j), crit(j), topen(j + lswtch);
    if (iprsup >= 2) {
      write(lunit6, "(' STAT. OPEN.  I, J =',2i5,5x,3e15.6)"), i, j,
        adelay(j), crit(j), topen(j + lswtch);
    }
  }
statement_7246:
  inecho = 0;
  cmn.io.rewind(lunt12);
  if (knt == 1) {
    mtape = lunit5;
  }
  lunit5 = lunt12;
  cmn.io.rewind(lunit5);
  if (knt > 1) {
    goto statement_409;
  }
statement_166:
  cmn.iplot = -1;
  cmn.io.rewind(lunit3);
  FEM_DO_SAFE(i, 1, kswtch) {
    j = lswtch + i;
    write(lunit3, fem::unformatted), kmswit(i), kmswit(j), adelay(i),
      crit(i), topen(j), kdepsw(i);
  }
  write(lunit3, fem::unformatted), kloaep;
  goto statement_409;
statement_76403:
  if (loopss(1) != 7766) {
    goto statement_13000;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(' IN \"OVER12\".  B4 SNEAKY RESTORATION.','   NUMUM, IT1, IBR =',3i8)"),
      numum, it1, ibr;
  }
  if (numum > 0) {
    it1 = ibr;
  }
  if (numum == 0) {
    ibr = it1;
  }
  lstat(22) = ibr;
statement_13000:
  n1 = nchain;
  if (kbase == 0) {
    goto statement_13010;
  }
  cmn.io.rewind(lunit9);
  write(lunit9, fem::unformatted), ntot, nenerg;
  if (cmn.jflsos > 0) {
    write(lunit9, fem::unformatted), cmn.pu;
  }
  inecho = lunt12;
  cmn.io.rewind(lunt12);
statement_13010:
  if (kbase >= 2 && kbase != intinf) {
    goto statement_156;
  }
  if (ktab == 0) {
    goto statement_156;
  }
  indstp = 1;
  write(6, star), " Over12 ready for TACS.  newtac =", newtac;
  if (newtac != 1) {
    tacs2(cmn);
  }
  //C!w      if ( newtac .eq. 1 )
  //C!w     1 call ntacs2
  write(6, star), " Done with TACS, back in over12.  ioutin =", ioutin;
  iout = ioutin;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' IN ''OVER12'' AFTER ''TACS2'' .',"
      "'    IOUT  INDSTP  MULTPR  KPRCHG ',/,31x,4i8)"),
      iout, indstp, multpr, kprchg;
  }
  if (kill > 0) {
    goto statement_9200;
  }
  if (nchain != n1) {
    goto statement_9800;
  }
statement_156:
  cmn.iftail = 0;
  if (kbase == 0) {
    goto statement_598;
  }
  if (kbase != intinf) {
    tables(cmn);
  }
  if (ktab == 0) {
    iprout = 0;
  }
  if (iprsup >= 1) {
    write(lunit6, format_2721), n4, nword1, nword2, ltlabl, ktab,
      isw, cmn.lunit2, cmn.iv, lbrnch;
  }
  cmn.io.rewind(lunt10);
  n8 = 0;
  FEM_DO_SAFE(i, 1, kswtch) {
    if (adelay(i) != -44444.f) {
      goto statement_7256;
    }
    n8++;
  statement_7256:;
  }
  write(lunt10, fem::unformatted), n8;
  FEM_DO_SAFE(i, 1, kswtch) {
    if (adelay(i) != -44444.f) {
      goto statement_7259;
    }
    j = i + lswtch;
    write(lunt10, fem::unformatted), i, adelay(i), crit(i), topen(j);
  statement_7259:;
  }
  if (kbase != intinf) {
    goto statement_7263;
  }
  knt = 1;
  moncar(1) = knt;
  goto statement_166;
statement_7263:
  nenerg = 0;
  if (iprsup >= 1) {
    write(lunit6, format_4624), knt, kbase, kloaep, mtape;
  }
  if (iprsup >= 4) {
    {
      write_loop wloop(cmn, lunit6, "(/,' AT 76',2i10,/,1x,6i5)");
      wloop, kswtch, kloaep;
      FEM_DO_SAFE(ip, 1, ll6) {
        wloop, kdepsw(ip);
      }
    }
  }
  FEM_DO_SAFE(j, 1, kswtch) {
    if (std::abs(adelay(j)) != 44444.f) {
      goto statement_42630;
    }
    n = kdepsw(j);
    if (n == 0) {
      goto statement_42300;
    }
    tma = tclose(n);
    if (adelay(n) == -44444.f) {
      tma = topen(n);
    }
    tmb = tclose(j);
    if (adelay(j) == -44444.f) {
      tmb = topen(j);
    }
    tmc = tma + tmb;
    if (adelay(j) == 44444.f) {
      tclose(j) = tmc;
    }
    if (adelay(j) == -44444.f) {
      topen(j) = tmc;
    }
    goto statement_42500;
  statement_42300:
    if (kloaep <= 0) {
      goto statement_42500;
    }
    tmt = tclose(kloaep);
    if (adelay(kloaep) == -44444.f) {
      tmt = topen(kloaep);
    }
    if (adelay(j) == 44444.f) {
      tclose(j) = tmt;
    }
    if (adelay(j) == -44444.f) {
      topen(j) = tmt;
    }
  statement_42500:
    crit(j) = 0.0f;
    if (adelay(j) == -44444.f) {
      goto statement_42630;
    }
    topen(j) = cmn.fltinf;
    adelay(j) = 0.0f;
  statement_42630:;
  }
  if (iprsup < 1) {
    goto statement_598;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(' AT 52630, TCLOSE AFTER SORTING',/(1x,8e15.6))");
    FEM_DO_SAFE(j, 1, kswtch) {
      wloop, tclose(j);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(' AT 5263, TOPEN AFTER SORTING',/(1x,8e15.6))");
    FEM_DO_SAFE(j, 1, kswtch) {
      wloop, topen(j);
    }
  }
  goto statement_598;
statement_4088:
  ii = 0;
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(i, 1, ntot) {
      wloop, bus(i);
    }
  }
  FEM_DO_SAFE(i, 1, kswtch) {
    j = lswtch + i;
    write(lunit3, fem::unformatted), kmswit(i), kmswit(j), adelay(i),
      crit(i), topen(j), kdepsw(i);
  }
  write(lunit3, fem::unformatted), kloaep;
  ncompt = 2 * (sigmax / aincr + cmn.flzero);
  nhalf = ncompt / 2;
  n3 = 0;
  FEM_DO_SAFE(i, 1, kswtch) {
    if (std::abs(adelay(i)) != 44444.f) {
      goto statement_4090;
    }
    n3++;
  statement_4090:;
  }
  n4 = nbyte(3) / nbyte(4);
  iofcnt = n4 * ncompt;
  ioftab = n4 * 3 * ncompt;
  mxpair = n3 * (n3 - 1) / 2;
  n2 = (3 + mxpair) * ncompt;
  if (cmn.kburro == 1) {
    goto statement_4093;
  }
  n1 = locint(kswtyp(1)) - locint(irandn(1));
  move0(irandn, n1);
  goto statement_4097;
statement_4093:
  move0(irandn, lsiz23);
  n1 = lsiz23;
statement_4097:
  if (iprsup >= 1) {
    goto statement_4095;
  }
  goto statement_4099;
statement_4095:
  write(lunit6, "(/,' AT 2345 OF OVER12  ')");
  FEM_DO_SAFE(i, 1, kswtch) {
    j = lswtch + i;
    write(lunit6, "(1x,2i6,3e15.6)"), kmswit(i), kmswit(j), adelay(i),
      crit(i), topen(j);
  }
statement_4099:
  if (n1 >= n2) {
    goto statement_4100;
  }
  kill = 151;
  lstat(19) = 4090;
  lstat(13) = ncompt;
  lstat(14) = n1;
  lstat(15) = n2;
  lstat(16) = n3;
  goto statement_9200;
statement_4100:
  FEM_DO_SAFE(L, 1, ncompt) {
    if (L > nhalf) {
      goto statement_4110;
    }
    frandn(L) = -aincr * (nhalf - L);
    goto statement_4120;
  statement_4110:
    frandn(L) = aincr * (L - nhalf);
  statement_4120:;
  }
statement_409:
  if (nenerg < 0) {
    goto statement_188;
  }
  time44(cmn, atim(1));
  runtym(d1, d2);
  seed = seedy(cmn, atim(1)) + 1000.f * (d1 + d2);
  seed = 2.0f * seed;
  if (jseedr >= nenerg) {
    seed = seedr;
  }
  d8 = randnm(cmn, seed);
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' IN  =OVER12=  JUST AFTER 1ST USE OF  =RANDNM= .',/,1x,"
      "'     KNT  KSWTCH  JSEEDR  NENERG   ITEST   IDIST',16x,'SEED',18x,'D8',"
      "/,1x,6i8,2e20.10)"),
      knt, kswtch, jseedr, nenerg, itest, idist, seed, d8;
  }
  bias = 0.0f;
  if (itest == 1) {
    goto statement_1646;
  }
  if (knt > 1) {
    goto statement_1615;
  }
  nswtpe = 0;
  FEM_DO_SAFE(i, 1, kswtch) {
    if (std::abs(adelay(i)) != 44444.f) {
      goto statement_1605;
    }
    if (adelay(i) == 44444.f) {
      goto statement_1607;
    }
  statement_1605:;
  }
  goto statement_1608;
statement_1607:
  nswtpe++;
statement_1608:
  FEM_DO_SAFE(i, 1, kswtch) {
    if (std::abs(adelay(i)) != 44444.f) {
      goto statement_1610;
    }
    if (adelay(i) == -44444.f) {
      goto statement_1612;
    }
  statement_1610:;
  }
  goto statement_1615;
statement_1612:
  nswtpe++;
statement_1615:
  secfrq = (1.0f / statfr) / 360.f;
  window = (cmn.degmax - degmin) * secfrq;
  if (window < 0.0f) {
    window = 360.f * secfrq;
  }
  zerofl = 0.0f;
  d14 = knt;
  d14 = d14 / nenerg;
  FEM_DO_SAFE(j, 1, nswtpe) {
    if (cmn.linsys != 1) {
      d14 = randnm(cmn, zerofl);
    }
    ranoff = d14 * window + degmin * secfrq;
    //C     write (*,*) ' knt, nenerg, window, degmin, secfrq, d14, ranoff =',
    //C    1              knt, nenerg, window, degmin, secfrq, d14, ranoff
    if (j > 1) {
      goto statement_1619;
    }
    //C     BIAS = RANOFF                                                     M32.4006
    dum9 = ranoff;
    angle = ranoff * 360.f * statfr;
    goto statement_1620;
  statement_1619:
    bias2 = ranoff;
    cmn.angtpe = ranoff * 360.f * statfr;
  statement_1620:;
  }
statement_1646:
  FEM_DO_SAFE(ksw, 1, kswtch) {
    if (std::abs(adelay(ksw)) != 44444.f) {
      goto statement_700;
    }
    ndxi = ksw + lswtch;
    if (itest == 1) {
      goto statement_664;
    }
    if (itest >= 2) {
      goto statement_1663;
    }
    if (itest == 0 && nswtpe < 2) {
      goto statement_1630;
    }
    if (adelay(ksw) == 44444.f) {
      goto statement_1630;
    }
    bias = bias2;
    goto statement_664;
  statement_1630:
    bias = dum9;
    goto statement_664;
  statement_1663:
    if (itest > 2) {
      goto statement_662;
    }
    if (adelay(ksw) == +44444.f) {
      goto statement_663;
    }
    bias = 0.0f;
    goto statement_664;
  statement_663:
    bias = ranoff;
    goto statement_664;
  statement_662:
    if (adelay(ksw) == -44444.f) {
      goto statement_663;
    }
    bias = 0.0f;
  statement_664:
    timev = crit(ksw);
    n = kdepsw(ksw);
    if (kloaep == 0) {
      goto statement_665;
    }
    if (n > 0) {
      goto statement_665;
    }
    timev = crit(kloaep);
  statement_665:
    rng = randnm(cmn, zerofl);
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' AT 666  OF  \"OVER12\" .   KSW, RNG, BIAS, ANGLE =',1i10,"
        "3e16.6)"),
        ksw, rng, bias, angle;
    }
    if (idist > 0) {
      goto statement_675;
    }
    if (topen(ndxi) < 0.0f) {
      goto statement_675;
    }
    d9 = rng;
    if (d9 == 0.0f) {
      goto statement_665;
    }
    if (d9 == 1.0f) {
      goto statement_665;
    }
    if (2.0f * d9 > 1.0f) {
      d9 = 1.0f - d9;
    }
    d7 = alogz(1.0f / (d9 * d9));
    eh = sqrtz(d7);
    xn = 2.515517f + eh * (0.802853f + 0.010328f * eh);
    xd = 1.0f + eh * (1.432788f + eh * (0.189269f + 0.001308f * eh));
    xq = eh - xn / xd;
    if (xq > sigmax) {
      xq = sigmax;
    }
    if (2.0f * rng < 1.0f) {
      xq = -xq;
    }
    rng = timev + topen(ndxi) * xq + bias;
    goto statement_680;
  statement_675:
    d1 = 3.0f;
    rng = timev + bias + sqrtz(d1) * std::abs(topen(ndxi)) * (2.0f * rng - 1.0f);
  statement_680:
    if (adelay(ksw) == -44444.f) {
      goto statement_7680;
    }
    tclose(ksw) = rng;
    if (n == 0) {
      goto statement_700;
    }
    if (adelay(n) == 44444.f) {
      tclose(ksw) = tclose(n) + tclose(ksw) - bias;
    }
    if (adelay(n) == -44444.f) {
      tclose(ksw) = topen(n) + tclose(ksw) - bias;
    }
    if (tclose(ksw) < deltat) {
      goto statement_690;
    }
    goto statement_700;
  statement_7680:
    topen(ksw) = rng;
    if (n == 0) {
      goto statement_700;
    }
    if (adelay(n) == 44444.f) {
      topen(ksw) = tclose(n) + topen(ksw) - bias;
    }
    if (adelay(n) == -44444.f) {
      topen(ksw) = topen(n) + topen(ksw) - bias;
    }
    if (topen(ksw) < deltat) {
      goto statement_690;
    }
    goto statement_700;
  statement_690:
    time44(cmn, atim(1));
    runtym(d1, d2);
    seed = seedy(cmn, atim(1)) + 1000.f * (d1 + d2);
    seed = 2.0f * seed;
    d8 = randnm(cmn, seed);
    rng = randnm(cmn, zerofl);
    ltdelt++;
    moncar(3) = ltdelt;
    if (adelay(ksw) == 44444.f) {
      tclose(ksw) = 0.0f;
    }
    if (adelay(ksw) == -44444.f) {
      topen(ksw) = 0.0f;
    }
  statement_700:;
  }
  if (moncar(7) <= 0) {
    goto statement_300;
  }
  //C     NOW READ USER-SUPPLIED TCLOSE OF "USER SUPPLIED SWITCH TIMES"     M37.4106
  n17 = moncar(7);
  {
    read_loop rloop(cmn, n17, format_4372);
    FEM_DO_SAFE(ksw, 1, kswtch) {
      rloop, tclose(ksw);
    }
  }
  {
    read_loop rloop(cmn, n17, format_4372);
    FEM_DO_SAFE(ksw, 1, kswtch) {
      rloop, topen(ksw);
    }
  }
statement_300:
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    wloop, ranoff;
    FEM_DO_SAFE(k1, 1, kswtch) {
      wloop, tclose(k1);
    }
  }
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    wloop, ranoff;
    FEM_DO_SAFE(k1, 1, kswtch) {
      wloop, topen(k1);
    }
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, format_4624);
      wloop, knt, kbase, kloaep, mtape, nenerg, jseedr, ltdelt,
        kswtch, seedr, ranoff;
      FEM_DO_SAFE(k1, 1, kswtch) {
        wloop, tclose(k1);
      }
      FEM_DO_SAFE(k, 1, kswtch) {
        wloop, topen(k);
      }
    }
  }
  if (isw != 4444) {
    goto statement_703;
  }
  npair = 0;
  irbase = ioftab;
  if (idist > 0) {
    goto statement_840;
  }
  FEM_DO_SAFE(j, 1, kswtch) {
    if (std::abs(adelay(j)) != 44444.f) {
      goto statement_830;
    }
    k = j + lswtch;
    if (topen(k) < 0) {
      goto statement_830;
    }
    if (kloaep == 0) {
      goto statement_752;
    }
    if (kdepsw(j) == 0) {
      goto statement_751;
    }
    tstatj = crit(j) + crit(kloaep);
    goto statement_754;
  statement_751:
    tstatj = crit(kloaep);
    goto statement_754;
  statement_752:
    if (kdepsw(j) == 0) {
      goto statement_753;
    }
    n = kdepsw(j);
    tstatj = crit(j) + crit(n);
    goto statement_754;
  statement_753:
    tstatj = crit(j);
  statement_754:
    j1 = j - 1;
    FEM_DO_SAFE(i, 1, j1) {
      if (std::abs(adelay(i)) != 44444.f) {
        goto statement_820;
      }
      if (i == j) {
        goto statement_820;
      }
      ni = i + lswtch;
      if (topen(ni) < 0) {
        goto statement_820;
      }
      npair++;
      tdiff = tclose(i) - tclose(j);
      if (kloaep == 0) {
        goto statement_762;
      }
      if (kdepsw(i) == 0) {
        goto statement_761;
      }
      tstati = crit(i) + crit(kloaep);
      goto statement_764;
    statement_761:
      tstati = crit(kloaep);
      goto statement_764;
    statement_762:
      if (kdepsw(i) == 0) {
        goto statement_763;
      }
      n = kdepsw(i);
      tstati = crit(i) + crit(n);
      goto statement_764;
    statement_763:
      tstati = crit(i);
    statement_764:
      tmean = tstati - tstatj;
      tdiff = tdiff - tmean;
      sumdt = sqrtz(topen(ni) * topen(ni) + topen(k) * topen(k));
      fsigma = sigmax * sumdt;
      if (std::abs(tdiff) <= fsigma) {
        goto statement_800;
      }
      ii++;
      goto statement_820;
    statement_800:
      sumdt = sumdt * aincr;
      k1 = tdiff / sumdt;
      if (iprsup >= 1) {
        write(lunit6, "(' NPAIR,TDIFF,SUMDT,K1=',10x,i6,2e15.6,i6)"),
          npair, tdiff, sumdt, k1;
      }
      if (tdiff < 0.0f) {
        goto statement_805;
      }
      k1 += nhalf + 1;
      goto statement_810;
    statement_805:
      k1 += nhalf;
    statement_810:
      k1 = k1 * n4 - 1;
      n6 = irbase + k1;
      irandn(n6)++;
      irbase += iofcnt;
    statement_820:;
    }
  statement_830:;
  }
  knt++;
  moncar(1) = knt;
  if (knt <= nenerg) {
    goto statement_409;
  }
statement_840:
  npair = 0;
  irbase = ioftab;
  FEM_DO_SAFE(j, 1, kswtch) {
    if (std::abs(adelay(j)) != 44444.f) {
      goto statement_895;
    }
    j1 = j - 1;
    FEM_DO_SAFE(i, 1, j1) {
      if (std::abs(adelay(i)) != 44444.f) {
        goto statement_890;
      }
      if (i == j) {
        goto statement_890;
      }
      npair++;
      k1 = kmswit(j);
      ndx1 = lswtch + j;
      k2 = kmswit(ndx1);
      k3 = kmswit(i);
      ndx2 = lswtch + i;
      k4 = kmswit(ndx2);
      bus1 = bus(k1);
      bus2 = bus(k2);
      bus3 = bus(k3);
      bus4 = bus(k4);
      write(lunit6,
        "(/,/,' SWITCH PAIR',i4,15x,'  ''',a6,'''  TO  ''',a6,'''   AND   ''',"
        "a6,'''  TO  ''',a6,'''')"),
        npair, bus1, bus2, bus3, bus4;
      if (idist > 0) {
        goto statement_850;
      }
      if (topen(ndx1) < 0) {
        goto statement_850;
      }
      if (topen(ndx2) < 0) {
        goto statement_850;
      }
      goto statement_858;
    statement_850:
      write(lunit6,
        "(' IN THIS PAIR EITHER ONE OR BOTH SWITCH CLOSING TIMES ARE GENERATED"
        " ACCORDING TO THE UNIFORM DISTRIBUTION AND IT WILL BE SKIPPED.')");
      goto statement_890;
    statement_858:
      n3 = ncompt - 1;
      FEM_DO_SAFE(L, 1, n3) {
        k = L + 1;
        k1 = k * n4 - 1;
        l1 = L * n4 - 1;
        n7 = irbase + k1;
        n8 = irbase + l1;
        irandn(n7) += irandn(n8);
        total = nenerg;
        m = ncompt + k;
        frandn(m) = irandn(n7) / total;
        d9 = (k - nhalf) * aincr;
        az = std::abs(d9);
        t = 1.0f / (1.0f + .2316419f * az);
        d1 = .3989423f * expz(-d9 * d9 * onehaf);
        d8 = 1.0f - d1 * t * ((((1.330274f * t - 1.821256f) * t +
          1.781478f) * t - .3565638f) * t + .3193815f);
        if (d9 >= 0.0f) {
          goto statement_864;
        }
        d8 = 1.0f - d8;
      statement_864:
        n9 = m + ncompt;
        frandn(n9) = d8;
      }
      irbase += iofcnt;
      n1 = 1;
      n2 = 14;
      n3 = 2 * ncompt;
    statement_869:
      if (n2 > ncompt) {
        n2 = ncompt;
      }
      {
        write_loop wloop(cmn, lunit6, "(1x,'TIME',10x,14f8.4)");
        FEM_DO_SAFE(L, n1, n2) {
          wloop, frandn(L);
        }
      }
      n6 = n1 + ncompt;
      n7 = n2 + ncompt;
      {
        write_loop wloop(cmn, lunit6, "(1x,'SAMPLE',8x,14f8.4)");
        FEM_DO_SAFE(L, n6, n7) {
          wloop, frandn(L);
        }
      }
      n8 = n1 + n3;
      n9 = n2 + n3;
      {
        write_loop wloop(cmn, lunit6, "(1x,'THEORETICAL',3x,14f8.4,/,1x)");
        FEM_DO_SAFE(L, n8, n9) {
          wloop, frandn(L);
        }
      }
      n1 += 14;
      if (n1 > ncompt) {
        goto statement_890;
      }
      n2 += 14;
      goto statement_869;
    statement_890:;
    }
    if (ii == 0) {
      goto statement_895;
    }
    write(lunit6,
      "(/,i6,' OUT OF',i6,' SWITCH CLOSING TIMES FALLING BEYOND',f8.4,"
      "' TIMES THE STANDARD DEVIATION.')"),
      ii, nenerg, sigmax;
  statement_895:;
  }
  lstat(32) = kswtch;
  cmn.xmaxmx = 1.0f;
  aincr = 1.0f;
  cmn.numnvo = 1;
  cmn.nc = 1;
  runtym(d1, d2);
  flstat(5) += d1;
  flstat(6) += d2;
  flstat(9) = d1;
  flstat(10) = d2;
  lastov = 12;
  nchain = 29;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
statement_703:
  if (isw == 0) {
    goto statement_702;
  }
  if (knt == 1) {
    goto statement_702;
  }
  n6 = 0;
  FEM_DO_SAFE(k1, 1, kswtch) {
    if (fem::iabs(kpos(k1)) == 2) {
      goto statement_4208;
    }
    if (adelay(k1) != 44444.f) {
      goto statement_4216;
    }
    volti(n6 + 1) = tclose(k1);
    goto statement_4213;
  statement_4208:
    if (adelay(k1) != -44444.f) {
      goto statement_4216;
    }
    volti(n6 + 1) = topen(k1);
  statement_4213:
    n6++;
    if (n6 < 2 * cmn.lsiz26) {
      goto statement_4215;
    }
    lstat(19) = 4213;
    iprint = 26;
    goto statement_9200;
  statement_4215:
    lastxx(n6) = k1;
  statement_4216:;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,32x,'RANDOM SWITCHING TIMES FOR ENERGIZATION NUMBER',i4,/(32x,5(i4,"
      "e16.6)))");
    wloop, knt;
    FEM_DO_SAFE(k1, 1, n6) {
      wloop, lastxx(k1), volti(k1);
    }
  }
statement_702:
  if (knt == 1) {
    goto statement_598;
  }
  n9 = ipntv(11);
  if (n9 <= 0) {
    goto statement_6666;
  }
  FEM_DO_SAFE(i, 1, n9) {
    read(lunit5, "(a1)"), d1;
  }
statement_6666:
  lastov = 12;
  nchain = 16;
  goto statement_9800;
statement_188:
  klorow = ipntv(1);
  ilorow = 1;
  if (kloaep == 0) {
    goto statement_190;
  }
  klorow = kloaep;
  ilorow = cmn.iloaep;
statement_190:
  nj = klorow + lswtch;
  ns2 = tdns(klorow);
  if (numref <= 1) {
    goto statement_201;
  }
  if (knt == 1) {
    indtv(ilorow) = 1;
  }
  j = 0;
statement_198:
  j++;
  if (j != ilorow) {
    goto statement_195;
  }
  if (j == numref) {
    goto statement_201;
  }
  goto statement_199;
statement_195:
  indtv(j)++;
  n1 = ipntv(j);
  ns1 = tdns(n1);
  if (indtv(j) <= ns1) {
    goto statement_200;
  }
  indtv(j) = 1;
  if (j == numref) {
    goto statement_201;
  }
  goto statement_199;
statement_201:
  indtv(ilorow)++;
  if (indtv(ilorow) > ns2) {
    goto statement_702;
  }
  goto statement_200;
statement_199:
  if (j < numref) {
    goto statement_198;
  }
statement_200:
  tstbeg = crit(klorow);
  if (itest > 0) {
    goto statement_203;
  }
  tstbeg = tstbeg - 0.5f * (tdns(klorow) - 1.0f) * topen(nj);
statement_203:
  if (adelay(klorow) == 44444.f) {
    tclose(klorow) = tstbeg + (indtv(ilorow) - 1) * topen(nj);
  }
  if (adelay(klorow) == -44444.f) {
    topen(klorow) = tstbeg + (indtv(ilorow) - 1) * topen(nj);
  }
  k = 1;
  FEM_DO_SAFE(i, 1, kswtch) {
    if (k != ilorow) {
      goto statement_207;
    }
    k++;
    if (indtv(k) == 0) {
      indtv(k) = 1;
    }
  statement_207:
    if (i == klorow) {
      goto statement_230;
    }
    if (ipntv(k) == 0) {
      goto statement_210;
    }
    if (i == ipntv(k)) {
      goto statement_220;
    }
  statement_210:
    if (std::abs(adelay(i)) != 44444.f) {
      goto statement_230;
    }
    n = kdepsw(i);
    if (adelay(i) == 44444.f) {
      tclose(i) = tclose(n) + crit(i);
    }
    if (adelay(i) == -44444.f) {
      topen(i) = topen(n) + crit(i);
    }
    goto statement_230;
  statement_220:
    j = i + lswtch;
    if (kloaep == 0) {
      goto statement_225;
    }
    n2 = ipntv(k);
    if (adelay(i) == 44444.f) {
      tclose(i) = tclose(kloaep) + topen(j) * (indtv(k) - .5f - .5f * tdns(n2));
    }
    if (adelay(i) == -44444.f) {
      topen(i) = topen(kloaep) + topen(j) * (indtv(k) - .5f - .5f * tdns(n2));
    }
    goto statement_228;
  statement_225:
    tstbeg = crit(i);
    if (itest > 0) {
      goto statement_227;
    }
    tstbeg = crit(i) - 0.5f * (tdns(i) - 1.0f) * topen(j);
  statement_227:
    if (adelay(i) == 44444.f) {
      tclose(i) = tstbeg + (indtv(k) - 1) * topen(j);
    }
    if (adelay(i) == -44444.f) {
      topen(i) = tstbeg + (indtv(k) - 1) * topen(j);
    }
  statement_228:
    k++;
    if (indtv(k) == 0) {
      indtv(k) = 1;
    }
  statement_230:;
  }
  goto statement_300;
  //C                                                         PREPARING R,X,   10717
statement_598:
  d2 = 1.0f / (deltat * 500.f);
  if (cmn.m4plot != 1) {
    goto statement_5763;
  }
  if (kbrser != 1) {
    goto statement_5763;
  }
  n24 = kbreak;
  kbrser = 2;
  kbreak = 1;
  emtspy(cmn);
  kbreak = n24;
statement_5763:
  if (iprsup < 2) {
    goto statement_6300;
  }
  write(lunit6, "(/,' AT S.N. 6 OF OVER12.   NENERG =',i3)"), nenerg;
  FEM_DO_SAFE(i, 1, kswtch) {
    ndx3 = lswtch + i;
    write(lunit6, "(1x,2i6,3e15.6)"), kmswit(i), kmswit(ndx3), adelay(i),
      crit(i), topen(ndx3);
  }
statement_6300:
  if (cmn.numsm <= 0) {
    goto statement_901;
  }
  elecyy(cmn);
  premec(cmn);
statement_901:
  if (it == 0) {
    goto statement_433;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' LUMPED-ELEMENT BRANCH-PARAMETER VALUES',"
        "' IN \"OVER12\", PRIOR TO PROCESSING.',/,18x,'TR',18x,'TX',19x,'R',"
        "19x,'C',/(1x,4e20.10))");
      FEM_DO_SAFE(i, 1, it) {
        wloop, tr(i), tx(i), r(i), c(i);
      }
    }
  }
  k = 1;
statement_5527:
  j = length(k);
  xopt = xoptbr(k);
  copt = coptbr(k);
  d22 = d2;
  ci1 = d2 / 1000.f;
  if (xopt > 0.0f) {
    d22 = d2 * 1000.f / (twopi * xopt);
  }
  if (copt > 0.0f) {
    ci1 = ci1 / (twopi * copt);
  }
  //C     IF (KODSEM(K) .NE. 0  .AND. IMODEL(K) .NE. -2                     M32.4122
  //C    1                      .OR.  IMODEL(K) .NE. -4) J = KODEBR(K)      M43.1185
  if (kodsem(k) != 0 && imodel(k) >= 0) {
    j = kodebr(k);
  }
  if (j == 0) {
    j = 1;
  }
  j = fem::iabs(j);
  if (kbus(k) < 0) {
    goto statement_5539;
  }
  if (kodebr(k) > 0) {
    goto statement_5539;
  }
  if (length(k) < 0) {
    goto statement_5539;
  }
  n1 = fem::iabs(nr(k));
  n2 = n1 - 1 + j * (j + 1) / 2;
  if (iprsup >= 2) {
    write(lunit6, "(/,' AT 5528.',5i10,e15.5)"), k, length(k), nr(k),
      n1, n2, d22;
  }
  //C     CHECK FOR THE PRESENCE OF THE -666 BRANCHES  *   *   *   *   *   *M32.4123
  if (length(k + 1) != -666) {
    goto statement_905;
  }
  dteqiv(cmn, ikf, isfd, d22, azr, azi);
  //C     CONVERT MODAL IMPEDANCES TO PHASE FRAME OF REFERENCE *   *   *   *M32.4126
  cz = j;
  azr = (azr - azi) / cz;
  lb = n1;
  ka = 1;
  //C     LOAD THE EQUIVALENT IMPEDANCES INTO THE  TR  TABLES  *   *   *   *M32.4131
  FEM_DO_SAFE(kb, n1, n2) {
    tr(kb) = azr;
    tx(kb) = 0.f;
    if (lb != kb) {
      goto statement_904;
    }
    tr(lb) += azi;
    ka++;
    lb += ka;
  statement_904:;
  }
statement_905:
  FEM_DO_SAFE(i, n1, n2) {
    c(i) = c(i) * ci1;
    x(i) = tr(i) + tx(i) * d22;
    tx(i) = -x(i);
  }
statement_5539:
  k += j;
  if (k <= ibr) {
    goto statement_5527;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (X(I), C(I), I=1, IT)   AFTER CONVERSION',"
        "' TO  R + 2*L/DELTAT .',/(1x,8e16.7))");
      FEM_DO_SAFE(i, 1, it) {
        wloop, x(i), c(i);
      }
    }
  }
statement_433:
  if (kswtch == 0) {
    goto statement_430;
  }
  if (iprsup >= 1) {
    goto statement_455;
  }
  goto statement_477;
statement_455:
  write(lunit6,
    "(/,' SWITCH TABLE VECTORS, BEFORE SWITCH TABLE PROCESSING IN  ''OVER12'' "
    ".',/,'     ROW   BUS1    BUS2     KPOS  ISOURC',14x,'TCLOSE',15x,'TOPEN',"
    "16x,'CRIT',14x,'FKPOSI')");
  FEM_DO_SAFE(k, 1, kswtch) {
    ndx4 = lswtch + k;
    write(lunit6, "(6i8,3e20.10)"), k, kmswit(k), kmswit(ndx4), kpos(k),
      isourc(k), kswtyp(k), tclose(k), topen(k), crit(k);
  }
statement_477:
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' CONTINUATION OF SWITCH TABLE VECTORS.',/,5x,'ROW',9x,'ENERGY',"
        "9x,9x,'ADELAY',/(i8,2e15.6))");
      FEM_DO_SAFE(k, 1, kswtch) {
        wloop, k, energy(k), adelay(k);
      }
    }
  }
  FEM_DO_SAFE(k, 1, kswtch) {
    n1 = kmswit(k);
    ndx5 = lswtch + k;
    n2 = kmswit(ndx5);
    icheck = kswtyp(k);
    if (std::abs(adelay(k)) == 44444.f) {
      goto statement_422;
    }
    if (adelay(k) <= 0.f) {
      goto statement_428;
    }
    adelay(ndx5) = adelay(k);
    goto statement_422;
  statement_428:
    if (icheck <= 0) {
      goto statement_422;
    }
    if (istead == 0) {
      goto statement_422;
    }
    if (icheck == 9976) {
      goto statement_422;
    }
    nn1 = kbus(icheck);
    n15 = nn1;
    if (n15 == 1) {
      n15 = n2;
    }
    n16 = fem::iabs(kssfrq(n15));
    omega = twopi * sfreq(n16);
    ck1 = (f(nn1) - f(n2)) / omega;
    if (noutpr == 0) {
      write(lunit6,
        "(' INITIAL FLUX IN COIL ''',a6,''' TO ''',a6,''' =',e13.5)"),
        bus(nn1), bus(n2), ck1;
    }
    ck(icheck) = ck1 - (e(nn1) - e(n2)) * delta2;
    if (std::abs(ck1) > topen(k) && noutpr == 0) {
      write(lunit6,
        "(' WARNING.  ASSUMPTION THAT AC STEADY STATE HAS FUNDAMENTAL FREQUENC"
        "Y ONLY IS QUESTIONABLE WITH PRECEDING FLUX OUTSIDE  LINEAR REGION')");
    }
  statement_422:;
  }
  //C                                      INVERSION OF MATRICES OF COUPLED    10834
  //C                                           PRESETTING TABLES FOR LOSSLE   10835
statement_430:
  k = 1;
  itadd = it + 1;
  n1 = ibr + 1;
  if (n1 < 10) {
    n1 = 10;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,'     ROW    KBUS    MBUS  LENGTH  KODEBR  KODSEM  INDSEM',12x,"
        "'CIK',12x,'CKI',10x,'CKKJM',/(7i8,3e15.6))");
      FEM_DO_SAFE(i, 1, n1) {
        wloop, i, kbus(i), mbus(i), length(i), kodebr(i), kodsem(i),
          indhst(i), cik(i), cki(i), ckkjm(i);
      }
    }
  }
  n5 = k;
  iline = 1;
  iprint = 8;
statement_500:
  if (kbus(k) < 0) {
    goto statement_535;
  }
  it2 = length(k);
  if (it2 < 0) {
    goto statement_520;
  }
  i = nr(k);
  if (it2 <= 1) {
    goto statement_510;
  }
  if (kodebr(k) <= 0) {
    goto statement_4460;
  }
  L = nr(k);
  jt = it2 * (it2 + 1) / 2;
  mover(tx(L), cmr(1), jt);
  {
    arr<double> cmr(dimension(3002 / 2), fem::fill0);
    const int lennkknonl = 72048;
    arr<double> cmi(dimension(lennkknonl / 2), fem::fill0);

    mover(tx(L), cmr(1), jt);
    d1 = -1.0f / delta2;
    addmxd(cmr(1), d1, cmr(1), it2);
    reduct(cmr(1), it2, ll0);

    ii = L + jt - 1;
    if (iprsup >= 2) {
      {
        write_loop wloop(cmn, lunit6,
          "(/,' AT 4435.  INTERMED. MATRIX (D)',/(1x,6e20.10))");
        FEM_DO_SAFE(i, 1, jt) {
          wloop, cmr(i);
        }
      }
    }
    multmx(cmr(1), tr(L), x(L), cmi(1), it2);
    multmx(cmr(1), tx(L), r(L), cmi(1), it2);
  }
  addmxd(r(L), one, r(L), it2);
  FEM_DO_SAFE(i, L, ii) {
    r(i) = 2.0f * r(i);
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' AT 4451.  FINAL (G), (H) FROM (A), (B).',3i10,/(1x,6e20.10))");
      wloop, k, L, it2;
      FEM_DO_SAFE(i, L, ii) {
        wloop, x(i), r(i);
      }
    }
  }
  goto statement_520;
statement_4460:
  reduct(tx(i), it2, ll0);
  ii = i - 1;
  n2 = 1;
statement_501:
  FEM_DO_SAFE(L, 1, it2) {
    if (L <= n2) {
      goto statement_504;
    }
    n1 += L - 1;
    goto statement_502;
  statement_504:
    n1 = ii + L;
  statement_502:
    volt(L) = tx(n1);
  }
  mult(tr(i), volt(1), volti(1), it2, ll0);
  mult(tx(i), volti(1), volt(1), it2, ll0);
  FEM_DO_SAFE(L, 1, n2) {
    ii++;
    r(ii) = (tx(ii) - volt(L)) * 2.0f;
  }
  n2++;
  if (n2 <= it2) {
    goto statement_501;
  }
  goto statement_520;
statement_530:
  i = fem::iabs(i);
  gus1 = c(i);
  if (gus1 != 0.f) {
    gus1 = 1.0f / gus1;
  }
  gus2 = 1.0f / (x(i) + gus1);
  r(i) = gus2 * (tr(i) * 2.0f - x(i) + gus1);
  x(i) = gus2;
  c(i) = gus1;
  goto statement_520;
statement_535:
  it2 = fem::iabs(length(k));
  if (kodsem(k) == 0 || imodel(k) == -2) {
    goto statement_5349;
  }
  if (kodsem(k) != 0 && imodel(k) == -4) {
    goto statement_5349;
  }
  n1 = k;
  n3 = 1;
statement_5350:
  if (cki(n1) < 0.0f) {
    goto statement_5353;
  }
  n1++;
  n3++;
  goto statement_5350;
statement_5353:
  n2 = k + n3 - 1;
  length(n2) = n3;
  it2 = fem::iabs(kodebr(k));
  n1 = k + it2 - 1;
  n2 = itadd;
  FEM_DO_SAFE(i, k, n1) {
    nr(i) = n2;
    n2++;
  }
  k += n3 - it2;
  goto statement_520;
statement_5349:
  a = it2;
  ii = 1;
statement_534:
  if (ck(k) >= 0.0f) {
    goto statement_6482;
  }
  kf = nr(k);
  cik(k) = kf;
  i = nhist(kf);
  nr(k) = i;
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' FREQ. DEPENDENT MODE.','      KF       I       K      II',"
      "'   ILINE     IT2    KBUS    MBUS',/,22x,8i8)"),
      kf, i, k, ii, iline, it2, kbus(k), mbus(k);
  }
  if (iskip(kf) > 0) {
    goto statement_537;
  }
  h2 = 0.0f;
  goto statement_11536;
statement_6482:
  h2 = cik(k);
  h3 = h2 / deltat;
  i = h3;
  //CL                                                                      M31.2706
  if (imodel(k) == -2) {
    goto statement_50001;
  }
  if (imodel(k) == -4) {
    goto statement_50006;
  }
  goto statement_50005;
  //C                                                                       M43.1196
statement_50006:
  i = -2;
  cmn.inoff1 = lbrnch;
  cmn.inoff2 = 2 * lbrnch;
  cmn.inoff3 = 3 * lbrnch;
  cmn.inoff4 = 4 * lbrnch;
  cmn.inoff5 = 5 * lbrnch;
  koff1 = 900;
  koff2 = koff1 + isecti;
  koff3 = koff2 + isecti;
  koff4 = koff3 + isecti;
  koff5 = koff4 + isecti;
  koff6 = koff5 + isecti;
  koff7 = koff6 + isecti;
  koff8 = koff7 + isecti;
  koff9 = koff8 + isecti;
  koff10 = koff9 + isecti;
  koff13 = koff10 + isecti;
  koff14 = koff13 + isecti;
  koff15 = koff14 + isecti;
  koff16 = koff15 + isecti;
  koff17 = koff16 + isecti;
  koff18 = koff17 + isecti;
  koff19 = koff18 + isecti;
  koff20 = koff19;
  if (jglnn != 0) {
    goto statement_8893;
  }
  FEM_DO_SAFE(jlk, 1, ibr) {
    if (kodsem(jlk) == 0) {
      goto statement_1007;
    }
    nwww = length(jlk);
    nqtw += fem::pow2(nwww);
    nph += nwww;
    jglnn++;
  statement_1007:;
  }
  if (nph <= isecti) {
    goto statement_8891;
  }
  write(lunit6,
    "(' In OVER12, offset variable ISECTI =',i5,"
    "' is too samll.  It should be increased to the value of ',i5,/,"
    "'which is the number of coupled phases currently modelled',"
    "' with new MARTI frequency-dependent format.     STOP.')"),
    isecti, nph;
  FEM_STOP(0);
statement_8891:
  FEM_DO_SAFE(iq, 1, nqtw) {
    nqtt += semaux(koff20 + iq);
  }
statement_8893:
  koff21 = koff20 + nqtt;
  koff22 = koff21 + lbrnch;
  koff23 = koff22 + nqtw;
  koff24 = koff23 + nqtw;
  cmn.koff25 = koff24 + 288;
  nr(k) = i;
  n1 = kodsem(k);
  nrz = cki(k);
  nra = ckkjm(k);
  n8 = n1 + 5 * nrz + 2 * nra + 1;
  n9 = n8 + 1;
  sconst(n9) = sconst(n1);
  sconst(n8) = 0.0f;
  nn8 = n1 + 5 * nrz + 5 * nra + 3;
  nn9 = nn8 + 1;
  nk1 = nn9 + 1;
  sconst(nn8) = 0.0f;
  sconst(nn9) = 0.0f;
  FEM_DO_SAFE(j, 1, nrz) {
    n2 = n1 + j;
    n3 = n2 + nrz;
    fac1 = sconst(n3) * deltat;
    fac2 = sconst(n2) / sconst(n3);
    n5 = n1 + 2 * nrz + 2 * nra + j;
    sconst(n5) = expz(-fac1);
    hi = (one - sconst(n5)) / fac1;
    n6 = n5 + nrz;
    sconst(n6) = fac2 * (one - hi);
    n7 = n6 + nrz;
    sconst(n7) = -fac2 * (sconst(n5) - hi);
    sconst(n8) += sconst(n7);
    sconst(n9) += sconst(n6);
    semaux(koff21 + k) = sconst(n9);
    if (iprsup > 0) {
      write(6,
        "(' J,NRZ,CJ,DJ,EJ,ESUM,D0SUM=Y05',/,1x,i3,2x,i3,3x,e14.5,3x,e14.5,3x,"
        "e14.5,3x,e14.5,3x,e14.5)"),
        j, nrz, sconst(n5), sconst(n6), sconst(n7), sconst(n8),
        sconst(n9);
    }
  }
  jgl = 0;
  //C     IF ( IPRSUP .GT. 0 )                                              M44. 426
  //C    1 write(LUNIT6,4445)
  //C  445  FORMAT(19H   J  NRA  SCST(N5),
  //C    130H  SCST(N6)  SCST(N7)  SST(NN8),                                M44. 429
  //C    330H  SCT(NN9)  ST(NN10)  ST(NN11),                                M44. 430
  //C    430H  ST(NN12)  ST(NN13)  ST(NN14),                                M44. 431
  //C    530H  ST(NN15)      FAC3      FAC4,                                M44. 432
  //C    630H      FAC5      SK1R      SK1I,                                M44. 433
  //C    710H       SWD)                                                    M44. 434
  FEM_DO_SAFE(j, 1, nra) {
    n2 = n1 + 2 * nrz + j;
    n3 = n2 + nra;
    n5 = n1 + 5 * nrz + 2 * nra + 2 + j;
    n6 = n5 + nra;
    n7 = n6 + nra;
    if (std::abs(sconst(n2)) >= 1.e+13f) {
      goto statement_5324;
    }
    if (std::abs(sconst(n2)) == 0.0f) {
      goto statement_5324;
    }
    fac1 = sconst(n3) * deltat;
    fac2 = sconst(n2) / sconst(n3);
    sconst(n5) = expz(-fac1);
    hi = (one - sconst(n5)) / fac1;
    sconst(n6) = fac2 * (one - hi);
    sconst(n7) = -fac2 * (sconst(n5) - hi);
    sconst(nn8) += sconst(n7);
    sconst(nn9) += sconst(n6);
    goto statement_5325;
  statement_5324:
    jgl++;
    if (jgl == 2) {
      goto statement_5486;
    }
    fac1 = sconst(n3) * deltat / 1.e15f;
    sconst(n5) = expz(-fac1);
    dblpr2 = sconst(n5);
    fac3 = -sconst(n3 + 1) * deltat / 1.e15f;
    fac4 = sconst(n3 + 1) / 1.e15f;
    fac5 = sconst(n3) / 1.e15f;
    dcosz(fac3, dblpr3);
    dsinz(fac3, dblpr4);
    dblpr1 = dblpr2 * dblpr3;
    dblpr2 = dblpr2 * dblpr4;
    d18 = fac4 * fac4 + fac5 * fac5;
    nn10 = nk1 + 1;
    nn11 = nn10 + 1;
    nn12 = nn11 + 1;
    nn13 = nn12 + 1;
    nn14 = nn13 + 1;
    nn15 = nn14 + 1;
    nk1 += 6;
    sk1r = sconst(n2) / 1.e+15f;
    sk1i = sconst(n2 + 1) / 1.e+15f;
    rll = ((unity - dblpr1) * fac5 - dblpr2 * fac4);
    sll = -(dblpr2 * fac5 + (unity - dblpr1) * fac4);
    yll = sk1r * rll - sk1i * sll;
    xll = sk1r * dblpr1 - sk1i * dblpr2;
    sconst(n5) = dblpr1;
    sconst(n6) = sk1r - yll / (deltat * d18);
    sconst(n7) = -(xll - yll / (deltat * d18));
    sconst(nn8) += sconst(n7);
    sconst(nn9) += sconst(n6);
    //C 5325 IF ( IPRSUP .GT. 0 )
    //C    1 write(*,5488)J,NRA,SCONST(N5),SCONST(N6),                        M43.1280
    //C    2       SCONST(N7),SCONST(NN8),SCONST(NN9),                        M43.1281
    //C    3   SCONST(NN10), SCONST(NN11), SCONST(NN12),                      M44. 469
    //C    4   SCONST(NN13), SCONST(NN14), SCONST(NN15),                      M44. 470
    //C    5   FAC3, FAC4, FAC5, SK1R, SK1I, SWD                              M44. 471
    //C  488  FORMAT(1X,I3,2X,I3, 17E10.3 )
  statement_5325:
    if (std::abs(sconst(n2)) <= 1.e+14f) {
      goto statement_50008;
    }
    if (jgl == 1) {
      goto statement_50008;
    }
  statement_5486:
    jgl = 0;
  statement_50008:;
  }
  goto statement_5335;
  //C                                                                       M43.1287
statement_50001:
  i = -2;
  nr(k) = i;
  n1 = kodsem(k);
  nrz = cki(k);
  nra = ckkjm(k);
  n8 = n1 + 5 * nrz + 2 * nra + 1;
  n9 = n8 + 1;
  sconst(n9) = sconst(n1);
  sconst(n8) = 0.0f;
  nn8 = n1 + 5 * nrz + 5 * nra + 3;
  nn9 = nn8 + 1;
  sconst(nn8) = 0.0f;
  sconst(nn9) = 0.0f;
  FEM_DO_SAFE(j, 1, nrz) {
    n2 = n1 + j;
    n3 = n2 + nrz;
    fac1 = sconst(n3) * deltat;
    fac2 = sconst(n2) / sconst(n3);
    n5 = n1 + 2 * nrz + 2 * nra + j;
    sconst(n5) = expz(-fac1);
    hi = (one - sconst(n5)) / fac1;
    n6 = n5 + nrz;
    sconst(n6) = fac2 * (one - hi);
    n7 = n6 + nrz;
    sconst(n7) = -fac2 * (sconst(n5) - hi);
    sconst(n8) += sconst(n7);
    sconst(n9) += sconst(n6);
  }
  FEM_DO_SAFE(j, 1, nra) {
    n2 = n1 + 2 * nrz + j;
    n3 = n2 + nra;
    fac1 = sconst(n3) * deltat;
    fac2 = sconst(n2) / sconst(n3);
    n5 = n1 + 5 * nrz + 2 * nra + 2 + j;
    sconst(n5) = expz(-fac1);
    hi = (one - sconst(n5)) / fac1;
    n6 = n5 + nra;
    sconst(n6) = fac2 * (one - hi);
    n7 = n6 + nra;
    sconst(n7) = -fac2 * (sconst(n5) - hi);
    sconst(nn8) += sconst(n6);
    sconst(nn9) += sconst(n7);
  }
  //C                                                                       M43.1290
  //C     Should put the calculation of Ti integer here using               M43.1291
  //C     same way as Zc & A1 had been done above                           M43.1292
  //C                   LJG. April 20, 1987                                 M43.1293
  //C                                                                       M43.1294
  ci(k) = one / (sconst(n9) * a);
  ck(k) = 1.0f;
  cik(k) = 1.0f;
  goto statement_5335;
statement_50005:
  if (istead > 0) {
    goto statement_531;
  }
  if (h2 <= cmn.tmax) {
    goto statement_531;
  }
  i = -2;
statement_531:
  n4 = h3;
  d1 = n4;
  cik(k) = h3 - d1;
  if (i != 0) {
    goto statement_537;
  }
statement_11536:
  kill = 29;
  lstat(19) = 531;
  flstat(16) = h2;
statement_12536:
  n1 = fem::iabs(kbus(k));
  n2 = fem::iabs(mbus(k));
  bus1 = bus(n1);
  bus2 = bus(n2);
  goto statement_9200;
statement_537:
  if (ii == 1) {
    length(k) = iline;
  }
  iline += i + 2;
  nr(k) = i;
  if (iline < cmn.lpast) {
    goto statement_536;
  }
  lstat(19) = 537;
  goto statement_9000;
statement_536:
  if (ck(k) >= 0.0f) {
    goto statement_5074;
  }
  ck(k) = -1.0f;
  yx = zinf(kf);
  goto statement_533;
statement_5074:
  ck1 = ck(k) * onehaf;
  yx = ci(k);
  if (yx < 0.f) {
    goto statement_532;
  }
  yx += ck1 / 2.0f;
  ck(k) = (yx - ck1) / yx;
  if (ck(k) > 0.0f) {
    goto statement_533;
  }
  kill = 102;
  lstat(19) = 536;
  lstat(15) = k;
  flstat(14) = ck1 * 2.0f;
  flstat(15) = yx - 0.5f * ck1;
  goto statement_12536;
statement_532:
  ck(k) = expz(ck1 / yx);
statement_533:
  ci(k) = 1.0f / (yx * a);
  if (iprsup < 4) {
    goto statement_5335;
  }
  if (noutpr == 0) {
    write(lunit6,
      "(/,' AFTER PROCESSING NEW MODE OF LINE.',/,"
      "'       K      II  LENGTH   ILINE     IT2       I      N3',13x,'H3',9x,"
      "'CIK(K)',/,7i8,2e15.6)"),
      k, ii, length(k), iline, it2, i, n3, h3, cik(k);
  }
statement_5335:
  if (ii < it2) {
    goto statement_5375;
  }
  it2 = 1;
  goto statement_520;
statement_5375:
  if (ii > 1) {
    goto statement_538;
  }
  length(k + 1) = length(k);
  length(k) = -it2;
statement_538:
  ii++;
  k++;
  goto statement_534;
statement_510:
  if (i < 0) {
    goto statement_530;
  }
  tx(i) = 1.0f / x(i);
  r(i) = 2.0f * (x(i) - tr(i)) / fem::pow2(x(i));
  //C                                                                       M43.1298
  //C                                                                       M43.1299
statement_520:
  if (kbus(k) >= 0) {
    goto statement_81520;
  }
  if (kodsem(k) != 0 && imodel(k) == -4) {
    goto statement_5698;
  }
  if (kodsem(k) != 0 && imodel(k) != -2) {
    goto statement_81515;
  }
statement_5698:
  itadd += ii * (ii + 1) / 2;
  goto statement_81520;
statement_81515:
  itadd += it2 * (it2 + 1) / 2;
statement_81520:
  k += fem::iabs(it2);
  n5 = k;
  if (k <= ibr) {
    goto statement_500;
  }
  lastov = 12;
  nchain = 13;
  if (iprsup <= 2) {
    goto statement_9800;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' BRANCH-TABLE INTEGER VECTORS AT END ''OVER12'' .',/,"
      "'     ROW    KBUS    MBUS      NR  KODEBR  LENGTH  KODSEM  INDHST',"
      "/(8i8))");
    FEM_DO_SAFE(k, 1, ibr) {
      wloop, k, kbus(k), mbus(k), nr(k), kodebr(k), length(k), kodsem(k),
        indhst(k);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,5x,'ROW',7x,'BUS',13x,'CI',13x,'CK',12x,'CIK',12x,'CKI',10x,'CKKJM',"
      "/(i8,4x,a6,5e15.6))");
    FEM_DO_SAFE(k, 1, ibr) {
      wloop, k, bus(k), ci(k), ck(k), cik(k), cki(k), ckkjm(k);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' (SCONST(I), I=1, IFSEM)',/,8(1x,e15.7))");
    FEM_DO_SAFE(i, 1, cmn.ifsem) {
      wloop, sconst(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(/,' (CNVHST(I), I=1, IFX)',/,8(1x,e15.7))");
    FEM_DO_SAFE(i, 1, cmn.ifx) {
      wloop, cnvhst(i);
    }
  }
  goto statement_9800;
statement_9000:
  lstat(16) = iprint;
  kill = 1;
statement_9200:
  lastov = 12;
  nchain = 51;
  lstat(18) = 12;
statement_9800:
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
statement_99999:;
} // over12

void fdint(
  common& cmn,
  int& ikf,
  int& isfd,
  int& ibf,
  double const& omg)
{
  common_write write(cmn);
  int& it2 = cmn.it2;
  int& iprsup = cmn.iprsup;
  auto& cikfd = cmn.cikfd;
  const auto& rmfd = cmn.rmfd;
  const auto& imfd = cmn.imfd;
  const auto& voltk = static_cast<common_c0b124&>(cmn).voltk;
  const auto& volt = cmn.volt;
  //
  int idk = fem::int0;
  int isc = fem::int0;
  auto& lunit6 = cmn.lunit6;
  double cz = fem::double0;
  arr_1d<40, double> ur(fem::fill0);
  arr_1d<40, double> ui(fem::fill0);
  int ka = fem::int0;
  double ar = fem::double0;
  double ai = fem::double0;
  int i = fem::int0;
  int ist = fem::int0;
  int isu = fem::int0;
  int isv = fem::int0;
  double ar1 = fem::double0;
  double al1 = fem::double0;
  double arl = fem::double0;
  double ac1 = fem::double0;
  double azr = fem::double0;
  double azi = fem::double0;
  double den = fem::double0;
  double aur = fem::double0;
  double aui = fem::double0;
  int isk = fem::int0;
  int isw = fem::int0;
  int kb = fem::int0;
  //C     THIS ROUTINE INITIALIZES A)CAPACITOR VOLTAGES, B)BRANCH CURRENTS**M32.4338
  idk = 2 * ikf;
  ikf++;
  isc = ibf + 1;
  if (iprsup > 0) {
    write(lunit6,
      "(' INTEGER COUNTERS AT START OF FDINT......',7x,'IKF',6x,'ISFD',7x,"
      "'IBF',6x,'IZFD',6x,'IPFD',/,41x,5i10)"),
      ikf, isfd, ibf, imfd(idk + 1), imfd(idk + 2);
  }
  //C     CALCULATE MODAL VOLTAGES FROM THE PHASE VALUES   *   *   *   *   *M32.4346
  cz = it2;
  cz = 1.0f / cz;
  ur(1) = volt(1);
  ui(1) = voltk(1);
  FEM_DO_SAFE(ka, 2, it2) {
    ur(1) += volt(ka);
    ui(1) += voltk(ka);
    ur(ka) = (volt(1) - volt(ka)) * cz;
    ui(ka) = (voltk(1) - voltk(ka)) * cz;
  }
  ar = ur(1) * cz;
  ai = ui(1) * cz;
  if (iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6,
        "(1x,'MODAL VOLTAGES (SET NO.)',i5,2x,'REAL AND IMAGINARY IN PAIRS',"
        "/(2x,6e20.11))");
      wloop, ikf, ar, ai;
      FEM_DO_SAFE(i, 2, it2) {
        wloop, ur(i), ui(i);
      }
    }
  }
  //C     INITIALIZE  BRANCH  QUANTITIES   *   *   *   *   *   *   *   *   *M32.4361
  //C     PROCESS FIRST THE ZERO SEQUENCE DATA *   *   *   *   *   *   *   *M32.4362
  ist = isfd + 1;
  isu = isfd + imfd(idk + 1) * 5;
  isv = ibf;
  FEM_DOSTEP(ka, ist, isu, 5) {
    isv++;
    ar1 = rmfd(ka);
    al1 = rmfd(ka + 1) * omg;
    arl = rmfd(ka + 3);
    ac1 = rmfd(ka + 2);
    if (ac1 > 0.f) {
      ac1 = 1.f / (ac1 * omg);
    }
    azr = ar1;
    azi = al1;
    if (arl == 0.f || al1 == 0.f) {
      goto statement_4;
    }
    den = 1.0f / (arl * arl + al1 * al1);
    azr += arl * (al1 * al1) * den;
    azi = al1 * (arl * arl) * den;
  statement_4:
    azi = azi - ac1;
    //C     INVERT BRANCH IMPEDANCE TO OBTAIN ADMITTANCE *   *   *   *   *   *M32.4380
    den = 1.0f / (azr * azr + azi * azi);
    azr = azr * den;
    azi = -azi * den;
    //C     CALCULATE AND STORE BRANCH CURRENT   *   *   *   *   *   *   *   *M32.4384
    aur = ar * azr - ai * azi;
    aui = ar * azi + ai * azr;
    cikfd(isv + 1) = aur;
    //C     CALCULATE CAPACITOR VOLTAGE  *   *   *   *   *   *   *   *   *   *M32.4388
    cikfd(isv + 2) = -aui * ac1;
    isv += 2;
  }
  ibf = isv;
  isfd = isu;
  ist = isfd + 1;
  isu = isfd + imfd(idk + 2) * 5;
  isk = imfd(idk + 2) * 3;
  isv = isv - 2;
  //C     PROCESS THE REMAINING MODES  *   *   *   *   *   *   *   *   *   *M32.4398
  //C     START LOOP ACROSS ALL MODAL BRANCHES *   *   *   *   *   *   *   *M32.4399
  FEM_DOSTEP(ka, ist, isu, 5) {
    ar1 = rmfd(ka);
    al1 = rmfd(ka + 1) * omg;
    arl = rmfd(ka + 3);
    ac1 = rmfd(ka + 2);
    if (ac1 > 0.f) {
      ac1 = 1.f / (ac1 * omg);
    }
    azi = al1;
    azr = ar1;
    if (arl == 0.f || al1 == 0.f) {
      goto statement_6;
    }
    den = 1.0f / (arl * arl + al1 * al1);
    azr += arl * (al1 * al1) * den;
    azi = al1 * (arl * arl) * den;
  statement_6:
    azi = azi - ac1;
    //C     INVERT BRANCH IMPEDANCE TO OBTAIN ADMITTANCE *   *   *   *   *   *M32.4413
    den = 1.0f / (azr * azr + azi * azi);
    azr = azr * den;
    azi = -azi * den;
    //C     START THE INTERNAL LOOP ACROSS MODES *   *   *   *   *   *   *   *M32.4417
    isv += 3;
    isw = isv;
    FEM_DO_SAFE(kb, 2, it2) {
      //C     CALCULATE AND STORE BRANCH CURRENT   *   *   *   *   *   *   *   *M32.4421
      aur = ur(kb) * azr - ui(kb) * azi;
      aui = ur(kb) * azi + ui(kb) * azr;
      cikfd(isw + 1) = aur;
      //C     CALCULATE CAPACITOR VOLTAGE  *   *   *   *   *   *   *   *   *   *M32.4425
      cikfd(isw + 2) = -aui * ac1;
      isw += isk;
    }
  }
  ibf += (it2 - 1) * isk;
  isfd = isu;
  if (iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6,
        "(' ARRAY CIKFD FROM',i6,'  TO',i6,/(2x,6e21.11))");
      wloop, isc, ibf;
      FEM_DO_SAFE(ka, isc, ibf) {
        wloop, cikfd(ka);
      }
    }
  }
}

double funp13(
  double const& y,
  double const& x,
  double const& twopi)
{
  double return_value = fem::double0;
  if (x != 0.0f) {
    goto statement_101;
  }
  if (y != 0.0f) {
    goto statement_102;
  }
  return_value = 0.0f;
  goto statement_110;
statement_102:
  if (y > 0.0f) {
    goto statement_103;
  }
  return_value = -twopi / 4.f;
  goto statement_110;
statement_103:
  return_value = twopi / 4.f;
  goto statement_110;
statement_101:
  if (y != 0.0f) {
    goto statement_105;
  }
  if (x > 0.0f) {
    goto statement_104;
  }
  return_value = twopi / 2.f;
  goto statement_110;
statement_104:
  return_value = 0.0f;
  goto statement_110;
statement_105:
  return_value = std::atan2(y, x);
statement_110:
  return return_value;
}

void redu13(
  arr_ref<double> a,
  int const& n,
  int const& m)
{
  a(dimension(n * (n+1) / 2));
  int j = fem::int0;
  double w = fem::double0;
  int ij = fem::int0;
  double h1 = fem::double0;
  arr_1d<100, double> b(fem::fill0);
  int k = fem::int0;
  int ik = fem::int0;
  int i1 = fem::int0;
  int i = fem::int0;
  double h2 = fem::double0;
  int i2 = fem::int0;
  int L = fem::int0;
  //C)    THIS SUBROUTINE CAN BE USED FOR EITHER PARTIAL REDUCTION OR FOR   M29.1895
  //C)    COMPLETE INVERSION OF A REAL  N BY N  SYMMETRIC MATRIX  'A' .     M29.1896
  //C)    STORAGE FOR MATRIX ELEMENTS IS IN THE IMPLIED ORDER   (1,1),      M29.1897
  //C)    (1,2), (2,2), (1,3), (2,3), (3,3), (1,4),  ETC.,  FOR THE         M29.1898
  //C)    COMPLETE UPPER TRIANGLE.   VARIABLES  M+1, ...., N  ARE TO BE     M29.1899
  //C)    ELIMINATED (WHICH IS THE DEFINITION OF VARIABLE  'M', NOTE).      M29.1900
  //C)    RESULT IS REDUCED MATRIX IN COLUMNS 1,...M IN CASE OF REDUCTION   M29.1901
  //C)    (M UNEQUAL 0) OR NEGATIVE INVERSE MATRIX IN COLUMNS 1,...N IN CASEM29.1902
  //C)    OF INVERSION (M=0).                                               M29.1903
  j = n + 1;
  w = 1.0f;
  if (m > 0) {
    w = -w;
  }
  ij = n * j / 2;
statement_3:
  j = j - 1;
  if (j == m) {
    return;
  }
  h1 = -1.0f / a(ij);
  b(j) = h1;
  ij = ij - j;
  k = 0;
  ik = 0;
  //C                                   BEGIN K-LOOP                        M29.1916
statement_4:
  ik += k;
  i1 = ik + 1;
  k++;
  if (k > n) {
    goto statement_3;
  }
  if (k < j) {
    goto statement_9;
  }
  if (w < 0.f) {
    goto statement_3;
  }
  if (k == j) {
    goto statement_7;
  }
  i = ik + j;
statement_5:
  h2 = a(i);
  b(k) = h2 * h1;
  //C                                   BEGIN I-LOOP                        M29.1927
  i2 = ik + k;
  L = 0;
  FEM_DO_SAFE(i, i1, i2) {
    L++;
    a(i) += b(L) * h2;
  }
  if (k < j) {
    goto statement_4;
  }
  i = ik + j;
  a(i) = b(k);
  goto statement_4;
  //C                                   END I-LOOP                          M29.1937
statement_7:
  i = ij;
  FEM_DO_SAFE(L, 1, j) {
    i++;
    a(i) = b(L);
  }
  goto statement_4;
  //C                                   END K-LOOP                          M29.1943
statement_9:
  i = ij + k;
  goto statement_5;
}

void last13(
  common& cmn)
{
  common_write write(cmn);
  double& deltat = cmn.deltat;
  double& epsiln = cmn.epsiln;
  double& unity = cmn.unity;
  double& onehaf = cmn.onehaf;
  auto& flstat = cmn.flstat;
  auto& lstat = cmn.lstat;
  int& iline = cmn.iline;
  int& it2 = cmn.it2;
  int& lpast = cmn.lpast;
  int& lfdep = cmn.lfdep;
  int& ifx = cmn.ifx;
  int& lsiz26 = cmn.lsiz26;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  int& ibr = cmn.ibr;
  auto& xk = cmn.xk;
  auto& xm = cmn.xm;
  auto& con1 = cmn.con1;
  auto& sconst = cmn.sconst;
  auto& cnvhst = cmn.cnvhst;
  const auto& sfd = cmn.sfd;
  const auto& qfd = cmn.qfd;
  auto& semaux = cmn.semaux;
  const auto& c = cmn.c;
  const auto& tr = cmn.tr;
  const auto& tx = cmn.tx;
  const auto& r = static_cast<common_c0b064&>(cmn).r;
  auto& nr = cmn.nr;
  auto& length = cmn.length;
  const auto& cik = cmn.cik;
  const auto& ci = cmn.ci;
  const auto& ck = cmn.ck;
  const auto& imodel = cmn.imodel;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& cki = cmn.cki;
  auto& indhst = cmn.indhst;
  const auto& kodsem = cmn.kodsem;
  const auto& sfreq = cmn.sfreq;
  const auto& e = cmn.e;
  const auto& f = static_cast<common_c0b119&>(cmn).f;
  const auto& kssfrq = cmn.kssfrq;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;
  auto& voltk = static_cast<common_c0b124&>(cmn).voltk;
  auto& volt = cmn.volt;
  const auto& bus = cmn.bus;
  //
  int mdrive = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  int n15 = fem::int0;
  int n16 = fem::int0;
  double steady = fem::double0;
  int k = fem::int0;
  int n7 = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int n3 = fem::int0;
  int n4 = fem::int0;
  int n8 = fem::int0;
  int L = fem::int0;
  int i1 = fem::int0;
  int i2 = fem::int0;
  int i3 = fem::int0;
  int i4 = fem::int0;
  int i5 = fem::int0;
  int i6 = fem::int0;
  int i7 = fem::int0;
  int i8 = fem::int0;
  int n23 = fem::int0;
  int i10 = fem::int0;
  int i11 = fem::int0;
  double wdthaf = fem::double0;
  double w = fem::double0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  int j = fem::int0;
  int ii = fem::int0;
  int n9 = fem::int0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  double d17 = fem::double0;
  double d19 = fem::double0;
  double d20 = fem::double0;
  double d18 = fem::double0;
  double d9 = fem::double0;
  double d13 = fem::double0;
  double d10 = fem::double0;
  double d14 = fem::double0;
  double d11 = fem::double0;
  double d15 = fem::double0;
  double d12 = fem::double0;
  double d16 = fem::double0;
  int ndx1 = fem::int0;
  int iflag = fem::int0;
  int itadd = fem::int0;
  double dthaf = fem::double0;
  int mxstrt = fem::int0;
  double eeeta = fem::double0;
  int i0 = fem::int0;
  double soutk = fem::double0;
  double soutm = fem::double0;
  double trrsum = fem::double0;
  double trisum = fem::double0;
  double d1save = fem::double0;
  double d5save = fem::double0;
  int moon = 0;
  int n10 = fem::int0;
  double dxp = fem::double0;
  double dxq = fem::double0;
  double stype = fem::double0;
  double dblpr1 = fem::double0;
  double dblpr2 = fem::double0;
  double dblpr3 = fem::double0;
  double dblpr4 = fem::double0;
  double wfac = fem::double0;
  double wshz = fem::double0;
  double spole = fem::double0;
  double wpole = fem::double0;
  double resr = fem::double0;
  double resi = fem::double0;
  double tnr = fem::double0;
  double tni = fem::double0;
  double tdr = fem::double0;
  double tdi = fem::double0;
  double fac = fem::double0;
  double trr = fem::double0;
  double tri = fem::double0;
  double eoutk = fem::double0;
  double d21 = fem::double0;
  double eoutm = fem::double0;
  double tir = fem::double0;
  double tii = fem::double0;
  double d22 = fem::double0;
  int iq2 = fem::int0;
  int iq3 = fem::int0;
  static const char* format_14415 = "(' TRRSUM AND TRISUM ARE',5x,2e15.7)";
  static const char* format_14995 =
    "(/,/,5x,'(CNVHST(L), L=',i10,', ',i10,')..',/(8(1x,e15.7)))";
  static const char* format_14996 =
    "(/,/,5x,'(SCONST(L), L=',i10,', ',i10,')..',/(8(1x,e15.7)))";
  static const char* format_14997 =
    "(/,/,5x,'(XM    (L), L=',i10,', ',i10,')..',/(8(1x,e15.7)))";
  static const char* format_14998 =
    "(/,/,5x,'(XK    (L), L=',i10,', ',i10,')..',/(8(1x,e15.7)))";
  static const char* format_14999 =
    "(/,/,1x,'K = ',i5,5x,'KBUS = ',i5,5x,'MBUS = ',i5,5x,'NR = ',i5,5x,"
    "'LENGTH = ',i5,5x,'KODSEM = ',i5,/,1x,'INDHST = ',i5,5x,'KODEBR = ',i5,"
    "5x,'CI = ',f5.0,5x,'CK = ',f5.0,5x,'CIK = ',f5.0,5x,'CKI = ',f5.0)";
  //C!, VIM(1)
  //C!EQUIVALENCE    ( LSTAT(14), MDRIVE ),  ( VOLT(1), VIM(1) )
  mdrive = lstat(14);
  if (iprsup >= 1) {
    write(lunit6, "(' BEGIN MODULE \"LAST13\".')");
  }
  i = ibr + 1;
statement_610:
  i = i - 1;
  if (i <= 0) {
    goto statement_650;
  }
  if (kbus(i) >= 0 || kodsem(i) == 0) {
    goto statement_610;
  }
  if (imodel(i) == -2) {
    goto statement_610;
  }
  if (imodel(i) == -4) {
    goto statement_610;
  }
  i = i - length(i) + 1;
  n15 = fem::iabs(kbus(i));
  if (n15 == 1) {
    n15 = fem::iabs(mbus(i));
  }
  n16 = fem::iabs(kssfrq(n15));
  steady = cmn.twopi * sfreq(n16) * deltat;
  it2 = fem::iabs(kodebr(i));
  if (iprsup < 6) {
    goto statement_14009;
  }
  k = i;
  n7 = 1;
statement_14000:
  write(lunit6, format_14999), k, kbus(k), mbus(k), nr(k), length(k),
    kodsem(k), indhst(k), kodebr(k), ci(k), ck(k), cik(k), cki(k);
  n1 = fem::iabs(kodsem(k));
  n2 = fem::iabs(indhst(k));
  n3 = n1 - 1;
  n4 = n2 - 1;
  n8 = n4;
  if (n7 <= fem::iabs(kodebr(k))) {
    n8 += 6;
  }
  if (kodsem(k) > 0) {
    goto statement_14002;
  }
  n3 += 2 - ck(k) - ck(k);
  n4 += 2;
  if (ck(k) < 0.0f) {
    goto statement_14001;
  }
  n3 += 6 * ck(k);
  n4 += ck(k) - 1;
  goto statement_14005;
statement_14001:
  goto statement_14005;
statement_14002:
  n3 += 1 - ci(k) - ci(k);
  n4 += 2;
  if (ci(k) < 0.0f) {
    goto statement_14003;
  }
  n3 += 7 * ci(k);
  n4 += 2 * ci(k) - 2;
statement_14003:
  n3 = n3 - ck(k) - ck(k);
  n4 += 2;
  if (ck(k) < 0.0f) {
    goto statement_14004;
  }
  n3 += 6 * ck(k);
  n4 += 2 * ck(k) - 2;
statement_14004:
statement_14005:
  {
    write_loop wloop(cmn, lunit6, format_14996);
    wloop, n1, n3;
    FEM_DO_SAFE(L, n1, n3) {
      wloop, sconst(L);
    }
  }
  if (n8 > n4) {
    n4 = n8;
  }
  {
    write_loop wloop(cmn, lunit6, format_14995);
    wloop, n2, n4;
    FEM_DO_SAFE(L, n2, n4) {
      wloop, cnvhst(L);
    }
  }
  k++;
  n7++;
  if (cki(k - 1) > 0.0f) {
    goto statement_14000;
  }
statement_14009:
  if (indhst(i) > 0 || nr(i) < 0) {
    goto statement_14100;
  }
  //C                                                                       M23.2593
  //C  COMPUTE PHASOR TERMINAL CONDITIONS(VOLTAGE AND CURRENT) AND VOLTAGE  M23.2594
  //C  TRAVELLING WAVES(PHASE FRAME IF CIK(.) .LT. 0 ELSE MODAL).           M23.2595
  //C                                                                       M23.2596
  //C     VOLT       +J*VOLTI        KBUS TERMINAL VOLTAGE                  M23.2597
  //C     VOLTK      +J*VIM          MBUS TERMINAL VOLTAGE                  M23.2598
  //C     SEMAUX(0)  +J*SEMAUX(I1)   KBUS TERMINAL CURRENT TOWARDS MBUS     M23.2599
  //C     SEMAUX(I2) +J*SEMAUX(I3)   MBUS TERMINAL CURRENT TOWARDS KBUS     M23.2600
  //C     SEMAUX(I4) +J*SEMAUX(I5)   OUTGOING VOLTAGE TRAVELLING WAVE FROM KM23.2601
  //C     SEMAUX(I6) +J*SEMAUX(I7)   OUTGOING VOLTAGE TRAVELLING WAVE FROM MM23.2602
  //C     SEMAUX(I8) +J*SEMAUX(N23)   INCOMING VOLTAGE TRAVELLING WAVE AT K M37.4727
  //C     SEMAUX(I10)+J*SEMAUX(I11)  INCOMING VOLTAGE TRAVELLING WAVE AT M  M23.2604
  //C                                                                       M23.2605
  i1 = it2;
  i2 = i1 + it2;
  i3 = i2 + it2;
  i4 = i3 + it2;
  i5 = i4 + it2;
  i6 = i5 + it2;
  i7 = i6 + it2;
  i8 = i7 + it2;
  n23 = i8 + it2;
  i10 = n23 + it2;
  i11 = i10 + it2;
  n1 = std::abs(cik(i));
  n2 = n1 + it2 * it2;
  n3 = nr(i);
  n4 = n3 + it2 - 1;
  wdthaf = onehaf * steady;
  w = steady / deltat;
  if (cik(i) > 0.0f) {
    goto statement_14010;
  }
  move0(volt, it2);
  move0(volti, it2);
  move0(voltk, it2);
  move0(volt, lsiz26 + 1, it2);
  move0(semaux, 12 * it2);
statement_14010:
  FEM_DO_SAFE(k, 1, it2) {
    if (kodsem(i) < 0 && cik(i) < 0.0f) {
      goto statement_14060;
    }
    d1 = 0.0f;
    d2 = 0.0f;
    d3 = 0.0f;
    d4 = 0.0f;
    d5 = 0.0f;
    d6 = 0.0f;
    d7 = 0.0f;
    d8 = 0.0f;
    FEM_DO_SAFE(j, n3, n4) {
      ii = i + j - n3;
      n9 = -kbus(ii);
      d1 += qfd(n1) * e(n9) - qfd(n2) * f(n9);
      d2 += qfd(n1) * f(n9) + qfd(n2) * e(n9);
      n9 = fem::iabs(mbus(ii));
      d3 += qfd(n1) * e(n9) - qfd(n2) * f(n9);
      d4 += qfd(n1) * f(n9) + qfd(n2) * e(n9);
      d5 += sfd(n1) * tr(j) - sfd(n2) * tx(j);
      d6 += sfd(n1) * tx(j) + sfd(n2) * tr(j);
      d7 += sfd(n1) * r(j) - sfd(n2) * c(j);
      d8 += sfd(n1) * c(j) + sfd(n2) * r(j);
      n1++;
      n2++;
    }
    if (kodsem(i) < 0) {
      goto statement_14050;
    }
    ii = k + i - 1;
    n5 = -indhst(ii);
    if (ci(ii) > 0.0f) {
      n5++;
    }
    if (std::abs(w - cnvhst(n5 + 4)) < 0.0001f) {
      goto statement_14040;
    }
    n6 = -kbus(ii);
    n7 = fem::iabs(mbus(ii));
    write(lunit6,
      "(/,/,"
      "' WARNING...  STEADY STATE MODAL PARAMETERS FOR RECURSIVE-CONVOLUTION C"
      "OMPONENT CONNECTING NODES ''',a6,''' AND ''',a6,'''',/,13x,'FOR MODE ',"
      "i2,' ARE DETERMINED AT ANGULAR FREQUENCY OF ',e12.5,"
      "' RADIANS/SEC.  THE STEADY-STATE SOLUTION FREQUENCY ',/,13x,"
      "'BEING USED IS ',e12.5,' RADIANS/SEC. ')"),
      bus(n6), bus(n7), k, cnvhst(n5 + 4), w;
  statement_14040:
    d17 = fem::pow2(cnvhst(n5 + 2)) + fem::pow2(cnvhst(n5 + 3));
    d19 = (cnvhst(n5 + 2) * cnvhst(n5 + 0) + cnvhst(n5 + 3) * cnvhst(
      n5 + 1)) / d17;
    d20 = (cnvhst(n5 + 2) * cnvhst(n5 + 1) - cnvhst(n5 + 3) * cnvhst(
      n5 + 0)) / d17;
    d17 = sqrtz(d19 * d19 + d20 * d20);
    if (d19 < 0.0f) {
      goto statement_14043;
    }
    d17 = sqrtz((d19 + d17) * onehaf);
    d18 = onehaf * d20 / d17;
    goto statement_14047;
  statement_14043:
    d18 = sqrtz((-d19 + d17) * onehaf);
    if (d20 < 0.0f) {
      d18 = -d18;
    }
    d17 = onehaf * d20 / d18;
    //C  D17 + J*D18 IS THE CHARACTERISTIC IMPEDANCE OF MODE K AT SS FREQUENCYM23.2678
  statement_14047:
    d9 = onehaf * (d1 + d17 * d5 - d18 * d6);
    d13 = d1 - d9;
    d10 = onehaf * (d2 + d17 * d6 + d18 * d5);
    d14 = d2 - d10;
    d11 = onehaf * (d3 + d17 * d7 - d18 * d8);
    d15 = d3 - d11;
    d12 = onehaf * (d4 + d17 * d8 + d18 * d7);
    d16 = d4 - d12;
    if (cik(i) < 0.0f) {
      goto statement_14060;
    }
  statement_14050:
    volt(k) = d1;
    volti(k) = d2;
    voltk(k) = d3;
    ndx1 = lsiz26 + k;
    volt(ndx1) = d4;
    n6 = k;
    semaux(n6) = d5;
    n6 += it2;
    semaux(n6) = d6;
    n6 += it2;
    semaux(n6) = d7;
    n6 += it2;
    semaux(n6) = d8;
    if (kodsem(i) < 0) {
      goto statement_14080;
    }
    n6 += it2;
    semaux(n6) = d9;
    n6 += it2;
    semaux(n6) = d10;
    n6 += it2;
    semaux(n6) = d11;
    n6 += it2;
    semaux(n6) = d12;
    n6 += it2;
    semaux(n6) = d13;
    n6 += it2;
    semaux(n6) = d14;
    n6 += it2;
    semaux(n6) = d15;
    n6 += it2;
    semaux(n6) = d16;
    goto statement_14080;
  statement_14060:
    n6 = -kbus(ii);
    volt(k) = e(n9);
    volti(k) = f(n9);
    n9 = fem::iabs(mbus(ii));
    voltk(k) = e(n9);
    ndx1 = lsiz26 + k;
    volt(ndx1) = f(n9);
    n9 = n3 + k - 1;
    n6 = k;
    semaux(n6) = tr(n9);
    n6 += it2;
    semaux(n6) = tx(n9);
    n6 += it2;
    semaux(n6) = r(n9);
    n6 += it2;
    semaux(n6) = c(n9);
    if (kodsem(i) < 0) {
      goto statement_14080;
    }
    n7 = -cik(ii) + (k - 1) * it2;
    n8 += it2 * it2;
    FEM_DO_SAFE(j, 1, it2) {
      n6 = i4 + j;
      semaux(n6) += sfd(n7) * d9 - sfd(n8) * d10;
      n6 = i5 + j;
      semaux(n6) += sfd(n7) * d10 + sfd(n8) * d9;
      n6 = i6 + j;
      semaux(n6) += sfd(n7) * d11 - sfd(n8) * d12;
      n6 = i7 + j;
      semaux(n6) += sfd(n7) * d12 + sfd(n8) * d11;
      n6 = i8 + j;
      semaux(n6) += sfd(n7) * d13 - sfd(n8) * d14;
      n6 = n23 + j;
      semaux(n6) += sfd(n7) * d14 + sfd(n8) * d13;
      n6 = i10 + j;
      semaux(n6) += sfd(n7) * d15 - sfd(n8) * d16;
      n6 = i11 + j;
      semaux(n6) += sfd(n7) * d16 + sfd(n8) * d15;
      n7++;
      n8++;
    }
  statement_14080:;
  }
  if (iprsup < 6) {
    goto statement_14085;
  }
  write(lunit6,
    "(/,/,/,5x,'CHARACTERISTIC IMPEDANCE OF LAST MODE = ',e15.7,'+ J*',e15.7,"
    "/,/,5x,'MODE',6x,'K-VOLTAGE',6x,'M-VOLTAGE',6x,'K-CURRENT',6x,"
    "'M-CURRENT',7x,'K V OUT',8x,'M V OUT',9x,'K V IN',9x,'M V IN',/,/)"),
    d17, d18;
  FEM_DO_SAFE(L, 1, it2) {
    n3 = i2 + L;
    n4 = i4 + L;
    n5 = i6 + L;
    n6 = i8 + L;
    n7 = i10 + L;
    write(lunit6, "(/,6x,i2,1x,8e15.7)"), L, volt(L), voltk(L),
      semaux(L), semaux(n3), semaux(n4), semaux(n5), semaux(n6),
      semaux(n7);
    n2 = i1 + L;
    n3 = i3 + L;
    n4 = i5 + L;
    n5 = i7 + L;
    n6 = n23 + L;
    n7 = i11 + L;
    ndx1 = lsiz26 + L;
    write(lunit6, "(9x,8e15.7)"), volti(L), volt(ndx1), semaux(n2),
      semaux(n3), semaux(n4), semaux(n5), semaux(n6), semaux(n7);
  }
statement_14085:
  if (iflag == 1) {
    goto statement_14100;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(/,/,5x,"
      "'TABLE OF DISCREPANCIES BETWEEN THE RESULTS OF TIME-DOMAIN CONVOLUTION("
      "ANLAYTIC) AND STEADY-STATE PHASOR SOLUTION.',/,/,2x,' KBUS ',5x,"
      "' MBUS ',5x,'ROW',5x,'COL',7x,'KBUS VOLTAGE',8x,'MBUS VOLTAGE',8x,"
      "'KBUS CURRENT',8x,'MBUS CURRENT',/,/)");
  }
  iflag = 1;
statement_14100:
  itadd = nr(i);
  dthaf = onehaf * deltat;
  mxstrt = 0;
  k = i;
  //C  BEGIN LOOP OVER CONVOLUTIONS ....                                    M23.2793
statement_14105:
  n1 = std::abs(cki(k)) - 1;
  n2 = n1 / it2 + 1;
  n1 = n1 - (n2 - 1) * it2 + 1;
  if (itadd < 0) {
    goto statement_14290;
  }
  n3 = kodsem(k);
  n4 = fem::iabs(indhst(k));
  if (n3 > 0) {
    goto statement_14190;
  }
  n5 = ck(k);
  if (n5 >= 0) {
    goto statement_14290;
  }
  //C  ALLOCATE AND INITIALIZE PAST HISTORY OF AMETANI LUMPED ELEMENT.      M23.2803
  n5 = -n3 - n5 - n5;
  n6 = sconst(n5) / deltat + 2.0f;
  length(k) = n6;
  if (mxstrt != 0) {
    goto statement_14150;
  }
  nr(k) = iline;
  mxstrt = iline;
  iline += n6;
  if (iline <= lpast) {
    goto statement_14120;
  }
  lstat(19) = 14110;
statement_14110:
  lstat(16) = 8;
  lstat(10) = n3;
  lstat(11) = n4;
  lstat(12) = n5;
  flstat(15) = deltat;
  flstat(16) = cnvhst(n4);
  flstat(17) = sconst(n5);
  flstat(18) = sconst(n3 - 2);
  kill = 1;
  goto statement_9200;
statement_14120:
  if (indhst(k) < 0) {
    goto statement_14130;
  }
  n7 = nr(k);
  move0(xk, n7, n6 - 1);
  goto statement_14290;
statement_14130:
  d1 = volt(n2) - voltk(n2);
  ndx1 = lsiz26 + n2;
  d2 = voltk(n2) - volt(ndx1);
  FEM_DO_SAFE(j, 2, n6) {
    d3 = (j - n6) * steady;
    n8 = n7 + j;
    xk(n8) = d1 * cosz(d3) - d2 * sinz(d3);
  }
  goto statement_14290;
statement_14150:
  nr(k) = -mxstrt;
  if (iline < mxstrt + n6) {
    iline = mxstrt + n6;
  }
  mxstrt = 0;
  if (iline <= lpast) {
    goto statement_14160;
  }
  lstat(19) = 14160;
  goto statement_14110;
statement_14160:
  if (indhst(k) < 0) {
    goto statement_14170;
  }
  n7 = -nr(k);
  move0(xm, n7, n6 - 1);
  goto statement_14290;
statement_14170:
  n7 = -nr(k) - 2;
  d1 = volt(n2) - voltk(n2);
  ndx1 = lsiz26 + n2;
  d2 = voltk(n2) - volt(ndx1);
  FEM_DO_SAFE(j, 2, n6) {
    d3 = (j - n6) * steady;
    n8 = n7 + j;
    xm(n8) = d1 * cosz(d3) - d2 * sinz(d3);
  }
  goto statement_14290;
  //C  ALLOCATE AND INITIALIZE PAST HISTORY FOR PROPAGATION CONVOLUTIONS.   M23.2854
statement_14190:
  n5 = ci(k);
  switch (fem::if_arithmetic(n5)) {
  case -1: goto statement_14195;
  case  0: goto statement_14250;
  default: goto statement_14200;
  }
statement_14195:
  n3 = n3 - n5 - n5 + 1;
  n6 = sconst(n3 - 2) / deltat + 2.0f;
  goto statement_14210;
statement_14200:
  n6 = cnvhst(n4) / deltat + 2.0f;
  n3 += 5 * n5 + 1;
statement_14210:
  length(k) = n6;
  nr(k) = iline + 1;
  iline += n6 + 1;
  if (iline <= lpast) {
    goto statement_14220;
  }
  lstat(19) = 14220;
  goto statement_14110;
statement_14220:
  if (indhst(k) < 0) {
    goto statement_14230;
  }
  n7 = nr(k);
  move0(xk, n7, n6 - 1);
  move0(xm, n7, n6 - 1);
  goto statement_14250;
statement_14230:
  n7 = nr(k) - 2;
  n8 = i4 + n2;
  d1 = semaux(n8);
  n8 = i5 + n2;
  d2 = semaux(n8);
  n8 = i6 + n2;
  d3 = semaux(n8);
  n8 = i7 + n2;
  d4 = semaux(n8);
  FEM_DO_SAFE(j, 2, n6) {
    d6 = (j - n6 - 1) * steady;
    d5 = cosz(d6);
    d6 = sinz(d6);
    n8 = n7 + j;
    xk(n8) = d1 * d5 - d2 * d6;
    xm(n8) = d3 * d5 - d4 * d6;
  }
  //C  ALLOCATE AND INITIALIZE PAST HISTORY FOR CHAR. ADMITTANCE CONVOLUTIONM23.2890
statement_14250:
  n5 = ck(k);
  if (n5 >= 0) {
    goto statement_14290;
  }
  n3 = n3 - n5 - n5;
  n6 = sconst(n3 - 2) / deltat + 2.0f;
  n7 = iline;
  iline += n6;
  if (iline <= lpast) {
    goto statement_14260;
  }
  lstat(19) = 14260;
  goto statement_14110;
statement_14260:
  if (indhst(k) < 0) {
    goto statement_14270;
  }
  move0(xk, n7, n6 - 1);
  move0(xm, n7, n6 - 1);
  goto statement_14290;
statement_14270:
  n7 = n7 - 2;
  n8 = i8 + n2;
  d1 = volt(n2) - 2.0f * semaux(n8);
  n8 = n23 + n2;
  d2 = volti(n2) - 2.0f * semaux(n8);
  n8 = i10 + n2;
  d3 = voltk(n2) - 2.0f * semaux(n8);
  n8 = i11 + n2;
  ndx1 = lsiz26 + n2;
  d4 = volt(ndx1) - 2.0f * semaux(n8);
  FEM_DO_SAFE(j, 2, n6) {
    d6 = (j - n6) * steady;
    d5 = cosz(d6);
    d6 = sinz(d6);
    n8 = n7 + j;
    xk(n8) = d1 * d5 - d2 * d6;
    xm(n8) = d3 * d5 - d4 * d6;
  }
statement_14290:
  n3 = kodsem(k);
  if (n3 > 0) {
    goto statement_14430;
  }
  //C  INITIALIZE HISTORY TERM OF LUMPED ELEMENT PARALLEL CAPACITOR         M23.2923
  n5 = ck(k);
  n3 = -n3;
  sconst(n4 + 1) = sconst(n4 + 1) / dthaf;
  if (itadd < 0) {
    goto statement_14310;
  }
  eeeta = cnvhst(n4);
  if (indhst(k) < 0) {
    goto statement_14300;
  }
  cnvhst(n4) = 0.0f;
  goto statement_14310;
statement_14300:
  d1 = volt(n2) - voltk(n2);
  ndx1 = lsiz26 + n2;
  d2 = volti(n2) - volt(ndx1);
  d3 = cosz(steady);
  d4 = -sinz(steady);
  d5 = d1 * d3 - d2 * d4;
  d6 = d1 * d4 + d2 * d3;
  cnvhst(n4) = -sconst(n3 + 1) * (d5 + wdthaf * d6);
  d3 = d1 * (sconst(n3) + sconst(n3 + 1)) - cnvhst(n4);
  if (n5 >= 0) {
    goto statement_14310;
  }
  d9 = -d1 * sconst(n3 + 2) * dthaf;
statement_14310:
  switch (fem::if_arithmetic(n5)) {
  case -1: goto statement_14320;
  case  0: goto statement_14340;
  default: goto statement_14370;
  }
statement_14320:
  n5 = n3 - n5 - n5;
  n3 += 2;
  n4++;
  i0 = -1;
  moon = 1; // FEM_THROW_UNHANDLED("executable assign: assign14340tomoon");
  goto statement_14700;
  //C     ...  AMETANI INITIALIZATION  ...                                  M23.2949
statement_14340:
  if (itadd < 0 || indhst(k) >= 0) {
    goto statement_14670;
  }
  goto statement_14410;
  //C  INITIALIZE SEMLYEN LUMPED ELEMENT CONVOLUTION                        M23.2952
statement_14370:
  n3 += 2;
  n5 = n3 + 4 * (n5 - 1);
  n4++;
  moon = 11; // FEM_THROW_UNHANDLED("executable assign: assign14390tomoon");
  i0 = -1;
  goto statement_14800;
  //C     ...  SEMLYEN INITIALIZATION  ...                                  M23.2959
statement_14390:
  if (itadd < 0 || indhst(k) >= 0) {
    goto statement_14670;
  }
statement_14410:
  d4 = semaux(n2);
  d5 = -d3;
  d6 = -d4;
  n8 = i + n1 - 1;
  n7 = -kbus(n8);
  n8 = fem::iabs(mbus(n8));
  if (iprsup >= 1) {
    write(lunit6,
      "(/,2x,a6,5x,a6,5x,i2,6x,i2,46x,e15.8,5x,e15.8,/,75x,2(5x,e15.8))"),
      bus(n7), bus(n8), n1, n2, d3, d5, d4, d6;
  }
  goto statement_14670;
  //C  TRANSMISSION LINE PROPAGATION IMPULSE CONVOLUTION INITIALIZATION     M23.2973
statement_14430:
  n5 = ci(k);
  n3++;
  eeeta = cnvhst(n4);
  if (itadd < 0 || indhst(k) >= 0) {
    goto statement_14440;
  }
  n8 = i4 + n2;
  d5 = semaux(n8);
  n8 = i5 + n2;
  d6 = semaux(n8);
  n8 = i6 + n2;
  d1 = semaux(n8);
  n8 = i7 + n2;
  d2 = semaux(n8);
  d3 = 0.0f;
  d4 = 0.0f;
  n8 = i8 + n2;
  n9 = i10 + n2;
  soutk = semaux(n8);
  soutm = semaux(n9);
  trrsum = 0.0f;
  trisum = 0.0f;
  if (n5 >= 0) {
    goto statement_14440;
  }
  d9 = 0.0f;
  d10 = 0.0f;
statement_14440:
  switch (fem::if_arithmetic(n5)) {
  case -1: goto statement_14450;
  case  0: goto statement_14525;
  default: goto statement_14500;
  }
  //C  AMETANI PROPAGATION CONVOLUTION INITIALIZATION                       M23.2992
statement_14450:
  n5 = n3 - n5 - n5 - 2;
  i0 = 1;
  moon = 2; // FEM_THROW_UNHANDLED("executable assign: assign14470tomoon");
  goto statement_14700;
  //C     ...  AMETANI INITIALIZATION  ...                                  M23.2997
statement_14470:
  n3 = n5 + 2;
  goto statement_14525;
  //C  SEMLYEN PROPAGATION CONVOLUTION INITIALIZATION.                      M23.3000
statement_14500:
  n5 = n3 + 5 * n5 - 5;
  i0 = 2;
  moon = 12; // FEM_THROW_UNHANDLED("executable assign: assign14520tomoon");
  goto statement_14800;
  //C     ...  SEMLYEN INITIALIZATION  ...                                  M23.3005
statement_14520:
  n3 = n5 + 5;
statement_14525:
  if (itadd < 0 || indhst(k) >= 0) {
    goto statement_14550;
  }
  n8 = n1 + i - 1;
  n7 = -kbus(n8);
  n8 = fem::iabs(mbus(n8));
  if (iprsup >= 1) {
    write(lunit6, "(/,2x,a6,5x,a6,5x,i2,6x,i2,6x,e15.8,5x,e15.8)"),
      bus(n7), bus(n8), n1, n2, d3, d4;
  }
  //C  TRANSMISSION LINE CHARACTERISTIC ADMITTANCE CONVOLUTION INITIALIZATIOM23.3014
  if (iprsup >= 1) {
    write(lunit6, format_14415), trrsum, trisum;
  }
statement_14550:
  n5 = ck(k);
  if (itadd < 0 || indhst(k) >= 0) {
    goto statement_14560;
  }
  if (itadd != 11911) {
    goto statement_14555;
  }
  d1save = d1;
  d1 = trrsum * d1save - trisum * d2;
  d2 = trisum * d1 + trrsum * d2;
  d5save = d5;
  d5 = trrsum * d5save - trisum * d6;
  d6 = trisum * d5 + trrsum * d6;
statement_14555:
  n8 = i8 + n2;
  d1 = volt(n2) - 2.0f * semaux(n8);
  n8 = n23 + n2;
  d2 = volti(n2) - 2.0f * semaux(n8);
  n8 = i10 + n2;
  d5 = voltk(n2) - 2.0f * semaux(n8);
  n8 = i11 + n2;
  ndx1 = lsiz26 + n2;
  d6 = volt(ndx1) - 2.0f * semaux(n8);
  n8 = kodsem(k);
  d3 = sconst(n8) * d1;
  d4 = sconst(n8) * d5;
  trrsum = sconst(n8);
  trisum = 0.0f;
  n8 = i2 + n2;
  soutk = semaux(n2);
  soutm = semaux(n8);
  if (n5 >= 0) {
    goto statement_14560;
  }
  d9 = -sconst(n3 + 1) * volt(n2) * dthaf;
  d10 = -sconst(n3 + 1) * voltk(n2) * dthaf;
statement_14560:
  switch (fem::if_arithmetic(n5)) {
  case -1: goto statement_14570;
  case  0: goto statement_14580;
  default: goto statement_14610;
  }
  //C  AMETANI CHARACTERISTIC ADMITTANCE CONVOLUTION INITIALIZATION         M23.3032
statement_14570:
  n5 = n3 - n5 - n5 - 2;
  i0 = 1;
  moon = 3; // FEM_THROW_UNHANDLED("executable assign: assign14580tomoon");
  goto statement_14700;
  //C     ...  AMETANI INITIALIZATION  ...                                  M23.3037
statement_14580:
  if (itadd < 0 || indhst(k) >= 0) {
    goto statement_14670;
  }
  goto statement_14650;
  //C  SEMLYEN CHARACTERISTIC ADMITTANCE CONVOLUTION INITIALIZATION         M23.3040
statement_14610:
  n5 = n3 + 4 * (n5 - 1);
  i0 = 1;
  moon = 13; // FEM_THROW_UNHANDLED("executable assign: assign14630tomoon");
  goto statement_14800;
  //C     ...  SEMLYEN INITIALIZATION  ...                                  M23.3045
statement_14630:
  if (itadd < 0 || indhst(k) >= 0) {
    goto statement_14670;
  }
statement_14650:
  n3 = i2 + n2;
  n4 = i8 + n2;
  n5 = i10 + n2;
  if (iprsup >= 1) {
    write(lunit6, "(' ',79x,e15.8,5x,e15.8,/,35x,4(5x,e15.8))"), d3,
      d4, semaux(n4), semaux(n5), semaux(n2), semaux(n3);
  }
  if (iprsup >= 1) {
    write(lunit6, format_14415), trrsum, trisum;
  }
  //C                                                                       M23.3054
statement_14670:
  indhst(k) = fem::iabs(indhst(k));
  nr(k) = fem::iabs(nr(k));
  k++;
  if (cki(k - 1) >= 0.0f) {
    goto statement_14105;
  }
  if (iprsup < 6) {
    goto statement_610;
  }
  k = i;
  n7 = 1;
statement_14680:
  write(lunit6, format_14999), k, kbus(k), mbus(k), nr(k), length(k),
    kodsem(k), indhst(k), kodebr(k), ci(k), ck(k), cik(k), cki(k);
  n1 = fem::iabs(kodsem(k));
  n2 = fem::iabs(indhst(k));
  n3 = n1 - 1;
  n4 = n2 - 1;
  n8 = n4;
  if (n7 <= fem::iabs(kodebr(k))) {
    n8 += 6;
  }
  if (kodsem(k) > 0) {
    goto statement_14682;
  }
  n3 += 2 - ck(k) - ck(k);
  n4 += 2;
  if (ck(k) < 0.0f) {
    goto statement_14681;
  }
  n3 += 6 * ck(k);
  n4 += ck(k) - 1;
  goto statement_14685;
statement_14681:
  n5 = nr(k);
  n6 += n5 + length(k) - 1;
  if (nr(k) > 0) {
    {
      write_loop wloop(cmn, lunit6, format_14998);
      wloop, n5, n6;
      FEM_DO_SAFE(L, n5, n6) {
        wloop, xk(L);
      }
    }
  }
  if (nr(k) < 0) {
    {
      write_loop wloop(cmn, lunit6, format_14997);
      wloop, n5, n6;
      FEM_DO_SAFE(L, n5, n6) {
        wloop, xm(L);
      }
    }
  }
  goto statement_14685;
statement_14682:
  n3 += 1 - ci(k) - ci(k);
  n4 += 2;
  if (ci(k) < 0.0f) {
    goto statement_14683;
  }
  n3 += 7 * ci(k);
  n4 += 2 * ci(k) - 2;
statement_14683:
  n3 = n3 - ck(k) - ck(k);
  n4 += 2;
  if (ck(k) < 0.0f) {
    goto statement_14684;
  }
  n3 += 6 * ck(k);
  n4 += 2 * ck(k) - 2;
statement_14684:
  n5 = nr(k);
  n6 = n5 + length(k) - 1;
  if (ck(k) < 0.0f) {
    n6 += sconst(n3 - 1) / deltat + 2.0f;
  }
  {
    write_loop wloop(cmn, lunit6, format_14998);
    wloop, n5, n6;
    FEM_DO_SAFE(L, n5, n6) {
      wloop, xk(L);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_14997);
    wloop, n5, n6;
    FEM_DO_SAFE(L, n5, n6) {
      wloop, xm(L);
    }
  }
statement_14685:
  {
    write_loop wloop(cmn, lunit6, format_14996);
    wloop, n1, n3;
    FEM_DO_SAFE(L, n1, n3) {
      wloop, sconst(L);
    }
  }
  if (n8 > n4) {
    n4 = n8;
  }
  {
    write_loop wloop(cmn, lunit6, format_14995);
    wloop, n2, n4;
    FEM_DO_SAFE(L, n2, n4) {
      wloop, cnvhst(L);
    }
  }
  k++;
  n7++;
  if (cki(k - 1) > 0.0f) {
    goto statement_14680;
  }
  goto statement_610;
  //C  AMETANI PIECEWISE-LINEAR CONVOLUTION INITIALIZATION                  M23.3115
statement_14700:
  if (itadd < 0 || indhst(k) >= 0) {
    goto statement_14710;
  }
  d1 = d1 / wdthaf;
  d2 = d2 / wdthaf;
  if (i0 < 0) {
    goto statement_14710;
  }
  d5 = d5 / wdthaf;
  d6 = d6 / wdthaf;
statement_14710:
  FEM_DOSTEP(j, n3, n5, 2) {
    d15 = dthaf * sconst(j + 1);
    if (kodebr(k) > 0) {
      sconst(j + 1) = d15;
    }
    if (itadd < 0 || indhst(k) >= 0) {
      goto statement_14730;
    }
    d8 = w * sconst(j);
    d7 = cosz(d8);
    d8 = sinz(d8);
    if (j == n3) {
      goto statement_14720;
    }
    d11 = d16 * (d1 * (d8 - d14) - d2 * (d7 - d13));
    d3 += d11;
    d9 += d11;
    if (i0 < 0) {
      goto statement_14720;
    }
    d12 = d16 * (d5 * (d8 - d14) - d6 * (d7 - d13));
    d4 += d12;
    d10 += d12;
  statement_14720:
    d13 = d7;
    d14 = d8;
    d16 = d15;
  statement_14730:;
  }
  if (itadd < 0) {
    goto statement_14750;
  }
  if (indhst(k) <= 0) {
    goto statement_14740;
  }
  cnvhst(n4) = 0.0f;
  n4++;
  if (i0 < 0) {
    goto statement_14750;
  }
  cnvhst(n4) = 0.0f;
  n4++;
  goto statement_14750;
statement_14740:
  d8 = w * cmn.tmax;
  d7 = cosz(d8);
  d8 = sinz(d8);
  d11 = d16 * (d1 * (d8 - d14) - d2 * (d7 - d13));
  d3 += d11;
  cnvhst(n4) = d9 + d11;
  n4++;
  if (i0 < 0) {
    goto statement_14750;
  }
  d12 = d16 * (d5 * (d8 - d14) - d6 * (d7 - d13));
  d4 += d12;
  cnvhst(n4) = d10 + d12;
  n4++;
statement_14750:
  switch (moon) {
  case 1: goto statement_14340;
  case 2: goto statement_14470;
  case 3: goto statement_14580;
  default: break;
  }
  //C  SEMLYEN EXPONENTIAL CONVOLUTION INITIALIZATION                       M23.3162
statement_14800:
  n10 = 4;
  dxp = 1.0f;
  dxq = 0.0f;
  if (fem::iabs(i0) <= 1) {
    goto statement_14810;
  }
  d7 = eeeta / deltat;
  n7 = d7;
  dxq = d7 - n7;
  dxp = unity - dxq;
  n10 = 5;
  if (itadd < 0 || indhst(k) >= 0) {
    goto statement_14810;
  }
  d8 = w * eeeta;
  d7 = cosz(d8);
  d8 = -sinz(d8);
  d9 = d1 * d7 - d2 * d8;
  d2 = d1 * d8 + d2 * d7;
  d1 = d9;
  if (i0 < 0) {
    goto statement_14810;
  }
  d9 = d5 * d7 - d6 * d8;
  d6 = d5 * d8 + d6 * d7;
  d5 = d9;
  if (iprsup >= 1) {
    write(lunit6,
      "(' VALUES OF D1,D2,D5,D6 BEFORE DO 14940 LOOP',4e17.8)"), d1,
      d2, d5, d6;
  }
statement_14810:
  FEM_DOSTEP(j, n3, n5, n10) {
    stype = sconst(j);
    switch (fem::if_arithmetic(stype)) {
    case -1: goto statement_14940;
    case  0: goto statement_14820;
    default: goto statement_14830;
    }
  statement_14820:
    d7 = sconst(j + 1);
    d8 = 0.0f;
    d11 = sconst(j + 2);
    d12 = 0.0f;
    if (d7 != 0.0f) {
      goto statement_14826;
    }
    sconst(j + 2) = dxp * d11;
    sconst(j + 3) = dxq * d11;
    if (i0 == 2) {
      sconst(j + 4) = 0.0f;
    }
    cnvhst(n4) = 0.0f;
    cnvhst(n4 + 1) = 0.0f;
    n4 += 2;
    if (indhst(k) >= 0) {
      goto statement_14940;
    }
    cnvhst(n4 - 2) = d1 * d11;
    d3 += d1 * d11;
    cnvhst(n4 - 1) = d5 * d11;
    d4 += d5 * d11;
    goto statement_14940;
  statement_14826:
    d9 = d11 * d7;
    d10 = 0.0f;
    goto statement_14840;
  statement_14830:
    n9 = j + n10;
    d7 = sconst(j + 1);
    d8 = sconst(n9 + 1);
    d11 = sconst(j + 2);
    d12 = sconst(n9 + 2);
    d9 = d11 * d7 - d12 * d8;
    d10 = d11 * d8 + d12 * d7;
    //C                                                                       M44. 619
  statement_14840:
    d13 = deltat * d7;
    d14 = deltat * d8;
    if (d13 * d13 + d14 * d14 > 0.0001f) {
      goto statement_14880;
    }
    //C                                                                       M44. 620
    n6 = 0;
    n8 = 1;
    d20 = epsiln * epsiln;
    dblpr1 = 0.0f;
    dblpr2 = 0.0f;
    dblpr3 = 0.0f;
    dblpr4 = 0.0f;
    d15 = -unity;
    d16 = 0.0f;
  statement_14850:
    n6++;
    if (n6 < 15) {
      goto statement_14870;
    }
    n8 = i + n1 - 1;
    n7 = -kbus(n8);
    n8 = fem::iabs(mbus(n8));
    write(lunit6,
      "(/,/,"
      "' WARNING...  THE TAYLOR''S SERIES USED TO CLACULATE THE SEMLYEN CONVOL"
      "UTION COEFFIECIENT CONNECTED BETWEEN ''',a6,''' AND ''',a6,'''',/,13x,"
      "'HAS FAILED TO CONVERGE.  THE MATRIX ENTRY IS (',i2,',',i2,'), TYPE ',"
      "i2,'.  RELATIVE ERROR IS ',e15.8,' AND ',e12.5,'.',/,13x,"
      "'THE CONVERGENCE TOLLERANCE IS ',e12.5,"
      "'.  COMPUTATION WILL CONTINUE USING THE ''DEXPZ/DSINZ/DCOSZ'' ROUTINES."
      " ')"),
      bus(n7), bus(n8), n1, n2, i0, d17, d18, cmn.flzero;
    goto statement_14880;
  statement_14870:
    n7 = n8;
    n8 = n8 * (n6 + 1);
    d17 = -d15 * d13 + d16 * d14;
    d16 = -d15 * d14 - d16 * d13;
    d15 = d17;
    d17 = d15 / n8;
    d18 = d16 / n8;
    dblpr1 += d17;
    dblpr2 += d18;
    d17 = (d17 * d17 + d18 * d18) / (dblpr1 * dblpr1 + dblpr2 * dblpr2);
    d18 = n8 - n7;
    d18 = d18 / n8 / n7;
    d19 = d15 * d18;
    d18 = d16 * d18;
    dblpr3 += d19;
    dblpr4 += d18;
    d18 = (d19 * d19 + d18 * d18) / (dblpr3 * dblpr3 + dblpr4 * dblpr4);
    if (d18 > d20 || d17 > d20) {
      goto statement_14850;
    }
    d15 = d11 * dblpr1 - d12 * dblpr2;
    d16 = d11 * dblpr2 + d12 * dblpr1;
    if (kodebr(k) < 0) {
      goto statement_14890;
    }
    d13 = expz(-d13);
    sconst(j + 1) = d13 * cosz(d14);
    sconst(j + 2) = d15;
    sconst(j + 3) = d11 * dblpr3 - d12 * dblpr4;
    if (stype <= 0.0f) {
      goto statement_14890;
    }
    sconst(n9 + 1) = -d13 * sinz(d14);
    sconst(n9 + 2) = d16;
    sconst(n9 + 3) = d11 * dblpr4 + d12 * dblpr3;
    goto statement_14890;
  statement_14880:
    dblpr1 = -d13;
    //dexpz(dblpr1, dblpr2);
    dblpr2 = std::exp(dblpr1);
    dblpr1 = -d14;
    dcosz(dblpr1, dblpr3);
    dsinz(dblpr1, dblpr4);
    dblpr1 = dblpr2 * dblpr3;
    dblpr2 = dblpr2 * dblpr4;
    d17 = d13 * d13 + d14 * d14;
    dblpr3 = ((unity - dblpr1) * d13 - dblpr2 * d14) / d17;
    dblpr4 = (-(unity - dblpr1) * d14 - dblpr2 * d13) / d17;
    d15 = d11 * (unity - dblpr3) + d12 * dblpr4;
    d16 = -d11 * dblpr4 + d12 * (unity - dblpr3);
    if (kodebr(k) < 0) {
      goto statement_14890;
    }
    sconst(j + 1) = dblpr1;
    sconst(j + 2) = d15;
    sconst(j + 3) = d11 * (dblpr3 - dblpr1) - d12 * (dblpr4 - dblpr2);
    if (stype <= 0.0f) {
      goto statement_14890;
    }
    sconst(n9 + 1) = dblpr2;
    sconst(n9 + 2) = d16;
    sconst(n9 + 3) = d11 * (dblpr4 - dblpr2) + d12 * (dblpr3 - dblpr1);
  statement_14890:
    if (fem::iabs(i0) > 1) {
      goto statement_14895;
    }
    if (i0 > 0) {
      goto statement_14893;
    }
    cnvhst(n4 + 0) = d15 * (volt(n2) - voltk(n2));
    if (stype <= 0.0f) {
      goto statement_14900;
    }
    cnvhst(n4 + 1) = d16 * (volt(n2) - voltk(n2));
    goto statement_14900;
  statement_14893:
    cnvhst(n4 + 0) = d15 * volt(n2);
    cnvhst(n4 + 1) = d15 * voltk(n2);
    if (stype <= 0.0f) {
      goto statement_14900;
    }
    cnvhst(n4 + 2) = d16 * volt(n2);
    cnvhst(n4 + 3) = d16 * voltk(n2);
    goto statement_14900;
  statement_14895:
    cnvhst(n4 + 0) = 0.0f;
    cnvhst(n4 + 1) = 0.0f;
    if (kodebr(k) < 0) {
      goto statement_14897;
    }
    d16 = sconst(j + 2);
    d17 = sconst(j + 3);
    sconst(j + 2) = dxp * d16;
    sconst(j + 3) = dxq * d16 + dxp * d17;
    sconst(j + 4) = dxq * d17;
  statement_14897:
    if (stype <= 0.0f) {
      goto statement_14900;
    }
    cnvhst(n4 + 2) = 0.0f;
    cnvhst(n4 + 3) = 0.0f;
    if (kodebr(k) < 0) {
      goto statement_14900;
    }
    d16 = sconst(n9 + 2);
    d17 = sconst(n9 + 3);
    sconst(n9 + 2) = dxp * d16;
    sconst(n9 + 3) = dxq * d16 + dxp * d17;
    sconst(n9 + 4) = dxq * d17;
  statement_14900:
    if (itadd < 0) {
      goto statement_14940;
    }
    if (indhst(k) < 0) {
      goto statement_14920;
    }
    cnvhst(n4) = 0.0f;
    n4++;
    if (i0 < 0) {
      goto statement_14910;
    }
    cnvhst(n4) = 0.0f;
    n4++;
  statement_14910:
    if (stype <= 0.0f) {
      goto statement_14940;
    }
    cnvhst(n4) = 0.0f;
    n4++;
    if (i0 < 0) {
      goto statement_14940;
    }
    cnvhst(n4) = 0.0f;
    n4++;
    goto statement_14940;
  statement_14920:
    wfac = cmn.tenm6;
    wshz = w * wfac;
    spole = d7 * wfac;
    wpole = -d8 * wfac;
    resr = d9 * wfac;
    resi = d10 * wfac;
    tnr = resr * spole - resi * wpole;
    tni = resr * wshz;
    tdr = spole * spole + wpole * wpole - wshz * wshz;
    tdi = 2.f * spole * wshz;
    fac = 1.f / (tdr * tdr + tdi * tdi);
    tdr = tdr * fac;
    tdi = tdi * fac;
    trr = tdr * tnr + tdi * tni;
    tri = tdr * tni - tdi * tnr;
    trrsum += trr;
    trisum += tri;
    d15 = trr * d1 - tri * d2;
    if (iprsup >= 1) {
      write(lunit6,
        "(' VALUES OF D3,TRR,TRI,D15 BEFORE D3 UPDATE',4e17.8)"), d3,
        trr, tri, d15;
    }
    d3 += d15;
    if (j < n5 || stype > 0.0f) {
      goto statement_14924;
    }
    eoutk = d3 - soutk;
    d3 = soutk;
    d15 = d15 - eoutk;
    if (iprsup >= 1) {
      write(lunit6,
        "(' D15 RESET TO ',e15.8,' TO CORRECT OUTPUT K ERROR = ',e15.8)"),
        d15, eoutk;
    }
  statement_14924:
    cnvhst(n4) = d15 - cnvhst(n4);
    n4++;
    if (i0 < 0) {
      goto statement_14930;
    }
    d21 = trr * d5 - tri * d6;
    if (iprsup >= 1) {
      write(lunit6,
        "(' VALUES OF D4,TRR,TRI,D21 BEFORE D4 UPDATE',4e17.8)"), d4,
        trr, tri, d21;
    }
    d4 += d21;
    if (j < n5 || stype > 0.0f) {
      goto statement_14928;
    }
    eoutm = d4 - soutm;
    d4 = soutm;
    d21 = d21 - eoutm;
    if (iprsup >= 1) {
      write(lunit6,
        "(' D21 RESET TO ',e15.8,' TO CORRECT OUTPUT M ERROR = ',e15.8)"),
        d21, eoutm;
    }
  statement_14928:
    cnvhst(n4) = d21 - cnvhst(n4);
    n4++;
  statement_14930:
    if (stype <= 0.0f) {
      goto statement_14940;
    }
    trrsum += trr;
    trisum += tri;
    d3 += d15;
    tnr = resi * spole + resr * wpole;
    tni = resi * wshz;
    tir = tdr * tnr + tdi * tni;
    tii = tdr * tni - tdi * tnr;
    d16 = tir * d1 + tii * d2;
    if (iprsup >= 1) {
      write(lunit6,
        "(' VALUES OF D16,TIR,TII,D16 BEFORE D16 UPDATE',4e17.8)"),
        d16, tir, tii, d16;
    }
    cnvhst(n4) = d16 - cnvhst(n4);
    n4++;
    if (i0 < 0) {
      goto statement_14940;
    }
    d4 += d21;
    d22 = tir * d5 + tii * d6;
    cnvhst(n4) = d22 - cnvhst(n4);
    n4++;
  statement_14940:;
  }
  switch (moon) {
  case 11: goto statement_14390;
  case 12: goto statement_14520;
  case 13: goto statement_14630;
  default: break;
  }
statement_650:
  k = 2 * cmn.ifdep;
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6, "(/,' (KODSEM(I), I=1, IBR)',/(1x,10i10))");
      FEM_DO_SAFE(i, 1, ibr) {
        wloop, kodsem(i);
      }
    }
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (CNVHST(I), I=1, IFX)',/(1x,8e16.6))");
      FEM_DO_SAFE(i, 1, ifx) {
        wloop, cnvhst(i);
      }
    }
  }
  lstat(28) = iline - 1;
  lstat(42) = ifx;
  i = 0;
  if (k <= 0) {
    goto statement_6679;
  }
  if (iprsup <= 0) {
    goto statement_6675;
  }
  write(lunit6,
    "(/,' EXPONENTIAL-TAIL CONSTANTS READY FOR DELTAT-LOOP CONVOLUTION, AT END"
    "  ''OVER13'' .',/,10x,'I',13x,'CON1(I)',13x,'CON2(I)',13x,'CON3(I)')");
statement_6675:
  i++;
  iq2 = 2 * lfdep + i;
  iq3 = 4 * lfdep + i;
  if (i > k) {
    goto statement_6679;
  }
  d3 = con1(i);
  d4 = con1(iq2);
  d5 = con1(iq3);
  if (d5 == 0.0f) {
    goto statement_2314;
  }
  d6 = d4 * deltat;
  d1 = expz(-d6);
  d6 = (d1 - 1.0f) / d6;
  d2 = d3 / d4;
  con1(i) = d2 * (1.0f + d6);
  con1(iq2) = -d2 * (d6 + d1);
  con1(iq3) = d1;
statement_2314:
  if (iprsup >= 2) {
    write(lunit6, "(1x,i10,3e20.11)"), i, con1(i), con1(iq2), con1(iq3);
  }
  goto statement_6675;
statement_6679:
  lstat(35) = cmn.iftail;
  if (iprsup >= 1) {
    write(lunit6, "(' AT 4568.')");
  }
  if (cmn.numsm > 0) {
    goto statement_9200;
  }
  if (cmn.kconst > 0) {
    goto statement_9200;
  }
  if (mdrive > 0) {
    goto statement_9200;
  }
  kill = 191;
  lstat(19) = 1423;
statement_9200:
  if (iprsup >= 1) {
    write(lunit6,
      "(' EXIT  MODULE \"LAST13\".  KILL, LSTAT(19) =',2i8)"), kill,
      lstat(19);
  }
}

void breqiv(
  common& cmn,
  int& ikf,
  int& isfd,
  int& ibf)
{
  common_write write(cmn);
  double& delta2 = cmn.delta2;
  int& it2 = cmn.it2;
  int& iprsup = cmn.iprsup;
  auto& rmfd = cmn.rmfd;
  auto& cikfd = cmn.cikfd;
  const auto& imfd = cmn.imfd;
  const auto& volt = cmn.volt;
  //
  int idk = fem::int0;
  int isc = fem::int0;
  int isf = fem::int0;
  auto& lunit6 = cmn.lunit6;
  double cz = fem::double0;
  arr_1d<40, double> ur(fem::fill0);
  int ka = fem::int0;
  double ar = fem::double0;
  int ist = fem::int0;
  int isk = fem::int0;
  int isv = fem::int0;
  double al1 = fem::double0;
  double ar1 = fem::double0;
  double ac1 = fem::double0;
  double arl = fem::double0;
  double a2 = fem::double0;
  double a1 = fem::double0;
  double azr = fem::double0;
  double azi = fem::double0;
  int isu = fem::int0;
  int isw = fem::int0;
  int kb = fem::int0;
  //C     THIS ROUTINE PRODUCES COMPANION MODEL FOR EACH BRANCH. IT ALSO    M32.4596
  //C     INITIALIZES THE CURRENT INJECTIONS FOR THE BRANCHES  *   *   *   *M32.4597
  idk = ikf * 2;
  ikf++;
  isc = ibf + 1;
  isf = isfd + 1;
  if (iprsup > 0) {
    write(lunit6,
      "(' INTEGER COUNTERS AT START OF BREQIV.....',7x,'IKF',6x,'ISFD',7x,"
      "'IBF',6x,'IZFD',6x,'IPFD',/,41x,5i10)"),
      ikf, isfd, ibf, imfd(idk + 1), imfd(idk + 2);
  }
  //C     CALCULATE MODAL VOLTAGES FROM PHASE VALUES   *   *   *   *   *   *M32.4606
  cz = it2;
  cz = 1.0f / cz;
  ur(1) = volt(1);
  FEM_DO_SAFE(ka, 2, it2) {
    ur(1) += volt(ka);
    ur(ka) = (volt(1) - volt(ka)) * cz;
  }
  ar = ur(1) * cz;
  if (iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6,
        "(' MODAL VOLTAGES IN BREQIV',/(2x,6e21.12))");
      wloop, ar;
      FEM_DO_SAFE(ka, 2, it2) {
        wloop, ur(ka);
      }
    }
  }
  //C     PROCESS 'ZERO' SEQUENCE INFORMATION FIRST    *   *   *   *   *   *M32.4616
  ist = isfd + 1;
  isk = imfd(idk + 1);
  isfd += isk * 5;
  isv = ibf - 2;
  FEM_DOSTEP(ka, ist, isfd, 5) {
    isv += 3;
    al1 = rmfd(ka + 1) / delta2;
    ar1 = rmfd(ka);
    ac1 = rmfd(ka + 2);
    arl = rmfd(ka + 3);
    if (ac1 > 0) {
      ac1 = delta2 / ac1;
    }
    a2 = 0.f;
    a1 = al1;
    if (al1 == 0.f || arl == 0.f) {
      goto statement_4;
    }
    a1 = (al1 * arl) / (arl + al1);
    a2 = 2.f * a1 / arl;
  statement_4:
    azr = 1.f / (ar1 + a1 + ac1);
    azi = (ar1 - a1 + ac1) * azr;
    cikfd(isv) = -cikfd(isv + 1) + azr * ar;
    //C     STORE CONSTANTS FOR LATER USE IN THE TIME-STEP LOOP  *   *   *   *M32.4636
    rmfd(ka + 1) = azr;
    rmfd(ka + 2) = ac1;
    rmfd(ka + 3) = azi;
    rmfd(ka + 4) = a2;
  }
  //C     PROCESS THE REMAINING MODES  *   *   *   *   *   *   *   *   *   *M32.4642
  ibf = isv + 2;
  ist = isfd + 1;
  isk = imfd(idk + 2);
  isu = isfd + isk * 5;
  isk = isk * 3;
  //C     LOOP ACROSS ALL 'POSITIVE' SEQUENCE BRANCHES *   *   *   *   *   *M32.4648
  FEM_DOSTEP(ka, ist, isu, 5) {
    al1 = rmfd(ka + 1) / delta2;
    ar1 = rmfd(ka);
    arl = rmfd(ka + 3);
    ac1 = rmfd(ka + 2);
    if (ac1 > 0.f) {
      ac1 = delta2 / ac1;
    }
    a2 = 0.f;
    a1 = al1;
    if (arl == 0.f || al1 == 0.f) {
      goto statement_6;
    }
    a1 = (al1 * arl) / (al1 + arl);
    a2 = 2.f * a1 / arl;
  statement_6:
    azr = 1.f / (ar1 + a1 + ac1);
    azi = (ar1 - a1 + ac1) * azr;
    //C     INTERNAL LOOP ACROSS THE REMAINING ( IT2 - 1 ) MODES *   *   *   *M32.4662
    isv += 3;
    isw = isv - isk;
    FEM_DO_SAFE(kb, 2, it2) {
      isw += isk;
      cikfd(isw) = -cikfd(isw + 1) + azr * ur(kb);
    }
    //C     STORE CONSTANTS FOR LATER USE IN THE TIME-STEP LOOP  *   *   *   *M32.4668
    rmfd(ka + 1) = azr;
    rmfd(ka + 3) = azi;
    rmfd(ka + 2) = ac1;
    rmfd(ka + 4) = a2;
  }
  ibf += (it2 - 1) * isk;
  isfd = isu;
  if (iprsup < 1) {
    goto statement_15;
  }
  write(lunit6, "(' ARRAYS FOR BRANCH SET NO.',i6,'  AT END OF BREQIV')"), ikf;
  {
    write_loop wloop(cmn, lunit6,
      "(' ARRAY RMFD FROM',i6,'  TO',i6,/(2x,6e21.11))");
    wloop, isf, isfd;
    FEM_DO_SAFE(ka, isf, isfd) {
      wloop, rmfd(ka);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(' ARRAY CIKFD FROM',i6,'  TO',i6,/(2x,6e21.11))");
    wloop, isc, ibf;
    FEM_DO_SAFE(ka, isc, ibf) {
      wloop, cikfd(ka);
    }
  }
statement_15:;
}


struct over13_save
{
  fem::str<8> text1;
  fem::str<8> text2;

  over13_save() :
    text1(fem::char0),
    text2(fem::char0)
  {}
};

// SETUP INITIAL CONDITIONS ON LUMPED ELEMENTS, AND PAST        
// HISTORY FOR DISTRIBUTED LINES.                               
void over13(
  common& cmn)
{
  FEM_CMN_SVE(over13);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  const auto& texta6 = cmn.texta6;
  const auto& abuff = cmn.abuff;
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  double& deltat = cmn.deltat;
  double& delta2 = cmn.delta2;
  double& epsiln = cmn.epsiln;
  auto& twopi = cmn.twopi;
  double& omega = cmn.omega;
  double& flzero = cmn.flzero;
  auto& flstat = cmn.flstat;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  int& iline = cmn.iline;
  int& inonl = cmn.inonl;
  int& it1 = cmn.it1;
  int& it2 = cmn.it2;
  int& istead = cmn.istead;
  int& lymat = cmn.lymat;
  int& lpast = cmn.lpast;
  int& ltails = cmn.ltails;
  int& lfdep = cmn.lfdep;
  int& iv = cmn.iv;
  int& lastov = cmn.lastov;
  int& lhist = cmn.lhist;
  int& noutpr = cmn.noutpr;
  int& lsiz26 = cmn.lsiz26;
  int& ifdep2 = cmn.ifdep2;
  int& iftail = cmn.iftail;
  int& kill = cmn.kill;
  int& ivolt = cmn.ivolt;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& it = cmn.it;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  auto& x = static_cast<common_c0b001&>(cmn).x;
  auto& ykm = cmn.ykm;
  auto& xk = cmn.xk;
  auto& xm = cmn.xm;
  const auto& con1 = cmn.con1;
  const auto& eta = cmn.eta;
  auto& stailm = cmn.stailm;
  auto& stailk = cmn.stailk;
  auto& sconst = cmn.sconst;
  auto& cnvhst = cmn.cnvhst;
  auto& sfd = cmn.sfd;
  auto& qfd = cmn.qfd;
  auto& semaux = cmn.semaux;
  auto& crit = cmn.crit;
  auto& energy = cmn.energy;
  const auto& nonlad = cmn.nonlad;
  const auto& nonle = cmn.nonle;
  auto& vnonl = cmn.vnonl;
  auto& curr = cmn.curr;
  auto& anonl = cmn.anonl;
  const auto& vecnl1 = cmn.vecnl1;
  const auto& vzer5 = cmn.vzer5;
  const auto& ilast = cmn.ilast;
  const auto& nltype = cmn.nltype;
  auto& cchar = cmn.cchar;
  auto& vchar = cmn.vchar;
  auto& gslope = cmn.gslope;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& r = static_cast<common_c0b064&>(cmn).r;
  auto& nr = cmn.nr;
  const auto& length = cmn.length;
  auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  auto& ck = cmn.ck;
  const auto& nonlk = cmn.nonlk;
  const auto& nonlm = cmn.nonlm;
  const auto& litype = cmn.litype;
  const auto& imodel = cmn.imodel;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& cki = cmn.cki;
  const auto& ckkjm = cmn.ckkjm;
  auto& indhst = cmn.indhst;
  const auto& kodsem = cmn.kodsem;
  const auto& namebr = cmn.namebr;
  const auto& sfreq = cmn.sfreq;
  const auto& kmswit = cmn.kmswit;
  auto& nextsw = cmn.nextsw;
  auto& tclose = cmn.tclose;
  auto& adelay = cmn.adelay;
  auto& kpos = cmn.kpos;
  auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  const auto& kssfrq = cmn.kssfrq;
  auto& kode = cmn.kode;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;
  auto& voltk = static_cast<common_c0b124&>(cmn).voltk;
  auto& volt = cmn.volt;
  const auto& bus = cmn.bus;
  int& koff20 = cmn.koff20;
  int& koff24 = cmn.koff24;
  int& koff25 = cmn.koff25;
  int& inoff1 = cmn.inoff1;
  int& inoff2 = cmn.inoff2;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  if (is_called_first_time) {
    text1 = "PARAME";
    text2 = "TERS  ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int jglnn = fem::int0;
  int isecti = fem::int0;
  int ll0 = fem::int0;
  int kcbl = fem::int0;
  int kmode = fem::int0;
  int ll1 = fem::int0;
  int marti = fem::int0;
  int ibf = fem::int0;
  int ikf = fem::int0;
  int isfd = fem::int0;
  double fzero = fem::double0;
  int i = fem::int0;
  int L = fem::int0;
  int k = fem::int0;
  int itadd = fem::int0;
  int jpl = fem::int0;
  int kv = fem::int0;
  double phs2 = fem::double0;
  int j = fem::int0;
  int n15 = fem::int0;
  int n16 = fem::int0;
  double steady = fem::double0;
  int m = fem::int0;
  int ibadd = fem::int0;
  double d6 = fem::double0;
  int n4 = fem::int0;
  int j0 = fem::int0;
  int ipp = fem::int0;
  int n11 = fem::int0;
  int n10 = fem::int0;
  int n12 = fem::int0;
  double d12 = fem::double0;
  int n13 = fem::int0;
  double d13 = fem::double0;
  double d14 = fem::double0;
  int n18 = fem::int0;
  int n19 = fem::int0;
  int n14 = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  double d9 = fem::double0;
  int n8 = fem::int0;
  int iprint = fem::int0;
  double d11 = fem::double0;
  int ll = fem::int0;
  double a = fem::double0;
  double d1 = fem::double0;
  double tpi = fem::double0;
  double winic = fem::double0;
  double d2 = fem::double0;
  double d7 = fem::double0;
  int n3 = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int nkp = fem::int0;
  double omg = fem::double0;
  int n17 = fem::int0;
  int n20 = fem::int0;
  double vr1 = fem::double0;
  double curr1 = fem::double0;
  int isd = fem::int0;
  double curi1 = fem::double0;
  double curr2 = fem::double0;
  double curi2 = fem::double0;
  double aph = fem::double0;
  int nl = fem::int0;
  int n5 = fem::int0;
  int iy = fem::int0;
  int iz = fem::int0;
  double wdt = fem::double0;
  double omegs1 = fem::double0;
  int nrz = fem::int0;
  int nra = fem::int0;
  int ivbr = fem::int0;
  int ns1 = fem::int0;
  int nk1 = fem::int0;
  int nn17 = fem::int0;
  int nn5 = fem::int0;
  double phf = fem::double0;
  double hf = fem::double0;
  int ioff1 = fem::int0;
  int ioff2 = fem::int0;
  int ioff3 = fem::int0;
  int ioff4 = fem::int0;
  int ioff5 = fem::int0;
  int ioff6 = fem::int0;
  int ioff7 = fem::int0;
  int ioff8 = fem::int0;
  int koff11 = fem::int0;
  int nq1 = fem::int0;
  int nphs2 = fem::int0;
  int kqvq = fem::int0;
  int kqv = fem::int0;
  int iq = fem::int0;
  int nteq = fem::int0;
  int lq = fem::int0;
  int nq2 = fem::int0;
  int nq3 = fem::int0;
  double d = fem::double0;
  int jkl = fem::int0;
  double akr = fem::double0;
  double aki = fem::double0;
  double apr = fem::double0;
  double api = fem::double0;
  double dqq3 = fem::double0;
  double ddd3 = fem::double0;
  double ddd4 = fem::double0;
  int j1 = fem::int0;
  int jadd = fem::int0;
  int icbr = fem::int0;
  int iprcbl = fem::int0;
  int kq = fem::int0;
  int ifd = fem::int0;
  int kmv = fem::int0;
  int itam = fem::int0;
  int im = fem::int0;
  int jm = fem::int0;
  int nphs = fem::int0;
  int kadt = fem::int0;
  int idt = fem::int0;
  int ka = fem::int0;
  int jh = fem::int0;
  int kvd = fem::int0;
  int lj = fem::int0;
  int jv = fem::int0;
  double sumkr = fem::double0;
  double sumki = fem::double0;
  double summr = fem::double0;
  double summi = fem::double0;
  double ar = fem::double0;
  double ai = fem::double0;
  int lj1 = fem::int0;
  int lqv = fem::int0;
  int ky = fem::int0;
  int ii = fem::int0;
  double czire = fem::double0;
  double cziim = fem::double0;
  double djk3 = fem::double0;
  int lg = fem::int0;
  int kqk = fem::int0;
  int jqa = fem::int0;
  int iqa = fem::int0;
  int la = fem::int0;
  int iadrs = fem::int0;
  int ifa = fem::int0;
  double taua = fem::double0;
  double ejwtr = fem::double0;
  double ejwti = fem::double0;
  int nn6 = fem::int0;
  int nk7 = fem::int0;
  int nk8 = fem::int0;
  double dkr = fem::double0;
  double dki = fem::double0;
  double djk4 = fem::double0;
  double ccc3 = fem::double0;
  double ccc4 = fem::double0;
  int nn4 = fem::int0;
  double taui = fem::double0;
  int ntaui = fem::int0;
  double amagk = fem::double0;
  double amagm = fem::double0;
  double angk = fem::double0;
  double angm = fem::double0;
  double wd = fem::double0;
  int koff12 = fem::int0;
  int n9 = fem::int0;
  int ier = fem::int0;
  double vsl = fem::double0;
  double vsli = fem::double0;
  double vsr = fem::double0;
  double vsri = fem::double0;
  double csl = fem::double0;
  double csli = fem::double0;
  double csr = fem::double0;
  double csri = fem::double0;
  double h1 = fem::double0;
  double h2 = fem::double0;
  int j2 = fem::int0;
  double ckreal = fem::double0;
  double ckimag = fem::double0;
  double absfk = fem::double0;
  double phfk = fem::double0;
  double cmreal = fem::double0;
  double cmimag = fem::double0;
  double absfm = fem::double0;
  double phfm = fem::double0;
  int nrf = fem::int0;
  int ix = fem::int0;
  double c2r = fem::double0;
  double c2i = fem::double0;
  double c3r = fem::double0;
  double c3i = fem::double0;
  double d3 = fem::double0;
  int i1 = fem::int0;
  double vi1 = fem::double0;
  double vr2 = fem::double0;
  double vi2 = fem::double0;
  double yx = fem::double0;
  double gus3 = fem::double0;
  double bi3 = fem::double0;
  double gus4 = fem::double0;
  double bi4 = fem::double0;
  int nl1 = fem::int0;
  arr_1d<50, double> ekreal(fem::fill0);
  arr_1d<50, double> ekimag(fem::fill0);
  arr_1d<50, double> emreal(fem::fill0);
  arr_1d<50, double> emimag(fem::fill0);
  int jj = fem::int0;
  arr_1d<50, double> closev(fem::fill0);
  arr_1d<50, double> farv(fem::fill0);
  arr_1d<50, double> closei(fem::fill0);
  arr_1d<50, double> fari(fem::fill0);
  double gus1 = fem::double0;
  int ip = fem::int0;
  int jip = fem::int0;
  int iip = fem::int0;
  int isd1 = fem::int0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  int kf = fem::int0;
  double d8 = fem::double0;
  double d10 = fem::double0;
  double d4 = fem::double0;
  double d5 = fem::double0;
  int iflag = fem::int0;
  int kj = fem::int0;
  static const char* format_111 =
    "(17x,'CI1',17x,'CK1',2x,'IT1',3x,'N1',3x,'N3',/,2(2x,e18.9),3i5)";
  static const char* format_3438 =
    "(/,' MATRIX [T] FOLLOWS.  VOLT(1:N9) ....',/(1x,5e25.16))";
  static const char* format_3471 =
    "(/,' INVERSE OF  (ZTHEV).  IER =',i2,/(1x,5e25.16))";
  static const char* format_5340 =
    "(' IN OVER13, NEW MARTI LINE SOLUTION LOGIC OVERFLOWED STO',"
    "'RAGE LIST NO. 22: LHIST =',i5,' NEEDED SPACE HERE KOFF11=',i5,'.',/,"
    "' EXECUTION IS ABORTED, AND REDIMENSION WITH LARGER VALUEOF LIST NO. 22 I"
    "S REQUIRED.')";
  static const char* format_54159 = "('+LINEAR I.',4x,3e12.4)";
  static const char* format_5433 =
    "(' KVD,JV,VMR5(KVD),VKR5(KVD)=',1x,i5,1x,i5,2x,2e14.5)";
  static const char* format_7011 = "(i2,a6,3e15.8,21x,i6)";
  static const char* format_7020 = "(i2,2a6,4e15.8,i6)";
  static const char* format_81107 = "(1x,10e12.5)";

  auto& mdrive = cmn.lstat(14);

  if (iprsup >= 1) {
    write(lunit6,
      "(' BEGIN MODULE \"OVER13\".','  ISTEAD     IBR    NTOT',/,23x,8i8)"),
      istead, ibr, ntot;
  }
  jglnn = 0;
  isecti = 400;
  ll0 = 0;
  kcbl = 0;
  kmode = 0;
  ll1 = 1;
  mdrive = 0;
  marti = 0;
  //C     INITIALIZE COUNTERS FOR THE -666 BRANCHES*   *   *   *   *   *   *M32.4294
  ibf = 0;
  ikf = 0;
  isfd = 0;
  fzero = 0.0f;
  if (istead > 0) {
    goto statement_546;
  }
  FEM_DO_SAFE(i, 1, ibr) {
    if (kbus(i) < 0) {
      goto statement_540;
    }
    ci(i) = 0.f;
    cik(i) = 0.f;
    ck(i) = 0.f;
  statement_540:;
  }
  move0(e, ntot);
  move0(f, ntot);
  move0(kode, ntot);
  move0(xk, lpast);
  move0(xm, lpast);
  move0(stailk, ltails);
  move0(stailm, ltails);
  goto statement_545;
statement_546:
  L = iline + 1;
  k = lpast - iline;
  move0(xk, L, k);
  move0(xm, L, k);
  k = 0;
  itadd = it + 1;
  marti = 1;
statement_547:
  k++;
  if (imodel(k) != -4) {
    goto statement_4202;
  }
  jpl = 0;
  FEM_DO_SAFE(i, 1, ibr) {
    if (kodsem(i) == 0) {
      goto statement_2023;
    }
    kv = namebr(inoff1 + i);
    if (kv == 0) {
      goto statement_2023;
    }
    if (kv == 1) {
      goto statement_2024;
    }
    goto statement_2025;
  statement_2024:
    nr(i) = lpast + kv;
    it2 = length(i);
    phs2 = it2 * it2;
    FEM_DO_SAFE(j, 1, phs2) {
      jpl += semaux(koff20 + kv);
      kv++;
    }
    goto statement_2023;
  statement_2025:
    nr(i) = lpast + 2 * jpl + 1;
  statement_2023:;
  }
statement_4202:
  if (kill > 0) {
    goto statement_9200;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' IN  ''OVER13'' ,   NEXT COUPLED BRANCH GROUP.',"
      "'         K       IBR   KBUS(K)','     NR(K)    ISTEAD KODEBR(K)',/,"
      "44x,6i10)"),
      k, ibr, kbus(k), nr(k), istead, kodebr(k);
  }
  if (k > ibr) {
    goto statement_521;
  }
  L = kbus(k);
  n15 = fem::iabs(L);
  if (n15 == 1) {
    n15 = fem::iabs(mbus(k));
  }
  n16 = fem::iabs(kssfrq(n15));
  omega = twopi * sfreq(n16);
  steady = omega * deltat;
  if (L < 0) {
    goto statement_575;
  }
  m = fem::iabs(mbus(k));
  goto statement_560;
statement_521:
  if (inonl == 0) {
    goto statement_545;
  }
  ibadd = ibr;
  FEM_DO_SAFE(i, 1, inonl) {
    if (nltype(i) != -99) {
      goto statement_3684;
    }
    if (anonl(i) >= 0.0f) {
      goto statement_523;
    }
    anonl(i) = -anonl(i);
    k = nonlk(i);
    m = fem::iabs(nonlm(i));
    d6 = e(k) - e(m);
    n4 = nonlad(i);
    curr(i) = 1.0f;
    if (d6 < 0.0f) {
      curr(i) = -1.0f;
    }
    if (std::abs(d6) <= vchar(i)) {
      goto statement_3676;
    }
    if (noutpr == 0) {
      write(lunit6,
        "(' TYPE-99 ELEMENT FROM ''',a6,''' TO ''',a6,"
        "''' HAS INITIAL CONDITION VOLTAGE OF',e15.6,"
        "'   WHICH IS BEYOND SEGMENT-1 BREAKPOINT.',/,70x,"
        "'THE USER SHOULD EXPECT SPURIOUS TRANSIENTS AT TIME ZERO.')"),
        bus(k), bus(m), d6;
    }
  statement_3676:
    goto statement_523;
  statement_3684:
    j0 = nonle(i);
    if (j0 > 0) {
      goto statement_523;
    }
    if (nltype(i) == -98) {
      curr(i) = 1.0f;
    }
    k = nonlk(i);
    m = fem::iabs(nonlm(i));
    if (vzer5(i) == 0.f) {
      goto statement_522;
    }
    ibadd++;
    if (nltype(i) == -98) {
      goto statement_522;
    }
    curr(i) = -ci(ibadd);
  statement_522:
    ipp = k;
    if (ipp == 1) {
      ipp = m;
    }
    ipp = fem::iabs(kssfrq(ipp));
    omega = twopi * sfreq(ipp);
    ci1 = (f(k) - f(m)) / omega;
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' FLUX CALC.','       I  NLTYPE       K       M',12x,'CI1',10x,"
        "'OMEGA',11x,'F(K)',11x,'F(M)',/,11x,4i8,4e15.6)"),
        i, nltype(i), k, m, ci1, omega, f(k), f(m);
    }
    if (nltype(i) != -96) {
      goto statement_7115;
    }
    if (ci1 != 0) {
      goto statement_710;
    }
    ci1 = vecnl1(i);
    n11 = nonlad(i);
    cchar(n11 + 3) = curr(i);
    goto statement_7122;
    //C     CHECK THAT THE INITIAL FLUX-CURRENT POINT LIES WITHIN THE MAJOR   M23.2326
    //C     HYSTERESIS LOOP.                                                  M23.2327
  statement_710:
    n10 = ilast(i);
    n11 = nonlad(i);
    n11 = cchar(n11);
    n12 = nonlad(i) + 3;
    cchar(n12) = curr(i);
    n12 = n10 + n11;
    if (curr(i) > cchar(n10)) {
      goto statement_720;
    }
    d12 = vchar(n12 + 1) * curr(i) + cchar(n12 + 1);
    goto statement_726;
  statement_720:
    if (curr(i) < cchar(n12 - 1)) {
      goto statement_730;
    }
    n13 = n12 + n11 + 1;
    d12 = vchar(n13) * curr(i) + cchar(n13);
  statement_726:
    d13 = d12;
    d14 = d12;
    goto statement_760;
  statement_730:
    n18 = n10 + 1;
    n19 = n12 - 1;
    FEM_DO_SAFE(n14, n18, n19) {
      if (curr(i) > cchar(n14)) {
        goto statement_740;
      }
      n15 = n14;
      goto statement_745;
    statement_740:;
    }
  statement_745:
    n16 = n15 + n11 + 1;
    d13 = vchar(n16) * curr(i) + cchar(n16);
    FEM_DO_SAFE(n14, n18, n19) {
      if (-curr(i) > cchar(n14)) {
        goto statement_750;
      }
      n15 = n14;
      goto statement_755;
    statement_750:;
    }
  statement_755:
    n16 = n15 + n11 + 1;
    d14 = vchar(n16) * curr(i) - cchar(n16);
    if (d14 + flzero >= ci1 && ci1 >= d13 - flzero) {
      goto statement_7122;
    }
    d12 = cmn.onehaf * (d13 + d14);
  statement_760:
    if (d12 == ci1) {
      goto statement_7122;
    }
    write(lunit6,
      "(/,10x,'NOTE  ---- NONLINEAR ELEMENT NUMBER',i4,"
      "'  IS A TYPE-96 HYSTERETIC INDUCTOR WHICH IS CONNECTED',/,21x,"
      "'BETWEEN BUSSES  ''',a6,'''  AND  ''',a6,"
      "''' .   THE INITIAL FLUX-CURRENT POINT AS FOUND BY THE',/,21x,"
      "'PHASOR STEADY-STATE SOLUTION HAS BEEN OBSERVED TO LIE OUTSIDE THE USER"
      "-DEFINED MAJOR HYSTERESIS LOOP, HOWEVER.',/,21x,'THE INITIAL FLUX IS',"
      "e14.4,'   AND THE INITIAL CURRENT IS',e14.4,"
      "' .    THE EMTP SHALL NOW ALTER THIS')"),
      i, bus(k), bus(m), ci1, curr(i);
    write(lunit6,
      "(21x,"
      "'JUST-PRINTED FLUX SO AS TO MAKE IT LEGAL, WHILE HOLDING THE CURRENT CO"
      "NSTANT.   THE LINE OF CONSTANT CURRENT',/,21x,"
      "'INTERSECTS THE USER-SUPPLIED MAJOR HYSTERESIS LOOP AT TWO POINTS (POSS"
      "IBLY EQUAL, IF THE CURRENT IS LARGE',/,21x,"
      "'ENOUGH).   THE  ''UPPER''  IS CUT AT FLUX VALUE',e14.5,"
      "' ,   AND THE  ''LOWER''  AT FLUX VALUE',e14.5,' .',/,21x,"
      "'THE INITIAL FLUX SHALL BE TAKEN BY THE EMTP TO BE THE AVERAGE OF THESE"
      ", WHICH HAS FLUX VALUE',e15.5,' .')"),
      d14, d13, d12;
    ci1 = d12;
    if (iprsup >= 3) {
      write(lunit6,
        "(/,' TYPE-96 PROCESS.','     N10     N11     N12     N18     N19',"
        "12x,'NONLE(I)',/,17x,5i8,i10,/,1x,13x,'CURR(I)',17x,'CI1',17x,'D13',"
        "17x,'D14',16x,'E(K)',16x,'E(M)',/,1x,6e20.11)"),
        n10, n11, n12, n18, n19, nonle(i), curr(i), ci1, d13, d14, e(k),
        e(m);
    }
  statement_7122:
    n6 = nonlad(i);
    n7 = cchar(n6);
    n12 = n6 + 2;
    n15 = ilast(i);
    n10 = n15 + n7 - 1;
    vnonl(i) = ci1;
    vchar(n6 + 4) = vnonl(i);
    gslope(n6 + 4) = curr(i);
    cchar(n6 + 4) = -1;
    if (e(k) < e(m)) {
      goto statement_920;
    }
    //C     AN UPPER TRAJECTORY IS INITIALLY ASSUMED                          M25. 361
    cchar(n6 + 1) = 1;
    vchar(n6 + 5) = vchar(n10);
    gslope(n6 + 5) = cchar(n10);
    d6 = 0.0f;
    if (std::abs(vchar(n6 + 5) - vchar(n6 + 4)) > flzero) {
      goto statement_1895;
    }
    d12 = 0.0f;
    vchar(n6) = 0.0f;
    vchar(n6 + 1) = 0.0f;
    cchar(n12) = n15 + n7;
    goto statement_1312;
  statement_1895:
    FEM_DO_SAFE(n11, n15, n10) {
      if (gslope(n6 + 4) > cchar(n11)) {
        goto statement_1900;
      }
      cchar(n12) = n11;
      goto statement_1910;
    statement_1900:;
    }
    cchar(n12) = n10 + 1;
  statement_1910:
    n13 = cchar(n12) + n7 + 1;
    d9 = vchar(n13) * gslope(n6 + 4) + cchar(n13);
    d12 = vchar(n6 + 4) - d9;
    goto statement_1700;
    //C     A DOWNER TRAJECTORY IS INITIALLY ASSUMED                          M25. 382
  statement_920:
    cchar(n6 + 1) = -1;
    vchar(n6 + 5) = vchar(n15);
    gslope(n6 + 5) = cchar(n15);
    d6 = 0.0f;
    if (std::abs(vchar(n6 + 5) - vchar(n6 + 4)) > flzero) {
      goto statement_1945;
    }
    d12 = 0.0f;
    vchar(n6) = 0.0f;
    vchar(n6 + 1) = 0.0f;
    cchar(n12) = n15 + n7;
    goto statement_1212;
  statement_1945:
    FEM_DO_SAFE(n11, n15, n10) {
      if (-gslope(n6 + 4) > cchar(n11)) {
        goto statement_1950;
      }
      cchar(n12) = n11;
      goto statement_1960;
    statement_1950:;
    }
    cchar(n12) = n10 + 1;
  statement_1960:
    n13 = cchar(n12) + n7 + 1;
    d9 = vchar(n13) * gslope(n6 + 4) - cchar(n13);
    d12 = d9 - vchar(n6 + 4);
  statement_1700:
    vchar(n6) = (d12 - d6) / (vchar(n6 + 4) - vchar(n6 + 5));
    vchar(n6 + 1) = d12 - vchar(n6) * vchar(n6 + 4);
    if (cchar(n6 + 1) == 1) {
      goto statement_1312;
    }
  statement_1212:
    n14 = cchar(n12);
    n13 = n14 + n7 + 1;
    d13 = gslope(n14) * (1.0f + vchar(n6));
    d13 = 1.0f / d13;
    d14 = gslope(n13) - gslope(n14) * vchar(n6 + 1);
    d14 = d14 * d13;
    goto statement_1315;
  statement_1312:
    n14 = cchar(n12);
    n13 = n14 + n7 + 1;
    d13 = gslope(n14) * (1.0f - vchar(n6));
    d13 = 1.0f / d13;
    d14 = gslope(n14) * vchar(n6 + 1) - gslope(n13);
    d14 = d14 * d13;
  statement_1315:
    gslope(n6 + 1) = delta2 / d13;
    gslope(n6) = curr(i) - (e(k) - e(m)) * gslope(n6 + 1);
    vchar(n12) = vnonl(i);
    vchar(n6 + 3) = curr(i);
    gslope(n6 + 2) = cchar(n6 + 1);
    gslope(n6 + 3) = cchar(n6 + 2);
    n8 = n6 + 5;
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6,
          "(/,' DONE TYPE-96 INIT.',5x,'N13 =',i4,/,7x,'ROW',15x,'CCHAR',15x,"
          "'VCHAR',14x,'GSLOPE',/(1x,i9,3e20.11))");
        wloop, n13;
        FEM_DO_SAFE(ipp, n6, n8) {
          wloop, ipp, cchar(ipp), vchar(ipp), gslope(ipp);
        }
      }
    }
    goto statement_7117;
  statement_7115:
    if (anonl(i) == 0.0f) {
      goto statement_523;
    }
  statement_7117:
    if (noutpr == 0) {
      write(lunit6,
        "(' INITIAL FLUX IN COIL ''',a6,''' TO ''',a6,''' =',e13.5)"),
        bus(k), bus(m), ci1;
    }
    if (std::abs(ci1) > std::abs(anonl(i)) && noutpr == 0) {
      write(lunit6,
        "(' WARNING.  ASSUMPTION THAT AC STEADY STATE HAS FUNDAMENTAL FREQUENC"
        "Y ONLY IS QUESTIONABLE WITH PRECEDING FLUX OUTSIDE  LINEAR REGION')");
    }
    vnonl(i) = ci1 - (e(k) - e(m)) * delta2;
    if (nltype(i) != -98) {
      goto statement_523;
    }
    if (vnonl(i) < 0.0f) {
      curr(i) = -1.0f;
    }
  statement_523:;
  }
statement_545:
  istead = 0;
  iprint = -1;
  itadd = it + 1;
  //C                                                                       M44. 774
  //C     READ INPUT CARD USING CIMAGE.                                        11137
  //C                                                                       M44. 775
statement_544:
  cimage(cmn);
statement_5758:
  if (kolbeg > 0) {
    goto statement_4623;
  }
  read(abuff, format_7011), ivolt;
  goto statement_4625;
statement_4623:
  nfrfld = 1;
  freone(cmn, d11);
  ivolt = d11;
statement_4625:
  if (ivolt <= 1) {
    goto statement_590;
  }
  mdrive = 1;
  if (ivolt == 2) {
    goto statement_550;
  }
  iprint = 1;
  if (ivolt == 3) {
    goto statement_553;
  }
  if (ivolt == 4) {
    goto statement_570;
  }
  if (ivolt == 5) {
    goto statement_5600;
  }
  kill = 30;
  lstat(19) = 550;
  lstat(16) = ivolt;
  goto statement_9200;
statement_550:
  if (kolbeg > 0) {
    goto statement_4633;
  }
  read(abuff, format_7011), ll, bus1, a, ci1, ck1, k;
  goto statement_4635;
statement_4633:
  k = ivolt;
  nright = -1;
  nfrfld = 1;
  freone(cmn, d1);
  bus1 = texta6(1);
  nright = 0;
  freone(cmn, a);
  freone(cmn, ci1);
  freone(cmn, ck1);
statement_4635:
  if (iprint == 0) {
    goto statement_54157;
  }
  if (iprint == 0) {
    write(6, star), "OVER13-CABLE.    CK1, TPI=", ck1, tpi;
  }
  winic = ck1 * tpi;
  iprint = 0;
  if (noutpr == 0) {
    write(kunit6, "('+NODE VOLT INIT COND.',2e11.3,f7.1)"), a, ci1, ck1;
  }
  steady = ck1 * twopi * deltat;
  goto statement_4463;
statement_54157:
  if (noutpr == 0) {
    write(kunit6, "('+NODE VOLT INIT COND.',2e11.3)"), a, ci1;
  }
statement_4463:
  if (k > 0) {
    goto statement_7005;
  }
  FEM_DO_SAFE(k, 2, ntot) {
    if (bus(k) == bus1) {
      goto statement_552;
    }
  }
  kill = 31;
  lstat(19) = 551;
  goto statement_9200;
statement_7005:
  if (bus(k) == bus1) {
    goto statement_552;
  }
  kill = 31;
  lstat(19) = 7005;
  goto statement_9200;
statement_552:
  e(k) = a;
  f(k) = ci1;
  goto statement_544;
statement_553:
  if (kolbeg > 0) {
    goto statement_4643;
  }
  read(abuff, format_7020), ll, bus1, bus2, ci1, ck1, a, d2, k;
  goto statement_4645;
statement_4643:
  ll = ivolt;
  nright = -1;
  nfrfld = 2;
  freone(cmn, d1);
  bus1 = texta6(1);
  bus2 = texta6(2);
  nright = 0;
  nfrfld = 1;
  freone(cmn, ci1);
  freone(cmn, ck1);
  freone(cmn, a);
  freone(cmn, d2);
  freone(cmn, d7);
  k = d7;
statement_4645:
  if (noutpr == 0) {
    write(kunit6, format_54159), ci1, ck1, a;
  }
  if (k > 0) {
    goto statement_7000;
  }
  FEM_DO_SAFE(k, 1, ibr) {
    L = kbus(k);
    ll = fem::iabs(L);
    m = fem::iabs(mbus(k));
    if (bus(ll) != bus1) {
      goto statement_554;
    }
    if (bus(m) != bus2) {
      goto statement_554;
    }
    if (L < 0) {
      goto statement_575;
    }
    goto statement_560;
  statement_554:;
  }
  kill = 32;
  lstat(19) = 554;
  goto statement_9200;
statement_7000:
  L = kbus(k);
  ll = fem::iabs(L);
  m = fem::iabs(mbus(k));
  if (bus(ll) != bus1 || bus(m) != bus2) {
    goto statement_7001;
  }
  if (L < 0) {
    goto statement_575;
  }
  goto statement_560;
statement_7001:
  kill = 32;
  lstat(19) = 7000;
  goto statement_9200;
statement_560:
  n3 = nr(k);
  if (n3 > 0) {
    goto statement_565;
  }
  if (istead > 0) {
    goto statement_561;
  }
  ci(k) = -ci1;
  ck(k) = ck1;
statement_561:
  n3 = -n3;
  cik(k) = -ci(k) - x(n3) * (e(L) - e(m));
  if (istead > 0) {
    goto statement_547;
  }
  goto statement_544;
statement_565:
  it2 = fem::iabs(length(k));
  if (istead > 0) {
    goto statement_568;
  }
  cik(k) = ci1;
  ci(k) = ck1;
  ck(k) = a;
statement_568:
  ci1 = e(L);
  ck1 = e(m);
  volti(1) = -ci1 / 2.0f;
  voltk(1) = -ck1 / 2.0f;
  volt(1) = ck1 - ci1;
  if (length(k + 1) == -666) {
    voltk(1) = f(m) - f(L);
  }
  n1 = k + it2 - 1;
  if (it2 == 1) {
    goto statement_567;
  }
  it1 = k + 1;
  if (iprsup >= 1) {
    write(lunit6, format_111), ci1, ck1, it1, n1, n3;
  }
  FEM_DO_SAFE(i, it1, n1) {
    L = kbus(i);
    m = fem::iabs(mbus(i));
    if (istead > 0) {
      goto statement_569;
    }
    //C     READ INPUT CARD USING CIMAGE.                                        11211
    cimage(cmn);
    if (kolbeg > 0) {
      goto statement_4653;
    }
    read(abuff, format_7020), n2, bus1, bus2, cik(i), ci(i), ck(i);
    goto statement_4655;
  statement_4653:
    nfrfld = 1;
    freone(cmn, d11);
    n2 = d11;
    nright = -1;
    freone(cmn, d1);
    bus1 = texta6(1);
    freone(cmn, d1);
    bus2 = texta6(1);
    nright = 0;
    frefld(cmn, cik(i));
    frefld(cmn, ci(i));
    frefld(cmn, ck(i));
  statement_4655:
    if (noutpr == 0) {
      write(kunit6, format_54159), cik(i), ci(i), ck(i);
    }
    if (bus(L) == bus1 && bus(m) == bus2) {
      goto statement_569;
    }
    kill = 32;
    lstat(19) = 569;
    goto statement_9200;
  statement_569:
    ci1 = e(L);
    ck1 = e(m);
    nkp = L;
    L = i - k + 1;
    volti(L) = -ci1 / 2.0f;
    voltk(L) = -ck1 / 2.0f;
    volt(L) = ck1 - ci1;
    if (length(k + 1) == -666) {
      voltk(L) = f(m) - f(nkp);
    }
  }
  if (kodebr(k) <= 0) {
    goto statement_567;
  }
  mult(x(n3), volt(1), cik(k), it2, ll1);
  L = k;
  FEM_DO_SAFE(i, 1, it2) {
    if (iprsup >= 3) {
      write(lunit6,
        "(/,' AT 38567, INIT  I(T-DELTAT) ....',i10,2e25.15)"), i,
        volt(i), cik(L);
    }
    L++;
  }
  goto statement_28567;
statement_567:
  mult(tx(n3), volt(1), cik(k), it2, ll1);
  if (iprsup >= 1) {
    write(lunit6, format_111), ci1, ck1, it1, n1, n3;
  }
  if (length(k + 1) != -666) {
    goto statement_28567;
  }
  //C     PROCESS NEXT SET OF MODAL BRANCHES   *   *   *   *   *   *   *   *M32.4304
  omg = steady / deltat;
  fdint(cmn, ikf, isfd, ibf, omg);
statement_28567:
  mult(c(n3), volti(1), ci(k), it2, ll1);
  mult(c(n3), voltk, ck(k), it2, ll1);
  k = n1;
  if (istead > 0) {
    goto statement_547;
  }
  goto statement_544;
statement_570:
  if (kolbeg > 0) {
    goto statement_4663;
  }
  read(abuff, format_7020), k, bus1, bus2, ci1, ck1;
  goto statement_4665;
statement_4663:
  k = ivolt;
  nright = -1;
  nfrfld = 2;
  freone(cmn, d1);
  bus1 = texta6(1);
  bus2 = texta6(2);
  nright = 0;
  nfrfld = 1;
  freone(cmn, ci1);
  freone(cmn, ck1);
statement_4665:
  if (noutpr == 0) {
    write(kunit6, "('+NONLIN. BRANCH INIT COND.',2x,2e11.3)"), ci1, ck1;
  }
  FEM_DO_SAFE(k, 1, inonl) {
    L = nonlk(k);
    m = fem::iabs(nonlm(k));
    if (bus(L) != bus1) {
      goto statement_571;
    }
    if (bus(m) == bus2) {
      goto statement_572;
    }
  statement_571:;
  }
  kill = 33;
  lstat(19) = 571;
  goto statement_9200;
statement_572:
  n1 = nonlad(k);
  n2 = nonle(k);
  if (n2 > 0) {
    goto statement_544;
  }
  n2 = -n2;
  if (nltype(k) != -96) {
    goto statement_7361;
  }
  vnonl(k) = ci1 - (e(L) - e(m)) * delta2;
  n17 = nonlad(k);
  n18 = n17 + 1;
  n19 = n17 + 2;
  n20 = n17 + 3;
  cchar(n20) = ck1;
  curr(k) = cchar(n20);
  //C     READ INPUT CARD USING CIMAGE.                                     M25. 425
  cimage(cmn);
  {
    read_loop rloop(abuff(1), "(2i10,4e15.8)");
    rloop, n15, n16;
    FEM_DO_SAFE(ipp, n17, n20) {
      rloop, vchar(ipp);
    }
  }
  cchar(n18) = n15;
  cchar(n19) = n16;
  if (noutpr == 0) {
    write(kunit6, "('+  TYPE-96.',2i4,2e15.6)"), n15, n16, vchar(n17),
      vchar(n17 + 1);
  }
  gslope(n19) = cchar(n18);
  gslope(n20) = cchar(n19);
  n16 = cchar(n19);
  n15 = n16 + cchar(n17) + 1;
  if (cchar(n18) != 1) {
    goto statement_4667;
  }
  d13 = gslope(n16) * (1.0f - vchar(n17));
  d13 = 1.0f / d13;
  d14 = gslope(n16) * vchar(n18) - gslope(n15);
  d14 = d14 * d13;
  goto statement_4668;
statement_4667:
  d13 = gslope(n16) * (1.0f + vchar(n17));
  d13 = 1.0f / d13;
  d14 = gslope(n15) - gslope(n16) * vchar(n18);
  d14 = d14 * d13;
statement_4668:
  gslope(n18) = delta2 / d13;
  gslope(n17) = vchar(n20) - gslope(n18) * (e(L) - e(m));
  n18 = n17 + 4;
  n19 = n17 + 5;
  //C READ INPUT CARD USING CIMAGE.                                         M25. 428
  cimage(cmn);
  read(abuff, "(i10,4e15.8)"), n20, vchar(n18), vchar(n19), gslope(n18),
    gslope(n19);
  cchar(n18) = n20;
  if (noutpr == 0) {
    write(kunit6, "('+  TYPE-96.',i8,2e14.6)"), n20, vchar(n18), vchar(n19);
  }
  goto statement_544;
statement_7361:
  FEM_DO_SAFE(i, n1, n2) {
    if (cchar(i) > ci1) {
      goto statement_574;
    }
  }
  kill = 34;
  lstat(19) = 573;
  flstat(16) = ci1;
  flstat(15) = cchar(n2);
  lstat(14) = n2;
  lstat(13) = k;
  goto statement_9200;
statement_574:
  n1 = i - 1;
  vr1 = vchar(n1);
  curr1 = cchar(n1);
  curr(k) = ci1;
  ci1 = vr1 + (vchar(i) - vr1) * (ci1 - curr1) / (cchar(i) - curr1);
  if (ck1 != 0.f) {
    ci1 = ck1;
  }
  vnonl(k) = ci1 - (e(L) - e(m)) * delta2;
  goto statement_544;
  //C 3456789012345678901234567890123456789012345678901234567890123456789012M44. 781
statement_575:
  if (imodel(k) != -3) {
    goto statement_3300;
  }
  //C                                                                       M44. 783
  //C                                                                       M44. 784
statement_3300:
  n1 = -kbus(k);
  n2 = fem::iabs(mbus(k));
  if (imodel(k) == -4) {
    goto statement_7550;
  }
  //C      IF(KODSEM(K) .NE. 0                                              M31.2796
  //C     1 .AND. IMODEL(K) .NE. -2) GO TO 5750      !for Semlyen or cas. PIM44. 787
  if (kodsem(k) != 0 && imodel(k) >= 0) {
    goto statement_5750;
  }
statement_7550:
  n4 = length(k);
  if (n4 > 0) {
    n4 = 1;
  }
  isd = itadd;
  if (imodel(k) == -2) {
    goto statement_60001;
  }
  if (imodel(k) == -4) {
    goto statement_60006;
  }
  if (istead == 0) {
    goto statement_578;
  }
  curr1 = tr(itadd);
  curi1 = tx(itadd);
  curr2 = r(itadd);
  curi2 = c(itadd);
  itadd++;
  goto statement_579;
  //CL                                                                      M31.2798
  //C     INITIALIZATION OF HISTORY VECTORS FOR MARTI'S  F.D. LINES         M31.2799
  //C     NON-ZERO INITIAL CONDITIONS                                       M31.2800
  //C                                                                       M44. 791
  //C                                                                       M44. 792
statement_60006:
  it2 = fem::iabs(n4);
  aph = it2;
  nl = litype(k);
  if (istead == 0) {
    goto statement_60005;
  }
  n5 = nl - 1;
  iy = k;
  iz = itadd;
  //C                                                                       M44. 800
  //C                                       CALL INCDRV ( K, NPHS, DELTAT, OM44. 801
  //C                                                                       M44. 802
  n7 = iy;
  n8 = iz;
  steady = omega * deltat;
  if (iprsup > 0) {
    write(lunit6, star), "steady = omega * deltat", omega, deltat, steady;
  }
  wdt = -deltat * omega;
  //C                                                                       M44. 809
  //C                               Evaluate: vm(to), vm(to-dt), vk(to), vk(M44. 810
  //C                                                                       M44. 811
  if (istead == 0) {
    omegs1 = 0.0f;
  }
  n1 = kodsem(k);
  nrz = cki(k);
  nra = ckkjm(k);
  if (iprsup > 0) {
    write(lunit6,
      "(1x,i6,1x,i6,1x,i6,' I       VKDT(I)       VMDT(I)','NN5 N6')"),
      n1, nra, nrz;
  }
  ivbr = k;
  FEM_DO_SAFE(i, 1, it2) {
    ns1 = kodsem(ivbr);
    nrz = cki(ivbr);
    nra = ckkjm(ivbr);
    n1 = -kbus(ivbr);
    n2 = fem::iabs(mbus(ivbr));
    nk1 = ns1 + 5 * nra + 5 * nrz + 4 + 1;
    nn17 = sconst(nk1);
    nn5 = ns1 + 5 * nrz + 5 * nra + 4 + 1 + 1 + nn17;
    phf = std::atan2(f(n2), e(n2));
    hf = fem::dsqrt(fem::pow2(e(n2)) + fem::pow2(f(n2)));
    sconst(nn5) = hf * std::cos(wdt + phf);
    n6 = nn5 + 1;
    phf = std::atan2(f(n1), e(n1));
    hf = fem::dsqrt(fem::pow2(e(n1)) + fem::pow2(f(n1)));
    sconst(n6) = hf * std::cos(wdt + phf);
    if (iprsup > 0) {
      write(lunit6, "(9x,i5,1x,2e14.5,1x,1x,i6,1x,i6)"), i, sconst(nn5),
        sconst(n6), nn5, n6;
    }
    ivbr++;
  }
  //C        Single phase and constant Q                                    M44. 842
  //C        Evaluate Im' = Q**-1 * Im                                      M44. 843
  //C                 Ik' = Q**-1 * Ik                                      M44. 844
  //C 125   CALL QINV(QR,QI,QK0,W,NPHS,IADRSQ,NTERMQ) !Q MATRIX AND CONVERTSM44. 845
  //C                                                                       M44. 846
  ioff1 = 0;
  ioff2 = ioff1 + isecti;
  ioff3 = ioff2 + isecti;
  ioff4 = ioff3 + isecti;
  ioff5 = ioff4 + isecti;
  ioff6 = ioff5 + isecti;
  ioff7 = ioff6 + isecti;
  ioff8 = ioff7 + isecti;
  if (ioff8 <= lymat) {
    goto statement_5337;
  }
  write(lunit6,
    "(' IN OVER13, NEW MARTI LINE SOLUTION LOGIC OVERFLOWED STO',"
    "'RAGE LIST NO. 5: LYMAT =',i5,' NEEDED SPACE HERE IOFF8=',i5,'.',/,"
    "' EXECUTION IS ABORTED, AND REDIMENSION WITH LARGER VALUEOF LIST NO. 5 IS"
    " REQUIRED.')"),
    lymat, ioff8;
  FEM_STOP(0);
statement_5337:
  koff25 = koff24 + 288;
  koff11 = koff25 + 288;
  if (koff11 < lhist) {
    goto statement_5339;
  }
  write(lunit6, format_5340), lhist, koff11;
  FEM_STOP(0);
  //C
statement_5339:
  nq1 = namebr(inoff2 + k);
  nphs2 = it2 * it2;
  kqvq = namebr(inoff1 + k);
  kqv = litype(k);
  FEM_DO_SAFE(iq, 1, nphs2) {
    nteq = semaux(koff20 + kqvq);
    qfd(kqv) = sconst(nq1);
    sfd(kqv) = 0.e0;
    if (iprsup >= 2) {
      write(lunit6,
        "(1x,'kQV NTEQ    NQ1    NQ2    NQ3   SCONST(NQ1)',"
        "'   SCONST(NQ2)   SCONST(NQ3)       QR(KQV)')");
    }
    FEM_DO_SAFE(lq, 1, nteq) {
      nq2 = nq1 + lq;
      nq3 = nq2 + nteq;
      if (std::abs(sconst(nq2)) >= 1.e+13f) {
        goto statement_3000;
      }
      d = fem::pow2(omega) + fem::pow2(sconst(nq3));
      qfd(kqv) += sconst(nq2) * sconst(nq3) / d;
      sfd(kqv) = sfd(kqv) - sconst(nq2) * omega / d;
      goto statement_3001;
    statement_3000:
      jkl++;
      if (jkl == 2) {
        goto statement_3002;
      }
      akr = sconst(nq2) / 1.e+15f;
      aki = sconst(nq2 + 1) / 1.e+15f;
      apr = sconst(nq3) / 1.e+15f;
      api = sconst(nq3 + 1) / 1.e+15f;
      dqq3 = fem::pow2(apr) + fem::pow2((omega + api));
      ddd3 = (akr * apr + aki * (omega + api)) / dqq3;
      ddd4 = (aki * apr - akr * (omega + api)) / dqq3;
      xk(kqv) += 2 * ddd3;
      if (jkl == 1) {
        goto statement_3001;
      }
    statement_3002:
      jkl = 0;
    statement_3001:
      if (iprsup >= 2) {
        write(lunit6, "(1x,i6,3x,i6,2x,i5,2x,i5,2x,i5,4e14.5)"), kqv,
          nteq, nq1, nq2, nq3, sconst(nq1), sconst(nq2), sconst(nq3),
          qfd(kqv);
      }
      nq2++;
      nq3++;
    }
    nq1 += 2 * nteq + 1;
    kqv++;
    kqvq++;
  }
  j1 = litype(k);
  jadd = j - 1 + nphs2;
  if (iprsup >= 2) {
    write(lunit6, star), "Following are QR(k) by rows____________";
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6, "('+ Qr-I:',3e14.5)");
      FEM_DO_SAFE(j, j1, jadd) {
        wloop, qfd(j);
      }
    }
  }
  if (iprsup >= 2) {
    write(lunit6, star), "Following are QI(k) by rows____________";
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6, "('+ Qi-I:',3e14.5)");
      FEM_DO_SAFE(j, j1, jadd) {
        wloop, sfd(j);
      }
    }
  }
  icbr = itadd;
  FEM_DO_SAFE(i, 1, it2) {
    r(icbr) = -r(icbr);
    c(icbr) = -c(icbr);
    if (iprcbl > 0) {
      write(lunit6, star), "  AIMR(I)=-AIMR(I) , AIMI(I)=-AIMI(I) ",
        r(icbr), c(icbr);
    }
    icbr++;
  }
  //C                                                                       M44. 948
  //C        Invert matrix Q                                                M44. 949
  //C                                                                       M44. 950
  //C     KQ = IADRSU(K)                                                    M44. 951
  //C      KQ = NAMEBR(INOFF1+K)                                            M44. 952
  kq = litype(k);
  //C      CALL CINVL(QFD(KQ),SFD(KQ),IT2)                            !inverM44. 954
  ll = 1;
  nphs2 = it2 * it2;
  //CCCC   WSM & THL  comment out following DO loop on 14 Sept 88.   It
  //CCCC              seems to us that initialization is not required.
  //C     DO 7003 IFD = 1, 72                                               M44. 525
  //C     WK1(KOFF24+LL) = 0.0                                              M44. 959
  //C     WK1(KOFF24+LL+1)=0.0                                              M44. 960
  //C     LL=LL+2                              !skip two celles for next freM44. 961
  //C7003 CONTINUE                                                          M44. 962
  ll = 1;
  nphs2 = it2 * it2;
  FEM_DO_SAFE(ifd, 1, nphs2) {
    semaux(koff24 + ll) = qfd(kq);
    semaux(koff24 + ll + 1) = sfd(kq);
    ll += 2;
    kq++;
  }
  cominv(cmn, semaux(koff24 + 1), semaux(koff25 + 1), it2, 60.f);
  cmn.t = 0.0000000f;
  kq = namebr(inoff1 + k);
  kq = litype(k);
  ll = 1;
  FEM_DO_SAFE(ifd, 1, nphs2) {
    qfd(kq) = semaux(koff25 + ll);
    sfd(kq) = semaux(koff25 + ll + 1);
    ll += 2;
    kq++;
  }
  kmv = k;
  itam = itadd;
  //C      KQ = NAMEBR(INOFF1+K)                                            M44. 988
  kq = litype(k);
  //C     CALL MVECC(QFD(KQ),SFD(KQ),R(ITADD),C(ITADD),IT2,                 M44. 989
  //C    1    W1( IOFF1 + K ), W1( IOFF2 + K ) )         !Modal current Im'=M44. 990
  if (iprsup > 0) {
    write(lunit6,
      "('  I    J   IT2','    QFD(KQ)    SFD(KQ)   R(ITADD)',"
      "'   C(ITADD)W1(IOFF1+K)W1(IOFF2+K)',"
      "'  TR(ITADD)  TX(ITADD)W1(IOFF7+K)','W1(IOFF8+K)')");
  }
  FEM_DO_SAFE(im, 1, it2) {
    ykm(ioff1 + kmv - 1 + im) = 0.e0;
    ykm(ioff2 + kmv - 1 + im) = 0.e0;
    ykm(ioff7 + kmv - 1 + im) = 0.e0;
    ykm(ioff8 + kmv - 1 + im) = 0.e0;
  }
  FEM_DO_SAFE(jm, 1, it2) {
    FEM_DO_SAFE(im, 1, it2) {
      ykm(ioff1 + kmv - 1 + im) += qfd(kq) * r(itam) - sfd(kq) * c(itam);
      ykm(ioff2 + kmv - 1 + im) += qfd(kq) * c(itam) + sfd(kq) * r(itam);
      ykm(ioff7 + kmv - 1 + im) += qfd(kq) * tr(itam) - sfd(kq) * tx(itam);
      ykm(ioff8 + kmv - 1 + im) += qfd(kq) * tx(itam) + sfd(kq) * tr(itam);
      if (iprsup > 0) {
        write(lunit6, "(1x,i2,3x,i2,3x,i3,10e11.4)"), im, jm, it2,
          qfd(kq), sfd(kq), r(itam), c(itam), ykm(ioff1 + kmv - 1 + im),
          ykm(ioff2 + kmv - 1 + im), tr(itam), tx(itam), ykm(ioff7 +
            kmv - 1 + im), ykm(ioff8 + kmv - 1 + im);
      }
      kq++;
    }
    itam++;
  }
  //C     CALL MVECC(QFD(KQ),SFD(KQ),TR(ITADD),TX(ITADD),IT2,               M44.1029
  //C    1    W1( IOFF7 + K ), W1( IOFF8 + K ) )         !modal current Ik'=M44.1030
  icbr = itadd;
  FEM_DO_SAFE(i, 1, nphs) {
    r(icbr) = -r(icbr);
    c(icbr) = -c(icbr);
    icbr++;
  }
  //C                                                                       M44.1038
  //C                                  Evaluate:   im'(to-dt)  ,  ik'(to-dt)M44.1039
  //C                                                                       M44.1040
  kadt = k;
  FEM_DO_SAFE(idt, 1, it2) {
    n1 = kodsem(kadt);
    nrz = cki(kadt);
    nra = ckkjm(kadt);
    nk1 = n1 + 5 * nra + 5 * nrz + 4 + 1;
    nn17 = sconst(nk1);
    nn5 = n1 + 5 * nrz + 5 * nra + 4 + 2 + 1 + 1 + nn17;
    n6 = nn5 + 1;
    phf = std::atan2(ykm(ioff2 + kadt), ykm(ioff1 + kadt));
    hf = fem::dsqrt(fem::pow2(ykm(ioff2 + kadt)) + fem::pow2(ykm(
      ioff1 + kadt)));
    sconst(nn5) = hf * std::cos(wdt + phf);
    phf = std::atan2(ykm(ioff8 + kadt), ykm(ioff7 + kadt));
    hf = fem::dsqrt(fem::pow2(ykm(ioff7 + kadt)) + fem::pow2(ykm(
      ioff8 + kadt)));
    sconst(n6) = hf * std::cos(wdt + phf);
    if (iprsup > 0) {
      write(lunit6, star), "   AIM5DT,      AIK5DT ", sconst(nn5), sconst(n6);
    }
    kadt++;
  }
  //C                                         Evaluate    Vm'    Vk'        M44.1063
  //C                                                     Vmj'   Vkj'       M44.1064
  ka = k;
  FEM_DO_SAFE(jh, 1, it2) {
    n4 = indhst(ka);
    cnvhst(n4 + 5) = 0.f;
    cnvhst(n4 + 6) = 0.f;
    cnvhst(n4 + 7) = 0.f;
    cnvhst(n4 + 8) = 0.f;
    ka++;
  }
  kvd = k;
  kv = namebr(inoff1 + k);
  nq1 = namebr(inoff2 + k);
  //C      LJ = KV                              ! 1st pole of Qii for the brM44.1077
  lj = nr(k);
  //C      IF ( KV .GT. 1) LJ = ( KV-1 ) * 2 + 1                            M44.1078
  //C      KILINE = LPAST                                                   M44.   9
  //C      LJ = KILINE + LJ                                                 M44.1080
  //C      NR(K) = LJ                                                       M44.1081
  if (iprsup >= 1) {
    write(lunit6,
      "(' BEGIN Qt*Vk,m = Vk,m in mode domain ','       k     IBR    NTOT',/,"
      "23x,3i8)"),
      k, ibr, ntot;
  }
  FEM_DO_SAFE(jv, 1, it2) {
    n4 = indhst(kvd);
    FEM_DO_SAFE(iv, 1, it2) {
      n1 = -kbus(n7);
      n2 = fem::iabs(mbus(n7));
      nteq = semaux(koff20 + kv);
      sumkr = sconst(nq1) * e(n1);
      sumki = sconst(nq1) * f(n1);
      summr = sconst(nq1) * e(n2);
      summi = sconst(nq1) * f(n2);
      if (iprsup > 0) {
        write(lunit6,
          "(' IQ  NTEQ    NQ1    NQ2    NQ3','     S(NQ1)     S(NQ2)',"
          "'     S(NQ3)      E(N1)','      E(N2)      HK2()','      HK3()',"
          "'      SUMKR      SUMMR')");
      }
      jkl = 0;
      FEM_DO_SAFE(iq, 1, nteq) {
        nq2 = nq1 + iq;
        nq3 = nq2 + nteq;
        if (std::abs(sconst(nq2)) >= 1.e+13f) {
          goto statement_3003;
        }
        d = fem::pow2(omega) + fem::pow2(sconst(nq3));
        ar = sconst(nq2) * sconst(nq3) / d;
        ai = -sconst(nq2) * omega / d;
        goto statement_3004;
      statement_3003:
        jkl++;
        if (jkl == 2) {
          goto statement_3005;
        }
        akr = sconst(nq2) / 1.e+15f;
        aki = sconst(nq2 + 1) / 1.e+15f;
        apr = sconst(nq3) / 1.e+15f;
        api = sconst(nq3 + 1) / 1.e+15f;
        dqq3 = fem::pow2(apr) + fem::pow2((omega + api));
        ar = 2 * (akr * apr + aki * (omega + api)) / dqq3;
        ai = 0.f;
      statement_3004:
        ykm(ioff3 + iq) = ar * e(n1) - ai * f(n1);
        ykm(ioff4 + iq) = ar * f(n1) + ai * e(n1);
        ykm(ioff5 + iq) = ar * e(n2) - ai * f(n2);
        ykm(ioff6 + iq) = ar * f(n2) + ai * e(n2);
        sumkr += ykm(ioff3 + iq);
        sumki += ykm(ioff4 + iq);
        summr += ykm(ioff5 + iq);
        summi += ykm(ioff6 + iq);
        if (jkl == 1) {
          goto statement_3006;
        }
      statement_3005:
        jkl = 0;
      statement_3006:
        if (iprsup > 0) {
          write(lunit6, "(1x,i2,3x,i3,2x,i5,2x,i5,2x,i5,9e11.4)"),
            iq, nteq, nq1, nq2, nq3, sconst(nq1), sconst(nq2), sconst(nq3),
            e(n1), e(n2), ykm(ioff3 + iq), ykm(ioff4 + iq), sumkr,
            summr;
        }
        nq2++;
        nq3++;
      }
      nq1 += 2 * nteq + 1;
      if (iprsup > 0) {
        write(lunit6, format_5433), iv, jv, cnvhst(n4 + 5), cnvhst(n4 + 7);
      }
      cnvhst(n4 + 7) += sumkr;
      cnvhst(n4 + 8) += sumki;
      cnvhst(n4 + 5) += summr;
      cnvhst(n4 + 6) += summi;
      if (iprsup > 0) {
        write(lunit6, format_5433), kvd, jv, cnvhst(n4 + 5), cnvhst(n4 + 7);
      }
      //C                                                                       M44.1139
      //C        Evaluate Vmj'(to-dt)                                           M44.1140
      //C                                                                       M44.1141
      //C     LJ = IADRSDT  !keep parallel pointer as tranformation matrix for VM44.1142
      lj1 = lj + nteq;
      if (iprsup > 0) {
        write(lunit6, "('   LJ   LJ1  NTEQ    VMJ5DT(LJ)    VKJ5DT(LJ)')");
      }
      FEM_DO_SAFE(lqv, 1, nteq) {
        phf = std::atan2(ykm(ioff6 + lqv), ykm(ioff5 + lqv));
        hf = sqrtz(fem::pow2(ykm(ioff5 + lqv)) + fem::pow2(ykm(ioff6 + lqv)));
        xm(lj) = hf * cosz(wdt + phf);
        phf = std::atan2(ykm(ioff4 + lqv), ykm(ioff3 + lqv));
        hf = sqrtz(fem::pow2(ykm(ioff3 + lqv)) + fem::pow2(ykm(ioff4 + lqv)));
        xm(lj1) = hf * cosz(wdt + phf);
        if (iprsup >= 1) {
          write(lunit6, "(2x,i8,2x,i8,2x,i4,2e14.3)"), lj, lj1, nteq,
            xm(lj), xm(lj1);
        }
        lj++;
        lj1++;
      }
      lj += nteq;
      n7++;
      if (iv == it2) {
        n7 = n7 - it2;
      }
      kv++;
    }
    phf = std::atan2(cnvhst(n4 + 6), cnvhst(n4 + 5));
    hf = sqrtz(fem::pow2(cnvhst(n4 + 5)) + fem::pow2(cnvhst(n4 + 6)));
    semaux(cmn.koff1 + kvd) = hf * cosz(wdt + phf);
    phf = std::atan2(cnvhst(n4 + 8), cnvhst(n4 + 7));
    hf = sqrtz(fem::pow2(cnvhst(n4 + 7)) + fem::pow2(cnvhst(n4 + 8)));
    semaux(cmn.koff2 + kvd) = hf * cosz(wdt + phf);
    //C      write(*,*) 'vm5dt(kvd), vk5dt(kvd) =,',                          M44.1172
    //C     1            WK1(KOFF1+KVD), WK1(KOFF2+KVD)                       M44.1173
    kvd++;
  }
  //C                                                                       M44.1176
  //C        Evaluate:    Gmj = Ycj' * Vm'   Gkj' = Ycj' * Vk'              M44.1177
  //C                     Fk = Gk + Ik'                                     M44.1178
  //C                     Bm = Gm - Im'                                     M44.1179
  ky = k;
  FEM_DO_SAFE(iv, 1, it2) {
    //C     CALL FJ(VKR5(IV),VKI5(IV),XR,XI,GKR,GKI                           M44.1182
    //C     1       ,VMR5(IV),VMI5(IV),EJA,EJY,GMR,GMI                        M44.1183
    //C     1       ,YPI(IADRS),YKI(IADRS),W,NTEY,0.D0,YK0(IV))               M44.1184
    n1 = kodsem(ky);
    n4 = indhst(ky);
    sumkr = sconst(n1) * cnvhst(n4 + 7);
    sumki = sconst(n1) * cnvhst(n4 + 8);
    summr = sconst(n1) * cnvhst(n4 + 5);
    summi = sconst(n1) * cnvhst(n4 + 6);
    nrz = cki(ky);
    nra = ckkjm(ky);
    jkl = 0;
    FEM_DO_SAFE(ii, 1, nrz) {
      n2 = n1 + ii;
      n3 = n2 + nrz;
      if (std::abs(sconst(n2)) >= 1.e+13f) {
        goto statement_5326;
      }
      d1 = fem::pow2(sconst(n3)) + fem::pow2(omega);
      czire = sconst(n2) * sconst(n3) / d1;
      cziim = -sconst(n2) * omega / d1;
      goto statement_5328;
    statement_5326:
      jkl++;
      if (jkl == 2) {
        goto statement_5327;
      }
      akr = sconst(n2) / 1.e+15f;
      aki = sconst(n2 + 1) / 1.e+15f;
      apr = sconst(n3) / 1.e+15f;
      api = sconst(n3 + 1) / 1.e+15f;
      djk3 = fem::pow2(apr) + fem::pow2((omega + api));
      ddd3 = (akr * apr + aki * (omega + api)) / djk3;
      //C     DDD4 = ( AKI * APR - AKR * ( OMEGA + API ) ) / DJK3               M44. 556
      czire = 2 * ddd3;
      cziim = 0.f;
    statement_5328:
      ykm(ioff3 + ii) = czire * cnvhst(n4 + 7) - cziim * cnvhst(n4 + 8);
      ykm(ioff4 + ii) = czire * cnvhst(n4 + 8) + cziim * cnvhst(n4 + 7);
      ykm(ioff5 + ii) = czire * cnvhst(n4 + 5) - cziim * cnvhst(n4 + 6);
      ykm(ioff6 + ii) = czire * cnvhst(n4 + 6) + cziim * cnvhst(n4 + 5);
      sumkr += ykm(ioff3 + ii);
      sumki += ykm(ioff4 + ii);
      summr += ykm(ioff5 + ii);
      summi += ykm(ioff6 + ii);
      if (iprsup > 0) {
        write(lunit6,
          "(1x,'N1,II,N2,N3,YPI,YKI=',1x,i6,2x,i6,3x,i6,3x,i6,3x,2e14.5)"),
          n1, ii, n2, n3, sconst(n2), sconst(n3);
      }
      if (jkl == 1) {
        goto statement_2020;
      }
    statement_5327:
      jkl = 0;
    statement_2020:;
    }
    if (iprsup > 0) {
      write(lunit6, star),
        "the VOLTAGE Vm & Vk. SUMMR,SUMMI,SUMKR,SUMKI", summr, summi,
        sumkr, sumki;
    }
    //C                                                                       M44.1215
    //C        Evaluate:   gmj(to-dt)                                         M44.1216
    //C                                                                       M44.1217
    if (iprsup > 0) {
      write(lunit6,
        "('KY KODSEM(KY) CKI(KY) CKKJM(KY)',"
        "'  NN5   N6    GMJDT(NN5)     GKJDT(N6)')");
    }
    nk1 = n1 + 5 * nra + 5 * nrz + 4 + 1;
    nn17 = sconst(nk1);
    jkl = 0;
    FEM_DO_SAFE(lg, 1, nrz) {
      nn5 = n1 + 5 * nrz + 5 * nra + 4 + 2 + 2 + lg + 1 + nn17;
      n6 = nn5 + nrz;
      n2 = n1 + lg;
      if (std::abs(sconst(n2)) >= 1.e+13f) {
        jkl++;
      }
      if (jkl == 2) {
        goto statement_5829;
      }
      phf = std::atan2(ykm(ioff6 + lg), ykm(ioff5 + lg));
      hf = fem::dsqrt(fem::pow2(ykm(ioff5 + lg)) + fem::pow2(ykm(ioff6 + lg)));
      sconst(nn5) = hf * std::cos(wdt + phf);
      phf = std::atan2(ykm(ioff4 + lg), ykm(ioff3 + lg));
      hf = fem::dsqrt(fem::pow2(ykm(ioff3 + lg)) + fem::pow2(ykm(ioff4 + lg)));
      sconst(n6) = hf * std::cos(wdt + phf);
      if (iprsup > 0) {
        write(lunit6,
          "(1x,i5,8x,i6,5x,i6,7x,i6,2x,i6,2x,i6,2e14.5)"), ky, kodsem(ky),
          nrz, nra, nn5, n6, sconst(nn5), sconst(n6);
      }
      if (jkl == 1) {
        goto statement_107;
      }
    statement_5829:
      jkl = 0;
    statement_107:;
    }
    //C                                                                       M44.1240
    //C        Evaluate:   Bm'                                                M44.1241
    //C                                                                       M44.1242
    cnvhst(n4 + 9) = summr - ykm(ioff1 + ky);
    cnvhst(n4 + 10) = summi - ykm(ioff2 + ky);
    cnvhst(n4 + 11) = sumkr + ykm(ioff7 + ky);
    cnvhst(n4 + 12) = sumki + ykm(ioff8 + ky);
    if (iprsup > 0) {
      write(lunit6,
        "('KY,BMR5(KY),BMI5,FKR5,FKI5=',1x,i2,2x,4e14.5)"), ky,
        cnvhst(n4 + 9), cnvhst(n4 + 10), cnvhst(n4 + 11), cnvhst(n4 +
          12);
    }
    ky++;
  }
  //C                                                                       M44.1257
  //C        Evaluate:     imj(to-dt)  ikj(to-dt)                           M44.1258
  //C                                                                       M44.1259
  if (iprsup > 0) {
    write(lunit6,
      "(' BEGIN Qt*Ik,m = Ik,m in phase domain','       k     IBR    NTOT',/,"
      "23x,3i8)"),
      k, ibr, ntot;
  }
  nq1 = namebr(inoff2 + k);
  ka = k;
  kq = namebr(inoff1 + k);
  kqk = namebr(inoff1 + ka);
  kv = namebr(inoff1 + k);
  //C      LJ = KV                              ! 1st pole of Qii for the brM44.  11
  //C      IF ( KV .GT. 1) LJ = ( KV-1 ) * 2 + 1                            M44.  12
  //C      KILINE = LPAST                                  !next cell is freM44.  14
  //C      LJ = KILINE + LJ                                                 M44.  15
  //C      NR(K) = LJ                                                       M44.  16
  lj = nr(k);
  FEM_DO_SAFE(jqa, 1, it2) {
    FEM_DO_SAFE(iqa, 1, it2) {
      nteq = semaux(koff20 + kq);
      sumkr = sconst(nq1) * ykm(ioff7 + ka);
      sumki = sconst(nq1) * ykm(ioff8 + ka);
      summr = sconst(nq1) * ykm(ioff1 + ka);
      summi = sconst(nq1) * ykm(ioff2 + ka);
      if (iprsup > 0) {
        write(lunit6,
          "('JQA NTEQ    NQ1    NQ2    NQ3',' SNT(NQ1) SNT(NQ2)',"
          "' SST(NQ3) AIMR(KA) AIMI(KA)','  HM1(KA)  HK1(KA)    SUMKR',"
          "'    SUMKI    SUMMR    SUMMI')");
      }
      FEM_DO_SAFE(iq, 1, nteq) {
        nq2 = nq1 + iq;
        nq3 = nq2 + nteq;
        if (std::abs(sconst(nq2)) >= 1.e+13f) {
          goto statement_3007;
        }
        d = fem::pow2(omega) + fem::pow2(sconst(nq3));
        ar = sconst(nq2) * sconst(nq3) / d;
        ai = -sconst(nq2) * omega / d;
        goto statement_3008;
      statement_3007:
        jkl++;
        if (jkl == 2) {
          goto statement_3009;
        }
        akr = sconst(nq2) / 1.e+15f;
        aki = sconst(nq2 + 1) / 1.e+15f;
        apr = sconst(nq3) / 1.e+15f;
        api = sconst(nq3 + 1) / 1.e+15f;
        dqq3 = fem::pow2(apr) + fem::pow2((omega + api));
        ar = 2 * (akr * apr + aki * (omega + api)) / dqq3;
        ai = 0.f;
      statement_3008:
        ykm(ioff3 + iq) = ar * ykm(ioff7 + ka) - ai * ykm(ioff8 + ka);
        ykm(ioff4 + iq) = ar * ykm(ioff8 + ka) + ai * ykm(ioff7 + ka);
        ykm(ioff5 + iq) = ar * ykm(ioff1 + ka) - ai * ykm(ioff2 + ka);
        ykm(ioff6 + iq) = ar * ykm(ioff2 + ka) + ai * ykm(ioff1 + ka);
        sumkr += ykm(ioff3 + iq);
        sumki += ykm(ioff4 + iq);
        summr += ykm(ioff5 + iq);
        summi += ykm(ioff6 + iq);
        if (jkl == 1) {
          goto statement_3010;
        }
      statement_3009:
        jkl = 0;
      statement_3010:
        if (iprsup > 0) {
          write(lunit6, "(1x,i2,3x,i2,2x,i5,2x,i5,2x,i5,11e9.3)"),
            jqa, nteq, nq1, nq2, nq3, sconst(nq1), sconst(nq2),
            sconst(nq3), ykm(ioff7 + ka), ykm(ioff8 + ka), ykm(ioff1 + ka),
            ykm(ioff2 + ka), sumkr, sumki, summr, summi;
        }
        nq2++;
        nq3++;
      }
      nq1 += 2 * nteq + 1;
      nteq = semaux(koff20 + kq);
      lj1 = lj + nteq;
      FEM_DO_SAFE(la, 1, nteq) {
        phf = std::atan2(ykm(ioff4 + la), ykm(ioff3 + la));
        hf = fem::dsqrt(fem::pow2(ykm(ioff3 + la)) + fem::pow2(ykm(
          ioff4 + la)));
        xk(lj1) = hf * std::cos(wdt + phf);
        phf = std::atan2(ykm(ioff6 + la), ykm(ioff5 + la));
        hf = fem::dsqrt(fem::pow2(ykm(ioff5 + la)) + fem::pow2(ykm(
          ioff6 + la)));
        xk(lj) = hf * std::cos(wdt + phf);
        lj++;
        lj1++;
      }
      kq++;
      lj += nteq;
    }
    ka++;
  }
  //C                                                                       M44.1329
  //C        Evaluate:   Fmj' = A1j * Fk'  => fmj'(to), fm'(to)             M44.1330
  //C                    Bkj' = A1j * Bm'  => bkj'(to), bk'(to)             M44.1331
  //C                                                                       M44.1332
  //C      CALL FJ(FKR5(I),FKI5(I),FMJ5(IADRS),FMJI5(IADRS),FM5(I),SUMKI    M44.1333
  //C     1       ,BMR5(I),BMI5(I),BKJ5(IADRS),BKJI5(IADRS),BK5(I),SUMMI    M44.1334
  //C     2       ,API(IADRS),AKI(IADRS),W,NTEA,TAU(I),0.D0)                M44.1335
  ka = k;
  iadrs = 1;
  jkl = 0;
  FEM_DO_SAFE(ifa, 1, it2) {
    n4 = indhst(ka);
    taua = cnvhst(n4);
    ejwtr = std::cos(omega * taua);
    ejwti = -std::sin(omega * taua);
    sumkr = 0.e0;
    sumki = 0.e0;
    summr = 0.e0;
    summi = 0.e0;
    n1 = kodsem(ka);
    nrz = cki(ka);
    nra = ckkjm(ka);
    if (iprsup > 0) {
      write(lunit6,
        "(' NK7  NRA  API(IADRS)','       CZIRE       CZIIM            ',"
        "'  AKI(IADRS)    FKR5(KA)    FKI5(KA)',/,"
        "'    BMR5(KA)    BMI5(KA) FMJ5(IADRS)',"
        "' BKJ5(IADRS)     FM5(II)     BK5(II)')");
    }
    FEM_DO_SAFE(ii, 1, nra) {
      n2 = n1 + 2 * nrz + ii;
      n3 = n2 + nra;
      nk1 = n1 + 5 * nra + 5 * nrz + 4 + 1;
      nn17 = sconst(nk1);
      nn5 = n1 + 7 * nrz + 5 * nra + 8 + ii + 1 + nn17;
      nn6 = nn5 + nra;
      if (fem::abs(sconst(n2)) >= 1.e13f) {
        goto statement_4338;
      }
      d1 = fem::pow2(sconst(n3)) + fem::pow2(omega);
      czire = sconst(n2) * sconst(n3) / d1;
      cziim = -sconst(n2) * omega / d1;
      goto statement_4337;
    statement_4338:
      jkl++;
      if (jkl == 2) {
        goto statement_5486;
      }
      nk7 = n1 + 7 * nra + 7 * nrz + 9 + nn17 + ii;
      nk8 = nk7 + nra;
      akr = sconst(n2) / 1.e+15f;
      aki = sconst(n2 + 1) / 1.e+15f;
      apr = sconst(n3) / 1.e+15f;
      api = sconst(n3 + 1) / 1.e+15f;
      dkr = apr * akr - api * aki;
      dki = apr * aki + api * akr;
      akr = dkr;
      aki = dki;
      djk3 = fem::pow2(apr) + fem::pow2((omega + api));
      ddd3 = (akr * apr + aki * (omega + api)) / djk3;
      ddd4 = (aki * apr - akr * (omega + api)) / djk3;
      djk4 = fem::pow2(apr) + fem::pow2((omega - api));
      ccc3 = (akr * apr - aki * (omega - api)) / djk4;
      ccc4 = (akr * (omega - api) + aki * apr) / djk4;
      czire = ddd3 + ccc3;
      cziim = ddd4 - ccc4;
      czire = ddd3;
      cziim = ddd4;
    statement_4337:
      ykm(ioff3 + ii) = czire * cnvhst(n4 + 11) - cziim * cnvhst(n4 + 12);
      ykm(ioff4 + ii) = czire * cnvhst(n4 + 12) + cziim * cnvhst(n4 + 11);
      ykm(ioff5 + ii) = czire * cnvhst(n4 + 9) - cziim * cnvhst(n4 + 10);
      ykm(ioff6 + ii) = czire * cnvhst(n4 + 10) + cziim * cnvhst(n4 + 9);
      ar = ykm(ioff3 + ii) * ejwtr - ykm(ioff4 + ii) * ejwti;
      ai = ykm(ioff3 + ii) * ejwti + ykm(ioff4 + ii) * ejwtr;
      ykm(ioff3 + ii) = ar;
      ykm(ioff4 + ii) = ai;
      sconst(nn5) = ar;
      ar = ykm(ioff5 + ii) * ejwtr - ykm(ioff6 + ii) * ejwti;
      ai = ykm(ioff5 + ii) * ejwti + ykm(ioff6 + ii) * ejwtr;
      ykm(ioff5 + ii) = ar;
      ykm(ioff6 + ii) = ai;
      sconst(nn6) = ar;
      sumkr += ykm(ioff3 + ii);
      sumki += ykm(ioff4 + ii);
      summr += ykm(ioff5 + ii);
      summi += ykm(ioff6 + ii);
      if (iprsup > 0) {
        write(lunit6, "(1x,i3,2x,i3,6e16.7,/,9x,6e16.7)"), nk7, nra,
          sconst(n3), sconst(n2), czire, cziim, cnvhst(n4 + 11),
          cnvhst(n4 + 12), cnvhst(n4 + 9), cnvhst(n4 + 10), sconst(nn5),
          sconst(nn6), sumkr, summr;
      }
      if (jkl == 1) {
        goto statement_1028;
      }
    statement_5486:
      jkl = 0;
    statement_1028:;
    }
    semaux(cmn.koff3 + ka) = sumkr;
    semaux(cmn.koff4 + ka) = summr;
    ka++;
    if (iprsup > 0) {
      write(lunit6, star), " Fmj = A1j * Fk; Bkj = A1j * Bm";
    }
    if (iprsup > 0) {
      write(lunit6, star), " SUMKR, jSUMKI, SUMMR, jSUMMI ", sumkr,
        sumki, summr, summi;
    }
  }
  //C                                                                       M44.1402
  //C        Fill up history vectors: bm'(history)                          M44.1403
  //C                                 fk'(history)                          M44.1404
  //C                                                                       M44.1405
  ka = k;
  if (kmode == 5) {
    koff11 = kcbl;
  }
  if (koff11 < lhist) {
    goto statement_1114;
  }
  write(lunit6, format_5340), lhist, koff11;
  write(lunit6, star), " Nearby statement number is 1114. ";
  FEM_STOP(0);
  //C
statement_1114:
  FEM_DO_SAFE(ifa, 1, it2) {
    nn4 = indhst(ka);
    taui = cnvhst(nn4);
    ntaui = taui / deltat + 1;
    //C      CALL FILLUP(CNVHST(NN4+11),CNVHST(NN4+12),FKH5(IADRS)            M44.1414
    //C     1           ,CNVHST(NN4+9), CNVHST(NN4+10),BMH5(IADRS)            M44.1415
    //C     2           ,OMEGA,WDT,NTAUI,TAUI)                                M44.1416
    //C      CALL FILLUP(FKR5(IFA),FKI5(IFA),FKH5(IADRS)                      M44.1417
    //C     1           ,BMR5(IFA),BMI5(IFA),BMH5(IADRS)                      M44.1418
    //C     2           ,W,WDT,NTAUI,TAUI)                                    M44.1419
    n1 = ntaui - 1;
    amagk = fem::dsqrt(fem::pow2(cnvhst(nn4 + 11)) + fem::pow2(cnvhst(
      nn4 + 12)));
    amagm = fem::dsqrt(fem::pow2(cnvhst(nn4 + 9)) + fem::pow2(cnvhst(
      nn4 + 10)));
    angk = std::atan2(cnvhst(nn4 + 12), cnvhst(nn4 + 11));
    angm = std::atan2(cnvhst(nn4 + 10), cnvhst(nn4 + 9));
    wd = wdt;
    koff11 += 0;
    koff12 = koff11 + ntaui;
    FEM_DO_SAFE(i, 1, n1) {
      semaux(koff11 + i) = amagk * std::cos(wd + angk);
      semaux(koff12 + i) = amagm * std::cos(wd + angm);
      wd += wdt;
    }
    semaux(koff11 + ntaui) = amagk * std::cos(-omega * taui + angk);
    semaux(koff12 + ntaui) = amagm * std::cos(-omega * taui + angm);
    if (iprsup > 0) {
      write(lunit6,
        "(/,' FORWARD FUNCTIONS FKHIST AND BMHIST; POSITIONS','   1','  TO',"
        "i6)"),
        ntaui;
    }
    if (iprsup > 0) {
      {
        write_loop wloop(cmn, 6, "(1x,10e12.5)");
        FEM_DO_SAFE(i, 1, ntaui) {
          wloop, semaux(koff11 + i);
        }
        FEM_DO_SAFE(i, 1, ntaui) {
          wloop, semaux(koff12 + i);
        }
      }
    }
    if (iprcbl > 0) {
      write(lunit6, star), "KA,FKR5(KA),FKI5(KA),FKH5(IADRS)=", ka,
        cnvhst(nn4 + 11), cnvhst(nn4 + 12), semaux(koff11 + ntaui);
    }
    if (iprcbl > 0) {
      write(lunit6, star),
        "BMR5(KA),BMI5(KA),BMH5(IADRS),WDT,NTAUI=", cnvhst(nn4 + 9),
        cnvhst(nn4 + 10), semaux(koff12 + ntaui), wdt, ntaui;
    }
    ka++;
    koff12 += ntaui;
    koff11 = koff12;
  }
  kcbl = koff11;
  if (koff11 < lhist) {
    goto statement_6258;
  }
  write(lunit6, format_5340), lhist, koff11;
  write(lunit6, star), " Nearby statement number is 6258. ";
  FEM_STOP(0);
  //C
statement_6258:
  if (koff11 > koff25 + 288) {
    kmode = 5;
  }
  k += it2 - 1;
  itadd += it2 + (it2 - 1) * it2 / 2;
  goto statement_547;
  //C                                                                       M44.1465
statement_60001:
  it2 = fem::iabs(n4);
  aph = it2;
  nl = litype(k);
  if (istead == 0) {
    goto statement_60005;
  }
  //C     INITIAL CONDITIONS FROM STEADY-STATE                              M31.2805
  //C        CONVERT TO MODE QUANTITIES                                     M31.2806
statement_61594:
  n9 = it2 * it2;
  j = nl - 1;
  FEM_DO_SAFE(i, 1, n9) {
    j++;
    volt(i) = qfd(j);
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, format_3438);
      FEM_DO_SAFE(L, 1, n9) {
        wloop, volt(L);
      }
    }
  }
  move0(volti, n9);
  n10 = 1;
  n12 = it2 + 1;
  FEM_DO_SAFE(L, 1, it2) {
    volti(n10) = 1.0f;
    n10 += n12;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' UNIT MATRIX.  VOLTI(1:N9) ...',/(1x,5e25.16))");
      FEM_DO_SAFE(L, 1, n9) {
        wloop, volti(L);
      }
    }
  }
  dgelg(volti(1), volt(1), it2, it2, epsiln, ier);
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, format_3471);
      wloop, ier;
      FEM_DO_SAFE(m, 1, n9) {
        wloop, volti(m);
      }
    }
  }
  n5 = nl - 1;
  iy = k;
  iz = itadd;
  FEM_DO_SAFE(i, 1, it2) {
    n7 = iy;
    n8 = iz;
    vsl = 0.0f;
    vsli = 0.0f;
    vsr = 0.0f;
    vsri = 0.0f;
    csl = 0.0f;
    csli = 0.0f;
    csr = 0.0f;
    csri = 0.0f;
    FEM_DO_SAFE(j, 1, it2) {
      n1 = fem::iabs(kbus(n7));
      n2 = fem::iabs(mbus(n7));
      n5++;
      h1 = qfd(n5);
      vsl += h1 * e(n1);
      vsli += h1 * f(n1);
      vsr += h1 * e(n2);
      vsri += h1 * f(n2);
      n6 = i + (j - 1) * it2;
      h2 = volti(n6);
      csl += h2 * tr(n8);
      csli += h2 * tx(n8);
      csr += h2 * r(n8);
      csri += h2 * c(n8);
      n7++;
      n8++;
      if (i != 1) {
        goto statement_62595;
      }
      if (iprsup <= 5) {
        goto statement_62595;
      }
      write(lunit6,
        "(/,' INITIAL PHASE VALUES, MARTI''S BRANCH',i4,8e11.4)"), j,
        e(n1), f(n1), e(n2), f(n2), tr(n8), tx(n8), r(n8), c(n8);
    statement_62595:;
    }
    if (iprsup >= 5) {
      write(lunit6,
        "(/,' INITIAL MODAL VALUES, MARTI''S BRANCH',i4,8e11.4)"), i,
        vsl, vsli, vsr, vsri, csl, csli, csr, csri;
    }
    omegs1 = omega;
    if (istead == 0) {
      omegs1 = 0.0f;
    }
    n4 = indhst(k);
    cnvhst(n4 + 5) = csl;
    cnvhst(n4 + 6) = csr;
    n1 = kodsem(k);
    nrz = cki(k);
    nra = ckkjm(k);
    FEM_DO_SAFE(ii, 1, nrz) {
      n2 = n1 + ii;
      n3 = n2 + nrz;
      d1 = fem::pow2(sconst(n3)) + fem::pow2(omegs1);
      czire = sconst(n2) * sconst(n3) / d1;
      cziim = -sconst(n2) * omegs1 / d1;
      nn5 = n1 + 5 * nrz + 5 * nra + 4 + ii;
      sconst(nn5) = csl * czire - csli * cziim;
      n6 = nn5 + nrz;
      sconst(n6) = csr * czire - csri * cziim;
    }
    if (iprsup < 1) {
      goto statement_81108;
    }
    write(lunit6,
      "(/,' INITIALIZATION OF HISTORY VECTORS OF MARTI''S BRANCH ',i4,"
      "'  NODE K, NODE M',' PARTIAL EQUIV. VOLTAGES')"),
      i;
    j1 = nn5 - nrz + 1;
    j2 = n6 - nrz + 1;
    {
      write_loop wloop(cmn, lunit6, format_81107);
      FEM_DO_SAFE(ii, j1, nn5) {
        wloop, sconst(ii);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_81107);
      FEM_DO_SAFE(ii, j2, n6) {
        wloop, sconst(ii);
      }
    }
    //C     FORWARD PERTURBATION FUNCTIONS  (F)                               M31.2889
  statement_81108:
    ckreal = vsl + cnvhst(n4 + 1) * csl - cnvhst(n4 + 2) * csli;
    ckimag = vsli + cnvhst(n4 + 1) * csli + cnvhst(n4 + 2) * csl;
    absfk = sqrtz(fem::pow2(ckreal) + fem::pow2(ckimag));
    phfk = funp13(ckimag, ckreal, twopi);
    cmreal = vsr + cnvhst(n4 + 1) * csr - cnvhst(n4 + 2) * csri;
    cmimag = vsri + cnvhst(n4 + 1) * csri + cnvhst(n4 + 2) * csr;
    absfm = sqrtz(fem::pow2(cmreal) + fem::pow2(cmimag));
    phfm = funp13(cmimag, cmreal, twopi);
    nrf = cnvhst(n4) / deltat + 2.f;
    nr(k) = iline + 1;
    iline += 1 + nrf;
    if (iline <= lpast) {
      goto statement_8109;
    }
    iprint = 8;
    lstat(19) = 8109;
    goto statement_9000;
  statement_8109:
    FEM_DO_SAFE(ii, 1, nrf) {
      ix = nr(k) + ii - 1;
      xk(ix) = absfk * cosz((-nrf + ii) * omegs1 * deltat + phfk);
      xm(ix) = absfm * cosz((-nrf + ii) * omegs1 * deltat + phfm);
    }
    if (iprsup < 1) {
      goto statement_81113;
    }
    j1 = ix - nrf + 1;
    write(lunit6,
      "(/,' FORWARD FUNCTIONS XK AND XM; POSITIONS',i6,'  TO',i6)"),
      j1, ix;
    {
      write_loop wloop(cmn, lunit6, format_81107);
      FEM_DO_SAFE(ii, j1, ix) {
        wloop, xk(ii);
      }
      FEM_DO_SAFE(ii, j1, ix) {
        wloop, xm(ii);
      }
    }
    //C     HISTORY OF PARTIAL EQUIVALENT CURRENT SOURCES  (B)                M31.2914
  statement_81113:
    d9 = -omegs1 * cnvhst(n4);
    c2r = cosz(d9);
    c2i = sinz(d9);
    FEM_DO_SAFE(ii, 1, nra) {
      n2 = n1 + 2 * nrz + ii;
      n3 = n2 + nra;
      d1 = fem::pow2(sconst(n3)) + fem::pow2(omegs1);
      c3r = sconst(n2) * sconst(n3) / d1;
      c3i = -sconst(n2) * omegs1 / d1;
      n7 = n1 + 7 * nrz + 5 * nra + 4 + ii;
      d2 = c2r * c3r - c2i * c3i;
      d3 = c2r * c3i + c2i * c3r;
      sconst(n7) = d2 * cmreal - d3 * cmimag;
      n8 = n7 + nra;
      sconst(n8) = d2 * ckreal - d3 * ckimag;
    }
    if (iprsup < 1) {
      goto statement_63593;
    }
    j1 = n7 - nra + 1;
    j2 = n8 - nra + 1;
    write(lunit6, "(/,' PARTIAL EQUIV. CURRENT SOURCES')");
    {
      write_loop wloop(cmn, lunit6, format_81107);
      FEM_DO_SAFE(ii, j1, n7) {
        wloop, sconst(ii);
      }
      FEM_DO_SAFE(ii, j2, n8) {
        wloop, sconst(ii);
      }
    }
  statement_63593:
    k++;
    itadd++;
  }
  itadd += it2 * (it2 - 1) / 2;
  it1 = 0;
  k = k - 1;
  if (istead > 0) {
    goto statement_547;
  }
  goto statement_544;
  //C                                                                       M44.1466
  //C        USER-SUPPLIED D.C. CONDITIONS                                  M31.2946
  //C        SINGLE PHASE LINES                                             M31.2947
statement_60005:
  n1 = fem::iabs(kbus(k));
  n2 = fem::iabs(mbus(k));
  tr(itadd) = ci1;
  tx(itadd) = 0.0f;
  r(itadd) = a;
  c(itadd) = 0.0f;
  f(n1) = 0.0f;
  f(n2) = 0.0f;
  omegs1 = 0.0f;
  if (n4 >= 0) {
    goto statement_61594;
  }
  //C        MULTIPHASE LINES                                               M31.2958
  ix = itadd;
  FEM_DO_SAFE(i1, 2, it2) {
    ii = k + i1 - 1;
    if (nr(ii) < 0) {
      it1 = 1;
    }
    L = -kbus(ii);
    m = mbus(ii);
    //C     READ INPUT CARD USING CIMAGE                                      M31.2965
    cimage(cmn);
    read(abuff, "(i2,2a6,4e15.8)"), n3, bus1, bus2, h1, h2, ci1, ck1;
    write(lunit6, "(' ',a6,1x,a6,4e13.5)"), bus1, bus2, h1, h2, ci1, ck1;
    if (bus(L) != bus1 || bus(m) != bus2) {
      stoptp(cmn);
    }
    ix++;
    tr(ix) = h1;
    tx(ix) = 0.0f;
    r(ix) = ci1;
    c(ix) = 0.0f;
    f(L) = 0.0f;
    f(m) = 0.0f;
  }
  marti = 1;
  goto statement_61594;
statement_578:
  curr1 = ci1;
  curi1 = ck1;
  curr2 = a;
  curi2 = d2;
  //C                                                                       M44.1467
  //C                         Meyer_line with groung wire FD goes through heM44.1468
  //C                                                                       M44.1469
statement_579:
  vr1 = e(n1);
  vi1 = f(n1);
  vr2 = e(n2);
  vi2 = f(n2);
  it2 = iabsz(n4);
  yx = it2;
  gus3 = vr1;
  bi3 = vi1;
  gus4 = vr2;
  bi4 = vi2;
  vsl = curr1;
  vsli = curi1;
  vsr = curr2;
  vsri = curi2;
  it1 = 0;
  //C     TRANSFORMATION OF INITIAL CONDITIONS FROM PHASE TO MODAL          M29.1740
  //C     QUANTITIES                                                        M29.1741
  nl = litype(k);
  FEM_DO_SAFE(i, 1, it2) {
    n7 = k + i - 1;
    L = kbus(n7);
    L = fem::iabs(L);
    m = mbus(n7);
    ii = itadd + i - 2;
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' NEXT CONDUCTOR.','       I       L       M       K',/,16x,4i8,/,"
        "16x,14x,'YX',11x,'CI(K)',12x,'E(L)',12x,'E(M)',10x,'TR(II)',11x,"
        "'R(II)',/,16x,6e16.7)"),
        i, L, m, k, yx, ci(k), e(L), e(m), tr(ii), r(ii);
    }
  }
  iprint = 3;
  itadd = isd;
  nl1 = nl + it2 * it2 - 1;
  FEM_DO_SAFE(i, 1, it2) {
    ii = k + i - 1;
    if (nr(ii) < 0) {
      it1 = 1;
    }
    L = -kbus(ii);
    m = mbus(ii);
    if (istead > 0) {
      goto statement_594;
    }
    if (i == 1) {
      goto statement_599;
    }
    //C     READ INPUT CARD USING CIMAGE                                      M29.1753
    cimage(cmn);
    read(abuff, format_7020), n3, bus1, bus2, ci1, ck1, a, d2;
    write(kunit6, "('+STEADY STATE INITIAL CONDITIONS')");
    if (bus(L) != bus1 || bus(m) != bus2) {
      goto statement_9020;
    }
  statement_599:
    if (itadd > cmn.ldata) {
      goto statement_9000;
    }
    tr(itadd) = ci1;
    tx(itadd) = ck1;
    r(itadd) = a;
    c(itadd) = d2;
  statement_594:
    itadd++;
    a = ci(ii);
    d2 = std::abs(ck(ii));
    if (a < 0.f) {
      a = -a * d2;
    }
    d2 = d2 / yx;
    volti(i) = -a / d2;
    ekreal(i) = e(m);
    ekimag(i) = f(m);
    emreal(i) = e(L);
    emimag(i) = f(L);
  }
  if (iprsup < 1) {
    goto statement_1594;
  }
  n2 = itadd - 1;
  write(lunit6, "(' NL, ISD, N2 AND IT2 AT 1593 ARE',4i10)"), nl, isd, n2, it2;
  {
    write_loop wloop(cmn, lunit6,
      "(' (TR(I), TX(I), R(I), C(I), I=ISD,N2) ARE',/(1x,8e15.6))");
    FEM_DO_SAFE(i, isd, n2) {
      wloop, tr(i), tx(i), r(i), c(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(' (EKREAL(I), EKIMAG(I), EMREAL(I), EMIMAG(I), I=1,IT2) ARE',/(1x,"
      "8e15.6))");
    FEM_DO_SAFE(i, 1, it2) {
      wloop, ekreal(i), ekimag(i), emreal(i), emimag(i);
    }
  }
statement_1594:
  FEM_DO_SAFE(jj, 1, it2) {
    ii = k + jj - 1;
    if (ck(ii) < 0.0f) {
      goto statement_21594;
    }
  }
  goto statement_4594;
statement_21594:
  n9 = it2 * it2;
  j = nl - 1;
  FEM_DO_SAFE(i, 1, n9) {
    j++;
    volt(i) = qfd(j);
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, format_3438);
      FEM_DO_SAFE(L, 1, n9) {
        wloop, volt(L);
      }
    }
  }
  move0(voltk, n9);
  n10 = 1;
  n12 = it2 + 1;
  FEM_DO_SAFE(L, 1, it2) {
    voltk(n10) = 1.0f;
    n10 += n12;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' UNIT MAXTRIX.  VOLTK(1:N9) ...',/(1x,5e25.16))");
      FEM_DO_SAFE(L, 1, n9) {
        wloop, voltk(L);
      }
    }
  }
  dgelg(voltk(1), volt(1), it2, it2, epsiln, ier);
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, format_3471);
      wloop, ier;
      FEM_DO_SAFE(m, 1, n9) {
        wloop, voltk(m);
      }
    }
  }
  n5 = nl - 1;
  n7 = isd;
  FEM_DO_SAFE(i, 1, it2) {
    vsl = 0.0f;
    vsr = 0.0f;
    csl = 0.0f;
    csr = 0.0f;
    FEM_DO_SAFE(j, 1, it2) {
      n5++;
      h1 = qfd(n5);
      vsl += h1 * ekreal(j);
      vsr += h1 * emreal(j);
      n6 = i + (j - 1) * it2;
      h2 = voltk(n6);
      csl += h2 * r(n7);
      csr += h2 * tr(n7);
      n7++;
    }
    closev(i) = vsr;
    farv(i) = vsl;
    closei(i) = csr;
    fari(i) = csl;
    n7 = isd;
  }
  //C**** COMPLEX VOLTAGE & CURRENT VECTORS ARE STORED IN EKREAL,EKIMAG,    M29.1786
  //C     EMREAL,EMIMAG AND TR,TX,R,C                                       M29.1787
statement_4594:
  n6 = isd - 1;
  FEM_DO_SAFE(i, 1, it2) {
    FEM_DO_SAFE(j, 1, i) {
      gus1 = 0.f;
      n5 = nl - 1;
      FEM_DO_SAFE(ip, 1, it2) {
        jip = n5 + j;
        iip = n5 + i;
        gus1 += qfd(jip) * volti(ip) * qfd(iip);
        n5 += it2;
      }
      n6++;
      x(n6) = gus1;
    }
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(' AT 1595 X(I) FROM I = ',i8,3x,'TO ',i8,3x,'ARE',/(1x,8e15.6))");
      wloop, isd, n6;
      FEM_DO_SAFE(i, isd, n6) {
        wloop, x(i);
      }
    }
  }
  isd1 = isd + it2 * (it2 + 1) / 2 - 1;
  ll0 = 0;
  redu13(x(isd), it2, ll0);
  ll1 = 1;
  mult(x(isd), tr(isd), emreal, it2, ll1);
  mult(x(isd), tx(isd), emimag, it2, ll1);
  mult(x(isd), r(isd), ekreal, it2, ll1);
  mult(x(isd), c(isd), ekimag, it2, ll1);
  //C**** Y=AX+Y IS OBTAINED FOR SIDE M,K IN REAL AND IMAG                  M29.1812
  n5 = nl - 1;
  FEM_DO_SAFE(i, 1, it2) {
    vsl = 0.f;
    vsli = 0.f;
    vsr = 0.f;
    vsri = 0.f;
    ii = k + i - 1;
    a = ci(ii);
    if (a < 0.f) {
      a = -a * ck(ii);
    }
    a = a * yx;
    FEM_DO_SAFE(j, 1, it2) {
      n5++;
      h1 = qfd(n5);
      vsl += h1 * ekreal(j);
      vsli += h1 * ekimag(j);
      vsr += h1 * emreal(j);
      vsri += h1 * emimag(j);
    }
    volti(i) = sqrtz(vsl * vsl + vsli * vsli) * a;
    if (volti(i) == 0.f) {
      vsl = 1.f;
    }
    volt(i) = std::atan2(vsli, vsl);
    voltk(i) = sqrtz(vsr * vsr + vsri * vsri) * a;
    if (voltk(i) == 0.f) {
      vsr = 1.f;
    }
    ndx1 = lsiz26 + i;
    volt(ndx1) = std::atan2(vsri, vsr);
  }
  //C *** END OF TRANSFORMATION FOR INITIAL CONDITIONS                      M29.1836
  ii = length(k + 1);
  if (length(k) > 0) {
    ii = length(k);
  }
  itadd += it2 * (it2 - 1) / 2;
  if (istead <= 0) {
    itadd = it + 1;
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(' (VOLTI(I),VOLT(I), VOLTK(I),             I=1,IT2) ARE',/(1x,"
        "6e20.10))");
      FEM_DO_SAFE(i, 1, it2) {
        wloop, volti(i), volt(i), voltk(i);
      }
    }
  }
  ndx1 = lsiz26 + 1;
  ndx2 = lsiz26 + it2;
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6, "(' VIM(LSIZ26+I):',6e19.10)");
      FEM_DO_SAFE(i, ndx1, ndx2) {
        wloop, volt(i);
      }
    }
  }
  k = k - 1;
  i = 0;
statement_5019:
  i++;
  k++;
  h1 = volti(i);
  h2 = voltk(i);
  ci1 = volt(i);
  ndx1 = lsiz26 + i;
  ck1 = volt(ndx1);
  n4 = nr(k) + 1;
  n2 = ii + n4;
  gus1 = -n4;
  gus1 = gus1 * steady;
  gus4 = gus1 + (1.0f - cik(k)) * steady;
  FEM_DO_SAFE(n1, ii, n2) {
    a = h1 * cosz(gus1 + ci1);
    d2 = h2 * cosz(gus1 + ck1);
    gus1 += steady;
    xk(n1) = a;
    xm(n1) = d2;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' ONE MODE PAST HISTORY  (XK(J), XM(J), J=II, N2)  FOLLOWS.',"
        "'       K KBUS(K) MBUS(K)      II      N2     IT2',/,58x,6i8,/(1x,"
        "8e16.7))");
      wloop, k, kbus(k), mbus(k), ii, n2, it2;
      FEM_DO_SAFE(n1, ii, n2) {
        wloop, xk(n1), xm(n1);
      }
    }
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(' PHASOR QUANTITIES USED.',14x,'H1',14x,'H2',13x,'CI1',13x,'CK1',10x,"
      "'STEADY',/,24x,5e16.7)"),
      h1, h2, ci1, ck1, steady;
  }
  if (ck(k) < 0) {
    goto statement_20750;
  }
  a = h1 * cosz(gus4 + ci1);
  d2 = h2 * cosz(gus4 + ck1);
  if (ci(k) < 0.f) {
    goto statement_584;
  }
  ci1 = (ck(k) + 1.0f) / 2.0f;
  ck1 = 1.0f - ci1;
  xk(n2) = ci1 * a + ck1 * d2;
  xm(n2) = ci1 * d2 + ck1 * a;
  goto statement_583;
statement_20750:
  kf = cik(k);
  ifdep2 = kf + kf - 1;
  a = 0.0f;
  d7 = h2;
  d8 = ck1;
  d9 = h1;
  d10 = ci1;
statement_20755:
  d3 = con1(ifdep2);
  d4 = con1(ifdep2 + 2 * lfdep);
  d5 = con1(ifdep2 + 4 * lfdep);
  iftail++;
  if (iftail <= ltails) {
    goto statement_20762;
  }
  iprint = 15;
  lstat(19) = 20762;
  goto statement_9000;
statement_20762:
  d6 = omega * d5;
  d2 = d3 / (d4 * d4 + omega * omega);
  d3 = d2 * omega;
  d4 = d2 * d4;
  d8 = d8 - d6;
  d10 = d10 - d6;
  stailk(iftail) = d7 * (d4 * cosz(d8) + d3 * sinz(d8));
  stailm(iftail) = d9 * (d4 * cosz(d10) + d3 * sinz(d10));
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' EXP. TAIL HISTORY.','  IFDEP2  IFTAIL       K',6x,"
      "'STAILK(IFTAIL)',6x,'STAILM(IFTAIL)',14x,'D2',14x,'D3',/,19x,3i8,"
      "2e20.11,2e16.7,/,19x,14x,'D4',14x,'D5',14x,'D6',14x,'D7',14x,'D8',14x,"
      "'D9',13x,'D10',/,19x,7e16.7)"),
      ifdep2, iftail, k, stailk(iftail), stailm(iftail), d2, d3, d4,
      d5, d6, d7, d8, d9, d10;
  }
  if (a > 0.0f) {
    goto statement_20775;
  }
  a = 1.0f;
  d7 = h1;
  d8 = ci1;
  d9 = h2;
  d10 = ck1;
  ifdep2++;
  goto statement_20755;
  //C      M22.452220775 IF ( IT2  .EQ.  1 )   GO TO 20700                  M30. 351
statement_20775:
  d7 = ci(k) * yx / eta(kf);
  a = d7 * closev(i) - closei(i);
  d2 = d7 * farv(i) - fari(i);
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' FREQ. DEP. LAST HISTORY POINT.',"
      "'       K       I  IFDEP2  IFTAIL',7x,'CLOSEV(I)',9x,'FARV(I)',7x,"
      "'CLOSEI(I)',/,31x,4i8,3e16.7,/,31x,9x,'FARI(I)',11x,'CI(K)',15x,'A',"
      "14x,'D2',/,31x,4e16.7)"),
      k, i, ifdep2, iftail, closev(i), farv(i), closei(i), fari(i), ci(k),
      a, d2;
  }
statement_584:
  xk(n2) = a;
  xm(n2) = d2;
statement_583:
  ii = n2 + 1;
  if (i < it2) {
    goto statement_5019;
  }
  if (istead > 0) {
    goto statement_547;
  }
  goto statement_544;
statement_5750:
  it2 = fem::iabs(kodebr(k));
  n11 = k + it2 - 1;
  if (istead > 0) {
    goto statement_5862;
  }
  itadd = nr(k) - 1;
  it = itadd;
  //C     READ INPUT CARD USING CIMAGE                                      M21. 174
  cimage(cmn);
  FEM_DO_SAFE(i, 1, it2) {
    ii = k + i - 1;
    itadd++;
    if (i != 1) {
      goto statement_5763;
    }
    tr(itadd) = ci1;
    tx(itadd) = ck1;
    r(itadd) = a;
    c(itadd) = d2;
    goto statement_5759;
  statement_5763:
    m = fem::iabs(mbus(ii));
    L = fem::iabs(kbus(ii));
    if (kolbeg > 0) {
      goto statement_4693;
    }
    if (kolbeg > 0) {
      goto statement_4693;
    }
    read(abuff, format_7020), n3, bus1, bus2, tr(itadd), tx(itadd), r(itadd),
      c(itadd);
    goto statement_4695;
  statement_4693:
    nfrfld = 1;
    kolbeg = 1;
    freone(cmn, d11);
    n3 = d11;
    nright = -1;
    freone(cmn, d1);
    bus1 = texta6(1);
    freone(cmn, d1);
    bus2 = texta6(1);
    nright = 0;
    frefld(cmn, tr(itadd));
    frefld(cmn, tx(itadd));
    frefld(cmn, r(itadd));
    frefld(cmn, c(itadd));
  statement_4695:
    if (noutpr == 0) {
      write(kunit6, format_54159), tr(itadd), tx(itadd), r(itadd);
    }
    if (bus1 == bus(L) && bus2 == bus(m) && n3 == 3) {
      goto statement_5767;
    }
  statement_5766:
    lstat(19) = 5766;
    kill = 32;
    goto statement_9200;
    //C     READ INPUT CARD USING CIMAGE                                      M21. 175
  statement_5767:
    cimage(cmn);
  statement_5759:
    if (kolbeg > 0) {
      goto statement_4703;
    }
    read(abuff, format_7020), n3, bus1, bus2;
    goto statement_4705;
  statement_4703:
    nfrfld = 1;
    freone(cmn, d11);
    n3 = d11;
    nright = -1;
    freone(cmn, d1);
    bus1 = texta6(1);
    freone(cmn, d1);
    bus2 = texta6(1);
    nright = 0;
  statement_4705:
    if (bus1 != text1) {
      goto statement_5755;
    }
    if (bus2 != text2) {
      goto statement_5755;
    }
    if (n3 != i) {
      goto statement_5766;
    }
    read(abuff, "(14x,4e15.8)"), ci1, ck1, a, d2;
    write(kunit6, "('+MODAL Z AND Y.  ',3e11.4)"), ci1, ck1, d2;
    //C     READ INPUT CARD USING CIMAGE                                      M22.4562
    cimage(cmn);
    n3 = fem::iabs(indhst(ii));
    if (ci(ii) > 0.0f) {
      n3++;
    }
    cnvhst(n3 + 0) = ci1;
    cnvhst(n3 + 1) = ck1;
    cnvhst(n3 + 2) = a;
    cnvhst(n3 + 3) = d2;
    cnvhst(n3 + 4) = steady / deltat;
  statement_5755:;
  }
  itadd = it + 1;
statement_5862:
  FEM_DO_SAFE(i, k, n11) {
    if (indhst(i) > 0) {
      indhst(i) = -indhst(i);
    }
  }
  itadd += it2 * (it2 + 1) / 2;
statement_5809:
  if (cki(k) < 0.0f) {
    goto statement_5810;
  }
  k++;
  goto statement_5809;
statement_5810:
  if (istead == 0) {
    goto statement_5758;
  }
  goto statement_547;
  //C     INITIAL CONDITION INPUT FOR EMTP SWITCH COMPONENT.                M20.3888
statement_5600:
  if (kolbeg > 0) {
    goto statement_4713;
  }
  read(abuff, "(2x,2a6,3i4,4e13.6)"), bus1, bus2, n1, n2, n3, d1, d2, d3, d4;
  goto statement_4715;
statement_4713:
  nfrfld = 1;
  nright = -1;
  freone(cmn, d1);
  bus1 = texta6(1);
  freone(cmn, d1);
  bus2 = texta6(1);
  nright = 0;
  freone(cmn, d11);
  n1 = d11;
  freone(cmn, d11);
  n2 = d11;
  freone(cmn, d11);
  n3 = d11;
  freone(cmn, d1);
  freone(cmn, d2);
  freone(cmn, d3);
  freone(cmn, d4);
statement_4715:
  if (noutpr == 0) {
    write(kunit6, "('+SWITCH INIT. COND.',3i6,e13.4)"), n1, n2, n3, d1;
  }
  FEM_DO_SAFE(k, 1, cmn.kswtch) {
    L = fem::iabs(kmswit(k));
    ndx1 = cmn.lswtch + k;
    m = fem::iabs(kmswit(ndx1));
    if (bus1 != bus(L)) {
      goto statement_5630;
    }
    if (bus2 == bus(m)) {
      goto statement_5640;
    }
  statement_5630:;
  }
  kill = 31;
  lstat(19) = 5630;
  goto statement_9200;
statement_5640:
  tclose(k) = d1;
  iflag = 0;
  adelay(k) = d2;
  energy(k) = d3;
  crit(k) = d4;
  kpos(k) = n1;
  kode(L) = n2;
  kode(m) = n3;
  //C     READ INPUT CARD USING CIMAGE                                      M32.4324
  cimage(cmn);
  read(abuff, "(14x,i4)"), nextsw(k);
  if (noutpr == 0) {
    write(kunit6, "('+  CONTINUE.  NEXTSW =',i4)"), nextsw(k);
  }
  goto statement_544;
  //C     TRANSFER CONTROL TO 2ND HALF OF OVERLAY 13, IN "LAST13".          M29.1859
statement_590:
  if (marti == 1) {
    goto statement_4590;
  }
  FEM_DO_SAFE(kj, 1, ibr) {
    if (imodel(kj) != -2) {
      goto statement_3590;
    }
    n4 = indhst(kj);
    nrf = cnvhst(n4) / deltat + 2.f;
    nr(kj) = iline + 1;
    iline += 1 + nrf;
    if (iline <= lpast) {
      goto statement_3590;
    }
    iprint = 8;
    lstat(19) = 3590;
    goto statement_9000;
  statement_3590:;
  }
statement_4590:
  last13(cmn);
  if (kill > 0) {
    goto statement_9200;
  }
  lastov = nchain;
  nchain++;
  goto statement_9800;
statement_9020:
  write(lunit6, "(' ERROR IN IDENTIFICATION OF NEXT BRANCH. JOB TERMINATED')");
  goto statement_9200;
statement_9000:
  lstat(16) = iprint;
  kill = 1;
statement_9200:
  lastov = nchain;
  nchain = 51;
  lstat(18) = lastov;
statement_9800:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT MODULE  \"OVER13\".')");
  }
} // over13

void banmul(
  arr_cref<double> ab,
  arr_cref<double> x,
  arr_ref<double> y,
  int const& n)
{
  ab(dimension((n-1)*2+1));
  x(dimension(n));
  y(dimension(n));
  double s1 = fem::double0;
  int i2 = fem::int0;
  double d1 = fem::double0;
  int n1 = fem::int0;
  int i = fem::int0;
  double d3 = fem::double0;
  double d2 = fem::double0;
  //C     THIS MODULE PERFORMS POSTMULTIPLICATION OF A VECTOR BY A TRI-     M37.4912
  //C     DIAGONAL MATRIX 'AB'. THE RESULTS ARE ADDED TO THE VECTOR 'Y'.    M37.4913
  //C     INITIALIZATION ************************************************** M37.4915
  s1 = 0.0f;
  i2 = 0;
  d1 = x(1);
  if (n1 == 1) {
    goto statement_20;
  }
  n1 = n - 1;
  //C     START LOOP ****************************************************** M37.4919
  FEM_DO_SAFE(i, 1, n1) {
    d3 = x(i + 1);
    i2 += 2;
    d2 = ab(i2);
    y(i) += ab(i2 - 1) * d1 + d2 * d3 + s1;
    s1 = d2 * d1;
    d1 = d3;
  }
  //C     FINISH LAST ROW OPERATIONS ************************************** M38.2934
statement_20:
  y(n) += ab(i2 + 1) * d1 + s1;
}

void bandel(
  arr_ref<double> ab,
  int const& n)
{
  ab(dimension(n+n));
  int n2 = fem::int0;
  int i2 = fem::int0;
  double d = fem::double0;
  double e = fem::double0;
  //C     TRIANGULARIZATION OF SYMMETRIC TRIDIAGONAL MATRIX 'AB' STORED AS  M37.4931
  //C     A ONE VECTOR CONTAINING DIAGONALS AND LOWER (UPPER) OFF-DIAGONALS M37.4932
  //C     EACH DIAGONAL IS FOLLOWED BY AN APROPRIATE OFF-DIAGONAL . THERE   M37.4933
  //C     ARE ALTOGETHER  2 * N  ENTRIES IN THE VECTOR 'AB'.                M37.4934
  //C     INITIALIZATION *************************************************  M37.4936
  n2 = n + n;
  i2 = 2;
  d = 1.0f / ab(1);
  //C     START LOOP OVER REMAINING ENTRIES ******************************  M37.4940
statement_10:
  ab(i2 - 1) = d;
  e = ab(i2);
  d = d * e;
  ab(i2) = d;
  i2 += 2;
  if (i2 > n2) {
    goto statement_20;
  }
  d = 1.0f / (ab(i2 - 1) - d * e);
  goto statement_10;
statement_20:;
}




void past(
  common& cmn)
{
  common_write write(cmn);
  double& omega = cmn.omega;
  double& tenm6 = cmn.tenm6;
  int& iprsup = cmn.iprsup;
  int& ibr = cmn.ibr;
  const auto& ykm = cmn.ykm;
  const auto& km = cmn.km;
  auto& cik = cmn.cik;
  auto& elp = cmn.elp;
  auto& cu = cmn.cu;
  auto& shp = cmn.shp;
  auto& histq = cmn.histq;
  auto& ismdat = cmn.ismdat;
  const auto& kks = cmn.kks;
  const auto& e = cmn.e;
  //
  int ilk = fem::int0;
  int in = fem::int0;
  int nwd = fem::int0;
  int iht = fem::int0;
  int ivk = fem::int0;
  int i26 = fem::int0;
  int j30 = fem::int0;
  int i30 = fem::int0;
  int j75 = fem::int0;
  double ako = fem::double0;
  int k = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  double v1 = fem::double0;
  double v2 = fem::double0;
  double v3 = fem::double0;
  double cv0 = fem::double0;
  int im = fem::int0;
  int idk = fem::int0;
  int jd30 = fem::int0;
  int je30 = fem::int0;
  int jdk = fem::int0;
  int k31 = fem::int0;
  int n3 = fem::int0;
  int kbk = fem::int0;
  int kp = fem::int0;
  int n4 = fem::int0;
  int n5 = fem::int0;
  double ap1 = fem::double0;
  double ap2 = fem::double0;
  int idelta = fem::int0;
  int i75 = fem::int0;
  double c1 = fem::double0;
  double c2 = fem::double0;
  double c3 = fem::double0;
  double a1 = fem::double0;
  double a2 = fem::double0;
  int izu = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int izn = fem::int0;
  double a3 = fem::double0;
  double a4 = fem::double0;
  double a5 = fem::double0;
  double a6 = fem::double0;
  int ih = fem::int0;
  double afd = fem::double0;
  double afq = fem::double0;
  int ikm = fem::int0;
  int ij = fem::int0;
  double a11 = fem::double0;
  double cz = fem::double0;
  int numask = fem::int0;
  int num2 = fem::int0;
  int num4 = fem::int0;
  int nlocg = fem::int0;
  int nloce = fem::int0;
  int n22 = fem::int0;
  int m22 = fem::int0;
  int m26 = fem::int0;
  int ka = fem::int0;
  int kb = fem::int0;
  int kd = fem::int0;
  int ke = fem::int0;
  int kc = fem::int0;
  double cd = fem::double0;
  int nloce1 = fem::int0;
  double cexc = fem::double0;
  int kv = fem::int0;
  int kw = fem::int0;
  int ku = fem::int0;
  int kl = fem::int0;
  int ii = fem::int0;
  int idv = fem::int0;
  int iu = fem::int0;
  int ibk = fem::int0;
  int i = fem::int0;
  int ibl = fem::int0;
  int ik = fem::int0;
  static const char* format_6602 =
    "(1x,'MATRIX Y FROM',i6,2x,'TO',i6,/(2x,6e20.11))";
  //C     THIS MODULE IS USED BY BRANDWAJN (TYPE-59) S.M. MODEL             M31.3077
  //C     INITIALIZATION AFTER PHASOR SOLUTION FOR TYPE-59 S.M.             M31.3079
  //C     THIS ROUTINE MOVES THE INITIAL CONDITIONS TO TIME '-DELTAT'       M20.3946
  ibr = cmn.ibrold;
  ilk = 0;
  in = 1;
  nwd = 24;
  iht = 0;
  ivk = 0;
  i26 = 0;
  j30 = 1;
  i30 = 1;
  j75 = 27;
  ako = 1.0f + cmn.damrat;
  cmn.delta6 = 6.0f * cmn.deltat;
  FEM_DO_SAFE(k, 1, cmn.numsm) {
    n1 = ismdat(j30 + 2);
    n2 = ismdat(j30 + 5);
    v1 = e(n1) - e(n2);
    n1 = ismdat(j30 + 3);
    n2 = ismdat(j30 + 6);
    v2 = e(n1) - e(n2);
    n1 = ismdat(j30 + 4);
    n2 = ismdat(j30 + 7);
    v3 = e(n1) - e(n2);
    cv0 = (v1 + v2 + v3) * cmn.asqrt3;
    im = ismdat(j30);
    //C     RETRIEVE AND STORE THE ELEMENTS OF MATRIX /YKM/ PERTAINING TO *   M32.4686
    //C     THE SYNCHRONOUS MACHINES CONNECTED TO NODES NODSMA(K),NODSMB(K),**M23.3704
    //C     AND NODSMC(K) ****************************************************M23.3705
    idk = j75 + 54;
    jd30 = j30 + 20;
    je30 = j30 + 1;
    FEM_DO_SAFE(jdk, 1, 3) {
      k31 = je30 + jdk;
      n1 = ismdat(k31);
      n3 = kks(n1);
      kbk = jdk + 6;
      k31 = je30;
      FEM_DOSTEP(kp, jdk, kbk, 3) {
        k31++;
        n1 = ismdat(k31);
        n4 = n3 - 1;
      statement_12:
        if (fem::iabs(km(n4)) != n1) {
          goto statement_14;
        }
        elp(idk + kp) = ykm(n4);
        n5 = kp + jd30;
        ismdat(n5) = n4;
        goto statement_15;
      statement_14:
        n4 = n4 - 1;
        goto statement_12;
      statement_15:;
      }
    }
    ap1 = 0.0f;
    ap2 = 0.0f;
    idelta = ismdat(j30 + 1);
  statement_800:
    ilk++;
    i75 = i26 + 27;
    c1 = cu(in + 11);
    c2 = cu(in + 12);
    c3 = cu(in + 13);
    a1 = elp(i75);
    a2 = elp(i75 + 1);
    //C     CALCULATE BRANCH HISTORY TERMS CIK ****************************** M39.2673
    cik(ibr + 1) = -c1 - a1 * v1 - a2 * (v2 + v3);
    cik(ibr + 2) = -c2 - a1 * v2 - a2 * (v1 + v3);
    cik(ibr + 3) = -c3 - a1 * v3 - a2 * (v1 + v2);
    ibr += 3;
    if (iprsup < 2) {
      goto statement_100;
    }
    izu = ibr - 2;
    {
      write_loop wloop(cmn, lunit6, "(1x,'CURRENT INJECTION ',3e21.12)");
      FEM_DO_SAFE(izn, izu, ibr) {
        wloop, cik(izn);
      }
    }
    //C     CALCULATE HISTORY TERMS FOR ROTOR CIRCUITS * * * * * * * * * * * *M20.3993
    //C     THESE CALCULATIONS USE THE CURRENTS FROM TIME T = 0.0 *********** M37.4829
  statement_100:
    a1 = cu(in);
    a2 = cu(in + 1);
    a3 = cu(in + 3);
    a4 = cu(in + 4);
    a5 = cu(in + 5);
    a6 = cu(in + 6);
    //C     HISTORY TERMS FOR ROTOR CIRCUITS********************************* M37.4835
    ih = i75 + 17;
    cu(in + 3) = elp(ih + 6) * a1 + (elp(ih + 7) + ako * elp(i26 +
      7)) * a3 + elp(ih + 8) * a4;
    cu(in + 4) = elp(ih + 9) * a1 + elp(ih + 10) * a3 + (elp(ih +
      11) + ako * elp(i26 + 8)) * a4;
    cu(in + 11) = 1.0f;
    cu(in + 5) = elp(ih + 12) * a2 + (elp(ih + 13) + ako * elp(i26 +
      15)) * a5 + elp(ih + 14) * a6;
    cu(in + 6) = elp(ih + 15) * a2 + elp(ih + 16) * a5 + (elp(ih +
      17) + ako * elp(i26 + 16)) * a6;
    cu(in + 12) = cu(in + 7);
    cu(in + 13) = cu(in + 8);
    //C     CALCULATE HISTORY TERMS FOR STATOR CIRCUITS********************** M37.4848
    cu(in + 2) = cv0 + cu(in + 2) / elp(i26 + 17);
    afd = cu(in + 14) * omega;
    afq = cu(in + 16) * omega;
    //C     NOT FINISHED***************************************************** M37.4853
    cu(in) = cu(in + 7) + a1 / elp(i75 + 39) + afq;
    cu(in + 1) = cu(in + 8) + a2 * elp(i75 + 41) - afd;
    if (iprsup < 1) {
      goto statement_150;
    }
    ikm = in + nwd - 1;
    {
      write_loop wloop(cmn, lunit6,
        "(/,' CURRENT HISTORY TERMS FOR GENERATOR NO.',i5,/(1x,7e17.8))");
      wloop, ilk;
      FEM_DO_SAFE(ij, in, ikm) {
        wloop, cu(ij);
      }
    }
  statement_150:
    a5 = elp(i75);
    a6 = elp(i75 + 1);
    if (idelta == 0) {
      goto statement_160;
    }
    a11 = (a5 - a6) / 3.0f;
    a5 = a11 + a11;
    a6 = -a11;
  statement_160:
    ap1 += a5;
    ap2 += a6;
    //C     BACK-OFF THE MECHANICAL EQUATIONS TO T = -DELTAT   * * * * * * * *M30. 397
    //C     ANGLE = ANGLE - ( DELTAT * SPEED ) / 2.0    SPEED = TORQUE - Y *  M30. 399
    //C     SPEED    * * * * * * * * * * * * * * * * * * * * * * * * * * * * *M30. 400
    cz = elp(i26 + 26);
    numask = ismdat(i30 + 11);
    num2 = numask + numask;
    num4 = num2 + num2;
    nlocg = ismdat(i30 + 12);
    nloce = ismdat(i30 + 13);
    n1 = iht + numask;
    n2 = n1 + num2;
    n22 = ivk + num2;
    m22 = n22;
    m26 = iht + num4;
    FEM_DO_SAFE(ka, 1, numask) {
      kb = n1 + ka;
      kd = n2 + ka;
      ke = m26 + ka;
      kc = ke + numask;
      m22++;
      shp(m22) = histq(kb);
      histq(ke) = -shp(m22);
      histq(kd) = histq(kc) / histq(kb);
    }
    kb = n2 + nlocg;
    cd = ((afd * a2 - afq * a1) * tenm6) / omega;
    histq(kb) = histq(kb) - cd * cz;
    if (nloce == 0) {
      goto statement_22;
    }
    kb = n2 + nloce;
    nloce1 = n22 + nloce;
    cexc = -cu(in + 10) * a3 * tenm6;
    histq(kb) = histq(kb) - cexc / shp(nloce1);
  statement_22:
    FEM_DO_SAFE(ka, 1, numask) {
      kd = iht + ka;
      kb = kd + num2;
      kc = m26 + ka;
      histq(kb) = histq(kd) + cmn.delta2 * histq(kc);
    }
    kv = ivk + 1;
    kw = n2 + 1;
    ku = m26 + 1;
    banmul(shp(kv), histq(ku), histq(kw), numask);
    kl = ivk + num2;
    if (iprsup > 1) {
      {
        write_loop wloop(cmn, lunit6, format_6602);
        wloop, kv, kl;
        FEM_DO_SAFE(ii, kv, kl) {
          wloop, shp(ii);
        }
      }
    }
    //C     TRIANGULARIZE AN APPROPRIATE PART OF THE MATRIX  'Y' ************ M37.4893
    bandel(shp(kv), numask);
    ivk = kl + 5 * num2;
    ka = iht + 1;
    iht += 3 * num2;
    if (iprsup < 1) {
      goto statement_200;
    }
    {
      write_loop wloop(cmn, lunit6,
        "('  ARRAY HISTQ FROM',i5,'  TO',i5,/(2x,6e20.11))");
      wloop, ka, kb;
      FEM_DO_SAFE(kc, ka, iht) {
        wloop, histq(kc);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_6602);
      wloop, kv, kl;
      FEM_DO_SAFE(ii, kv, kl) {
        wloop, shp(ii);
      }
    }
    kl += 3 * num2;
    kv = kl + 1;
    kl += 2 * num2;
    {
      write_loop wloop(cmn, lunit6, format_6602);
      wloop, kv, kl;
      FEM_DO_SAFE(ii, kv, kl) {
        wloop, shp(ii);
      }
    }
  statement_200:
    im = im - 1;
    in += nwd;
    i26 += 101;
    i30 += 30;
    if (im > 0) {
      goto statement_800;
    }
    //C     CALCULATE AND STORE THE CONSTANT OFF-SET TERMS FOR UPDATING OF THEM23.3750
    //C     MATRIX (YKM). THESE TERMS WILL BE USED ONLY FOR SATURABLE . ******M32.4696
    //C     SYNCHRONOUS MACHINES *********************************************M23.3752
    elp(idk + 1) = elp(idk + 1) - ap1;
    elp(idk + 5) = elp(idk + 5) - ap1;
    elp(idk + 9) = elp(idk + 9) - ap1;
    elp(idk + 2) = elp(idk + 2) - ap2;
    elp(idk + 3) = elp(idk + 3) - ap2;
    elp(idk + 4) = elp(idk + 4) - ap2;
    elp(idk + 6) = elp(idk + 6) - ap2;
    elp(idk + 7) = elp(idk + 7) - ap2;
    elp(idk + 8) = elp(idk + 8) - ap2;
    if (iprsup <= 0) {
      goto statement_899;
    }
    idv = idk + 9;
    jdk = idk + 1;
    {
      write_loop wloop(cmn, lunit6, "(' AT 900.'(/,6e20.12))");
      FEM_DO_SAFE(iu, jdk, idv) {
        wloop, elp(iu);
      }
    }
    idv = jd30 + 9;
    jdk = jd30 + 1;
    {
      write_loop wloop(cmn, lunit6, "(' AT 900.',/,9i12,/)");
      FEM_DO_SAFE(iu, jdk, idv) {
        wloop, ismdat(iu);
      }
    }
  statement_899:
    j30 += 30;
    j75 += 101;
  }
  if (iprsup < 2) {
    goto statement_2500;
  }
  ibk = 0;
  FEM_DO_SAFE(i, 1, ilk) {
    ibl = ibk + 1;
    ibk += 101;
    {
      write_loop wloop(cmn, lunit6, "(/(1x,6e20.12))");
      FEM_DO_SAFE(ik, ibl, ibk) {
        wloop, elp(ik);
      }
    }
  }
statement_2500:;
}

struct zincox_save
{
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;

  zincox_save() :
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0)
  {}
};


void
zincox(
  common& cmn,
  int const& ns)
{
  FEM_CMN_SVE(zincox);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  double& epsiln = cmn.epsiln;
  double& t = cmn.t;
  double& fltinf = cmn.fltinf;
  auto& flstat = cmn.flstat;
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  int& lchar = cmn.lchar;
  int& m4plot = cmn.m4plot;
  int& lsiz26 = cmn.lsiz26;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  const auto& nonlad = cmn.nonlad;
  const auto& nonle = cmn.nonle;
  auto& vnonl = cmn.vnonl;
  auto& curr = cmn.curr;
  const auto& anonl = cmn.anonl;
  const auto& vecnl1 = cmn.vecnl1;
  auto& vecnl2 = cmn.vecnl2;
  auto& vzer5 = cmn.vzer5;
  auto& ilast = cmn.ilast;
  auto& cursub = cmn.cursub;
  auto& cchar = cmn.cchar;
  auto& vchar = cmn.vchar;
  auto& gslope = cmn.gslope;
  const auto& znolim = cmn.znolim;
  const auto& kknonl = cmn.kknonl;
  const auto& znonl = cmn.znonl;
  const auto& isubeg = cmn.isubeg;
  const auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;
  auto& voltk = static_cast<common_c0b124&>(cmn).voltk;
  auto& volt = cmn.volt;
  const auto& bus = cmn.bus;
  fem::str<80>& buff77 = cmn.buff77;
  fem::str<80>& prom80 = cmn.prom80;
  fem::str<132>& munit6 = cmn.munit6;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  if (is_called_first_time) {
    text1 = "SPY   ";
    text2 = "SOLVE ";
    text3 = "STOP  ";
    text4 = "LOOK  ";
  }
  int ll10 = fem::int0;
  int iofznr = fem::int0;
  double d12 = fem::double0;
  int iofzni = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int n6 = fem::int0;
  int n5 = fem::int0;
  int n1 = fem::int0;
  int n8 = fem::int0;
  int ll1 = fem::int0;
  int n7 = fem::int0;
  int j = fem::int0;
  int n10 = fem::int0;
  int n18 = fem::int0;
  int ndx7r = fem::int0;
  int ndx1r = fem::int0;
  int ndx1i = fem::int0;
  int ndx7i = fem::int0;
  int ndx2 = fem::int0;
  int m5 = fem::int0;
  int L = fem::int0;
  int n12 = fem::int0;
  int n = fem::int0;
  int k = fem::int0;
  int m = fem::int0;
  int n11 = fem::int0;
  int inl = fem::int0;
  int n15 = fem::int0;
  int ndx3 = fem::int0;
  int n13 = fem::int0;
  int n14 = fem::int0;
  int m2 = fem::int0;
  int l1 = fem::int0;
  int n17 = fem::int0;
  int ndx17r = fem::int0;
  int ndx17i = fem::int0;
  int ier = fem::int0;
  int niter = fem::int0;
  int n2 = fem::int0;
  double d3 = fem::double0;
  int il = fem::int0;
  int ityp = fem::int0;
  int ils = fem::int0;
  double d4 = fem::double0;
  double d5 = fem::double0;
  int ichr = fem::int0;
  int ibk = fem::int0;
  int jb = fem::int0;
  int ik = fem::int0;
  double azm = fem::double0;
  double d11 = fem::double0;
  int ist = fem::int0;
  int ind = fem::int0;
  double azx = fem::double0;
  int ndx4 = fem::int0;
  int m22 = fem::int0;
  int il1 = fem::int0;
  double amult = fem::double0;
  double d35 = fem::double0;
  double d6 = fem::double0;
  int n4 = fem::int0;
  double znvref = fem::double0;
  double gap = fem::double0;
  int k1 = fem::int0;
  int k2 = fem::int0;
  //C!DIMENSION FOLD( 1 )
  //C!DIMENSION KSING( 1 ), KINDEP( 1 )
  //C!EQUIVALENCE ( KSING(1), CCHAR(1) )
  //C!EQUIVALENCE ( KINDEP(1), GSLOPE(1) )
  //C!EQUIVALENCE ( FOLD(1), VCHAR(1) )
  //C!DIMENSION NSUBKM( 1 )
  //C!EQUIVALENCE ( KKNONL(1), NSUBKM(1) )
  //C     INTRINSIC  ABSZ                                                   M32.6260
  ll10 = 10;
  iofznr = nonle(cmn.inonl);
  iofznr = iabsz(iofznr);
  d12 = nbyte(3);
  d12 = iofznr * d12 / nbyte(4);
  iofzni = d12 + 1.0f;
  if (iprsup > 0) {
    write(lunit6,
      "(' TOP OF  \"ZINCOX\" .',3x,' NS, IOFZNR, IOFZNI, LCHAR =',4i8)"),
      ns, iofznr, iofzni, lchar;
  }
  n6 = isubeg(ns);
statement_3415:
  n5 = 1;
  n1 = 0;
  n8 = n6;
  ll1 = 1;
  //C     DETERMINE NUMBER OF ELEMENTS IN THE SUBNETWORK                    M37.5692
  n7 = 0;
  FEM_DO_SAFE(j, 1, 99999) {
    n7++;
    n10 = kknonl(n8);
    if (n10 <= n8) {
      goto statement_20;
    }
    n8 = n10;
  }
  //C     CHECK FOR TABLE OVERFLOW****************************************  M37.5699
statement_20:
  n18 = n8;
  ndx7r = iofznr + n7;
  if (ndx7r <= lchar) {
    goto statement_3422;
  }
  write(lunit6,
    "(/,' OVERFLOW IN \"ZINCOX\".',i5,"
    "' COUPLED ARRESTERS, IF ADDED TO IOFZNR =',i5,' OVERFLOW LIST 10. ')"),
    n7, iofznr;
  kill = 1;
  lstat(19) = 3422;
  lstat(16) = 10;
  goto statement_4567;
statement_3422:
  if (fem::pow2(n7) < lsiz26) {
    goto statement_3424;
  }
  write(lunit6,
    "(/,' OVERFLOW IN \"ZINCOX\".',i5,"
    "' COUPLED ARRESTERS, IF SQUARED, OVERFLOW LIST 26.')"),
    n7;
  kill = 1;
  lstat(19) = 3424;
  lstat(16) = 26;
  goto statement_4567;
statement_3424:
  if (n7 * 2 < lsiz26) {
    goto statement_3425;
  }
  write(lunit6,
    "(/,' OVERFLOW IN \"ZINCOX\".',i5,"
    "' COUPLED ARRESTERS, IF DOUBLED, OVERFLOW LIST 26.')"),
    n7;
  kill = 1;
  lstat(19) = 3425;
  lstat(16) = 26;
  goto statement_4567;
statement_3425:
  ndx1r = iofznr + 1;
  ndx1i = iofzni + 1;
  ndx7i = iofzni + n7;
  //C     EXTRACT ZTHEVENIN FROM ZNONL, DETERMINE ELEMENTS CONNECTED TO     M37.5724
  //C     KNOWN VOLTAGE NODES********************************************   M37.5725
  ndx2 = ndx1i;
  m5 = n6;
  FEM_DO_SAFE(L, 1, n7) {
    n12 = 0;
    cchar(ndx2) = 0;
    //C     PROCESS A COLUMN AT A TIME**********************************      M37.5730
    FEM_DO_SAFE(n, 1, n7) {
      k = kknonl(m5 + 1) + n1;
      m = kknonl(m5 + 2) + n1;
      volti(n5) = znonl(k) - znonl(m);
      if (volti(n5) != 0.0f) {
        n12 = 1;
      }
      m5 = kknonl(m5);
      n5++;
    }
    if (n12 == 0) {
      cchar(ndx2) = -1;
    }
    ndx2++;
    n1 += cmn.ntot;
  }
  n5 = n5 - 1;
  if (iprsup >= 6) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' THEVENIN MATRIX. N6, NS, N7, N5 =',4i8,/(1x,8e16.7))");
      wloop, n6, ns, n7, n5;
      FEM_DO_SAFE(L, 1, n5) {
        wloop, volti(L);
      }
    }
  }
  //C     EXTRACT AND STORE THEVENIN VOLTAGES****************************   M37.5739
  m = 0;
  FEM_DO_SAFE(L, 1, n7) {
    n10 = kknonl(m5 + 1);
    n11 = kknonl(m5 + 2);
    inl = kknonl(m5 + 3);
    voltk(m + 1) = e(n10) - e(n11);
    voltk(m + 2) = vzer5(inl);
    vecnl2(inl) = curr(inl);
    m5 = kknonl(m5);
    m += 2;
  }
  if (iprsup > 1) {
    {
      write_loop wloop(cmn, lunit6, "(/,' ''KSING''  B4 COPY CHECKING.',20i5)");
      FEM_DO_SAFE(L, ndx1i, ndx7i) {
        wloop, cchar(L);
      }
    }
  }
  n15 = n7 - 1;
  if (n15 == 0) {
    goto statement_3638;
  }
  n10 = 0;
  ndx2 = iofzni;
  FEM_DO_SAFE(L, 1, n15) {
    ndx2++;
    if (cchar(ndx2) == -1) {
      goto statement_3634;
    }
    n11 = n10 + n7;
    ndx3 = ndx2 + 1;
    FEM_DO_SAFE(m, ndx3, ndx7i) {
      if (cchar(m) != 0) {
        goto statement_3628;
      }
      //C     CHECK FOR IDENTICAL ROWS (COLUMNS) ***************************    M37.5757
      FEM_DO_SAFE(n12, 1, n7) {
        n13 = n10 + n12;
        n14 = n11 + n12;
        if (volti(n13) != volti(n14)) {
          goto statement_3628;
        }
      }
      cchar(m) = L;
    statement_3628:
      n11 += n7;
    }
  statement_3634:
    n10 += n7;
  }
statement_3638:
  if (iprsup < 6) {
    goto statement_40;
  }
  write(lunit6, "(/,1x,'    ROW  KSING         VTHEV          VOLD')");
  m2 = -1;
  FEM_DO_SAFE(L, 1, n7) {
    m2 += 2;
    l1 = iofzni + L;
    write(lunit6, "((1x,2i7,2e14.5))"), L, cchar(l1), voltk(m2), voltk(m2 + 1);
  }
statement_40:
  n17 = 0;
  FEM_DO_SAFE(L, ndx1i, ndx7i) {
    gslope(L) = 0;
    if (cchar(L) != 0) {
      goto statement_3645;
    }
    n17++;
    gslope(L) = n17;
  statement_3645:;
  }
  if (n17 == 0) {
    goto statement_3522;
  }
  if (n17 == n7) {
    goto statement_3674;
  }
  //C     COLLAPSE ZTHEVENIN (REMOVE ZERO AND DEPENDENT ROWS )              M37.5771
  n11 = 1;
  n5 = 0;
  FEM_DO_SAFE(L, ndx1i, ndx7i) {
    FEM_DO_SAFE(m, ndx1i, ndx7i) {
      if (cchar(L) != 0) {
        goto statement_3657;
      }
      if (cchar(m) != 0) {
        goto statement_3657;
      }
      n5++;
      volt(n5) = volti(n11);
    statement_3657:
      n11++;
    }
  }
  mover(volt(1), volti(1), n5);
  if (iprsup >= 5) {
    {
      write_loop wloop(cmn, lunit6, "(' COLLAPSED  (ZTHEV):',7e15.5)");
      FEM_DO_SAFE(L, 1, n5) {
        wloop, volt(L);
      }
    }
  }
statement_3674:
  //C     ENTER NEWTON LOOP FOR ZNO ARRESTERS (NOT USER FORTRAN):           M31.3396
  move0(volt, n5);
  ndx17r = iofznr + n17;
  ndx17i = iofzni + n17;
  n10 = 1;
  n12 = n17 + 1;
  FEM_DO_SAFE(L, 1, n17) {
    volt(n10) = 1.0f;
    n10 += n12;
  }
  if (kill > 0) {
    goto statement_4567;
  }
  //C     CALCULATE EXPLICIT INVERSE OF THE COLLAPSED ZTHEV *************** M37.5777
  dgelg(volt(1), volti(1), n17, n17, epsiln, ier);
  if (iprsup > 5) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' INVERSE OF  (ZTHEV).  IER =',i2,/(1x,8e16.7))");
      wloop, ier;
      FEM_DO_SAFE(m, 1, n5) {
        wloop, volt(m);
      }
    }
  }
  niter = 0;
  if (ier == 0) {
    goto statement_3693;
  }
  lstat(19) = 3471;
statement_3681:
  kill = 209;
statement_3686:
  lstat(13) = n7;
  lstat(14) = kknonl(n18 + 3);
  lstat(15) = kknonl(n6 + 3);
  lstat(16) = n17;
  lstat(17) = niter;
  n1 = kknonl(n6 + 1);
  n2 = kknonl(n6 + 2);
  bus1 = bus(n1);
  cmn.bus2 = bus(n2);
  flstat(14) = d3;
  flstat(15) = t;
  iprsup = 9;
  if (m4plot != 1) {
    goto statement_3415;
  }
  write(munit6,
    "('   ? ? ?   Singular Jacobian.  Newton',' iteration stopped.')");
  window(cmn);
statement_3691:
  write(munit6,
    "(' Trouble in  \"ZINCOX\".  KILL  LSTAT(19)',"
    "'   IER  NITER            D3')");
  window(cmn);
  write(munit6, "(22x,i6,i11,i6,i7,e14.5)"), kill, lstat(19), ier, niter, d3;
  window(cmn);
  FEM_DO_SAFE(il, 1, n7) {
    inl = kknonl(m5 + 3);
    curr(inl) = vecnl2(inl);
    m5 = kknonl(m5);
  }
  honker(cmn, ll10);
statement_3711:
  write(prom80, "(' SEND REMEDY (SPY, SOLVE, LOOK, STOP) :')");
  prompt(cmn);
  cmn.lockbr = 1;
  flager(cmn);
  read(buff77, "(a6)"), bus1;
  kill = 0;
  if (bus1 != text1) {
    goto statement_3726;
  }
  spying(cmn);
  goto statement_3711;
statement_3726:
  if (bus1 == text2) {
    goto statement_3415;
  }
  if (bus1 == text3) {
    stoptp(cmn);
  }
  if (bus1 != text4) {
    goto statement_3752;
  }
  write(prom80, "(' SEND DIAGNOSTIC LEVEL IPRSUP (I2 FORMAT) :')");
  prompt(cmn);
  read(buff77, "(i2)"), iprsup;
  goto statement_3711;
statement_3752:
  goto statement_3711;
statement_3693:
  d3 = fltinf;
  mover(volt(1), volti(1), n5);
statement_3474:
  niter++;
  n11 = 1;
  move0(vchar, ndx1r, n17);
  ndx2 = iofzni;
  m2 = 0;
  FEM_DO_SAFE(L, 1, n7) {
    ndx2++;
    m2 += 2;
    if (cchar(ndx2) == -1) {
      goto statement_3482;
    }
    n13 = L;
    if (cchar(ndx2) > 0) {
      n13 = cchar(ndx2);
    }
    ndx3 = n13 + iofzni;
    n14 = gslope(ndx3);
    n10 = (n14 - 1) * n17 + n13;
    inl = kknonl(m5 + 3);
    ityp = kknonl(m5 + 4);
    ils = ilast(inl);
    if (ityp == 1) {
      goto statement_41;
    }
    //C     PROCESS PIECEWISE LINEAR AND TIME VARYING RESISTANCES************ M37.5834
    if (ils > 0) {
      goto statement_254;
    }
    d4 = voltk(m2);
    if (ityp == 3) {
      d4 = t + vnonl(inl);
    }
    d5 = d4;
    if (ityp == 2 && vchar(ichr) == 0.0f) {
      d5 = std::abs(d5);
    }
    ichr = nonlad(inl);
    ils = -ils;
    if (d5 > vchar(ils)) {
      goto statement_251;
    }
    ibk = ils;
    FEM_DO_SAFE(jb, ichr, ils) {
      if (d5 < vchar(ibk)) {
        goto statement_250;
      }
      ik = ibk;
      goto statement_253;
    statement_250:
      ibk = ibk - 1;
    }
    ik = ichr;
    goto statement_253;
  statement_251:
    ibk = nonle(inl);
    FEM_DO_SAFE(jb, ils, ibk) {
      if (d5 > vchar(jb)) {
        goto statement_252;
      }
      ik = jb - 1;
      goto statement_253;
    statement_252:;
    }
    ik = ibk;
    //C     SEGMENT HAS BEEN DETERMINED************************************** M37.5858
  statement_253:
    ilast(inl) = -ik;
    azm = gslope(ik);
    d11 = azm * d5 + cchar(ik);
    if ((d5 * d4) < 0.0f) {
      d11 = -d11;
    }
    if (ityp == 2) {
      goto statement_261;
    }
    if (d11 == 0.0f) {
      d11 = epsiln;
    }
    azm = 1.0f / d11;
    d11 = azm * voltk(m2);
  statement_261:
    curr(inl) = d11;
    volt(n10) = volt(n10) - azm;
    goto statement_68;
  statement_254:
    d11 = 0.0f;
    curr(inl) = 0.0f;
    goto statement_68;
    //C     PROCESS ZNO ARRESTERS******************************************** M37.5873
  statement_41:
    d5 = std::abs(voltk(m2) / anonl(inl));
    if (ils < 0) {
      goto statement_45;
    }
    //C     SET LIMITS FOR SCANNING OF SEGMENT BOUNDARIES                     M37.5876
    ist = nonlad(inl);
    ind = ils;
    goto statement_55;
  statement_45:
    ist = -ils + 1;
    ind = nonle(inl);
    //C     START SCAN OF SEGMENT BOUNDARIES********************************* M37.5882
  statement_55:
    ist++;
    FEM_DO_SAFE(jb, ist, ind) {
      if (vchar(jb) < d5) {
        goto statement_60;
      }
      ik = jb - 1;
      goto statement_65;
    statement_60:;
    }
    ik = ind;
    //C     SEGMENT HAS BEEN DETERMINED************************************** M37.5890
  statement_65:
    azm = cchar(ik);
    if (ik >= ist) {
      goto statement_66;
    }
    d11 = azm * voltk(m2);
    curr(inl) = d11;
    volt(n10) = volt(n10) - azm;
    goto statement_68;
  statement_66:
    azx = gslope(ik);
    d11 = azm * (fem::pow(d5, azx));
    if (voltk(m2) < 0.0f) {
      d11 = -d11;
    }
    curr(inl) = d11;
    volt(n10) = volt(n10) - azx * d11 / voltk(m2);
  statement_68:
    ndx4 = iofznr + n14;
    if (cchar(ndx2) != 0) {
      goto statement_75;
    }
    m22 = 0;
    FEM_DO_SAFE(m, ndx1i, ndx7i) {
      if (cchar(m) != 0) {
        goto statement_70;
      }
      vchar(ndx4) = vchar(ndx4) - volti(n11) * (voltk(m22 + 2) -
        voltk(m22 + 1));
      n11++;
    statement_70:
      m22 += 2;
    }
  statement_75:
    vchar(ndx4) += d11;
  statement_3482:
    m5 = kknonl(m5);
  }
  if (d3 <= cmn.epszno) {
    goto statement_3522;
  }
  if (iprsup < 7) {
    goto statement_3499;
  }
  {
    write_loop wloop(cmn, lunit6, "(/,' RHS VECTOR  ''FOLD'' .',7e15.6)");
    FEM_DO_SAFE(L, ndx1r, ndx17r) {
      wloop, vchar(L);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(' JACOBIAN  ''VOLT'' .',7e15.6)");
    FEM_DO_SAFE(L, 1, n5) {
      wloop, volt(L);
    }
  }
statement_3499:
  dgelg(vchar(ndx1r), volt(1), n17, ll1, epsiln, ier);
  if (ier == 0) {
    goto statement_3501;
  }
  lstat(19) = 3501;
  goto statement_3681;
statement_3501:
  if (iprsup > 4) {
    {
      write_loop wloop(cmn, lunit6, "(' DV CORRECTION :',7e15.6)");
      FEM_DO_SAFE(L, ndx1r, ndx17r) {
        wloop, vchar(L);
      }
    }
  }
  d3 = 0.0f;
  //C     CHECK FOR TOO LARGE VOLTAGE CORRECTIONS*************************  M37.5920
  FEM_DO_SAFE(jb, ndx1i, ndx7i) {
    if (cchar(jb) != 0) {
      goto statement_80;
    }
    n13 = gslope(jb) + iofznr;
    il1 = kknonl(m5 + 3);
    d4 = std::abs(vchar(n13) / anonl(il1));
    if (d4 > d3) {
      d3 = d4;
    }
  statement_80:
    m5 = kknonl(m5);
  }
  //C     SCALE CORRECTIONS, IF TOO LARGE********************************** M37.5928
  if (d3 <= znolim(1)) {
    goto statement_90;
  }
  amult = znolim(1) / d3;
  FEM_DO_SAFE(jb, ndx1r, ndx17r) {
    vchar(jb) = vchar(jb) * amult;
  }
statement_90:
  if (niter < 4) {
    goto statement_92;
  }
  //C     CHECK FOR OSCILLATORY SOLUTION*********************************** M37.5935
  d35 = std::abs(d3 - d35) / d35;
  if (d35 > (10.0f * epsiln)) {
    goto statement_92;
  }
  amult = 0.1f;
  FEM_DO_SAFE(jb, ndx1r, ndx17r) {
    vchar(jb) = vchar(jb) * amult;
  }
  //C     UPDATE VOLTAGES( ADD SCALED CORRECTIONS)************************* M37.5942
statement_92:
  m2 = 0;
  d4 = znolim(2);
  FEM_DO_SAFE(L, ndx1i, ndx7i) {
    m2 += 2;
    inl = kknonl(m5 + 3);
    if (cchar(L) == -1) {
      goto statement_100;
    }
    if (cchar(L) == 0) {
      goto statement_95;
    }
    n12 = cchar(L) * 2;
    voltk(m2) = voltk(n12);
    goto statement_100;
  statement_95:
    n13 = gslope(L) + iofznr;
    voltk(m2) += vchar(n13);
    if (kknonl(m5 + 4) > 1) {
      goto statement_100;
    }
    d6 = voltk(m2);
    d5 = d4 * anonl(inl);
    if (d5 > std::abs(d6)) {
      goto statement_100;
    }
    voltk(m2) = d5;
    if (d6 < 0.0f) {
      voltk(m2) = -d5;
    }
  statement_100:
    m5 = kknonl(m5);
  }
  n4 = kknonl(n6 + 3);
  if (iprsup >= 3) {
    write(lunit6,
      "(' SUBSYSTEMS 1ST ARRESTER',i3,5x,'NITER =',i3,5x,'MAX DEL-V =',e13.4)"),
      n4, niter, d3;
  }
  mover(volti(1), volt(1), n5);
  d35 = d3;
  if (niter <= cmn.maxzno) {
    goto statement_3474;
  }
  if (d3 <= cmn.epwarn) {
    goto statement_3522;
  }
  write(lunit6,
    "(' SUBSYSTEM =',i3,'  ITERATION LIMIT.   LARGEST ABS(DV / ZNVREF) =',"
    "e12.3)"),
    ns, d3;
  if (d3 <= cmn.epstop) {
    goto statement_3522;
  }
  kill = 212;
  lstat(19) = 3522;
  if (m4plot != 1) {
    goto statement_3686;
  }
  write(munit6,
    "('   ? ? ?   Non-converged Newton iteration.','   Limit  MAXZNO =',i5,"
    "'  reached.')");
  window(cmn);
  goto statement_3691;
statement_3522:
  ndx2 = iofzni;
  m2 = 0;
  FEM_DO_SAFE(L, 1, n7) {
    ndx2++;
    m2 += 2;
    inl = kknonl(m5 + 3);
    ityp = kknonl(m5 + 4);
    ils = ilast(inl);
    znvref = 1.0f / anonl(inl);
    if (cchar(ndx2) != -1) {
      goto statement_180;
    }
    d4 = voltk(m2 - 1);
    if (ityp == 1) {
      goto statement_139;
    }
    //C     PROCESS PIECEWISE LINEAR AND TIME VARYING  RESISTANCES**********  M37.5988
    d11 = 0.0f;
    if (ils > 0) {
      goto statement_168;
    }
    ichr = nonlad(inl);
    ils = -ils;
    if (ityp == 3) {
      d4 = t + vnonl(inl);
    }
    d3 = d4;
    if (ityp == 2 && vchar(ichr) == 0.0f) {
      d3 = std::abs(d3);
    }
    if (d3 > vchar(ils)) {
      goto statement_351;
    }
    ibk = ils;
    FEM_DO_SAFE(jb, ichr, ils) {
      if (d3 < vchar(ibk)) {
        goto statement_350;
      }
      ik = ibk;
      goto statement_353;
    statement_350:
      ibk = ibk - 1;
    }
    ik = ibk;
    goto statement_353;
  statement_351:
    ibk = nonle(inl);
    FEM_DO_SAFE(jb, ils, ibk) {
      if (d3 > vchar(jb)) {
        goto statement_352;
      }
      ik = jb - 1;
      goto statement_353;
    statement_352:;
    }
    ik = ibk;
    //C     SEGMENT HAS BEEN DETERMINED*************************************  M37.6012
  statement_353:
    ilast(inl) = -ik;
    ils = -ik;
    azm = gslope(ik);
    d11 = azm * d3 + cchar(ik);
    if ((d3 * d4) < 0.0f) {
      d11 = -d11;
    }
    if (ityp == 2) {
      goto statement_168;
    }
    d4 = voltk(m2 - 1);
    if (d11 == 0.0f) {
      d11 = epsiln;
    }
    d11 = (1.0f / d11) * d4;
    goto statement_168;
    //C     PROCESS ZNO ARRESTERS******************************************** M37.6023
  statement_139:
    d5 = std::abs(d4 * znvref);
    if (ils < 0) {
      goto statement_145;
    }
    //C     SET LIMITS FOR SCANNING OF SEGMENT BOUNDARIES                     M37.6026
    ist = nonlad(inl);
    ind = ils;
    goto statement_155;
  statement_145:
    ist = -ils + 1;
    ind = nonle(inl);
    //C     START SCAN OF SEGMENT BOUNDARIES********************************* M37.6032
  statement_155:
    ist++;
    FEM_DO_SAFE(jb, ist, ind) {
      if (vchar(jb) < d5) {
        goto statement_160;
      }
      ik = jb - 1;
      goto statement_165;
    statement_160:;
    }
    ik = ind;
    //C     SEGMENT HAS BEEN DETERMINED************************************** M37.6040
  statement_165:
    azm = cchar(ik);
    if (ik >= ist) {
      goto statement_166;
    }
    d11 = azm * d4;
    goto statement_168;
  statement_166:
    azx = gslope(ik);
    d11 = azm * (fem::pow(d5, azx));
    if (d4 < 0.0f) {
      d11 = -d11;
    }
  statement_168:
    voltk(m2) = d4;
    curr(inl) = d11;
    //C     DETERMINE GAP STATUS FOR NEXT TIME STEP************************** M37.6050
  statement_180:
    d6 = vnonl(inl);
    if (d6 == fltinf) {
      goto statement_196;
    }
    if (ils < 0) {
      goto statement_190;
    }
    d5 = std::abs(voltk(m2));
    if (d5 > d6) {
      ils = -ils;
    }
    if (ityp == 3 && ils < 0) {
      vnonl(inl) = -(t + cmn.deltat);
    }
    goto statement_195;
  statement_190:
    if (ityp == 3) {
      goto statement_195;
    }
    if (curr(inl) * vecnl2(inl) < 0.0f) {
      ils = -ils;
    }
    if (ityp == 1 || ils < 0) {
      goto statement_195;
    }
    gap = vecnl1(inl);
    if (gap == 0.0f) {
      goto statement_195;
    }
    if (gap < 0.0f) {
      ils = -ils;
    }
    if (gap > 0.0f) {
      vnonl(inl) = fltinf;
    }
  statement_195:
    ilast(inl) = ils;
  statement_196:
    vzer5(inl) = voltk(m2);
    n13 = m5 / 5;
    cursub(n13 + 1) = curr(inl);
    k1 = kknonl(m5 + 1);
    k2 = kknonl(m5 + 2);
    f(k1) = f(k1) - curr(inl);
    f(k2) += curr(inl);
    m5 = kknonl(m5);
  }
statement_4567:
  if (iprsup >= 1) {
    write(lunit6,
      "(' EXIT MODULE \"ZINCOX\".  KILL, LSTAT(19) =',2i8)"), kill,
      lstat(19);
  }
}

// FORM (Y) FOR THE TRANSIENTS NETWORK. TRIANGULARIZE THE     
// FIRST PARTITION (NONSWITCH/SOURCE NODES).                    
void over14(
  common& cmn)
{
  common_write write(cmn);
  double& delta2 = cmn.delta2;
  double& omega = cmn.omega;
  double& fltinf = cmn.fltinf;
  //const auto& moncar = cmn.moncar;
  auto& lstat = cmn.lstat;
  int& inonl = cmn.inonl;
  int& it2 = cmn.it2;
  int& lswtch = cmn.lswtch;
  int& lfd = cmn.lfd;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  auto& kentnb = cmn.kentnb;
  auto& nbhdsw = cmn.nbhdsw;
  auto& finit = cmn.finit;
  const auto& nonlad = cmn.nonlad;
  auto& nonle = cmn.nonle;
  const auto& vnonl = cmn.vnonl;
  auto& curr = cmn.curr;
  auto& anonl = cmn.anonl;
  const auto& vzer5 = cmn.vzer5;
  const auto& ilast = cmn.ilast;
  const auto& nltype = cmn.nltype;
  const auto& cchar = cmn.cchar;
  const auto& gslope = cmn.gslope;
  const auto& length = cmn.length;
  const auto& nonlk = cmn.nonlk;
  const auto& nonlm = cmn.nonlm;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& sfreq = cmn.sfreq;
  const auto& kmswit = cmn.kmswit;
  const auto& e = cmn.e;
  const auto& f = static_cast<common_c0b119&>(cmn).f;
  const auto& kssfrq = cmn.kssfrq;
  auto& volt = cmn.volt;
  //
  auto& lunit6 = cmn.lunit6;
  int n6 = fem::int0;
  int mswtch = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  int ndx1 = fem::int0;
  int m = fem::int0;
  int i = fem::int0;
  int ndx2 = fem::int0;
  int isfd = fem::int0;
  int ibf = fem::int0;
  int ikf = fem::int0;
  int n1 = fem::int0;
  int n15 = fem::int0;
  int n16 = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  int n7 = fem::int0;
  int j0 = fem::int0;
  int ka = fem::int0;
  int kb = fem::int0;
  int it2d = fem::int0;
  int kc = fem::int0;
  int kd = fem::int0;
  int mfd = fem::int0;

  auto& knt = cmn.moncar(1);
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER14.\"')");
  }
  //C     DEFINE "KENTNB" AND "NBHDSW" VECTORS FOR MODULE "SWITCH"          M32.4457
  //C     OF OVERLAY 16 (CALLED BY "SUBTS1") VIA  "DO 2472":                M32.4458
  n6 = 0;
  if (kswtch <= 0) {
    goto statement_2483;
  }
  mswtch = lswtch * 3;
  FEM_DO_SAFE(j, 1, kswtch) {
    kentnb(j) = n6 + 1;
    k = kmswit(j);
    ndx1 = lswtch + j;
    m = kmswit(ndx1);
    FEM_DO_SAFE(i, 1, kswtch) {
      if (i == j) {
        goto statement_2461;
      }
      ndx2 = lswtch + i;
      if (k != kmswit(i) && k != kmswit(ndx2) && m != kmswit(i) &&
        m != kmswit(ndx2)) {
        goto statement_2461;
      }
      n6++;
      if (n6 > mswtch) {
        goto statement_1983;
      }
      nbhdsw(n6) = i;
    statement_2461:;
    }
  }
  kentnb(kswtch + 1) = n6 + 1;
statement_2483:
  //C     INITIALIZE COUNTERS FOR THE -666 BRANCHES    *   *   *   *   *   *M32.4479
  isfd = 0;
  ibf = 0;
  ikf = 0;
  move0(finit, ntot);
  if (iprsup > 0) {
    write(lunit6,
      "(/,' VARIOUS SCALARS AT BEGINNING OF  ''LAST14'' .',/,1x,"
      "'   INONL      NV     IBR      IT    NTOT  NENERG     KNT',9x,'FLTINF',"
      "9x,'FLZERO',10x,'OMEGA',9x,'DELTA2',9x,'DELTAT',/,1x,7i8,5e15.6)"),
      inonl, cmn.nv, ibr, cmn.it, ntot, cmn.nenerg, knt, fltinf,
      cmn.flzero, omega, delta2, cmn.deltat;
  }
  i = inonl;
  goto statement_73577;
statement_73571:
  if (nltype(i) > 0) {
    goto statement_73574;
  }
  if (nltype(i) != -97) {
    goto statement_73572;
  }
  curr(i) = 0.0f;
  if (anonl(i) >= 0.0f) {
    goto statement_73572;
  }
  curr(i) = 1.0f;
  anonl(i) = -1.0f / fltinf;
statement_73572:
  k = nonlk(i);
  n1 = nonlm(i);
  m = fem::iabs(n1);
  n15 = k;
  if (n15 == 1) {
    n15 = m;
  }
  n16 = fem::iabs(kssfrq(n15));
  omega = cmn.twopi * sfreq(n16);
  d1 = (f(k) - f(m)) / omega;
  d2 = e(k) - e(m);
  if (nltype(i) != -96) {
    goto statement_73584;
  }
  n7 = nonlad(i);
  curr(i) = cchar(n7 + 3);
  anonl(i) = gslope(n7);
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' TYPE-96 IN \"OVER14\".','       I      N7',21x,'CURR',20x,'VNONL',"
      "20x,'ANONL',/,21x,2i8,3e25.15)"),
      i, n7, curr(i), vnonl(i), anonl(i);
  }
  goto statement_73585;
statement_73584:
  if (nltype(i) != -98) {
    goto statement_73574;
  }
  nonle(i) = -nonle(i);
  j0 = nonlad(i);
  anonl(i) = gslope(j0) * (d1 / delta2 - d2);
statement_73585:
  k = nonlk(i);
  m = fem::iabs(nonlm(i));
  finit(m) += anonl(i);
  finit(k) = finit(k) - anonl(i);
  if (iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' FINIT(J), J=1, NTOT AT 594 OF MAIN14.',4i10,/(1x,5e25.15))");
      wloop, i, k, m, j0;
      FEM_DO_SAFE(j, 1, ntot) {
        wloop, finit(j);
      }
    }
  }
statement_73574:
  i = i - 1;
statement_73577:
  if (i > 0) {
    goto statement_73571;
  }
  if (inonl > 0 && iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' NONLINEAR-ELEMENT TABLE BEFORE  (Y)  FORMATION, IN OVER14.',/,"
        "7x,'ROW',5x,'NONLK',5x,'NONLM',4x,'NLTYPE',4x,'NONLAD',5x,'NONLE',5x,"
        "'ILAST',10x,'VNONL',11x,'CURR',10x,'ANONL',10x,'VZERO',/(7i10,"
        "4e15.5))");
      FEM_DO_SAFE(i, 1, inonl) {
        wloop, i, nonlk(i), nonlm(i), nltype(i), nonlad(i), nonle(i),
          ilast(i), vnonl(i), curr(i), anonl(i), vzer5(i);
      }
    }
  }
  last14(cmn);
  //C     FOLLOWING 2 CARDS EXTRACTED FROM "LAST14" (NO OV16 USE):          M32.4485
  if (cmn.numsm > 0) {
    past(cmn);
  }
  cmn.lastov = nchain;
  if (kill > 0) {
    goto statement_9600;
  }
  nchain++;
  //C     SCAN BRANCH TABLES FOR THE -666 BRANCHES AND INITIALIZE BRANCH    M32.4491
  if (ibr < 2) {
    goto statement_99999;
  }
  //C     VARIABLES    *   *   *   *   *   *   *   *   *   *   *   *   *   *M32.4493
  FEM_DO_SAFE(ka, 2, ibr) {
    if (length(ka) != -666) {
      goto statement_401;
    }
    kb = ka - 1;
    it2 = length(kb);
    it2 = iabsz(it2);
    it2d = ka + it2 - 1;
    kc = 0;
    FEM_DO_SAFE(kd, kb, it2d) {
      kc++;
      lfd = iabsz(kbus(kd));
      mfd = iabsz(mbus(kd));
      volt(kc) = e(mfd) - e(lfd);
    }
    breqiv(cmn, ikf, isfd, ibf);
  statement_401:;
  }
  goto statement_9800;
statement_1983:
  kill = 1;
  write(lunit6,
    "(' ------ SWITCH VECTOR NBHDSW OVERFLOW AT OVER14',"
    "' TO SOLVE THE PROBLEM, JUST ENLARGE LIST 6 -----  ')");
  lstat(16) = 6;
statement_9600:
  lstat(18) = 14;
  nchain = 51;
statement_9800:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT  \"OVER14\".')");
  }
statement_99999:;

} // over14








void top15(
  common& cmn)
{
  common_write write(cmn);
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  auto& lstat = cmn.lstat;
  auto& iprsov= cmn.iprsov;
  int& inonl = cmn.inonl;
  int& ncomp = cmn.ncomp;
  int& kpartb = cmn.kpartb;
  int& numsub = cmn.numsub;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  const auto& eta = cmn.eta;
  const auto& nltype = cmn.nltype;
  auto& nlsub = cmn.nlsub;
  auto& cursub = cmn.cursub;
  const auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  const auto& ck = cmn.ck;
  auto& tstop = cmn.tstop;
  const auto& nonlk = cmn.nonlk;
  const auto& nonlm = cmn.nonlm;
  auto& kknonl = cmn.kknonl;
  auto& isubeg = cmn.isubeg;
  const auto& imodel = cmn.imodel;
  const auto& kbus = cmn.kbus;
  const auto& kodebr = cmn.kodebr;
  const auto& kodsem = cmn.kodsem;
  const auto& iform = cmn.iform;
  const auto& node = cmn.node;
  auto& crest = cmn.crest;
  auto& time1 = cmn.time1;
  auto& time2 = cmn.time2;
  auto& tstart = cmn.tstart;
  auto& sfreq = cmn.sfreq;
  const auto& e = cmn.e;
  auto& kssfrq = cmn.kssfrq;
  auto& kode = cmn.kode;
  auto& kpsour = cmn.kpsour;
  //
  auto& lunit6 = cmn.lunit6;
  int knum = fem::int0;
  int kntbr = fem::int0;
  int k = fem::int0;
  int i = fem::int0;
  double a = fem::double0;
  int L = fem::int0;
  int nn1 = fem::int0;
  int n3 = fem::int0;
  int n2 = fem::int0;
  double gus4 = fem::double0;
  double gus3 = fem::double0;
  double gus1 = fem::double0;
  double gus2 = fem::double0;
  double h1 = fem::double0;
  double h2 = fem::double0;
  int n15 = fem::int0;
  int mark = fem::int0;
  int il = fem::int0;
  int nn15 = fem::int0;
  int numc = fem::int0;
  int nn16 = fem::int0;
  //C!DIMENSION  NSUBKM(1)
  //C!EQUIVALENCE  ( KKNONL(1), NSUBKM(1) )
  //C!EQUIVALENCE (LSTAT(14), KNUM)
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' ENTER  \"TOP15\" .','  NENERG     IBR  KSWTCH   INONL',/,17x,5i8)"),
      cmn.nenerg, ibr, cmn.kswtch, inonl;
  }
  //C
  knum = 1;
  lstat(14) = knum;
  kntbr = 0;
  iprsov(35) = 0;
  cmn.kcount = 2;
  k = 0;
  i = 1;
statement_11905:
  if (kbus(i) >= 0) {
    goto statement_905;
  }
  ci1 = ci(i);
  //C      IF (KODSEM(I) .NE. 0 .AND. IMODEL(I) .NE. -2)  GO TO 309         M31.3086
  //C 309  IF (KODSEM(I) .NE. 0 .AND. IMODEL(I) .NE. -4)  GO TO 903         M43.2246
  if (kodsem(i) != 0 && imodel(i) >= 0) {
    goto statement_903;
  }
  ck1 = std::abs(ck(i));
  a = 1.0f;
  if (ci1 < 0.f) {
    a = ck1;
  }
  if (ck(i) >= 0.0f) {
    goto statement_25903;
  }
  L = cik(i);
  a = 1.0f / eta(L);
  if (iprsup >= 2) {
    write(lunit6, "(/,' FREQ DEP  2/M*Z  AT 24903',3i10,3e20.6)"), i,
      L, k, a, ck1, ci(i);
  }
statement_25903:
  ci(i) = ci(i) * (a + ck1);
statement_905:
  i++;
  goto statement_904;
statement_903:
  nn1 = iabsz(kodebr(i));
  i += nn1;
statement_904:
  if (i <= ibr) {
    goto statement_11905;
  }
  if (kconst == 0) {
    goto statement_912;
  }
  FEM_DO_SAFE(k, 1, kconst) {
    if (iform(k) == 17) {
      crest(k) = crest(k + 1);
    }
    if (fem::iabs(iform(k)) != 14) {
      goto statement_902;
    }
    sfreq(k) = sfreq(k) * cmn.twopi;
    if (tstart(k) < 0.f) {
      tstart(k) = 0.f;
    }
  statement_902:
    if (fem::iabs(iform(k)) != 16) {
      goto statement_906;
    }
    ck1 = tstop(k + 1);
    tstop(k + 1) = 0.f;
    n3 = fem::iabs(node(k));
    n2 = fem::iabs(node(k + 1));
    gus4 = e(n3) - e(n2);
    gus3 = crest(k + 2) - gus4 * tstop(k);
    gus1 = gus3;
    if (iform(k + 1) > 1) {
      gus1 = ck1;
    }
    gus2 = gus4 * tstop(k) - crest(k);
    ck1 = gus2 / time1(k) + gus1 * sfreq(k) / crest(k + 1);
    h1 = time1(k + 1) * tstop(k) - crest(k);
    h2 = tstart(k + 1) * tstop(k) - crest(k);
    crest(k) += 2.0f * ck1;
    sfreq(k) = 1.0f - 2.0f * sfreq(k) / crest(k + 1);
    time1(k) = 1.0f - 2.0f / time1(k);
    crest(k + 1) = 2.0f * ck1;
    sfreq(k + 1) = gus2;
    time1(k + 1) = h1;
    time2(k + 1) = h2;
    tstart(k + 1) = sfreq(k) * gus3 + time1(k) * gus2;
  statement_906:;
  }
statement_912:
  n15 = -4;
  numsub = 0;
  if (inonl == 0) {
    goto statement_9200;
  }
  move0(cursub, inonl);
  move(kpsour, kssfrq(1), ntot);
  FEM_DO_SAFE(k, 1, inonl) {
    nlsub(k) = 0;
    if (nltype(k) < 0) {
      goto statement_7248;
    }
    n15 += 5;
    kknonl(n15) = n15;
    kknonl(n15 + 1) = nonlk(k);
    kknonl(n15 + 2) = fem::iabs(nonlm(k));
    kknonl(n15 + 3) = k;
    kknonl(n15 + 4) = 0;
    if (nltype(k) > 920) {
      kknonl(n15 + 4) = nltype(k) - 920;
    }
    mark = kssfrq(kknonl(n15 + 1));
    if (mark == 0) {
      mark = kssfrq(kknonl(n15 + 2));
    }
    if (mark < ntot && mark != 0) {
      goto statement_2345;
    }
    numsub++;
    isubeg(numsub) = n15;
    nlsub(k) = numsub;
    if (mark == 0) {
      goto statement_6789;
    }
    FEM_DO_SAFE(il, 2, kpartb) {
      if (kssfrq(il) == mark) {
        kssfrq(il) = numsub;
      }
    }
    goto statement_6789;
  statement_7777:
    cmn.kill = 229;
    lstat(15) = k;
    lstat(16) = kknonl(nn15 + 3);
    goto statement_9200;
  statement_2345:
    nn15 = isubeg(mark);
    if (kknonl(n15 + 4) == 0) {
      goto statement_7777;
    }
    if (kknonl(nn15 + 4) == 0) {
      goto statement_7777;
    }
    numc = 2;
  statement_2745:
    nn16 = kknonl(nn15);
    if (nn15 >= nn16) {
      goto statement_4567;
    }
    nn15 = nn16;
    numc++;
    goto statement_2745;
  statement_4567:
    kknonl(nn15) = n15;
    kknonl(n15) = nn16;
    nlsub(k) = mark;
    if (numc > ncomp) {
      ncomp = numc;
    }
  statement_6789:
    if (iprsup >= 1) {
      write(lunit6,
        "('  K, NUMSUB, N15, NCOMP, ISUBEG(NUMSUB) =',5i8)"), k,
        numsub, n15, ncomp, isubeg(numsub);
    }
  statement_7248:;
  }
  if (iprsup >= 7) {
    {
      write_loop wloop(cmn, 6, star);
      wloop, " TOP15.  KSSFRQ(1:NTOT) =";
      FEM_DO_SAFE(k, 1, ntot) {
        wloop, kssfrq(k);
      }
    }
  }
  FEM_DO_SAFE(k, 2, kpartb) {
    if (kssfrq(k) > ntot) {
      kssfrq(k) = 0;
    }
  }
  if (iprsup >= 7) {
    {
      write_loop wloop(cmn, 6, star);
      wloop, " After tamper..  KSSFRQ(1:NTOT) =";
      FEM_DO_SAFE(k, 1, ntot) {
        wloop, kssfrq(k);
      }
    }
  }
  move(kssfrq(1), kpsour(1), ntot);
statement_9200:
  move0(kode, ntot);
  cmn.nfrfld = n15;
  if (iprsup >= 3) {
    write(lunit6, "(' EXIT  \"TOP15\" .')");
  }

} // top15



void uminit(
  common& cmn,
  int& n15,
  arr_cref<double> /* reacl */,
  arr_cref<double> /* gpar */,
  arr_cref<double> /* fpar */,
  arr_cref<double> /* hist */,
  arr_cref<double> /* umcurp */,
  arr_cref<int> nodvo1,
  arr_cref<int> nodvo2,
  arr_ref<int> jcltac,
  arr_cref<int> /* jclout */,
  arr_cref<int> jtype,
  arr_cref<int> nodom,
  arr_cref<int> jtmtac,
  arr_cref<double> /* histom */,
  arr_cref<double> /* omegm */,
  arr_cref<double> /* omold */,
  arr_cref<double> /* thetam */,
  arr_cref<double> /* reamdu */,
  arr_cref<double> /* reamds */,
  arr_cref<double> /* flxds */,
  arr_cref<double> /* flxdr */,
  arr_cref<double> /* reamqu */,
  arr_cref<double> /* flxqs */,
  arr_cref<double> /* flxqr */,
  arr_cref<int> /* jcdsat */,
  arr_cref<int> /* jcqsat */,
  arr_cref<double> /* flxd */,
  arr_cref<double> /* flxq */,
  arr_cref<int> /* nppair */,
  arr_cref<double> /* rotmom */,
  arr_cref<int> ncld,
  arr_cref<int> nclq,
  arr_cref<int> /* jtqout */,
  arr_cref<int> /* jomout */,
  arr_cref<int> /* jthout */,
  arr_cref<double> /* reamqs */,
  arr_cref<double> /* epsom */,
  arr_cref<double> /* dcoef */,
  arr_cref<int> kcoil,
  arr_cref<double> /* voltum */,
  arr_cref<double> /* anglum */,
  arr_cref<int> /* nodfum */,
  arr_cref<int> /* nodmum */,
  arr_cref<int> /* kumout */,
  arr_cref<int> /* jumout */,
  arr_cref<double> /* umoutp */)
{
  nodvo1(dimension(1));
  nodvo2(dimension(1));
  jcltac(dimension(1));
  jtype(dimension(1));
  nodom(dimension(1));
  jtmtac(dimension(1));
  ncld(dimension(1));
  nclq(dimension(1));
  kcoil(dimension(1));
  common_write write(cmn);
  auto& lstat = cmn.lstat;
  int& ncomp = cmn.ncomp;
  int& numum = cmn.numum;
  int& numsub = cmn.numsub;
  int& iprsup = cmn.iprsup;
  const auto& loopss = cmn.loopss;
  auto& kknonl = cmn.kknonl;
  auto& isubeg = cmn.isubeg;
  auto& kpsour = cmn.kpsour;
  int& ksubum = cmn.ksubum;
  //
  auto& lunit6 = cmn.lunit6;
  int nclcom = fem::int0;
  int k = fem::int0;
  int kcl = fem::int0;
  int n2 = fem::int0;
  int n3 = fem::int0;
  int n4 = fem::int0;
  int nshare = fem::int0;
  int n8 = fem::int0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  int n16 = fem::int0;
  int numcom = fem::int0;
  int j = fem::int0;
  int mars = fem::int0;
  int num = fem::int0;
  int mark = fem::int0;
  int mm = fem::int0;
  int n7 = fem::int0;
  int n9 = fem::int0;
  int n1 = fem::int0;
  auto& nsubkm = cmn.kknonl;
  //C  JCLTAC(KCL AND KCL+1) ARE DEFINED AND INITIALIZED IN UMRENU          M39.2713
  //C  JCLTAC(KCL+2) IS DEFINED HERE. IT IS ZERO UNLESS A SET OF            M39.2714
  //C     OF MAX 3 UM'S SHARING A COMMON MECH NETW IS DEALT WITH.           M39.2715
  //C   * IT IS SET TO THE UM NR IF THE UM WITH THIS KCL IS THE             M39.2716
  //C     LOWEST NUMBERED UM IN THIS SET. THIS UM TAKES CARE OF             M39.2717
  //C     THE MULTI- PHASE COMPENSATION OF THE COMMON MECH NETW.            M39.2718
  //C   * IT IS SET TO THE NEGATIVE VALUE OF THE "CURSUB" ENTRY IF          M39.2719
  //C     IT IS NOT THE LOWEST NUMBERED UM IN THIS SET.                     M39.2720
  //C  NSHARE IS A FLAG TO DECIDE HOW MECH NETWORKS OF EACH UM ARE          M39.2721
  //C     TO BE COMPENSATED.                                                M39.2722
  //C     NSHARE = 1  : NO COMP OF MECH NETWORK IN CASE THAT IT             M39.2723
  //C                 HAS BEEN DONE EARLIER BY A MECHANICALLY               M39.2724
  //C                 CONNECTED LOWER-NUMBERED UM                           M39.2725
  //C     NSHARE = 0 : UM NOT MECHANICALLY CONNECTED TO OTHER UM'S          M39.2726
  //C                 AND HENCE SINGLE-PHASE COMP AS USUAL.                 M39.2727
  //C     NSHARE = 10 : COMPENSATION OF COMMON MECH NETWRK TO BE            M39.2728
  //C                   CONDUCTED WITH THE LOWEST NUMBERED UM.              M39.2729
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE UMINIT.\"')");
  }
  cmn.istart = 0;
  ksubum = numsub + 1;
  nclcom = n15 + 5;
  if (iprsup >= 1) {
    write(lunit6, "(/,' BEGIN  \"UMINIT\" . KSUBUM =',i4)"), ksubum;
  }
  //C  NCOMP IS THE MAX NUMBER OF COMPENSATED PHASES PER SUBNETWORK.        M33.1449
  //C  N8 IS USED TO DETERMINE THE VALUE OF THIS NCOMP.                     M33.1450
  FEM_DO_SAFE(k, 1, numum) {
    kcl = kcoil(k);
    jcltac(kcl + 2) = 0;
    n2 = jcltac(kcl);
    n3 = jcltac(kcl + 1);
    n4 = k;
    if (n2 == 0 && n3 == 0) {
      goto statement_7010;
    }
    if (n2 != 0 && n2 < n4) {
      n4 = n2;
    }
    if (n3 != 0 && n3 < n4) {
      n4 = n3;
    }
    if (n4 == k) {
      jcltac(kcl + 2) = k;
    }
  statement_7010:;
  }
  FEM_DO_SAFE(k, 1, numum) {
    kcl = kcoil(k);
    nshare = jcltac(kcl) + jcltac(kcl + 1);
    if (nshare != 0) {
      nshare = 1;
    }
    if (jcltac(kcl + 2) > 0) {
      nshare = 10;
    }
    //C  COMPENSATION OF POWER NETWORK *******************************        M39.2747
    n8 = 0;
    numsub++;
    isubeg(numsub) = n15 + 5;
    n5 = kcl;
    n6 = n5 + 2;
    n16 = 0;
    numcom = k;
    if (loopss(8) == 1) {
      goto statement_7310;
    }
    j = n5;
    mars = 1;
  statement_1111:
    if (nodvo1(j) == nodvo2(j)) {
      goto statement_7305;
    }
  statement_6666:
    n8++;
    n15 += 5;
    kknonl(n15) = n15 + 5;
  statement_6767:
    kknonl(n15 + 1) = nodvo1(j);
    kknonl(n15 + 2) = nodvo2(j);
    //C CODE SECTION REPEATEDLY CALLED FOR EACH COMPENSATED NODE-PAIR:        M39.2751
  statement_6868:
    kknonl(n15 + 3) = -k;
    kknonl(n15 + 4) = mars;
    n16 = 1;
    nclcom++;
    num = 0;
    mark = kpsour(kknonl(n15 + 1));
  statement_1010:
    if (mark == 0 || mark == numsub) {
      goto statement_1515;
    }
    if (mark < cmn.ntot) {
      goto statement_7777;
    }
    FEM_DO_SAFE(mm, 2, cmn.kpartb) {
      if (kpsour(mm) == mark) {
        kpsour(mm) = numsub;
      }
    }
  statement_1515:
    if (num > 0) {
      goto statement_1616;
    }
    num = 1;
    mark = kpsour(kknonl(n15 + 2));
    goto statement_1010;
  statement_7777:
    write(lunit6,
      "(/,' ERROR STOP. SOMETHING HAS GONE WRONG WITH',"
      "' SETTING UP THE COMPENSATION TABLES IN MODULE',' \"UMINIT\" FOR UM -',"
      "i4,'. CONSULT EMTP',/,' MANAGEMENT AFTER MAKING SURE THAT YOU DID',"
      "' NOT VIOLATE THE UM RULE REGARDING THE',' THREE-PHASE RESTRICTION.')"),
      k;
    cmn.kill = 229;
    n15 = isubeg(mark);
    lstat(15) = k;
    lstat(16) = kknonl(n15 + 3);
    goto statement_9800;
  statement_1616:
    switch (mars) {
    case 1: goto statement_7305;
    case 2: goto statement_7312;
    case 3: goto statement_7318;
    case 4: goto statement_7322;
    default: break;
    }
    //C  END CODE SECTION ............................................        M39.2763
  statement_7305:
    j++;
    if (j <= n6) {
      goto statement_1111;
    }
    //C  THE FOLLOWING CONDITION IS NEEDED FOR THE LAST NODE-PAIR             M39.2764
    //C    TO BE COMPENSATED FOR THIS SUBNETWORK. THIS CONDITION IS           M39.2765
    //C    TO BE INSERTED FOR ALL THE OTHER SUBNETWORKS.                      M39.2766
    if (n16 == 1) {
      kknonl(n15) = isubeg(numsub);
    }
    if (n8 > ncomp) {
      ncomp = n8;
    }
    //C  COMPENSATION OF EXCIT NETWORK FOR 3 OR LESS COILS ***********        M39.2768
    n8 = 0;
    if (n16 == 0) {
      goto statement_7310;
    }
    numsub++;
    isubeg(numsub) = n15 + 5;
  statement_7310:
    n16 = 0;
    n6 = n5 + 2 + ncld(k) + nclq(k);
    if (jtype(k) == 4) {
      n6++;
    }
    n7 = n6 - n5 + 1;
    n9 = n6;
    if (n7 > 6) {
      n9 = n5 + 5;
    }
    n5 += 3;
    j = n5;
    mars = 2;
  statement_2222:
    if (j > n9) {
      goto statement_2323;
    }
    if (nodvo1(j) != nodvo2(j)) {
      goto statement_6666;
    }
  statement_7312:
    j++;
    goto statement_2222;
  statement_2323:
    if (n16 == 1) {
      kknonl(n15) = isubeg(numsub);
    }
    if (n8 > ncomp) {
      ncomp = n8;
    }
    //C  COMPENSATION OF EXCIT NETWORK FOR 4 OR MORE COILS ***********        M39.2769
    //C    NOTE : IN THIS CASE THEY WILL ALL BE SINGLE-PHASE COMP             M39.2770
    n8 = 0;
    if (n7 <= 6) {
      goto statement_7319;
    }
    n5 += 3;
    j = n5;
    mars = 3;
  statement_3333:
    if (j > n6) {
      goto statement_3434;
    }
    if (nodvo1(j) == nodvo2(j)) {
      goto statement_7318;
    }
    if (n16 == 0) {
      goto statement_7316;
    }
    numsub++;
    isubeg(numsub) = n15 + 5;
  statement_7316:
    n15 += 5;
    n8 = 1;
    kknonl(n15) = n15;
    goto statement_6767;
  statement_7318:
    j++;
    goto statement_3333;
  statement_3434:
    if (n8 > ncomp) {
      ncomp = n8;
    }
    //C  COMPENSATION OF MECH NETWORK ********************************        M39.2772
  statement_7319:
    n8 = 0;
    if (jtmtac(k) != 0) {
      goto statement_7328;
    }
    if (nshare == 1) {
      goto statement_7328;
    }
    mars = 4;
    if (n16 == 0) {
      goto statement_7320;
    }
    numsub++;
    isubeg(numsub) = n15 + 5;
  statement_7320:
    n15 += 5;
    n8++;
    kknonl(n15) = n15 + 5;
    kknonl(n15 + 1) = nodom(numcom);
    kknonl(n15 + 2) = 1;
    goto statement_6868;
    //C  COMPENSATION OF HIGHER NUMBERED UM IF MECHANICALLY CONNECTED         M39.2780
  statement_7322:
    if (nshare == 0) {
      goto statement_7325;
    }
    if (nshare == -1) {
      goto statement_7324;
    }
    nshare = 0;
    if (jcltac(kcl + 1) != 0) {
      nshare = -1;
    }
    numcom = jcltac(kcl);
    if (numcom == 0) {
      goto statement_7324;
    }
    n1 = kcoil(numcom);
    jcltac(n1 + 2) = -nclcom;
    goto statement_7320;
  statement_7324:
    numcom = jcltac(kcl + 1);
    nshare = 0;
    n1 = kcoil(numcom);
    jcltac(n1 + 2) = -nclcom;
    goto statement_7320;
  statement_7325:
    if (n16 == 1) {
      kknonl(n15) = isubeg(numsub);
    }
    if (n8 > ncomp) {
      ncomp = n8;
    }
  statement_7328:
    if (n16 == 0) {
      numsub = numsub - 1;
    }
  }
statement_9800:
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE UMINIT.\"')");
  }
}


struct smout_save
{
  arr<fem::str<8> > digit;
  fem::str<8> text1;
  arr<fem::str<8> > texta;
  arr<fem::str<8> > textb;

  smout_save() :
    digit(dimension(10), fem::fill0),
    text1(fem::char0),
    texta(dimension(15), fem::fill0),
    textb(dimension(3), fem::fill0)
  {}
};

void smout(
  common& cmn)
{
  FEM_CMN_SVE(smout);
  common_write write(cmn);
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  int& iprsup = cmn.iprsup;
  auto& ismout = cmn.ismout;
  const auto& ismdat = cmn.ismdat;
  int& nst = cmn.nst;
  int& nsmout = cmn.nsmout;
  //
  str_arr_ref<1> digit(sve.digit, dimension(10));
  fem::str<8>& text1 = sve.text1;
  str_arr_ref<1> texta(sve.texta, dimension(15));
  str_arr_ref<1> textb(sve.textb, dimension(3));
  if (is_called_first_time) {
    texta(1) = "ID    ";
    texta(2) = "IQ    ";
    texta(3) = "I0    ";
    texta(4) = "IF    ";
    texta(5) = "IKD   ";
    texta(6) = "IG    ";
    texta(7) = "IKQ   ";
    texta(8) = "IA    ";
    texta(9) = "IB    ";
    texta(10) = "IC    ";
    texta(11) = "EFD   ";
    texta(12) = "MFORCE";
    texta(13) = "MANG  ";
    texta(14) = "TQ GEN";
    texta(15) = "TQ EXC";
    textb(1) = "ANG   ";
    textb(2) = "VEL   ";
    textb(3) = "TOR   ";
    digit(1) = "1     ";
    digit(2) = "2     ";
    digit(3) = "3     ";
    digit(4) = "4     ";
    digit(5) = "5     ";
    digit(6) = "6     ";
    digit(7) = "7     ";
    digit(8) = "8     ";
    digit(9) = "9     ";
    digit(10) = "0     ";
    text1 = "MACH  ";
  }
  int ll5 = fem::int0;
  int ll6 = fem::int0;
  int jk = fem::int0;
  int jk1 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int ip1 = fem::int0;
  int ip = fem::int0;
  int i30 = fem::int0;
  int i = fem::int0;
  int n = fem::int0;
  int i5 = fem::int0;
  int n15 = fem::int0;
  int L = fem::int0;
  arr_1d<1, fem::str<8> > busvec(fem::fill0);
  int n10 = fem::int0;
  fem::str<8> text2 = fem::char0;
  int icnt = fem::int0;
  int m = fem::int0;
  int jb = fem::int0;
  int n7 = fem::int0;
  int n6 = fem::int0;
  int n5 = fem::int0;
  double d12 = fem::double0;
  //C     THIS MODULE IS USED ONLY BY  TYPE 59 S.M.  MODELING               M38.2986
  ll5 = 5;
  ll6 = 6;
  nsmout = 0;
  jk = 0;
  jk1 = 0;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' BEGIN  ''SMOUT'' .','     NST    LSYN',/,17x,4i8)"), nst,
      cmn.lsyn;
  }
  n1 = 0;
  n2 = 0;
  ip1 = -2;
  FEM_DO_SAFE(ip, 1, nst) {
    i30 = 30 * ip - 29;
    n2++;
    if (n2 <= 9) {
      goto statement_4113;
    }
    n2 = 0;
    n1++;
  statement_4113:
    i = ip;
    n = i;
    i5 = i30 + 17;
    n15 = ismdat(i5);
    if (n15 < 0) {
      goto statement_3648;
    }
    L = 5;
    busvec(1) = text1;
    if (n1 > 0) {
      packa1(digit(n1), busvec(1), L);
    }
    L++;
    n10 = n2;
    if (n10 == 0) {
      n10 = 10;
    }
    packa1(digit(n10), busvec(1), L);
    text2 = busvec(1);
    icnt = 0;
    namea6(cmn, text2, icnt);
    if (n15 == 0) {
      goto statement_21;
    }
    FEM_DO_SAFE(L, 1, n15) {
      ip1 += 3;
      m = ismout(ip1);
      jk++;
      jk1 += 3;
      ismout(jk1 - 1) = icnt;
      text2 = texta(m);
      jb = 0;
      namea6(cmn, text2, jb);
      ismout(jk1) = jb;
    }
  statement_21:
    FEM_DO_SAFE(n7, 1, 3) {
      i5++;
      n15 = ismdat(i5);
      if (n15 == 0) {
        goto statement_4224;
      }
      FEM_DO_SAFE(L, 1, n15) {
        ip1 += 3;
        n6 = ismout(ip1);
        n5 = n6 / 10;
        n6 = n6 - 10 * n5;
        busvec(1) = textb(n7);
        if (n5 > 0) {
          goto statement_4206;
        }
        packa1(digit(n6), busvec(1), ll5);
        goto statement_4215;
      statement_4206:
        packa1(digit(n5), busvec(1), ll5);
        n10 = n6;
        if (n10 == 0) {
          n10 = 10;
        }
        packa1(digit(n10), busvec(1), ll6);
      statement_4215:
        jk++;
        jk1 += 3;
        ismout(jk1 - 1) = icnt;
        jb = 0;
        text2 = busvec(1);
        namea6(cmn, text2, jb);
        ismout(jk1) = jb;
      }
    statement_4224:;
    }
    if (jk <= cmn.lsmout) {
      goto statement_3648;
    }
    cmn.kill = 1;
    lstat(19) = 4224;
    lstat(16) = 11;
    return;
  statement_3648:;
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (I, JSMOUT(I), KSMOUT(I), I=1, JK)',/(1x,10(3i4,1x)))");
      FEM_DO_SAFE(i, 1, jk) {
        wloop, i, ismout(3 * i), ismout(3 * i - 1);
      }
    }
  }
  nsmout = jk;
  d12 = nbyte(4);
  d12 = (3 * nsmout) * d12 / nbyte(3);
  cmn.msmout = d12 + 1.0f;
}




struct over15_save
{
  fem::str<8> text1;
  fem::str<8> text10;
  fem::str<8> text11;
  fem::str<8> text12;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;
  fem::str<8> text8;
  fem::str<8> text9;

  over15_save() :
    text1(fem::char0),
    text10(fem::char0),
    text11(fem::char0),
    text12(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0),
    text8(fem::char0),
    text9(fem::char0)
  {}
};

// FINAL SETUP OPERATIONS BEFORE TIME-STEP LOOP.                
void over15(
  common& cmn)
{
  FEM_CMN_SVE(over15);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& blank = cmn.blank;
  fem::str<8>& terra = cmn.terra;
  const auto& date1 = cmn.date1;
  const auto& tclock = cmn.tclock;
  const auto& abuff = cmn.abuff;
  double& xmaxmx = cmn.xmaxmx;
  const auto& begmax = cmn.begmax;
  double& fltinf = cmn.fltinf;
  auto& flstat = cmn.flstat;
  auto& moncar = cmn.moncar;
  auto& lunit4 = cmn.lunit4;
  auto& lunit9 = cmn.lunit9;
  const auto& kprchg = cmn.kprchg;
  const auto& multpr = cmn.multpr;
  auto& lstat = cmn.lstat;
  int& icheck = cmn.icheck;
  int& inonl = cmn.inonl;
  int& istep = cmn.istep;
  int& kcount = cmn.kcount;
  int& lbus = cmn.lbus;
  int& lswtch = cmn.lswtch;
  int& iplot = cmn.iplot;
  int& ncomp = cmn.ncomp;
  int& nv = cmn.nv;
  int& npower = cmn.npower;
  int& maxpe = cmn.maxpe;
  int& lsiz12 = cmn.lsiz12;
  auto& ktrlsw = cmn.ktrlsw;
  int& maxbus = cmn.maxbus;
  int& lastov = cmn.lastov;
  int& noutpr = cmn.noutpr;
  int& lsiz26 = cmn.lsiz26;
  int& numout = cmn.numout;
  int& numsub = cmn.numsub;
  int& modout = cmn.modout;
  int& kill = cmn.kill;
  int& ivolt = cmn.ivolt;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& intinf = cmn.intinf;
  int& kconst = cmn.kconst;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  int& limstp = cmn.limstp;
  int& nc = cmn.nc;
  int& numnvo = cmn.numnvo;
  int& nenerg = cmn.nenerg;
  auto& xmax = cmn.xmax;
  auto& koutvp = cmn.koutvp;
  auto& ibsout = cmn.ibsout;
  auto& bvalue = cmn.bvalue;
  auto& sptacs = cmn.sptacs;
  const auto& kswtyp = cmn.kswtyp;
  auto& modswt = cmn.modswt;
  const auto& topen = cmn.topen;
  const auto& crit = cmn.crit;
  const auto& kdepsw = cmn.kdepsw;
  const auto& isourc = cmn.isourc;
  const auto& nonlad = cmn.nonlad;
  const auto& nonle = cmn.nonle;
  const auto& vnonl = cmn.vnonl;
  const auto& curr = cmn.curr;
  const auto& anonl = cmn.anonl;
  const auto& vecnl1 = cmn.vecnl1;
  const auto& namenl = cmn.namenl;
  const auto& nltype = cmn.nltype;
  const auto& vecnl2 = cmn.vecnl2;
  const auto& kupl = cmn.kupl;
  const auto& ismout = cmn.ismout;
  const auto& cchar = cmn.cchar;
  const auto& vchar = cmn.vchar;
  const auto& gslope = cmn.gslope;
  const auto& texvec = cmn.texvec;
  auto& ibrnch = cmn.ibrnch;
  auto& jbrnch = cmn.jbrnch;
  const auto& nonlk = cmn.nonlk;
  auto& nonlm = cmn.nonlm;
  auto& spum = cmn.spum;
  const auto& kknonl = cmn.kknonl;
  const auto& isubeg = cmn.isubeg;
  const auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  const auto& namebr = cmn.namebr;
  const auto& iform = cmn.iform;
  const auto& node = cmn.node;
  const auto& crest = cmn.crest;
  const auto& time1 = cmn.time1;
  const auto& time2 = cmn.time2;
  const auto& tstart = cmn.tstart;
  const auto& sfreq = cmn.sfreq;
  const auto& kmswit = cmn.kmswit;
  auto& nextsw = cmn.nextsw;
  auto& tclose = cmn.tclose;
  const auto& adelay = cmn.adelay;
  auto& kpos = cmn.kpos;
  const auto& namesw = cmn.namesw;
  const auto& busum = cmn.busum;
  auto& e = cmn.e;
  auto& kssfrq = cmn.kssfrq;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;

  auto& bus = cmn.bus;
  int& nsmout = cmn.nsmout;
  int& numbus = cmn.numbus;
  int& iukumo = cmn.iukumo;
  int& iujumo = cmn.iujumo;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text10 = sve.text10;
  fem::str<8>& text11 = sve.text11;
  fem::str<8>& text12 = sve.text12;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  fem::str<8>& text7 = sve.text7;
  fem::str<8>& text8 = sve.text8;
  fem::str<8>& text9 = sve.text9;
  if (is_called_first_time) {
    text1 = "TACS  ";
    text4 = "NORMAL";
    text5 = "      ";
    text6 = "UNIFOR";
    text7 = "M     ";
    text8 = " MIDDL";
    text9 = "E     ";
    text10 = "MINIMU";
    text11 = "M     ";
    text12 = "CHAN01";
  }
  int lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  double d2 = fem::double0;
  int ijk = fem::int0;
  arr_1d<13, fem::str<8> > aupper(fem::fill0);
  int L = fem::int0;
  int n13 = fem::int0;
  int j = fem::int0;
  int i = fem::int0;
  int jk = fem::int0;
  int ip = fem::int0;
  int ik = fem::int0;
  int iprint = fem::int0;
  int nk1 = fem::int0;
  int nk2 = fem::int0;
  int mpower = fem::int0;
  int kswpe4 = fem::int0;
  fem::str<8> text2 = fem::char0;
  fem::str<8> text3 = fem::char0;
  int n1 = fem::int0;
  int ndx1 = fem::int0;
  int m = fem::int0;
  double d1 = fem::double0;
  int n2 = fem::int0;
  int k = fem::int0;
  int ndx2 = fem::int0;
  int n3 = fem::int0;
  int n15 = fem::int0;
  int n11 = fem::int0;
  int n12 = fem::int0;
  int n14 = fem::int0;
  int mpr = fem::int0;
  int n44 = fem::int0;
  int ioutcs = fem::int0;
  int n5 = fem::int0;
  int n16 = fem::int0;
  int n9 = fem::int0;
  int n23 = fem::int0;
  int ntacs = fem::int0;
  int n8 = fem::int0;
  int n18 = fem::int0;
  int ncsave = fem::int0;
  int i3 = fem::int0;
  int n17 = fem::int0;
  int n19 = fem::int0;
  int numbco = fem::int0;
  int lunit6save = fem::int0;
  int n4 = fem::int0;
  int kprsta = fem::int0;
  arr_1d<13, fem::str<8> > alower(fem::fill0);
  int moon = 0;
  fem::str<132> outlin = fem::char0;
  int ndx4 = fem::int0;
  double d6 = fem::double0;
  double d11 = fem::double0;
  int n6 = fem::int0;
  int k1 = fem::int0;
  static const char* format_3113 =
    "(/,' ''KOUTVP''  AND  ''KOUTIE''  PAIRS.',/(1x,10i12))";
  static const char* format_3207 =
    "(/,' BEFORE OUTPUT-VARIABLE HEADING.',"
    "'      NC  LSIZ12  NSMOUT  IOUTCS    NTOT',"
    "'  NUMNVO      NV      N8  MAXBUS      N9     N18',/,32x,12i8)";
  static const char* format_4568 = "('  \"EXIT  MODULE OVER15.\"')";
  static const char* format_8026 = "(/,' KOUTVP OR KOUTIE',/(1x,10i10))";
  static const char* format_8927 = "(a132)";

  auto ispum = ArraySpan(reinterpret_cast<int*>(&spum(1)), spum.size() * 2);
  auto& nsubkm = kknonl;

  auto& knt = moncar(1);
  auto& kbase = moncar(2);
  auto& ltdelt = moncar(3);
  auto& isw = moncar(4);
  auto& idist = moncar(5);
  auto& itest = moncar(6);

  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;

  auto& kjout =  isptacs(12);
  auto& klntab = isptacs(18);

  //C     TRANSFER TO  "TOP15"  FOR FRONT END OF OVERLAY 15.                M28.4664
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER15.\"')");
  }
  move0(kssfrq, ntot);
  top15(cmn);
  if (kill > 0) {
    goto statement_9200;
  }
  goto statement_3038;
  //C     READ USER-SUPPLIED NAMES FOR EMTP NODE-VOLTAGE OUTPUT.  ----------M33.1150
  //C     READ INPUT CARD USING CIMAGE.                                     M33.1151
statement_1030:
  cimage(cmn);
statement_3038:
  read(abuff, "(i2,13a6)"), ijk, aupper;
  if (ijk != 1) {
    goto statement_8211;
  }
  numnvo = cmn.ntot1;
  ivolt = ijk;
  if (noutpr == 0) {
    write(kunit6, "('+REQUEST FOR OUTPUT OF ALL NODE VOLTAGES.')");
  }
  interp();
  if (aupper(1) == blank) {
    goto statement_3094;
  }
  goto statement_1030;
statement_8211:
  L = 0;
  if (aupper(1) != text12) {
    goto statement_4693;
  }
  //C     HONOR "CHAN01" IN COLS. 3-8 BY BUILDING DUMMY NODE VOLTAGE        M37.4957
  //C     CHANNELS WITH NAMES "CHAN01", "CHAN02", ETC.:                     M37.4958
  read(abuff, "(8x,i8)"), n13;
  if (n13 + ntot <= lbus && n13 > 0) {
    goto statement_4682;
  }
statement_4675:
  write(lunit6,
    "('   = = =  No, too many dummy node voltage',"
    "' output channels for EMTP dimensions.',/,"
    "'          N13 + NTOT .GT. LBUS,   where   N13,',' NTOT, LBUS =',3i8,"
    "'     If execution is',/,'          interactive,  DEPOSIT  revised  N13',"
    "'  value in  ISTEP  at next SPY break.')"),
    n13, ntot, lbus;
  spying(cmn);
  n13 = istep;
  istep = 0;
statement_4682:
  if (noutpr == 0) {
    write(kunit6, "('+DUMMY NODE VOLTAGE OUTPUT NUMBER',i8)"), n13;
  }
  FEM_DO_SAFE(j, 1, n13) {
    nmincr(cmn, text12, j);
    bus(ntot + j) = text12;
    numnvo++;
    if (numnvo > lsiz12) {
      goto statement_4675;
    }
    e(ntot + j) = 0.0f;
    ibsout(numnvo) = ntot + j;
  }
  goto statement_1030;
  //CCCCC  4693 DO 8288 I = 1, 13                                                 M37.4984
statement_4693:
  if (ijk != -5) {
    goto statement_1830;
  }
  //CCCC  write (*,*) ' Begin search for branch voltages.   NV =', nv
  FEM_DOSTEP(i, 1, 11, 2) {
    if (aupper(i) == blank && aupper(i + 1) == blank) {
      goto statement_4962;
    }
    FEM_DO_SAFE(jk, 1, 2) {
      bus1 = aupper(i + jk - 1);
      //CCCC  write (*,*) ' Ready to check next name.  JK, BUS1 =',  JK, BUS1
      FEM_DO_SAFE(ip, 1, ntot) {
        if (bus1 != bus(ip)) {
          goto statement_2801;
        }
        //CCCC  write (*,*) ' Match found.   JK, IP =',  JK, IP
        if (jk == 1) {
          ibrnch(nv + 1) = ip;
        }
        if (jk == 2) {
          jbrnch(nv + 1) = ip;
        }
        if (jk == 1) {
          goto statement_5183;
        }
        nv++;
        //CCCC  write (*,*) ' Done assigning V-branch out.   NV, IBRNCH(NV),',
        //CCCC 1            ' JBRNCH(NV) =',   NV, IBRNCH(NV), JBRNCH(NV)
        goto statement_4962;
      statement_2801:;
      }
      if (noutpr == 0) {
        write(lunit6,
          "(5x,'Ignore V-branch request involving nonexistent',' node  \"',a6,"
          "'\"')"),
          bus1;
      }
      goto statement_4962;
    statement_5183:;
    }
  statement_4962:;
  }
  if (noutpr == 0) {
    write(kunit6, "('+CARD of name pairs for branch voltages.')");
  }
  goto statement_1030;
statement_1830:
  FEM_DO_SAFE(i, 1, 13) {
    if (ijk < 0) {
      goto statement_8215;
    }
    bus1 = aupper(i);
    if (bus1 == blank) {
      goto statement_8288;
    }
    L = 1;
    FEM_DO_SAFE(ik, 2, ntot) {
      if (bus1 == bus(ik)) {
        goto statement_3056;
      }
    }
    if (noutpr == 0) {
      write(lunit6,
        "(5x,'REQUEST FOR VOLTAGE OUTPUT OF NONEXISTENT NODE ''',a6,"
        "''' WILL BE IGNORED.')"),
        bus1;
    }
    goto statement_8288;
  statement_3056:
    if (ivolt == 1) {
      goto statement_8888;
    }
    numnvo++;
    ibsout(numnvo) = ik;
    if (numnvo <= lsiz12) {
      goto statement_8288;
    }
    iprint = 11;
    lstat(19) = 3056;
    goto statement_9000;
  statement_8888:
    write(lunit6,
      "(' THERE HAS BEEN THE REQUEST FOR ALL NODE VOLTAGE',"
      "' OUTPUT, SO THIS REQUEST WILL BE IGNORED.')");
    goto statement_1030;
  statement_8215:
    L = 1;
    if (aupper(i) == blank) {
      goto statement_8288;
    }
    FEM_DO_SAFE(j, 1, ibr) {
      ip = namebr(j);
      if (texvec(ip) == aupper(i)) {
        goto statement_8231;
      }
    }
    FEM_DO_SAFE(j, 1, inonl) {
      ip = namenl(j);
      if (texvec(ip) == aupper(i)) {
        goto statement_8233;
      }
    }
    FEM_DO_SAFE(j, 1, kswtch) {
      ip = namesw(j);
      if (texvec(ip) == aupper(i)) {
        goto statement_8235;
      }
    }
    write(lunit6,
      "('     REQUEST FOR BRANCH OUTPUT OF NONEXISTENT',"
      "' BRANCH WILL BE IGNORED')");
    goto statement_8288;
  statement_8311:
    iprint = 11;
    lstat(19) = 8237;
    goto statement_9000;
  statement_8333:
    iprint = 18;
    lstat(19) = 8237;
    goto statement_9000;
  statement_8231:
    jk = 1111;
    nk1 = fem::iabs(kbus(j));
    nk2 = fem::iabs(mbus(j));
    if (ijk != -2) {
      mbus(j) = -nk2;
    }
    goto statement_8237;
  statement_8235:
    jk = 3333;
    nk1 = kmswit(j);
    nk2 = kmswit(j + lswtch);
    if (ijk != -2) {
      kpos(j) = -fem::iabs(kpos(j));
    }
    goto statement_8237;
  statement_8233:
    jk = 2222;
    nk1 = nonlk(j);
    nk2 = fem::iabs(nonlm(j));
    if (ijk != -2) {
      nonlm(j) = -nk2;
    }
  statement_8237:
    if (ijk > -2) {
      goto statement_8288;
    }
    nv++;
    if (nv > lsiz12) {
      goto statement_8311;
    }
    if (ijk >= -3) {
      goto statement_8260;
    }
    npower++;
    if (npower > maxpe) {
      goto statement_8333;
    }
    mpower = npower + maxpe;
    koutvp(npower) = nv;
    if (jk == 3333) {
      koutvp(npower) = -nv;
    }
    koutvp(mpower) = j;
    if (jk == 2222) {
      koutvp(mpower) = -j;
    }
    if (jk == 3333 && kswpe4 == 0) {
      kswpe4 = npower;
    }
    if (iprsup > 2) {
      write(lunit6, "(/,' POWER OUTPUT REQUEST',4i10)"), npower,
        maxpe, koutvp(npower), koutvp(mpower);
    }
  statement_8260:
    if (jk != 2222 || nk1 <= nk2) {
      goto statement_8262;
    }
    if (fem::iabs(nltype(j)) != 99) {
      goto statement_8262;
    }
    ibrnch(nv) = nk2;
    jbrnch(nv) = nk1;
    goto statement_8288;
  statement_8262:
    ibrnch(nv) = nk1;
    jbrnch(nv) = nk2;
  statement_8288:;
  }
  if (L == 0) {
    goto statement_3081;
  }
  if (noutpr == 0) {
    write(kunit6, "('+CARD OF BUS NAMES FOR NODE-VOLTAGE OUTPUT.')");
  }
  goto statement_1030;
statement_3081:
  if (noutpr == 0) {
    write(kunit6, "('+BLANK CARD ENDING NODE NAMES FOR VOLTAGE OUTPUT.')");
  }
  interp();
  if (nenerg == 0) {
    goto statement_3094;
  }
  write(lunit6,
    "(/,/,"
    "' THE DATA CASE NOW READY TO BE SOLVED IS A STATISTICAL OVERVOLTAGE STUDY"
    " WHICH INVOLVES',i7,'   ENERGIZATIONS')"),
    nenerg;
  if (nenerg < 0) {
    goto statement_1329;
  }
  text2 = text4;
  text3 = text5;
  if (idist == 0) {
    goto statement_1310;
  }
  text2 = text6;
  text3 = text7;
statement_1310:
  write(lunit6,
    "(' (PARAMETER  \"NENERG\"  OF COLUMNS 65-72',"
    "' OF THE 2ND MISC. DATA CARD).  ',"
    "' SWITCH CLOSING OR OPENING TIMES FOR THE',/,"
    "' SPECIALLY-FLAGGED SWITCHES (WITH \"STATISTICS\"',"
    "' PUNCHED IN COLUMNS 55-64) ARE VARIED RANDOMLY',' ACCORDING TO A ',a6,"
    "a1,' DISTRIBUTION.')"),
    text2, text3;
  write(lunit6,
    "(' THE USER CAN SELECT EITHER UNIFORM OR NORMAL DISTRIBUTIONS, BASED ON T"
    "HE VALUE OF PARAMETER  ''IDIST''  OF COLUMNS',/,"
    "' 17-24 OF THE SPECIAL STATISTICS MISC. DATA CARD.   THE FOLLOWING IS A L"
    "ISTING OF SWITCHES WHOSE CLOSING TIMES ARE',/,"
    "' TO BE STATISTICALLY VARIED, ALONG WITH THE ASSOCIATED MEAN AND STANDARD"
    " DEVIATION FOR THE DISTRIBUTION, AS REQUESTED',' BY THE USER.')");
  if (xmaxmx < 0.0f) {
    write(lunit6,
      "(' THE USER PUNCHED STATISTICS MISCELLANEOUS DATA',"
      "' PARAMETER  XMAXMX =',e12.3,"
      "' ,   WITH THE NEGATIVE VALUE REPRESENTING',/,"
      "' A REQUEST FOR USE OF THE 100 BUILT-IN RANDOM',"
      "' NUMBERS.   AS SUCH, THE ANSWER IS REALLY',"
      "' DETERMINISTIC, THEN (A SECOND SOLUTION',/,"
      "' ON ANY COMPUTER SHOULD GIVE THE SAME ANSWER).')"),
      xmaxmx;
  }
  goto statement_1336;
statement_1329:
  text2 = text8;
  text3 = text9;
  if (itest > 0) {
    goto statement_8329;
  }
  text2 = text10;
  text3 = text11;
statement_8329:
  write(lunit6,
    "(' (PARAMETER  \"NENERG\"  OF COLUMNS 65-72',"
    "' OF THE 2ND MISC. DATA CARD).',/,"
    "' CLOSING TIMES FOR THE SPECIALLY-FLAGGED SWITCHES (WITH  ''SYSTEMATIC'' "
    " PUNCHED IN COLUMNS 55-64) ARE VARIED',/,1x,"
    "'REGULARLY BETWEEN MINIMUM AND MAXIMUM TIMES, WITH A UNIFORM INCREMENT IN"
    " BETWEEN FOR EACH SWITCH.   THE FOLLOWING',/,1x,"
    "'IS A LISTING OF THE SWITCHES WHOSE CLOSING TIMES ARE TO BE SYSTEMATICALL"
    "Y VARIED FOR THIS DATA CASE.   ALSO TABULATED',/,1x,"
    "'ARE THE ASSOCIATED ',a6,a1,"
    "'  CLOSING TIMES AND STEP-INCREMENT SIZES FOR THE',"
    "' SWITCHES, EXACTLY AS WAS READ FROM THE SWITCH CARDS.')"),
    text2, text3;
statement_1336:
  write(lunit6,
    "(/,10x,'ENTRY',4x,'SWITCH',6x,'FROM',8x,'TO',9x,'COLUMNS 15-24',8x,"
    "'COLUMNS 25-34',7x,'REFERENCE SWITCH NO.',/,5x,2(4x,'NUMBER'),2(7x,"
    "'BUS'),10x,'(IN SECONDS)',9x,'(IN SECONDS)',5x,"
    "'(0 IMPLIES INDEPENDENCE)')");
  n1 = 0;
  FEM_DO_SAFE(i, 1, kswtch) {
    if (std::abs(adelay(i)) != 44444.f) {
      goto statement_1352;
    }
    L = fem::iabs(kmswit(i));
    ndx1 = lswtch + i;
    m = fem::iabs(kmswit(ndx1));
    n1++;
    d1 = std::abs(topen(ndx1));
    write(lunit6, "(5x,2i10,2(4x,a6),2f21.6,6x,i10)"), n1, i, bus(L),
      bus(m), crit(i), d1, kdepsw(i);
  statement_1352:;
  }
  if (nenerg < 0) {
    goto statement_1373;
  }
  write(lunit6,
    "(' NOW IN ADDITION TO SWITCH-TIME VARIATION CAUSED BY EACH SWITCH''S OWN "
    "DISTRIBUTION, THERE IS THE ADDED RANDOM',/,"
    "' DELAY WHICH IS THE SAME FOR ALL SWITCHES, REFERED TO BY THE TERM ''REFE"
    "RENCE ANGLE''.   DISTRIBUTION FOR THIS',/,"
    "' ANGLE IS UNIFORM OVER THE TIME INTERVAL FROM',e14.5,' TO',e14.5,"
    "' DEGREES BASED ON',e13.3,' HZ',/,"
    "' FREQUENCY.   THIS WAS ALL SPECIFIED BY THE USER USING FIELDS  ''DEGMIN'"
    "' ,  ''DEGMAX'' ,  AND  ''STATFR''  (COLS. 41-64)',/,"
    "' OF THE SPECIAL STATISTICS MISC. DATA CARD.')"),
    cmn.degmin, cmn.degmax, cmn.statfr;
  write(lunit6,
    "(' HOWEVER, IF THE PARAMETER ''ITEST'' (FOUND IN COL. 9-16 OF THE STATIST"
    "ICS MISC. DATA CARD) IS GREATER THAN ZERO,',/,"
    "' THE REFERENCE ANGLE IS SET TO ZERO AND, CONSEQUENTLY, THERE IS NO ADDED"
    " RANDOM DELAY. ',/,1x)");
statement_1373:
  write(lunit6,
    "(' IN THE FOLLOWING PRINTOUT, SWITCH TIMES WHICH ARE USED FOR EACH ENERGI"
    "ZATION ARE TABULATED, FOLLOWED BY PEAK',/,"
    "' OUTPUT-VARIABLE VALUES WHICH OCCUR FOR THE ASSOCIATED SIMULATION.   FOR"
    "MAT FOR PEAK VALUES IS IDENTICAL TO THE',/,"
    "' PRINTOUT FOR MAXIMUM VARIABLE VALUES OF A',' CONVENTIONAL STUDY')");
  if (nenerg > 0) {
    write(lunit6,
      "(' EXCEPT THAT PRINTOUT OF THE',' REFERENCE ANGLE IN DEGREES',"
      "' HAS BEEN ADDED AT THE EXTREME LEFT.')");
  }
statement_3094:
  nc = nv;
  if (iprsup < 3) {
    goto statement_7436;
  }
  write(lunit6,
    "(/,' MIXTURE OF INTEGER ARRAYS IN OVER15.   ONLY THE LONGEST COLUMN(S) WI"
    "LL NOT HAVE GARBAGE AT THE ENDS.',/,12x,'ROW',5x,'BUS1 ',6x,'BUS2',4x,"
    "'KSWTYP',6x,'KPOS',6x,'NODE',4x,'ISOURC',6x,'KBUS',6x,'MBUS',5x,'NONLK',"
    "5x,'NONLM')");
  n2 = kswtch;
  if (kconst > n2) {
    n2 = kconst;
  }
  if (ibr > n2) {
    n2 = ibr;
  }
  if (inonl > n2) {
    n2 = inonl;
  }
  FEM_DO_SAFE(k, 1, n2) {
    ndx1 = lswtch + k;
    write(lunit6, "(5x,11i10)"), k, kmswit(k), kmswit(ndx1), kswtyp(k),
      kpos(k), node(k), isourc(k), kbus(k), mbus(k), nonlk(k), nonlm(
        k);
  }
statement_7436:
  iprint = 11;
  if (iprsup >= 2) {
    write(lunit6, "(/,' AT 8025 ',5i10)"), ibr, inonl, kswtch, nv, npower;
  }
  if (kswtch == 0) {
    goto statement_912;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6, format_8026);
      FEM_DO_SAFE(L, 1, npower) {
        wloop, koutvp(L);
      }
    }
  }
  ndx1 = maxpe + 1;
  ndx2 = maxpe + npower;
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6, format_8026);
      FEM_DO_SAFE(L, ndx1, ndx2) {
        wloop, koutvp(L);
      }
    }
  }
  FEM_DO_SAFE(k, 1, kswtch) {
    n3 = kpos(k);
    if (n3 >= 0) {
      goto statement_907;
    }
    nc++;
    lstat(19) = 907;
    if (nc > lsiz12) {
      goto statement_9000;
    }
    n2 = fem::iabs(kmswit(k));
    ibrnch(nc) = n2;
    ndx2 = lswtch + k;
    jbrnch(nc) = fem::iabs(kmswit(ndx2));
    if (iprsup >= 4) {
      write(lunit6, "(/,' AT 8028 ',4i10)"), k, nc, n3, n2;
    }
    FEM_DO_SAFE(i, 1, npower) {
      mpower = maxpe + i;
      if (koutvp(i) > 0) {
        goto statement_5438;
      }
      if (koutvp(mpower) == k) {
        goto statement_4385;
      }
    statement_5438:;
    }
    goto statement_907;
  statement_4385:
    koutvp(mpower) = -nc;
  statement_907:;
  }
statement_912:
  if (inonl == 0) {
    goto statement_8411;
  }
  FEM_DO_SAFE(k, 1, inonl) {
    icheck = nonlm(k);
    if (iprsup > 3) {
      write(lunit6, "(/,' AT 8029 ',3i10)"), k, icheck, nc;
    }
    if (icheck >= 0) {
      goto statement_909;
    }
    nc++;
    lstat(19) = 8029;
    if (nc > lsiz12) {
      goto statement_9000;
    }
    ibrnch(nc) = nonlk(k);
    jbrnch(nc) = -icheck;
    FEM_DO_SAFE(i, 1, npower) {
      mpower = maxpe + i;
      if (koutvp(i) < 0) {
        goto statement_5439;
      }
      if (koutvp(mpower) >= 0) {
        goto statement_5439;
      }
      if (koutvp(mpower) == -k) {
        goto statement_4398;
      }
    statement_5439:;
    }
    goto statement_909;
  statement_4398:
    koutvp(mpower) = -(1000 + nc);
  statement_909:;
  }
  //C     BRING "N15" OF "TOP15" OUT INTO "OVER15" USING "NFRFLD"           M28.4667
statement_8411:
  n15 = cmn.nfrfld;
  if (cmn.numum > 0) {
    //w 
    uminit(cmn, n15, spum(cmn.iureac), spum(cmn.iugpar), spum(cmn.iufpar),
      spum(cmn.iuhist), spum(cmn.iuumrp), ispum(cmn.iunod1), ispum(cmn.iunod2),
      ispum(cmn.iujclt), ispum(cmn.iujclo), ispum(cmn.iujtyp), ispum(cmn.iunodo),
      ispum(cmn.iujtmt), spum(cmn.iuhism), spum(cmn.iuomgm), spum(cmn.iuomld),
      spum(cmn.iutham), spum(cmn.iuredu), spum(cmn.iureds), spum(cmn.iuflds),
      spum(cmn.iufldr), spum(cmn.iurequ), spum(cmn.iuflqs), spum(cmn.iuflqr),
      ispum(cmn.iujcds), ispum(cmn.iujcqs), spum(cmn.iuflxd), spum(cmn.iuflxq),
      ispum(cmn.iunppa), spum(cmn.iurotm), ispum(cmn.iuncld), ispum(cmn.iunclq),
      ispum(cmn.iujtqo), ispum(cmn.iujomo), ispum(cmn.iujtho), spum(cmn.iureqs),
      spum(cmn.iuepso), spum(cmn.iudcoe), ispum(cmn.iukcoi), spum(cmn.iuvolt),
      spum(cmn.iuangl), ispum(cmn.iunodf), ispum(cmn.iunodm), ispum(iukumo),
      ispum(iujumo), spum(cmn.iuumou));
    ;
  }
  if (kill > 0) {
    goto statement_9200;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' DONE SETTING COMP. VECTORS.','  NUMSUB     N15   NCOMP',/,28x,"
      "3i8)"),
      numsub, n15, ncomp;
  }
  if (iprsup < 2) {
    goto statement_7321;
  }
  n11 = numsub + 1;
  {
    write_loop wloop(cmn, lunit6, "(' ISUBEG :',10i10)");
    FEM_DO_SAFE(k, 1, n11) {
      wloop, isubeg(k);
    }
  }
  n12 = isubeg(numsub) + 4;
  {
    write_loop wloop(cmn, lunit6, "(' NSUBKM :',10i10)");
    FEM_DO_SAFE(k, 1, n12) {
      wloop, kknonl(k);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(' KUPL :',10i10)");
    FEM_DO_SAFE(k, 1, inonl) {
      wloop, kupl(k);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(' VECNL2 :',10e12.4)");
    FEM_DO_SAFE(k, 1, inonl) {
      wloop, vecnl2(k);
    }
  }
statement_7321:
  n14 = cmn.lcomp * lbus;
  n13 = ncomp * ntot;
  if (n13 <= n14) {
    goto statement_7327;
  }
  kill = 1;
  iprint = 24;
  lstat(19) = 7321;
  goto statement_9000;
statement_7327:
  FEM_DO_SAFE(k, 1, ibr) {
    icheck = mbus(k);
    if (iprsup >= 3) {
      write(lunit6,
        "(' AT 8030 OF \"OVER15\", K, ICHECK, NC =',3i6)"), k,
        icheck, nc;
    }
    if (icheck >= 0) {
      goto statement_911;
    }
    nc++;
    lstat(19) = 8030;
    if (nc > lsiz12) {
      goto statement_9000;
    }
    ibrnch(nc) = fem::iabs(kbus(k));
    jbrnch(nc) = -icheck;
    FEM_DO_SAFE(i, 1, npower) {
      mpower = maxpe + i;
      if (koutvp(i) <= 0) {
        goto statement_5540;
      }
      if (koutvp(mpower) == k) {
        goto statement_5415;
      }
    statement_5540:;
    }
    goto statement_911;
  statement_5415:
    koutvp(mpower) = -nc;
  statement_911:;
  }
  FEM_DO_SAFE(i, 1, npower) {
    mpr = maxpe + i;
    if (koutvp(mpr) >= 0) {
      goto statement_5507;
    }
    n44 = fem::iabs(koutvp(mpr));
    if (n44 > 1000) {
      n44 = n44 - 1000;
    }
    koutvp(mpr) = n44;
  statement_5507:;
  }
  lstat(31) = nc;
  if (cmn.ktab > 0) {
    goto statement_4752;
  }
  ioutcs = 0;
  lstat(59) = ioutcs;
statement_4752:
  if (cmn.numsm > 0) {
    smout(cmn);
  }
  lstat(37) = cmn.nst;
  lstat(36) = cmn.mfirst;
  if (kill > 0) {
    goto statement_9200;
  }
  n5 = nc + nsmout + ioutcs + numout;
  n16 = 1;
  if (numbus > 0) {
    n16 = numbus;
  }
  n9 = ioutcs + 1;
  n23 = 0;
  namea6(cmn, text1, n23);
  ntacs = ntot + n23;
  n8 = ntot + maxbus;
  n18 = n8 + n16;
  if (iprsup >= 1) {
    write(lunit6, format_3207), nc, lsiz12, nsmout, ioutcs, ntot,
      numnvo, nv, n8, maxbus, n9, n18;
  }
  if (n5 <= lsiz12) {
    goto statement_3204;
  }
  kill = 179;
  lstat(19) = 3204;
  lstat(14) = n5;
  lstat(15) = nsmout;
  lstat(16) = ioutcs;
  lstat(13) = numout;
  lstat(12) = nc;
  goto statement_9200;
statement_3204:
  ncsave = nc;
  if (nenerg != 0 && kbase != intinf) {
    goto statement_3224;
  }
  i = 0;
  i3 = 0;
statement_3206:
  i++;
  if (i > nsmout) {
    goto statement_3209;
  }
  nc++;
  i3 += 3;
  ibrnch(nc) = ismout(i3 - 1) + ntot;
  jbrnch(nc) = ismout(i3) + ntot;
  goto statement_3206;
statement_3209:
  i = 0;
statement_3211:
  i++;
  if (i > ioutcs) {
    goto statement_3218;
  }
  nc++;
  ibrnch(nc) = ntacs;
  ik = ivarb(kjout + i);
  jbrnch(nc) = ntot + ivarb(klntab + ik);
  goto statement_3211;
statement_3218:
  if (numout <= 0) {
    goto statement_3224;
  }
  n17 = iukumo - 1;
  n19 = iujumo - 1;
  FEM_DO_SAFE(i, 1, numout) {
    nc++;
    ndx1 = n17 + i;
    ndx2 = n19 + i;
    ibrnch(nc) = ispum(ndx1) + n8;
    jbrnch(nc) = ispum(ndx2) + n8;
  }
statement_3224:
  numbco = nc - nv;
  lstat(31) = nc;
  k = numnvo + nc;
  n2 = lsiz26;
  if (cmn.iaverg == 0) {
    n2 += n2;
  }
  if (k <= n2) {
    goto statement_3098;
  }
  kill = 1;
  lstat(16) = 26;
  lstat(19) = 3098;
  goto statement_9200;
statement_3098:
  lstat(32) = k;
  if (begmax(1) <= 0.0f) {
    goto statement_1061;
  }
  if (k <= lsiz12) {
    goto statement_1063;
  }
  iprint = 12;
  lstat(19) = 1063;
  goto statement_9000;
  //C     NEXT INITIALIZE EXTREMA VECTOR  "XMAX" .   THERE ARE 4            M27.1321
  //C     PARTITIONS OF SIZE  LIST 12:  (XMAX TMAX XMIN TMIN) .             M27.1322
statement_1063:
  FEM_DO_SAFE(i, 1, k) {
    xmax(i) = -fltinf;
    ndx1 = lsiz12 + i;
    xmax(ndx1) = 0.0f;
    ndx1 += lsiz12;
    xmax(ndx1) = fltinf;
    ndx1 += lsiz12;
    xmax(ndx1) = 0.0f;
  }
statement_1061:
  runtym(d1, d2);
  limstp = kprchg(cmn.indstp);
  flstat(7) = flstat(7) - d1;
  flstat(8) = flstat(8) - d2;
  if (cmn.iout >= 0) {
    goto statement_300;
  }
  cmn.isprin = intinf;
  limstp = intinf;
statement_300:
  if (iplot < 0) {
    cmn.isplot = intinf;
  }
  lunit6save = lunit6;
  lunit6 = 79;
  cmn.io.open(79, fem::file_not_specified)
    .status("SCRATCH");
  if (nenerg != 0 && kbase != intinf) {
    goto statement_54242;
  }
  flstat(5) += d1;
  flstat(6) += d2;
  if (iplot < 0 && kbase == 0) {
    goto statement_7802;
  }
  if (iplot < 0) {
    goto statement_3106;
  }
  cmn.io.rewind(lunit4);
  {
    write_loop wloop(cmn, lunit4, fem::unformatted);
    wloop, date1, tclock, n18, numnvo, numbco, nc;
    FEM_DO_SAFE(i, 1, ntot) {
      wloop, bus(i);
    }
    FEM_DO_SAFE(i, 1, maxbus) {
      wloop, texvec(i);
    }
    FEM_DO_SAFE(i, 1, n16) {
      wloop, busum(i);
    }
  }
  if (iprsup >= 1) {
    write(6, format_3207), nc, lsiz12, nsmout, ioutcs, ntot, numnvo,
      nv, n8, maxbus, n9, n18;
  }
  if (ivolt != 1) {
    goto statement_3103;
  }
  {
    write_loop wloop(cmn, lunit4, fem::unformatted);
    FEM_DO_SAFE(i, 2, ntot) {
      wloop, i;
    }
  }
  goto statement_3104;
statement_3103:
  if (numnvo > 0) {
    {
      write_loop wloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(i, 1, numnvo) {
        wloop, ibsout(i);
      }

      cmn.out_stream << "Time";
      for (int i = 1; i <= numnvo; ++i) { // node voltage
        cmn.out_stream << ',' << bus(ibsout(i))(1,6).std_str();
      }
      if (nc == 0)
        cmn.out_stream << '\n';
    }
  }
statement_3104:
  if (nc > 0) {
    {
      write_loop wloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(i, 1, nc) {
        wloop, ibrnch(i);
      }
      FEM_DO_SAFE(i, 1, nc) {
        wloop, jbrnch(i);
      }
      if (numnvo == 0) cmn.out_stream << "Time";
      for (int i = 1; i <= nc; ++i) { // branch current
        cmn.out_stream << ',' << bus(ibrnch(i))(1,6).std_str() << "->" << bus(jbrnch(i))(1,6).std_str();
      }
      cmn.out_stream << '\n';
    }
  }
statement_3106:
  if (kbase != 1 && kbase != intinf) {
    goto statement_7802;
  }
  write(lunit9, fem::unformatted), date1, tclock, ivolt, maxbus,
    ndx1, ndx2, n16, nsmout, ioutcs, numout, n18, numnvo, numbco, nc,
    kswtch;
  {
    write_loop wloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(i, 1, ntot) {
      wloop, bus(i);
    }
    FEM_DO_SAFE(i, 1, maxbus) {
      wloop, texvec(i);
    }
    FEM_DO_SAFE(i, 1, n16) {
      wloop, busum(i);
    }
  }
  if (iprsup >= 1) {
    write(6, format_3207), nc, lsiz12, nsmout, ioutcs, ntot, numnvo,
      nv, n8, maxbus, n9, n18;
  }
  if (ivolt != 1) {
    goto statement_4103;
  }
  {
    write_loop wloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(i, 2, ntot) {
      wloop, i;
    }
  }
  goto statement_4104;
statement_4103:
  if (numnvo > 0) {
    {
      write_loop wloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(i, 1, numnvo) {
        wloop, ibsout(i);
      }
    }
  }
statement_4104:
  if (nc > 0) {
    {
      write_loop wloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(i, 1, nc) {
        wloop, ibrnch(i);
      }
      FEM_DO_SAFE(i, 1, nc) {
        wloop, jbrnch(i);
      }
    }
  }
statement_7802:
  if (ivolt == 1) {
    goto statement_3107;
  }
  if (numnvo > nc) {
    lstat(31) = numnvo;
  }
statement_3107:
  if (noutpr != 0) {
    goto statement_54242;
  }
  n4 = ncsave - nv;
  if (cmn.kol132 == 132) {
    goto statement_6637;
  }
  write(lunit6,
    "(' TIME-STEP LOOP BEGINS.  NUMBER OF NODE',"
    "' VOLTAGES, BRANCH VOLTAGES, CURRENTS, TACS',/,"
    "' VARIABLES, AND S.M. VARIABLES ARE :',5i6)"),
    numnvo, nv, n4, nsmout, ioutcs;
  goto statement_6645;
statement_6637:
  write(lunit6,
    "(/,' COLUMN HEADINGS FOR THE',i4,"
    "'  EMTP OUTPUT VARIABLES FOLLOW.   THESE ARE ORDERED ACCORDING TO THE FIV"
    "E',/,' POSSIBLE EMTP OUTPUT-VARIABLE CLASSES, AS FOLLOWS ....')"),
    k;
  write(lunit6,
    "(3x,'FIRST',i4,"
    "'  OUTPUT VARIABLES ARE ELECTRIC-NETWORK NODE VOLTAGES (WITH RESPECT TO L"
    "OCAL GROUND)|')"),
    numnvo;
  write(lunit6,
    "(3x,' NEXT',i4,"
    "'  OUTPUT VARIABLES ARE BRANCH VOLTAGES (VOLTAGE OF UPPER NODE MINUS VOLT"
    "AGE OF LOWER NODE)|')"),
    nv;
  write(lunit6,
    "(3x,' NEXT',i4,"
    "'  OUTPUT VARIABLES ARE BRANCH CURRENTS (FLOWING FROM THE UPPER EMTP NODE"
    " TO THE LOWER)|')"),
    n4;
  write(lunit6,
    "(3x,' NEXT',i4,"
    "'  OUTPUT VARIABLES PERTAIN TO DYNAMIC SYNCHRONOUS MACHINES, WITH NAMES G"
    "ENERATED INTERNALLY|')"),
    nsmout;
  write(lunit6,
    "(3x,'FINAL',i4,"
    "'  OUTPUT VARIABLES BELONG TO  ''TACS''  (NOTE INTERNALLY-ADDED UPPER NAM"
    "E OF PAIR).')"),
    ioutcs;
  write(lunit6,
    "(' BRANCH POWER  CONSUMPTION (POWER  FLOW, IF A SWITCH) IS TREATED LIKE A"
    " BRANCH VOLTAGE FOR THIS GROUPING|',/,"
    "' BRANCH ENERGY CONSUMPTION (ENERGY FLOW, IF A SWITCH) IS TREATED LIKE A "
    "BRANCH CURRENT FOR THIS GROUPING.')");
statement_6645:
  if (iprsup <= 0) {
    goto statement_54242;
  }
  if (npower <= 0) {
    goto statement_54242;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' ''IBRNCH''  AND  ''JBRNCH''  PAIRS OF BRANCH-OUTPUT NODE NUMERS, I"
      "N  OVER15',/(1x,20i6))");
    FEM_DO_SAFE(i, 1, nc) {
      wloop, ibrnch(i), jbrnch(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3113);
    FEM_DO_SAFE(i, 1, npower) {
      wloop, koutvp(i);
    }
  }
  ndx1 = maxpe + 1;
  ndx2 = maxpe + npower;
  {
    write_loop wloop(cmn, lunit6, format_3113);
    FEM_DO_SAFE(L, ndx1, ndx2) {
      wloop, koutvp(L);
    }
  }
statement_54242:
  k = 0;
  n1 = 0;
  if (nenerg != 0) {
    n1 = 1;
  }
  kprsta = 1;
  if (nenerg > 0) {
    kprsta = 0;
  }
  goto statement_3152;
statement_3119:
  k++;
  j = k + 1;
  if (ivolt != 1) {
    j = ibsout(k);
  }
  m++;
  aupper(m) = bus(j);
  alower(m) = blank;
  if (m < 9) {
    goto statement_3158;
  }
  moon = 1; // FEM_THROW_UNHANDLED("executable assign: assign3152tomoon");
statement_3126:
  if (noutpr != 0) {
    goto statement_7113;
  }
  if (n1 == 1) {
    {
      write_loop wloop(cmn, lunit6, "(/,15x,9(7x,a6))");
      FEM_DO_SAFE(i, 1, 9) {
        wloop, aupper(i);
      }
    }
  }
  if (n1 == 0) {
    {
      write_loop wloop(cmn, lunit6, "(/,'  STEP     TIME',9(7x,a6))");
      FEM_DO_SAFE(i, 1, 9) {
        wloop, aupper(i);
      }
    }
  }
  if (n1 > 0) {
    goto statement_3144;
  }
  n1 = 1;
statement_3144:
  if (kprsta == 1) {
    {
      write_loop wloop(cmn, lunit6, "(15x,9(7x,a6))");
      FEM_DO_SAFE(i, 1, 9) {
        wloop, alower(i);
      }
    }
  }
  if (kprsta == 0) {
    {
      write_loop wloop(cmn, lunit6, "('  REF. ANGLE   ',9(7x,a6))");
      FEM_DO_SAFE(i, 1, 9) {
        wloop, alower(i);
      }
    }
  }
  kprsta = 1;
statement_7113:
  switch (moon) {
  case 1: goto statement_3152;
  case 2: goto statement_3166;
  case 3: goto statement_3188;
  case 4: goto statement_3197;
  case 5: goto statement_3177;
  case 6: goto statement_8637;
  default: break;
  }
statement_3152:
  m = 0;
statement_3158:
  if (k < numnvo) {
    goto statement_3119;
  }
  k = 0;
  goto statement_3169;
statement_3164:
  k++;
  L = ibrnch(k);
  j = jbrnch(k);
  m++;
  aupper(m) = bus(L);
  if (L == 1) {
    aupper(m) = terra;
  }
  alower(m) = bus(j);
  if (j == 1) {
    alower(m) = terra;
  }
  if (m < 9) {
    goto statement_3169;
  }
  moon = 2; // FEM_THROW_UNHANDLED("executable assign: assign3166tomoon");
  goto statement_3126;
statement_3166:
  m = 0;
statement_3169:
  if (k < ncsave) {
    goto statement_3164;
  }
  k = 0;
  if (nenerg != 0) {
    goto statement_3198;
  }
  goto statement_3191;
statement_3182:
  k++;
  L = ismout(3 * k - 1);
  j = ismout(3 * k);
  m++;
  aupper(m) = texvec(L);
  alower(m) = texvec(j);
  if (m < 9) {
    goto statement_3191;
  }
  moon = 3; // FEM_THROW_UNHANDLED("executable assign: assign3188tomoon");
  goto statement_3126;
statement_3188:
  m = 0;
statement_3191:
  if (k < nsmout) {
    goto statement_3182;
  }
  k = 0;
  goto statement_3199;
statement_3195:
  k++;
  m++;
  aupper(m) = text1;
  ndx1 = ivarb(kjout + k);
  ndx1 = ivarb(klntab + ndx1);
  alower(m) = texvec(ndx1);
  if (m < 9) {
    goto statement_3199;
  }
  moon = 4; // FEM_THROW_UNHANDLED("executable assign: assign3197tomoon");
  goto statement_3126;
statement_3197:
  m = 0;
statement_3199:
  if (k < ioutcs) {
    goto statement_3195;
  }
  k = 0;
  goto statement_8641;
statement_8634:
  k++;
  ndx1 = n17 + k;
  ndx2 = n19 + k;
  L = ispum(ndx1);
  j = ispum(ndx2);
  m++;
  aupper(m) = busum(L);
  alower(m) = busum(j);
  if (m < 9) {
    goto statement_8641;
  }
  moon = 6; // FEM_THROW_UNHANDLED("executable assign: assign8637tomoon");
  goto statement_3126;
statement_8637:
  m = 0;
statement_8641:
  if (k < numout) {
    goto statement_8634;
  }
statement_3198:
  if (m == 0) {
    goto statement_3177;
  }
statement_3171:
  m++;
  aupper(m) = blank;
  alower(m) = blank;
  if (m < 9) {
    goto statement_3171;
  }
  moon = 5; // FEM_THROW_UNHANDLED("executable assign: assign3177tomoon");
  goto statement_3126;
statement_3177:
  kcount = nv;
  lunit6 = lunit6save;
  cmn.io.rewind(79);
  FEM_DO_SAFE(ip, 1, 99999) {
    try {
      read(79, format_8927), outlin;
    }
    catch (fem::read_end const&) {
      goto statement_8644;
    }
    write(lunit6, format_8927), outlin;
  }
statement_8644:
  if (kswtch <= 0) {
    goto statement_8719;
  }
  n11 = 0;
  FEM_DO_SAFE(i, 1, kswtch) {
    ndx4 = lswtch + i;
    k = kmswit(i);
    m = kmswit(ndx4);
    d6 = tclose(i);
    if (ktrlsw(1) == 8877) {
      goto statement_8688;
    }
    d6 = 0.0f;
    if (tclose(i) > 0.0f) {
      goto statement_8710;
    }
    if (tclose(i) == 0.0f) {
      goto statement_8695;
    }
    tclose(i) = 0.0f;
    goto statement_8689;
  statement_8688:
    if (nextsw(i) != 87) {
      goto statement_8695;
    }
  statement_8689:
    d11 = 0.0f;
    if (kbase == 2) {
      goto statement_8702;
    }
    write(lunit6,
      "(' ***          PHASOR I(0) =',e15.7,33x,'SWITCH \"',a6,'\" TO \"',a6,"
      "'\" CLOSED AFTER',e12.5,' SEC.')"),
      tclose(i), bus(k), bus(m), d11;
    goto statement_8702;
  statement_8693:
    d6 = 0.0f;
    goto statement_8710;
  statement_8695:
    if (tclose(i) > 0.0f) {
      goto statement_8693;
    }
    if (fem::iabs(kpos(i)) != 10) {
      goto statement_8284;
    }
    if (std::abs(e(k) - e(m)) < topen(i)) {
      goto statement_8710;
    }
  statement_8284:
    if (kbase == 2) {
      goto statement_8702;
    }
    write(lunit6,
      "(' ***                       ',15x,33x,'SWITCH \"',a6,'\" TO \"',a6,"
      "'\" CLOSED AFTER',e12.5,' SEC.')"),
      bus(k), bus(m), tclose(i);
  statement_8702:
    n8 = kpos(i);
    kpos(i) = 2;
    if (n8 < 0) {
      kpos(i) = -2;
    }
    n11++;
    modswt(n11) = i;
  statement_8710:
    if (kpos(i) >= 0) {
      goto statement_8713;
    }
    kcount++;
    bvalue(kcount) = d6;
    if (iprsup >= 1) {
      write(lunit6, "(' KCOUNT, BVALUE(KCOUNT) =',i8,e15.6)"),
        kcount, bvalue(kcount);
    }
  statement_8713:;
  }
  ktrlsw(1) = n11;
statement_8719:
  nc = ncsave;
  if (kbase != 2 && kbase != intinf) {
    goto statement_710;
  }
  if (isw == 0) {
    goto statement_710;
  }
  n6 = 0;
  FEM_DO_SAFE(k1, 1, kswtch) {
    if (fem::iabs(kpos(k1)) == 2) {
      goto statement_4208;
    }
    if (adelay(k1) != 44444.f) {
      goto statement_4216;
    }
    volti(n6 + 1) = tclose(k1);
    goto statement_4213;
  statement_4208:
    if (adelay(k1) != -44444.f) {
      goto statement_4216;
    }
    volti(n6 + 1) = topen(k1);
  statement_4213:
    n6++;
    if (n6 < 2 * lsiz26) {
      goto statement_4215;
    }
    lstat(19) = 4213;
    iprint = 26;
    goto statement_9200;
  statement_4215:
    nextsw(n6) = k1;
  statement_4216:;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,32x,'RANDOM SWITCHING TIMES FOR ENERGIZATION NUMBER',i4,/(32x,5(i4,"
      "e16.6)))");
    wloop, knt;
    FEM_DO_SAFE(k1, 1, n6) {
      wloop, nextsw(k1), volti(k1);
    }
  }
statement_710:
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' BEGIN DEL-T LOOP AT 1077.  KPRCHG, MULTPR=',/(1x,12i10))"),
      kprchg, multpr;
  }
  move0(nextsw, kswtch);
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' SOURCE TABLE.',/,5x,'ROW',3x,'IFORM',4x,'NODE',10x,'CREST',10x,"
        "'TIME1',10x,'TIME2',9x,'TSTART',10x,'SFREQ',/(3i8,5e15.6))");
      FEM_DO_SAFE(i, 1, kconst) {
        wloop, i, iform(i), node(i), crest(i), time1(i), time2(i),
          tstart(i), sfreq(i);
      }
    }
  }
  if (iprsup > 0) {
    write(lunit6,
      "(/,' N.L. ELEM TABLE UPON ENTERING TIME-STEP LOOP',/,5x,'ROW',2x,"
      "'NLTYPE',3x,'NONLK',3x,'NONLM',2x,'NONLAD',2x,'NONLE ',9x,'VECNL1',3x,"
      "'ANONL',4x,'CURR',8x,'VNONL')");
  }
  i = 1;
statement_73900:
  if (i > inonl) {
    goto statement_73902;
  }
  if (iprsup > 0) {
    write(lunit6, "(6i8,e15.5,2f8.0,e12.3)"), i, nltype(i), nonlk(i),
      nonlm(i), nonlad(i), nonle(i), vecnl1(i), anonl(i), curr(i),
      vnonl(i);
  }
  i++;
  goto statement_73900;
statement_73902:
  i = 1;
statement_73903:
  if (i > cmn.ichar) {
    goto statement_1000;
  }
  if (iprsup > 1) {
    write(lunit6, "(' N.L. CHAR AT 73904 OF MAIN14.',i10,3e15.5)"),
      i, gslope(i), cchar(i), vchar(i);
  }
  i++;
  goto statement_73903;
statement_1000:
  if (nenerg != 0) {
    goto statement_1009;
  }
  n1 = 2 * modout;
  if (modout == 0) {
    goto statement_9999;
  }
  if (noutpr == 0) {
    write(lunit6,
      "(/,10x,'REMEMBER ---- WHAT ARE LABELED AS THE INITIAL',i3,"
      "'  BRANCH-OUTPUT CURRENTS ARE IN REALITY',/,24x,"
      "'MODAL VOLTAGES AT THE TWO ENDS OF THE LAST DISTRIBUTED-PARAMETER LINE "
      "OF THE DATA CASE BEING SOLVED.',/,24x,'THE FIRST',i3,"
      "'  MODE VOLTAGES AT THE  ''BUS1''  END ALL COME FIRST, FOLLOWED BY ALL "
      "THE CORRESPONDING',/,24x,'ENTRIES FOR THE  ''BUS2''  END OF THE LINE.',"
      "/,1x)"),
      n1, modout;
  }
  goto statement_9999;
statement_1009:
  if (kbase == intinf) {
    kbase = 2;
  }
  if (kbase == 2) {
    moncar(2) = kbase;
  }
  if (kbase == 2 && cmn.tenerg < 0.0f) {
    tables(cmn);
  }
  ltdelt = 0;
  moncar(3) = ltdelt;
  goto statement_9999;
statement_9000:
  lstat(16) = iprint;
  kill = 1;
statement_9200:
  lastov = nchain;
  nchain = 51;
  lstat(18) = 15;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
statement_9999:
  lastov = nchain;
  nchain++;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
statement_99999:;
} // over15









struct analyt_save
{
  int n16;

  analyt_save() :
    n16(fem::int0)
  {}
};


void analyt(
  common& cmn)
{
  FEM_CMN_SVE(analyt);
  common_read read(cmn);
  common_write write(cmn);
  double& deltat = cmn.deltat;
  double& t = cmn.t;
  auto& voltbc = cmn.voltbc;
  auto& lstat = cmn.lstat;
  int& kanal = cmn.kanal;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  auto& nr = cmn.nr;
  const auto& rampcn = cmn.rampcn;
  const auto& rampsl = cmn.rampsl;
  const auto& kyramp = cmn.kyramp;
  const auto& fendrp = cmn.fendrp;
  double& tminrp = cmn.tminrp;
  double& tmaxrp = cmn.tmaxrp;
  const auto& tbegrp = cmn.tbegrp;
  const auto& tendrp = cmn.tendrp;
  const auto& indxrp = cmn.indxrp;
  int& iprspy = cmn.iprspy;
  const auto& n10rmp = cmn.n10rmp;
  const auto& memrmp = cmn.memrmp;
  int& numrmp = cmn.numrmp;
  fem::str<80>& buff77 = cmn.buff77;
  fem::str<132>& munit6 = cmn.munit6;
  //
  int& n16 = sve.n16;
  if (is_called_first_time) {
    n16 = 0;
  }
  auto& lunit6 = cmn.lunit6;
  int j = fem::int0;
  int n17 = fem::int0;
  double d6 = fem::double0;
  int n4 = fem::int0;
  arr_1d<1, double> fkar1(fem::fill0);
  arr_1d<1, double> fkar2(fem::fill0);
  double d1 = fem::double0;
  //C)    THIS MODULE IS CALLED BY SUBROUTINE  'SUBTS3'  OF OVERLAY 16 IF   M30. 956
  //C)    DATA CASE BEING SOLVED USES ONE OR MORE SOURCES OF TYPE 1 THROUGH M15.1321
  //C)    10, AND ALSO HAS A SPECIAL   'ANALYTIC SOURCES'   REQUEST CARD    M15.1322
  //C)    WHICH PRECEDES THE MISCELLANEOUS DATA CARDS.   IF THIS BE THE     M15.1323
  //C)    CASE, THE USER MUST REPLACE THIS DUMMY MODULE WITH ONE WHICH PUTS M15.1324
  //C)    ONE OR MORE SOURCE VALUES IN VECTOR  'VOLTBC'  AT EACH TIME STEP. M31.3589
  //C     RELEVANT VARIABLES TO USE IN THIS DEFINITION PROCESS ARE .....    M12. 538
  //C          T     ----- TIME IN SECONDS FOR WHICH SOURCE VALUES MUST BE  M12. 539
  //C                      ASSIGNED.                                        M12. 540
  //C          ISTEP ----- THE TIME-STEP NUMBER.                            M12. 541
  //C          DELTAT ---- THE TIME-STEP SIZE.   A CONSTRAINT AMONG THESE   M12. 542
  //C                      THREE VARIABLES IS    T = ISTEP*DELTAT  .        M12. 543
  //C          VOLTBC  --- VECTOR OF SOURCE VALUES.   FOR THE SOURCE HAVING M31.3590
  //C                      TYPE-CODE  'L' ,   VOLTBC(L)  MUST BE ASSIGNED   M31.3591
  //C                      TO EQUAL THE DESIRED SOURCE VALUE AT TIME  'T' . M12. 546
  //C     SINCE THE PRESENT DUMMY MODULE HAD BETTER NEVER BE CALLED, THE    M12. 547
  //C     FOLLOWING STATEMENTS WILL KILL THE RUN WITH AN APPROPRIATE ERROR  M12. 548
  //C     MESSAGE.   THE ONE EXCEPTION IS FOR UTPF TEST CASE NUMBER 14,     M14.2604
  //C     WHICH HAS   NTOT = 5  ,   IBR = 5  ,    AND   DELTAT = 0.1   .    M14.2605
  //C       PRECEDING COMMENTS APPLIED BEFORE THE SPRING OF 1981,           M30. 957
  //C       WHEN INTERACTIVE CONTROL WAS DEVISED.  RAMPING OF COMMON        M35.5878
  //C       VARIABLES IS DONE HERE (REMOTE CONTROL FROM "EMTSPY").          M35.5879
  //C     INTRINSIC  ABSZ                                                   M32.6463
statement_1637:
  if (iprsup >= 1) {
    write(lunit6,
      "(' TOP OF \"ANALYT\".  NUMRMP, NTOT, TMINRP, TMAXRP =',2i8,2e15.6)"),
      numrmp, ntot, tminrp, tmaxrp;
  }
  if (numrmp <= 0) {
    goto statement_1847;
  }
  if (t < tminrp) {
    goto statement_1830;
  }
  if (t > tmaxrp + deltat) {
    goto statement_1830;
  }
  FEM_DO_SAFE(j, 1, numrmp) {
    if (t < tbegrp(j)) {
      goto statement_1762;
    }
    if (t > tendrp(j) + deltat) {
      goto statement_1762;
    }
    if (kyramp(j) != 1) {
      goto statement_1656;
    }
    cmn.kserlc = 1;
    n17 = indxrp(j);
    nr(n17) = 1;
    if (iprsup < 2) {
      goto statement_1675;
    }
    write(munit6, "(' \"ANALYT\", R-L-C RAMP.  J, N17 =',2i5)"), j, n17;
    window(cmn);
  statement_1675:
    d6 = rampcn(j) + rampsl(j) * t;
    if (t < tendrp(j) - deltat) {
      goto statement_1758;
    }
    d6 = fendrp(j);
    goto statement_1758;
  statement_1656:
    d6 = rampcn(j) + rampsl(j) * t;
    if (t > tendrp(j)) {
      d6 = fendrp(j);
    }
  statement_1758:
    n4 = memrmp(j);
    if (n10rmp(j) != 0) {
      goto statement_1748;
    }
    fkar1(n4) = d6;
    goto statement_1762;
  statement_1748:
    fkar2(n4) = d6;
    if (iprspy >= 1) {
      write(lunit6,
        "(' DONE NEXT RAMP IN \"ANALYT\".  J, N4, T, D6 =',2i8,2e15.6)"),
        j, n4, t, d6;
    }
  statement_1762:;
  }
statement_1830:
  if (iprspy >= 1) {
    write(lunit6,
      "(' EXIT \"ANALYT\".  T, TMINRP, TMAXRP =',3e15.6)"), t,
      tminrp, tmaxrp;
  }
  goto statement_9000;
statement_1847:
  if (kanal != 2) {
    goto statement_1942;
  }
  if (n16 == 5678) {
    goto statement_9000;
  }
  write(munit6,
    "('   ###  WARNING.   [Y] IS BEING RE-FORMED',"
    "' EACH DELTAT, BUT THERE IS NO RAMPING.')");
  window(cmn);
  write(cmn.prom80,
    "('                   IS IT OK TO CONTINUE',"
    "' (ONE AND ONLY CHANCE IF \"Y\")? :')");
  prompt(cmn);
  read(cmn.munit5, "(a1)"), buff77(1, 1);
  if (buff77(1, 1) != "Y") {
    goto statement_1868;
  }
  n16 = 5678;
  goto statement_9000;
statement_1868:
  cmn.lockbr = 1;
  spying(cmn);
  goto statement_1637;
statement_1942:
  if (kanal == 0) {
    goto statement_9000;
  }
  if (ntot != 5) {
    goto statement_8613;
  }
  if (ibr != 5) {
    goto statement_8613;
  }
  d1 = (deltat - 1.0f / 10.f) * 100.f;
  if (std::abs(d1) > cmn.tenm3) {
    goto statement_8613;
  }
  if (voltbc(2) != 0.0f) {
    goto statement_2416;
  }
  d1 = t - 0.25f;
  voltbc(2) = 100.f - 100.f * d1;
  if (t > 0.75f) {
    voltbc(2) = 0.0f;
  }
statement_2416:
  return;
statement_8613:
  kill = 101;
  lstat(19) = 8613;
statement_9000:
  if (iprsup >= 1) {
    write(lunit6,
      "(' EXIT \"ANALYT\".  NTOT, IBR, NUMRMP, KILL =',4i8)"), ntot,
      ibr, numrmp, kill;
  }
}

void arrest(
  common& cmn,
  arr_cref<double> a,
  arr_ref<double> b,
  double const& srt,
  double& svt,
  double& carst)
{
  a(dimension(1));
  b(dimension(1));
  common_write write(cmn);
  double& deltat = cmn.deltat;
  double& delta2 = cmn.delta2;
  double& epsiln = cmn.epsiln;
  int& iprsup = cmn.iprsup;
  //
  int ll8 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  int isign = fem::int0;
  double ylb = fem::double0;
  double cb = fem::double0;
  double rb = fem::double0;
  double be = fem::double0;
  double d1 = fem::double0;
  double f0 = fem::double0;
  double dfdv = fem::double0;
  double dfdi = fem::double0;
  double f1 = fem::double0;
  double f2 = fem::double0;
  double wx = fem::double0;
  double gi = fem::double0;
  double yg = fem::double0;
  double cg = fem::double0;
  double art = fem::double0;
  double vblock = fem::double0;
  double vgap = fem::double0;
  double avt = fem::double0;
  double curr = fem::double0;
  double cip = fem::double0;
  //C   NUMBER   VARIABLE                DESCRIPTION                        M14.2450
  //C    A(1)       K        VALVE BLOCK RESISTANCE CONSTANT                M14.2451
  //C    A(2)       B        VALVE BLOCK CURRENT EXPONENT                   M14.2452
  //C    A(3)       L        VALVE VLOCK INDUCTANCE                         M14.2453
  //C    A(4)                                                               M14.2454
  //C                                                                       M14.2455
  //C    A(5)       KC       GAP CAPACITANCE CONSTANT           T0-T1       M14.2456
  //C    A(6)       IC       GAP CURRENT LIMIT FOR CAPACITANCE  T0-T1       M14.2457
  //C    A(7)       E1       GAP TRANSITION VOLTAGE  (1 TO 2)   T0-T1       M14.2458
  //C    A(8)       KR       GAP                                T1-T4       M14.2459
  //C    A(9)       K0       GAP                                T1-T4       M14.2460
  //C    A(10)      K1       GAP                                T1-T4       M14.2461
  //C    A(11)      K2       GAP                                T1-T3       M14.2462
  //C    A(12)      W2       GAP TRANSITION ENERGY  (2 TO 3)    T1-T2       M14.2463
  //C    A(13)      KD       GAP                                T2-T3       M14.2464
  //C    A(14)      W0       GAP                                T2-T3       M14.2465
  //C    A(15)      W1       GAP                                T2-T3       M14.2466
  //C    A(16)      K0P      GAP                                T3-T4       M14.2467
  //C    A(17)      K3       GAP                                T3-T4       M14.2468
  //C    A(18)      I3       GAP TRANSITION CURRENT  (3 TO 4)   T0-T4       M14.2469
  //C                                                                       M14.2470
  //C    B(1)       VA       ARRESTER VOLTAGE                               M14.2471
  //C    B(2)       VG       GAP VOLTAGE                                    M14.2472
  //C    B(3)       IA       ARRESTER CURRENT                               M14.2473
  //C    B(4)       IA       ARRESTER CURRENT (T-DT)                        M14.2474
  //C    B(5)       WGAP     ENERGY IN GAP FROM T1                          M14.2475
  //C    B(6)       XK       REGION CODE                                    M14.2476
  //C    B(7)       M        1/C INTEGRAL OF REGION 1                       M14.2477
  //C    B(8)       VB       BLOCK VOLTAGE                                  M14.2478
  //C    B(9)       WT       ACCUMULATED ENERGY SINCE FLASHOVER             M14.2479
  //C    B(10)      FV       VOLTAGE DIVISION FACTOR                        M14.2480
  //C    B(11)      FI       CURRENT DIVISION FACTOR                        M14.2481
  ll8 = 8;
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6, "((1x,8e16.6))");
      FEM_DO_SAFE(i, 1, 20) {
        wloop, a(i), b(i);
      }
    }
  }
  if (b(6) > 0) {
    goto statement_100;
  }
  move0(b, 2, ll8);
  b(6) = 1.0f;
statement_100:
  //C  TEST POLARITY OF ARRESTER VOLTAGE                                    M14.2488
  isign = 1;
  b(1) = b(1) / b(10);
  b(3) = b(3) / b(11);
  if (b(1) > 0.0f) {
    goto statement_1;
  }
  b(1) = -b(1);
  if (b(3) < 0.0f) {
    b(3) = -b(3);
  }
  isign = -1;
statement_1:
  //C  CONSTRUCT VALVE BLOCK BRANCHES                                       M14.2498
  ylb = delta2 / a(3);
  cb = b(3) + ylb * b(8);
  rb = 0.0f;
  if (b(3) > epsiln) {
    rb = a(2) * a(1) * fem::pow(b(3), (a(2) - 1.0f));
  }
  be = (1.0f - a(2)) * a(1) * fem::pow(b(3), a(2));
  //C  TEST GAP REGION TRANSITION                                           M14.2504
  d1 = b(6);
  if (d1 >= 3.5f) {
    goto statement_50;
  }
  if (b(3) - b(4) >= 0.0f) {
    goto statement_44;
  }
  if (b(3) > a(18)) {
    goto statement_44;
  }
  d1 = 4.0f;
  goto statement_50;
statement_44:
  if (d1 > 1.5f) {
    goto statement_45;
  }
  if (b(2) < a(7)) {
    goto statement_50;
  }
  d1 = 2.0f;
  goto statement_46;
statement_45:
  if (d1 > 2.5f) {
    goto statement_50;
  }
statement_46:
  if (b(5) < a(12)) {
    goto statement_50;
  }
  d1 = 3.0f;
statement_50:
  b(6) = d1;
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' IN  ''ARREST'' .   ISIGN',13x,'D1',10x,'ANONL',9x,'VZERO2',11x,"
        "'CURR',/,15x,i8,4e15.6,/(1x,8e16.6))");
      wloop, isign, d1, srt, svt, carst;
      FEM_DO_SAFE(i, 1, 20) {
        wloop, a(i), b(i);
      }
    }
  }
  //C  SELECT REGION                                                        M14.2525
  if (d1 < 1.5f) {
    goto statement_200;
  }
  if (d1 < 2.5f) {
    goto statement_220;
  }
  if (d1 < 3.5f) {
    goto statement_240;
  }
  goto statement_260;
  //C  REGION (1) --- T0 TO T1                                              M14.2530
statement_200:
  f0 = b(7) * b(3);
  dfdv = 0.0f;
  dfdi = b(7);
  goto statement_99;
  //C  REGION (2) BRANCHES --- T1 TO T2                                     M14.2536
statement_220:
  f1 = a(8) * (a(9) - b(2));
  f2 = a(10) + a(11) * b(3);
  f0 = f1 / f2;
  dfdv = -a(8) / f2;
  dfdi = -a(11) * f1 / fem::pow2(f2);
  goto statement_99;
  //C  REGION (3) BRANCHES --- T2 TO T3                                     M14.2544
statement_240:
  wx = a(14) + a(15) * b(5);
  f1 = a(8) * (a(9) - b(2));
  f2 = a(10) + a(11) * b(3);
  f0 = f1 / f2 + wx * (a(13) - b(2));
  dfdv = -a(8) / f2 - wx;
  dfdi = a(11) * f1 / fem::pow2(f2);
  goto statement_99;
  //C  REGION (4) BRANCHES --- T3 TO T4                                     M14.2553
statement_260:
  f1 = a(8) * (a(16) - b(2));
  f2 = a(10) + a(17) * fem::pow2(b(3));
  f0 = f1 / f2;
  dfdv = -a(8) / f2;
  dfdi = -2.0f * a(17) * f1 * b(3) / fem::pow2(f2);
  goto statement_99;
statement_99:
  if (dfdi == 0) {
    dfdi = epsiln;
  }
  gi = b(3) + (dfdv * b(2) - f0) / dfdi;
  yg = (-dfdv + 2.0f / deltat) / dfdi;
  cg = b(2) * (-dfdv - 2.0f / deltat) / dfdi - b(3) + gi;
  art = 1.0f / ylb + rb + 1.0f / yg;
  vblock = -cb / ylb;
  vgap = -(cg + gi) / yg;
  avt = vblock + be + vgap;
  if (isign < 0) {
    svt = -svt;
  }
  //C  CORRECT ARRESTER INTERNAL NODE VOLTAGES                              M14.2571
  carst = (svt - avt * b(10)) / (art * b(10) / b(11) - srt);
  curr = carst / b(11);
  if (carst <= 0.0f) {
    goto statement_93;
  }
  vgap += curr / yg;
  if (b(6) > 1.5f) {
    goto statement_91;
  }
  cip = (curr + b(3)) * cmn.onehaf;
  if (curr > a(6)) {
    cip = a(6);
  }
  b(7) += a(5) * cip * deltat;
  goto statement_92;
statement_91:
  if (b(6) > 3.5f) {
    goto statement_92;
  }
  b(5) += (vgap * curr + b(2) * b(3)) * delta2;
statement_92:
  b(4) = b(3);
  b(3) = carst;
  b(2) = vgap;
  b(1) = b(10) * (avt + art * curr);
  b(8) = vblock + curr / ylb;
  if (isign > 0) {
    goto statement_94;
  }
  b(3) = -b(3);
  b(1) = -b(1);
  carst = -carst;
statement_94:
  b(9) += b(1) * b(3) * deltat;
  goto statement_5681;
statement_93:
  b(6) = 0.0f;
  b(3) = 0.0f;
  b(1) = 0.0f;
  carst = 0.0f;
statement_5681:
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' AT END  ''ARREST'' .',12x,'ART',12x,'AVT',10x,'CARST',/,19x,"
        "3e15.6,/(1x,8e16.6))");
      wloop, art, avt, carst;
      FEM_DO_SAFE(i, 1, 20) {
        wloop, a(i), b(i);
      }
    }
  }
}


void subts3(
  common& cmn)
{
  common_read read(cmn);
  common_write write(cmn);
  const auto& vstacs= cmn.vstacs;
  const auto& abuff = cmn.abuff;
  double& ck1 = cmn.ck1;
  double& deltat = cmn.deltat;
  double& delta2 = cmn.delta2;
  double& t = cmn.t;
  const auto& begmax = cmn.begmax;
  auto& peaknd = cmn.peaknd;
  auto& voltbc = cmn.voltbc;
  auto& flstat = cmn.flstat;
  const auto& moncar = cmn.moncar;
  const auto& kprchg = cmn.kprchg;
  const auto& multpr = cmn.multpr;
  auto& lstat = cmn.lstat;
  auto& iprsov= cmn.iprsov;
  int& inonl = cmn.inonl;
  int& iout = cmn.iout;
  int& iread = cmn.iread;
  int& istep = cmn.istep;
  int& nv = cmn.nv;
  int& npower = cmn.npower;
  int& maxpe = cmn.maxpe;
  int& lsiz12 = cmn.lsiz12;
  int& kpartb = cmn.kpartb;
  int& nstacs = cmn.nstacs;
  int& lastov = cmn.lastov;
  int& lsiz26 = cmn.lsiz26;
  int& numout = cmn.numout;
  int& isplot = cmn.isplot;
  int& isprin = cmn.isprin;
  int& maxout = cmn.maxout;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& ntot = cmn.ntot;
  int& limstp = cmn.limstp;
  int& indstp = cmn.indstp;
  int& nc = cmn.nc;
  const auto& ykm = cmn.ykm;
  const auto& km = cmn.km;
  auto& xmax = cmn.xmax;
  auto& bnrg = cmn.bnrg;
  const auto& koutvp = cmn.koutvp;
  const auto& ibsout = cmn.ibsout;
  auto& bvalue = cmn.bvalue;
  auto& sptacs = cmn.sptacs;
  const auto& nonlad = cmn.nonlad;
  const auto& nonle = cmn.nonle;
  const auto& vnonl = cmn.vnonl;
  auto& curr = cmn.curr;
  const auto& anonl = cmn.anonl;
  auto& vzer5 = cmn.vzer5;
  auto& ilast = cmn.ilast;
  const auto& nltype = cmn.nltype;
  const auto& nlsub = cmn.nlsub;
  auto& cursub = cmn.cursub;
  const auto& cchar = cmn.cchar;
  auto& vchar = cmn.vchar;
  const auto& kk = cmn.kk;
  const auto& spum = cmn.spum;
  const auto& ismout = cmn.ismout;
  const auto& ibrnch = cmn.ibrnch;
  const auto& jbrnch = cmn.jbrnch;
  auto& tstop = cmn.tstop;
  const auto& nonlk = cmn.nonlk;
  const auto& nonlm = cmn.nonlm;
  const auto& kknonl = cmn.kknonl;
  const auto& isubeg = cmn.isubeg;
  auto& iform = cmn.iform;
  const auto& node = cmn.node;
  auto& crest = cmn.crest;
  const auto& time1 = cmn.time1;
  const auto& time2 = cmn.time2;
  auto& tstart = cmn.tstart;
  auto& sfreq = cmn.sfreq;
  auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  const auto& kode = cmn.kode;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;
  auto& nsmout = cmn.nsmout;

  const auto& bus = cmn.bus;
  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;

  auto& koncur = isptacs(2);
  auto& kjout =  isptacs(12); 
  auto& kiuty =  isptacs(13); 
  auto& kxtcs =  isptacs(17);
  //
  //int koncur = fem::int0;
  //int kjout = fem::int0;
  //int kiuty = fem::int0;
  //int kxtcs = fem::int0;
  //int ioutcs = fem::int0;
  //int kbase = fem::int0;
  //int iupper = fem::int0;
  int ll2 = fem::int0;
  int ll6 = fem::int0;
  int ll8 = fem::int0;
  int ll10 = fem::int0;
  double d1 = fem::double0;
  int j = fem::int0;
  int n13 = fem::int0;
  int n7 = fem::int0;
  int k = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int i = fem::int0;
  int nodev = fem::int0;
  double sdlat = fem::double0;
  int ndx1 = fem::int0;
  int mpower = fem::int0;
  double d4 = fem::double0;
  int L = fem::int0;
  //double d2 = fem::double0;
  double sm = fem::double0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int j8 = fem::int0;
  int m = fem::int0;
  int n3 = fem::int0;
  int n8 = fem::int0;
  int n14 = fem::int0;
  double yx = fem::double0;
  int n4 = fem::int0;
  double gus1 = fem::double0;
  double gus2 = fem::double0;
  double gus3 = fem::double0;
  double gus4 = fem::double0;
  double ts = fem::double0;
  int ii = fem::int0;
  double a = fem::double0;
  int nn15 = fem::int0;
  int n15 = fem::int0;
  int i1 = fem::int0;
  int i2 = fem::int0;
  double a2 = fem::double0;
  double vzero2 = fem::double0;
  double vdiff = fem::double0;
  double vsl = fem::double0;
  //double h1 = fem::double0;
  double sk = fem::double0;
  double h2 = fem::double0;
  double vsr = fem::double0;
  double delti = fem::double0;
  double tz1 = fem::double0;

  auto& d2 = sm;
  auto& h1 = sk;


  auto& ioutcs = lstat(59);
  auto& kbase = moncar(2);
  auto& iupper = iprsov(36);

  auto vsmout = ArraySpan(reinterpret_cast<double*>(&cmn.ismout(1)), cmn.ismout.size() / 2);

  //C     INTRINSIC  ABSZ, COSZ, EXPZ                                       M32.6197
  ll2 = 2;
  ll6 = 6;
  ll8 = 8;
  ll10 = 10;
  if (peaknd(1) == 0.0f) {
    goto statement_1003;
  }
  if (begmax(maxout) > t) {
    goto statement_1003;
  }
  d1 = std::abs(peaknd(1));
  FEM_DO_SAFE(j, 2, ntot) {
    if (std::abs(e(j)) <= d1) {
      goto statement_1002;
    }
    peaknd(1) = e(j);
    d1 = std::abs(e(j));
    peaknd(2) = t;
    peaknd(3) = j;
  statement_1002:;
  }
statement_1003:
  if (istep < limstp) {
    goto statement_12;
  }
  isprin = 0;
  iout = multpr(indstp);
  if (iout >= 0) {
    goto statement_1010;
  }
  iout = -iout;
  FEM_DO_SAFE(j, 1, 4) {
    n13 = iprsov(j + 15);
    iprsov(j + 15) = iprsov(j + 30);
    iprsov(j + 30) = n13;
  }
  iprsup = iprsov(nchain);
statement_1010:
  indstp++;
  limstp = kprchg(indstp);
statement_12:
  n7 = 0;
  if (t <= cmn.tmax) {
    goto statement_14;
  }
  n7 = 1;
  if (cmn.nenerg != 0) {
    goto statement_14;
  }
  isprin = 0;
  isplot = 0;
statement_14:
  if (begmax(1) == 1.0f) {
    goto statement_13;
  }
  //C
  if (koncur == 1) {
    goto statement_13;
  }
  if (npower > 0) {
    goto statement_13;
  }
  if (isprin <= 0) {
    goto statement_13;
  }
  if (isplot > 0) {
    goto statement_1660;
  }
statement_13:
  if (nv == 0) {
    goto statement_1202;
  }
  FEM_DO_SAFE(k, 1, nv) {
    n1 = ibrnch(k);
    n2 = jbrnch(k);
    bvalue(k) = e(n1) - e(n2);
  }
statement_1202:
  volti(1) = t;
  if (cmn.ivolt == 1) {
    goto statement_1610;
  }
  k = 1;
statement_1600:
  if (k > cmn.numnvo) {
    goto statement_1630;
  }
  i = ibsout(k);
  k++;
  volti(k) = e(i);
  goto statement_1600;
statement_1610:
  k = ntot;
  mover(e(ll2), volti(ll2), cmn.ntot1);
statement_1630:
  if (nc == 0) {
    goto statement_1642;
  }
  nodev = k;
  FEM_DO_SAFE(i, 1, nc) {
    k++;
    volti(k) = bvalue(i);
  }
statement_1642:
  if (cmn.iaverg == 0) {
    goto statement_1652;
  }
  if (istep == 0) {
    goto statement_1657;
  }
  FEM_DO_SAFE(i, 2, k) {
    sdlat = volti(i);
    ndx1 = lsiz26 + i;
    volti(i) = cmn.onehaf * (sdlat + volti(ndx1));
    volti(ndx1) = sdlat;
  }
  goto statement_1652;
statement_1657:
  FEM_DO_SAFE(i, 2, k) {
    ndx1 = lsiz26 + i;
    volti(ndx1) = volti(i);
  }
statement_1652:
  if (npower <= 0) {
    goto statement_54280;
  }
  FEM_DO_SAFE(i, 1, npower) {
    mpower = maxpe + i;
    j = koutvp(i);
    if (j > 0) {
      goto statement_54262;
    }
    j = -j;
    n1 = ibrnch(j);
    d4 = e(n1);
    goto statement_54265;
  statement_54262:
    d4 = bvalue(j);
  statement_54265:
    L = koutvp(mpower);
    d1 = d4 * bvalue(L);
    bnrg(i) += d1 * deltat;
    if (istep == 0) {
      bnrg(i) = delta2 * d1;
    }
    d2 = bnrg(i) - d1 * delta2;
    n5 = j + nodev;
    n6 = L + nodev;
    volti(n5) = d1;
    volti(n6) = d2;
    if (istep <= 5 && iprsup >= 2) {
      write(lunit6, "(/,' AT 54270',4i10,5e15.4)"), i, k, j, L, d1,
        d2, bnrg(i), d4, bvalue(L);
    }
  }
statement_54280:
  if (nsmout == 0) {
    goto statement_54284;
  }
  mover(vsmout(cmn.msmout + 1), volti(k + 1), nsmout);
  k += nsmout;
statement_54284:
  if (ioutcs == 0) {
    goto statement_1650;
  }
  FEM_DO_SAFE(j8, 1, ioutcs) {
    k++;
    ndx1 = kxtcs + ivarb(kjout + j8);
    volti(k) = sptacs(ndx1);
  }
statement_1650:
  if (numout == 0) {
    goto statement_1643;
  }
  mover(spum(cmn.iuumou), volti(k + 1), numout);
  k += numout;
statement_1643:
  if (k > 1) {
    goto statement_1647;
  }
  kill = 44;
  lstat(19) = 1650;
  goto statement_9200;
statement_1647:
  if (koncur == 1) {
    spytac();
  }
  if (isplot > 0) {
    goto statement_1653;
  }
  if (cmn.m4plot == 0) {
    goto statement_1648;
  }
  pltfil(cmn, k);
  goto statement_1649;
statement_1648:
  {
    write_loop wloop(cmn, cmn.lunit4, fem::unformatted);
    FEM_DO_SAFE(i, 1, k) {
      wloop, volti(i);
    }
  }
statement_1649:
  isplot = cmn.iplot;
statement_1653:
  if (isprin > 0) {
    goto statement_1654;
  }
  if (kbase >= 2) {
    goto statement_1654;
  }
  n1 = k;
  if (n1 > 10) {
    n1 = 10;
  }
  if (istep > 99999) {
    istep = istep - 100000;
  }
  if (t >= cmn.unity) {
    goto statement_48;
  }
  if (deltat < cmn.tenm6) {
    goto statement_48;
  }
  {
    write_loop wloop(cmn, lunit6, "(1x,i5,f9.6,9e13.6)");
    wloop, istep;
    FEM_DO_SAFE(i, 1, n1) {
      wloop, volti(i);
    }
  }
  goto statement_56;
statement_48:
  if (istep <= 9999) {
    goto statement_39;
  }
  {
    write_loop wloop(cmn, lunit6, "(1x,i5,e9.3,9e13.6)");
    wloop, istep;
    FEM_DO_SAFE(i, 1, n1) {
      wloop, volti(i);
    }
  }
  goto statement_56;
statement_39:
  {
    write_loop wloop(cmn, lunit6, "(1x,i4,e10.3,9e13.6)");
    wloop, istep;
    FEM_DO_SAFE(i, 1, n1) {
      wloop, volti(i);
    }
  }
statement_56:
  if (k > n1) {
    {
      write_loop wloop(cmn, lunit6, "(15x,9e13.6)");
      FEM_DO_SAFE(i, 11, k) {
        wloop, volti(i);
      }
    }
  }
  isprin = iout;
statement_1654:
  if (begmax(1) == 0.0f) {
    goto statement_1660;
  }
  if (t < begmax(maxout)) {
    goto statement_1660;
  }
  //C     NOW UPDATE EXTREMA VECTOR  "XMAX" .   THERE ARE 4                 M27.1476
  //C     PARTITIONS OF SIZE OF LIST 12:  (XMAX, TMAX, XMIN, TMIN).         M27.1477
  FEM_DO_SAFE(i, 2, k) {
    L = i - 1;
    ndx1 = 2 * lsiz12 + L;
    if (volti(i) >= xmax(ndx1)) {
      goto statement_4655;
    }
    xmax(ndx1) = volti(i);
    ndx1 += lsiz12;
    xmax(ndx1) = t;
  statement_4655:
    if (volti(i) <= xmax(L)) {
      goto statement_1655;
    }
    xmax(L) = volti(i);
    ndx1 = lsiz12 + L;
    xmax(ndx1) = t;
  statement_1655:;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6, "(/,' XMAX(I) AT 1656',/(1x,8e15.4))");
      FEM_DO_SAFE(i, 1, L) {
        wloop, xmax(i);
      }
    }
  }
statement_1660:
  if (n7 == 0) {
    goto statement_1661;
  }
  if (cmn.memsav == 0) {
    goto statement_8000;
  }
statement_1661:
  istep++;
  t += deltat;
  if (t > begmax(maxout + 1)) {
    maxout += 2;
  }
  isplot = isplot - 1;
  isprin = isprin - 1;
  if (t < sptacs(29)) {
    goto statement_1945;
  }
  sptacs(29) = cmn.fltinf;
  ivarb(kiuty + 3) = ivarb(kiuty + 2);
statement_1945:
  if (iprsup >= 4) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' K, IBR =',2i6,10x,'(F(I), I=1, NTOT )  FOLLOW ...',/(1x,"
        "8e16.7))");
      wloop, k, cmn.ibr;
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, f(i);
      }
    }
  }
  //C                                 CONSTANT VOLTAGES AND CURRENTS           13702
  i = 0;
  if (iread == 0) {
    goto statement_1247;
  }
  //C     READ INPUT CARD USING CIMAGE.                                        13705
  cimage(cmn);
  if (nchain == 16) {
    goto statement_9999;
  }
  write(kunit6, "('+ANOTHER INPUT CARD FOR TYPE 1-10 SOURCES.')");
  if (cmn.kolbeg > 0) {
    goto statement_7823;
  }
  {
    read_loop rloop(abuff(1), "(10e8.0)");
    FEM_DO_SAFE(j, 1, 10) {
      rloop, voltbc(j);
    }
  }
  goto statement_7825;
statement_7823:
  cmn.nfrfld = 10;
  frefld(cmn, voltbc(1));
statement_7825:
  if (voltbc(1) != 9999.f) {
    goto statement_11247;
  }
  write(kunit6, "('+ANOTHER INPUT CARD FOR TYPE 1-10 SOURCES.','   END.')");
  iread = 0;
statement_1247:
  move0(voltbc, ll10);
statement_11247:
  interp();
  if (nstacs == 0) {
    goto statement_11248;
  }
  FEM_DO_SAFE(j, 1, nstacs) {
    //C!N1 = VSTACS(J)
    read(vstacs(j), star), n1;
    if (n1 == 0) {
      goto statement_21247;
    }
    ndx1 = kxtcs + n1;
    voltbc(j) = sptacs(ndx1);
  statement_21247:;
  }
statement_11248:
  if (cmn.kanal > 0) {
    analyt(cmn);
  }
  if (kill > 0) {
    goto statement_9200;
  }
statement_1249:
  i++;
  if (i > kconst) {
    goto statement_1300;
  }
  if (iprsup >= 4) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' I, KCONST =',2i6,10x,'(F(I), I=1, NTOT )  FOLLOW ...',/(1x,"
        "8e16.7))");
      wloop, i, kconst;
      FEM_DO_SAFE(m, 1, ntot) {
        wloop, f(m);
      }
    }
  }
  n1 = node(i);
  n2 = fem::iabs(n1);
  n3 = iform(i);
  if (n3 != 17) {
    goto statement_7362;
  }
  n8 = sfreq(i);
  ndx1 = kxtcs + n8;
  crest(i + 1) = crest(i) * sptacs(ndx1);
  goto statement_1249;
statement_7362:
  if (n3 != 18) {
    goto statement_7368;
  }
  //C     FOLLOWING CODE IS FOR IDEAL TRANSFORMER AND SOURCE:               M32.6205
  n14 = time1(i);
  f(n14) = yx;
  goto statement_1249;
statement_7368:
  if (n3 != 16) {
    goto statement_1251;
  }
  j = i + 1;
  n4 = fem::iabs(node(j));
  gus1 = e(n2) - e(n4);
  n3 = iform(j);
  gus2 = time1(j);
  gus3 = time2(j);
  ck1 = crest(j + 1) - tstop(i) * gus1;
  gus4 = sfreq(j);
  sfreq(j) = tstart(j) + crest(j) - ck1;
  if (sfreq(j) > gus3) {
    goto statement_1256;
  }
  if (sfreq(j) < gus2) {
    goto statement_1257;
  }
  tstop(j) = (sfreq(j) - gus4) / delta2 - tstop(j);
  iform(j) = 1;
statement_1258:
  tstart(j) = sfreq(i) * ck1 + time1(i) * sfreq(j) + tstart(i) * tstop(j);
  yx = crest(i) + tstart(j);
  f(n4) = f(n4) - yx;
  crest(j + 1) = yx;
  i = j;
  goto statement_1250;
statement_1256:
  sfreq(j) = gus3;
  tstop(j) = 0.f;
  iform(j) = 2;
  goto statement_1258;
statement_1257:
  sfreq(j) = gus2;
  tstop(j) = 0.f;
  iform(j) = 3;
  goto statement_1258;
statement_1251:
  yx = 0.f;
  ts = t - tstart(i);
  if (ts < 0.f) {
    goto statement_1250;
  }
  if (t >= tstop(i)) {
    goto statement_1250;
  }
  k = fem::iabs(n3);
  if (k == 14) {
    goto statement_1270;
  }
  if (k == 15) {
    goto statement_1286;
  }
  if (k < 60) {
    goto statement_1387;
  }
  n8 = sfreq(i);
  ndx1 = kxtcs + n8;
  yx = sptacs(ndx1);
  goto statement_1250;
statement_1387:
  yx = crest(i);
  if (k >= 12) {
    goto statement_1280;
  }
  if (k < 11) {
    yx = voltbc(k);
  }
statement_1250:
  if (n1 > 0) {
    goto statement_1260;
  }
  f(n2) += yx;
  goto statement_1249;
statement_1260:
  if (n3 < 0) {
    yx += e(n2);
  }
  e(n2) = yx;
  goto statement_1249;
statement_1270:
  yx = crest(i) * cosz(sfreq(i) * ts + time1(i));
  if (iprsup < 3) {
    goto statement_1250;
  }
  write(lunit6, "(/,' AT 1273 ',7i12,/,/(1x,6e20.8))"), i, kconst,
    n1, n2, n3, node(i), iform(i), t, tstart(i), tstop(i), crest(i),
    sfreq(i), ts, time1(i), yx, f(n2), e(n2);
  goto statement_1250;
statement_1280:
  if (ts >= time1(i)) {
    goto statement_1285;
  }
  yx = ts / time1(i) * yx;
  goto statement_1250;
statement_1285:
  if (k == 12) {
    goto statement_1250;
  }
  yx += sfreq(i) * (ts - time1(i));
  goto statement_1250;
statement_1286:
  yx = crest(i) * (expz(sfreq(i) * ts) - expz(time1(i) * ts));
  goto statement_1250;
  //C                                         ELIMINATION PROCESS ON RIGHT S   13779
  //C                                         Solve for V = [Y] ** -1 * I   M44.2302
statement_1300:
  mover(f(1), e(1), kpartb);
  n1 = 1;
statement_1301:
  e(n1) = 0.0f;
  if (kode(n1) <= n1) {
    goto statement_1302;
  }
  n1 = kode(n1);
  goto statement_1301;
statement_1302:
  FEM_DO_SAFE(j, 2, kpartb) {
    if (kode(j) == 0) {
      goto statement_1303;
    }
    k = kode(j);
    if (k > kpartb) {
      goto statement_1303;
    }
    if (k > j) {
      e(k) += e(j);
    }
  statement_1303:;
  }
  ii = 1;
  if (iprsup < 4) {
    goto statement_1410;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' E(L), L=1, NTOT  AT BEGIN REPEAT SOLN.',/(1x,5e25.15))");
    FEM_DO_SAFE(L, 1, ntot) {
      wloop, e(L);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' TABLE OF FACTORS USED.  L, KM(L), YKM(L)',/(2i10,e30.20,5x,2i10,"
      "e30.20))");
    FEM_DO_SAFE(L, 1, iupper) {
      wloop, L, km(L), ykm(L);
    }
  }
statement_1410:
  if (ii > iupper) {
    goto statement_1450;
  }
  L = fem::iabs(km(ii));
  a = e(L);
  e(L) = a * ykm(ii);
  j = kk(L);
statement_1420:
  ii++;
  if (ii > j) {
    goto statement_1410;
  }
  k = km(ii);
  if (k > kpartb) {
    goto statement_1420;
  }
  e(k) = e(k) - a * ykm(ii);
  goto statement_1420;
statement_1450:
  if (iprsup >= 5) {
    {
      write_loop wloop(cmn, lunit6,
        "(' AFTER DOWNWARD,  ( E(K), K = 1, NTOT )','  FOLLOW ...',/(1x,"
        "8e16.8))");
      FEM_DO_SAFE(k, 1, ntot) {
        wloop, e(k);
      }
    }
  }
  //C                                               BACKSUBSTITUTION           13823
  L = ntot;
  goto statement_5211;
statement_1500:
  if (ii == 1) {
    goto statement_1550;
  }
  a = 0.f;
statement_1510:
  ii = ii - 1;
  k = km(ii);
  if (k < 0) {
    goto statement_1520;
  }
  a = a - e(k) * ykm(ii);
  goto statement_1510;
statement_1520:
  L = fem::iabs(k);
  e(L) += a;
statement_5211:
  if (kode(L) == 0) {
    goto statement_5218;
  }
  if (kode(L) > L) {
    goto statement_5218;
  }
  j = L;
  n5 = kode(j);
statement_5214:
  e(n5) = e(j);
  j = n5;
  n5 = kode(j);
  if (n5 != L) {
    goto statement_5214;
  }
statement_5218:
  if (L <= kpartb) {
    goto statement_1500;
  }
  L = L - 1;
  goto statement_5211;
statement_1550:
  if (inonl == cmn.num99) {
    goto statement_1570;
  }
  FEM_DO_SAFE(i, 1, inonl) {
    if (nltype(i) < 0) {
      goto statement_1559;
    }
    nn15 = nlsub(i);
    n15 = isubeg(nn15);
    if (n15 <= 0) {
      goto statement_1559;
    }
    if (kknonl(n15 + 4) == 0) {
      goto statement_3534;
    }
    if (kknonl(n15 + 3) != i) {
      goto statement_1559;
    }
    //C     PERFORM SIMULTANEOUS  ZNO  SOLUTION IN  "ZINCOX" .                M25. 919
    zincox(cmn, nn15);
    if (kill > 0) {
      goto statement_9200;
    }
    goto statement_1559;
  statement_3534:
    i1 = nonlad(i);
    i2 = nonle(i);
    k = nonlk(i);
    L = fem::iabs(nonlm(i));
    a2 = anonl(i);
    n1 = ilast(i);
    vzero2 = e(k) - e(L);
    if (nltype(i) == 94) {
      goto statement_1521;
    }
    i2 = fem::iabs(i2);
    vzero2 = vzero2 * delta2 + vnonl(i);
    vdiff = vzero2 - vzer5(i);
    vzer5(i) = vzero2;
    if (vdiff < 0.0f) {
      goto statement_3400;
    }
    if (vdiff == 0.0f) {
      goto statement_1555;
    }
    vsl = vzero2 + a2 * cchar(n1);
    h1 = vsl - vchar(n1);
    sk = h1;
    goto statement_3800;
  statement_3100:
    n1++;
    if (n1 < i2) {
      goto statement_3200;
    }
    lstat(19) = 3100;
  statement_4296:
    kill = 35;
    flstat(13) = a2;
    flstat(11) = e(k);
    flstat(12) = e(L);
    lstat(16) = i;
    k = nonlk(i);
    cmn.bus1 = bus(k);
    cmn.bus2 = bus(L);
    goto statement_9200;
  statement_3200:
    h1 = h2;
    sk = h1;
  statement_3800:
    vsr = vzero2 + a2 * cchar(n1 + 1);
    h2 = vsr - vchar(n1 + 1);
    if (h1 * h2 > 0.f) {
      goto statement_3100;
    }
  statement_3300:
    delti = std::abs(h1) * (cchar(n1 + 1) - cchar(n1)) / (std::abs(h1) + std::abs(h2));
    curr(i) = cchar(n1) + delti;
    goto statement_1555;
  statement_3500:
    n1 = n1 - 1;
    if (n1 >= i1) {
      goto statement_3475;
    }
    lstat(19) = 3500;
    goto statement_4296;
  statement_3400:
    vsr = vzero2 + a2 * cchar(n1 + 1);
    h2 = vsr - vchar(n1 + 1);
    goto statement_3450;
  statement_3475:
    h2 = h1;
  statement_3450:
    vsl = vzero2 + a2 * cchar(n1);
    h1 = vsl - vchar(n1);
    sk = h1;
    switch (fem::if_arithmetic(h1 * h2)) {
    case -1: goto statement_3300;
    case  0: goto statement_3300;
    default: goto statement_3500;
    }
  statement_1555:
    ilast(i) = n1;
    goto statement_8259;
  statement_1521:
    i1 = fem::iabs(i1);
    vzer5(i) = vzero2;
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' AEP ARRES. AT 1524 OF ''SUBTS3''.',4i10,3e20.6)"), i,
        nonle(i), i1, i2, vnonl(i), vchar(i2 + 5), vzero2;
    }
    if (vchar(i2 + 5) != 0.0f) {
      goto statement_1561;
    }
    if (std::abs(vnonl(i)) > std::abs(vzero2)) {
      goto statement_8259;
    }
    tz1 = t - deltat;
    write(lunit6,
      "(60x,'ARRESTER  ''',a6,'''  TO  ''',a6,'''  FLASHOVER AT TIME',e13.5,"
      "'  SEC.')"),
      bus(k), bus(L), tz1;
  statement_1561:
    vchar(i2) = vzero2;
    arrest(cmn, cchar(i1), vchar(i2), anonl(i), vzero2, curr(i));
    if (vchar(i2 + 5) != 0.0f) {
      goto statement_8259;
    }
    tz1 = t - deltat;
    write(lunit6,
      "(60x,'ARRESTER  ''',a6,'''  TO  ''',a6,'''   CLEARED  AT TIME',e13.5,"
      "'  SEC.',/,70x,'PER UNIT ENERGY DISSIPATED =',e14.6)"),
      bus(k), bus(L), tz1, vchar(i1 + 8);
    //C     NEXT ASSIGN COMPENSATION CURRENT FOR NON-ZNO  COMPENSATION        M25. 929
    //C     ELEMENTS.  THIS IS USED IN  "SUBTS4"  SUPERPOSITION.              M25. 930
  statement_8259:
    n8 = n15 / 5 + 1;
    cursub(n8) = curr(i);
    f(k) = f(k) - curr(i);
    f(L) += curr(i);
    if (iprsup >= 4) {
      write(lunit6, "(' N.L. ELEM. CURRENT.',6i10,3e15.6)"), i,
        nltype(i), nn15, n8, k, L, curr(i), f(k), f(L);
    }
  statement_1559:;
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' N.L. ELEMENT,  CURR(I), I=1, INONL',6e15.5)");
      FEM_DO_SAFE(i, 1, inonl) {
        wloop, curr(i);
      }
    }
  }
statement_1570:
  lastov = nchain;
  nchain = 19;
  goto statement_9999;
statement_8000:
  lastov = nchain;
  nchain = 20;
  goto statement_9999;
statement_9200:
  lstat(18) = 18;
  lastov = nchain;
  nchain = 51;
statement_9999:;
}

struct subts1_save
{
  int nwarn;
  fem::str<8> text1;
  fem::str<8> text10;
  fem::str<8> text11;
  fem::str<8> text12;
  fem::str<8> text13;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text8;
  fem::str<8> text9;

  subts1_save() :
    nwarn(fem::int0),
    text1(fem::char0),
    text10(fem::char0),
    text11(fem::char0),
    text12(fem::char0),
    text13(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text8(fem::char0),
    text9(fem::char0)
  {}
};

void bansol(
  arr_cref<double> ab,
  arr_ref<double> x,
  int const& n)
{
  ab(dimension(n*2));
  x(dimension(n));
  int i2 = fem::int0;
  int i1 = fem::int0;
  double d = fem::double0;
  //C     THIS ROUTINE PERFORMS FORWARD AND BACKWARD SOLUTION WITH          M37.5623
  //C     WITH A TRIDIAGONAL SYMMETRIC MATRIX 'AB'. FOR DETAIL OF           M37.5624
  //C     STORAGE ARRANGEMENTS FOR 'AB' SEE SUBROUTINE 'BANDEL'.            M37.5625
  //C     INITIALIZATION ************************************************** M37.5627
  i2 = 2;
  i1 = 1;
  //C     FORWARD SUBSTITUTION ( DOWNWARDS ) ****************************** M37.5630
  d = x(1);
statement_10:
  x(i1) = d * ab(i2 - 1);
  if (i1 == n) {
    goto statement_20;
  }
  i1++;
  d = x(i1) - d * ab(i2);
  i2 += 2;
  goto statement_10;
  //C     BACK SUBTITUTION ( UPWARDS ) ************************************ M37.5638
statement_20:
  if (i1 == 1) {
    goto statement_40;
  }
  i2 = i2 - 2;
  i1 = i1 - 1;
  x(i1) = x(i1) - x(i1 + 1) * ab(i2);
  goto statement_20;
statement_40:;
}

void redusm(
  arr_ref<double> x,
  int const& m,
  int const& n)
{
  x(dimension(m*m));
  int j = fem::int0;
  int ik = fem::int0;
  int nk = fem::int0;
  int m1 = fem::int0;
  double c = fem::double0;
  int k = fem::int0;
  arr_1d<6, double> a1(fem::fill0);
  int mk = fem::int0;
  double b = fem::double0;
  int i = fem::int0;
  //C     THIS ROUTINE IS A COPY  OF AN IDENTICAL ROUTINE USED IN OVER12****M23.4834
  //C     IT USES GAUSS-JORDAN ELIMINATION PROCESS FOR BOTH MATRIX INVERSIONM23.4835
  //C     AND MATRIX RDUCTION( ELIMINATION OF VARIABLES)********************M23.4836
  j = m;
  ik = fem::pow2(m);
  nk = ik - m;
  m1 = m + 1;
statement_1:
  c = 1.0f / x(ik);
  FEM_DO_SAFE(k, 1, m) {
    a1(k) = x(nk + k);
  }
  k = 1;
statement_4:
  mk = (k - 1) * m;
  b = -x(mk + j) * c;
  i = 1;
statement_3:
  mk++;
  x(mk) += b * a1(i);
  i++;
  if (i <= m) {
    goto statement_3;
  }
  x(mk - m + j) = b;
  k++;
  if (k == j) {
    k++;
  }
  if (k <= m) {
    goto statement_4;
  }
  FEM_DO_SAFE(k, 1, m) {
    x(nk + k) = a1(k) * c;
  }
  x(ik) = c;
  j = j - 1;
  ik = ik - m1;
  nk = nk - m;
  if (j > n) {
    goto statement_1;
  }
}

void increm(
  common& cmn,
  int const& ilk,
  double const& sf3)
{
  common_write write(cmn);
  int& iprsup = cmn.iprsup;
  auto& elp = cmn.elp;
  const auto& ismdat = cmn.ismdat;
  auto& z = static_cast<common_smach&>(cmn).z;
  auto& x1 = cmn.x1;
  double& factom = cmn.factom;
  double& damrat = cmn.damrat;
  //
  auto& lunit6 = cmn.lunit6;
  int i30 = fem::int0;
  int ll36 = fem::int0;
  double acde = fem::double0;
  double acdf = fem::double0;
  int i26 = fem::int0;
  int i75 = fem::int0;
  double asd = fem::double0;
  double sb = fem::double0;
  double sf4 = fem::double0;
  double sf5 = fem::double0;
  double sf6 = fem::double0;
  double sf7 = fem::double0;
  int k = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int i = fem::int0;
  int ll7 = fem::int0;
  int ll3 = fem::int0;
  double a = fem::double0;
  double b = fem::double0;
  double sum = fem::double0;
  double etot = fem::double0;
  int in = fem::int0;
  int idp = fem::int0;
  int idt = fem::int0;
  int ids = fem::int0;
  int iu = fem::int0;
  static const char* format_6004 = "(/,' NEW COLUMN',i6,/(1x,7e17.8))";
  static const char* format_6005 = "(3x,8e15.7)";
  //C     THIS MODULE IS USED ONLY BY BRANDWAJN (TYPE-59) S.M. MODEL        M31.3340
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE INCREM.\"')");
  }
  i30 = 30 * ilk - 29;
  write(lunit6,
    "(' ***',10x,'MACHINE NO.',i6,10x,'BEGIN OPERATION ON SEGMENTS NO.',2x,"
    "2i10)"),
    ilk, ismdat(i30 + 9), ismdat(i30 + 10);
  ll36 = 36;
  move0(z, ll36);
  acde = 1.0f;
  acdf = 1.0f;
  i26 = 101 * ilk - 100;
  i75 = i26 + 26;
  //C     START  WITH  INCREMENTAL  INDUCTANCES OF THE DIRECT AXIS**********M23.4615
  asd = elp(i26 + 21);
  if (sf3 <= asd) {
    goto statement_205;
  }
  //C     D - AXIS  SATURATED **********************************************M23.4618
  sb = ismdat(i30 + 9);
  sb = sb * 0.1f;
  sf4 = asd * (.9f + sb);
  sf5 = asd * (1.1f + sb);
  sf6 = sf4 / (1.0f + elp(i26 + 22) * (sf4 - asd));
  sf7 = sf5 / (1.0f + elp(i26 + 22) * (sf5 - asd));
  acde = (sf7 - sf6) / (sf5 - sf4);
  //C     CALCULATE INCREMENTAL INDUCTANCES FOR THE QUADRATURE AXIS ********M23.4626
statement_205:
  asd = elp(i26 + 23);
  if (sf3 <= asd) {
    goto statement_206;
  }
  //C     Q - AXIS  SATURATED **********************************************M23.4629
  sb = ismdat(i30 + 10);
  sb = sb * 0.1f;
  sf4 = asd * (.9f + sb);
  sf5 = asd * (1.1f + sb);
  sf6 = sf4 / (1.0f + elp(i26 + 24) * (sf4 - asd));
  sf7 = sf5 / (1.0f + elp(i26 + 24) * (sf5 - asd));
  acdf = (sf7 - sf6) / (sf5 - sf4);
statement_206:
  z(50) = (elp(i26) * acde + elp(i26 + 18)) * factom;
  z(51) = (elp(i26 + 8) * acdf + elp(i26 + 18)) * factom;
  z(52) = elp(i26 + 2) + elp(i75 + 35) * acde;
  z(53) = elp(i26 + 5) + elp(i75 + 36) * acde;
  z(54) = elp(i26 + 10) + elp(i75 + 37) * acdf;
  z(55) = elp(i26 + 13) + elp(i75 + 38) * acdf;
  //C     FILL IN  THE  THE  TRANSFORMER TERMS   OF  THE RESISTIVE HISTORY**M23.4642
  //C     MATRIX OF  THE  GENERATOR*****************************************M23.4643
  z(1) = z(50) + elp(i26 + 19);
  z(8) = z(51) + elp(i26 + 19);
  z(15) = z(52) + elp(i26 + 6);
  z(22) = z(53) + elp(i26 + 7);
  z(29) = z(54) + elp(i26 + 14);
  z(36) = z(55) + elp(i26 + 15);
  z(11) = elp(i75 + 41) * acdf;
  z(26) = z(11);
  z(12) = elp(i75 + 42) * acdf;
  z(32) = z(12);
  z(30) = elp(i26 + 12) * acdf;
  z(35) = z(30);
  z(3) = elp(i75 + 39) * acde;
  z(13) = z(3);
  z(4) = elp(i75 + 40) * acde;
  z(19) = z(4);
  z(16) = elp(i26 + 4) * acde;
  z(21) = z(16);
  if (iprsup < 1) {
    goto statement_208;
  }
  FEM_DO_SAFE(k, 1, 6) {
    n1 = (k - 1) * 6 + 1;
    n2 = n1 + 5;
    {
      write_loop wloop(cmn, lunit6, format_6004);
      wloop, k;
      FEM_DO_SAFE(i, n1, n2) {
        wloop, z(i);
      }
    }
  }
statement_208:
  mover(z(1), x1(1), ll36);
  ll7 = 6;
  ll3 = 2;
  redusm(x1(1), ll7, ll3);
  if (iprsup <= 0) {
    goto statement_210;
  }
  write(lunit6, "(/,' REDUCED NETWORK MODEL.',i10)"), ilk;
  FEM_DO_SAFE(k, 1, 6) {
    n1 = (k - 1) * 6 + 1;
    n2 = n1 + 5;
    {
      write_loop wloop(cmn, lunit6, format_6004);
      wloop, k;
      FEM_DO_SAFE(i, n1, n2) {
        wloop, x1(i);
      }
    }
  }
statement_210:
  a = x1(1);
  b = x1(8);
  sf6 = a;
  sf7 = b;
  //C     SUM=(A+B) * ONEHAF                                                M37.5585
  //C     A=A-SUM                                                           M37.5586
  //C     X1(1)=A                                                           M37.5587
  //C     X1( 8 ) = -A                                                      M37.5588
  sum = a;
  x1(8) = b - a;
  etot = 1.0f / elp(i26 + 16);
  a = 1.0f / sum;
  b = 1.0f / etot;
  sum = (b + 2.0f * a) / 3.0f;
  etot = (b - a) / 3.0f;
  elp(i75) = sum;
  elp(i75 + 1) = etot;
  elp(i75 + 53) = a * cmn.athtw;
  elp(i75 + 54) = b * cmn.asqrt3;
  if (iprsup <= 0) {
    goto statement_212;
  }
  write(lunit6, format_6005), elp(i75), elp(i75 + 1), elp(i75 + 53),
    elp(i75 + 54);
  //C     CORRECTION TERMS FOR VOLTAGE AND CURRENT CALCULATIONS*************M23.4718
statement_212:
  elp(i75 + 5) = x1(3);
  elp(i75 + 6) = x1(4);
  elp(i75 + 7) = x1(11);
  elp(i75 + 8) = x1(12);
  elp(i75 + 9) = x1(15);
  elp(i75 + 10) = x1(21);
  elp(i75 + 11) = x1(16);
  elp(i75 + 12) = x1(22);
  elp(i75 + 13) = x1(29);
  elp(i75 + 14) = x1(35);
  elp(i75 + 15) = x1(30);
  elp(i75 + 16) = x1(36);
  elp(i75 + 43) = x1(13);
  elp(i75 + 44) = x1(19);
  elp(i75 + 45) = x1(26);
  elp(i75 + 46) = x1(32);
  elp(i75 + 47) = 1.0f / sf6;
  elp(i75 + 48) = elp(i26 + 18) * elp(i75 + 39);
  elp(i75 + 49) = sf7;
  elp(i75 + 52) = x1(8);
  if (iprsup < 1) {
    goto statement_214;
  }
  idp = in;
  in += 7;
  ids = idt + 3;
  write(lunit6,
    "(5x,' ARRAYS FOR MACH NO.',i5,'  IN ORDER OF AC ',1x,'A21,',1x,'A22,',"
    "1x)"),
    ilk;
  write(lunit6, format_6005), elp(i75 + 2), elp(i75 + 3), elp(i75 + 51),
    elp(i75 + 52);
  idt = i75 + 5;
  ids = idt + 3;
  {
    write_loop wloop(cmn, lunit6, format_6005);
    FEM_DO_SAFE(iu, idt, ids) {
      wloop, elp(iu);
    }
  }
  ids++;
  idt = ids + 7;
  {
    write_loop wloop(cmn, lunit6, format_6005);
    FEM_DO_SAFE(iu, ids, idt) {
      wloop, elp(iu);
    }
  }
  //C     CALCULATE THE RESISTIVE MATRIX FOR HISTORY CALCULATIONS           M23.4759
  //C     STORE  CONSTANTS FOR FUTURE USE IN THE TIME-STEP LOOP ************M23.4760
statement_214:
  elp(i75 + 17) = z(50) - elp(i26 + 19) * damrat;
  elp(i75 + 18) = z(13);
  elp(i75 + 19) = z(19);
  elp(i75 + 20) = z(51) - elp(i26 + 19) * damrat;
  elp(i75 + 21) = z(26);
  elp(i75 + 22) = z(32);
  elp(i75 + 23) = z(3);
  elp(i75 + 24) = z(52) - elp(i26 + 6) * damrat;
  elp(i75 + 25) = z(21);
  elp(i75 + 26) = z(4);
  elp(i75 + 27) = z(16);
  elp(i75 + 28) = z(53) - elp(i26 + 7) * damrat;
  elp(i75 + 29) = z(11);
  elp(i75 + 30) = z(54) - elp(i26 + 14) * damrat;
  elp(i75 + 31) = z(35);
  elp(i75 + 32) = z(12);
  elp(i75 + 33) = z(30);
  elp(i75 + 34) = z(55) - elp(i26 + 15) * damrat;
  if (iprsup < 1) {
    goto statement_216;
  }
  write(lunit6, "(/,' HISTORY MATRIX FOR GENERATOR NO.',i5)"), ilk;
  in = i75 + 9;
  FEM_DO_SAFE(k, 1, 5) {
    in += 7;
    n2 = in + 7;
    n1 = in + 1;
    {
      write_loop wloop(cmn, lunit6, "(1x,'NEW  ROW    ',i6,/(1x,7e17.8))");
      wloop, in;
      FEM_DO_SAFE(i, n1, n2) {
        wloop, elp(i);
      }
    }
  }
  write(lunit6, "('  \"EXIT  MODULE INCREM.\"')");
statement_216:;
}




void update(
  common& cmn)
{
  common_write write(cmn);
  double& delta2 = cmn.delta2;
  double& omega = cmn.omega;
  double& onehaf = cmn.onehaf;
  double& flzero = cmn.flzero;
  auto& flstat = cmn.flstat;
  auto& lstat = cmn.lstat;
  const auto& iprsov = cmn.iprsov;
  int& numsm = cmn.numsm;
  int& iprsup = cmn.iprsup;
  int& ibr = cmn.ibr;
  auto& ykm = cmn.ykm;
  const auto& sptacs = cmn.sptacs;
  auto& cik = cmn.cik;
  auto& ismout = cmn.ismout;
  auto& elp = cmn.elp;
  auto& cu = cmn.cu;
  auto& shp = cmn.shp;
  auto& histq = cmn.histq;
  auto& ismdat = cmn.ismdat;
  const auto& e = cmn.e;
  const auto& bus = cmn.bus;
  auto& etac = cmn.etac;
  const auto& ismtac = cmn.ismtac;
  auto& x1 = cmn.x1;
  auto& smoutv = cmn.smoutv;
  double& sqrt32 = cmn.sqrt32;
  double& athtw = cmn.athtw;
  double& damrat = cmn.damrat;
  double& om2 = cmn.om2;
  auto& ksmspy = cmn.ksmspy;
  //
  int kxtcs = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int ilk = fem::int0;
  int ll0 = fem::int0;
  int ll1 = fem::int0;
  int nwd = fem::int0;
  int ikn = fem::int0;
  int i26 = fem::int0;
  int ll7 = fem::int0;
  int iu = fem::int0;
  int ib = fem::int0;
  int lmset = fem::int0;
  int icnt = fem::int0;
  int ipout = fem::int0;
  double acb = fem::double0;
  int j30 = fem::int0;
  int i30 = fem::int0;
  int j75 = fem::int0;
  int n22spy = fem::int0;
  int k = fem::int0;
  int im = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  double v1 = fem::double0;
  double v2 = fem::double0;
  double v3 = fem::double0;
  int idsat = fem::int0;
  int idelta = fem::int0;
  double ap1 = fem::double0;
  double ap2 = fem::double0;
  int numask = fem::int0;
  int nlocg = fem::int0;
  int nloce = fem::int0;
  int num2 = fem::int0;
  int num4 = fem::int0;
  int num6 = fem::int0;
  int n26 = fem::int0;
  int n27 = fem::int0;
  int ikv = fem::int0;
  int ikw = fem::int0;
  int ibu = fem::int0;
  int n22 = fem::int0;
  int kag = fem::int0;
  int kag2 = fem::int0;
  int ksg = fem::int0;
  int ksex = fem::int0;
  int ikp = fem::int0;
  int i75 = fem::int0;
  double a1 = fem::double0;
  double a2 = fem::double0;
  int juk = fem::int0;
  double d6 = fem::double0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  double cv3 = fem::double0;
  double a5 = fem::double0;
  double cz = fem::double0;
  double czt = fem::double0;
  double acde = fem::double0;
  double acdf = fem::double0;
  int ispdr = fem::int0;
  double q3 = fem::double0;
  double etot = fem::double0;
  double sum = fem::double0;
  double dsped = fem::double0;
  int n7 = fem::int0;
  double au = fem::double0;
  double av = fem::double0;
  double tsd = fem::double0;
  double tsc = fem::double0;
  double a3 = fem::double0;
  double cv1 = fem::double0;
  double a4 = fem::double0;
  double cv2 = fem::double0;
  double c1 = fem::double0;
  double c2 = fem::double0;
  double c3 = fem::double0;
  double c4 = fem::double0;
  double ac2 = fem::double0;
  double ac1 = fem::double0;
  double cd = fem::double0;
  double cexc = fem::double0;
  int jt = fem::int0;
  int ik = fem::int0;
  int m1 = fem::int0;
  int ndx1 = fem::int0;
  double q2 = fem::double0;
  double spdn = fem::double0;
  double spdd = fem::double0;
  int kc = fem::int0;
  int ka = fem::int0;
  int kb = fem::int0;
  int kd = fem::int0;
  double d2 = fem::double0;
  double dang = fem::double0;
  auto& epomeg = cmn.epomeg;
  int k1 = fem::int0;
  int kmset = fem::int0;
  int i = fem::int0;
  int jmset = fem::int0;
  double sf4 = fem::double0;
  double sf5 = fem::double0;
  int n9 = fem::int0;
  int jmset1 = fem::int0;
  int m = fem::int0;
  int n5 = fem::int0;
  int ids = fem::int0;
  int n8 = fem::int0;
  int L = fem::int0;
  double d9 = fem::double0;
  int n12 = fem::int0;
  int n13 = fem::int0;
  int mp = fem::int0;
  double s1 = fem::double0;
  int iz = fem::int0;
  int iy = fem::int0;
  int izy = fem::int0;
  double d11 = fem::double0;
  double d12 = fem::double0;
  int ik1 = fem::int0;
  double d31 = fem::double0;
  double d32 = fem::double0;
  double d21 = fem::double0;
  double d22 = fem::double0;
  int ij = fem::int0;
  double alpha = fem::double0;
  int isd = fem::int0;
  int isq = fem::int0;
  double acur2 = fem::double0;
  double q4 = fem::double0;
  double acd = fem::double0;
  double acq = fem::double0;
  int itq = fem::int0;
  double acur1 = fem::double0;
  int ip = fem::int0;
  double a11 = fem::double0;
  int ies = fem::int0;
  int ifs = fem::int0;
  int ll3 = fem::int0;
  //C     THIS MODULE IS USED ONLY BY BRANDWAJN (TYPE-59) S.M. MODEL        M31.3338
  //C!DIMENSION VSMOUT(1)
  //C!EQUIVALENCE ( ISMOUT(1), VSMOUT(1) )
  //C!DIMENSION MASSEX(1)
  //C!EQUIVALENCE ( HISTQ(1), MASSEX(1) )
  //C     INTRINSIC  COSZ, SINZ, ABSZ, SQRTZ, ATAN2Z                        M34. 158
  //C     THIS ROUTINE ADJUSTS THE CURRENT SOURCES TO BE INJECTED INTO      M20.4303
  //C     THE EQUIVALENT PI-CIRCUITS * * * * * * * * * * * * * * * * * * * *M20.4304
  kxtcs = sptacs(17);
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE UPDATE.\"')");
  }
  //C     INITIALIZE COUNTERS     ******************************************M33.1543
  ilk = 0;
  ll0 = 0;
  ll1 = 1;
  //C     COUNTERS FOR ELECTRICAL VARIABLES ********************************M33.1547
  ibr = cmn.ibrold;
  nwd = 24;
  ikn = 1;
  i26 = 0;
  ll7 = 7;
  //C     COUNTERS FOR MECHANICAL VARIABLES ********************************M33.1556
  iu = 0;
  ib = 0;
  //C     CONTERS FOR TACS  INTERFACE AND OUTPUT. COMPUTATIONAL CONSTANTS   M33.1561
  lmset = 0;
  icnt = cmn.msmout;
  ipout = -2;
  //CCCC  ACB = OMDT * ISTEP                                                VAX.2973
  acb = omega * cmn.t;
  if (iprsup > 0) {
    write(lunit6,
      "(' BEGIN  ''UPDATE'' ',5x,'IBR',5x,'NUMSM',8x,'IT',/,15x,3(5x,i5))"),
      ibr, numsm, cmn.it;
  }
  j30 = 1;
  i30 = 1;
  j75 = 27;
  n22spy = ksmspy(1);
  FEM_DO_SAFE(k, 1, numsm) {
    im = ismdat(j30);
    n1 = ismdat(j30 + 2);
    n2 = ismdat(j30 + 5);
    v1 = e(n1) - e(n2);
    n1 = ismdat(j30 + 3);
    n2 = ismdat(j30 + 6);
    v2 = e(n1) - e(n2);
    n1 = ismdat(j30 + 4);
    n2 = ismdat(j30 + 7);
    v3 = e(n1) - e(n2);
    idsat = 0;
    idelta = ismdat(j30 + 1);
    ap1 = 0.0f;
    ap2 = 0.0f;
    if (iprsup > 0) {
      write(lunit6,
        "(13x,'V1',9x,'NODSMA',13x,'V2',9x,'NODSMB',13x,'V3',9x,'NODSMC',/,"
        "3(1x,e14.7,10x,i5))"),
        v1, ismdat(j30 + 2), v2, ismdat(j30 + 3), v3, ismdat(j30 + 4);
    }
  statement_800:
    ilk++;
    numask = ismdat(i30 + 11);
    nlocg = ismdat(i30 + 12);
    nloce = ismdat(i30 + 13);
    num2 = numask + numask;
    num4 = num2 + num2;
    num6 = num4 + num2;
    n26 = iu + num4;
    n27 = n26 + numask;
    ikv = iu + numask;
    ikw = ikv + 1;
    ibu = ib + 1;
    n22 = ib + num2;
    kag = iu + nlocg;
    kag2 = kag + num2;
    ksg = kag + numask;
    ksex = ikv + nloce;
    ikp = ikv + numask;
    //C     CALCULATE CURRENTS FOR TIME ''T-DELTAT''                          M20.4346
    i75 = i26 + 27;
    a1 = elp(i75);
    a2 = elp(i75 + 1);
    juk = ibr + 1;
    d6 = -a1 * v1 - a2 * (v2 + v3) - cik(juk);
    d7 = -a1 * v2 - a2 * (v1 + v3) - cik(juk + 1);
    d8 = -a1 * v3 - a2 * (v1 + v2) - cik(juk + 2);
    cv3 = (v1 + v2 + v3) * cmn.asqrt3;
    a5 = -(cv3 - cu(ikn + 2)) * elp(i26 + 17);
    if (iprsup > 0) {
      write(lunit6,
        "(' FOR TIME \"T-DELTAT\".',18x,'D6',18x,'D7',18x,'D8',/,21x,3e20.11)"),
        d6, d7, d8;
    }
    //C     TRANSFORM PHASE VARIABLES TO PARK"S COORDINATES  * * * * * * * * *M30. 554
    cz = elp(i26 + 26);
    czt = cz * cmn.tenm6;
    acde = elp(i75 + 2);
    acdf = elp(i75 + 3);
    ispdr = 1;
    q3 = -cu(ikn + 10) * cu(ikn + 11) * czt;
    etot = cu(ikn + 19);
    sum = cu(ikn + 20);
    dsped = histq(ksg);
    n7 = ismdat(i30 + 16);
    //C     ENTER THE ITERATION LOOP(ANGLE,SPEED,CURRENT)  * * * * * * * * * *M30. 570
  statement_200:
    etot = etot * athtw;
    sum = sum * athtw;
    au = etot * onehaf;
    av = sum * sqrt32;
    tsd = av - au;
    tsc = -au - av;
    a3 = d6 * etot + d7 * tsd + d8 * tsc;
    cv1 = v1 * etot + v2 * tsd + v3 * tsc;
    au = au * cmn.sqrt3;
    av = sum * onehaf;
    tsd = au - av;
    tsc = -av - au;
    a4 = d6 * sum + d7 * tsc + d8 * tsd;
    cv2 = v1 * sum + v2 * tsc + v3 * tsd;
    //C     CALCULATE ROTOR CURRENTS **************************************** M38.3186
    c1 = elp(i75 + 5) * a3 + elp(i75 + 9) * cu(ikn + 3) + elp(i75 +
      10) * cu(ikn + 4);
    c2 = elp(i75 + 6) * a3 + elp(i75 + 10) * cu(ikn + 3) + elp(i75 +
      12) * cu(ikn + 4);
    c3 = elp(i75 + 7) * a4 + elp(i75 + 13) * cu(ikn + 5) + elp(i75 +
      14) * cu(ikn + 6);
    c4 = elp(i75 + 8) * a4 + elp(i75 + 14) * cu(ikn + 5) + elp(i75 +
      16) * cu(ikn + 6);
    if (iprsup < 1) {
      goto statement_922;
    }
    write(lunit6,
      "(40x,' UPDATED CURRENTS',40x,' UPDATED VOLTAGES',/,3x,3e18.10,3x,"
      "3e18.10)"),
      a3, a4, a5, cv1, cv2, cv3;
    write(lunit6, "(' UPDATED ROTOR CURRENTS',/,2x,4(e20.12,5x))"),
      c1, c2, c3, c4;
    //C     CALCULATE THE ELECTROMAGNETIC TORQUE***************************** M37.5374
  statement_922:
    ac2 = elp(i26 + 1) * a3 + elp(i26 + 2) * c1 + elp(i26 + 4) * c2;
    ac1 = elp(i26 + 9) * a4 + elp(i26 + 10) * c3 + elp(i26 + 12) * c4;
    cd = (ac2 * acde * a4 - ac1 * acdf * a3) * czt;
    //C     RESOLVE THE MECHANICHAL EQUATIONS. NOTE THE  CONSTANT TERMS HAVE  M30. 589
    //C     BEEN CALCULATED IN THE PREVIOUS TIME-STEP* * * * * * * * * * * * *M30. 590
    cexc = histq(ksex);
    jt = n27;
    if (n7 > 0) {
      goto statement_220;
    }
    FEM_DO_SAFE(ik, ikw, ikp) {
      jt++;
      histq(ik) = histq(jt) / histq(ik);
    }
    goto statement_222;
  statement_220:
    m1 = n7;
    FEM_DO_SAFE(ik, ikw, ikp) {
      jt++;
      m1 = m1 - 1;
      ndx1 = histq(m1);
      if (ndx1 > 0) {
        goto statement_221;
      }
      q2 = 1.0f;
      goto statement_201;
    statement_221:
      ndx1 += kxtcs;
      q2 = sptacs(ndx1);
    statement_201:
      histq(ik) = (histq(jt) * q2) / histq(ik);
    }
  statement_222:
    histq(ksg) = histq(ksg) - cd;
    if (nloce == 0) {
      goto statement_202;
    }
    cexc = (q3 * c1) / cexc;
    histq(ksex) = histq(ksex) - cexc;
    //C     CALCULATE NEW ESTIMATES OF MECHANICAL SPEEDS AND ROTOR ANGLE * * *M30. 605
  statement_202:
    jt = n26;
    FEM_DO_SAFE(ik, ikw, ikp) {
      jt++;
      histq(jt) = -histq(ik);
      histq(ik) = histq(ik) - histq(ik + num2);
    }
    bansol(shp(ibu), histq(ikw), numask);
    spdn = histq(ksg);
    //C     CHECK THE CONVERGENCE OF ROTOR SPEED **************************** M37.5393
    if (std::abs(dsped) <= flzero) {
      dsped = flzero;
    }
    spdd = std::abs((spdn - dsped) / dsped);
    if (spdd > cmn.epdgel) {
      goto statement_206;
    }
    //C     SUCCESSFUL ITERATION (CONVERGENCE ACHIEVED ) * * * * * * * * * * *M30. 614
    //C     FINISH THE CALCULATION OF THE MECHANICAL ANGLES  * * * * * * * * *M30. 615
  statement_204:
    kc = n22 + 5 * numask;
    FEM_DO_SAFE(ka, 1, numask) {
      jt = iu + ka;
      ik = ikv + ka;
      kb = n26 + ka;
      kd = kc + ka;
      histq(ik + num2) = histq(kb) - shp(kd);
      histq(jt) = histq(jt + num2) + delta2 * histq(ik);
    }
    //C     STORE THE CALCULATED CURRENTS AND VOLTAGES   * * * * * * * * * * *M30. 622
    cu(ikn) = a3;
    cu(ikn + 1) = a4;
    cu(ikn + 2) = a5;
    cu(ikn + 3) = c1;
    cu(ikn + 4) = c2;
    cu(ikn + 5) = c3;
    cu(ikn + 6) = c4;
    d2 = spdn * cz;
    q3 = cu(ikn + 10) * cu(ikn + 11);
    dang = histq(kag) * cz;
    goto statement_208;
  statement_206:
    dsped = spdn;
    ispdr++;
    dang = (histq(kag2) + delta2 * spdn) * cz;
    etot = cosz(dang);
    sum = sinz(dang);
    if (ispdr <= iprsov(37)) {
      goto statement_200;
    }
    if (spdd > epomeg) {
      goto statement_920;
    }
    write(lunit6,
      "(2x,'WARNING',2x,15('*'),/,2x,'LACK OF CONVERGENCE FOR MACHINE NO.',i5,"
      "2x,'ON STEP NO.',i10,/,' Iteration limit  IPRSOV(37) =',i10)"),
      ilk, cmn.istep, iprsov(37);
    goto statement_204;
  statement_920:
    lstat(19) = 206;
    lstat(18) = cmn.nchain;
    k1 = ismdat(j30 + 2);
    cmn.bus1 = bus(k1);
    flstat(14) = spdd;
    lstat(12) = ilk;
    cmn.kill = 104;
    return;
  statement_208:
    if (iprsup == 0) {
      goto statement_50;
    }
    write(lunit6,
      "(6x,'AFTER SPEED CALCULATION',5x,'ROTOR',13x,'EXCITER',17x,'TEG',16x,"
      "'TEXC',/,20x,4e20.12)"),
      spdn, histq(ksex), cd, cexc;
    //C     LOAD INTERNAL MACHINE VARIABLES INTO TACS VARIABLE 'ETAC' ******* M38.3226
  statement_50:
    if (n22spy != -1) {
      goto statement_51;
    }
    ksmspy(2) = ilk;
    emtspy(cmn);
    if (ksmspy(1) == -1) {
      goto statement_51;
    }
    if (ksmspy(1) == 2) {
      n22spy = 0;
    }
    if (n22spy == 0) {
      goto statement_51;
    }
    smoutv(1) = d6;
    smoutv(2) = d7;
    smoutv(3) = d8;
    smoutv(4) = cv1;
    smoutv(5) = cv2;
    smoutv(6) = cv3;
    smoutv(7) = q3;
    smoutv(8) = v1;
    smoutv(9) = v2;
    smoutv(10) = v3;
    smoutv(11) = cd;
    smoutv(12) = cexc;
    goto statement_50;
  statement_51:
    kmset = ismdat(i30 + 14);
    if (kmset == 0) {
      goto statement_8610;
    }
    FEM_DO_SAFE(i, 1, kmset) {
      lmset++;
      jmset = ismtac(lmset);
      if (jmset > 0) {
        goto statement_1696;
      }
      jmset = -jmset;
      if (jmset > 7) {
        goto statement_1680;
      }
      etac(lmset) = cu(ikn + jmset - 1);
      goto statement_8650;
    statement_1680:
      if (jmset > 8) {
        goto statement_1681;
      }
      etac(lmset) = cv1;
      goto statement_8650;
    statement_1681:
      if (jmset > 9) {
        goto statement_1682;
      }
      etac(lmset) = cv2;
      goto statement_8650;
    statement_1682:
      if (jmset > 10) {
        goto statement_1683;
      }
      etac(lmset) = cv3;
      goto statement_8650;
    statement_1683:
      if (jmset > 11) {
        goto statement_1684;
      }
      etac(lmset) = q3;
      goto statement_8650;
    statement_1684:
      if (jmset > 13) {
        goto statement_1686;
      }
      sf4 = a3 * elp(i26 + 21) + c1 + c2;
      sf5 = (a4 * elp(i26 + 21) + c3 + c4) * elp(i75 + 4);
      if (jmset == 13) {
        goto statement_1685;
      }
      etac(lmset) = sqrtz(fem::pow2(sf4) + fem::pow2(sf5));
      goto statement_8650;
    statement_1685:
      etac(lmset) = std::atan2(sf5, sf4);
      goto statement_8650;
    statement_1686:
      if (jmset > 14) {
        goto statement_1687;
      }
      etac(lmset) = cd;
      goto statement_8650;
    statement_1687:
      if (jmset > 15) {
        goto statement_1688;
      }
      etac(lmset) = cexc;
      goto statement_8650;
    statement_1688:
      if (jmset == 17) {
        goto statement_1689;
      }
      etac(lmset) = ac2 * acde + elp(i26 + 19) * a3;
      goto statement_8650;
    statement_1689:
      etac(lmset) = ac1 * acdf + elp(i26 + 19) * a4;
      goto statement_8650;
    statement_1696:
      if (jmset > num2) {
        goto statement_1697;
      }
      n9 = iu + jmset;
      etac(lmset) = histq(n9);
      goto statement_8650;
    statement_1697:
      jmset1 = jmset - num2;
      m = iu + jmset1;
      n5 = m + numask;
      ids = n22 + jmset;
      etac(lmset) = shp(ids + numask) * (histq(m) - histq(m + 1)) +
        shp(ids) * (histq(n5) - histq(n5 + 1));
    statement_8650:;
    }
  statement_8610:
    n9 = ismdat(i30 + 17);
    if (n9 < 0) {
      goto statement_209;
    }
    if (n9 == 0) {
      goto statement_8215;
    }
    n8 = ikn - 1;
    FEM_DO_SAFE(ka, 1, n9) {
      ipout += 3;
      icnt++;
      n5 = ismout(ipout);
      switch (n5) {
      case 1: goto statement_8201;
      case 2: goto statement_8201;
      case 3: goto statement_8201;
      case 4: goto statement_8201;
      case 5: goto statement_8201;
      case 6: goto statement_8201;
      case 7: goto statement_8201;
      case 8: goto statement_8202;
      case 9: goto statement_8203;
      case 10: goto statement_8204;
      case 11: goto statement_8205;
      case 12: goto statement_8206;
      case 13: goto statement_8206;
      case 14: goto statement_8208;
      case 15: goto statement_8209;
      case 16: goto statement_8207;
      default: break;
      }
    statement_8201:
      L = n5 + n8;
      if (0 < L && L <= cu.size()) ismout(icnt) = cu(L);
      else ismout(icnt) = 0;
      goto statement_8200;
    statement_8202:
      ismout(icnt) = d6;
      goto statement_8200;
    statement_8203:
      ismout(icnt) = d7;
      goto statement_8200;
    statement_8204:
      ismout(icnt) = d8;
      goto statement_8200;
    statement_8205:
      ismout(icnt) = q3;
      goto statement_8200;
    statement_8206:
      sf4 = a3 * elp(i26 + 21) + c1 + c2;
      sf5 = (a4 * elp(i26 + 21) + c3 + c4) * elp(i75 + 4);
      if (n5 == 13) {
        goto statement_8207;
      }
      ismout(icnt) = sqrtz(fem::pow2(sf4) + fem::pow2(sf5));
      goto statement_8200;
    statement_8207:
      ismout(icnt) = std::atan2(sf5, sf4);
      goto statement_8200;
    statement_8208:
      ismout(icnt) = cd;
      goto statement_8200;
    statement_8209:
      ismout(icnt) = cexc;
    statement_8200:;
    }
  statement_8215:
    n9 = ismdat(i30 + 18);
    if (n9 == 0) {
      goto statement_8225;
    }
    d9 = acb / cz;
    FEM_DO_SAFE(ka, 1, n9) {
      ipout += 3;
      icnt++;
      n5 = ismout(ipout) + iu;
      if (0 < n5 && n5 <= histq.size())
        ismout(icnt) = (histq(n5) - d9) * cmn.radeg;
      else ismout(icnt) = 0;
    }
  statement_8225:
    n9 = ismdat(i30 + 19);
    if (n9 == 0) {
      goto statement_8235;
    }
    d9 = omega / cz;
    n12 = iu + numask;
    FEM_DO_SAFE(ka, 1, n9) {
      ipout += 3;
      icnt++;
      n13 = ismout(ipout) + n12;
      if (0 < n13 && n13 <= histq.size())
        ismout(icnt) = histq(n13) - d9;
      else ismout(icnt) = 0;
    }
  statement_8235:
    n9 = ismdat(i30 + 20);
    if (n9 == 0) {
      goto statement_209;
    }
    jt = n22 + num2;
    FEM_DO_SAFE(ka, 1, n9) {
      icnt++;
      ipout += 3;
      n5 = ismout(ipout);
      mp = jt + n5;
      m = iu + n5;
      n5 = m + numask;
      if (0 < m && m < histq.size() && 0 < n5 && n5 < histq.size())
        ismout(icnt) = shp(mp + numask) * (histq(m) - histq(m + 1)) +
        shp(mp) * (histq(n5) - histq(n5 + 1));
      else ismout(icnt) = 0;
    }
    //C     PREDICT NEW ROTOR ANGLE AND SPEED. CALCULATE ALSO CONSTANT TERMS  M37.5422
    //C     FOR THE ITERATION LOOP IN THE NEXT TIME-STEP   * * * * * * * * * *M37.5423
  statement_209:
    s1 = 0.0f;
    iz = iu + 1;
    iy = ikv;
    izy = iy + num2;
    ik = n22 + num6;
    ib = ik;
    d11 = histq(iz);
    d12 = histq(iy + 1);
    if (numask == 1) {
      goto statement_211;
    }
    ik1 = ikv - 1;
    FEM_DO_SAFE(ka, iz, ik1) {
      iy++;
      izy++;
      ik += 4;
      d31 = histq(ka + 1);
      d32 = histq(iy + 1);
      d21 = shp(ik - 2);
      d22 = shp(ik);
      histq(izy) += shp(ik - 3) * d11 + shp(ik - 1) * d12 + d21 *
        d31 + d22 * d32 + s1;
      s1 = d21 * d11 + d22 * d12;
      d11 = d31;
      d12 = d32;
    }
    s1 += shp(ik + 1) * d11;
  statement_211:
    histq(izy + 1) += shp(ik + 3) * d12 + s1;
    kc = n22;
    ik = ikv;
    izy = iz + num2;
    FEM_DO_SAFE(ka, iz, ikv) {
      ik++;
      histq(izy) = histq(ka) + delta2 * histq(ik);
      kc++;
      d6 = shp(kc);
      shp(kc) = histq(ik);
      histq(ik) = histq(ik) * 2.0f - d6;
      izy++;
    }
    if (iprsup < 1) {
      goto statement_214;
    }
    ij = iu + 1;
    ik = iu + num6;
    {
      write_loop wloop(cmn, lunit6, "(2x,'HISTQ AT 213',2i8,/(1x,5e22.13))");
      wloop, ij, ik;
      FEM_DO_SAFE(ka, ij, ik) {
        wloop, histq(ka);
      }
    }
    //C     FINISH THE PREDICTION OF SPEED AND ANGLE   ********************** M37.5465
  statement_214:
    alpha = 9.0f * (cu(ikn + 21) - dang) + cu(ikn + 22) +
      cmn.delta6 * (d2 + cu(ikn + 23));
    cu(ikn + 22) = cu(ikn + 21);
    cu(ikn + 21) = dang;
    cu(ikn + 23) = d2;
    if (ismdat(i30 + 8) == 0) {
      goto statement_946;
    }
    //C     UPDATE THE SATURATION STATUS VARIABLES   *   *   *   *   *   *   *M32.6080
    sf4 = a3 * elp(i26 + 21) + c1 + c2;
    sf5 = (a4 * elp(i26 + 21) + c3 + c4) * elp(i75 + 4);
    sf4 = sqrtz(fem::pow2(sf4) + fem::pow2(sf5));
    if (elp(i26 + 22) >= sf4) {
      goto statement_938;
    }
    d9 = sf4 / elp(i26 + 22) - 0.9f;
    isd = 10.0f * d9;
    isd = (isd + 1) / 2;
    elp(i75 + 2) = 1.0f / (1.0f + elp(i26 + 23) * (sf4 - elp(i26 + 22)));
    goto statement_939;
  statement_938:
    isd = 0;
    elp(i75 + 2) = 1.0f;
  statement_939:
    if (elp(i26 + 24) >= sf4) {
      goto statement_941;
    }
    d9 = sf4 / elp(i26 + 24) - 0.9f;
    isq = 10.0f * d9;
    isq = (isq + 1) / 2;
    elp(i75 + 3) = 1.0f / (1.0f + elp(i26 + 25) * (sf4 - elp(i26 + 24)));
    goto statement_942;
  statement_941:
    isq = 0;
    elp(i75 + 3) = 1.0f;
  statement_942:
    if (isd == ismdat(i30 + 9) && isq == ismdat(i30 + 10)) {
      goto statement_944;
    }
    ismdat(i30 + 9) = isd;
    ismdat(i30 + 10) = isq;
    increm(cmn, ilk, sf4);
    cmn.ialter = 1;
    idsat++;
  statement_944:
    acde = elp(i75 + 2);
    acdf = elp(i75 + 3);
    //C     CALCULATE STATOR FLUX LINKAGES.  *   *   *   *   *   *   *   *   *M32.6106
  statement_946:
    ac1 = -ac1 * acdf - elp(i26 + 19) * a4;
    ac2 = ac2 * acde + elp(i26 + 19) * a3;
    //C     PREDICT FOR THE NEXT TIME-STEP THE NEW STATOR  CURRENTS********** M37.5492
    //C     ACUR1 = 2.0 * A3 - CU( IKN+7 )    !D-AXIS PREDICTED CURRENT       M37.5493
    //C     CU( IKN+7 ) = A3                                                  M37.5494
    //C     ACUR2 = 2.0 * A4 - CU( IKN+8 )    !Q-AXIS PREDICTED CURRENT       M38.3315
    acur2 = (2.5f * a4 - 1.5f * cu(ikn + 13) + cu(ikn + 8)) * onehaf;
    cu(ikn + 13) = cu(ikn + 8);
    cu(ikn + 8) = a4;
    //C     UPDATE THE FIELD VOLTAGE ( IF TACS CONTROLLED )****************** M37.5497
    q4 = cu(ikn + 10);
    jmset = ismdat(i30 + 15);
    if (jmset == 0) {
      goto statement_948;
    }
    ndx1 = kxtcs + jmset;
    cu(ikn + 11) = sptacs(ndx1);
    q4 = q4 * cu(ikn + 11);
    //C     CALCULATE HISTORY TERMS FOR THE ELECTRICAL PART  * * * * * * * * *M20.4645
  statement_948:
    acd = elp(i75 + 17) * a3 + elp(i75 + 18) * c1 + elp(i75 + 19) * c2;
    acd += (ac1 * d2 - cv1) * damrat;
    acq = elp(i75 + 20) * a4 + elp(i75 + 21) * c3 + elp(i75 + 22) * c4;
    acq += (ac2 * d2 - cv2) * damrat;
    x1(3) = elp(i26 + 18) * cu(ikn + 2) - cv3 * damrat;
    x1(4) = elp(i75 + 23) * a3 + elp(i75 + 24) * c1 + elp(i75 + 25) * c2;
    x1(5) = elp(i75 + 26) * a3 + elp(i75 + 27) * c1 + elp(i75 + 28) * c2;
    x1(6) = elp(i75 + 29) * a4 + elp(i75 + 30) * c3 + elp(i75 + 31) * c4;
    x1(7) = elp(i75 + 32) * a4 + elp(i75 + 33) * c3 + elp(i75 + 34) * c4;
    if (iprsup < 1) {
      goto statement_952;
    }
    {
      write_loop wloop(cmn, lunit6,
        "(2x,' AT 16 HISTORY TERMS MACH NO.',i5,/(2x,6e19.11))");
      wloop, ilk, acd, acq;
      FEM_DO_SAFE(itq, 3, 7) {
        wloop, x1(itq);
      }
    }
    write(lunit6, "(2x,' PREDICTED STATOR CURRENTS',2x,2e25.12)"), acur1, acur2;
  statement_952:
    x1(4) = x1(4) - (q3 * damrat + q4);
    //C     ACCOUNT FOR THE INFLUENCE OF  ROTOR CIRCUITS  *   *   *   *   *   M32.6148
    sf4 = -(elp(i75 + 43) * x1(4) + elp(i75 + 44) * x1(5));
    sf5 = -(elp(i75 + 45) * x1(6) + elp(i75 + 46) * x1(7));
    x1(1) = acd + sf4;
    x1(2) = acq + sf5;
    mover(x1(ll1), cu(ikn), ll7);
    //C     ADD CORRECTION TERMS( ACCOUNT FOR ASSYMETRY)     *****************M33.1680
    //C     SF4 = SF4 - AC( IL ) * ACUR1       !NO D-AXIS CORRECTION TERM     M38.3333
    sf5 = sf5 - elp(i75 + 52) * acur2;
    //C     PERFORM REMAINING OPERATIONS IN THE SYNCHRONOUS FRAME*************M36.1555
    a1 = cu(ikn + 18) - dang;
    a2 = sinz(a1);
    a1 = cosz(a1);
    c1 = a1 * ac2 + a2 * ac1;
    c2 = a2 * ac2 - a1 * ac1;
    //C     PREDICT SPEED VOLTAGES******************************************* M36.1561
    ac2 = (2.5f * c1 - 1.5f * cu(ikn + 14) + cu(ikn + 15)) * om2;
    ac1 = (2.5f * c2 - 1.5f * cu(ikn + 16) + cu(ikn + 17)) * om2;
    cu(ikn + 14) = cu(ikn + 15);
    cu(ikn + 15) = c1;
    cu(ikn + 16) = cu(ikn + 17);
    cu(ikn + 17) = c2;
    //C     CONVERT REMAINING VARIABLES TO SYNCHRONOUS FRAME******************M36.1566
    q3 = cosz(alpha);
    q4 = sinz(alpha);
    cu(ikn + 18) += cmn.omdt;
    cu(ikn + 19) = q3;
    cu(ikn + 20) = q4;
    a5 = cu(ikn + 18);
    c1 = cosz(a5);
    c2 = sinz(a5);
    a3 = c1 * q3 + c2 * q4;
    a4 = c2 * q3 - c1 * q4;
    q3 = a3 * sf4 - a4 * sf5;
    q4 = a4 * sf4 + a3 * sf5;
    //C     CONVERT  VOLTAGE SOURCES TO CURRENT SOURCES  * * * * * * * * * * *M20.4683
    a3 = (a1 * acd - a2 * acq - ac1 + q3) * elp(i75 + 53);
    a4 = (a2 * acd + a1 * acq + ac2 + q4) * elp(i75 + 53);
    a5 = x1(3) * elp(i75 + 54);
    //C     CONVERT SYNCHRONOUS VARIABLES TO PHASE COORDINATES  **************M36.1582
    cik(juk) = -a3 * c1 - a4 * c2 - a5;
    a1 = -c1 * onehaf;
    a2 = c2 * sqrt32;
    etot = a1 + a2;
    sum = a1 - a2;
    a1 = -c2 * onehaf;
    a2 = c1 * sqrt32;
    c3 = a1 - a2;
    c4 = a1 + a2;
    cik(juk + 1) = -etot * a3 - c3 * a4 - a5;
    cik(juk + 2) = -sum * a3 - c4 * a4 - a5;
    ibr += 3;
    if (iprsup > 0) {
      {
        write_loop wloop(cmn, lunit6, "(10x,e20.12,4x,3e20.12)");
        wloop, alpha;
        FEM_DO_SAFE(ip, juk, ibr) {
          wloop, cik(ip);
        }
      }
    }
    a1 = elp(i75);
    a2 = elp(i75 + 1);
    if (idelta == 0) {
      goto statement_897;
    }
    a11 = (a1 - a2) / 3.0f;
    a1 = a11 + a11;
    a2 = -a11;
  statement_897:
    ap1 += a1;
    ap2 += a2;
    //C     END  OF  UPDATING  PROCEDURE * * *** * * * * * * * * * * * * * * *M20.4716
    ib += num4;
    iu = ikp + num4;
    ikn += nwd;
    i26 += 101;
    i30 += 30;
    im = im - 1;
    if (im > 0) {
      goto statement_800;
    }
    if (idsat == 0) {
      goto statement_899;
    }
    //C     UPDATE THE APPROPRIATE ELEMENTS OF THE MATRIX (YKM)  *************M32.6151
    ies = j75 + 54;
    ifs = j30 + 20;
    n1 = ismdat(ifs + 1);
    ykm(n1) = elp(ies + 1) + ap1;
    n1 = ismdat(ifs + 4);
    ykm(n1) = elp(ies + 4) + ap2;
    n1 = ismdat(ifs + 7);
    ykm(n1) = elp(ies + 7) + ap2;
    n1 = ismdat(ifs + 2);
    ykm(n1) = elp(ies + 2) + ap2;
    n1 = ismdat(ifs + 5);
    ykm(n1) = elp(ies + 5) + ap1;
    n1 = ismdat(ifs + 8);
    ykm(n1) = elp(ies + 8) + ap2;
    n1 = ismdat(ifs + 3);
    ykm(n1) = elp(ies + 3) + ap2;
    n1 = ismdat(ifs + 6);
    ykm(n1) = elp(ies + 6) + ap2;
    n1 = ismdat(ifs + 9);
    ykm(n1) = elp(ies + 9) + ap1;
  statement_899:
    j75 += 101;
    j30 += 30;
  }
  cmn.nexmod = 0;
  ll3 = 3;
  move0(ksmspy, ll3);
  if (iprsup > 0) {
    write(lunit6, "('  \"EXIT  MODULE UPDATE.\"')");
  }
}

struct yserlc_save
{
  double ccon;
  int ixcopt;
  double xcon;

  yserlc_save() :
    ccon(fem::double0),
    ixcopt(fem::int0),
    xcon(fem::double0)
  {}
};

void frefp3(
  common& cmn,
  str_ref ansi,
  double& d12,
  double& d13,
  double& d14)
{
  common_read read(cmn);
  //C     UNIVERSAL MODULE (WORKS FOR ANY COMPUTER) USED ONLY FOR THE       M35.4281
  //C     INTERACTIVE EMTP ("EMTSPY").  IT IS CALLED TO DECODE THREE        M35.4282
  //C     FLOATING POINT NUMBERS D12,D13,D14 FROM CHARACTER*80 ANSI.        M35.4283
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4284
  int n8 = 3;
  frefix(cmn, ansi, n8);
  read(ansi, "(3e20.0)"), d12, d13, d14;
}


void yserlc(
  common& cmn)
{
  FEM_CMN_SVE(yserlc);
  common_read read(cmn);
  common_write write(cmn);
  double& epsiln = cmn.epsiln;
  auto& twopi = cmn.twopi;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  int& kpartb = cmn.kpartb;
  int& ialter = cmn.ialter;
  int& iprsup = cmn.iprsup;
  auto& x = static_cast<common_c0b001&>(cmn).x;
  auto& ykm = cmn.ykm;
  const auto& km = cmn.km;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& r = static_cast<common_c0b064&>(cmn).r;
  auto& nr = cmn.nr;
  auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  auto& ck = cmn.ck;
  const auto& kks = cmn.kks;
  const auto& litype = cmn.litype;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  int& lserlc = cmn.lserlc;
  int& kserlc = cmn.kserlc;
  fem::str<80>& buff77 = cmn.buff77;
  //
  double& ccon = sve.ccon;
  int& ixcopt = sve.ixcopt;
  double& xcon = sve.xcon;
  if (is_called_first_time) {
    ixcopt = 0;
    xcon = 0.0f;
    ccon = 0.0f;
  }
  auto& lunit6 = cmn.lunit6;
  int j = fem::int0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  int n1 = fem::int0;
  double d23 = fem::double0;
  double d44 = fem::double0;
  double gus1 = fem::double0;
  double d33 = fem::double0;
  double gus2 = fem::double0;
  int n8 = fem::int0;
  int n9 = fem::int0;
  int n3 = fem::int0;
  int n4 = fem::int0;
  int n2 = fem::int0;
  //C     MODULE OF INTERACTIVE EMTP ONLY, ASSOCIATED WITH "EMTSPY".        M36.1486
  //C     NON-INTERACTIVE VERSIONS CAN REPLACE BY A DUMMY MODULE.           M36.1487
  //C     THIS MODULE IS CALLED ONLY BY "SUBTS1" OF OVERLAY 16.             M36.1488
  //C     BURROUGHS: PRESERVE LOCAL VARIABLE BETWEEN MODULE CALLS:          M36.1489
  if (iprsup >= 4) {
    write(lunit6,
      "(' TOP OF \"YSERLC\".  LSERLC, KSERLC KPARTB, IALTER =',4i8)"),
      lserlc, kserlc, kpartb, ialter;
  }
  if (lserlc <= 0) {
    goto statement_9000;
  }
  if (kserlc <= 0) {
    goto statement_9000;
  }
  if (ixcopt > 0) {
    goto statement_3000;
  }
  ccon = 1.0f / (cmn.deltat * 500000.f);
  xcon = ccon * 1000.f;
  if (xopt > 0.0f) {
    xcon = xcon * 1000.0f / (twopi * xopt);
  }
  if (copt > 0.0f) {
    ccon = ccon / (twopi * copt);
  }
  ixcopt = 1;
statement_3000:
  FEM_DO_SAFE(j, 1, lserlc) {
    ndx1 = cmn.ibr + j;
    if (kbus(ndx1) == 0) {
      goto statement_8276;
    }
    if (nr(ndx1) == 0) {
      goto statement_8276;
    }
    nr(ndx1) = 0;
    ndx2 = cmn.it + j;
    n1 = litype(ndx1);
    n1 = nr(n1);
    n1 = fem::iabs(n1);
    d23 = 1.0f / x(n1);
    d44 = tr(ndx2) + xcon * tx(ndx2);
    gus1 = c(ndx2);
    if (gus1 != 0.0f) {
      gus1 = 1.0f / (gus1 * ccon);
    }
    d33 = d44 + gus1;
    if (d33 >= epsiln * d23 * 10.f) {
      goto statement_8253;
    }
    write(cmn.munit6,
      "('  ZERO-DIVIDE TROUBLE.  EPSILN FAILURE.',/,'  J, D33, D23, EPSILN =',"
      "i8,3e15.6,/,'  SEND REVISED DESIRED R,X,C-VALUES :')"),
      j, d33, d23, epsiln;
    read(cmn.munit5, "(a80)"), buff77;
    frefp3(cmn, buff77, tr(ndx2), tx(ndx2), c(ndx2));
    d44 = tr(ndx2) + xcon * tx(ndx2);
    gus1 = c(ndx2);
    if (gus1 != 0.0f) {
      gus1 = 1.0f / (gus1 * ccon);
    }
    d33 = d44 + gus1;
  statement_8253:
    d23 = 1.0f / d33 - x(n1);
    ci(ndx1) = tr(ndx2);
    ck(ndx1) = tx(ndx2);
    cik(ndx1) = c(ndx2);
    x(n1) = d44;
    gus2 = 1.0f / d33;
    r(n1) = gus2 * (ci(ndx1) * 2.0f - x(n1) + gus1);
    x(n1) = gus2;
    c(n1) = gus1;
    if (kbus(ndx1) < mbus(ndx1)) {
      goto statement_4107;
    }
    n8 = mbus(ndx1);
    n9 = kbus(ndx1);
    goto statement_4114;
  statement_4107:
    n8 = kbus(ndx1);
    n9 = mbus(ndx1);
  statement_4114:
    if (iprsup >= 3) {
      write(lunit6,
        "(' NEXT [Y] CHANGE.  J, N8, N9, D23 =',3i8,e14.5)"), j, n8,
        n9, d23;
    }
    if (n8 == 1) {
      goto statement_5231;
    }
    if (n8 > kpartb) {
      goto statement_8276;
    }
    n3 = kks(n8);
  statement_5217:
    n3 = n3 - 1;
    n4 = fem::iabs(km(n3));
    if (n4 != n8) {
      goto statement_5224;
    }
    ykm(n3) += d23;
    goto statement_5217;
  statement_5224:
    if (n4 != n9) {
      goto statement_5217;
    }
    ykm(n3) = ykm(n3) - d23;
    goto statement_5238;
  statement_5231:
    if (n9 > kpartb) {
      goto statement_8276;
    }
  statement_5238:
    if (n9 > kpartb) {
      goto statement_5252;
    }
    n1 = kks(n9);
  statement_5244:
    n1 = n1 - 1;
    n2 = fem::iabs(km(n1));
    if (n2 != n9) {
      goto statement_5247;
    }
    ykm(n1) += d23;
    goto statement_5252;
  statement_5247:
    if (n2 != n8) {
      goto statement_5244;
    }
    ykm(n1) = ykm(n1) - d23;
    goto statement_5244;
  statement_5252:
    if (ialter == 0) {
      ialter = 1;
    }
  statement_8276:;
  }
statement_9000:;
}

void lineqs(
  arr_cref<double, 2> aum,
  arr_ref<double> yum)
{
  aum(dimension(3, 3));
  yum(dimension(15));
  int n5 = fem::int0;
  int n6 = fem::int0;
  int n10 = fem::int0;
  int n11 = fem::int0;
  arr_2d<3, 4, double> bum(fem::fill0);
  int n1 = fem::int0;
  int n2 = fem::int0;
  int n8 = fem::int0;
  int n9 = fem::int0;
  int n7 = fem::int0;
  int n12 = fem::int0;
  int n13 = fem::int0;
  n5 = 3;
  n6 = n5 + 1;
  //C FORMATION OF AUGMENTED MATRIX                                         M27.2530
  FEM_DO_SAFE(n10, 1, n5) {
    FEM_DO_SAFE(n11, 1, n5) {
      bum(n10, n11) = aum(n10, n11);
    }
    bum(n10, n6) = yum(n10);
  }
  //C START GAUSSIAN ELIMINATION                                            M27.2536
  FEM_DO_SAFE(n1, 1, n5) {
    n2 = n1 + 1;
    if (n2 > n5) {
      goto statement_50;
    }
    FEM_DO_SAFE(n10, n2, n5) {
      n8 = n6 - n1;
      FEM_DO_SAFE(n9, 1, n8) {
        n11 = n6 + 1 - n9;
        bum(n10, n11) = bum(n10, n11) - bum(n10, n1) * bum(n1, n11) / bum(n1,
          n1);
      }
      n11 = n6 - n8;
      bum(n10, n11) = 0.0f;
    }
  }
  //C CALCULATION OF SOLUTION                                               M27.2548
statement_50:
  FEM_DO_SAFE(n10, 1, n5) {
    n7 = n5 + 1 - n10;
    yum(n7) = bum(n7, n6) / bum(n7, n7);
    FEM_DO_SAFE(n12, 1, n5) {
      n13 = n7 + n12;
      if (n13 > n5) {
        goto statement_70;
      }
      yum(n7) = yum(n7) - bum(n7, n13) * yum(n13) / bum(n7, n7);
    statement_70:;
    }
  }
}


void solvum(
  common& cmn,
  arr_ref<double> reacl,
  arr_cref<double> gpar,
  arr_ref<double> fpar,
  arr_ref<double> hist,
  arr_ref<double> umcurp,
  arr_cref<int> nodvo1,
  arr_cref<int> nodvo2,
  arr_cref<int> jcltac,
  arr_cref<int> jclout,
  arr_ref<int> jtype,
  arr_cref<int> nodom,
  arr_cref<int> jtmtac,
  arr_ref<double> histom,
  arr_ref<double> omegm,
  arr_ref<double> omold,
  arr_ref<double> thetam,
  arr_cref<double> reamdu,
  arr_cref<double> reamds,
  arr_cref<double> flxds,
  arr_ref<double> flxdr,
  arr_ref<double> reamqu,
  arr_ref<double> flxqs,
  arr_ref<double> flxqr,
  arr_cref<int> jcdsat,
  arr_cref<int> jcqsat,
  arr_ref<double> flxd,
  arr_ref<double> flxq,
  arr_cref<int> nppair,
  arr_cref<double> rotmom,
  arr_cref<int> ncld,
  arr_cref<int> nclq,
  arr_cref<int> jtqout,
  arr_cref<int> jomout,
  arr_cref<int> jthout,
  arr_ref<double> reamqs,
  arr_cref<double> epsom,
  arr_cref<double> dcoef,
  arr_cref<int> kcoil,
  arr_ref<double> voltum,
  arr_ref<double> anglum,
  arr_cref<int> /* nodfum */,
  arr_cref<int> /* nodmum */,
  arr_cref<int> /* kumout */,
  arr_cref<int> /* jumout */,
  arr_ref<double> umoutp)
{
  reacl(dimension(1));
  gpar(dimension(1));
  fpar(dimension(1));
  hist(dimension(1));
  umcurp(dimension(1));
  nodvo1(dimension(1));
  nodvo2(dimension(1));
  jcltac(dimension(1));
  jclout(dimension(1));
  jtype(dimension(1));
  nodom(dimension(1));
  jtmtac(dimension(1));
  histom(dimension(1));
  omegm(dimension(1));
  omold(dimension(1));
  thetam(dimension(1));
  reamdu(dimension(1));
  reamds(dimension(1));
  flxds(dimension(1));
  flxdr(dimension(1));
  reamqu(dimension(1));
  flxqs(dimension(1));
  flxqr(dimension(1));
  jcdsat(dimension(1));
  jcqsat(dimension(1));
  flxd(dimension(1));
  flxq(dimension(1));
  nppair(dimension(1));
  rotmom(dimension(1));
  ncld(dimension(1));
  nclq(dimension(1));
  jtqout(dimension(1));
  jomout(dimension(1));
  jthout(dimension(1));
  reamqs(dimension(1));
  epsom(dimension(1));
  dcoef(dimension(1));
  kcoil(dimension(1));
  voltum(dimension(1));
  anglum(dimension(1));
  umoutp(dimension(1));
  common_write write(cmn);
  double& deltat = cmn.deltat;
  double& t = cmn.t;
  auto& twopi = cmn.twopi;
  int& iout = cmn.iout;
  int& numum = cmn.numum;
  int& numout = cmn.numout;
  int& iprsup = cmn.iprsup;
  int& ntot = cmn.ntot;
  auto& loopss = cmn.loopss;
  const auto& sptacs = cmn.sptacs;
  auto& cursub = cmn.cursub;
  const auto& znonl = cmn.znonl;
  const auto& isubeg = cmn.isubeg;
  auto& crest = cmn.crest;
  const auto& tclose = cmn.tclose;
  auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  auto& etac = cmn.etac;
  auto& ptheta = cmn.ptheta;
  auto& zthevr = cmn.zthevr;
  auto& vinp = cmn.vinp;
  auto& zthevs = cmn.zthevs;
  auto& umcur = cmn.umcur;
  auto& con = cmn.con;
  auto& dumvec = cmn.dumvec;
  auto& dummat = cmn.dummat;
  auto& pi = cmn.pi;
  double& sroot2 = cmn.sroot2;
  double& sroot3 = cmn.sroot3;
  double& omegrf = cmn.omegrf;
  int& inpu = cmn.inpu;
  int& ncltot = cmn.ncltot;
  auto& ndum = cmn.ndum;
  int& initum = cmn.initum;
  int& istart = cmn.istart;
  //
  auto& lunit6 = cmn.lunit6;
  int n1 = fem::int0;
  int n5 = fem::int0;
  double d1 = fem::double0;
  int jm = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  int n8 = fem::int0;
  int kswsta = fem::int0;
  double d5 = fem::double0;
  int n15 = fem::int0;
  int n19 = fem::int0;
  int n12 = fem::int0;
  int n18 = fem::int0;
  int n11 = fem::int0;
  int n20 = fem::int0;
  int n14 = fem::int0;
  double d3 = fem::double0;
  int n2 = fem::int0;
  int n10 = fem::int0;
  int nclcom = fem::int0;
  double seltat = fem::double0;
  int nxout = fem::int0;
  int mshare = fem::int0;
  double tau = fem::double0;
  int n3 = fem::int0;
  int n4 = fem::int0;
  double d4 = fem::double0;
  int ncurpr = fem::int0;
  double flxdmh = fem::double0;
  double flxqmh = fem::double0;
  int kcl = fem::int0;
  int ntyp59 = fem::int0;
  int inpust = fem::int0;
  int nmexc = fem::int0;
  int kconex = fem::int0;
  int nexc = fem::int0;
  double selta2 = fem::double0;
  double rppair = fem::double0;
  double flxdrr = fem::double0;
  double flxqrr = fem::double0;
  double flxda = fem::double0;
  double flxqa = fem::double0;
  int n9 = fem::int0;
  int kcld1 = fem::int0;
  int kclde = fem::int0;
  int kclq1 = fem::int0;
  int kclqe = fem::int0;
  int kcle = fem::int0;
  int ncl = fem::int0;
  double zthev = fem::double0;
  arr_2d<3, 3, double> zths3(fem::fill0);
  double rd2 = fem::double0;
  double d2 = fem::double0;
  double betaq = fem::double0;
  double betad1 = fem::double0;
  int nshare = fem::int0;
  double zthevm = fem::double0;
  double omthev = fem::double0;
  double zthem2 = fem::double0;
  double zthem3 = fem::double0;
  double tqgen2 = fem::double0;
  double tqgen3 = fem::double0;
  int n13 = fem::int0;
  double tumtac = fem::double0;
  double thetae = fem::double0;
  double omege = fem::double0;
  double curum1 = fem::double0;
  double curum2 = fem::double0;
  double curum3 = fem::double0;
  arr_2d<3, 3, double> zmat(fem::fill0);
  double omegmp = fem::double0;
  double theold = fem::double0;
  int nitrom = fem::int0;
  arr_2d<3, 3, double> smat(fem::fill0);
  double d10 = fem::double0;
  double d15 = fem::double0;
  double curmd = fem::double0;
  double curmq = fem::double0;
  double curmt = fem::double0;
  double d19 = fem::double0;
  double d20 = fem::double0;
  double d18 = fem::double0;
  double d11 = fem::double0;
  double d12 = fem::double0;
  double d16 = fem::double0;
  double d17 = fem::double0;
  int jacob = fem::int0;
  double fjd = fem::double0;
  double fjq = fem::double0;
  double fjdd = fem::double0;
  double fjqd = fem::double0;
  double fjdq = fem::double0;
  double fjqq = fem::double0;
  double sflxd = fem::double0;
  double sflxq = fem::double0;
  double d13 = fem::double0;
  double d6 = fem::double0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  double d9 = fem::double0;
  int n16 = fem::int0;
  double tqgen = fem::double0;
  double tdamp = fem::double0;
  double tcin = fem::double0;
  double tangle = fem::double0;
  int noutst = fem::int0;
  int itol = fem::int0;
  int itolto = fem::int0;
  double flxdd = fem::double0;
  double flxqq = fem::double0;
  double flxddp = fem::double0;
  double flxqqp = fem::double0;
  static const char* format_16005 =
    "('0-------------------------------------------------')";
  static const char* format_6589 =
    "(' N1, N2, NXOUT, JCLOUT(N2), UMCUR(N1)',' UMOUTP(NXOUT) =',4i8,2e14.5)";
  static const char* format_7250 =
    "(/,' NUMOUT =',i4,10x,'NUMOUT+NSMTAC+3 =',i4)";
  static const char* format_7252 =
    "(' TACS INTERFACE REQUESTED FOR SM-59 DATA INPUT',"
    "'. THE UM OUTPUT TABLE UMOUTP(NUMOUT+NSMTAC+3) :',/,6(6x,e14.5),/(6(6x,"
    "e14.5)))";
  //C   JCLTAC(KCL AND KCL+1) ARE INITIALIZED IN "UMRENU"                   M39.3076
  //C   JCLTAC(KCL+2) IS INITIALIZED IN "UMINIT".                           M39.3077
  //C   AT EVERY TIME-STEP T SOLVUM MAY BE CALLED THREE TIMES (AT           M33.1901
  //C   TIME = 0.0 THERE IS AN ADDITIONAL CALL IN OVER16 TO                 M33.1902
  //C   CALCULATE UM HISTORY ARRAYS AND PREDICT VALUES OF THE               M33.1903
  //C   UM POWER CURRENTS IF CASE OF NO COMPENSATION).                      M33.1904
  //C   THE SEQUENCE TO THESE CALLS AT A CERTAIN TIME T IS AS :             M33.1905
  //C   * CALL 1 : SOLVUM TIME-STEP CALCULATIONS (CALL IN SUBTS4).          M33.1906
  //C        INPUT CONDITION : IF NO TCLOSE READING, LOOPSS(1)=7766         M34. 162
  //C                          IF TCLOSE READING , LOOPSS(1) = 6644         M34. 163
  //C                          IF NO POWER COMP,  LOOPSS(8)=1               M33.1908
  //C        AT COMPLETION : IF TCLOSE READING, LOOPSS(1)=6644              M33.1909
  //C                        IF NO POWER COMP,  LOOPSS(8)=3                 M34. 164
  //C             NOTE : AT T=0.0, CALL TO TCLOSE READING IS SKIPPED        M33.1913
  //C             AND AT COMPLETION : LOOPSS(1)=7766, LOOPSS(8)=3           M36.1594
  //C   * CALL 2 : IF TACS TRANSFER WITH SM TYPE-59 DATA IS DESIRED,        M33.1915
  //C              THEN THE SWITCH CURRENT IS TO BE READ FROM TCLOSE        M33.1916
  //C              (CALL IS IN SUBTS1, FIRST CALL TO SOLVUM)                M33.1917
  //C        INPUT CONDITION : LOOPSS(1)=6644                               M33.1918
  //C        AT COMPLETION : LOOPSS(1)=7766                                 M33.1919
  //C   * CALL 3 : IF THE POWER CIRCUITS OF ALL UM IS REQUESTED TO          M33.1921
  //C              BE NON-COMPENSATED (TO FACILITATE MULTI-MACH).           M33.1922
  //C              THIS CALL IS TO INJECT THE F-ARRAY WITH THE              M33.1923
  //C              PREDICTED UM POWER VOLTAGES FOR CALCULATIONS OF          M36.1595
  //C              NEXT TIME-STEP.                                          M33.1925
  //C              (CALL IS IN SUBTS1, SECOND CALL TO SOLVUM)               M33.1926
  //C        INPUT CONDITION : LOOPSS(8)=3                                  M33.1927
  //C        AT COMPLETION : LOOPSS(1) UNCHANGED                            M33.1928
  //C                        LOOPSS(8)=1                                    M33.1929
  //C   NOW WE ARE READY FOR THE NEXT CALL 1.                               M33.1930
  //C     INTRINSIC  COSZ, SINZ, SQRTZ                                      M32.6285
  if (iprsup >= 1) {
    write(lunit6,
      "('  \"BEGIN MODULE SOLVUM.\"',8x,'KCONST =',i4,8x,'IBR =',i4)"),
      cmn.kconst, cmn.ibr;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' TOP OF  \"SOLVUM\" .',"
      "'  ISTART LOOPSS1 LOOPSS8  NCLTOT   NUMUM  NUMOUT',13x,'T',/,19x,6i8,"
      "e14.5)"),
      istart, loopss(1), loopss(8), ncltot, numum, numout, t;
  }
  if (iprsup >= 1 && istart == 0) {
    {
      write_loop wloop(cmn, lunit6, "(/,' HIST(1:NCLTOT) ='(1x,6e14.5))");
      FEM_DO_SAFE(n1, 1, ncltot) {
        wloop, hist(n1);
      }
    }
  }
  //C.  MASS ANGLE AND SPEED HISTORY FOR TYPE-59 DATA INPUT *******         M32.6289
  if (istart > 0) {
    goto statement_17040;
  }
  if (cmn.nsmach == 0) {
    goto statement_70;
  }
  if (umoutp(numout + 1) != -9999.0f) {
    goto statement_70;
  }
  n5 = umoutp(numout + 3);
  if (iprsup >= 1) {
    write(lunit6, format_7250), numout, n5;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, format_7252);
      FEM_DO_SAFE(n1, 1, n5) {
        wloop, umoutp(n1);
      }
    }
  }
  d1 = umoutp(numout + 2);
  if (d1 == 0.0f) {
    goto statement_17042;
  }
  jm = 0;
  //C  JM IS COUNTER OF MACHINES WITH SM TYPE-50 DATA INPUT                 M32.6296
  n5 = numout + 4;
  //C   N5 IS FIRST ENTRY OF UMOUTP USED FOR TACS TRANSFER PURPOSE          M32.6298
  n6 = umoutp(numout + 3) - 2;
  //C   UMOUTP(NUMOUT+3) IS LAST ENTRY OF UMOUTP USED FOR TACS TRANSF       M32.6300
  n6 = n6 - 2;
statement_17000:
  if (n5 > n6) {
    goto statement_17042;
  }
  if (umoutp(n5) <= -300.0f) {
    goto statement_17010;
  }
  n5++;
  goto statement_17000;
statement_17010:
  jm++;
  n7 = umoutp(n5 + 4);
  //C  N7 IS TOTAL NR OF MASSES FOR MACHINE JM                              M32.6308
  n8 = umoutp(n5 + 3);
  //C  N8 IS TOTAL NR OF UMOUTP ENTRIES NEEDED FOR MASS HISTORY             M32.6310
  //C    CALCULATIONS OF MACHINE JM.                                        M32.6311
  kswsta = -umoutp(n5) - 300;
  d5 = thetam(jm) + twopi / (4.0f * nppair(jm));
  //C  HISTORY OF MASS NR 1 OF MACHINE JM :                                 M32.6314
  umoutp(n5 + 3) = 0.0f;
  if (n7 == 1) {
    umoutp(n5 + 3) = d5;
  }
  umoutp(n5 + 4) = e(n5 + 1);
  if (n7 == 1) {
    goto statement_17034;
  }
  //C  HISTORY OF MASS NR 2 AND HIGHER FOR MACHINE JM :                     M32.6319
  FEM_DO_SAFE(n15, 2, n7) {
    n19 = n5 + (n15 - 1) * 5;
    //C  N19 IS A POINTER TO UMOUTP FOR MASS NR N15                           M32.6322
    n12 = umoutp(n19 + 1);
    //C  N12 IS NODE NR OF MASS NR N15                                        M32.6324
    n18 = n5 + (n15 - 2) * 5;
    //C  N18 IS A POINTER TO UMOUTP FOR MASS NR (N15-1)                       M32.6326
    n11 = umoutp(n18 + 1);
    //C  N11 IS NODE NR OF MASS NR (N15-1)                                    M32.6328
    n20 = kswsta + n15 - 1;
    //C  N20 IS SWITCH NR OF SWITCH FROM MASS NR (N15-1) TO (N15)             M32.6330
    //C  UMOUTP(N19+3) WAS LMUT OF MASS NR (N15-1) AND (N15)                  M32.6331
    //C  UMOUTP(N19+4) WAS LMUT/RMUT OF MASS NR (N15-1) AND (N15)             M32.6332
    umoutp(n19 + 3) = umoutp(n18 + 3) + umoutp(n19 + 3) * tclose(n20);
    d1 = e(n11) - e(n12);
    umoutp(n19 + 3) += umoutp(n19 + 4) * d1;
    //C  NOW UMOUTP(N19+3) HAS BEEN SET TO HISTORY OF MASS ANGLE.             M32.6336
    if (n12 != nodom(jm)) {
      goto statement_17015;
    }
    n14 = n15;
    d3 = umoutp(n19 + 3) - d5;
    //C  N14 IS THE GENERATOR MASS OF MACHINE JM :                            M32.6340
  statement_17015:
    umoutp(n19 + 4) = e(n12);
    //C  NOW UMOUTP(N19+4) HAS BEEN SET TO HISTORY OF MASS SPEED.             M32.6342
  }
  //C  SHIFT OF ANGLES TO HAVE GEN ANGLE = D5 = THETAM(JM)+TWOPI/NPPAIR:    M32.6344
  FEM_DO_SAFE(n15, 1, n7) {
    n19 = n5 + (n15 - 1) * 5;
    umoutp(n19 + 3) = umoutp(n19 + 3) - d3;
    if (n15 == n14) {
      umoutp(n19 + 3) = d5;
    }
  }
statement_17034:
  n5 += n8;
  goto statement_17000;
  //C. TACS TRANSFER IN CASE OF SM TYPE-59 DATA INPUT**************         M32.6352
statement_17040:
  if (loopss(1) != 6644) {
    goto statement_70;
  }
  //C  LOOPSS(1) = 6644, MEANS THAT ONE OF THE UM HAS SM TYPE-59            M32.6354
  //C    DATA INPUT (INTELLIGENCE IN MACH DO LOOP) AND THAT SOLVUM          M32.6355
  //C    HAS TO BE CALLED FOR THE SECOND TIME AT EACH TIME STEP             M32.6356
  //C    TO PROCESS THE SWITCH CURRENTS FOR PASSING TORQUES, FIELD          M32.6357
  //C    VARIABLES AND MASS SPEEDS AND ANGLES TO TACS                       M32.6358
  loopss(1) = 7766;
  n1 = umoutp(numout + 3);
  if (iprsup >= 1) {
    write(lunit6, format_7250), numout, n1;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, format_7252);
      FEM_DO_SAFE(n2, 1, n1) {
        wloop, umoutp(n2);
      }
    }
  }
  //C  N5 IS FIRST ENTRY OF UMOUTP USED FOR TACS TRANSFER REQUEST:          M32.6360
statement_17042:
  n5 = numout + 4;
  //C  UMOUTP(NUMOUT+3) IS LAST ENTRY OF UMOUTP USED FOR TACS TRANSF        M32.6362
  n6 = umoutp(numout + 3) - 2;
statement_17050:
  if (istart != 0) {
    goto statement_17060;
  }
  if (n5 > n6) {
    goto statement_70;
  }
  goto statement_17070;
statement_17060:
  if (n5 > n6) {
    goto statement_21000;
  }
statement_17070:
  n7 = umoutp(n5 + 1);
  //C  N7 IS THE NODE NR OR THE SWITCH NR                                   M32.6369
  n8 = umoutp(n5 + 2);
  //C  N8 IS THE ENTRY OF THE TACS TABLE ETAC                               M32.6371
  n10 = umoutp(n5);
  //C  N10 IS THE CODE TYPE FOR THE VARIABLES TO BE TRANSFERED              M32.6373
  //C  TRANSFER OF SHAFT TORQUES :                                          M32.6374
  if (n10 != -1) {
    goto statement_17100;
  }
  etac(n8) = -tclose(n7);
  n5 += 3;
  goto statement_17050;
  //C  TRANSFER OF MASS SPEEDS :                                            M32.6379
statement_17100:
  if (n10 != -2) {
    goto statement_17110;
  }
  etac(n8) = e(n7);
  n5 += 3;
  goto statement_17050;
  //C  TRANSFER OF MASS ANGLES :                                            M32.6384
statement_17110:
  if (n10 <= -300) {
    goto statement_17112;
  }
  if (n10 != -3) {
    goto statement_17116;
  }
statement_17112:
  if (n8 != 0) {
    goto statement_17114;
  }
  n5 += 5;
  goto statement_17050;
statement_17114:
  d1 = deltat / 2.0f;
  etac(n8) = umoutp(n5 + 3) + (umoutp(n5 + 4) * e(n7)) * d1;
  umoutp(n5 + 3) = etac(n8);
  umoutp(n5 + 4) = d1 * e(n7);
  n5 += 5;
  goto statement_17050;
statement_17116:
  if (n10 != -299) {
    goto statement_17120;
  }
  n5 += 5;
  goto statement_17050;
  //C  TRANSFER OF EXCITER CURRENT                                          M32.6399
statement_17120:
  if (n10 != -4) {
    goto statement_17130;
  }
  etac(n8) = -tclose(n7);
  n5 += 3;
  goto statement_17050;
  //C  TRANSFER OF EXCITER VOLTAGE                                          M32.6404
statement_17130:
  if (n10 != -5) {
    goto statement_17140;
  }
  etac(n8) = e(n7);
  n5 += 3;
  goto statement_17050;
statement_17140:
  write(lunit6,
    "(/,' ERROR STOP.   SOMETHING WRONG WITH',"
    "' SM TYPE-59 TRANSFER TO TACS. CONSULT',/,' EMTP MANAGEMENT.')");
  stoptp(cmn);
  //C.DYNAMIC (START OF TIME-STEP LOOP) ****************************        M28.5595
statement_70:
  if (loopss(8) == 3) {
    goto statement_1000;
  }
  //C     LOOPSS(8) = 3, MEANS THAT F-ARRAY IS TO BE INJECTED               M33.1932
  //C       IN SUBTS1 IN CASE OF NO COMPENSATION FOR POWER CIRCUITS.        M33.1933
  //C. INTIALIZATION OF FIRST ELEMENT OF CURSUB, I.E. FIRST                 M28.5596
  //C  USED COIL OF FIRST USED MACHINE.                                     M28.5597
  nclcom = isubeg(cmn.ksubum);
  //C. PROGRAM STOP IF SPEED CONVERGENCE FAILED IN PREVIOUS                 M28.5604
  //C. TIME STEP.                                                           M28.5605
statement_79:
  if (inpu != 50) {
    goto statement_90;
  }
  write(lunit6,
    "('0PROGRAM STOP BECAUSE OF UM NONCONVERGENCE.',"
    "'  POSSIBLE REASONS ARE :')");
  write(lunit6, "(' * TIME STEP TOO HIGH')");
  write(lunit6, "(' * CONVERGENCE MARGIN EPSOM TOO LOW')");
  write(lunit6, "(' * ERROR IN UM DATA INPUT')");
  stoptp(cmn);
statement_90:
  seltat = deltat;
  //C. START OF FIRST MACHINE DO-LOOP:                                      M39.3078
statement_1000:
  nxout = 0;
  mshare = 0;
  FEM_DO_SAFE(jm, 1, numum) {
    //C  ADJUSTING OMEGRF TO ROTMOM(JM) IF MECH NETWORK OPTION USED:          M37.6081
    omegrf = twopi * cmn.statfr;
    if (jtmtac(jm) != 0) {
      goto statement_1004;
    }
    omegrf = rotmom(jm);
  statement_1004:
    tau = omegrf * t;
    //C  INJECTION OF PREDICTED UM POWER CURRENT TO F ARRAY IN SUBTS1.        M33.1945
    if (loopss(8) != 3) {
      goto statement_1100;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' ***************************************',"
        "' INJECTION OF PREDICTED POWER-COIL CURRENTS',' FOR UM NUMBER',i4,"
        "' :',/,' ***************************************',2x,'NODVO1',5x,"
        "'F(NODVO1)',2x,'NODVO2',5x,'F(NODVO2)')"),
        jm;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = 3 * (numum + jm - 1) + n1;
      n3 = kcoil(jm) - 1 + n1;
      n4 = nodvo1(n3);
      if (n4 == nodvo2(n3)) {
        goto statement_1030;
      }
      if (n4 <= 1) {
        goto statement_1010;
      }
      f(n4) += umcurp(n2);
    statement_1010:
      n5 = nodvo2(n3);
      if (n5 <= 1) {
        goto statement_1020;
      }
      f(n5) = f(n5) - umcurp(n2);
    statement_1020:
      d4 = f(n4);
      d5 = f(n5);
      if (n4 <= 1) {
        d4 = 0.0f;
      }
      if (n5 <= 1) {
        d5 = 0.0f;
      }
      if (iprsup >= 1) {
        write(lunit6,
          "(' *********',' COIL NUMBER',i4,' :',14x,i6,e14.5,2x,i6,e14.5)"),
          n3, n4, d4, n5, d5;
      }
    statement_1030:;
    }
    if (jm == numum) {
      loopss(8) = 1;
    }
    if (jm == numum) {
      goto statement_21000;
    }
    goto statement_99999;
    //C     NCURPR IS SET TO 1 ON INITIATION OF PREDICTION CALCULATION        M33.1961
    //C     OF UM POWER VOLTAGES IF POWER CIRCUITS ARE NOT COMPENSATED        M36.1639
  statement_1100:
    ncurpr = 0;
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' ***************************************',"
        "' DYNAMIC RUN OF SOLVUM FOR UM NUMBER',i4,' :')"),
        jm;
    }
    if (loopss(8) == 1) {
      flxdmh = flxd(jm);
    }
    if (loopss(8) == 1) {
      flxqmh = flxq(jm);
    }
    kcl = kcoil(jm);
    //C  IN CASE OF SM TYPE-59 DATA INPUT                                     M32.6418
    ntyp59 = 0;
    if (jtype(jm) != 13) {
      goto statement_1200;
    }
    if (umoutp(numout + 1) == -9999.0f) {
      loopss(1) = 6644;
    }
    if (istart == 0) {
      loopss(1) = 7766;
    }
    jtype(jm) = 1;
    ntyp59 = 1;
    inpust = inpu;
    inpu = 0;
    nmexc = 0;
    if (fpar(kcl + 3) >= 0.0f) {
      goto statement_1200;
    }
    kconex = -fpar(kcl + 3);
    nmexc = fpar(kcl + 4);
    nexc = fpar(kcl + 5);
  statement_1200:
    if (inpu != 1) {
      goto statement_1210;
    }
    seltat = omegrf * deltat;
  statement_1210:
    selta2 = seltat / 2.0f;
    rppair = nppair(jm);
    if (istart != 0) {
      goto statement_1220;
    }
    if (jcdsat(jm) != 5) {
      goto statement_1220;
    }
    reamqu(jm) = reamdu(jm);
    reamqs(jm) = reamds(jm);
    flxqr(jm) = flxdr(jm);
    flxqs(jm) = flxds(jm);
  statement_1220:
    if (inpu == 2) {
      goto statement_1300;
    }
    flxdrr = 0.0f;
    flxqrr = 0.0f;
    goto statement_1600;
    //C  IF REMANENT FLUX OPTION IS REQUESTED (INPU = 2) :                    M35.1644
  statement_1300:
    if (istart != 0) {
      goto statement_1450;
    }
    n1 = jcdsat(jm) + jcqsat(jm);
    if (n1 != 0) {
      goto statement_1400;
    }
    flxdr(jm) = 0.0f;
    flxqr(jm) = 0.0f;
  statement_1400:
    if (flxdr(jm) < 0.0f) {
      flxdr(jm) = -flxdr(jm);
    }
    if (flxqr(jm) < 0.0f) {
      flxqr(jm) = -flxqr(jm);
    }
  statement_1450:
    if (jcdsat(jm) != 5) {
      goto statement_1500;
    }
    flxdrr = flxdr(jm);
    flxqrr = flxdrr;
    flxda = 0.0f;
    flxqa = 0.0f;
    goto statement_1999;
  statement_1500:
    flxdrr = flxdr(jm);
    flxqrr = flxqr(jm);
    //C   CALCULATION OF FLXDA AND FLXQA (SATURATION LINE) IF NO              M35.1647
    //C     TOTAL SATURATION (IF JCDSAT = 5 , CALCULATION IS LATER):          M35.1648
  statement_1600:
    if (reamdu(jm) == 0.0f) {
      flxda = 0.0f;
    }
    if (reamdu(jm) == 0.0f) {
      goto statement_1610;
    }
    flxda = (reamds(jm) / reamdu(jm)) * (flxdrr - flxds(jm));
    flxda += flxds(jm);
    if (jcdsat(jm) == 0) {
      flxda = 0.0f;
    }
  statement_1610:
    flxqa = (reamqs(jm) / reamqu(jm)) * (flxqrr - flxqs(jm));
    flxqa += flxqs(jm);
    if (jcqsat(jm) == 0) {
      flxqa = 0.0f;
    }
  statement_1999:
    FEM_DO_SAFE(n1, 1, 10) {
      con(n1) = 0.0f;
    }
    if (jtype(jm) >= 13) {
      goto statement_2001;
    }
    n9 = jtype(jm);
    switch (n9) {
    case 1: goto statement_2001;
    case 2: goto statement_2002;
    case 3: goto statement_2003;
    case 4: goto statement_2004;
    case 5: goto statement_2005;
    case 6: goto statement_2006;
    case 7: goto statement_2007;
    case 8: goto statement_2008;
    case 9: goto statement_2009;
    case 10: goto statement_2010;
    case 11: goto statement_2011;
    case 12: goto statement_2012;
    default: break;
    }
  statement_2001:
    con(3) = 1.0f;
    con(5) = 1.0f;
    goto statement_3000;
  statement_2002:
    con(2) = 1.0f;
    con(5) = 1.0f;
    goto statement_3000;
  statement_2003:
    con(3) = 1.0f;
    goto statement_3000;
  statement_2004:
    con(3) = 1.0f;
    con(6) = 1.0f;
    goto statement_3000;
  statement_2005:
    con(2) = 1.0f;
    goto statement_3000;
  statement_2006:
    con(1) = 1.0f;
    goto statement_3000;
  statement_2007:
    con(10) = 1.0f;
    goto statement_3000;
  statement_2008:
    con(4) = 1.0f;
    goto statement_3000;
  statement_2009:
    con(4) = 1.0f;
    con(7) = 1.0f;
    goto statement_3000;
  statement_2010:
    con(4) = 1.0f;
    con(7) = 1.0f;
    goto statement_3000;
  statement_2011:
    con(4) = 1.0f;
    con(8) = 1.0f;
    goto statement_3000;
  statement_2012:
    con(4) = 1.0f;
    con(8) = 1.0f;
    con(9) = 1.0f;
    //C. COIL MARKINGS :                                                      M28.5692
  statement_3000:
    kcld1 = kcoil(jm) + 3;
    kclde = kcoil(jm) + 2 + ncld(jm);
    kclq1 = kclde + 1;
    kclqe = kclde + nclq(jm);
    kcle = kclqe;
    ncl = 3 + ncld(jm) + nclq(jm);
    if (con(6) < 1.0f) {
      goto statement_3010;
    }
    ncl++;
    kcle++;
  statement_3010:
    FEM_DO_SAFE(n1, kcl, kcle) {
      fpar(n1) = 1.0f / (1.0f + gpar(n1) * reacl(n1) / selta2);
    }
    //C. ZERO INITIALIZTION OF ALL THEV VARIABLES :                           M28.5704
    zthev = 0.0f;
    FEM_DO_SAFE(n1, 1, ncl) {
      vinp(n1) = 0.0f;
      zthevs(n1) = 0.0f;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        zthevr(n1, n2) = 0.0f;
        zths3(n1, n2) = 0.0f;
      }
    }
    //C. THEV VOLTAGES AND IMPEDANCES FOR UM-STATOR(EXCITATION):              M33.1967
    n15 = kcle - kcl - 2;
    if (ncl > 6) {
      n15 = 3;
    }
    FEM_DO_SAFE(n1, 1, 9) {
      ndum(n1) = 0;
    }
    FEM_DO_SAFE(n1, 1, n15) {
      n2 = kcl + 2 + n1;
      ndum(n1) = nodvo1(n2);
      ndum(n1 + 3) = nodvo2(n2);
      ndum(n1 + 6) = nodvo1(n2) - nodvo2(n2);
    }
    FEM_DO_SAFE(n1, 1, n15) {
      n2 = ndum(n1);
      n3 = ndum(n1 + 3);
      n4 = n1 + 6;
      if (ndum(n4) == 0) {
        goto statement_4022;
      }
      vinp(n1 + 3) = -e(n2) + e(n3);
    statement_4022:;
    }
    if (istart == 0) {
      goto statement_4110;
    }
    n20 = 0;
    FEM_DO_SAFE(n1, 1, n15) {
      n2 = ndum(n1) + n20 * ntot;
      n3 = ndum(n1 + 3) + n20 * ntot;
      n5 = ndum(n1);
      n6 = ndum(n1 + 3);
      n7 = n1 + 6;
      n8 = ndum(1) + n20 * ntot;
      n9 = ndum(4) + n20 * ntot;
      if (ndum(n7) == 0) {
        goto statement_4033;
      }
      n20++;
      zths3(n1, n1) = -znonl(n2) + znonl(n3);
      if (n1 != 1) {
        goto statement_4030;
      }
      d1 = dcoef(jm) * dcoef(jm);
      if (ntyp59 == 1) {
        zths3(1, 1) = zths3(1, 1) * d1;
      }
      if (n15 == 1) {
        goto statement_4200;
      }
      goto statement_4033;
    statement_4030:
      if (ndum(7) == 0) {
        goto statement_4033;
      }
      zths3(1, n1) = -znonl(n8) + znonl(n9);
      zths3(n1, 1) = -znonl(n5) + znonl(n6);
    statement_4033:;
    }
    if (n15 < 3) {
      goto statement_4200;
    }
    n19 = 0;
    n20 = 0;
    n1 = ndum(8) * ndum(9);
    if (n1 == 0) {
      goto statement_4110;
    }
    if (ndum(7) != 0) {
      n20 = 1;
    }
    n1 = 3;
  statement_4044:
    n2 = ndum(n1) + n20 * ntot;
    n3 = ndum(n1 + 3) + n20 * ntot;
    if (n19 == 1) {
      goto statement_4045;
    }
    zths3(3, 2) = -znonl(n2) + znonl(n3);
    n20++;
    n19 = 1;
    n1 = 2;
    goto statement_4044;
  statement_4045:
    zths3(2, 3) = -znonl(n2) + znonl(n3);
  statement_4110:
    if (ncl <= 6) {
      goto statement_4200;
    }
    n15 = kcld1 + 3;
    FEM_DO_SAFE(n1, n15, kcle) {
      n2 = nodvo1(n1);
      n3 = nodvo2(n1);
      n10 = n1 - kcl + 1;
      if (nodvo1(n1) == nodvo2(n1)) {
        goto statement_4120;
      }
      if (istart == 0) {
        goto statement_4115;
      }
      zthevs(n10) = -znonl(n2) + znonl(n3);
    statement_4115:
      vinp(n10) = -e(n2) + e(n3);
    statement_4120:;
    }
    //C. THEV VOLTAGES AND IMPEDANCES FOR ROTOR(POWER)-COILS :                M33.1968
  statement_4200:
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + kcl - 1;
      ndum(n1) = nodvo1(n2);
      ndum(n1 + 3) = nodvo2(n2);
      ndum(n1 + 6) = nodvo1(n2) - nodvo2(n2);
    }
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = ndum(n1);
      n3 = ndum(n1 + 3);
      n4 = n1 + 6;
      if (ndum(n4) == 0) {
        goto statement_4222;
      }
      vinp(n1) = e(n2) - e(n3);
    statement_4222:;
    }
    if (loopss(8) == 1) {
      goto statement_5000;
    }
    if (istart == 0) {
      goto statement_5000;
    }
    n20 = 0;
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = ndum(n1) + n20 * ntot;
      n3 = ndum(n1 + 3) + n20 * ntot;
      n5 = ndum(n1);
      n6 = ndum(n1 + 3);
      n7 = n1 + 6;
      n8 = ndum(1) + n20 * ntot;
      n9 = ndum(4) + n20 * ntot;
      if (ndum(n7) == 0) {
        goto statement_4233;
      }
      n20++;
      zthevr(n1, n1) = -znonl(n2) + znonl(n3);
      if (n1 == 1) {
        goto statement_4233;
      }
      if (ndum(7) == 0) {
        goto statement_4233;
      }
      zthevr(1, n1) = -znonl(n8) + znonl(n9);
      zthevr(n1, 1) = -znonl(n5) + znonl(n6);
    statement_4233:;
    }
    zthev = con(4) * zthevr(3, 3);
    zthevr(3, 3) = zthevr(3, 3) * (con(2) + con(3));
    n19 = 0;
    n20 = 0;
    n1 = ndum(8) * ndum(9);
    if (n1 == 0) {
      goto statement_5000;
    }
    if (ndum(7) != 0) {
      n20 = 1;
    }
    n1 = 3;
  statement_4244:
    n2 = ndum(n1) + n20 * ntot;
    n3 = ndum(n1 + 3) + n20 * ntot;
    if (n19 == 1) {
      goto statement_4245;
    }
    zthevr(3, 2) = -znonl(n2) + znonl(n3);
    n20++;
    n19 = 1;
    n1 = 2;
    goto statement_4244;
  statement_4245:
    zthevr(2, 3) = -znonl(n2) + znonl(n3);
    //C. GENERATE THE SCALAR PARAMETER RD2 FOR SPECIAL DM:                    M28.5826
  statement_5000:
    rd2 = 0.0f;
    if (jtype(jm) < 9) {
      goto statement_6000;
    }
    if (jtype(jm) > 11) {
      goto statement_6000;
    }
    if (gpar(kcl + 4) != 0.0f) {
      rd2 = 1.0f / gpar(kcl + 4);
    }
    //C. UPDATE FOR SPECIAL DM-TYPES: CSC + CPC = 1                           M28.5831
  statement_6000:
    d1 = con(7) + con(8);
    if (d1 == 0.0f) {
      goto statement_7000;
    }
    reacl(kcl + 2) += d1 * reacl(kcl + 4);
    reacl(kcl + 3) += d1 * reacl(kcl + 4);
    fpar(kcl + 2) = 1.0f / (1.0f + gpar(kcl + 2) * reacl(kcl + 2) / selta2);
    fpar(kcl + 3) = 1.0f / (1.0f + gpar(kcl + 3) * reacl(kcl + 3) / selta2);
    d2 = d1 * zthev + con(8) * (reacl(kcl + 4) + rd2) / selta2;
    betaq = fpar(kcl + 2) * gpar(kcl + 2) * d2;
    betad1 = fpar(kcl + 3) * gpar(kcl + 3) * d2;
    //C. THEVENIN MECHANICAL IMPEDANCE AND SPEED:                             M28.5841
  statement_7000:
    n1 = nodom(jm);
    nshare = jcltac(kcl) + jcltac(kcl + 1);
    if (nshare != 0) {
      mshare = 1;
    }
    zthevm = 0.0f;
    omthev = 0.0f;
    zthem2 = 0.0f;
    zthem3 = 0.0f;
    tqgen2 = 0.0f;
    tqgen3 = 0.0f;
    if (jtmtac(jm) != 0) {
      goto statement_8000;
    }
    omthev = e(n1);
    if (istart == 0) {
      goto statement_8000;
    }
    zthevm = -znonl(n1);
    //C  IF MORE UM'S SHARE THE SAME MECH NETWORK OF THIS UM NR. JM :         M39.3089
    if (nshare == 0) {
      goto statement_8000;
    }
    n12 = jcltac(kcl);
    tqgen2 = voltum(n12);
    n13 = jcltac(kcl + 1);
    if (n13 == 0) {
      goto statement_7010;
    }
    tqgen3 = voltum(n13);
  statement_7010:
    n4 = 0;
    if (jm > n12) {
      n4 = 1;
    }
    if (jm > n13 && n13 != 0) {
      n4++;
    }
    n5 = 0;
    if (n12 > jm) {
      n5 = 1;
    }
    if (n12 > n13 && n13 != 0) {
      n5++;
    }
    //C  NOW POSITION THE CORRECT ENTRY TO THE TABLE ZNONL :                  M39.3102
    n1 = nodom(jm) + n4 * ntot;
    n2 = nodom(jm) + n5 * ntot;
    zthevm = -znonl(n1);
    zthem2 = -znonl(n2);
    if (n13 == 0) {
      goto statement_8000;
    }
    n6 = 3 - (n4 + n5);
    n3 = nodom(jm) + n6 * ntot;
    zthem3 = -znonl(n3);
    //C. TACS INPUT FOR UM-STATOR (EXCITATION COILS) :                        M38.3498
  statement_8000:
    FEM_DO_SAFE(n1, 4, ncl) {
      n2 = kcl - 1 + n1;
      n3 = jcltac(n2);
      if (n3 == 0) {
        goto statement_8002;
      }
      if (n1 > 3) {
        goto statement_8001;
      }
      vinp(n1) += sptacs(n3);
      goto statement_8002;
    statement_8001:
      vinp(n1) = vinp(n1) - sptacs(n3);
    statement_8002:;
    }
    if (ntyp59 == 1) {
      vinp(4) = vinp(4) * dcoef(jm);
    }
    //C. VOLTAGE INPUT FOR SPECIAL DM:                                        M28.5859
    if (d1 == 0.0f) {
      goto statement_9000;
    }
    vinp(4) = -d1 * vinp(3);
    vinp(5) = 0.0f;
    //C.TACS INPUT FOR MECHANICAL INPUT TORQUE:                               M28.5863
  statement_9000:
    tumtac = 0.0f;
    if (jtmtac(jm) == 0) {
      goto statement_11000;
    }
    n1 = jtmtac(jm);
    tumtac = sptacs(n1);
    //C. DETERMINATION OF HISTORY AT TIME = 0.0 :                             M28.5868
  statement_11000:
    if (istart != 0) {
      goto statement_12000;
    }
    thetae = rppair * (1.0f - con(1) - con(4)) * thetam(jm);
    omege = rppair * omegm(jm);
    goto statement_12200;
    //C  CALCULATION OF UM POWER CURRENTS FOR OUTPUT :                        M33.1971
  statement_12000:
    if (loopss(8) == 0) {
      goto statement_12004;
    }
    n3 = 3 * (numum + jm - 1);
    curum1 = umcurp(n3 + 1) - gpar(kcl + 2) * vinp(1);
    curum2 = umcurp(n3 + 2) - gpar(kcl + 2) * vinp(2);
    curum3 = umcurp(n3 + 3) - gpar(kcl + 2) * vinp(3);
    goto statement_12016;
    //C. STORING ZTHEVR AND VINP(1:3) FOR NITROM:                             M28.5873
  statement_12004:
    FEM_DO_SAFE(n1, 1, 3) {
      zthevs(n1) = vinp(n1);
      FEM_DO_SAFE(n2, 1, 3) {
        zmat(n1, n2) = zthevr(n1, n2);
      }
    }
    //C. PREDICTION FOR OMEGA-ITERATION:                                      M28.5879
  statement_12016:
    omegmp = 2.0f * omegm(jm) - omold(jm);
    omold(jm) = omegm(jm);
    theold = thetam(jm);
    nitrom = -1;
  statement_12020:
    nitrom++;
    if (loopss(8) != 0) {
      goto statement_12100;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      vinp(n1) = zthevs(n1);
      FEM_DO_SAFE(n2, 1, 3) {
        zthevr(n1, n2) = zmat(n1, n2);
      }
    }
  statement_12100:
    thetam(jm) = theold + selta2 * (omold(jm) + omegmp);
    thetae = rppair * (1.0f - con(1) - con(4)) * thetam(jm);
    omege = rppair * omegmp;
    //C.SET UP PARK TRANSFORMATION:                                           M28.5893
  statement_12200:
    ptheta(1, 1) = 1.0f;
    ptheta(2, 2) = cosz(thetae);
    ptheta(2, 3) = -sinz(thetae);
    ptheta(3, 2) = -ptheta(2, 3);
    ptheta(3, 3) = ptheta(2, 2);
    FEM_DO_SAFE(n1, 2, 3) {
      ptheta(1, n1) = 0.0f;
      ptheta(n1, 1) = ptheta(1, n1);
    }
    FEM_DO_SAFE(n1, 1, 3) {
      dummat(1, n1) = con(3) / sroot3;
    }
    dummat(2, 1) = con(3) * sroot2 / sroot3;
    dummat(2, 3) = -con(3) / (sroot2 * sroot3);
    dummat(2, 2) = dummat(2, 3) + con(2) + con(10);
    dummat(3, 1) = 0.0f;
    dummat(3, 2) = -con(3) / sroot2;
    dummat(3, 3) = -dummat(3, 2) + con(2) + con(1) - con(10) + con(4);
    matmul(ptheta, dummat);
    if (ncurpr == 1) {
      goto statement_14609;
    }
    //C. UPDATING FOR SPECIAL IM(3-PHASE ROTOR) AND SMAT :                    M28.5911
    if (con(6) != 1.0f) {
      goto statement_12300;
    }
    if (nitrom > 0) {
      goto statement_12300;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      n3 = n1 + 1;
      if (n1 == 3) {
        n3 = 1;
      }
      FEM_DO_SAFE(n2, 1, 3) {
        smat(n1, n2) = dummat(n3, n2);
      }
    }
    FEM_DO_SAFE(n2, 1, 3) {
      n3 = n2 - 1;
      FEM_DO_SAFE(n1, 1, 3) {
        if (n2 != 1) {
          goto statement_12231;
        }
        dumvec(n1) = smat(n1, n2);
        goto statement_12232;
      statement_12231:
        smat(n1, n3) = smat(n1, n2);
        if (n2 != 3) {
          goto statement_12232;
        }
        smat(n1, n2) = dumvec(n1);
      statement_12232:;
      }
    }
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + 3;
      dumvec(n1) = vinp(n2);
    }
    matvec(smat, dumvec);
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + 3;
      vinp(n2) = dumvec(n1);
    }
    //C. TRANSFORM THE UM-ROTOR(POWER) VOLTAGES:                              M33.1981
  statement_12300:
    if (loopss(8) != 0) {
      goto statement_12304;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      dumvec(n1) = vinp(n1);
    }
    matvec(ptheta, dumvec);
    FEM_DO_SAFE(n1, 1, 3) {
      vinp(n1) = dumvec(n1);
    }
    //C. DETERMINATION OF INITIAL CURRENTS IN UM DOMAIN :                     M28.5944
  statement_12304:
    if (istart != 0) {
      goto statement_12400;
    }
    if (initum != 0) {
      goto statement_12330;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + kcl - 1;
      dumvec(n1) = hist(n2);
    }
    matvec(ptheta, dumvec);
    FEM_DO_SAFE(n1, 1, 3) {
      umcur(n1) = dumvec(n1);
    }
    if (con(6) != 1.0f) {
      goto statement_12335;
    }
    dumvec(1) = -hist(kcl + 5);
    dumvec(2) = -hist(kcl + 3);
    dumvec(3) = -hist(kcl + 4);
    matvec(dummat, dumvec);
    umcur(4) = dumvec(2);
    umcur(5) = dumvec(3);
    umcur(6) = dumvec(1);
    goto statement_12350;
  statement_12330:
    if (initum == 0) {
      goto statement_12350;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + kcl - 1;
      umcur(n1) = +hist(n2);
    }
    if (jtype(jm) != 4) {
      goto statement_12335;
    }
    FEM_DO_SAFE(n1, 4, 6) {
      n2 = n1 + kcl - 1;
      umcur(n1) = -hist(n2);
    }
    goto statement_12350;
  statement_12335:
    FEM_DO_SAFE(n2, kcld1, kcle) {
      n1 = n2 - kcl + 1;
      umcur(n1) = -hist(n2);
    }
    //C. CALCULATION OF INITIAL FLXD(JM) AND FLXQ(JM):                        M28.5964
  statement_12350:
    d10 = umcur(2);
    d15 = umcur(3);
    if (ncld(jm) < 1) {
      goto statement_12360;
    }
    FEM_DO_SAFE(n2, kcld1, kclde) {
      n1 = n2 - kcl + 1;
      d10 += umcur(n1);
    }
    if (ncld(jm) <= 1) {
      goto statement_12360;
    }
    if (jtype(jm) != 12) {
      goto statement_12360;
    }
    d10 = d10 - umcur(5);
  statement_12360:
    if (nclq(jm) < 1) {
      goto statement_12370;
    }
    FEM_DO_SAFE(n2, kclq1, kclqe) {
      n1 = n2 - kcl + 1;
      d15 += umcur(n1);
    }
  statement_12370:
    curmd = d10;
    curmq = d15;
    if (jcdsat(jm) != 5) {
      goto statement_12372;
    }
    curmt = d10 * d10 + d15 * d15;
    if (curmt == 0.0f) {
      goto statement_12375;
    }
    curmt = sqrtz(curmt);
    d19 = d10 * flxds(jm) / curmt;
    d20 = d15 * flxqs(jm) / curmt;
    if (d19 < 0.0f) {
      d19 = -d19;
    }
    if (d20 < 0.0f) {
      d20 = -d20;
    }
    if (reamdu(jm) == 0.0f) {
      goto statement_12375;
    }
    d18 = reamds(jm) / reamdu(jm);
    flxda = d19 + d18 * (flxdrr - d19);
    flxqa = d20 + d18 * (flxqrr - d20);
  statement_12372:
    if (jcdsat(jm) == 0) {
      goto statement_12375;
    }
    if (reamdu(jm) == 0.0f) {
      goto statement_12375;
    }
    d11 = flxds(jm) / reamdu(jm);
    d12 = -d11;
    if (d10 > d11) {
      goto statement_12377;
    }
    if (d10 < d12) {
      goto statement_12377;
    }
  statement_12375:
    flxd(jm) = reamdu(jm) * d10 + flxdrr;
    if (d10 < 0.0f) {
      flxd(jm) = flxd(jm) - 2.f * flxdrr;
    }
    if (jcdsat(jm) != 5) {
      goto statement_12376;
    }
    if (curmt == 0.0f) {
      goto statement_12385;
    }
  statement_12376:
    goto statement_12380;
  statement_12377:
    if (d10 >= 0.0f) {
      flxd(jm) = flxda + reamds(jm) * d10;
    }
    if (d10 < 0.0f) {
      flxd(jm) = -flxda + reamds(jm) * d10;
    }
  statement_12380:
    if (jcqsat(jm) == 0) {
      goto statement_12385;
    }
    d16 = flxqs(jm) / reamqu(jm);
    d17 = -d16;
    if (d15 > d16) {
      goto statement_12387;
    }
    if (d15 < d17) {
      goto statement_12387;
    }
  statement_12385:
    flxq(jm) = reamqu(jm) * d15 + flxqrr;
    if (d15 < 0.0f) {
      flxq(jm) = flxq(jm) - 2.f * flxqrr;
    }
    goto statement_14200;
  statement_12387:
    if (d15 >= 0.0f) {
      flxq(jm) = flxqa + reamqs(jm) * d15;
    }
    if (d15 < 0.0f) {
      flxq(jm) = -flxqa + reamqs(jm) * d15;
    }
    goto statement_14200;
    //C. TRANSFORM THE UM-ROTOR(POWER) THEVENIN IMPEDANCES:                   M33.1983
  statement_12400:
    if (loopss(8) == 1) {
      goto statement_12465;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = ptheta(n2, n1);
      }
    }
    matmul(zthevr, dummat);
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = ptheta(n1, n2);
      }
    }
    matmul(dummat, zthevr);
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        zthevr(n1, n2) = dummat(n1, n2);
      }
    }
    //C. TRANSFORM THE UM-STATOR(EXCIT) IN CASE OF ABC-EXCITATION :           M33.1986
  statement_12465:
    if (con(6) != 1.0f) {
      goto statement_12600;
    }
    if (nitrom > 0) {
      goto statement_12600;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = smat(n2, n1);
      }
    }
    matmul(zths3, dummat);
    matmul(smat, zths3);
    //C. NOTE: FROM NOW ON SMAT IS IN BACK-TRANSFORMATION MODE :              M28.6021
    //C.                             (ONLY FOR T > 0.0)                       M28.6022
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        zths3(n1, n2) = smat(n1, n2);
        smat(n1, n2) = dummat(n1, n2);
      }
    }
    //C. CALCULATION OF FLXD AND FLXQ:                                        M28.6027
    //C. CALCULATION OF JACOBIAN:                                             M28.6028
  statement_12600:
    flxd(jm) = 0.0f;
    flxq(jm) = 0.0f;
    jacob = 1;
    goto statement_13000;
  statement_12601:
    fjd = umcur(2);
    fjq = umcur(3);
    if (loopss(8) == 1) {
      fjd = 0.0f;
    }
    if (loopss(8) == 1) {
      fjq = 0.0f;
    }
    if (kcld1 > kclde) {
      goto statement_12603;
    }
    FEM_DO_SAFE(n1, kcld1, kclde) {
      n2 = n1 - kcl + 1;
      fjd += umcur(n2);
    }
    if (jtype(jm) != 12) {
      goto statement_12603;
    }
    fjd = fjd - umcur(5);
  statement_12603:
    if (kclq1 > kclqe) {
      goto statement_12605;
    }
    FEM_DO_SAFE(n1, kclq1, kclqe) {
      n2 = n1 - kcl + 1;
      fjq += umcur(n2);
    }
  statement_12605:
    flxd(jm) = 1.0f;
    flxq(jm) = 0.0f;
    jacob = 2;
    goto statement_13000;
  statement_12606:
    fjdd = umcur(2);
    fjqd = umcur(3);
    if (loopss(8) == 1) {
      fjdd = 0.0f;
    }
    if (loopss(8) == 1) {
      fjqd = 0.0f;
    }
    if (kcld1 > kclde) {
      goto statement_12608;
    }
    FEM_DO_SAFE(n1, kcld1, kclde) {
      n2 = n1 - kcl + 1;
      fjdd += umcur(n2);
    }
    if (jtype(jm) != 12) {
      goto statement_12608;
    }
    fjdd = fjdd - umcur(5);
  statement_12608:
    fjdd = fjdd - fjd;
    if (kclq1 > kclqe) {
      goto statement_12610;
    }
    FEM_DO_SAFE(n1, kclq1, kclqe) {
      n2 = n1 - kcl + 1;
      fjqd += umcur(n2);
    }
  statement_12610:
    fjqd = fjqd - fjq;
    flxd(jm) = 0.0f;
    flxq(jm) = 1.0f;
    jacob = 3;
    goto statement_13000;
  statement_12611:
    fjdq = umcur(2);
    fjqq = umcur(3);
    if (loopss(8) == 1) {
      fjdq = 0.0f;
    }
    if (loopss(8) == 1) {
      fjqq = 0.0f;
    }
    if (kcld1 > kclde) {
      goto statement_12613;
    }
    FEM_DO_SAFE(n1, kcld1, kclde) {
      n2 = n1 - kcl + 1;
      fjdq += umcur(n2);
    }
    if (jtype(jm) != 12) {
      goto statement_12613;
    }
    fjdq = fjdq - umcur(5);
  statement_12613:
    fjdq = fjdq - fjd;
    if (kclq1 > kclqe) {
      goto statement_12615;
    }
    FEM_DO_SAFE(n1, kclq1, kclqe) {
      n2 = n1 - kcl + 1;
      fjqq += umcur(n2);
    }
  statement_12615:
    fjqq = fjqq - fjq;
    if (loopss(8) == 1) {
      fjd += umcur(2);
    }
    if (loopss(8) == 1) {
      fjq += umcur(3);
    }
    jacob = 4;
    //C. START FLXDS AND FLXQS CHECK:                                         M28.6081
    //C    CURMD AND CURMQ ARE REPEATEDLY CALCULATED TO FIND IF               M38.3505
    //C       REAMDU OR REAMDS AND REAMQU OR REAMQS NEEDS TO BE USED.         M38.3506
    //C    N1 = 1: FIRST TIME AND UNSATURATED TO FIND SFLXD AND SFLXQ         M38.3507
    //C    N1 = 5: COMMAND TO REPEAT CALCULATIONS IN SATURATED CONDITION      M38.3508
    //C            IF SATURATION OPTION IS REQUESTED                          M38.3509
    //C    N1 = 2: COMMAND TO EXIT CALCULATION                                M38.3510
    //C    N1 = 3: COMMAND TO REPEAT WITH Q-AXIS SATURATION                   M38.3511
    //C    N1 = 4: COMMAND TO REPEAT WITH D-AXIS SATURATION                   M38.3512
    //C    THE CONSTANT N2 IS USED FOR TOTAL SATURATION OPTION PURPOSE        M38.3513
    n1 = 1;
    n2 = 1;
    n5 = 1 + jcdsat(jm) + 2 * jcqsat(jm);
    //C  FIRST FIND SFLXD AND SFLXQ WITH NO SAT. AND RES. MAGN.               M30. 869
    d15 = 0.0f;
    sflxd = 0.0f;
    sflxq = 0.0f;
    goto statement_12702;
  statement_12701:
    if (n5 == 2) {
      goto statement_12704;
    }
    if (n5 == 3) {
      goto statement_12706;
    }
    if (n5 == 4) {
      goto statement_12708;
    }
    if (n5 >= 5) {
      goto statement_12708;
    }
  statement_12702:
    d12 = 0.0f;
    d13 = 0.0f;
    goto statement_12710;
  statement_12704:
    d12 = 1.0f;
    d13 = 0.0f;
    goto statement_12710;
  statement_12706:
    d12 = 0.0f;
    d13 = 1.0f;
    goto statement_12710;
  statement_12708:
    d12 = 1.0f;
    d13 = 1.0f;
  statement_12710:
    d1 = sflxd * ((1.0f - d12) * d15 * flxdrr + d12 * flxda);
    d2 = sflxq * ((1.0f - d13) * d15 * flxqrr + d13 * flxqa);
    d3 = fjdd * d1 + fjdq * d2 + fjd;
    d4 = fjqq * d2 + fjqd * d1 + fjq;
    d5 = reamdu(jm) * (1.0f - d12) + reamds(jm) * d12;
    d6 = reamqu(jm) * (1.0f - d13) + reamqs(jm) * d13;
    d7 = 1.0f - fjdd * d5;
    d8 = 1.0f - fjqq * d6;
    d9 = -fjdq * d6;
    d10 = -fjqd * d5;
    d11 = d7 * d8 - d9 * d10;
    curmd = (d8 * d3 - d9 * d4) / d11;
    curmq = (d7 * d4 - d10 * d3) / d11;
    d1 = curmd * curmd;
    d1 += curmq * curmq;
    curmt = sqrtz(d1);
    d19 = sflxd * curmd;
    d20 = sflxq * curmq;
    //C  DELETION OF 6 LINES TO THE M28 VERSION ON 28 DEC 1980,               M30. 885
    //C  THE DELETED LINE NUMBERS : M28.6109 TO M28.6114                      M30. 886
    if (n1 >= 5) {
      goto statement_12725;
    }
    switch (n1) {
    case 1: goto statement_12800;
    case 2: goto statement_12900;
    case 3: goto statement_12780;
    case 4: goto statement_12790;
    default: break;
    }
  statement_12725:
    if (n5 >= 5) {
      goto statement_12750;
    }
    switch (n5) {
    case 1: goto statement_12900;
    case 2: goto statement_12730;
    case 3: goto statement_12740;
    case 4: goto statement_12750;
    case 5: goto statement_12750;
    default: break;
    }
  statement_12730:
    if (d19 > d17) {
      goto statement_12900;
    }
    n1 = 2;
    n2 = 0;
    goto statement_12702;
  statement_12740:
    if (d20 > d18) {
      goto statement_12900;
    }
    n1 = 2;
    n2 = 0;
    goto statement_12702;
  statement_12750:
    if (n5 != 5) {
      goto statement_12755;
    }
    n2 = 0;
    if (d19 > d17) {
      goto statement_12900;
    }
    if (d20 > d18) {
      goto statement_12900;
    }
    n1 = 2;
    goto statement_12702;
  statement_12755:
    if (d19 <= d17 && d20 <= d18) {
      goto statement_12790;
    }
    if (d19 > d17 && d20 > d18) {
      goto statement_12900;
    }
    if (d19 > d17) {
      goto statement_12770;
    }
    goto statement_12760;
  statement_12760:
    n1 = 3;
    n2 = 0;
    goto statement_12706;
  statement_12770:
    n1 = 4;
    n2 = 0;
    goto statement_12704;
  statement_12780:
    if (d20 > d18) {
      goto statement_12900;
    }
    n1 = 2;
    n2 = 0;
    goto statement_12702;
  statement_12790:
    if (d19 > d17) {
      goto statement_12900;
    }
    n1 = 2;
    n2 = 0;
    goto statement_12702;
  statement_12800:
    if (n5 == 1) {
      goto statement_12900;
    }
    n1 = 5;
    d15 = 1.0f;
    sflxd = 1.0f;
    sflxq = 1.0f;
    if (curmd < 0.0f) {
      sflxd = -1.0f;
    }
    if (curmq < 0.0f) {
      sflxq = -1.0f;
    }
    if (reamdu(jm) == 0.0f) {
      goto statement_12802;
    }
    d17 = (flxds(jm) - flxdrr) / reamdu(jm);
    d18 = (flxqs(jm) - flxqrr) / reamqu(jm);
  statement_12802:
    if (jcdsat(jm) == 5) {
      goto statement_12804;
    }
    goto statement_12701;
    //C   CALCULATION OF FLXDA AND FLXQA IF TOTAL SATURATION :                M35.1649
  statement_12804:
    if (curmt != 0.0f) {
      goto statement_12806;
    }
    d1 = flxds(jm);
    d2 = d1;
    goto statement_12808;
  statement_12806:
    d19 = sflxd * curmd;
    d20 = sflxq * curmq;
    d17 = d17 * d19 / curmt;
    d18 = d18 * d20 / curmt;
    d1 = d19 * flxds(jm) / curmt;
    d2 = d20 * flxds(jm) / curmt;
  statement_12808:
    d3 = reamds(jm) / reamdu(jm);
    flxda = d1 + d3 * (flxdrr - d1);
    flxqa = d2 + d3 * (flxqrr - d2);
    n5 = 5;
    goto statement_12701;
  statement_12900:
    flxd(jm) = reamdu(jm) * (1.0f - d12) * curmd;
    flxq(jm) = reamqu(jm) * (1.0f - d13) * curmq;
    if (n5 == 1) {
      goto statement_13000;
    }
    flxd(jm) += reamds(jm) * d12 * curmd;
    flxd(jm) += sflxd * (1.0f - d12) * flxdrr;
    flxd(jm) += d12 * sflxd * flxda;
    flxq(jm) += reamqs(jm) * d13 * curmq;
    flxq(jm) += sflxq * (1.0f - d13) * flxqrr;
    flxq(jm) += d13 * sflxq * flxqa;
    if (n2 != 0) {
      goto statement_13000;
    }
    if (d12 != 0.0f) {
      goto statement_12910;
    }
    d1 = flxd(jm) * flxd(jm);
    d2 = flxdrr * flxdrr;
    if (d1 <= d2) {
      flxd(jm) = sflxd * flxdrr;
    }
  statement_12910:
    if (d13 != 0.0f) {
      goto statement_13000;
    }
    d1 = flxq(jm) * flxq(jm);
    d2 = flxqrr * flxqrr;
    if (d1 <= d2) {
      flxq(jm) = sflxq * flxqrr;
    }
    //C. UMCUR-ROTOR(POWER) EQUATIONS:                                        M33.1996
    //C. FORMATION OF ACURR                                                   M28.6149
  statement_13000:
    if (loopss(8) == 0) {
      goto statement_13008;
    }
    if (jacob > 1) {
      goto statement_13100;
    }
    umcur(1) = curum1;
    umcur(2) = curum2;
    umcur(3) = curum3;
    matvec(ptheta, umcur);
    if (gpar(kcl) == 0.0f) {
      umcur(1) = 0.0f;
    }
    goto statement_13100;
  statement_13008:
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = 0.0f;
      }
    }
    dummat(1, 1) = gpar(kcl) * fpar(kcl);
    dummat(2, 2) = gpar(kcl + 1) * fpar(kcl + 1);
    dummat(3, 3) = gpar(kcl + 2) * fpar(kcl + 2);
    FEM_DO_SAFE(n1, 2, 3) {
      dumvec(n1) = dummat(n1, n1);
    }
    matmul(dummat, zthevr);
    d1 = zthev + (con(7) + con(8)) * rd2;
    dummat(3, 3) += dumvec(3) * d1 + 1.0f;
    dummat(2, 2) += 1.0f;
    dummat(1, 1) += 1.0f;
    d1 = (1.0f - con(4)) * omege * dumvec(2) * reacl(kcl + 2);
    dummat(2, 3) += d1;
    d1 = (1.0f - con(4)) * omege * dumvec(3) * reacl(kcl + 1);
    dummat(3, 2) = dummat(3, 2) - d1;
    //C.FORMATION OF UMCUR-ROTOR(POWER):                                      M33.2006
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = kcl - 1 + n1;
      dumvec(n1) = -gpar(n2) * fpar(n2) * vinp(n1) + hist(n2);
    }
    d2 = +gpar(kcl + 1) * fpar(kcl + 1);
    d3 = +gpar(kcl + 2) * fpar(kcl + 2);
    d5 = -d2 * (flxd(jm) / selta2 + flxq(jm) * omege);
    dumvec(2) += d5;
    d5 = d3 * (flxd(jm) * omege - flxq(jm) / selta2);
    d6 = -d3 * flxd(jm) * (con(7) + con(8)) / selta2;
    dumvec(3) += d5 + d6;
    //C. FINAL RESULT FOR UMCUR-ROTOR(POWER):                                 M33.2007
    lineqs(dummat, dumvec);
    FEM_DO_SAFE(n1, 1, 3) {
      umcur(n1) = dumvec(n1);
    }
    //C.FORMATION OF UMCUR-STATOR(EXCIT) :                                    M33.2008
  statement_13100:
    FEM_DO_SAFE(n1, kcld1, kclqe) {
      n2 = n1 - kcl + 1;
      umcur(n2) = -gpar(n1) * fpar(n1) * vinp(n2) + hist(n1);
    }
    if (ncld(jm) == 0) {
      goto statement_13150;
    }
    FEM_DO_SAFE(n1, kcld1, kclde) {
      n2 = n1 - kcl + 1;
      d1 = -flxd(jm) * gpar(n1) * fpar(n1) / selta2;
      umcur(n2) += d1;
    }
    d4 = gpar(kcl + 3) * fpar(kcl + 3);
    umcur(4) += flxd(jm) * con(8) * d4 / selta2;
  statement_13150:
    if (nclq(jm) == 0) {
      goto statement_13200;
    }
    FEM_DO_SAFE(n1, kclq1, kclqe) {
      n2 = n1 - kcl + 1;
      d1 = -flxq(jm) * gpar(n1) * fpar(n1) / selta2;
      umcur(n2) += d1;
    }
    //C. UMCUR-STATOR(EXCIT)  FOR UM=TYPE 4(C3IM):                            M33.2009
  statement_13200:
    if (con(6) == 0.0f) {
      goto statement_13210;
    }
    n1 = kcle - kcl + 1;
    umcur(n1) = hist(kcle) - gpar(kcle) * fpar(kcle) * vinp(n1);
    //C. IMPLEMENTING INFLUENCE OF THEV IMPEDANCES :                          M28.6203
  statement_13210:
    d1 = con(7) + con(8);
    if (d1 < 1.0f) {
      goto statement_13212;
    }
    zths3(1, 1) = d1 * zthev + con(8) * rd2;
    dummat(1, 1) = 1.0f + gpar(kcld1) * fpar(kcld1) * zths3(1, 1);
    goto statement_13230;
  statement_13212:
    n15 = kcle;
    if (ncl > 6) {
      n15 = kcl + 5;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = 0.0f;
      }
    }
    FEM_DO_SAFE(n1, kcld1, n15) {
      n2 = n1 - kcl - 2;
      dummat(n2, n2) = gpar(n1) * fpar(n1);
    }
    matmul(dummat, zths3);
    FEM_DO_SAFE(n1, 1, 3) {
      dummat(n1, n1) += 1.0f;
    }
    n16 = n15 - kcl - 2;
    if (n16 == 2) {
      goto statement_13235;
    }
    if (n16 == 3) {
      goto statement_13240;
    }
  statement_13230:
    umcur(4) = umcur(4) / dummat(1, 1);
    goto statement_13260;
  statement_13235:
    d1 = dummat(1, 1) * dummat(2, 2);
    d1 = d1 - dummat(1, 2) * dummat(2, 1);
    d4 = umcur(4);
    d5 = umcur(5);
    umcur(4) = (dummat(2, 2) * d4 - dummat(1, 2) * d5) / d1;
    umcur(5) = (dummat(1, 1) * d5 - dummat(2, 1) * d4) / d1;
    goto statement_13260;
  statement_13240:
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + 3;
      dumvec(n1) = umcur(n2);
    }
    lineqs(dummat, dumvec);
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = n1 + 3;
      umcur(n2) = dumvec(n1);
    }
  statement_13260:
    if (ncl <= 6) {
      goto statement_13300;
    }
    n15 = kcld1 + 3;
    FEM_DO_SAFE(n1, n15, kcle) {
      n2 = n1 - kcl + 1;
      d1 = 1.0f + gpar(n1) * fpar(n1) * zthevs(n2);
      umcur(n2) = umcur(n2) / d1;
    }
    //C. UMCUR UPDATE FOR UM = SPECIAL DM-TYPES :                             M28.6244
  statement_13300:
    d1 = con(7) + con(8);
    if (d1 == 0.0f) {
      goto statement_14100;
    }
    d2 = 1.0f / (1.0f - betaq * betad1);
    d3 = umcur(3);
    d4 = umcur(4);
    umcur(3) = (d3 + betaq * d4) * d2;
    umcur(4) = (betad1 * d3 + d4) * d2;
    if (con(9) != 0.0f) {
      goto statement_14100;
    }
    umcur(5) = d1 * umcur(3) - con(8) * umcur(4);
    //C. PROGRAM CONTROL FOR CALCULATION OF JACOBIAN:                         M28.6254
  statement_14100:
    if (jacob >= 4) {
      goto statement_14200;
    }
    switch (jacob) {
    case 1: goto statement_12601;
    case 2: goto statement_12606;
    case 3: goto statement_12611;
    default: break;
    }
    //C. CALCULATION OF TQGEN:                                                M28.6256
  statement_14200:
    d1 = 3.0f * con(3) + 2.0f * con(2) + con(1) + 2.0f * con(10) + con(4);
    d2 = (reacl(kcl + 1) - reacl(kcl + 2)) * umcur(2) * umcur(3);
    d3 = umcur(2) * flxq(jm);
    d4 = umcur(3) * flxd(jm);
    tqgen = (d2 - d3 + d4) * rppair;
    if (inpu == 1) {
      tqgen = tqgen / d1;
    }
    //C. SOLVE OMEGM FROM TORQUE EQUATION:                                    M28.6264
    if (jtmtac(jm) == 0) {
      goto statement_14310;
    }
    tdamp = dcoef(jm) * omegm(jm);
    tcin = (tumtac - tqgen - tdamp) * selta2 / rotmom(jm);
    if (istart == 0) {
      goto statement_14510;
    }
    omegm(jm) = histom(jm) + tcin;
    goto statement_14400;
  statement_14310:
    if (istart == 0) {
      goto statement_14510;
    }
    omegm(jm) = omthev - zthevm * tqgen;
    if (nshare == 0) {
      goto statement_14400;
    }
    omegm(jm) = omegm(jm) - zthem2 * tqgen2 - zthem3 * tqgen3;
    //C. CHECK CRITERIUM FOR OMEGM-ITERATION:                                 M28.6273
  statement_14400:
    d1 = omegm(jm) - omegmp;
    d2 = +epsom(jm);
    d3 = -d2;
    if (d1 > d2) {
      goto statement_14410;
    }
    if (d1 >= d3) {
      goto statement_14500;
    }
  statement_14410:
    omegmp = omegm(jm);
    if (nitrom <= 50) {
      goto statement_14416;
    }
    write(lunit6, "('0ROTOR SPEED ITERATION FAILS  IN 50 STEPS.')");
    write(lunit6, "(' FAILING MACHINE NUMBER :',i3,3x,'TIME =',e14.5)"), jm, t;
    inpu = 50;
    goto statement_79;
  statement_14416:
    goto statement_12020;
    //C. CALCULATION OF TORQUE ANGLE FOR SM:                                  M28.6288
  statement_14500:
    omegm(jm) = omegmp;
  statement_14510:
    if (jtype(jm) > 2) {
      goto statement_14600;
    }
    tangle = thetae - (tau + pi / 2.0f);
    //C. OUTPUT VECTORS FOR 3-AND 2-PHASE ROTORS(POWER COILS):                M33.2010
  statement_14600:
    noutst = nxout + 1;
    //C. OUTPUT VECTOR FOR TORQUE:                                            M28.6293
    if (jtqout(jm) == 0) {
      goto statement_14602;
    }
    nxout++;
    umoutp(nxout) = tqgen;
    if (jtqout(jm) < 2) {
      goto statement_14602;
    }
    nxout++;
    umoutp(nxout) = flxd(jm);
    if (jtqout(jm) != 3) {
      goto statement_14602;
    }
    nxout++;
    umoutp(nxout) = curmd;
  statement_14602:
    if (jomout(jm) == 0) {
      goto statement_14603;
    }
    nxout++;
    umoutp(nxout) = omegm(jm);
    if (jomout(jm) < 2) {
      goto statement_14603;
    }
    nxout++;
    umoutp(nxout) = flxq(jm);
    if (jomout(jm) != 3) {
      goto statement_14603;
    }
    nxout++;
    umoutp(nxout) = curmq;
  statement_14603:
    if (jthout(jm) == 0) {
      goto statement_14606;
    }
    nxout++;
    if (jtype(jm) > 2) {
      goto statement_14604;
    }
    umoutp(nxout) = tangle;
    if (ntyp59 != 1) {
      goto statement_14606;
    }
    if (jthout(jm) == 1) {
      umoutp(nxout) = tangle * 360.0f / twopi + 90.0f;
    }
    if (jthout(jm) == 3) {
      umoutp(nxout) = -crest(kconex);
    }
    goto statement_14606;
  statement_14604:
    umoutp(nxout) = thetam(jm);
    //C. OUTPUT VECTOR FOR UM-ROTOR(POWER):                                   M33.2011
  statement_14606:
    if (loopss(8) == 1 && istart != 0) {
      goto statement_14616;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      dumvec(n1) = umcur(n1);
    }
  statement_14609:
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = ptheta(n2, n1);
      }
    }
    matvec(dummat, dumvec);
    if (ncurpr == 1) {
      goto statement_18100;
    }
  statement_14616:
    if (loopss(8) == 0) {
      goto statement_14619;
    }
    if (istart == 0) {
      goto statement_14619;
    }
    dumvec(1) = curum1;
    dumvec(2) = curum2;
    dumvec(3) = curum3;
  statement_14619:
    if (con(4) == 0.0f) {
      goto statement_14620;
    }
    dumvec(3) = umcur(3) - (con(7) + con(8)) * umcur(4);
  statement_14620:
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = kcl - 1 + n1;
      if (loopss(8) == 1) {
        goto statement_14622;
      }
      if (nodvo1(n2) == nodvo2(n2)) {
        goto statement_14622;
      }
      cursub(nclcom) = -dumvec(n1);
      nclcom++;
      n10 = nodvo1(n2);
      if (n10 > 1) {
        f(n10) += dumvec(n1);
      }
      n10 = nodvo2(n2);
      if (n10 > 1) {
        f(n10) = f(n10) - dumvec(n1);
      }
    statement_14622:
      if (jclout(n2) == 0) {
        goto statement_14625;
      }
      nxout++;
      umoutp(nxout) = dumvec(n1);
      if (jclout(n2) == 2) {
        umoutp(nxout) = umcur(n1);
      }
    statement_14625:
      if (iprsup >= 1) {
        write(lunit6, format_6589), n1, n2, nxout, jclout(n2), umcur(n1),
          umoutp(nxout);
      }
    }
    //C. OUTPUT VECTOR FOR STATOR(EXCIT) IF UM = 3-PHASE IM:                  M33.2026
    if (con(6) != 1.0f) {
      goto statement_14660;
    }
    if (istart != 0) {
      goto statement_14629;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = smat(n2, n1);
      }
    }
  statement_14629:
    FEM_DO_SAFE(n1, 1, 3) {
      dumvec(n1) = umcur(n1 + 3);
    }
    if (istart != 0) {
      goto statement_14631;
    }
    matvec(dummat, dumvec);
    goto statement_14632;
  statement_14631:
    matvec(smat, dumvec);
  statement_14632:
    FEM_DO_SAFE(n1, 1, 3) {
      switch (n1) {
      case 1: goto statement_14635;
      case 2: goto statement_14640;
      case 3: goto statement_14645;
      default: break;
      }
    statement_14635:
      n2 = 4;
      n3 = 1;
      goto statement_14650;
    statement_14640:
      n2 = 5;
      n3 = 2;
      goto statement_14650;
    statement_14645:
      n2 = 6;
      n3 = 3;
    statement_14650:
      n4 = kcl - 1 + n2;
      if (nodvo1(n4) == nodvo2(n4)) {
        goto statement_14652;
      }
      cursub(nclcom) = dumvec(n3);
      nclcom++;
      n10 = nodvo1(n4);
      if (n10 > 1) {
        f(n10) = f(n10) - dumvec(n3);
      }
      n10 = nodvo2(n4);
      if (n10 > 1) {
        f(n10) += dumvec(n3);
      }
    statement_14652:
      if (jclout(n4) == 0) {
        goto statement_14655;
      }
      nxout++;
      umoutp(nxout) = -dumvec(n3);
      if (iprsup >= 1) {
        write(lunit6, format_6589), n1, n2, nxout, jclout(n2), umcur(n1),
          umoutp(nxout);
      }
    statement_14655:;
    }
    goto statement_14700;
    //C. OUTPUT VECTORS FOR STATOR(EXCIT) IN GENERAL:                         M33.2027
  statement_14660:
    FEM_DO_SAFE(n1, 4, ncl) {
      d1 = 1.0f;
      if (n1 == 4 && ntyp59 == 1) {
        d1 = dcoef(jm);
      }
      n2 = kcl - 1 + n1;
      if (nodvo1(n2) == nodvo2(n2)) {
        goto statement_14664;
      }
      cursub(nclcom) = umcur(n1) * d1;
      nclcom++;
      n10 = nodvo1(n2);
      if (n10 > 1) {
        f(n10) = f(n10) - umcur(n1) * d1;
      }
      n10 = nodvo2(n2);
      if (n10 > 1) {
        f(n10) += umcur(n1) * d1;
      }
    statement_14664:
      if (jclout(n2) == 0) {
        goto statement_14665;
      }
      nxout++;
      umoutp(nxout) = -umcur(n1);
      if (ntyp59 == 1) {
        umoutp(nxout) = +umcur(n1) * dcoef(jm);
      }
      if (iprsup >= 1) {
        write(lunit6, format_6589), n1, n2, nxout, jclout(n2), umcur(n1),
          umoutp(nxout);
      }
    statement_14665:;
    }
    //C. OUTPUT VECTOR IF MECH. SYSTEM = ELECTR. NETWORK :                    M28.6369
  statement_14700:
    if (jtmtac(jm) != 0) {
      goto statement_15000;
    }
    n10 = nodom(jm);
    f(n10) = f(n10) - tqgen;
    if (jcltac(kcl + 2) < 0) {
      goto statement_15000;
    }
    cursub(nclcom) = tqgen;
    nclcom++;
    //C  IN CASE THIS UM IS LOWEST NUMBERED UM IN THE SET OF UM'S             M39.3117
    //C    SHARING A COMMON MECH NETWORK :                                    M39.3118
    if (jcltac(kcl + 2) <= 0) {
      goto statement_15000;
    }
    nclcom++;
    if (jcltac(kcl + 1) != 0) {
      nclcom++;
    }
    //C. E(K) AND VINP ADJUSTMENT FOR REM MAGN + OPEN POWER TERMINALS:        M33.2028
  statement_15000:
    if (inpu != 2) {
      goto statement_15005;
    }
    if (istart != 0) {
      goto statement_15005;
    }
    if (jtype(jm) == 6) {
      goto statement_15005;
    }
    if (jtype(jm) == 7) {
      goto statement_15005;
    }
    d1 = flxdrr * flxdrr + flxqrr * flxqrr;
    if (d1 == 0.0f) {
      goto statement_15005;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      if (umcur(n1) != 0.0f) {
        goto statement_15005;
      }
    }
    dumvec(1) = 0.0f;
    dumvec(2) = -omege * flxq(jm);
    dumvec(3) = +omege * flxd(jm);
    if (jtype(jm) > 7) {
      dumvec(2) = 0.0f;
    }
    d1 = vinp(2) * vinp(2) + vinp(3) * vinp(3);
    d2 = dumvec(2) * dumvec(2) + dumvec(3) * dumvec(3);
    if (d1 > d2) {
      goto statement_15005;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      vinp(n1) = dumvec(n1);
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = ptheta(n2, n1);
      }
    }
    matvec(dummat, dumvec);
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = kcl - 1 + n1;
      n4 = kcl + 1;
      n3 = nodvo1(n2);
      if (nodvo2(kcl) != nodvo2(n4)) {
        n3 = nodvo2(n2);
      }
      e(n3) = dumvec(n1);
      if (nodvo2(kcl) != nodvo2(n4)) {
        e(n3) = -dumvec(n1);
      }
    }
    //C. CALCULATION OF HISTORY VECTORS:                                      M28.6404
    //C.DETERMINATION OF ROTOR(POWER)-HIST:                                   M33.2029
  statement_15005:
    if (loopss(8) != 0) {
      goto statement_15100;
    }
    FEM_DO_SAFE(n1, 1, 3) {
      FEM_DO_SAFE(n2, 1, 3) {
        dummat(n1, n2) = 0.0f;
      }
    }
    if (loopss(8) == 1) {
      goto statement_15100;
    }
    d11 = gpar(kcl + 1) * fpar(kcl + 1);
    d12 = gpar(kcl + 2) * fpar(kcl + 2);
    dummat(1, 1) = -gpar(kcl) * fpar(kcl);
    dummat(2, 2) = -d11;
    dummat(3, 3) = -d12;
    matmul(dummat, zthevr);
    d1 = zthev + (con(7) + con(8)) * rd2;
    dummat(3, 3) = dummat(3, 3) - d1 * d12;
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = kcl - 1 + n1;
      d1 = (gpar(n2) * reacl(n2) / selta2 - 1.0f) * fpar(n2);
      dummat(n1, n1) += d1;
    }
    d1 = (1.0f - con(4)) * omege * d11 * reacl(kcl + 2);
    dummat(2, 3) = dummat(2, 3) - d1;
    d1 = (1.0f - con(4)) * omege * d12 * reacl(kcl + 1);
    dummat(3, 2) += d1;
    FEM_DO_SAFE(n1, 1, 3) {
      dumvec(n1) = umcur(n1);
    }
    matvec(dummat, dumvec);
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = kcl - 1 + n1;
      hist(n2) = dumvec(n1) - gpar(n2) * fpar(n2) * vinp(n1);
    }
    d5 = d11 * (flxd(jm) / selta2 - flxq(jm) * omege);
    hist(kcl + 1) += d5;
    d5 = d12 * (flxd(jm) * omege + flxq(jm) / selta2);
    hist(kcl + 2) += d5;
    d1 = (con(7) + con(8)) * d12;
    hist(kcl + 2) += flxd(jm) * d1 / selta2;
    //C. ROTOR(POWER)-HIST FOR SPECIAL DM:                                    M33.2031
    if (con(8) != 1.0f) {
      goto statement_15050;
    }
    d9 = rd2 - reacl(kcl + 4) / selta2;
    d10 = zthev + d9;
    hist(kcl + 2) += con(8) * d12 * d10 * umcur(5);
  statement_15050:
    if (con(7) != 1.0f) {
      goto statement_15100;
    }
    hist(kcl + 2) += con(7) * d12 * zthev * umcur(5);
    //C. DETERMINATION OF STATOR(EXCIT)-HIST:                                 M33.2032
  statement_15100:
    FEM_DO_SAFE(n1, kcld1, kclqe) {
      n2 = n1 - kcl + 1;
      d1 = gpar(n1) * fpar(n1);
      d2 = d1 * reacl(n1) / selta2;
      d3 = (-fpar(n1) + d2) * umcur(n2);
      hist(n1) = -d1 * vinp(n2) + d3;
    }
    if (ncld(jm) == 0) {
      goto statement_15115;
    }
    d13 = gpar(kcl + 3) * fpar(kcl + 3);
    FEM_DO_SAFE(n1, kcld1, kclde) {
      d1 = flxd(jm) * gpar(n1) * fpar(n1) / selta2;
      hist(n1) += d1;
    }
    hist(kcl + 3) = hist(kcl + 3) - flxd(jm) * con(8) * d13 / selta2;
  statement_15115:
    if (nclq(jm) == 0) {
      goto statement_15200;
    }
    FEM_DO_SAFE(n1, kclq1, kclqe) {
      d1 = flxq(jm) * gpar(n1) * fpar(n1) / selta2;
      hist(n1) += d1;
    }
    //C. STATOR(EXCIT)-HIST FOR SPECIAL DM:                                   M33.2033
    if (con(8) != 1.0f) {
      goto statement_15150;
    }
    hist(kcl + 3) += con(8) * d13 * d10 * umcur(3);
    d9 = (zthev + rd2) * d13 / selta2;
    hist(kcl + 3) = hist(kcl + 3) - con(8) * d9 * umcur(4);
  statement_15150:
    if (con(7) != 1.0f) {
      goto statement_15200;
    }
    hist(kcl + 3) += con(7) * d13 * zthev * umcur(3);
    d9 = zthev * d13 / selta2;
    hist(kcl + 3) = hist(kcl + 3) - con(7) * d9 * umcur(4);
    //C. STATOR(EXCIT)-HIST FOR UM = TYPE 4 (C3IM):                           M33.2034
  statement_15200:
    if (con(6) == 0.0f) {
      goto statement_15210;
    }
    n1 = kcle - kcl + 1;
    d1 = gpar(kcle) * fpar(kcle);
    d2 = d1 * reacl(kcle) / selta2 - fpar(kcle);
    hist(kcle) = d2 * umcur(n1) - d1 * vinp(n1);
    //C. IMPLEMENTATION OF INFLUENCE OF THEV IMPEDANCES :                     M28.6477
  statement_15210:
    n15 = kcle;
    if (ncl > 6) {
      n15 = kcl + 5;
    }
    n16 = n15 - kcl - 2;
    FEM_DO_SAFE(n1, 1, 3) {
      if (n1 > n16) {
        goto statement_15225;
      }
      dumvec(n1) = umcur(n1 + 3);
      goto statement_15230;
    statement_15225:
      dumvec(n1) = 0.0f;
    statement_15230:;
    }
    matvec(zths3, dumvec);
    FEM_DO_SAFE(n1, kcld1, n15) {
      n2 = n1 - kcl - 2;
      dumvec(n2) = gpar(n1) * fpar(n1) * dumvec(n2);
      hist(n1) = hist(n1) - dumvec(n2);
    }
    if (ncl <= 6) {
      goto statement_15300;
    }
    n15 = kcld1 + 3;
    FEM_DO_SAFE(n1, n15, kcle) {
      n2 = n1 - kcl + 1;
      d1 = gpar(n1) * fpar(n1) * zthevs(n2);
      hist(n1) = hist(n1) - d1 * umcur(n2);
    }
    //C. DETERMINATION OF HISTOM:                                             M28.6498
  statement_15300:
    histom(jm) = 0.0f;
    if (jtmtac(jm) == 0) {
      goto statement_16000;
    }
    histom(jm) = omegm(jm) + tcin;
    //C. OUTPUT STATEMENTS FOR UM:                                            M28.6502
  statement_16000:
    n1 = istart + jm - 1;
    if (n1 != 0) {
      goto statement_16008;
    }
    if (iprsup >= 1) {
      write(lunit6, format_16005);
    }
    goto statement_16016;
  statement_16008:
    if (istart != 0) {
      goto statement_16012;
    }
    goto statement_16020;
  statement_16012:
    itolto = itol + iout;
    if (iout == 0) {
      goto statement_16100;
    }
    if (istart != itolto) {
      goto statement_16100;
    }
    if (jm > 1) {
      goto statement_16020;
    }
  statement_16016:
    if (iprsup >= 2) {
      write(lunit6, format_16005);
    }
    if (iprsup >= 2) {
      write(lunit6,
        "('0TIME =',e14.5,'***************************  NCOMP =',i3)"),
        t, cmn.ncomp;
    }
  statement_16020:
    if (jm == numum) {
      itol = istart;
    }
    //C. MOMENTARY TEST OUTPUT :                                              M28.6522
    if (iprsup >= 2) {
      write(lunit6, "('0*** TEST OUTPUT :')");
    }
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6,
          "('0UMCUR(1)=',e14.5,2x,'UMCUR(2)=',e14.5,2x,'UMCUR(3)=',e14.5)");
        FEM_DO_SAFE(n1, 1, 3) {
          wloop, umcur(n1);
        }
      }
    }
    if (con(6) != 1.0f) {
      goto statement_16056;
    }
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6,
          "(' UMCUR(4)=',e14.5,2x,'UMCUR(5)=',e14.5,2x,'UMCUR(6)=',e14.5)");
        FEM_DO_SAFE(n1, 4, 6) {
          wloop, umcur(n1);
        }
      }
    }
  statement_16056:
    if (iprsup >= 2) {
      write(lunit6,
        "('     FLXD=',e14.5,2x,'    FLXQ=',e14.5,2x,'  NITROM=',i3)"),
        flxd(jm), flxq(jm), nitrom;
    }
    n2 = kcl + ncl - 1;
    if (istart > 1) {
      goto statement_16077;
    }
    if (iprsup <= 3) {
      goto statement_16077;
    }
    {
      write_loop wloop(cmn, lunit6, "('0NODVO1 :',3x,15i4)");
      FEM_DO_SAFE(n1, kcl, n2) {
        wloop, nodvo1(n1);
      }
    }
    {
      write_loop wloop(cmn, lunit6, "(' NODVO2 :',3x,15i4)");
      FEM_DO_SAFE(n1, kcl, n2) {
        wloop, nodvo2(n1);
      }
    }
    write(lunit6, "(' NODOM  :',3x,15i4)"), nodom(jm);
  statement_16077:
    if (iprsup >= 2) {
      write(lunit6, "('0ZTHEVM = ',e14.5)"), zthevm;
    }
    if (iprsup >= 2) {
      {
        write_loop wloop(cmn, lunit6,
          "('0ZTHEVR(3,3):',3x,3e14.5,/(16x,3e14.5))");
        FEM_DO_SAFE(n1, 1, 3) {
          FEM_DO_SAFE(n2, 1, 3) {
            wloop, zthevr(n1, n2);
          }
        }
      }
    }
    if (iprsup >= 2) {
      {
        write_loop wloop(cmn, lunit6,
          "('0ZTHS3(3,3):',3x,3e14.5,/(15x,3e14.5))");
        FEM_DO_SAFE(n1, 1, 3) {
          FEM_DO_SAFE(n2, 1, 3) {
            wloop, zths3(n1, n2);
          }
        }
      }
    }
    //C. END MOMENTARY                                                        M28.6557
    //C  FINAL STATEMENTS OF MACHINE DO-LOOP *************************        M33.2035
  statement_16100:
    if (nshare != 0) {
      fpar(kcl + 2) = tqgen;
    }
    //C. IN CASE OF SM TYPE-59 : STORING AND INJECT NEW EXCITER TORQUE        M38.3533
    if (ntyp59 != 1) {
      goto statement_18000;
    }
    jtype(jm) = 13;
    inpu = inpust;
    if (nmexc == 0) {
      goto statement_18000;
    }
    d1 = e(nmexc);
    d2 = e(nexc);
    d3 = umcur(4) * dcoef(jm);
    crest(kconex) = -d2 * d3 / d1;
    fpar(kcl + 3) = -kconex;
    fpar(kcl + 4) = nmexc;
    fpar(kcl + 5) = nexc;
    //C. PREDICTION OF FLUXES FOR INTERNAL UM VOLTAGE OF NEXT TIME-           M33.2036
    //C      STEP IF NO COMPENSATION FOR POWER COILS.                         M33.2037
    //C      UMCURP(1) TO STORE ZERO CURRENT                                  M33.2038
    //C      UMCURP(3NUMUM:6NUMUM) TO STORE VPI/RP FOR NEXT TIME-STEP.        M33.2039
  statement_18000:
    if (loopss(8) != 1) {
      goto statement_99999;
    }
    ncurpr = 1;
    d19 = gpar(kcl) * fpar(kcl);
    d20 = gpar(kcl) * reacl(kcl);
    n1 = 3 * (jm - 1);
    n2 = 3 * (numum + jm - 1);
    //C      TRANSFORMATION TO ZERO-FREQ DOMAIN :                             M33.2046
    d10 = (tau - thetae) * (1.0f - con(1) - con(4));
    if (inpu == 1) {
      d10 = d10 * omegrf;
    }
    d11 = cosz(d10);
    d12 = sinz(d10);
    d15 = flxd(jm);
    d16 = flxq(jm);
    flxd(jm) = d11 * d15 - d12 * d16;
    flxq(jm) = d12 * d15 + d11 * d16;
    d15 = umcur(2);
    d16 = umcur(3);
    umcur(2) = d11 * d15 - d12 * d16;
    umcur(3) = d12 * d15 + d11 * d16;
    flxdd = flxd(jm) + reacl(kcl + 1) * umcur(2);
    flxqq = flxq(jm) + reacl(kcl + 2) * umcur(3);
    //C      INITIALIZATION AT TIME = 0.0                                     M33.2061
    if (istart != 0) {
      goto statement_18020;
    }
    flxdmh = flxd(jm);
    flxqmh = flxq(jm);
    umcurp(n1 + 1) = 0.0f;
    hist(kcl) = 0.0f;
    hist(kcl + 1) = flxdd;
    hist(kcl + 2) = flxqq;
    //C      LINEAR PREDICTION OF FLUXES :                                    M33.2069
  statement_18020:
    flxddp = 2.0f * flxdd - hist(kcl + 1);
    flxqqp = 2.0f * flxqq - hist(kcl + 2);
    //C       CALCULATION OF VPI/RP FOR NEXT TIME-STEP                        M33.2072
    //C     DUMVEC(1) = D20 * (UMCURP(N1+1) - UMCUR(1))/SELTAT                M42.6761
    dumvec(1) = 0.0f;
    //C     D1 = (HIST(KCL+1) - FLXDD)/SELTAT                                 M33.2075
    d1 = (flxdmh - flxd(jm)) / seltat;
    dumvec(2) = (d1 - omegrf * flxqqp) * gpar(kcl + 1);
    //C     D1 = (HIST(KCL+2) - FLXQQ)/SELTAT                                 M33.2078
    d1 = (flxqmh - flxq(jm)) / seltat;
    dumvec(3) = (d1 + omegrf * flxddp) * gpar(kcl + 2);
    d20 = fpar(kcl) * (d20 / selta2 - 1.0f);
    umcurp(n1 + 1) = umcur(1);
    hist(kcl + 1) = flxdd;
    hist(kcl + 2) = flxqq;
    thetae = tau + deltat * omegrf;
    thetae = thetae * (1.0f - con(1) - con(4));
    if (inpu == 1) {
      thetae = omegrf * thetae;
    }
    goto statement_12200;
  statement_18100:
    FEM_DO_SAFE(n1, 1, 3) {
      n2 = 3 * (numum + jm - 1) + n1;
      umcurp(n2) = dumvec(n1);
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' **************************************',"
        "' PREDICTED A,B,C POWER VOLTAGES/RESISTANCE',"
        "' FOR NEXT TIME-STEP OF UM NUMBER',i4,' :')"),
        jm;
    }
    n1 = 3 * (numum + jm - 1) + 1;
    n2 = n1 + 2;
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, lunit6,
          "(5x,' UMCURP(',i3,':',i3,') :',3(3x,e14.5))");
        wloop, n1, n2;
        FEM_DO_SAFE(n3, n1, n2) {
          wloop, umcurp(n3);
        }
      }
    }
    if (jm != numum) {
      goto statement_99999;
    }
    loopss(8) = 3;
    //C. CONTINUATION OF MACHINE DO-LOOP:                                     M28.6558
  statement_99999:;
  }
  //C  START SECOND MACH DO-LOOP IN CASE A SET OF UM'S SHARING              M39.3126
  //C   A COMMON MECHANICAL NETWORK IS PRESENT :                            M39.3127
  if (mshare == 0) {
    goto statement_20000;
  }
  FEM_DO_SAFE(jm, 1, numum) {
    kcl = kcoil(jm);
    nshare = jcltac(kcl) + jcltac(kcl + 1);
    if (nshare == 0) {
      goto statement_30010;
    }
    //C  PREDICTING TORQUES OF HIGHER NUMBERED UM'S IN THE SET :              M39.3133
    //C    NOTE : FPAR(KCL+2) IS TQGEN AT TIME T                              M39.3134
    //C    NOW PREDICT TQGEN FOR NEXT TIME-STEP (FOR T+DELTAT)                M39.3135
    voltum(jm) = 2.0f * fpar(kcl + 2) - anglum(jm);
    if (istart == 0) {
      voltum(jm) = fpar(kcl + 2);
    }
    anglum(jm) = fpar(kcl + 2);
    //C  SETTING  CURSUB FOR TQGEN OF HIGHER NUMBERED UM'S IN SET :           M39.3139
    if (jcltac(kcl + 2) >= 0) {
      goto statement_30010;
    }
    n1 = -jcltac(kcl + 2);
    cursub(n1) = fpar(kcl + 2);
  statement_30010:;
  }
statement_20000:
  istart++;
statement_21000:
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' EXIT  \"SOLVUM\" .  ISTART LOOPSS1',' LOOPSS8   NUMUM',13x,'T',/,"
      "17x,4i8,e14.5,/)"),
      istart, loopss(1), loopss(8), numum, t;
  }
}



void subts1(
  common& cmn)
{
  FEM_CMN_SVE(subts1);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  double& deltat = cmn.deltat;
  double& delta2 = cmn.delta2;
  double& epsiln = cmn.epsiln;
  double& t = cmn.t;
  double& fltinf = cmn.fltinf;
  double& flzero = cmn.flzero;
  auto& voltbc = cmn.voltbc;
  const auto& moncar = cmn.moncar;
  int& max99m = cmn.max99m;
  auto& lstat = cmn.lstat;
  auto& iprsov= cmn.iprsov;
  int& inonl = cmn.inonl;
  int& istep = cmn.istep;
  int& it1 = cmn.it1;
  int& it2 = cmn.it2;
  int& kcount = cmn.kcount;
  int& lymat = cmn.lymat;
  int& lswtch = cmn.lswtch;
  int& m4plot = cmn.m4plot;
  int& lpast = cmn.lpast;
  int& ncomp = cmn.ncomp;
  int& nv = cmn.nv;
  auto& ktrlsw = cmn.ktrlsw;
  int& num99 = cmn.num99;
  int& kpartb = cmn.kpartb;
  int& lastov = cmn.lastov;
  int& ialter = cmn.ialter;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  const auto& loopss = cmn.loopss;
  int& nenerg = cmn.nenerg;
  const auto& x = static_cast<common_c0b001&>(cmn).x;
  auto& ykm = cmn.ykm;
  auto& km = cmn.km;
  auto& bvalue = cmn.bvalue;
  const auto& sptacs = cmn.sptacs;
  const auto& kswtyp = cmn.kswtyp;
  auto& modswt = cmn.modswt;
  const auto& topen = cmn.topen;
  auto& crit = cmn.crit;
  const auto& kdepsw = cmn.kdepsw;
  const auto& isourc = cmn.isourc;
  auto& energy = cmn.energy;
  const auto& iardub = cmn.iardub;
  auto& ardube = cmn.ardube;
  const auto& nonlad = cmn.nonlad;
  const auto& nonle = cmn.nonle;
  auto& vnonl = cmn.vnonl;
  auto& curr = cmn.curr;
  auto& anonl = cmn.anonl;
  const auto& vecnl1 = cmn.vecnl1;
  auto& vecnl2 = cmn.vecnl2;
  auto& vzer5 = cmn.vzer5;
  auto& ilast = cmn.ilast;
  const auto& nltype = cmn.nltype;
  auto& cchar = cmn.cchar;
  auto& vchar = cmn.vchar;
  auto& gslope = cmn.gslope;
  const auto& ktrans = cmn.ktrans;
  auto& kk = cmn.kk;
  const auto& nr = cmn.nr;
  auto& cik = cmn.cik;
  auto& ck = cmn.ck;
  auto& tstop = cmn.tstop;
  const auto& nonlk = cmn.nonlk;
  const auto& nonlm = cmn.nonlm;
  auto& spum = cmn.spum;
  const auto& kks = cmn.kks;
  const auto& kknonl = cmn.kknonl;
  auto& znonl = cmn.znonl;
  auto& finit = cmn.finit;
  const auto& isubeg = cmn.isubeg;
  const auto& kbus = cmn.kbus;
  const auto& node = cmn.node;
  auto& crest = cmn.crest;
  const auto& kmswit = cmn.kmswit;
  const auto& nextsw = cmn.nextsw;
  auto& tclose = cmn.tclose;
  auto& adelay = cmn.adelay;
  auto& kpos = cmn.kpos;
  auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  auto& kssfrq = cmn.kssfrq;
  const auto& kode = cmn.kode;
  const auto& kpsour = cmn.kpsour;
  const auto& bus = cmn.bus;
  int& iureac = cmn.iureac;
  int& iugpar = cmn.iugpar;
  int& iufpar = cmn.iufpar;
  int& iuhist = cmn.iuhist;
  int& iuumrp = cmn.iuumrp;
  int& iunod1 = cmn.iunod1;
  int& iunod2 = cmn.iunod2;
  int& iujclt = cmn.iujclt;
  int& iujclo = cmn.iujclo;
  int& iujtyp = cmn.iujtyp;
  int& iunodo = cmn.iunodo;
  int& iujtmt = cmn.iujtmt;
  int& iuhism = cmn.iuhism;
  int& iuomgm = cmn.iuomgm;
  int& iuomld = cmn.iuomld;
  int& iutham = cmn.iutham;
  int& iuredu = cmn.iuredu;
  int& iureds = cmn.iureds;
  int& iuflds = cmn.iuflds;
  int& iufldr = cmn.iufldr;
  int& iurequ = cmn.iurequ;
  int& iuflqs = cmn.iuflqs;
  int& iuflqr = cmn.iuflqr;
  int& iujcds = cmn.iujcds;
  int& iujcqs = cmn.iujcqs;
  int& iuflxd = cmn.iuflxd;
  int& iuflxq = cmn.iuflxq;
  int& iunppa = cmn.iunppa;
  int& iurotm = cmn.iurotm;
  int& iuncld = cmn.iuncld;
  int& iunclq = cmn.iunclq;
  int& iujtqo = cmn.iujtqo;
  int& iujomo = cmn.iujomo;
  int& iujtho = cmn.iujtho;
  int& iureqs = cmn.iureqs;
  int& iuepso = cmn.iuepso;
  int& iudcoe = cmn.iudcoe;
  int& iukcoi = cmn.iukcoi;
  int& iuvolt = cmn.iuvolt;
  int& iuangl = cmn.iuangl;
  int& iunodf = cmn.iunodf;
  int& iunodm = cmn.iunodm;
  int& iukumo = cmn.iukumo;
  int& iujumo = cmn.iujumo;
  int& iuumou = cmn.iuumou;
  fem::str<80>& buff77 = cmn.buff77;
  fem::str<80>& prom80 = cmn.prom80;
  auto& a8sw = cmn.a8sw;
  //
  int& nwarn = sve.nwarn;
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text10 = sve.text10;
  fem::str<8>& text11 = sve.text11;
  fem::str<8>& text12 = sve.text12;
  fem::str<8>& text13 = sve.text13;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  fem::str<8>& text8 = sve.text8;
  fem::str<8>& text9 = sve.text9;
  if (is_called_first_time) {
    text1 = "VALVE ";
    text2 = "DIODE ";
    text3 = "OPENIN";
    text4 = "CLOSIN";
    text5 = "GAP   ";
    text6 = "SWITCH";
    text8 = "CLOSED";
    text9 = " OPEN ";
    text10 = "SPY   ";
    text11 = "PASS  ";
    text12 = "STOP  ";
    text13 = "YKK   ";
    nwarn = 0;
  }
  auto& lunit6 = cmn.lunit6;
  int ndx1 = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  int n19 = fem::int0;
  int n18 = fem::int0;
  int ii = fem::int0;
  int i = fem::int0;
  double vsl = fem::double0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  double tcl = fem::double0;
  int nn1 = fem::int0;
  int isss = fem::int0;
  double gus4 = fem::double0;
  int iit1 = fem::int0;
  double a = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  fem::str<8> text7 = fem::char0;
  double timswt = fem::double0;
  int L = fem::int0;
  int n4 = fem::int0;
  double gus1 = fem::double0;
  int n13 = fem::int0;
  int k1 = fem::int0;
  int ndx2 = fem::int0;
  int ndx3 = fem::int0;
  int n = fem::int0;
  int n5 = fem::int0;
  int i1 = fem::int0;
  double d1 = fem::double0;
  int m = fem::int0;
  int m1 = fem::int0;
  int n3 = fem::int0;
  arr_1d<100, double> swcold(fem::fill0);
  double d5 = fem::double0;
  int mk = fem::int0;
  double delti = fem::double0;
  double didt = fem::double0;
  double d14 = fem::double0;
  double gus2 = fem::double0;
  int k9899 = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  int n9 = fem::int0;
  int n10 = fem::int0;
  int n12 = fem::int0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  int n11 = fem::int0;
  double d9 = fem::double0;
  double d10 = fem::double0;
  double d6 = fem::double0;
  double d11 = fem::double0;
  int n14 = fem::int0;
  double d13 = fem::double0;
  double d12 = fem::double0;
  double d15 = fem::double0;
  double d16 = fem::double0;
  int n8 = fem::int0;
  int ip = fem::int0;
  double gus3 = fem::double0;
  int n17 = fem::int0;
  int jj = fem::int0;
  double acheck = fem::double0;
  int n15 = fem::int0;
  int ll10 = fem::int0;
  int j11 = fem::int0;
  double bi = fem::double0;
  double ai = fem::double0;
  int knode = fem::int0;
  int mnode = fem::int0;
  int nn15 = fem::int0;
  static const char* format_806 =
    "(51x,a6,' ''',a6,''' TO ''',a6,'''  ',a6,'G AFTER',e12.5,' SEC.')";

  auto ispum = ArraySpan(reinterpret_cast<int*>(&spum(1)), spum.size() * 2);

  auto& knt = moncar(1);
  auto& kbase = moncar(2);
  auto& ipoint = iprsov(35);
  auto& iupper = iprsov(36);

  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& kxtcs = isptacs(17);

  if (iprsup >= 1) {
    write(lunit6,
      "(' BEGIN 1ST PIECE OF TIME-STEP LOOP.   ISTEP  ISPRIN',"
      "'  ISPLOT  KSWTCH   INONL   NUM99  IUPPER     KNT  NENERG',/,35x,10i8)"),
      istep, cmn.isprin, cmn.isplot, kswtch, inonl, num99, iupper, knt,
      nenerg;
  }
  if (cmn.numsm > 0) {
    update(cmn);
  }
  if (kswtch <= 0) {
    kcount = nv;
  }
  if (kswtch <= 0) {
    goto statement_1009;
  }
  if (istep > 0) {
    goto statement_3780;
  }
  //C     ADD CODE FOR RANDOM OPENING WITH CURRENT MARGIN (FROM OVER5):     M35.1511
  ndx1 = lswtch + 1;
  FEM_DO_SAFE(j, 1, kswtch) {
    ndx1 = ndx1 - 1;
    if (crit(ndx1) == 0.0f) {
      goto statement_3756;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(' RANDOM OPEN, SET CRIT.','  J, CRIT(J), CRIT(NDX1), TOPEN(J) =',i6,"
        "3e15.5)"),
        j, crit(j), crit(ndx1), topen(j);
    }
    crit(j) = crit(ndx1);
  statement_3756:;
  }
statement_3780:
  //C                                   CHECKING SWITCH-POSITIONS FOR CHANGE   12609
  if (iprsup >= 3) {
    write(lunit6,
      "(/,' MORE SCALARS.  LASTOV,   KBASE    NTOT','  KPARTB   NCOMP',14x,"
      "'T',9x,'TENERG',9x,'DELTAT',/,14x,5i8,3e15.6)"),
      lastov, kbase, ntot, kpartb, ncomp, t, cmn.tenerg, deltat;
  }
  if (iprsup < 4) {
    goto statement_1326;
  }
  write(lunit6,
    "(/,' SWITCH TABLE AT BEGINNING OF ''SUBTS1''.',/,"
    "'     ROW    KPOS    BUS1    BUS2  KSWTYP',9x,'TCLOSE',9x,'ADELAY',10x,"
    "'TOPEN',11x,'CRIT')");
  FEM_DO_SAFE(k, 1, kswtch) {
    ndx1 = lswtch + k;
    write(lunit6, "(5i8,4e15.6)"), k, kpos(k), kmswit(k), kmswit(ndx1),
      kswtyp(k), tclose(k), adelay(k), topen(k), crit(k);
  }
statement_1326:
  if (istep <= 0) {
    goto statement_800;
  }
  n19 = 0;
  n18 = 0;
  k = ktrlsw(4);
  if (k == 0) {
    goto statement_1216;
  }
statement_1214:
  ii = kpos(k);
  it1 = kswtyp(k);
  i = fem::iabs(ii);
  vsl = 0.f;
  if (i == 5) {
    goto statement_1002;
  }
  if (i == 0) {
    goto statement_1002;
  }
  ndx1 = lswtch + k;
  n1 = kmswit(k);
  n2 = kmswit(ndx1);
  tcl = tclose(k);
  nn1 = n1;
  if (it1 == 9976) {
    goto statement_3718;
  }
  if (it1 > 0) {
    nn1 = kbus(it1);
  }
  isss = isourc(k);
  if (isss > 0) {
    nn1 = -node(isss + 1);
  }
statement_3718:
  if (i == 10) {
    goto statement_2100;
  }
  if (i == 11) {
    goto statement_2108;
  }
  if (i == 4) {
    goto statement_2103;
  }
  if (it1 == 9976) {
    goto statement_2110;
  }
  if (it1 <= 0) {
    goto statement_2110;
  }
  gus4 = (e(nn1) - e(n2)) * delta2;
  ci1 = ck(it1);
  ck1 = ci1 + gus4;
  ck(it1) = ck1 + gus4;
  if (std::abs(ck1) >= crit(k) || std::abs(ck1) > std::abs(ci1)) {
    goto statement_1002;
  }
  gus4 = gus4 / delta2;
  iit1 = -nr(it1);
  ck1 = x(iit1) * gus4;
  cik(it1 + 1) += ck1 + cik(it1);
  cik(it1) = -ck1;
  goto statement_2113;
statement_2103:
  ck1 = e(n2) - e(n1);
  a = (ck1 + energy(k)) / 2.0f;
  energy(k) = ck1;
  if (a < 0.0f) {
    goto statement_1002;
  }
  i = 3;
  goto statement_2105;
  //C                          PART OF CHECKING SWITCH-POSITIONS FOR CHANGES   12649
statement_2100:
  if (t < tcl) {
    goto statement_1002;
  }
  if (it1 <= 0) {
    goto statement_2101;
  }
  iit1 = -nr(it1);
  e(n1) = e(n2);
  gus4 = e(nn1) - e(n2);
  cik(it1) = -x(iit1) * gus4;
  gus4 = gus4 * delta2;
  ck1 = ck(it1);
  a = ck1 + gus4;
  ck(it1) = a + gus4;
  if (std::abs(a) < topen(k) || std::abs(a) < std::abs(ck1)) {
    goto statement_1002;
  }
  d2 = x(iit1 + 1) / delta2;
  ci1 = cik(it1 + 1) + d2 * gus4;
  ck1 = x(iit1) / (delta2 * d2);
  d3 = a * (ck1 + 1.0f) - ci1 / d2;
  crit(k) = std::abs(d3 / ck1);
  goto statement_2102;
statement_2101:
  ck1 = e(nn1) - e(n2);
  if (std::abs(ck1) < topen(k)) {
    goto statement_1002;
  }
  adelay(k) = t + adelay(ndx1);
  if (isss != 0) {
    goto statement_8455;
  }
  if (n2 == 1) {
    e(nn1) = e(n2);
  }
  if (n2 != 1) {
    e(n2) = e(nn1);
  }
  goto statement_2102;
statement_8455:
  d4 = std::abs(crest(isss));
  if (ck1 < 0.0f) {
    d4 = -d4;
  }
  ck1 = d4;
  crest(isss) = -ck1;
  crest(isss + 1) = ck1;
  tstop(isss) = fltinf;
  tstop(isss + 1) = fltinf;
  energy(k) = 0.f;
statement_2102:
  i = 1;
statement_2105:
  tclose(k) = 0.f;
  if (tcl >= 0.f) {
    tcl = t;
  }
  if (nenerg != 0) {
    goto statement_620;
  }
  text7 = text8;
  timswt = tcl;
statement_620:
  n19++;
  modswt(n19) = k;
  goto statement_2115;
statement_2108:
  if (t < tcl) {
    goto statement_1002;
  }
  i = 2;
  if (topen(k) == fltinf) {
    goto statement_2105;
  }
  //C     IF ( II.GT.0 .AND. TOPEN(K) .GT. TMAX) I=0                   ! DANM42.6678
  goto statement_2105;
statement_2110:
  L = n1;
  if (nextsw(k) < 0) {
    L = n2;
  }
  a = -f(L);
  it2 = kks(L);
statement_2111:
  it2 = it2 - 1;
  j = km(it2);
  if (j < 0) {
    goto statement_2116;
  }
  a += ykm(it2) * e(j);
  goto statement_2111;
statement_2116:
  j = fem::iabs(j);
  a += ykm(it2) * e(j);
  if (iprsup >= 7) {
    write(lunit6,
      "('    K    BUS1    BUS2    L  NEXTSW(K)',7x,'F(L)',10x,'A',/,2x,i3,"
      "2(2x,a6),2x,i3,i11,2(2x,e15.5))"),
      k, bus(n1), bus(n2), L, nextsw(k), f(L), a;
  }
  if (iprsup >= 5) {
    write(lunit6,
      "(/,1x,'       K       L      II       I    ISSS     IT1',/,1x,6i8,/,7x,"
      "'TCLOSE(K)',14x,'T',7x,'TOPEN(K)',8x,'CRIT(K)',6x,'ADELAY(K)',/,1x,"
      "5e15.6)"),
      k, L, ii, i, isss, it1, tclose(k), t, topen(k), crit(k), adelay(
        k);
  }
  n4 = n1;
  if (n4 == L) {
    n4 = n2;
  }
  f(n4) = f(n4) - a;
  if (nextsw(k) > 0) {
    a = -a;
  }
  gus1 = a * tclose(k);
  if (gus1 == 0.0f && tclose(k) != 0.f) {
    gus1 = -1.0f;
  }
  tclose(k) = a;
  if (ii <= 0) {
    vsl = a;
  }
  if (i == 3) {
    gus1 = -a;
  }
  if (isss <= 0) {
    goto statement_2112;
  }
  gus4 = (e(nn1) - e(n2)) * a;
  energy(k) += gus4;
  if (gus4 < 0) {
    goto statement_2113;
  }
statement_2112:
  if (i > 1 && t < topen(k)) {
    goto statement_1002;
  }
  if (std::abs(a) < crit(k)) {
    gus1 = -1.0f;
  }
  if (t < adelay(k)) {
    gus1 = 1.0f;
  }
  if (gus1 >= 0.f) {
    goto statement_1002;
  }
statement_2113:
  i++;
  if (i != 2) {
    goto statement_2118;
  }
  i = 10;
  if (isss == 0) {
    goto statement_2118;
  }
  tstop(isss) = 0.f;
  tstop(isss + 1) = 0.f;
  a = energy(k) * deltat;
  if (nenerg != 0) {
    goto statement_2118;
  }
  write(lunit6,
    "(' ENERGY ABSORBED IN SWITCHED RESISTANCE ''',a6,''' TO ''',a6,'''',"
    "e15.6)"),
    bus(nn1), bus(n2), a;
statement_2118:
  tclose(k) = 0.f;
  if (i == 3) {
    i = 5;
  }
  energy(k) = 0.0f;
  n19++;
  modswt(n19) = -k;
  if (nenerg != 0) {
    goto statement_2115;
  }
  text7 = text9;
  timswt = t;
statement_2115:
  if (ialter == 0) {
    ialter = 1;
  }
  if (nenerg != 0) {
    goto statement_2107;
  }
  write(lunit6,
    "(' ***',65x,'SWITCH  \"',a6,'\"  TO  \"',a6,'\"  ',a6,' AFTER',e14.6,"
    "' SEC.')"),
    bus(nn1), bus(n2), text7, timswt;
statement_2107:
  j = fem::iabs(i);
  if (ii < 0) {
    j = -j;
  }
  ii = j;
  kpos(k) = ii;
statement_1002:
  if (n18 != 0) {
    goto statement_1221;
  }
  k = fem::iabs(nextsw(k));
  if (k != ktrlsw(4)) {
    goto statement_1214;
  }
statement_1216:
  n18 = 1;
  k = 0;
statement_1221:
  k++;
  if (k > kswtch) {
    goto statement_1227;
  }
  if (nextsw(k) == 0) {
    goto statement_1214;
  }
  goto statement_1221;
statement_1227:
  kcount = nv;
  FEM_DO_SAFE(k, 1, kswtch) {
    if (kpos(k) >= 0) {
      goto statement_1239;
    }
    kcount++;
    bvalue(kcount) = tclose(k);
    if (nextsw(k) == 0) {
      bvalue(kcount) = 0.0f;
    }
  statement_1239:;
  }
  //C          IF U.M. IMITATION OF S.M. MODELING (LOOPSS(1)=6644),  THEN   M32.5050
  //C          GO BACK INTO SOLVUM TO PASS MACHINE QUANTITIES (INCLUDING    M32.5051
  //C          JUST-CALCULATED TORQUE IN TCLOSE OF SWITCH) TO TACS:         M32.5052
statement_1009:
  if (loopss(1) == 6644) {
    solvum(cmn, spum(iureac), spum(iugpar), spum(iufpar), spum(iuhist), spum(iuumrp), 
      ispum(iunod1), ispum(iunod2), ispum(iujclt), ispum(iujclo), ispum(iujtyp), 
      ispum(iunodo), ispum(iujtmt), spum(iuhism), spum(iuomgm), spum(iuomld), 
      spum(iutham), spum(iuredu), spum(iureds), spum(iuflds), spum(iufldr), 
      spum(iurequ), spum(iuflqs), spum(iuflqr), ispum(iujcds), ispum(iujcqs), 
      spum(iuflxd), spum(iuflxq), ispum(iunppa), spum(iurotm), ispum(iuncld), 
      ispum(iunclq), ispum(iujtqo), ispum(iujomo), ispum(iujtho), spum(iureqs), 
      spum(iuepso), spum(iudcoe), ispum(iukcoi), spum(iuvolt), spum(iuangl), 
      ispum(iunodf), ispum(iunodm), ispum(iukumo), ispum(iujumo), spum(iuumou));
  }
  if (kill > 0) {
    goto statement_9200;
  }
  //CCCC  write (*,*) ' TACS?  ktab, istep, newtac =',  ktab, istep, newtac
  if (cmn.ktab <= 0 || istep <= 0) {
    goto statement_3865;
  }
  if (cmn.newtac != 1) {
    tacs3(cmn);
  }
  //C!w      if ( newtac .eq. 1 ) call ntacs3
  //C     ---------------------------------------  DIODE, VALVE, GAP  ------M28.5345
  //C     ------------------------------  AND TACS-CONTROLLED SWITCH  ------M28.5346
statement_3865:
  if (kswtch <= 0) {
    goto statement_800;
  }
  n13 = 0;
  FEM_DO_SAFE(i, 1, kswtch) {
    k1 = kdepsw(lswtch + i);
    if (k1 == 8888 || k1 == 8891) {
      goto statement_4718;
    }
    if (k1 != 8890) {
      goto statement_801;
    }
    n13++;
    if (n13 <= 100) {
      goto statement_4718;
    }
    write(6, star), " Overflow TRIAC storage in SUBTS1.  STOP.";
    FEM_STOP(0);
  statement_4718:
    ndx1 = lswtch + i;
    ndx2 = lswtch + ndx1;
    ndx3 = lswtch + ndx2;
    n1 = kmswit(i);
    n2 = kmswit(ndx1);
    n = iardub(i);
    n5 = iardub(ndx1);
    i1 = iardub(ndx2);
    d1 = ardube(ndx3);
    m = kpos(i);
    m1 = fem::iabs(m);
    bus1 = bus(n1);
    bus2 = bus(n2);
    bus3 = text1;
    if (n == 0) {
      bus3 = text2;
    }
    if (k1 == 8890) {
      bus3 = text5;
    }
    if (k1 == 8891) {
      bus3 = text6;
    }
    if (iprsup == 7) {
      write(lunit6,
        "(/,1x,'       I       N       M      N1',"
        "'      N2      N3      N4      I1      M1',13x,'D1',"
        "'    BUS1    BUS2',/,1x,9i8,e15.6,4x,2a8)"),
        i, n, m, n1, n2, n3, n4, i1, m1, d1, bus1, bus2;
    }
    if (iprsup == 7) {
      write(6, star), " N5, K1, N13, SWCOLD(N13) =", n5, k1, n13, swcold(n13);
    }
    //C     ------  CHECK  OPEN/CLOSE  CLAMPING  ------                       M28.5353
    if (n5 == 0) {
      goto statement_301;
    }
    ndx1 = kxtcs + n5;
    if (iprsup == 7) {
      write(lunit6, star), " NDX1, XTCS(NDX1) =", ndx1, sptacs(ndx1);
    }
    if (sptacs(ndx1) < -flzero * 10.f) {
      goto statement_809;
    }
    if (sptacs(ndx1) <= +flzero * 10.f) {
      goto statement_803;
    }
    if (m1 == 2) {
      goto statement_801;
    }
    goto statement_808;
  statement_809:
    if (m1 == 2) {
      goto statement_805;
    }
    goto statement_801;
  statement_301:
    if (k1 == 8891) {
      goto statement_801;
    }
    if (k1 == 8890 && n == 0) {
      goto statement_801;
    }
  statement_803:
    if (k1 == 8891) {
      goto statement_809;
    }
    if (n == 0 && k1 == 8890) {
      goto statement_801;
    }
    if (m1 != 2) {
      goto statement_804;
    }
    //C                                         ------  WAS CLOSED  ------    M28.5361
    d5 = tclose(i);
    mk = -adelay(i);
    if (iprsup == 7) {
      write(6, star), " MK, D5 =", mk, d5;
    }
    if (mk <= 0) {
      goto statement_888;
    }
    if (d5 > 0.0f) {
      goto statement_688;
    }
    if (a8sw(mk + 6) == 0.0f) {
      goto statement_788;
    }
    if (a8sw(mk + 6) * d5 > 0.0f) {
      goto statement_788;
    }
    delti = a8sw(mk + 6) - d5;
    didt = delti / deltat;
    a8sw(mk + 3) = fem::pow(didt, a8sw(mk + 1)) * a8sw(mk);
    a8sw(mk + 4) = a8sw(mk + 3) / (didt * a8sw(mk + 2));
    a8sw(mk + 5) = t + d5 * deltat / delti + a8sw(mk + 4) * a8sw(mk + 2);
  statement_788:
    if (t + deltat < a8sw(mk + 5)) {
      goto statement_871;
    }
    ardube(ndx2) = 9999.f;
    goto statement_805;
  statement_688:
    delti = a8sw(mk + 6) - d5;
    if (delti < d5) {
      goto statement_871;
    }
    didt = delti / deltat;
    a8sw(mk + 3) = fem::pow(didt, a8sw(mk + 1)) * a8sw(mk);
    a8sw(mk + 4) = a8sw(mk + 3) / (didt * a8sw(mk + 2));
    a8sw(mk + 5) = t + d5 * deltat / delti + a8sw(mk + 4) * a8sw(mk + 2);
    goto statement_788;
  statement_871:
    a8sw(mk + 6) = d5;
    goto statement_801;
  statement_888:
    if (k1 != 8890) {
      goto statement_4761;
    }
    ndx3 = kxtcs + n;
    if (iprsup == 7) {
      write(6, star), " Check  XTCS(NDX3) =", sptacs(ndx3);
    }
    if (sptacs(ndx3) > 10.f * flzero) {
      goto statement_801;
    }
    d14 = d5 * swcold(n13);
    swcold(n13) = d5;
    if (d14 < 0.0f) {
      goto statement_805;
    }
    d5 = std::abs(d5);
  statement_4761:
    if (d5 >= ardube(ndx2)) {
      goto statement_801;
    }
    //C                                               ------  OPENING  ------ M13.2551
  statement_805:
    j = 5;
    if (m < 0) {
      j = -j;
    }
    if (d1 != 0.0f) {
      ardube(i) = 0.0f;
    }
    kpos(i) = j;
    n19++;
    modswt(n19) = -i;
    if (ialter == 0) {
      ialter = 1;
    }
    if (i1 != 0) {
      write(lunit6, format_806), bus3, bus1, bus2, text3, t;
    }
    if (istep > 1 || k1 != 8888) {
      goto statement_801;
    }
    write(lunit6,
      "(/,26x,94('='),/,10x,"
      "'WARNING.  ----  THE JUST-OPENED VALVE OR DIODE WAS CLOSED DURING THE S"
      "TEADY-STATE PHASOR SOLUTION',/,26x,"
      "'FOR INITIAL CONDITIONS.   BUT THE RESULTING CURRENT AT TIME ZERO WAS F"
      "ROM CATHODE TO ANODE, SO',/,26x,"
      "'OPENING OCCURRED ON TIME-STEP NUMBER ONE.   THE USER MIGHT CONSIDER RE"
      "MOVING  ''CLOSED''  FROM',/,26x,"
      "'COLUMNS  55-60  OF THE ASSOCIATED SWITCH CARD.',/,26x,94('='),/,1x)");
    goto statement_801;
    //C     ------  WAS OPEN  ------                                          M28.5366
  statement_804:
    ardube(i) += deltat;
    if (ardube(i) > d1) {
      ardube(i) = -fltinf;
    }
    d5 = e(n1) - e(n2);
    ndx1 = lswtch + i;
    if (iprsup == 7) {
      write(6, star), " NDX1, ARDUBE(I), D1, D5, ARDUBE(NDX1) =",
        ndx1, ardube(i), d1, d5, ardube(ndx1);
    }
    if (k1 == 8890) {
      d5 = std::abs(d5);
    }
    if (d5 < ardube(ndx1)) {
      goto statement_801;
    }
    if (k1 == 8890) {
      goto statement_807;
    }
    if (ardube(i) < 0.0f) {
      goto statement_807;
    }
    ardube(i) = -fltinf;
    goto statement_808;
  statement_807:
    if (n == 0) {
      goto statement_808;
    }
    ndx1 = kxtcs + n;
    if (sptacs(ndx1) <= flzero * 10.f) {
      goto statement_801;
    }
    //C     ------  CLOSING  ------                                           M13.2573
  statement_808:
    j = 2;
    if (m < 0) {
      j = -j;
    }
    kpos(i) = j;
    n19++;
    modswt(n19) = i;
    if (ialter == 0) {
      ialter = 1;
    }
    if (i1 != 0) {
      write(lunit6, format_806), bus3, bus1, bus2, text4, t;
    }
  statement_801:;
  }
  ktrlsw(1) = n19;
  //C     ------------------------------------------------------------------M13.2596
statement_800:
  if (inonl <= 0) {
    goto statement_3991;
  }
  FEM_DO_SAFE(i, 1, inonl) {
    k = nonlk(i);
    m = fem::iabs(nonlm(i));
    vsl = e(k) - e(m);
    if (iprsup > 4) {
      write(lunit6, "(/,' AT  3906',5i10,f10.0,3e15.5)"), i, k, m,
        nltype(i), nonlad(i), curr(i), e(k), e(m), vnonl(i);
    }
    if (nltype(i) < 0) {
      goto statement_83903;
    }
    gus2 = curr(i);
    if (nonle(i) > 0) {
      goto statement_73960;
    }
    vnonl(i) += deltat * vsl;
    goto statement_73960;
  statement_83903:
    k9899 = 1;
    j = 0;
    if (nltype(i) != -96) {
      goto statement_7642;
    }
    n6 = nonlad(i);
    n7 = cchar(n6);
    n9 = ilast(i);
    n10 = n9 + n7 - 1;
    n12 = n6 + 2;
    vnonl(i) += vsl * delta2;
    cchar(n6 + 3) = vsl * gslope(n6 + 1) + gslope(n6);
    gus2 = cchar(n6 + 3);
    if ((cchar(n6 + 4) < 0) && (vsl > flzero)) {
      cchar(n6 + 4) = 0;
    }
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' BEGIN TYPE-96 UPDATE.','       I      N6      N7      N9',"
        "'VNONL(I)',16x,'GUS2',17x,'VSL',/,22x,4i8,3e20.11)"),
        i, n6, n7, n9, vnonl(i), gus2, vsl;
    }
    if (vnonl(i) + flzero < vchar(n6 + 2) && cchar(n6 + 1) == 1) {
      goto statement_1100;
    }
    if (vnonl(i) - flzero > vchar(n6 + 2) && cchar(n6 + 1) == -1) {
      goto statement_1100;
    }
    //C     THE LAST POINT WAS NOT A REVERSAL POINT OF HYSTERESIS TRAJECTORY. M23.3810
    if (std::abs(vnonl(i)) < vchar(n10)) {
      goto statement_1116;
    }
    vchar(n6) = 0.0f;
    vchar(n6 + 1) = 0.0f;
  statement_1116:
    d7 = vchar(n6) * vnonl(i) + vchar(n6 + 1);
    if (d7 >= 0.0f) {
      goto statement_1118;
    }
    d7 = 0.0f;
    vchar(n6) = 0.0f;
    vchar(n6 + 1) = 0.0f;
  statement_1118:
    if (cchar(n6 + 1) == 1) {
      goto statement_1110;
    }
    //C     WE ARE ON A DOWNER WITH NO REVERSAL.                              M25. 605
    if (cchar(n6 + 5) == 1) {
      goto statement_1127;
    }
    //C     CALCULATE THE DISTANCE BETWEEN THE UPPER AND                      M28.5376
    //C     LOWER HALF OF THE MAJOR LOOP AT THE PRESENT                       M28.5377
    //C     OPERATING POINT                                                   M28.5378
    d8 = vnonl(i) + d7;
    FEM_DO_SAFE(n11, n9, n10) {
      if (cchar(n6 + 3) > cchar(n11)) {
        goto statement_1123;
      }
      cchar(n12) = n11;
      goto statement_1125;
    statement_1123:;
    }
    cchar(n12) = n10 + 1;
  statement_1125:
    n13 = cchar(n12) + n7 + 1;
    d9 = vchar(n13) * cchar(n6 + 3) + cchar(n13);
    d10 = d8 - d9;
    //C     COMPARE AVAILABLE DISTANCE AND NORMAL OPERATION DISTANCE          M28.5388
    if (d7 <= (d10 + flzero)) {
      goto statement_1119;
    }
    cchar(n6 + 5) = 1;
  statement_1127:
    FEM_DO_SAFE(n11, n9, n10) {
      if (vnonl(i) > vchar(n11)) {
        goto statement_1130;
      }
      cchar(n12) = n11;
      goto statement_1212;
    statement_1130:;
    }
    cchar(n12) = n10 + 1;
    goto statement_1212;
  statement_1119:
    FEM_DO_SAFE(n11, n9, n10) {
      if (-d8 > vchar(n11)) {
        goto statement_1120;
      }
      cchar(n12) = n11;
      goto statement_1212;
    statement_1120:;
    }
    cchar(n12) = n10 + 1;
    goto statement_1212;
    //C     WE ARE ON AN UPPER WITH NO REVERSAL.                              M25. 614
  statement_1110:
    if (cchar(n6 + 5) == 1) {
      goto statement_1147;
    }
    //C     CALCULATE THE DISTANCE BETWEEN THE UPPER AND                      M28.5400
    //C     LOWER HALF OF THE MAJOR LOOP AT THE PRESENT                       M28.5401
    //C     OPERATING POINT                                                   M28.5402
    d8 = vnonl(i) - d7;
    FEM_DO_SAFE(n11, n9, n10) {
      if (-cchar(n6 + 3) > cchar(n11)) {
        goto statement_1140;
      }
      cchar(n12) = n11;
      goto statement_1141;
    statement_1140:;
    }
    cchar(n12) = n10 + 1;
  statement_1141:
    n13 = cchar(n12) + n7 + 1;
    d9 = vchar(n13) * cchar(n6 + 3) - cchar(n13);
    d10 = d9 - d8;
    //C     COMPARE AVAILABLE DISTANCE AND NORMAL OPERATION DISTANCE          M28.5413
    if (d7 <= (d10 + flzero)) {
      goto statement_1149;
    }
    cchar(n6 + 5) = 1;
  statement_1147:
    FEM_DO_SAFE(n11, n9, n10) {
      if (-vnonl(i) > vchar(n11)) {
        goto statement_1148;
      }
      cchar(n12) = n11;
      goto statement_1312;
    statement_1148:;
    }
    cchar(n12) = n10 + 1;
    goto statement_1312;
  statement_1149:
    FEM_DO_SAFE(n11, n9, n10) {
      if (d8 > vchar(n11)) {
        goto statement_1150;
      }
      cchar(n12) = n11;
      goto statement_1312;
    statement_1150:;
    }
    cchar(n12) = n10 + 1;
    goto statement_1312;
    //C     THE PREVIOUS POINT WAS A REVERSAL POINT ON HYSTERESIS TRAJECTORY. M25. 623
  statement_1100:
    cchar(n6 + 1) = -cchar(n6 + 1);
    cchar(n6 + 4)++;
    cchar(n6 + 5) = 0;
    if (cchar(n6 + 1) != 1) {
      goto statement_1195;
    }
    //C     WE NOW SWITCH TO AN UPPER ( THERE WAS A REVERSAL).                M25. 627
    if (vchar(n6 + 2) > -vchar(n10)) {
      goto statement_1580;
    }
    vchar(n6 + 5) = vchar(n10);
    gslope(n6 + 5) = cchar(n10);
    vchar(n6) = 0.0f;
    vchar(n6 + 1) = 0.0f;
    vchar(n6 + 4) = vchar(n9);
    gslope(n6 + 4) = cchar(n9);
    cchar(n12) = n9;
    goto statement_1312;
  statement_1580:
    if (cchar(n6 + 4) > 1) {
      goto statement_1581;
    }
    vchar(n6 + 4) = vchar(n10);
    gslope(n6 + 4) = cchar(n10);
    d6 = 0.0f;
    goto statement_1575;
  statement_1581:
    FEM_DO_SAFE(n11, n9, n10) {
      if (gslope(n6 + 4) > cchar(n11)) {
        goto statement_1701;
      }
      cchar(n12) = n11;
      goto statement_1710;
    statement_1701:;
    }
    cchar(n12) = n10 + 1;
  statement_1710:
    n13 = cchar(n12) + n7 + 1;
    d9 = vchar(n13) * gslope(n6 + 4) + cchar(n13);
    d6 = vchar(n6 + 4) - d9;
  statement_1575:
    FEM_DO_SAFE(n11, n9, n10) {
      if (vchar(n6 + 3) > cchar(n11)) {
        goto statement_1750;
      }
      cchar(n12) = n11;
      goto statement_1760;
    statement_1750:;
    }
    cchar(n12) = n10 + 1;
  statement_1760:
    n13 = cchar(n12) + n7 + 1;
    d10 = vchar(n13) * vchar(n6 + 3) + cchar(n13);
    d11 = vchar(n6 + 2) - d10;
    FEM_DO_SAFE(n11, n9, n10) {
      if (gslope(n6 + 5) > cchar(n11)) {
        goto statement_1800;
      }
      n14 = n11;
      goto statement_1810;
    statement_1800:;
    }
    n14 = n10 + 1;
  statement_1810:
    n14 += n7 + 1;
    d10 = vchar(n14) * gslope(n6 + 5) + cchar(n14);
    d13 = vchar(n6 + 5) - d10;
    if (vchar(n6 + 2) >= vchar(n6 + 5)) {
      goto statement_1675;
    }
    d14 = 0.0f;
    if (std::abs(d13) > flzero) {
      d14 = d11 * d6 / d13;
    }
    d9 += d14;
    goto statement_1550;
    //C     WE NOW SWITCH TO A DOWNER ( THERE WAS A REVERSAL ).               M25. 674
  statement_1195:
    if (vchar(n6 + 2) < vchar(n10)) {
      goto statement_1590;
    }
    vchar(n6 + 5) = vchar(n9);
    gslope(n6 + 5) = cchar(n9);
    vchar(n6) = 0.0f;
    vchar(n6 + 1) = 0.0f;
    vchar(n6 + 4) = vchar(n10);
    gslope(n6 + 4) = cchar(n10);
    cchar(n12) = n9;
    goto statement_1212;
  statement_1590:
    if (cchar(n6 + 4) > 1) {
      goto statement_1591;
    }
    vchar(n6 + 4) = vchar(n9);
    gslope(n6 + 4) = cchar(n9);
    d6 = 0.0f;
    goto statement_1515;
  statement_1591:
    FEM_DO_SAFE(n11, n9, n10) {
      if (-gslope(n6 + 4) > cchar(n11)) {
        goto statement_1600;
      }
      cchar(n12) = n11;
      goto statement_1610;
    statement_1600:;
    }
    cchar(n12) = n10 + 1;
  statement_1610:
    n13 = cchar(n12) + n7 + 1;
    d9 = vchar(n13) * gslope(n6 + 4) - cchar(n13);
    d6 = d9 - vchar(n6 + 4);
  statement_1515:
    FEM_DO_SAFE(n11, n9, n10) {
      if (-vchar(n6 + 3) > cchar(n11)) {
        goto statement_1650;
      }
      cchar(n12) = n11;
      goto statement_1660;
    statement_1650:;
    }
    cchar(n12) = n10 + 1;
  statement_1660:
    n13 = cchar(n12) + n7 + 1;
    d10 = vchar(n13) * vchar(n6 + 3) - cchar(n13);
    d11 = d10 - vchar(n6 + 2);
    FEM_DO_SAFE(n11, n9, n10) {
      if (-gslope(n6 + 5) > cchar(n11)) {
        goto statement_1850;
      }
      n14 = n11;
      goto statement_1860;
    statement_1850:;
    }
    n14 = n10 + 1;
  statement_1860:
    n14 += n7 + 1;
    d10 = vchar(n14) * gslope(n6 + 5) - cchar(n14);
    d13 = d10 - vchar(n6 + 5);
    if (vchar(n6 + 2) > vchar(n6 + 5)) {
      goto statement_1680;
    }
  statement_1675:
    vchar(n6 + 5) = vchar(n6 + 4);
    gslope(n6 + 5) = gslope(n6 + 4);
    d13 = d6;
    goto statement_1690;
  statement_1680:
    d14 = 0.0f;
    if (std::abs(d13) > flzero) {
      d14 = d11 * d6 / d13;
    }
    d9 = d9 - d14;
  statement_1550:
    vchar(n6 + 5) = d9;
    gslope(n6 + 5) = gslope(n6 + 4);
    d13 = d14;
  statement_1690:
    vchar(n6 + 4) = vchar(n6 + 2);
    gslope(n6 + 4) = vchar(n6 + 3);
    d12 = d11;
    if (vchar(n6 + 4) < (vchar(n6 + 5) - flzero)) {
      goto statement_1700;
    }
    if (vchar(n6 + 4) > (vchar(n6 + 5) + flzero)) {
      goto statement_1700;
    }
    if (cchar(n6 + 1) == 1) {
      goto statement_1720;
    }
    vchar(n6 + 5) = vchar(n9);
    gslope(n6 + 5) = cchar(n9);
    d13 = 0.0f;
    goto statement_1700;
  statement_1720:
    vchar(n6 + 5) = vchar(n10);
    gslope(n6 + 5) = cchar(n10);
    d13 = 0.0f;
  statement_1700:
    d15 = d12 * (vchar(n10) - vchar(n6 + 5)) / (vchar(n10) - vchar(n6 + 4));
    if (cchar(n6 + 1) == -1.f) {
      d15 = d12 * (-vchar(n10) - vchar(n6 + 5)) / (-vchar(n10) - vchar(n6 + 4));
    }
    if (d13 <= d15) {
      goto statement_1705;
    }
    d13 = d15;
    if (iprsup >= 1) {
      write(lunit6,
        "(/,5x,'NOTE ---- FOR THE TYPE-96 HYSTERETIC',"
        "' INDUCTOR WHICH CONNECTS BUS  ''',a6,'''  TO  ''',a6,"
        "''' ,   A TRAJECTORY WAS',/,15x,'INITIALLY CREATED WHICH WOULD HAVE',"
        "' CAUSED OPERATION OUTSIDE THE',' MAJOR HYSTERESIS LOOP.  THE',/,15x,"
        "'TRAJECTORY HAS BEEN MODIFIED TO',' PREVENT THIS.  ACCURACY OF THE',"
        "' RESULTS SHOULD BE UNAFFECTED.',/,'  T =',e15.6)"),
        bus(k), bus(m), t;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(15x,' ROW NUMBER OF  N.L.  ELEMENT IS',i4,"
        "' .   VARIABLES  D13, D15 =',2e13.4)"),
        i, d13, d15;
    }
  statement_1705:
    vchar(n6) = (d12 - d13) / (vchar(n6 + 4) - vchar(n6 + 5));
    vchar(n6 + 1) = d12 - vchar(n6) * vchar(n6 + 4);
    if (cchar(n6 + 1) == 1) {
      goto statement_1312;
    }
  statement_1212:
    n14 = cchar(n12);
    n13 = n14 + n7 + 1;
    if (cchar(n6 + 5) == 1) {
      goto statement_1213;
    }
    d13 = gslope(n14) * (1.0f + vchar(n6));
    d13 = 1.0f / d13;
    d14 = gslope(n13) - gslope(n14) * vchar(n6 + 1);
    d14 = d14 * d13;
    goto statement_1315;
  statement_1213:
    d13 = vchar(n13);
    d14 = cchar(n13);
    goto statement_1315;
  statement_1312:
    n14 = cchar(n12);
    n13 = n14 + n7 + 1;
    if (cchar(n6 + 5) == 1) {
      goto statement_1313;
    }
    d13 = gslope(n14) * (1.0f - vchar(n6));
    d13 = 1.0f / d13;
    d14 = gslope(n14) * vchar(n6 + 1) - gslope(n13);
    d14 = d14 * d13;
    goto statement_1315;
  statement_1313:
    d13 = vchar(n13);
    d14 = -cchar(n13);
  statement_1315:
    if (gslope(n12) == cchar(n6 + 1) && gslope(n6 + 3) == cchar(n12)) {
      goto statement_1319;
    }
    d15 = delta2 / d13;
    a = d15 - gslope(n6 + 1);
    gslope(n6 + 1) = d15;
    goto statement_1322;
  statement_1319:
    a = 0.0f;
  statement_1322:
    d16 = vnonl(i) - d14 + delta2 * vsl;
    d16 = d16 / d13;
    gus1 = d16 - gslope(n6);
    gslope(n6) = d16;
    gslope(n12) = cchar(n6 + 1);
    gslope(n6 + 3) = cchar(n12);
    vchar(n6 + 3) = cchar(n6 + 3);
    vchar(n12) = vnonl(i);
    vnonl(i) += vsl * delta2;
    n8 = n6 + 5;
    if (iprsup >= 2) {
      {
        write_loop wloop(cmn, lunit6,
          "(/,' DONE TYPE-96.',17x,'D14',19x,'A',16x,'GUS1',5x,"
          "'(I, CCHAR(I), VCHAR(I), GSLOPE(I), I=N6, N8) ...',/,14x,3e20.11,"
          "/(1x,i5,3e20.11,i5,3e20.11))");
        wloop, d14, a, gus1;
        FEM_DO_SAFE(ip, n6, n8) {
          wloop, ip, cchar(ip), vchar(ip), gslope(ip);
        }
      }
    }
    if (a == 0.0f) {
      goto statement_3975;
    }
    goto statement_3950;
  statement_7642:
    it1 = std::abs(curr(i));
    it2 = nonlad(i) - 1;
    gus2 = 0.0f;
    if (it1 != 0) {
      goto statement_73910;
    }
    if (nltype(i) != -97) {
      goto statement_3900;
    }
    if (t < anonl(i)) {
      goto statement_73960;
    }
    if (std::abs(vsl) <= vnonl(i)) {
      goto statement_73960;
    }
    anonl(i) = t;
    curr(i) = 1.0f;
    it2++;
    a = gslope(it2);
    gus1 = 0.0f;
    goto statement_3950;
  statement_3900:
    if (std::abs(vsl) <= vnonl(i)) {
      goto statement_73960;
    }
    j = 1;
    nn1 = anonl(i);
    it2 += nn1;
    curr(i) = nn1;
    if (vsl < 0.0f) {
      curr(i) = -curr(i);
    }
    vecnl2(i) = t + vecnl1(i);
    a = gslope(it2);
    gus1 = cchar(it2);
  statement_73905:
    if (vsl < 0.0f) {
      gus1 = -gus1;
    }
    goto statement_3950;
  statement_73910:
    it2 += it1;
    gus2 = vsl * gslope(it2);
    if (nltype(i) != -98) {
      goto statement_73907;
    }
    k9899 = 0;
    gus2 += anonl(i);
    gus4 = delta2 * vsl;
    vsl = vnonl(i) + gus4;
    goto statement_73908;
  statement_73907:
    if (nltype(i) != -97) {
      goto statement_43420;
    }
    if (it2 >= nonle(i)) {
      goto statement_73960;
    }
    if (t - anonl(i) < cchar(it2 + 1)) {
      goto statement_73960;
    }
    curr(i) += 1.0f;
    a = gslope(it2 + 1) - gslope(it2);
    gus1 = 0.0f;
    goto statement_3950;
  statement_43420:
    gus2 = std::abs(gus2) + cchar(it2);
    if (vsl < 0.0f) {
      gus2 = -gus2;
    }
    if (t < vecnl2(i)) {
      goto statement_73908;
    }
    if (std::abs(vsl) < vzer5(i)) {
      goto statement_73942;
    }
  statement_73908:
    a = curr(i) * vsl;
    if (a > 0.0f) {
      goto statement_73913;
    }
    if (it1 == 1) {
      goto statement_73937;
    }
    write(lunit6,
      "(' TROUBLE AT 73912 ON TYPE-99 OR 98 ELEM NUMBER ',i2,e10.1,2e15.5)"),
      i, curr(i), vsl, gus2;
    nn1 = it2 - 1;
    if (curr(i) > 0.0f) {
      goto statement_73935;
    }
    goto statement_73915;
  statement_73913:
    if (it2 >= nonle(i)) {
      goto statement_73930;
    }
    if (std::abs(vsl) <= vchar(it2)) {
      goto statement_73930;
    }
    nn1 = it2 + 1;
    if (curr(i) < 0.0f) {
      goto statement_73935;
    }
  statement_73915:
    curr(i) += 1.0f;
  statement_73925:
    a = gslope(nn1) - gslope(it2);
    if (k9899 > 0) {
      goto statement_73927;
    }
    gus3 = cchar(nn1);
    if (vsl < 0.0f) {
      gus3 = -gus3;
    }
    d1 = (vsl + gus4 - gus3) * gslope(nn1) / delta2;
    if (iprsup >= 1) {
      write(lunit6, "(' TYPE-98 SEGMENT CHANGE',2i10,/,1x,5e25.15)"),
        i, istep, d1, anonl(i), gus2, gus3, vnonl(i);
    }
    gus2 = (anonl(i) + d1) / 2.0f;
    goto statement_3950;
  statement_73927:
    gus1 = cchar(nn1) - cchar(it2);
    goto statement_73905;
  statement_73930:
    if (it1 > 1) {
      goto statement_73932;
    }
  statement_73931:
    if (k9899 > 0) {
      goto statement_73960;
    }
    goto statement_3973;
  statement_73932:
    nn1 = it2 - 1;
    if (std::abs(vsl) >= vchar(nn1)) {
      goto statement_73931;
    }
    if (curr(i) < 0.0f) {
      goto statement_73915;
    }
  statement_73935:
    curr(i) = curr(i) - 1.0f;
    goto statement_73925;
  statement_73937:
    if (k9899 > 0) {
      goto statement_73940;
    }
    curr(i) = -curr(i);
    goto statement_3973;
  statement_73940:
    if (t >= vecnl2(i)) {
      goto statement_73942;
    }
    curr(i) = -curr(i);
    goto statement_73978;
  statement_73942:
    gus1 = -cchar(it2);
    if (curr(i) < 0.0f) {
      gus1 = -gus1;
    }
    j = 1;
    a = -gslope(it2);
    curr(i) = 0.0f;
    d1 = vchar(it2) - cmn.sglfir;
    if (std::abs(d1) < flzero) {
      vnonl(i) = fltinf;
    }
  statement_3950:
    if (k < m) {
      goto statement_4113;
    }
    n8 = m;
    n9 = k;
    goto statement_4114;
  statement_4113:
    n8 = k;
    n9 = m;
  statement_4114:
    if (n8 == 1) {
      goto statement_3965;
    }
    if (n8 > kpartb) {
      goto statement_73978;
    }
    n3 = kks(n8);
  statement_3963:
    n3 = n3 - 1;
    n4 = fem::iabs(km(n3));
    if (n4 != n8) {
      goto statement_3964;
    }
    ykm(n3) += a;
    goto statement_3963;
  statement_3964:
    if (n4 != n9) {
      goto statement_3963;
    }
    ykm(n3) = ykm(n3) - a;
    goto statement_3967;
  statement_3965:
    if (n9 > kpartb) {
      goto statement_3974;
    }
  statement_3967:
    if (n9 > kpartb) {
      goto statement_3972;
    }
    n1 = kks(n9);
  statement_3970:
    n1 = n1 - 1;
    n2 = fem::iabs(km(n1));
    if (n2 != n9) {
      goto statement_3971;
    }
    ykm(n1) += a;
    goto statement_3972;
  statement_3971:
    if (n2 != n8) {
      goto statement_3970;
    }
    ykm(n1) = ykm(n1) - a;
    goto statement_3970;
  statement_3972:
    if (ialter == 0) {
      ialter = 1;
    }
  statement_3974:
    if (k9899 > 0) {
      goto statement_3975;
    }
  statement_3973:
    gus1 = 2.0f * (gus2 - anonl(i));
    vnonl(i) = vsl + gus4;
    anonl(i) += gus1;
    if (iprsup >= 3) {
      write(lunit6,
        "(/,' TYPE-98 ELEM UPDATE AT  1974.',3i10,f10.0,/(1x,5e25.15))"),
        i, k, m, curr(i), gus2, gus4, vsl, gus1, vnonl(i), anonl(i), a;
    }
  statement_3975:
    finit(k) = finit(k) - gus1;
    finit(m) += gus1;
  statement_73978:
    it1 = curr(i);
    if (j <= 0) {
      goto statement_73960;
    }
    max99m = max99m - 1;
    if (max99m >= 0 || iprsup >= 3) {
      write(lunit6,
        "(20x,'TYPE-99 N.L. V-I FROM ''',a6,''' TO ''',a6,'''',' AT T=',e12.4,"
        "' BEGINS OPERATION ON SEGMENT',i4,'.')"),
        bus(k), bus(m), t, it1;
    }
  statement_73960:
    if (nonlm(i) > 0) {
      goto statement_3990;
    }
    kcount++;
    bvalue(kcount) = gus2;
  statement_3990:;
  }
statement_3991:
  if (m4plot == 1) {
    yserlc(cmn);
  }
  if (ialter == 0) {
    goto statement_2616;
  }
  ktrlsw(3)++;
  if (ktrlsw(1) > 0) {
    identifier_switch(cmn);
  }
  if (cmn.kanal == 2) {
    last14(cmn);
  }
  //C       &&&&&&&&&& ENTER RETRIANGULARIZATION OF COMPLETE (Y)            M32.5093
  move0(kssfrq, ntot);
  ii = 0;
  L = 1;
  goto statement_2290;
statement_2205:
  L++;
  it2 = kode(L);
  if (it2 > L) {
    goto statement_2290;
  }
  if (it2 == 1) {
    goto statement_2290;
  }
  f(1) = 0.0f;
  n17 = 1;
  j = kks(L);
statement_2220:
  j = j - 1;
  n13 = km(j);
  i = fem::iabs(n13);
  if (kode(i) == 0) {
    goto statement_2227;
  }
statement_2224:
  if (kode(i) < i) {
    goto statement_2222;
  }
  i = kode(i);
  goto statement_2224;
statement_2222:
  if (kode(i) == 1) {
    goto statement_2233;
  }
statement_2227:
  if (i == L) {
    goto statement_2237;
  }
  n18 = n17;
statement_2225:
  jj = kssfrq(n17);
  if (jj == 0) {
    goto statement_2231;
  }
  if (jj == i) {
    goto statement_2229;
  }
  if (jj > i) {
    goto statement_2230;
  }
  n17 = jj;
  goto statement_2225;
statement_2237:
  f(1) += ykm(j);
  goto statement_2233;
statement_2229:
  f(i) += ykm(j);
  goto statement_2232;
statement_2230:
  kssfrq(i) = jj;
statement_2231:
  kssfrq(n17) = i;
  f(i) = ykm(j);
statement_2232:
  n17 = n18;
  if (kode(i) == 0) {
    n17 = i;
  }
statement_2233:
  if (n13 > 0) {
    goto statement_2220;
  }
  if (it2 == 0) {
    goto statement_2240;
  }
  if (it2 == L) {
    goto statement_2240;
  }
  //C     ADDITION OF LOWER NUMBERED ROW WHEN SWITCH IS CLOSED.                12939
  j = kks(it2);
  it2 = kode(it2);
  n17 = 1;
  goto statement_2220;
  //C                       ADDITION OF ELEMENTS FOR CLOSED SWITCHES           12943
statement_2240:
  n17 = 1;
  acheck = std::abs(f(1)) * epsiln;
  if (acheck != 0.0f || ktrans(L) == -664422) {
    goto statement_2260;
  }
  if (nwarn <= 0) {
    write(lunit6,
      "(' ZERO DIAGONAL ADMITTANCE;   ZERO YKK.',"
      "'  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%',/,"
      "' WHILE PREPARING TO ELIMINATE ROW  \"',a6,"
      "'\"  OF THE ADMITTANCE MATRIX,  IT IS FOUND',/,"
      "' THAT THE DIAGONAL IS ZERO DUE TO NO',"
      "' CONNECTED ELEMENTS.   ADD HIGH IMPEDANCE',/,"
      "' BRANCH TO EARTH (VALUE 10*FLZERO),  AND',' CONTINUE.')"),
      bus(L);
  }
  nwarn = -1;
  f(1) = flzero * 10.f;
statement_2260:
  k = kssfrq(n17);
  if (k > L || k == 0) {
    goto statement_2280;
  }
  a = f(k);
  if (a == 0.f) {
    goto statement_2279;
  }
  n14 = k;
  i = kk(k);
statement_2265:
  if (km(i) < 0) {
    goto statement_2270;
  }
  i = i - 1;
  goto statement_2265;
statement_2270:
  i++;
  if (i > kk(k)) {
    goto statement_2279;
  }
  n1 = km(i);
  if (n1 == L) {
    goto statement_2272;
  }
statement_2271:
  n15 = kssfrq(n14);
  if (n15 == n1) {
    goto statement_2273;
  }
  if (n15 > n1) {
    goto statement_2275;
  }
  if (n15 == 0) {
    goto statement_2276;
  }
  n14 = n15;
  goto statement_2271;
statement_2272:
  f(1) = f(1) - a * ykm(i);
  goto statement_2270;
statement_2273:
  f(n1) = f(n1) - a * ykm(i);
  goto statement_2277;
statement_2275:
  kssfrq(n1) = n15;
statement_2276:
  kssfrq(n14) = n1;
  f(n1) = -a * ykm(i);
statement_2277:
  n14 = n1;
  goto statement_2270;
statement_2279:
  kssfrq(n17) = 0;
  n17 = k;
  goto statement_2260;
statement_2280:
  a = f(1);
statement_1280:
  if (std::abs(a) >= acheck) {
    goto statement_4312;
  }
  if (nwarn <= 0) {
    write(lunit6,
      "(' FLOATING SUBNETWORK.  FLOATING SUBNETWORK.',"
      "'  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%',/,"
      "' THE ELIMINATION OF ROW  \"',a6,"
      "'\"  HAS PRODUCED A NEAR-ZERO DIAGNONAL',/,' OF VALUE',e13.5,"
      "'  JUST PRIOR TO',' RECIPROCATION.   THE ACCEPTABLE MINIMUM IS',/,"
      "e13.5,'  (EQUAL TO \"EPSILN\" TIMES YKK).',"
      "'   SHORT NODE TO GROUND WITH  YKK = FLTINF.',/,"
      "' FOR THE RECORD, MISCELLANEOUS DATA PARAMETER',"
      "' \"EPSILN\" HAS VALUE',e12.3,' .')"),
      bus(L), a, acheck, epsiln;
  }
  nwarn = -1;
  a = fltinf;
  if (m4plot != 1) {
    goto statement_4312;
  }
  nwarn = 0;
  write(cmn.munit6, "('   ++++  No, YKK grounding is optional.')");
  window(cmn);
  honker(cmn, ll10);
statement_3711:
  write(prom80, "(' SEND REMEDY (SPY, YKK, PASS, STOP) :')");
  prompt(cmn);
  cmn.lockbr = 1;
  flager(cmn);
  read(buff77, "(a6)"), bus1;
  if (bus1 != text10) {
    goto statement_3726;
  }
  spying(cmn);
  goto statement_3711;
statement_3726:
  if (bus1 == text11) {
    goto statement_4312;
  }
  if (bus1 == text12) {
    stoptp(cmn);
  }
  if (bus1 != text13) {
    goto statement_3711;
  }
  write(prom80, "(' SEND NEW YKK VALUE AT RECIPROCATION POINT :')");
  prompt(cmn);
  flager(cmn);
  frefp1(cmn, buff77, a);
  goto statement_1280;
statement_4312:
  a = 1.0f / a;
  ii++;
  km(ii) = -L;
  ykm(ii) = a;
  goto statement_2285;
statement_2283:
  if (f(k) == 0.0f) {
    goto statement_2288;
  }
  ii++;
  ykm(ii) = f(k) * a;
  km(ii) = k;
statement_2288:
  kssfrq(n17) = 0;
  n17 = k;
  k = kssfrq(k);
statement_2285:
  if (k != 0) {
    goto statement_2283;
  }
  kk(L) = ii;
  if (iprsup > 1) {
    write(lunit6,
      "(' DONE TRIANGULARIZING NEW ROW OF (Y) .',"
      "'       L      II   KK(L)  KPARTB',24x,'A',/,38x,4i8,e25.16)"),
      L, ii, kk(L), kpartb, a;
  }
  if (ii < kks(1)) {
    goto statement_2290;
  }
  kill = 1;
  lstat(13) = 2;
  lstat(15) = L;
  lstat(16) = 5;
  lstat(19) = 2290;
  goto statement_9200;
statement_2290:
  if (L < kpartb) {
    goto statement_2205;
  }
  iupper = ii;
  if (nwarn < 0) {
    nwarn = 1;
  }
  n4 = iupper + lymat - kks(1) + 1;
  if (n4 > lstat(25)) {
    lstat(25) = n4;
  }
  if (iprsup > 0) {
    write(lunit6,
      "(/,' UPPER-TRIANGULAR FACTORS FOR (Y).',4x,"
      "'(I, KM(I), YKM(I), I=1, IUPPER)',10x,'IUPPER, LYMAT, KKS(1) =',3i6)"),
      iupper, lymat, kks(1);
  }
  if (iprsup > 2) {
    {
      write_loop wloop(cmn, lunit6, "(1x,5(i6,i5,e15.6))");
      FEM_DO_SAFE(i, 1, iupper) {
        wloop, i, km(i), ykm(i);
      }
    }
  }
  if (iprsup > 1) {
    {
      write_loop wloop(cmn, lunit6, "(' KK(I), I=1, NTOT ',/(1x,20i6))");
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, kk(i);
      }
    }
  }
  if (iprsup > 3) {
    write(lunit6,
      "(/,1x,'   NUM99   INONL   NCOMP   ISTEP  INDSTP',"
      "'    NTOT   LPAST  IPOINT  KSWTCH',/,1x,9i8)"),
      num99, inonl, ncomp, istep, cmn.indstp, ntot, lpast, ipoint,
      kswtch;
  }
  //C     START.  FIND DIFFERENCES OF COLUMNS OF INVERSE FOR NONLINEARITIES*   13014
  n13 = 0;
  j11 = 0;
  if (ncomp <= 0) {
    goto statement_2616;
  }
  j11 = ntot * ncomp;
  move0(znonl, j11);
  if (inonl == num99) {
    goto statement_2321;
  }
  FEM_DO_SAFE(i, 1, inonl) {
    if (nltype(i) < 0) {
      goto statement_2320;
    }
    if (nltype(i) > 920) {
      goto statement_2320;
    }
    vzer5(i) = -fltinf;
    n1 = nonlad(i);
    ilast(i) = fem::iabs(n1);
    if (n1 < 0) {
      vzer5(i) = 0.f;
    }
  statement_2320:;
  }
statement_2321:
  FEM_DO_SAFE(n2, 1, cmn.numsub) {
    n1 = 0;
    L = isubeg(n2);
    if (L <= 0) {
      goto statement_2322;
    }
  statement_2306:
    d8 = -1.0f;
    j = kknonl(L + 1);
    FEM_DO_SAFE(n10, 1, 2) {
      if (kpsour(j) == 0) {
        goto statement_2315;
      }
    statement_4377:
      if (kode(j) < j) {
        goto statement_4319;
      }
      j = kode(j);
      goto statement_4377;
    statement_4319:
      if (kode(j) == 1) {
        goto statement_2315;
      }
      n5 = j + n1;
      znonl(n5) = d8;
    statement_2315:
      d8 = 1.0f;
      j = kknonl(L + 2);
    }
    L = kknonl(L);
    if (L == isubeg(n2)) {
      goto statement_2322;
    }
    n1 += ntot;
    goto statement_2306;
  statement_2322:;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (ZNONL(1:J11) BEFORE SOLUTION, AT 1313.',/(1x,8e15.5))");
      FEM_DO_SAFE(i, 1, j11) {
        wloop, znonl(i);
      }
    }
  }
  ii = 1;
  n4 = -kpartb;
statement_2410:
  if (ii > iupper) {
    goto statement_2450;
  }
  L = fem::iabs(km(ii));
  n8 = L;
  FEM_DO_SAFE(m, 1, ncomp) {
    voltbc(m) = znonl(n8);
    znonl(n8) = znonl(n8) * ykm(ii);
    n8 += ntot;
  }
  j = fem::iabs(kk(L));
statement_2420:
  ii++;
  if (ii > j) {
    goto statement_2410;
  }
  k = km(ii);
  if (k <= kpartb) {
    goto statement_2422;
  }
  ii = j + 1;
  goto statement_2410;
statement_2422:
  n8 = L;
  FEM_DO_SAFE(m, 1, ncomp) {
    znonl(k) = znonl(k) - voltbc(m) * ykm(ii);
    n8 += ntot;
    k += ntot;
  }
  goto statement_2420;
statement_2450:
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (ZNONL(K), K=1, J11) ...',/(1x,8e16.6))");
      FEM_DO_SAFE(k, 1, j11) {
        wloop, znonl(k);
      }
    }
  }
statement_2500:
  if (ii == 1) {
    goto statement_2550;
  }
  move0(voltbc, ncomp);
statement_2510:
  ii = ii - 1;
  k = km(ii);
  if (k < 0) {
    goto statement_2520;
  }
  n8 = k;
  FEM_DO_SAFE(m, 1, ncomp) {
    voltbc(m) = voltbc(m) - znonl(n8) * ykm(ii);
    n8 += ntot;
  }
  goto statement_2510;
statement_2520:
  L = fem::iabs(k);
  n8 = L;
  FEM_DO_SAFE(m, 1, ncomp) {
    znonl(n8) += voltbc(m);
    n8 += ntot;
  }
  if (kode(L) == 0) {
    goto statement_2500;
  }
  j = kode(L);
statement_2528:
  n8 = j;
  n9 = L;
  FEM_DO_SAFE(m, 1, ncomp) {
    znonl(n8) = znonl(n9);
    n8 += ntot;
    n9 += ntot;
  }
  if (kode(j) == L) {
    goto statement_2500;
  }
  j = kode(j);
  goto statement_2528;
  //C             FIND DIFFERENCES OF COLUMNS OF INVERSE FOR NONLINEARITIES    13185
statement_2550:
  if (inonl <= num99) {
    goto statement_2616;
  }
  FEM_DO_SAFE(i, 1, inonl) {
    if (nltype(i) < 0) {
      goto statement_2600;
    }
    if (nltype(i) > 920) {
      goto statement_2600;
    }
    n1 = nonlk(i);
    n2 = fem::iabs(nonlm(i));
    a = znonl(n1) - znonl(n2);
    if (nltype(i) == 94) {
      goto statement_2561;
    }
    if (nonle(i) > 0) {
      goto statement_2561;
    }
    a = a * delta2;
  statement_2561:
    anonl(i) = a;
  statement_2600:;
  }
statement_2616:
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' ZNONL AFTER SOLN, AT 2318',/(1x,8e15.5))");
      FEM_DO_SAFE(i, 1, j11) {
        wloop, znonl(i);
      }
    }
  }
  mover(finit(1), f(1), ntot);
  if (kswtch == 0) {
    goto statement_5000;
  }
  FEM_DO_SAFE(i, 1, kswtch) {
    k1 = kdepsw(lswtch + i);
    if (k1 != 8888 && k1 != 8890 && k1 != 8891) {
      goto statement_8801;
    }
    mk = -adelay(i);
    if (mk <= 0) {
      goto statement_8801;
    }
    m = fem::iabs(kpos(i));
    if (m != 5) {
      goto statement_8801;
    }
    ndx2 = lswtch + lswtch + i;
    if (ardube(ndx2) != 9999.f) {
      goto statement_8801;
    }
    n1 = kmswit(i);
    n2 = kmswit(lswtch + i);
    bi = fem::exp((a8sw(mk + 5) - t - deltat) / a8sw(mk + 4));
    ai = a8sw(mk + 3) * bi;
    f(n1) = ai;
    f(n2) = -ai;
    if (ai <= a8sw(mk + 7)) {
      ardube(ndx2) = 0.0f;
    }
    if (bi <= 0.0001f && a8sw(mk + 7) == 0.f) {
      ardube(ndx2) = 0.f;
    }
  statement_8801:;
  }
  //C              CALL TO SOLVUM IF NO COMPENSATION OF UM POWER CIRCUITS : M33.1513
statement_5000:
  if (loopss(8) == 3) {
    solvum(cmn, spum(iureac), 
      spum(iugpar), spum(iufpar), spum(iuhist), spum(iuumrp), 
      ispum(iunod1),  ispum(iunod2), ispum(iujclt), ispum(iujclo), 
      ispum(iujtyp), ispum(iunodo),  ispum(iujtmt), spum(iuhism), 
      spum(iuomgm), spum(iuomld), spum(iutham),  spum(iuredu), 
      spum(iureds), spum(iuflds), spum(iufldr), spum(iurequ),  
      spum(iuflqs), spum(iuflqr), ispum(iujcds), ispum(iujcqs), 
      spum(iuflxd),  spum(iuflxq), ispum(iunppa), spum(iurotm), 
      ispum(iuncld), ispum(iunclq), ispum(iujtqo), ispum(iujomo), 
      ispum(iujtho), spum(iureqs), spum(iuepso), spum(iudcoe), 
      ispum(iukcoi), spum(iuvolt), spum(iuangl), ispum(iunodf), 
      ispum(iunodm), ispum(iukumo), ispum(iujumo), spum(iuumou));
  }
  if (kill > 0) {
    goto statement_9200;
  }
  if (iprsup > 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (E(I), F(I), I=1, NTOT)   AT THE END OF THE FIRST PIECE OF THE T"
        "IME-STEP LOOP.',/(1x,10e13.3))");
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, e(i), f(i);
      }
    }
  }
  ipoint++;
  iprsov(35) = ipoint;
  if (ipoint == lpast) {
    ipoint = 0;
  }
  lastov = nchain;
  nchain = 17;
  goto statement_9900;
  kill = 229;
  lstat(19) = 7755;
  lstat(15) = ncomp;
  lstat(16) = cmn.lcomp;
  goto statement_9200;
  n15 = isubeg(knode);
  nn15 = isubeg(mnode);
  lstat(19) = 7766;
  kill = 229;
  lstat(19) = 7777;
  lstat(15) = kknonl(n15 + 3);
  lstat(16) = kknonl(nn15 + 3);
statement_9200:
  lstat(18) = 16;
  lastov = nchain;
  nchain = 51;
statement_9900:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT \"SUBTS1\".  KILL, LSTAT(19) =',2i8)"),
      kill, lstat(19);
  }

}

void redu17(
  arr_ref<double> a,
  int const& n,
  int const& m)
{
  a(dimension(1));
  int j = fem::int0;
  double w = fem::double0;
  int ij = fem::int0;
  double h1 = fem::double0;
  arr_1d<100, double> b(fem::fill0);
  int k = fem::int0;
  int ik = fem::int0;
  int i1 = fem::int0;
  int i = fem::int0;
  double h2 = fem::double0;
  int i2 = fem::int0;
  int L = fem::int0;
  //C)    FOR AN EXPLANATION ABOUT THE PARAMETERS OF THIS SUBROUTINE,       M15.1297
  //C)    SEE COMMENT CARDS IN SAME MODULE  'REDUCT'  OF OVERLAY 12 .       M15.1298
  j = n + 1;
  w = 1.0f;
  if (m > 0) {
    w = -w;
  }
  ij = n * j / 2;
statement_3:
  j = j - 1;
  if (j == m) {
    return;
  }
  h1 = -1.0f / a(ij);
  b(j) = h1;
  ij = ij - j;
  k = 0;
  ik = 0;
  //C                                   BEGIN K-LOOP                           13581
statement_4:
  ik += k;
  i1 = ik + 1;
  k++;
  if (k > n) {
    goto statement_3;
  }
  if (k < j) {
    goto statement_9;
  }
  if (w < 0.f) {
    goto statement_3;
  }
  if (k == j) {
    goto statement_7;
  }
  i = ik + j;
statement_5:
  h2 = a(i);
  b(k) = h2 * h1;
  //C                                   BEGIN I-LOOP                           13592
  i2 = ik + k;
  L = 0;
  FEM_DO_SAFE(i, i1, i2) {
    L++;
    a(i) += b(L) * h2;
  }
  if (k < j) {
    goto statement_4;
  }
  i = ik + j;
  a(i) = b(k);
  goto statement_4;
  //C                                   END I-LOOP                             13602
statement_7:
  i = ij;
  FEM_DO_SAFE(L, 1, j) {
    i++;
    a(i) = b(L);
  }
  goto statement_4;
  //C                                   END K-LOOP                             13608
statement_9:
  i = ij + k;
  goto statement_5;
}

void fdcinj(
  common& cmn,
  int& ikf,
  int& isfd,
  int& ibf)
{
  common_write write(cmn);
  int& it2 = cmn.it2;
  int& iprsup = cmn.iprsup;
  const auto& rmfd = cmn.rmfd;
  auto& cikfd = cmn.cikfd;
  const auto& imfd = cmn.imfd;
  auto& volt = cmn.volt;
  //
  int idk = fem::int0;
  int isf = fem::int0;
  int isc = fem::int0;
  auto& lunit6 = cmn.lunit6;
  double cz = fem::double0;
  arr_1d<40, double> ur(fem::fill0);
  int ka = fem::int0;
  double ar = fem::double0;
  int ist = fem::int0;
  int isu = fem::int0;
  int isv = fem::int0;
  double azr = fem::double0;
  double azi = fem::double0;
  int isk = fem::int0;
  double un = fem::double0;
  int kb = fem::int0;
  //C     THIS ROUTINE UPDATES THE CURRENT INJECTIONS FOR THE INDIVIDUAL    M32.5974
  //C     BRANCHES AS WELL AS FOR THE EQUIVALENT  BRANCHES INSERTED INTO THEM32.5975
  //C     EMTP. IT ALSO UPDATES THE CAPACITOR AND INDUCTOR VOLTAGES AND     M32.5976
  //C     CALCULATES BRANCH CURRENTS FOR THE INDIVIDUAL BRANCHES   *   *   *M32.5977
  idk = 2 * ikf;
  ikf++;
  isf = isfd + 1;
  isc = ibf + 1;
  if (iprsup > 0) {
    write(lunit6,
      "(' INTEGER COUNTERS AT START OF FDCINJ.....',7x,'IKF',6x,'ISFD',7x,"
      "'IBF',6x,'IZFD',6x,'IPFD',/,41x,5i10)"),
      ikf, isfd, ibf, imfd(idk + 1), imfd(idk + 2);
  }
  //C     CONVERT PHASE VOLTAGES TO MODAL FRAME OF REFERENCE   *   *   *   *M32.5987
  cz = it2;
  cz = 1.0f / cz;
  ur(1) = volt(1);
  FEM_DO_SAFE(ka, 2, it2) {
    ur(1) += volt(ka);
    ur(ka) = (volt(1) - volt(ka)) * cz;
  }
  ur(1) = ur(1) * cz;
  if (iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6,
        "(' MODAL VOLTAGES IN FDCINJ FOR SET NO.',i6,/(2x,6e21.11))");
      wloop, ikf;
      FEM_DO_SAFE(ka, 1, it2) {
        wloop, ur(ka);
      }
    }
  }
  //C     PROCESS FIRST THE 'ZERO' SEQUENCE DATA   *   *   *   *   *   *   *M32.5998
  ar = 0.f;
  ist = isf;
  isu = isfd + imfd(idk + 1) * 5;
  isv = ibf - 2;
  FEM_DOSTEP(ka, ist, isu, 5) {
    isv += 3;
    //C     CALCULATE BRANCH CURRENT     *   *   *   *   *   *   *   *   *   *M32.6005
    azr = rmfd(ka + 1) * ur(1) + cikfd(isv);
    //C     C A P A C I T O R   V O L T A G E    *   *   *   *   *   *   *   *M32.6007
    cikfd(isv + 2) += rmfd(ka + 2) * (azr + cikfd(isv + 1));
    //C     I N D U C T O R   V O L T A G E  *   *   *   *   *   *   *   *   *M32.6010
    azi = ur(1) - azr * rmfd(ka) - cikfd(isv + 2);
    azi = -rmfd(ka + 4) * azi - 2.f * cikfd(isv + 2) + ur(1);
    //C     C U R R E N T   I N J E C T I O N    *   *   *   *   *   *   *   *M32.6013
    azi = rmfd(ka + 1) * azi - rmfd(ka + 3) * azr;
    ar += azi;
    cikfd(isv) = azi;
    cikfd(isv + 1) = azr;
  }
  ur(1) = ar;
  //C     PROCESS THE REMAINING ( IT2 - 1 ) MODES  *   *   *   *   *   *   *M32.6019
  isfd = isu;
  ibf = isv + 2;
  isk = imfd(idk + 2);
  ist = isfd + 1;
  isu = isfd + isk * 5;
  //C     LOOP ACROSS MODES            *   *   *   *   *   *   *   *   *   *M32.6025
  FEM_DO_SAFE(ka, 2, it2) {
    ar = 0.f;
    un = ur(ka);
    FEM_DOSTEP(kb, ist, isu, 5) {
      isv += 3;
      //C     CALCULATE BRANCH CURRENT     *   *   *   *   *   *   *   *   *   *M32.6031
      azr = rmfd(kb + 1) * un + cikfd(isv);
      //C     C A P A C I T O R   V O L T A G E    *   *   *   *   *   *   *   *M32.6033
      cikfd(isv + 2) += rmfd(kb + 2) * (azr + cikfd(isv + 1));
      //C     I N D U C T O R   V O L T A G E  *   *   *   *   *   *   *   *   *M32.6036
      azi = un - azr * rmfd(kb) - cikfd(isv + 2);
      azi = -azi * rmfd(kb + 4) - 2.f * cikfd(isv + 2) + un;
      azi = rmfd(kb + 1) * azi - rmfd(kb + 3) * azr;
      ar += azi;
      cikfd(isv) = azi;
      cikfd(isv + 1) = azr;
    }
    ur(ka) = ar;
  }
  ibf += (it2 - 1) * isk * 3;
  isfd = isu;
  //C     CONVERT MODAL CURRENT INJECTIONS TO PHASE COORDINATES    *   *   *M32.6046
  cz = it2;
  volt(1) = 0.f;
  FEM_DO_SAFE(ka, 1, it2) {
    volt(1) += ur(ka);
  }
  FEM_DO_SAFE(ka, 2, it2) {
    volt(ka) = volt(1) - cz * ur(ka);
  }
  if (iprsup <= 0) {
    goto statement_15;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(' PHASE CURRENT INJECTIONS CIK......',/(2x,6e21.11))");
    FEM_DO_SAFE(ka, 1, it2) {
      wloop, volt(ka);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(' UPDATED MODAL BRANCH DATA FROM',i6,'  TO',i6,/(2x,6e21.11))");
    wloop, isc, ibf;
    FEM_DO_SAFE(ka, isc, ibf) {
      wloop, cikfd(ka);
    }
  }
statement_15:;

}


void subts2(
  common& cmn)
{
  common_read read(cmn);
  common_write write(cmn);
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  double& deltat = cmn.deltat;
  double& t = cmn.t;
  double& tmax = cmn.tmax;
  double& unity = cmn.unity;
  double& onehaf = cmn.onehaf;
  double& dltinv = cmn.dltinv;
  const auto& iprsov = cmn.iprsov;
  int& it1 = cmn.it1;
  int& it2 = cmn.it2;
  int& kcount = cmn.kcount;
  int& lpast = cmn.lpast;
  int& nv = cmn.nv;
  int& lfdep = cmn.lfdep;
  int& lsiz26 = cmn.lsiz26;
  int& lsiz28 = cmn.lsiz28;
  int& ifdep2 = cmn.ifdep2;
  int& modout = cmn.modout;
  int& lint = cmn.lint;
  int& iftail = cmn.iftail;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  auto& x = static_cast<common_c0b001&>(cmn).x;
  auto& xk = cmn.xk;
  auto& xm = cmn.xm;
  const auto& weight = cmn.weight;
  const auto& iwtent = cmn.iwtent;
  const auto& con1 = cmn.con1;
  const auto& iskip = cmn.iskip;
  auto& stailm = cmn.stailm;
  auto& stailk = cmn.stailk;
  auto& sconst = cmn.sconst;
  auto& cnvhst = cmn.cnvhst;
  const auto& qfd = cmn.qfd;
  auto& semaux = cmn.semaux;
  auto& bvalue = cmn.bvalue;
  const auto& c = cmn.c;
  const auto& tr = cmn.tr;
  const auto& tx = cmn.tx;
  const auto& r = static_cast<common_c0b064&>(cmn).r;
  const auto& nr = cmn.nr;
  const auto& length = cmn.length;
  auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  auto& ck = cmn.ck;
  const auto& litype = cmn.litype;
  const auto& imodel = cmn.imodel;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& cki = cmn.cki;
  const auto& ckkjm = cmn.ckkjm;
  const auto& indhst = cmn.indhst;
  const auto& kodsem = cmn.kodsem;
  auto& namebr = cmn.namebr;
  const auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;

  arr_ref<double> voltk(static_cast<common_c0b124&>(cmn).voltk,
    dimension(3000));
  auto& volt = cmn.volt;
  int& koff1 = cmn.koff1;
  int& koff2 = cmn.koff2;
  int& koff3 = cmn.koff3;
  int& koff4 = cmn.koff4;
  int& koff5 = cmn.koff5;
  int& koff6 = cmn.koff6;
  int& koff7 = cmn.koff7;
  int& koff8 = cmn.koff8;
  int& koff9 = cmn.koff9;
  int& koff10 = cmn.koff10;
  int& koff13 = cmn.koff13;
  int& koff14 = cmn.koff14;
  int& koff15 = cmn.koff15;
  int& koff16 = cmn.koff16;
  int& koff17 = cmn.koff17;
  int& koff18 = cmn.koff18;
  int& koff20 = cmn.koff20;
  int& koff21 = cmn.koff21;
  int& koff22 = cmn.koff22;
  int& koff25 = cmn.koff25;
  int& inoff1 = cmn.inoff1;
  int& inoff2 = cmn.inoff2;
  int& inoff3 = cmn.inoff3;
  int& inoff5 = cmn.inoff5;
  int& lcbl = cmn.lcbl;
  int& lmode = cmn.lmode;
  //
  auto& lunit6 = cmn.lunit6;
  int j = fem::int0;
  int nmodal = fem::int0;
  int isecti = fem::int0;
  int k = fem::int0;
  int llm1 = fem::int0;
  int ll0 = fem::int0;
  int ll1 = fem::int0;
  int ibf = fem::int0;
  int isfd = fem::int0;
  int ikf = fem::int0;
  int kaa = fem::int0;
  int n1 = fem::int0;
  int i = fem::int0;
  int n2 = fem::int0;
  int n3 = fem::int0;
  int msign = fem::int0;
  double gus1 = fem::double0;
  double gus2 = fem::double0;
  double gus3 = fem::double0;
  double a = fem::double0;
  double cap = fem::double0;
  double gus4 = fem::double0;
  double d1 = fem::double0;
  int ky = fem::int0;
  int koff11 = fem::int0;
  int kq = fem::int0;
  int kqk0 = fem::int0;
  int kh = fem::int0;
  int nnq1 = fem::int0;
  int lj = fem::int0;
  int nn1 = fem::int0;
  int nn2 = fem::int0;
  double gkt = fem::double0;
  double gmt = fem::double0;
  int nteq = fem::int0;
  int nrz = fem::int0;
  int nra = fem::int0;
  int nk1 = fem::int0;
  int nn17 = fem::int0;
  int nn5 = fem::int0;
  int n6 = fem::int0;
  int nq5 = fem::int0;
  int nq6 = fem::int0;
  double hktdt = fem::double0;
  double hmtdt = fem::double0;
  int lj1 = fem::int0;
  int jkl = fem::int0;
  int jq = fem::int0;
  int nnq2 = fem::int0;
  int nnq3 = fem::int0;
  int nq4 = fem::int0;
  int n4 = fem::int0;
  int n8 = fem::int0;
  int n9 = fem::int0;
  int jql = fem::int0;
  int nkyw = fem::int0;
  int n5 = fem::int0;
  int n7 = fem::int0;
  int nn6 = fem::int0;
  int nky = fem::int0;
  int nn10 = fem::int0;
  int nn11 = fem::int0;
  int ka = fem::int0;
  int ki = fem::int0;
  double hkout = fem::double0;
  double hmout = fem::double0;
  int iadrs = fem::int0;
  int kcc = fem::int0;
  int kktau = fem::int0;
  int nterm = fem::int0;
  double fk5 = fem::double0;
  double bm5 = fem::double0;
  int nkll = fem::int0;
  int koff12 = fem::int0;
  double fk5tau = fem::double0;
  double bm5tau = fem::double0;
  int nk2 = fem::int0;
  int nk3 = fem::int0;
  int nk4 = fem::int0;
  double c2 = fem::double0;
  double c1 = fem::double0;
  double yk = fem::double0;
  double ym = fem::double0;
  double fk5tdt = fem::double0;
  double bm5tdt = fem::double0;
  int kbb = fem::int0;
  int ktau = fem::int0;
  int jgl = fem::int0;
  int nkkk1 = fem::int0;
  int nk5 = fem::int0;
  int nq0k = fem::int0;
  int im = fem::int0;
  int jm = fem::int0;
  int kst = fem::int0;
  int n2p = fem::int0;
  double phsinv = fem::double0;
  int ii = fem::int0;
  int ndx1 = fem::int0;
  double yx = fem::double0;
  int ndx2 = fem::int0;
  int it21 = fem::int0;
  int n41 = fem::int0;
  double xmn4 = fem::double0;
  //double h1 = fem::double0;
  double h2 = fem::double0;
  double bus4z = fem::double0;
  double bus2z = fem::double0;
  double vkd = fem::double0;
  double vmd = fem::double0;
  int n11 = fem::int0;
  int nraz1 = fem::int0;
  int nraz2 = fem::int0;
  int nraz3 = fem::int0;
  int nra3 = fem::int0;
  int nrz2 = fem::int0;
  int nrz3 = fem::int0;
  int n31 = fem::int0;
  int n32 = fem::int0;
  int n33 = fem::int0;
  int n34 = fem::int0;
  int n10 = fem::int0;
  int ind = fem::int0;
  double d23 = fem::double0;
  double aikd = fem::double0;
  double aimd = fem::double0;
  int nn3 = fem::int0;
  int nn4 = fem::int0;
  int nn7 = fem::int0;
  int nn8 = fem::int0;
  int nn9 = fem::int0;
  int nrf = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  int j3 = fem::int0;
  int j4 = fem::int0;
  double ekh = fem::double0;
  double emh = fem::double0;
  double temp1 = fem::double0;
  int itauo = fem::int0;
  double frac = fem::double0;
  int i1 = fem::int0;
  int i1p1 = fem::int0;
  int i1p2 = fem::int0;
  int kf = fem::int0;
  int jf = fem::int0;
  int jfdep2 = fem::int0;
  int kfdep2 = fem::int0;
  double sk = fem::double0;
  double sm = fem::double0;
  int ik = fem::int0;
  int iklim = fem::int0;
  int L = fem::int0;
  int lbound = fem::int0;
  int ik1 = fem::int0;
  int im1 = fem::int0;
  double xxik = fem::double0;
  double xxim = fem::double0;
  double xxik1 = fem::double0;
  double xxim1 = fem::double0;
  double dk = fem::double0;
  double dm = fem::double0;
  int ndelt = fem::int0;
  double d4 = fem::double0;
  double d3 = fem::double0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  double d11 = fem::double0;
  double d12 = fem::double0;
  double d9 = fem::double0;
  double d10 = fem::double0;
  static const char* format_23010 =
    "(/,'  AFTER LINEAR CONV.  N2, N3, N4, N5, N6, N7, N8,  N9, N10 =  ',9i7,"
    "/,5x,'  D1, D2, D3, D4, D5, D6 =  ',6(1x,e15.7),/,"
    "'CNVHST(N5), CNVHST(N5+1), (XK/XM(J) J=N7, N8)  ...   ',/(8(1x,e15.7)))";
  static const char* format_7342 =
    "(/,' K, IBR =',2i6,10x,'(F(I), I=1, NTOT )  FOLLOW ...',/(1x,8e16.7))";
  static const char* format_80140 = "(' SCONST FROM',i6,'    TO',i6)";
  static const char* format_80145 = "(1x,10e12.5)";

  auto& d2 = sm;
  auto& h1 = sk;

  auto& ipoint = iprsov(35);

  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' Top  SUBTS2.  F(1:NTOT) follows ...',/(1x,8e16.7))");
      FEM_DO_SAFE(j, 1, ntot) {
        wloop, f(j);
      }
    }
  }
  nmodal = kcount;
  isecti = 400;
  k = 1;
  llm1 = -1;
  ll0 = 0;
  ll1 = 1;
  iftail = 0;
  //C                                      INITIALIZE COUNTERS FOR THE -666 M32.5947
  ibf = 0;
  isfd = 0;
  ikf = 0;
  kaa = 0;
  //C                                        ACCUMULATION OF NODE CURRENTS FM44.1702
  //C                                                          UPDATING LINEM44.1703
statement_1100:
  it2 = length(k);
  n1 = kbus(k);
  if (iprsup >= 1) {
    write(lunit6, star), "Top of SUBTS2 ,N1=", n1;
  }
  if (n1 < 0) {
    goto statement_1180;
  }
  it2 = fem::iabs(it2);
  if (it2 == 1) {
    goto statement_1150;
  }
statement_1105:
  it1 = k;
  if (length(k + 1) == -555) {
    goto statement_3535;
  }
  FEM_DO_SAFE(i, 1, it2) {
    n1 = kbus(it1);
    n2 = mbus(it1);
    volti(i) = -e(n1);
    voltk(i) = -e(n2);
    volt(i) = voltk(i) - volti(i);
    it1++;
  }
  n3 = nr(k);
  if (t > tmax) {
    goto statement_1190;
  }
  //C     CHECK FOR THE PRESENCE OF THE -666 BRANCHES  *   *   *   *   *   *M32.5951
  if (length(k + 1) == -666) {
    goto statement_3531;
  }
  mult(c(n3), volti(1), ci(k), it2, llm1);
  mult(c(n3), voltk, ck(k), it2, llm1);
  if (kodebr(k) <= 0) {
    goto statement_3530;
  }
  mover(cik(k), volti(1), it2);
  mult(x(n3), volt(1), volti(1), it2, ll1);
  mult(r(n3), volti(1), cik(k), it2, llm1);
  FEM_DO_SAFE(i, 1, 10) {
    if (cmn.istep <= 2 && iprsup >= 3) {
      write(lunit6,
        "(/,' UPDATE OF  I(T-DELTAT)  AT 73530.',6i12,/(1x,5e25.15))"),
        i, kbus(i), mbus(i), nr(i), length(i), kodebr(i), r(i), x(i),
        tr(i), tx(i), c(i), volt(i), volti(i), cik(i);
    }
  }
  goto statement_3535;
statement_3531:
  fdcinj(cmn, ikf, isfd, ibf);
  mover(volt(1), cik(k), it2);
  goto statement_3535;
statement_3530:
  mult(x(n3), cik(k), volt(1), it2, ll1);
  mult(r(n3), volt(1), cik(k), it2, llm1);
statement_3535:
  it1 = k + it2 - 1;
  FEM_DO_SAFE(i, k, it1) {
    n1 = kbus(i);
    n2 = mbus(i);
    f(n1) = f(n1) - cik(i) - ci(i);
    f(n2) += cik(i) - ck(i);
  }
  //C                                                                       M44.1706
  //C                                                                       M44.1707
  //C                                                                       M44.1708
  //C                                                                       M44.1709
  goto statement_1200;
statement_1150:
  i = nr(k);
  msign = mbus(k);
  n2 = fem::iabs(msign);
  gus1 = e(n1);
  gus2 = e(n2);
  gus3 = gus1 - gus2;
  a = cik(k);
  ci1 = ci(k);
  ck1 = ck(k);
  it1 = fem::iabs(i);
  cap = c(it1);
  if (iprsup >= 3) {
    write(lunit6, star), " IT1, N1, N2, K, I, T =", it1, n1, n2, k, i, t;
  }
  if (iprsup >= 3) {
    write(lunit6,
      "(' X(IT1), E(N1), E(N2), CIK(K), R(IT1) = ',5e18.10,/)"), x(it1),
      e(n1), e(n2), cik(k), r(it1);
  }
  if (i < 0) {
    goto statement_1170;
  }
  if (t > tmax) {
    goto statement_1105;
  }
  a = (gus3 + a * x(i)) * r(i) - a;
  gus4 = -cap * gus1 - ci1;
  ck1 = -cap * gus2 - ck1;
  f(n1) = f(n1) - gus4;
  f(n2) = f(n2) - ck1;
statement_1160:
  f(n1) = f(n1) - a;
  f(n2) += a;
  cik(k) = a;
  ci(k) = gus4;
  ck(k) = ck1;
  goto statement_1200;
statement_1170:
  gus3 = x(it1) * gus3;
  gus4 = gus3 + a;
  if (cap == 0.f) {
    goto statement_1175;
  }
  ck1 += cap * (gus4 + ci1);
  gus3 = gus3 - 2.0f * x(it1) * ck1;
statement_1175:
  a = gus3 - r(it1) * gus4;
  if (msign > 0) {
    goto statement_1160;
  }
  gus3 = gus4;
  d1 = n1;
  if (ck1 == d1) {
    gus3 = gus4 + ci(k - 1);
  }
  kcount++;
  bvalue(kcount) = gus3;
  goto statement_1160;
statement_1180:
  n1 = -n1;
  n2 = mbus(k);
  if (imodel(k) != -4) {
    goto statement_4340;
  }
  if (it2 < 0) {
    goto statement_481;
  }
statement_481:
  it2 = -it2;
  ky = k;
  koff11 = koff25 + 288;
  FEM_DO_SAFE(i, 1, isecti) {
    semaux(koff8 + i) = 0.e0;
    semaux(koff7 + i) = 0.e0;
    semaux(koff6 + i) = 0.e0;
    semaux(koff5 + i) = 0.e0;
    semaux(koff9 + i) = 0.0f;
    semaux(koff10 + i) = 0.0f;
    ky++;
  }
  if (iprsup > 0) {
    write(6, star), "+++++BEFORE UPDATING HISTORY SOURCE++++ T=", t;
  }
  kq = namebr(inoff1 + k);
  kqk0 = namebr(inoff2 + k);
  kh = k;
  nnq1 = namebr(inoff3 + k);
  //C      LJ = KQ                                 ! 1st pole of Qii for theM44.1754
  //C      IF ( KQ .GT. 1) LJ = ( KQ-1 ) * 2 + 1                            M44.1755
  //C      KILINE = LPAST                                  !next cell is freM44.  19
  //C      KILINE = NR(K)                                                   M44. 684
  //C      LJ = KILINE + LJ                                                 M44.  20
  lj = nr(k);
  FEM_DO_SAFE(j, 1, it2) {
    ky = k;
    FEM_DO_SAFE(i, 1, it2) {
      nn1 = -kbus(ky);
      nn2 = fem::iabs(mbus(ky));
      gkt = sconst(kqk0) * e(nn1);
      gmt = sconst(kqk0) * e(nn2);
      nteq = semaux(koff20 + kq);
      if (lint == 1) {
        goto statement_9824;
      }
      n1 = kodsem(ky);
      nrz = cki(ky);
      nra = ckkjm(ky);
      nk1 = n1 + 5 * nrz + 5 * nra + 4 + 1;
      nn17 = sconst(nk1);
      nn5 = nk1 + 1 + nn17;
      n6 = nn5 + 1;
      //C      CALL CONVOL(VM(I),VMDT(I),VMJ5DT(IADRS),VMOUT,HMOUT              M44.1765
      //C     1           ,VK(I),VKDT(I),VKJ5DT(IADRS),VKOUT,HKOUT              M44.1766
      //C     2           ,CJQ(IADRS),DJQ(IADRS),EJQ(IADRS),QK0(KQ),ESUMQ(KQ)   M44.1767
      //C     3           ,NTEQ,0)                                              M44.1768
      nq5 = nnq1 + 3 * nteq + 1;
      nq6 = nq5 + 1;
      hktdt = sconst(nq6) * sconst(n6);
      hmtdt = sconst(nq6) * sconst(nn5);
      if (iprsup > 0) {
        write(6,
          "(' KQ NTEQ   LJ  LJ1  CJQ(IADRS)','     QK0(KQ)',"
          "'   ESUMQ(KQ)       HKTDT       HMTDT',"
          "'       VK(I)     VKDT(I)   VKJ5DT(J)','       VM(I)')");
      }
      lj1 = lj + nteq;
      jkl = 0;
      FEM_DO_SAFE(jq, 1, nteq) {
        nnq2 = nnq1 + jq;
        nnq3 = nnq2 + nteq;
        nq4 = nnq3 + nteq;
        //C     VKJ5DT(IADRS) = QKI(IADRS) * VKJ5DT(IADRS)                        M44.1790
        //C    1              + EJQ(IADRS) * SCONST(N6)                           M44.1791
        //C    2              + QPI(IADRS) * E(NN1)                               M44.1792
        if (fem::abs(sconst(nnq2)) >= 1.e+14f) {
          goto statement_1800;
        }
        goto statement_1083;
      statement_1800:
        jkl++;
        if (jkl == 2) {
          goto statement_1801;
        }
        sconst(nnq2) = sconst(nnq2) / 1.e+15f;
      statement_1083:
        xm(lj1) = sconst(nnq2) * xm(lj1) + sconst(nq4) * sconst(n6) +
          sconst(nnq3) * e(nn1);
        xm(lj) = sconst(nnq2) * xm(lj) + sconst(nq4) * sconst(nn5) +
          sconst(nnq3) * e(nn2);
        gkt += xm(lj1);
        gmt += xm(lj);
        hktdt += sconst(nnq2) * xm(lj1);
        hmtdt += sconst(nnq2) * xm(lj);
        if (jkl == 1) {
          goto statement_1802;
        }
      statement_1801:
        jkl = 0;
      statement_1802:
        if (iprsup > 0) {
          write(6, "(1x,i2,3x,i2,2x,i3,2x,i3,9e12.5)"), kq, nteq, lj,
            lj1, sconst(nnq2), sconst(kqk0), sconst(nq6), hktdt,
            hmtdt, e(nn1), sconst(n6), xm(lj1), e(nn2);
        }
        lj++;
        lj1++;
        if (lj >= lpast + lsiz28) {
          write(6,
            "('+XM()',i5,' exceed the limit of list28',i5,/,"
            "' If you are going to',/,"
            "' run the case agian, you should have your programer change',/,"
            "' the dimenssion. Massage from LJG.')"),
            lj, lpast + lsiz28;
        }
      }
    statement_9824:
      kqk0 += 2 * nteq + 1;
      lj += nteq;
      semaux(koff8 + kh) += hmtdt;
      semaux(koff6 + kh) += gmt;
      semaux(koff7 + kh) += hktdt;
      semaux(koff5 + kh) += gkt;
      nnq1 += 3 * nteq + 2;
      ky++;
      kq++;
    }
    kh++;
  }
  //C                                                                       M44.1829
  //C        Evaluation of hm1(t+dt) and hk1(t+dt)                          M44.1830
  //C                                                                       M44.1831
  ky = k;
  n1 = kodsem(ky);
  FEM_DO_SAFE(i, 1, it2) {
    //C      CALL CONVOL(VM5(I),VM5DT(I),GMJDT(IADRS),GM,HM1(I)               M44.1836
    //C     1           ,VK5(I),VK5DT(I),GKJDT(IADRS),GK,HK1(I)               M44.1837
    //C     2           ,CJY(IADRS),DJY(IADRS),EJY(IADRS),YK0(I),ESUMY(I)     M44.1838
    //C     3           ,NTEY,0)                                              M44.1839
    if (iprsup > 0) {
      write(6, star),
        "Just before convolution,VM5dt(KY),Vk5dt(KY)dt=", semaux(koff1 + ky),
        semaux(koff2 + ky);
    }
    n4 = indhst(ky);
    n1 = kodsem(ky);
    nrz = cki(ky);
    nra = ckkjm(ky);
    n8 = n1 + 5 * nrz + 2 * nra + 1;
    n9 = n8 + 1;
    gkt = sconst(n1) * semaux(koff5 + ky);
    gmt = sconst(n1) * semaux(koff6 + ky);
    semaux(koff13 + ky) = sconst(n8) * semaux(koff2 + ky);
    semaux(koff14 + ky) = sconst(n8) * semaux(koff1 + ky);
    if (iprsup > 0) {
      write(6,
        "(' KY  NRZ   CJY(IADRS)','  YK0(KQ) ESUY(KQ) WK1(K13)',"
        "' WK1(K14)  VK5(KY) VK5DT(K)',' GKJDT(I)  VM5(KY) WK1(KF3)',"
        "' WK1(KF4)  SCN(N7)  SCN(N6)',' SCN(NN5)      GMT      GKT')");
    }
    jkl = 0;
    jql = 1;
    nkyw = n4 + 20;
    FEM_DO_SAFE(j, 1, nrz) {
      n5 = n1 + 2 * nrz + 2 * nra + j;
      n6 = n5 + nrz;
      n7 = n6 + nrz;
      nk1 = n1 + 5 * nra + 5 * nrz + 5;
      nn17 = sconst(nk1);
      nn5 = nk1 + j + 4 + nn17;
      nn6 = nn5 + nrz;
      nky = n1 + j;
      if (sconst(nky) > 1.e+13f) {
        goto statement_2000;
      }
      sconst(nn6) = sconst(n5) * sconst(nn6) + sconst(n7) * semaux(
        koff2 + ky) + sconst(n6) * semaux(koff5 + ky);
      sconst(nn5) = sconst(n5) * sconst(nn5) + sconst(n7) * semaux(
        koff1 + ky) + sconst(n6) * semaux(koff6 + ky);
      gkt += sconst(nn6);
      gmt += sconst(nn5);
      semaux(koff13 + ky) += sconst(n5) * sconst(nn6);
      semaux(koff14 + ky) += sconst(n5) * sconst(nn5);
      goto statement_2002;
    statement_2000:
      jkl++;
      if (jkl == 2) {
        goto statement_2001;
      }
      nkyw += jql;
      nn10 = nkyw + 1;
      nn11 = nn10 + 1;
      sconst(nn6) = cnvhst(nkyw) * sconst(nn6) + cnvhst(nn11) *
        semaux(koff2 + ky) + cnvhst(nn10) * semaux(koff5 + ky);
      sconst(nn5) = cnvhst(nkyw) * sconst(nn5) + cnvhst(nn11) *
        semaux(koff1 + ky) + cnvhst(nn10) * semaux(koff6 + ky);
      gkt += sconst(nn6);
      gmt += sconst(nn5);
      semaux(koff13 + ky) += sconst(n5) * sconst(nn6);
      semaux(koff14 + ky) += sconst(n5) * sconst(nn5);
      jql += 6;
    statement_2002:
      if (iprsup > 0) {
        write(6, "(1x,i2,3x,i2,16e9.3)"), ky, nrz, sconst(n5), sconst(n1),
          sconst(n8), semaux(koff13 + ky), semaux(koff14 + ky),
          semaux(koff5 + ky), semaux(koff2 + ky), sconst(nn6), semaux(
            koff6 + ky), semaux(koff3 + ky), semaux(koff4 + ky), sconst(n7),
          sconst(n6), sconst(nn5), gmt, gkt;
      }
      if (jkl == 1) {
        goto statement_4009;
      }
    statement_2001:
      jkl = 0;
    statement_4009:;
    }
    //C        Evaluate im'(t) = fm'(t) - gm(t)                               M44.1888
    //C                 ik'(t) = -bk'(t) + gk(t)                              M44.1889
    //C      AIM5(KY)=FM5(KY)-GMT                          !FM5() = A1*FK' froM44.1890
    //C      AIK5(KY)=-BK5(KY)+GKT                         !BK5() = A1*BM' froM44.1891
    cnvhst(n4 + 13) = semaux(koff3 + ky) - gmt;
    cnvhst(n4 + 14) = -semaux(koff4 + ky) + gkt;
    //C     1 write(*,3335) KY,HM1(KY),HK1(KY),AIM5(KY),AIK5(KY)              M44.1897
    if (iprsup > 0) {
      write(6, "('HM1(t),hK1(t),Im5(KY),Ik5(KY)=',1x,i1,4e14.5)"),
        ky, semaux(koff14 + ky), semaux(koff13 + ky), cnvhst(n4 + 13),
        cnvhst(n4 + 14);
    }
    ky++;
  }
  //C                                                                       M44.1904
  //C        Evaluation of hm3(t+dt) and hk3(t+dt)                          M44.1905
  //C        (from the convolutions: im(t+dt) = q(t+dt) # im'(t+dt)         M44.1906
  //C                                ik(t+dt) = q(t+dt) # ik'(t+dt) )       M44.1907
  //C                                                                       M44.1908
  //C                                       The calculation of Im(t) = Q(t) M44.1909
  if (lint == 1) {
    goto statement_116;
  }
  ka = k;
  kqk0 = namebr(inoff2 + k);
  nnq1 = namebr(inoff3 + k);
  kq = namebr(inoff1 + k);
  //C      LJ = KQ                        ! 1st pole of Qii for the branch KM44.1915
  lj = nr(k);
  //C      IF ( KQ .GT. 1) LJ = ( KQ-1 ) * 2 + 1                            M44.1917
  //C      KILINE = LPAST                                  !next cell is freM44.  27
  //C      KILINE = NR(K)                                                   M44. 731
  //C      LJ = KILINE + LJ                                                 M44.  28
  FEM_DO_SAFE(j, 1, it2) {
    n4 = indhst(ka);
    n1 = kodsem(ka);
    nrz = cki(ka);
    nra = ckkjm(ka);
    nk1 = n1 + 5 * nra + 5 * nrz + 4 + 1;
    nn17 = sconst(nk1);
    nn5 = n1 + 5 * nrz + 5 * nra + 4 + 2 + 1 + 1 + nn17;
    n6 = nn5 + 1;
    ki = k;
    FEM_DO_SAFE(i, 1, it2) {
      nteq = semaux(koff20 + kq);
      //C      CALL CONVOL(AIM5(J),AIM5DT(J),AIMJDT(IADRS),VMOUT,HMOUT          M44.1928
      //C     1           ,AIK5(J),AIK5DT(J),AIKJDT(IADRS),VKOUT,HKOUT          M44.1929
      //C     2           ,CJQ(IADRS),DJQ(IADRS),EJQ(IADRS),QK0(K),ESUMQ(K)     M44.1930
      //C     3           ,NTEQ,0)                                              M44.1931
      gkt = sconst(kqk0) * cnvhst(n4 + 14);
      gmt = sconst(kqk0) * cnvhst(n4 + 13);
      nq5 = nnq1 + 3 * nteq + 1;
      nq6 = nq5 + 1;
      hkout = sconst(nq6) * sconst(n6);
      hmout = sconst(nq6) * sconst(nn5);
      if (iprsup > 0) {
        write(lunit6,
          "(' KQ NTEQ IADRS    CJQ(IADS)','      QK0(KQ)',"
          "'    ESUMQ(KQ)        HKOUT        HMOUT',"
          "'     AIK5(KA)    AIK5DT(J)   AIKJDT(IS)','     AIM5(KA)')");
      }
      lj1 = lj + nteq;
      jkl = 0;
      FEM_DO_SAFE(jq, 1, nteq) {
        nnq2 = nnq1 + jq;
        nnq3 = nnq2 + nteq;
        nq4 = nnq3 + nteq;
        if (fem::abs(sconst(nnq2)) >= 1.e+14f) {
          goto statement_1804;
        }
        goto statement_1805;
      statement_1804:
        jkl++;
        if (jkl == 2) {
          goto statement_1806;
        }
        sconst(nnq2) = sconst(nnq2) / 1.e+15f;
      statement_1805:
        xk(lj1) = sconst(nnq2) * xk(lj1) + sconst(nq4) * sconst(n6) +
          sconst(nnq3) * cnvhst(n4 + 14);
        xk(lj) = sconst(nnq2) * xk(lj) + sconst(nq4) * sconst(nn5) +
          sconst(nnq3) * cnvhst(n4 + 13);
        gkt += xk(lj1);
        gmt += xk(lj);
        hkout += sconst(nnq2) * xk(lj1);
        hmout += sconst(nnq2) * xk(lj);
        if (jkl == 1) {
          goto statement_1807;
        }
      statement_1806:
        jkl = 0;
      statement_1807:
        if (iprsup > 0) {
          write(6, "(1x,i2,3x,i2,3x,i3,9e13.5)"), kq, nteq, iadrs,
            sconst(nnq2), sconst(kqk0), sconst(nq6), hkout, hmout,
            cnvhst(n4 + 14), sconst(n6), xk(lj1), cnvhst(n4 + 13);
        }
        //C      IADRS = IADRS + 1                                                M44.1972
        lj++;
        lj1++;
      }
      kqk0 += 2 * nteq + 1;
      lj += nteq;
      if (iprsup > 0) {
        write(6, star), "hist.sour. with current  HM3(ki), HK3(ki)",
          semaux(koff10 + ki), semaux(koff9 + ki);
      }
      semaux(koff10 + ki) += hmout;
      semaux(koff9 + ki) += hkout;
      if (iprsup > 0) {
        write(6, star), "hist.sour. with current  HM3(ki), HK3(ki)",
          semaux(koff10 + ki), semaux(koff9 + ki);
      }
      ki++;
      kq++;
      nnq1 += 3 * nteq + 2;
    }
    ka++;
  }
  //C                         Evaluate fk'(t) and bm'(t):                   M44.1992
  //C                                                      fk'(t) = 2ik'(t) M44.1993
  //C                                                     bm'(t) = -2im'(t) M44.1994
statement_116:
  kcc = koff25 + 288;
  koff11 = koff25 + 288;
  FEM_DO_SAFE(i, 1, ibr) {
    if (kodsem(i) == 0.0f || imodel(i) != -4) {
      goto statement_1097;
    }
    kktau = indhst(i);
    nterm = cnvhst(kktau) / deltat + 1;
    kcc += 2 * nterm;
  statement_1097:;
  }
  semaux(kcc + 1) = 68556311.00f;
  ka = k;
  if (lmode == 4) {
    koff11 = lcbl;
  }
  FEM_DO_SAFE(i, 1, it2) {
    n4 = indhst(ka);
    fk5 = 2.e0 * cnvhst(n4 + 14) + semaux(koff4 + ka);
    bm5 = -2.e0 * cnvhst(n4 + 13) + semaux(koff3 + ka);
    //C                                       Update past history terms of fk'M44.2011
    kktau = indhst(ka);
    nterm = cnvhst(kktau) / deltat + 1;
    if (iprsup > 0) {
      write(6,
        "('nterm ktau    fkh5(ktau)           fk5',"
        "'    bmh5(ktau)           bm5',"
        "'        fk5tdt        fk5tau        bm5tdt','        bm5tau')");
    }
    //C      CALL UPDCBL(FKH5(KTAU),FK5,FK5TDT,FK5TAU                         M44.2020
    //C     1           ,BMH5(KTAU),BM5,BM5TDT,BM5TAU                         M44.2021
    //C     1           ,NTERM,NKILL(KA),TAU(KA),DELTAT)                      M44.2022
    nkll = namebr(inoff5 + ka);
    koff11 += nkll;
    koff12 = koff11 + nterm;
    fk5tau = semaux(koff11);
    bm5tau = semaux(koff12);
    semaux(koff11) = fk5;
    semaux(koff12) = bm5;
    nk1 = namebr(inoff5 + ka) - 1;
    if (nk1 == 0) {
      koff11 += nterm;
    }
    if (nk1 == 0) {
      koff12 += nterm;
    }
    nk2 = nk1 - 1;
    if (nk2 == 0) {
      nk3 = koff11 - 2 + nterm;
    }
    if (nk2 == 0) {
      nk4 = koff12 - 2 + nterm;
    }
    c2 = cnvhst(kktau) - nterm * deltat;
    c1 = -c2 - deltat;
    if (nk2 != 0) {
      goto statement_7601;
    }
    yk = semaux(koff11 - 1) * c1 + semaux(nk3) * c2;
    ym = semaux(koff12 - 1) * c1 + semaux(nk4) * c2;
    goto statement_7602;
  statement_7601:
    yk = semaux(koff11 - 1) * c1 + semaux(koff11 - 2) * c2;
    ym = semaux(koff12 - 1) * c1 + semaux(koff12 - 2) * c2;
  statement_7602:
    semaux(koff11 - 1) = -yk / deltat;
    semaux(koff12 - 1) = -ym / deltat;
    fk5tdt = semaux(koff11 - 1);
    bm5tdt = semaux(koff12 - 1);
    kaa += 2 * nterm;
    //C                                                      !get ready for neM44.2070
    kbb = koff25 + 288 + kaa + 1;
    if (semaux(kbb) == 68556311.00f) {
      kaa = 0;
    }
    //C                                                  !get ready for next tM44.2075
    koff11 = koff25 + 288 + kaa;
    namebr(inoff5 + ka) = nk1;
    if (namebr(inoff5 + ka) == 0) {
      namebr(inoff5 + ka) = nterm;
    }
    if (iprsup > 0) {
      write(6, "(3x,i2,3x,i2,8e14.5)"), nterm, ktau, semaux(koff11),
        fk5, semaux(koff12), bm5, fk5tdt, fk5tau, bm5tdt, bm5tau;
    }
    //C                                 Evaluation of fm'(t+dt) = a1(t+dt) # fM44.2088
    //C                                               bk'(t+dt) = a1(t+dt) # bM44.2089
    //C      CALL CONVOL(FK5TDT,FK5TAU,FMJ5(IADRS),FM5(I),HKOUT               M44.2090
    //C     1           ,BM5TDT,BM5TAU,BKJ5(IADRS),BK5(I),HMOUT               M44.2091
    //C     2           ,CJA(IADRS),DJA(IADRS),EJA(IADRS),0.D0,0.D0,NTEA,1)   M44.2092
    n1 = kodsem(ka);
    nrz = cki(ka);
    nra = ckkjm(ka);
    semaux(koff3 + ka) = 0.e0;
    semaux(koff4 + ka) = 0.e0;
    if (iprsup > 0) {
      write(6,
        "(' KA  NRA CJA(IADRS)',' DJA(IADRS) EJA(IADRS)     FK5TDT',"
        "'     FK5TAU FMJ5(IARS)     BM5TDT',"
        "'     BM5TAU BKJ5(IARS)        FM5','        BK5')");
    }
    jgl = 0;
    FEM_DO_SAFE(j, 1, nra) {
      n5 = n1 + 5 * nrz + 2 * nra + 2 + j;
      n6 = n5 + nra;
      n7 = n6 + nra;
      nkkk1 = n1 + 5 * nra + 5 * nrz + 4 + 1;
      nn17 = sconst(nkkk1);
      nn5 = n1 + 7 * nrz + 5 * nra + 9 + j + nn17;
      nn6 = nn5 + nra;
      nk5 = n1 + 2 * nrz + j;
      if (fem::abs(sconst(nk5)) >= 1.e13f) {
        jgl++;
      }
      if (jgl == 2) {
        goto statement_5486;
      }
      sconst(nn5) = sconst(n5) * sconst(nn5) + sconst(n7) * fk5tau +
        sconst(n6) * fk5tdt;
      sconst(nn6) = sconst(n5) * sconst(nn6) + sconst(n7) * bm5tau +
        sconst(n6) * bm5tdt;
      semaux(koff3 + ka) += sconst(nn5);
      semaux(koff4 + ka) += sconst(nn6);
      if (jgl == 1) {
        goto statement_4337;
      }
    statement_5486:
      jgl = 0;
    statement_4337:
      if (iprsup > 0) {
        write(6, "(1x,i2,3x,i2,11e11.5)"), ka, nra, sconst(n5),
          sconst(n6), sconst(n7), fk5tdt, fk5tau, sconst(nn5),
          bm5tdt, bm5tau, sconst(nn6), semaux(koff3 + ka), semaux(
            koff4 + ka);
      }
    }
    ka++;
  }
  lcbl = koff11;
  if (koff11 > koff25 + 288) {
    lmode = 4;
  }
  ka = k;
  nq0k = namebr(inoff1 + k);
  FEM_DO_SAFE(i, 1, it2) {
    if (iprsup > 0) {
      write(6, star),
        "Y05(KA),WK1(KOFF8+KA),WK1(KOFF7+KA),HM1(KA),HK1(KA)", semaux(
          koff21 + ka), semaux(koff8 + ka), semaux(koff7 + ka), semaux(
            koff14 + ka), semaux(koff13 + ka);
    }
    //C     VMDT(KA)=FM5(KA)-Y05(KA)*HM2(KA)-HM1(KA)                          M44.2140
    //C     VKDT(KA)=BK5(KA)-Y05(KA)*HK2(KA)-HK1(KA)                          M44.2141
    //C     WK1(KOFF18+KA) = WK1( KOFF3 + KA )               !VMDT(KA)=       M44.2142
    //C    1         - Y05(KA) * WK1( KOFF8 + KA )                            M44.2143
    //C    2         - WK1(KOFF14+KA)                                         M44.2144
    semaux(koff18 + ka) = semaux(koff3 + ka) - semaux(koff21 + ka) *
      semaux(koff8 + ka) - semaux(koff14 + ka);
    semaux(koff17 + ka) = semaux(koff4 + ka) - semaux(koff21 + ka) *
      semaux(koff7 + ka) - semaux(koff13 + ka);
    //C
    if (iprsup > 0) {
      write(6, star),
        "KA,FM5(KA),HM1(KA),BK5(KA),HK1(KA),VMDT(KA),VKDT(KA)", ka,
        semaux(koff3 + ka), semaux(koff14 + ka), semaux(koff4 + ka),
        semaux(koff13 + ka), semaux(koff18 + ka), semaux(koff17 + ka);
    }
    ka++;
  }
  //C      CALL MVEC(WK1(KOFF22+NQ0K),WK1(KOFF18+K),                        M44.2157
  //C     1    WK1(KOFF16+K),WK1(KOFF17+K),WK1(KOFF15+K),IT2,0)             M44.2158
  FEM_DO_SAFE(im, 1, it2) {
    semaux(koff16 + k - 1 + im) = 0.e0;
    semaux(koff15 + k - 1 + im) = 0.e0;
  }
  FEM_DO_SAFE(jm, 1, it2) {
    FEM_DO_SAFE(im, 1, it2) {
      semaux(koff16 + k - 1 + im) += semaux(koff22 + nq0k) * semaux(
        koff18 + k - 1 + jm);
      semaux(koff15 + k - 1 + im) += semaux(koff22 + nq0k) * semaux(
        koff17 + k - 1 + jm);
      nq0k++;
    }
  }
  if (iprsup > 0) {
    write(6, star), "##equi. voltage sour. HM(1), HK(1)", semaux(koff16 + 1),
      semaux(koff15 + 1);
  }
  if (lint == 1) {
    goto statement_119;
  }
  ka = k;
  FEM_DO_SAFE(i, 1, it2) {
    semaux(koff16 + ka) += semaux(koff10 + ka);
    semaux(koff15 + ka) = semaux(koff15 + ka) - semaux(koff9 + ka);
    ka++;
  }
  //C                                                                       M44.2185
  //C        Complete updating of remaining variables:                      M44.2186
  //C                VM5DT,VK5DT                                            M44.2187
  //C                AIM5DT,AIK5DT                                          M44.2188
  //C                VMDT,VKDT                                              M44.2189
  //C                                                                       M44.2190
statement_119:
  kst = k;
  FEM_DO_SAFE(i, 1, it2) {
    semaux(koff1 + kst) = semaux(koff6 + kst);
    semaux(koff2 + kst) = semaux(koff5 + kst);
    n1 = kodsem(kst);
    nrz = cki(kst);
    nra = ckkjm(kst);
    nk1 = n1 + 5 * nra + 5 * nrz + 5;
    nn17 = sconst(nk1);
    nn5 = nk1 + 3 + nn17;
    n6 = nn5 + 1;
    n4 = indhst(kst);
    sconst(nn5) = cnvhst(n4 + 13);
    sconst(n6) = cnvhst(n4 + 14);
    if (iprsup > 0) {
      write(6, star), "##equi. current sour. AIM5DT(I), AIK5DT(I)",
        sconst(nn5), sconst(n6);
    }
    //C      AIM5DT(I)=AIM5(I)                                                M44.2206
    //C      AIK5DT(I)=AIK5(I)                                                M44.2207
    nn5 = nn5 - 2;
    n6 = nn5 + 1;
    //C      VMDT(I)=VM(I)                                                    M44.2210
    //C      VKDT(I)=VK(I)                                                    M44.2211
    //C      SCONST(NN5) = VM(KST)                                    !Update M44.2212
    //C      SCONST(N6)  = VK(KST)                                    !Update M44.2213
    nn1 = -kbus(kst);
    nn2 = fem::iabs(mbus(kst));
    sconst(nn5) = e(nn2);
    sconst(n6) = e(nn1);
    if (iprsup > 0) {
      write(6, star), "##equi. voltage sour. VMDT(I), VKDT(I)",
        sconst(nn5), sconst(n6);
    }
    //C      HMP(KST) = WK1(KOFF16+KST)                                       M44.2221
    //C      HKP(KST) = WK1(KOFF15+KST)                                       M44.2222
    //C      IF ( IPRSUP .GT. 0 )                                             M44.2223
    //C     1 write( *,*)'##equi. voltage sour. HMP(I), HKP(I)',              M44.2224
    //C     2                                   HMP(KST), HKP(KST)            M44.2225
    if (iprsup > 0) {
      write(lunit6, star), "##equi. voltage sour. VM5DT(I), VK5DT(I)",
        semaux(koff1 + kst), semaux(koff2 + kst);
    }
    kst++;
  }
  //C                                                                       M44.2231
  FEM_DO_SAFE(i, 1, it2) {
    n1 = -kbus(k);
    n2 = mbus(k);
    n2p = fem::iabs(n2);
    f(n1) += semaux(koff15 + k);
    f(n2p) += semaux(koff16 + k);
    k++;
    if (n2 > 0) {
      goto statement_483;
    }
    kcount++;
    //C      BVALUE(KCOUNT) = AIK(I)                                          M44.2241
    kcount++;
    //C     BVALUE(KCOUNT) = -AIM(I)                                          M44.2243
  statement_483:;
  }
  if (iprsup > 0) {
    write(lunit6, star), " subts2 cable done.  k, it2 =", k, it2;
  }
  it2 = 0;
  goto statement_1200;
  //C                    End Time step loop for frequency-dependent branchesM44.2249
  //C  4340 IF ( KODSEM(K) .NE. 0  .AND.                                    M44.2251
  //C     1     IMODEL(K) .NE. -2 )  GO TO 11780    !if this is semlyen caseM44.2252
statement_4340:
  if (kodsem(k) != 0 && imodel(k) >= 0) {
    goto statement_11780;
  }
  if (it2 > 0) {
    it2 = 1;
  }
  //C              TRANSFORMATION TO MODE VOLTAGES, MULTIPLIED BY NUMBER OF    13357
  it2 = iabsz(it2);
  phsinv = unity / it2;
  it1 = k + 1;
  ii = length(it1);
  if (length(k) > 0) {
    ii = length(k);
  }
  gus1 = it2;
  n3 = litype(k);
  //C                                            ** M*VMODE=M*QFD(TRANSPOSEDM31.3194
  it1 = k;
  if (iprsup >= 3) {
    write(lunit6,
      "(' GUS1, N3, IT1 AND IT2 AT 21194 ARE',e12.5,3i10)"), gus1,
      n3, it1, it2;
  }
  FEM_DO_SAFE(i, 1, it2) {
    n1 = -kbus(it1);
    n2 = mbus(it1);
    volt(i) = e(n1);
    ndx1 = lsiz26 + i;
    volt(ndx1) = e(n2);
    if (iprsup >= 1) {
      write(lunit6,
        "(' E(',i3,'), AND E(',i3,') AT 31194 ARE',2e15.7)"), n1, n2,
        e(n1), e(n2);
    }
    it1++;
  }
  FEM_DO_SAFE(i, 1, it2) {
    ci1 = 0.0f;
    ck1 = 0.0f;
    ndx1 = lsiz26;
    FEM_DO_SAFE(j, 1, it2) {
      yx = qfd(n3);
      ci1 += yx * volt(j);
      ndx1++;
      ck1 += yx * volt(ndx1);
      n3++;
    }
    volti(i) = ci1 * gus1;
    voltk(i) = ck1 * gus1;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' (VOLT(I),         VOLTI(I), VOLTK(I), I=1,IT2) ARE',/(1x,9e14.6))");
      FEM_DO_SAFE(i, 1, it2) {
        wloop, volt(i), volti(i), voltk(i);
      }
    }
  }
  ndx1 = lsiz26 + 1;
  ndx2 = lsiz26 + it2;
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, "(' VOLT:',8e16.8)");
      FEM_DO_SAFE(i, ndx1, ndx2) {
        wloop, volt(i);
      }
    }
  }
  gus1 = unity;
  //C              UPDATE MODE QUANTITIES AND FIND PHASE VECTORS I FOR RIGHTM29.2059
  ci1 = 0;
  if (modout <= 0) {
    goto statement_4641;
  }
  FEM_DO_SAFE(i, 1, modout) {
    n7 = nmodal + i;
    bvalue(n7) = volti(i) * phsinv;
    n8 = n7 + modout;
    bvalue(n8) = voltk(i) * phsinv;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' MODE VOLTAGES IN  ''SUBTS2'' .',3i10,/(1x,8e16.5))");
      wloop, nv, it2, k;
      FEM_DO_SAFE(i, 1, it2) {
        wloop, volti(i), voltk(i);
      }
    }
  }
  //C              UPDATE MODE QUANTITIES AND FIND PHASE VECTORS I FOR RIGHT   13407
statement_4641:
  ck1 = 0.f;
  msign = k;
  i = 0;
statement_41189:
  i++;
  if (imodel(msign) == -2) {
    goto statement_10125;
  }
  n3 = nr(msign);
  if (n3 < 0) {
    goto statement_1187;
  }
  it1 = ii + ipoint;
  n4 = it1 + n3;
  if (it1 > lpast) {
    it1 = it1 - lpast;
  }
  if (n4 > lpast) {
    n4 = n4 - lpast;
  }
  it21 = it1 + 1;
  n41 = n4 + 1;
  if (it21 > lpast) {
    it21 = 1;
  }
  if (n41 > lpast) {
    n41 = 1;
  }
  xmn4 = xm(n4);
  a = cik(msign);
  d2 = 1.0f - a;
  gus2 = ci(msign);
  h1 = std::abs(gus2);
  h2 = std::abs(ck(msign));
  //C                                                                       M44.2256
  //C                                   current output for single distributeM44.2257
  //C                                                                       M44.2258
  if (n2 > 0) {
    goto statement_3811;
  }
  n2 = -n2;
  //C!w
  read(cmn.bus4, star), bus4z;
  //C!w
  read(cmn.bus2, star), bus2z;
  bus4z = 1.f + h2;
  if (bus2z < 0.f) {
    bus4z = 2.0f * h2;
  }
  bus4z = h1 * e(n1) / bus4z - xk(n4);
  kcount++;
  bvalue(kcount) = bus4z;
  //C                                                                       M44.2266
statement_3811:
  if (iprsup > 8) {
    write(lunit6,
      "('0IN \"SUBTS2\".  I, MSIGN, IT1, IT21, CIK(MSIGN),',"
      "' CI(MSIGN), CK(MSIGN), XM(IT1), XK(IT1), XM(IT21),',"
      "' XK(IT21) FOLLOW .....',/,1x,4i5,7e15.6)"),
      i, msign, it1, it21, cik(msign), ci(msign), ck(msign), xm(it1),
      xk(it1), xm(it21), xk(it21);
  }
  xm(n4) = h1 * volti(i) - h2 * xk(n4);
  xk(n4) = h1 * voltk(i) - h2 * xmn4;
  if (ck(msign) < 0.0f) {
    goto statement_20510;
  }
  h1 = xk(it1) * a + xk(it21) * d2;
  d2 = xm(it1) * a + xm(it21) * d2;
  if (gus2 < 0.0f) {
    goto statement_1192;
  }
  a = h1 + d2;
  d2 = (h1 - d2) * h2;
  h1 = (a + d2) / 2.0f;
  d2 = (a - d2) / 2.0f;
statement_1192:
  xk(n41) = h1;
  xm(n41) = d2;
  if (iprsup > 6) {
    {
      write_loop wloop(cmn, lunit6,
        "('0IN \"SUBTS2\".  I, MSIGN, IT1, N41, AND',"
        "' (XK(J), XM(J), J=IT1, N41)  FOLLOW  ....',5x,4i5,/(1x,5e25.16))");
      wloop, i, msign, it1, n41;
      FEM_DO_SAFE(j, it1, n41) {
        wloop, xk(j), xm(j);
      }
    }
  }
statement_1188:
  ii += n3 + 2;
  //CJ                                                                      M31.3213
  goto statement_10130;
  //C                                                                       M31.3215
  //C                  CALCULATE EQUIVALENT CURRENT SOURCES                 M31.3216
  //C                  AND UPDATE HISTORY VECTORS FOR F.D.                  M31.3217
  //C                  MULTI-PHASE LINES                                    M31.3218
  //C                                                                       M31.3219
statement_10125:
  vkd = volti(i) * phsinv;
  vmd = voltk(i) * phsinv;
  nrz = cki(msign);
  nra = ckkjm(msign);
  n11 = indhst(msign);
  n1 = cnvhst(n11) * dltinv + 2.0f;
  n2 = kodsem(msign);
  nraz1 = nra + nrz;
  nraz2 = nraz1 + nraz1;
  nraz3 = nraz2 + nraz1;
  nra3 = nra * 3;
  nrz2 = nrz + nrz;
  nrz3 = nrz2 + nrz;
  n31 = n2 + nraz2;
  n32 = nraz3 + 4;
  n33 = n31 + n32;
  n34 = n33 + nrz2;
  n3 = n31 + nrz3 + 1;
  n7 = n3 + nra3;
  n10 = n3 + 1;
  //C                                           N10 is where first cell of CM44.2267
  ind = nr(msign) + ipoint - 1;
  if (ind > lpast) {
    ind = ind - lpast;
  }
  d23 = 1.0f / sconst(n10);
  if (t == 0.0f) {
    goto statement_81000;
  }
  //C                                                                     !tM44.2268
  //C     UPDATE HISTORY VECTORS                                            M31.3233
  aikd = vkd * d23 - cnvhst(n11 + 13);
  aimd = vmd * d23 - cnvhst(n11 + 14);
  FEM_DO_SAFE(ii, 1, nrz) {
    nn1 = n31 + ii;
    nn2 = nn1 + nrz;
    nn3 = nn2 + nrz;
    nn4 = nn1 + n32;
    nn5 = nn4 + nrz;
    //C                                    eki= mi*eki(t-DT) + pi*ik(t) + qi*iM44.2269
    //C                                                      SCONST(NN4) was eM44.2270
    //C                                                     CNVHST(N11+5) was M44.2271
    //C                                                                 AIKD wM44.2272
    //C                                                                       M44.2273
    //C     ek(t) = SUM eki(t)                                                M44.2274
    //C           = SUM ! mi*eki(t-DT) + Pi*ik(t) + Qi*ik(t-DT) }             M44.2275
    //C                                                                       M44.2276
    sconst(nn4) = sconst(nn2) * aikd + sconst(nn3) * cnvhst(n11 +
      5) + sconst(nn1) * sconst(nn4);
    sconst(nn5) = sconst(nn2) * aimd + sconst(nn3) * cnvhst(n11 +
      6) + sconst(nn1) * sconst(nn5);
  }
  FEM_DO_SAFE(ii, 1, nra) {
    nn6 = n10 + ii;
    nn7 = nn6 + nra;
    nn8 = nn7 + nra;
    nn9 = n34 + ii;
    nn10 = nn9 + nra;
    //C                                                                       M44.2277
    //C                                                                       M44.2278
    //C          bk(t) = SUM
    //C                                                                       M44.2280
    //C                                                                       M44.2281
    sconst(nn9) = sconst(nn6) * sconst(nn9) + sconst(nn7) * cnvhst(
      n11 + 8) + sconst(nn8) * cnvhst(n11 + 7);
    sconst(nn10) = sconst(nn6) * sconst(nn10) + sconst(nn7) * cnvhst(
      n11 + 10) + sconst(nn8) * cnvhst(n11 + 9);
  }
  cnvhst(n11 + 5) = aikd;
  cnvhst(n11 + 6) = aimd;
  nrf = ind + n1 - 1;
  if (nrf > lpast) {
    nrf = nrf - lpast;
  }
  xk(nrf) = 2.0f * vkd - cnvhst(n11 + 11);
  xm(nrf) = 2.0f * vmd - cnvhst(n11 + 12);
  if (iprsup == 0) {
    goto statement_81000;
  }
  write(lunit6,
    "(' AT T = ',e12.5,' FOR MARTI BRANCH',i4,/,' HISTORY VECTORS')"),
    t, i;
  j1 = nn4 - nrz + 1;
  j2 = nn5 - nrz + 1;
  j3 = nn9 - nra + 1;
  j4 = nn10 - nra + 1;
  write(lunit6, format_80140), j1, nn4;
  {
    write_loop wloop(cmn, lunit6, format_80145);
    FEM_DO_SAFE(ii, j1, nn4) {
      wloop, sconst(ii);
    }
  }
  write(lunit6, format_80140), j2, nn5;
  {
    write_loop wloop(cmn, lunit6, format_80145);
    FEM_DO_SAFE(ii, j2, nn5) {
      wloop, sconst(ii);
    }
  }
  write(lunit6, format_80140), j3, nn9;
  {
    write_loop wloop(cmn, lunit6, format_80145);
    FEM_DO_SAFE(ii, j3, nn9) {
      wloop, sconst(ii);
    }
  }
  write(lunit6, format_80140), j4, nn10;
  {
    write_loop wloop(cmn, lunit6, format_80145);
    FEM_DO_SAFE(ii, j4, nn10) {
      wloop, sconst(ii);
    }
  }
  write(lunit6,
    "(/,' FORWARD FUNCTIONS XK AND XM; POSITIONS',i6,'  TO',i6)"),
    ind, nrf;
  {
    write_loop wloop(cmn, lunit6, format_80145);
    FEM_DO_SAFE(ii, ind, nrf) {
      wloop, xk(ii);
    }
    FEM_DO_SAFE(ii, ind, nrf) {
      wloop, xm(ii);
    }
  }
  //C                                                                       M44.2282
  //C                                                                       M44.2283
  //C     EQUIVALENT CURRENT SOURCES                                        M31.3286
statement_81000:
  ekh = sconst(n3) * cnvhst(n11 + 5);
  emh = sconst(n3) * cnvhst(n11 + 6);
  FEM_DO_SAFE(ii, 1, nrz) {
    n4 = n31 + ii;
    n5 = n33 + ii;
    n6 = n5 + nrz;
    //C                                              !ekhv(t)=SUM(mi)*eki(t-DtM44.2284
    //C                                              !emhv(t)=SUM(mi)*emi(t-DtM44.2285
    ekh += sconst(n4) * sconst(n5);
    emh += sconst(n4) * sconst(n6);
  }
  //C                                                                       M44.2286
  //C     INTERPOLATION PROCESS FOR LAST POINT OF FORWARD FUNCTIONS         M31.3296
  //C                                                                       M44.2287
  temp1 = cnvhst(n11) * dltinv;
  itauo = temp1;
  frac = 1.0f - (temp1 - itauo);
  i1 = ind;
  i1p1 = i1 + 1;
  if (i1p1 > lpast) {
    i1p1 = i1p1 - lpast;
  }
  i1p2 = i1 + 2;
  if (i1p2 > lpast) {
    i1p2 = i1p2 - lpast;
  }
  //C                                                                       M44.2288
  //C                                        Xk=Fk>>>>(Vk+Zc*Ik)  coming froM44.2289
  //C                                        Xm=Fm>>>>(Vm+Zc*Im)  coming froM44.2290
  //C                                                                       M44.2291
  cnvhst(n11 + 7) = (xm(i1p1) - xm(i1)) * frac + xm(i1);
  cnvhst(n11 + 8) = (xm(i1p2) - xm(i1p1)) * frac + xm(i1p1);
  cnvhst(n11 + 9) = (xk(i1p1) - xk(i1)) * frac + xk(i1);
  cnvhst(n11 + 10) = (xk(i1p2) - xk(i1p1)) * frac + xk(i1p1);
  //C                                                                       M44.2292
  //C               bk(t) = SUMgi*bki(t-DT) + c*fm(t-Tau) + d*fm(t-Tau-DT)  M44.2293
  //C                         *************>>will be done in the loop 81050 M44.2294
  //C                                                                       M44.2295
  cnvhst(n11 + 11) = sconst(n7 + 2) * cnvhst(n11 + 8) + sconst(n7 +
    3) * cnvhst(n11 + 7);
  cnvhst(n11 + 12) = sconst(n7 + 2) * cnvhst(n11 + 10) + sconst(n7 +
    3) * cnvhst(n11 + 9);
  FEM_DO_SAFE(ii, 1, nra) {
    n8 = n10 + ii;
    n9 = n34 + ii;
    //C                                                                       M44.2296
    //C                bk(t) =SUB gi*bki(t-DT) + c*fm(t-Tau) + d*fm(t-Tau-DT) M44.2297
    //C                           *being done* + ^^^^^already done above^^^^^ M44.2298
    //C                                                                       M44.2299
    cnvhst(n11 + 11) += sconst(n8) * sconst(n9);
    cnvhst(n11 + 12) += sconst(n8) * sconst(n9 + nra);
  }
  cnvhst(n11 + 13) = (ekh + cnvhst(n11 + 11)) * d23;
  cnvhst(n11 + 14) = (emh + cnvhst(n11 + 12)) * d23;
  h1 = cnvhst(n11 + 13);
  d2 = cnvhst(n11 + 14);
  if (iprsup == 0) {
    goto statement_10130;
  }
  write(lunit6,
    "(/,' AT T = ',e12.5,' FOR MARTI BRANCH',i4,"
    "'   EQUIV. CIRCUIT, VOLTAGES AND CURRENT SOURCES:')"),
    t, i;
  write(lunit6, "(1x,6e16.7)"), ekh, emh, cnvhst(n11 + 11), cnvhst(n11 + 12),
    cnvhst(n11 + 13), cnvhst(n11 + 14);
statement_10130:
  volti(i) = h1 * gus1;
  voltk(i) = d2 * gus1;
  msign++;
  goto statement_1189;
statement_1187:
  h1 = 0.f;
  d2 = 0.f;
  goto statement_1188;
statement_20510:
  kf = msign;
  jf = it1;
  kf = cik(kf);
  ifdep2 = 2 * kf - 1;
  jfdep2 = 2 * lfdep + ifdep2;
  kfdep2 = 4 * lfdep + ifdep2;
  sk = 0.0f;
  sm = 0.0f;
  ik = n4;
  im = ik + lpast;
  iklim = 0;
statement_5140:
  L = iwtent(ifdep2);
  lbound = iwtent(ifdep2 + 1);
statement_5180:
  ik1 = ik - 1;
  im1 = im - 1;
  if (ik1 > iklim) {
    goto statement_5186;
  }
  ik1 += lpast;
  im1 += lpast;
statement_5186:
  if (im <= ik) {
    goto statement_35186;
  }
  xxik = xk(ik);
  xxim = xm(ik);
  goto statement_45186;
statement_35186:
  xxik = xm(im);
  xxim = xk(im);
statement_45186:
  sk += weight(L) * xxim;
  sm += weight(L) * xxik;
  //C     PRECEDING CODE REPLACES FOLLOWING TWO ORIGINAL RECORDS.           M28.5516
  //C     IT IS A PATCH, TO OBEY  COMMON  BOUNDARIES FOR BURROUGHS.         M28.5517
  //C5186 SK = SK + WEIGHT(L) * XX(IM)                                      M28.5518
  //C     SM = SM + WEIGHT(L) * XX(IK)                                      M28.5519
  if (iprsup >= 8) {
    write(lunit6,
      "(/,' PARTIAL SUM.',"
      "'       L      IK      IM     IK1     IM1   IKLIM  LBOUND',/,13x,7i8,/,"
      "13x,18x,'SK',18x,'SM',11x,'WEIGHT(L)',16x,'XXIK',16x,'XXIM',/,13x,"
      "5e20.11)"),
      L, ik, im, ik1, im1, iklim, lbound, sk, sm, weight(L), xxik,
      xxim;
  }
  L++;
  if (L >= lbound) {
    goto statement_5250;
  }
  ik = ik1;
  im = im1;
  goto statement_5180;
statement_5250:
  if (im1 <= ik1) {
    goto statement_35250;
  }
  xxik1 = xk(ik1);
  xxim1 = xm(ik1);
  goto statement_45250;
statement_35250:
  xxik1 = xm(im1);
  xxim1 = xk(im1);
statement_45250:
  iftail++;
  //C     PRECEDING CARDS ARE REPLACEMENT FOR TWO CARDS BELOW.              M28.5529
  //C     TEMPORARY PATCH TO OBSERVE  COMMON  BOUNDARIES.                   M28.5530
  //C5250 IFTAIL = IFTAIL + 1                                               M28.5531
  //C     DK = CON1(IFDEP2) * XX(IM)  +  CON1(JFDEP2) * XX(IM1)  +          M35.1616
  dk = con1(ifdep2) * xxim + con1(jfdep2) * xxim1 + con1(kfdep2) *
    stailk(iftail);
  if (iprsup >= 8) {
    write(lunit6,
      "(/,' STAILK UPDATE.',6x,'STAILK(IFTAIL)',6x,'STAILM(IFTAIL)',8x,"
      "'CON1(IFDEP2)',8x,'CON1(JFDEP2)',8x,'CON1(KFDEP2)',/,15x,5e20.11,/,15x,"
      "16x,'XXIK',15x,'XXIK1',16x,'XXIM',15x,'XXIM1',/,15x,5e20.11)"),
      stailk(iftail), stailm(iftail), con1(ifdep2), con1(jfdep2),
      con1(kfdep2), xxik, xxik1, xxim, xxim1;
  }
  stailk(iftail) = dk;
  sk += dk;
  //C     DM = CON1(IFDEP2) * XX(IK)  +  CON2(IFDEP2) * XX(IK1)  +          M35.1622
  dm = con1(ifdep2) * xxik + con1(jfdep2) * xxik1 + con1(kfdep2) *
    stailm(iftail);
  stailm(iftail) = dm;
  sm += dm;
  ndelt = t / deltat;
  if (ndelt < 10 && iprsup >= 2) {
    write(lunit6,
      "(/,' CONVOLUTION DONE.',"
      "'       K  IFDEP2  IFTAIL       L      IK      IM',14x,'DK',14x,'DM',"
      "14x,'SK',14x,'SM',/,18x,6i8,4e16.7)"),
      k, ifdep2, iftail, L, ik, im, dk, dm, sk, sm;
  }
  ifdep2++;
  jfdep2++;
  kfdep2++;
  if (ik > im) {
    goto statement_5300;
  }
  im = n4 - (iskip(kf) - 1);
  if (im <= 0) {
    im += lpast;
  }
  ik = im + lpast;
  iklim = lpast;
  goto statement_5140;
statement_5300:
  if (ndelt < 10 && iprsup >= 2) {
    write(lunit6,
      "(/,' DONE F.D. MODE.','       L      KF  IFDEP2       K  IFTAIL',18x,"
      "'SK',18x,'SM',/,16x,5i8,2e20.11)"),
      L, kf, ifdep2, k, iftail, sk, sm;
  }
  goto statement_1192;
statement_1189:
  if (i < it2) {
    goto statement_41189;
  }
  j = litype(k);
  //C*** IPHASE=TI*IMODE                                                    M29.2062
  n3 = j - 1;
  FEM_DO_SAFE(j, 1, it2) {
    h1 = 0.f;
    h2 = 0.f;
    n3++;
    n4 = n3;
    FEM_DO_SAFE(i, 1, it2) {
      yx = qfd(n4);
      h1 += yx * volti(i);
      h2 += yx * voltk(i);
      n4 += it2;
    }
    n1 = -kbus(k);
    n2 = mbus(k);
    f(n1) += h1;
    f(n2) += h2;
    if (iprsup >= 3) {
      write(lunit6,
        "('       J     IT2      N1      N2              H1              H2   "
        "        F(N1)           F(N2)',/,4i8,4(1x,e15.6))"),
        j, it2, n1, n2, h1, h2, f(n1), f(n2);
    }
    k++;
  }
  //C *** END OF CONVERSION TO IPHASE FOR UNTRANSPOSED OPTION               M29.2083
  it2 = 0;
  goto statement_1200;
  //C                                                                       M23.3932
  //C  RECURSIVE CONVOLUTION MODELS                                         M23.3933
  //C                                                                       M23.3934
statement_11780:
  it2 = fem::iabs(kodebr(k));
  phsinv = unity / it2;
  n2 = cik(k);
  //C  DEFINE THE TERMINAL VOLTAGE IN SEMAUX(0)(SEMAUX(IT2)) FOR KBUS(MBUS) M23.3937
  FEM_DO_SAFE(i, 1, it2) {
    if (n2 <= 0) {
      goto statement_11784;
    }
    d1 = 0.0f;
    d2 = 0.0f;
    FEM_DO_SAFE(j, 1, it2) {
      ii = j + k - 1;
      n3 = -kbus(ii);
      d1 += qfd(n2) * e(n3);
      n3 = fem::iabs(mbus(ii));
      d2 += qfd(n2) * e(n3);
      n2++;
    }
    goto statement_11786;
  statement_11784:
    ii = i + k - 1;
    n3 = -kbus(ii);
    d1 = e(n3);
    n3 = iabsz(mbus(ii));
    d2 = e(n3);
  statement_11786:
    n3 = it2 + i;
    semaux(i) = d1;
    semaux(n3) = d2;
    volt(i) = 0.0f;
    volti(i) = 0.0f;
    voltk(i) = 0.0f;
    ndx1 = lsiz26 + i;
    volt(ndx1) = 0.0f;
  }
  if (iprsup < 9) {
    goto statement_23200;
  }
  n3 = it2 + it2;
  {
    write_loop wloop(cmn, lunit6,
      "(/,'  AFTER CALCULATION OF MODAL/PHASE VOLTAGE VECTOR IN ''SUBTS2''.  '"
      ",i10,i10,f10.0,/(8(1x,e15.7)))");
    wloop, k, it2, cik(k);
    FEM_DO_SAFE(i, 1, n3) {
      wloop, semaux(i);
    }
  }
statement_23200:
  ii = k;
  if (kodsem(k) > 0) {
    goto statement_11824;
  }
  //C  CALCULATION OF BRANCH(VOLT) AND NORTON(VOLTI) I'S FOR LUMPED ELEMENTSM23.3971
statement_11790:
  n2 = std::abs(cki(ii)) - 1.0f;
  n3 = n2 / it2;
  n2 = n2 - n3 * it2 + 1;
  n4 = ck(ii);
  n5 = indhst(ii);
  n6 = -kodsem(ii);
  n3++;
  n7 = n3 + it2;
  d1 = semaux(n3) - semaux(n7);
  d4 = sconst(n6 + 1) * d1;
  d2 = d4 - cnvhst(n5);
  d3 = -d2 - d4;
  cnvhst(n5) = -d3;
  d2 += sconst(n6) * d1;
  switch (fem::if_arithmetic(n4)) {
  case -1: goto statement_11804;
  case  0: goto statement_11814;
  default: goto statement_11792;
  }
  //C  EXPONENTIAL REPRESENTATION OF THE TRANSFER FUNCTION.  COMPLETE CONVOLM23.3986
  //C  UTION TO GET CURRENT AT T=T0, THEN PREFORM PARTIAL CONV. TO GET I-NORM23.3987
statement_11792:
  if (iprsup >= 9) {
    write(lunit6, "(/,/,'  AT 11792.   ',5i10,3(1x,e15.7))"), n2, n3,
      n4, n5, n6, d1, d2, d3;
  }
  FEM_DO_SAFE(j, 1, n4) {
    d4 = cnvhst(n5 + 1) + d1 * sconst(n6 + 4);
    if (iprsup >= 9) {
      write(lunit6,
        "('  TOP OF LUMPED ELEMENT EXPONENTIAL CONVOLUTION LOOP.    ',2(2x,"
        "e15.8))"),
        cnvhst(n5 + 1), d4;
    }
    switch (fem::if_arithmetic(sconst(n6 + 2))) {
    case -1: goto statement_11794;
    case  0: goto statement_11796;
    default: goto statement_11798;
    }
  statement_11794:
    cnvhst(n5 + 1) = -sconst(n6 + 3) * cnvhst(n5) + sconst(n6 - 1) *
      d4 + sconst(n6 + 5) * d1;
    d4 = sconst(n6 - 1) * cnvhst(n5) + sconst(n6 + 3) * d4 + sconst(
      n6 + 1) * d1;
    d3 += d4 + d4;
    cnvhst(n5) = d4;
    goto statement_11800;
  statement_11796:
    d2 += d4;
    d4 = d4 * sconst(n6 + 3) + d1 * sconst(n6 + 5);
    d3 += d4;
    cnvhst(n5 + 1) = d4;
    goto statement_11800;
  statement_11798:
    d2 += d4 + d4;
    cnvhst(n5 + 1) = d4;
  statement_11800:
    n6 += 5;
    n5++;
    if (iprsup >= 9) {
      write(lunit6, "('  IN EXP. CONV. LOOP.  ',3i10,4(1x,e15.7))"),
        j, n5, n6, cnvhst(n5), d2, d3, d4;
    }
  }
  goto statement_11814;
  //C  PIECEWISE-LINEAR REPRESENTATION OF THE STEP FUNCTION.  COMPLETE CONV M23.4019
  //C  AT T=T0 TO GET NORTON I.  UPDATE CONV. HISTORY GO GET BRANCH I.      M23.4020
statement_11804:
  d4 = cnvhst(n5 + 1) + d1 * sconst(n6 + 3);
  d2 += d4;
  n7 = nr(ii);
  n8 = ipoint + fem::iabs(n7) + length(ii) - 3;
  if (n8 > lpast) {
    n8 = n8 - lpast;
  }
  n4 = n6 - n4 - n4 - 4;
  d5 = 0.0f;
  if (n7 < 0) {
    goto statement_11808;
  }
  //C  PAST HISTORY OF CONVOLUTION INPUT IS STORED IN 'XK'.                 M23.4029
  xk(n8) = d1;
  n8++;
  FEM_DOSTEP(j, n6, n4, 2) {
    d6 = sconst(j + 4) * dltinv;
    n7 = d6;
    d6 = d6 - n7;
    n7 = n8 - n7;
    if (n7 <= 0) {
      n7 += lpast;
    }
    n9 = n7 - 1;
    if (n9 <= 0) {
      n9 += lpast;
    }
    n10 = n9 - 1;
    if (n10 <= 0) {
      n10 += lpast;
    }
    d6 = xk(n7) + xk(n9) - d6 * (xk(n7) - xk(n10));
    d4 += sconst(j + 3) * (d5 - d6);
    d5 = d6;
  }
  if (iprsup < 9) {
    goto statement_11812;
  }
  n7 = fem::iabs(nr(ii)) + ipoint - 1;
  if (n7 > lpast) {
    n7 = n7 - lpast;
  }
  {
    write_loop wloop(cmn, lunit6, format_23010);
    wloop, n2, n3, n4, n5, n6, n7, n8, n9, n10, d1, d2, d3, d4, d5,
      d6, cnvhst(n5), cnvhst(n5 + 1);
    FEM_DO_SAFE(j, n7, n8) {
      wloop, xk(j);
    }
  }
  goto statement_11812;
  //C  PAST HISTORY OF CONVOLUTION INPUT IS STORED IN 'XM'.                 M23.4057
statement_11808:
  xm(n8) = d1;
  n8++;
  FEM_DOSTEP(j, n6, n4, 2) {
    d6 = sconst(j + 4) * dltinv;
    n7 = d6;
    d6 = d6 - n7;
    n7 = n8 - n7;
    if (n7 <= 0) {
      n7 += lpast;
    }
    n9 = n7 - 1;
    if (n9 <= 0) {
      n9 += lpast;
    }
    n10 = n9 - 1;
    if (n10 <= 0) {
      n10 += lpast;
    }
    d6 = xm(n7) + xm(n9) - d6 * (xm(n7) - xm(n10));
    d4 += sconst(j + 3) * (d5 - d6);
    d5 = d6;
  }
  if (iprsup < 9) {
    goto statement_11812;
  }
  n7 = fem::iabs(nr(ii)) + ipoint - 1;
  if (n7 > lpast) {
    n7 = n7 - lpast;
  }
  {
    write_loop wloop(cmn, lunit6, format_23010);
    wloop, n2, n3, n4, n5, n6, n7, n8, n9, n10, d1, d2, d3, d4, d5,
      d6, cnvhst(n5), cnvhst(n5 + 1);
    FEM_DO_SAFE(j, n7, n8) {
      wloop, xm(j);
    }
  }
statement_11812:
  d4 += sconst(n4 + 5) * d5;
  cnvhst(n5 + 1) = d4;
  d3 += d4;
statement_11814:
  volt(n2) += d2;
  volti(n2) += d3;
  ii++;
  if (cki(ii - 1) > 0) {
    goto statement_11790;
  }
  if (modout <= 0) {
    goto statement_11863;
  }
  FEM_DO_SAFE(i, 1, modout) {
    n7 = nv + i;
    bvalue(n7) = volt(i);
    n8 = n7 + modout;
    bvalue(n8) = volti(i);
  }
  //C  INCREMENT F TO REFLECT NORTON CONTRIBUTION OF THIS BRANCH.  COMPUTE  M23.4087
  //C  BRANCH CURRENT IF REQUESTED BY MBUS(.)                               M23.4088
statement_11863:
  n2 = cik(k);
  FEM_DO_SAFE(i, 1, it2) {
    ii = i + k - 1;
    n3 = -kbus(ii);
    n4 = mbus(ii);
    if (n2 > 0) {
      goto statement_11818;
    }
    if (n4 > 0) {
      goto statement_11816;
    }
    n4 = -n4;
    kcount++;
    bvalue(kcount) = volt(i);
  statement_11816:
    f(n3) = f(n3) - volti(i);
    f(n4) += volti(i);
    goto statement_11822;
  statement_11818:
    if (n4 > 0) {
      goto statement_11820;
    }
    n4 = -n4;
    d1 = 0.0f;
    n5 = n2;
    FEM_DO_SAFE(j, 1, it2) {
      d1 += qfd(n5) * volt(j);
      n5 += it2;
    }
    kcount++;
    bvalue(kcount) = d1;
  statement_11820:
    n5 = n2;
    d1 = 0.0f;
    FEM_DO_SAFE(j, 1, it2) {
      d1 = d1 - qfd(n5) * volti(j);
      n5 += it2;
    }
    if (iprsup >= 9) {
      write(lunit6,
        "('  PHASE CONVERSION AT 11822.  N2, N3, N4, KCOUNT, D1, BVALUE(KCOUNT"
        ") =   ',4i6,2(1x,e15.7))"),
        n2, n3, n4, kcount, d1, bvalue(kcount);
    }
    f(n3) += d1;
    f(n4) = f(n4) - d1;
    n2++;
  statement_11822:;
  }
  it2 = 1;
statement_11823:
  if (cki(k) < 0.0f) {
    goto statement_1200;
  }
  k++;
  goto statement_11823;
  //C  CALCULATION OF BRANCH VOLT(VOLTI) AND NORTON VOLTK(VIM) CURRENT      M23.4130
  //C  FOR TRANSMISSION LINE MODEL FOR KBUS(MBUS)                           M23.4131
statement_11824:
  n2 = std::abs(cki(ii)) - 1.0f;
  n3 = n2 * phsinv + 1;
  n2 = n2 - (n3 - 1) * it2 + 1;
  n4 = ck(ii);
  n5 = indhst(ii);
  n6 = kodsem(ii) + 1;
  n7 = nr(ii) + ipoint - 2;
  n8 = ci(ii);
  //C  D1(D2) = INCIDENT VOLTAGE WAVE AT T=T0 FOR KBUS(MBUS)                M23.4141
  //C  D3(D4) = INCIDENT VOLTAGE WAVE AT T=T0+DELTAT FOR KBUS(MBUS)         M23.4142
  //C  EXPONENTIAL(SEMLYEN) REPRESENTATION OF PROPAGATION TRANSFER FUNCTION M23.4143
  d1 = 0.0f;
  d2 = 0.0f;
  d3 = 0.0f;
  d4 = 0.0f;
  if (n8 == 0) {
    goto statement_11847;
  }
  n7 += 2;
  if (n7 > lpast) {
    n7 = n7 - lpast;
  }
  n9 = n7 - 1;
  if (n9 <= 0) {
    n9 += lpast;
  }
  n10 = n7 + 1;
  if (n10 > lpast) {
    n10 = n10 - lpast;
  }
  FEM_DO_SAFE(j, 1, n8) {
    if (iprsup >= 9) {
      write(lunit6,
        "('  TOP OF DO 11838.  N7, CNVHST(N5), CNVHST(N5+1), SCONST(N6) =  ',"
        "i10,3(1x,e15.7))"),
        n7, cnvhst(n5), cnvhst(n5 + 1), sconst(n6);
    }
    switch (fem::if_arithmetic(sconst(n6))) {
    case -1: goto statement_11830;
    case  0: goto statement_11826;
    default: goto statement_11828;
    }
  statement_11826:
    d1 += cnvhst(n5 + 0);
    d2 += cnvhst(n5 + 1);
    cnvhst(n5 + 0) = cnvhst(n5 + 0) * sconst(n6 + 1);
    cnvhst(n5 + 1) = cnvhst(n5 + 1) * sconst(n6 + 1);
    goto statement_11830;
  statement_11828:
    d5 = cnvhst(n5 + 0);
    d6 = cnvhst(n5 + 1);
    d1 += d5 + d5;
    d2 += d6 + d6;
    cnvhst(n5 + 0) = d5 * sconst(n6 + 1) - cnvhst(n5 + 2) * sconst(n6 + 6);
    cnvhst(n5 + 1) = d6 * sconst(n6 + 1) - cnvhst(n5 + 3) * sconst(n6 + 6);
    cnvhst(n5 + 2) = d5 * sconst(n6 + 6) + cnvhst(n5 + 2) * sconst(n6 + 1);
    cnvhst(n5 + 3) = d6 * sconst(n6 + 6) + cnvhst(n5 + 3) * sconst(n6 + 1);
  statement_11830:
    cnvhst(n5 + 0) += sconst(n6 + 2) * xm(n10) + sconst(n6 + 3) * xm(
      n7) + sconst(n6 + 4) * xm(n9);
    cnvhst(n5 + 1) += sconst(n6 + 2) * xk(n10) + sconst(n6 + 3) * xk(
      n7) + sconst(n6 + 4) * xk(n9);
    switch (fem::if_arithmetic(sconst(n6))) {
    case -1: goto statement_11836;
    case  0: goto statement_11832;
    default: goto statement_11834;
    }
  statement_11832:
    d3 += cnvhst(n5 + 0);
    d4 += cnvhst(n5 + 1);
    goto statement_11836;
  statement_11834:
    d3 += 2.0f * cnvhst(n5 + 0);
    d4 += 2.0f * cnvhst(n5 + 1);
  statement_11836:
    n5 += 2;
    n6 += 5;
    if (iprsup >= 9) {
      write(lunit6,
        "('  END OF DO 11838.  N5, N6, D3, D4, CNVHST(N5-2), CNVHST(N5-1) = ',"
        "2i5,4(1x,e13.6))"),
        n5, n6, d3, d4, cnvhst(n5 - 2), cnvhst(n5 - 1);
    }
  }
  n7 += length(ii) - 2;
  if (n7 > lpast) {
    n7 = n7 - lpast;
  }
  //C  UPDATE PAST HISTORY OF OUTGOING VOLTAGE WAVES FROM EACH BUS          M23.4242
  n9 = n3 + it2;
  xk(n7) = semaux(n3) - d1;
  xm(n7) = semaux(n9) - d2;
  d1 = xk(n7) - d1;
  d2 = xm(n7) - d2;
statement_11847:
  n10 = kodsem(ii);
  d5 = sconst(n10) * d1;
  d6 = sconst(n10) * d2;
  d3 = -d3 - d3;
  d4 = -d4 - d4;
  if (iprsup < 9) {
    goto statement_23110;
  }
  n8 = nr(ii) + ipoint - 1;
  if (n8 > lpast) {
    n8 = n8 - lpast;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,'  AFTER VOLTAGE CONVOLUTION.  N2, N3, N4, N5, N6, N7, N8  = ',7i10,"
      "/,'   SEMAUX(N3), SEMAUX(N9), D1, D2, D3, D4, D5, D6, (XK(J), XM(J), J="
      "N8, N7)  ....  ',/(8(1x,e15.7)))");
    wloop, n2, n3, n4, n5, n6, n7, n8, semaux(n3), semaux(n9), d1,
      d2, d3, d4, d5, d6;
    FEM_DO_SAFE(j, n8, n7) {
      wloop, xk(j), xm(j);
    }
  }
  //C  VOLT(VOLTI) = BRANCH CURRENT AT T=T0 AT KBUS(MBUS).                  M23.4263
  //C  VOLTK(VIM) = NORTON CURRENT VIA PARTIAL ADMITTANCE CONVOLUTION.      M23.4264
  //C  EXPONENTIAL(SEMLYEN) REPRESENTATION OF ADMITTANCE IMPULSE...         M23.4265
statement_23110:
  d7 = sconst(n10) * d3;
  d8 = sconst(n10) * d4;
  if (n4 == 0) {
    goto statement_11862;
  }
  d11 = semaux(n3);
  d12 = semaux(n9);
  FEM_DO_SAFE(j, 1, n4) {
    d9 = cnvhst(n5 + 0) + d11 * sconst(n6 + 2);
    d10 = cnvhst(n5 + 1) + d12 * sconst(n6 + 2);
    if (iprsup >= 9) {
      write(lunit6, "('  TOP OF DO 11856.  ',2i10,5(1x,e15.7))"), n5,
        n6, cnvhst(n5), cnvhst(n5 + 1), d9, d10, sconst(n6);
    }
    switch (fem::if_arithmetic(sconst(n6))) {
    case -1: goto statement_11848;
    case  0: goto statement_11850;
    default: goto statement_11852;
    }
  statement_11848:
    cnvhst(n5 + 0) = cnvhst(n5 - 2) * sconst(n6 + 1) + d9 * sconst(
      n6 - 3) + d3 * sconst(n6 + 2) + d1 * sconst(n6 + 3);
    d9 = cnvhst(n5 - 2) * sconst(n6 - 3) - d9 * sconst(n6 + 1) + d3 *
      sconst(n6 - 2) + d1 * sconst(n6 - 1);
    cnvhst(n5 + 1) = cnvhst(n5 - 1) * sconst(n6 + 1) + d10 * sconst(
      n6 - 3) + d4 * sconst(n6 + 2) + d2 * sconst(n6 + 3);
    d10 = cnvhst(n5 - 1) * sconst(n6 - 3) - d10 * sconst(n6 + 1) +
      d4 * sconst(n6 - 2) + d2 * sconst(n6 - 1);
    cnvhst(n5 - 2) = d9;
    cnvhst(n5 - 1) = d10;
    d7 += d9 + d9;
    d8 += d10 + d10;
    goto statement_11854;
  statement_11850:
    d5 += d9;
    d6 += d10;
    d9 = d9 * sconst(n6 + 1) + d3 * sconst(n6 + 2) + d1 * sconst(n6 + 3);
    d10 = d10 * sconst(n6 + 1) + d4 * sconst(n6 + 2) + d2 * sconst(n6 + 3);
    cnvhst(n5 + 0) = d9;
    cnvhst(n5 + 1) = d10;
    d7 += d9;
    d8 += d10;
    goto statement_11854;
  statement_11852:
    d5 += d9 + d9;
    d6 += d10 + d10;
    cnvhst(n5 + 0) = d9;
    cnvhst(n5 + 1) = d10;
  statement_11854:
    n5 += 2;
    n6 += 4;
    if (iprsup >= 9) {
      write(lunit6,
        "('  END OF DO 11856.  D5, D6, D7, D8, D9, D10 = ',6(1x,e13.6))"),
        d5, d6, d7, d8, d9, d10;
    }
  }
statement_11862:
  volt(n2) += d5;
  volti(n2) += d6;
  voltk(n2) += d7;
  ndx1 = lsiz26 + n2;
  volt(ndx1) += d8;
  ii++;
  if (cki(ii - 1) > 0.0f) {
    goto statement_11824;
  }
  //C  INCREMENT F TO INCLUDE THE NORTON CURRENTS OF THIS SET OF COUPLED    M23.4377
  //C  BRANCHES.  INCLUDE BRANCH CURRENT IN 'BVALUE' IF MBUS(.) .LT. 0.     M23.4378
  n2 = cik(k);
  FEM_DO_SAFE(i, 1, it2) {
    ii = i + k - 1;
    n3 = -kbus(ii);
    n4 = mbus(ii);
    if (n2 > 0) {
      goto statement_11866;
    }
    if (n4 > 0) {
      goto statement_11864;
    }
    n4 = -n4;
    //C  CURRENTS REQUESTED BY COL-80 PUNCH IS FROM 'KBUS' TO 'MBUS' AT 'KBUS'M23.4387
    //C  TERMINAL.  THE CORRESPONDING 'BVALUE(KCOUNT) =  ... ' CARD WHICH IS AM23.4388
    //C  COMMENT IS FOR THE CURRENT FROM 'MBUS' TO 'KBUS' AT 'MBUS' TERMINAL. M23.4389
    kcount++;
    bvalue(kcount) = volt(i);
    //C     KCOUNT = KCOUNT + 1                                               M23.4392
    //C     BVALUE(KCOUNT) = VOLTI(I)                                         M23.4393
  statement_11864:
    f(n3) = f(n3) - voltk(i);
    ndx1 = lsiz26 + i;
    f(n4) = f(n4) - volt(ndx1);
    goto statement_11874;
  statement_11866:
    if (n4 > 0) {
      goto statement_11870;
    }
    n4 = -n4;
    d1 = 0.0f;
    d2 = 0.0f;
    n5 = n2;
    FEM_DO_SAFE(j, 1, it2) {
      d1 += qfd(n5) * volt(j);
      d2 += qfd(n5) * volti(j);
      n5 += it2;
    }
    kcount++;
    bvalue(kcount) = d1;
    //C     KCOUNT = KCOUNT + 1                                               M23.4409
    //C     BVALUE(KCOUNT) = D2                                               M23.4410
  statement_11870:
    n5 = n2;
    d1 = 0.0f;
    d2 = 0.0f;
    ndx1 = lsiz26;
    FEM_DO_SAFE(j, 1, it2) {
      d1 = d1 - qfd(n5) * voltk(j);
      ndx1++;
      d2 = d2 - qfd(n5) * volt(ndx1);
      n5 += it2;
    }
    if (iprsup >= 9) {
      write(lunit6,
        "('  AFTER PHASE CONVERSION.  N2, N3, N4, KCOUNT =   ',4i10,/,"
        "'   BVALUE(KCOUNT), D1, D2 =   ',3(1x,e15.7))"),
        n2, n3, n4, kcount, bvalue(kcount), d1, d2;
    }
    f(n3) += d1;
    f(n4) += d2;
    n2++;
  statement_11874:;
  }
  it2 = 1;
statement_11876:
  if (cki(k) < 0.0f) {
    goto statement_1200;
  }
  k++;
  goto statement_11876;
statement_1190:
  if (cmn.ipunch == 0) {
    goto statement_1200;
  }
  if (length(k) <= 0) {
    goto statement_3564;
  }
  if (kodebr(k) > 0) {
    goto statement_3564;
  }
  redu17(x(n3), it2, ll0);
statement_3564:
  FEM_DO_SAFE(i, 1, it2) {
    volti(i) = -volti(i) * onehaf;
    voltk(i) = -voltk(i) * onehaf;
    if (kodebr(k) > 0) {
      goto statement_1191;
    }
    volt(i) = -volt(i);
  statement_1191:;
  }
  mult(x(n3), volt(1), cik(k), it2, ll1);
  mult(c(n3), volti(1), ci(k), it2, ll1);
  mult(c(n3), voltk, ck(k), it2, ll1);
statement_1200:
  k += it2;
  if (iprsup >= 4) {
    {
      write_loop wloop(cmn, lunit6, format_7342);
      wloop, k, ibr;
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, f(i);
      }
    }
  }
  if (k <= ibr) {
    goto statement_1100;
  }
  cmn.lastov = nchain;
  nchain = 18;
  if (iprsup >= 4) {
    {
      write_loop wloop(cmn, lunit6, format_7342);
      wloop, k, ibr;
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, f(i);
      }
    }
  }

}

void subts4(
  common& cmn)
{
  common_write write(cmn);
  double& t = cmn.t;
  double& tenerg = cmn.tenerg;
  const auto& moncar = cmn.moncar;
  auto& lstat = cmn.lstat;
  int& ncomp = cmn.ncomp;
  int& lastov = cmn.lastov;
  int& ialter = cmn.ialter;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& ntot = cmn.ntot;
  const auto& cursub = cmn.cursub;
  auto& spum = cmn.spum;
  const auto& kknonl = cmn.kknonl;
  const auto& znonl = cmn.znonl;
  const auto& isubeg = cmn.isubeg;
  auto& e = cmn.e;
  const auto& kpsour = cmn.kpsour;
  //
  auto& lunit6 = cmn.lunit6;
  int k = fem::int0;
  int n1 = fem::int0;
  int n15 = fem::int0;
  int n4 = fem::int0;
  int m = fem::int0;
  int n8 = fem::int0;

  auto& knt = moncar(1);
  auto& kbase = moncar(2);
  auto& kloaep = moncar(9);

  auto ispum = ArraySpan(reinterpret_cast<int*>(&spum(1)), spum.size() * 2);

  if (iprsup >= 6) {
    write(lunit6,
      "(' TOP \"SUBTS4\". KSWTCH, INONL, NUM99,',' NCOMP, NTOT =',10i8)"),
      cmn.kswtch, cmn.inonl, cmn.num99, ncomp, ntot;
  }
  if (cmn.numum <= 0) {
    goto statement_1742;
  }
  solvum(cmn, spum(cmn.iureac), 
    spum(cmn.iugpar), spum(cmn.iufpar), spum(cmn.iuhist), spum(cmn.iuumrp), 
    ispum(cmn.iunod1), ispum(cmn.iunod2), ispum(cmn.iujclt), ispum(cmn.iujclo), 
    ispum(cmn.iujtyp), ispum(cmn.iunodo), ispum(cmn.iujtmt), spum(cmn.iuhism), 
    spum(cmn.iuomgm), spum(cmn.iuomld), spum(cmn.iutham), spum(cmn.iuredu), 
    spum(cmn.iureds), spum(cmn.iuflds), spum(cmn.iufldr), spum(cmn.iurequ), 
    spum(cmn.iuflqs), spum(cmn.iuflqr), ispum(cmn.iujcds), ispum(cmn.iujcqs), 
    spum(cmn.iuflxd), spum(cmn.iuflxq), ispum(cmn.iunppa), spum(cmn.iurotm), 
    ispum(cmn.iuncld), ispum(cmn.iunclq), ispum(cmn.iujtqo), ispum(cmn.iujomo), 
    ispum(cmn.iujtho), spum(cmn.iureqs), spum(cmn.iuepso), spum(cmn.iudcoe), 
    ispum(cmn.iukcoi), spum(cmn.iuvolt), spum(cmn.iuangl), ispum(cmn.iunodf), 
    ispum(cmn.iunodm), ispum(cmn.iukumo), ispum(cmn.iujumo), spum(cmn.iuumou));

  if (cmn.kill > 0) {
    goto statement_9200;
  }
statement_1742:
  if (ncomp <= 0) {
    goto statement_1570;
  }
  if (iprsup >= 6) {
    {
      write_loop wloop(cmn, lunit6,
        "(' N.L. ELEMENT COMP.   K, KKNONL, E, ZNONL',2i10,2e20.8)");
      FEM_DO_SAFE(k, 2, ntot) {
        wloop, k, kknonl(k), e(k), znonl(k);
      }
    }
  }
  FEM_DO_SAFE(k, 2, ntot) {
    n1 = kpsour(k);
    if (n1 == 0) {
      goto statement_1560;
    }
    n15 = isubeg(n1);
    n4 = k;
  statement_1111:
    m = n15 / 5 + 1;
    e(k) += cursub(m) * znonl(n4);
    n15 = kknonl(n15);
    if (n15 == isubeg(n1)) {
      goto statement_2323;
    }
    n4 += ntot;
    goto statement_1111;
  statement_2323:
    n8 = n15 / 5 + 1;
    if (iprsup >= 7) {
      write(lunit6,
        "(' ROW SUPER.','       K      N1     N15',14x,'E',9x,'CURSUB',10x,"
        "'ZNONL',/,11x,3i8,3e15.6)"),
        k, n1, n15, e(k), cursub(n8), znonl(k);
    }
  statement_1560:;
  }
statement_1570:
  if (ialter == 1) {
    ialter = 0;
  }
  if (iprsup > 6) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,/,' VECTOR E(K) AT 1571, IMMEDIATELY AFTER CALC',/(1x,5e25.15))");
      FEM_DO_SAFE(k, 1, ntot) {
        wloop, e(k);
      }
    }
  }
  if (tenerg < 0.0f) {
    goto statement_1609;
  }
  if (knt > 1) {
    goto statement_1609;
  }
  if (kbase < 2) {
    goto statement_1609;
  }
  if (t + cmn.deltat < tenerg) {
    goto statement_1609;
  }
  if (iprsup >= -1) {
    write(lunit6,
      "(/,' AT END OF  ''SUBTS4'', COMMON BLOCKS ARE WRITTEN ON  ''LUNIT2''  D"
      "URING THE 1ST ENERGIZATION OF  ''STATISTICS''  CASE.',/,"
      "'     KNT   KBASE  KLOAEP  NENERG',14x,'T',9x,'TENERG',/,4i8,2e15.6)"),
      knt, kbase, kloaep, cmn.nenerg, t, tenerg;
  }
  tables(cmn);
  tenerg = -t;
statement_1609:
  if (t <= cmn.tmax) {
    goto statement_1611;
  }
  if (cmn.memsav != 0) {
    goto statement_1613;
  }
statement_1611:
  lastov = nchain;
  nchain = 16;
  return;
statement_1613:
  lastov = nchain;
  nchain = 20;
  return;
statement_9200:
  lastov = nchain;
  lstat(18) = nchain;
  nchain = 51;

}


// 16.  FIRST QUARTER OF TIME-STEP LOOP (CHECKING FOR CHANGES OF     
//      SWITCHES AND PSEUDO-NONLINEAR ELEMENTS, RETRIANGULARIZATION  
//      OF YBB  AND CALCULATION OF THEVENIN IMPEDANCE VECTORS).     
// 17.  SECOND QUARTER OF TIME-STEP LOOP (BRANCH-TABLE HISTORY       
//      UPDATING, ADDITION OF BRANCH CONTRIBUTIONS TO NODAL          
//      INJECTED CURRENT VECTOR I ).                                
// 18.  THIRD QUARTER OF TIME-STEP LOOP (SOURCE UPDATE, REPEAT       
//      SOLUTION OF (Y)V = I   FOR NODE VOLTAGE VECTOR  V ).       
// 19.  FOURTH QUARTER OF TIME-STEP LOOP (SOLUTION OF 3-PHASE        
//      NONLINEARITIES AND COMPENSATION-BASED ROTATING               
//      MACHINERY [TYPE-50 S.M., U.M.],  SUPERPOSITION TO            
//      GIVE THE TOTAL SOLUTION INCLUDING COMPENSATION).             
void over16(
  common& cmn)
{
  common_write write(cmn);
  const auto& iprsov = cmn.iprsov;
  auto& lastov = cmn.lastov;
  auto& kill = cmn.kill;
  auto& nchain = cmn.nchain;
  auto& iprsup = cmn.iprsup;
  auto& spum = cmn.spum;
  //
  auto& lunit6 = cmn.lunit6;
  int n1 = fem::int0;

  auto ispum = ArraySpan(reinterpret_cast<int*>(&spum(1)), spum.size() * 2);

  if (iprsup >= 1) {
    write(lunit6, "('  BEGIN MODULE \"OVER16\".')");
  }
  if (cmn.numum == 0) {
    goto statement_2450;
  }
  if (lastov == 1) {
    goto statement_2450;
  }
  if (lastov == 20) {
    goto statement_2450;
  }
  solvum(cmn, 
    spum(cmn.iureac), spum(cmn.iugpar), spum(cmn.iufpar), spum(cmn.iuhist), spum(cmn.iuumrp), 
    ispum(cmn.iunod1), ispum(cmn.iunod2), ispum(cmn.iujclt), ispum(cmn.iujclo), ispum(cmn.iujtyp), 
    ispum(cmn.iunodo), ispum(cmn.iujtmt), spum(cmn.iuhism), spum(cmn.iuomgm), spum(cmn.iuomld),
    spum(cmn.iutham), spum(cmn.iuredu), spum(cmn.iureds), spum(cmn.iuflds), spum(cmn.iufldr), 
    spum(cmn.iurequ), spum(cmn.iuflqs), spum(cmn.iuflqr), ispum(cmn.iujcds), ispum(cmn.iujcqs), 
    spum(cmn.iuflxd), spum(cmn.iuflxq), ispum(cmn.iunppa), spum(cmn.iurotm), ispum(cmn.iuncld), 
    ispum(cmn.iunclq), ispum(cmn.iujtqo), ispum(cmn.iujomo), ispum(cmn.iujtho), spum(cmn.iureqs),
    spum(cmn.iuepso), spum(cmn.iudcoe), ispum(cmn.iukcoi), spum(cmn.iuvolt), spum(cmn.iuangl), 
    ispum(cmn.iunodf), ispum(cmn.iunodm), ispum(cmn.iukumo), ispum(cmn.iujumo), spum(cmn.iuumou));
statement_2450:
  if (kill == 0) {
    goto statement_2468;
  }
  nchain = 51;
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT MODULE  \"OVER16\".   KILL =',i5)"), kill;
  }
  goto statement_99999;
statement_2468:
  if (cmn.m4plot == 1) {
    emtspy(cmn);
  }
  n1 = nchain - 15;
  iprsup = iprsov(nchain);
  if (n1 > 4) {
    goto statement_99999;
  }
  if (n1 <= 0) {
    goto statement_99999;
  }
  switch (n1) {
  case 1: goto statement_3016;
  case 2: goto statement_3017;
  case 3: goto statement_3018;
  case 4: goto statement_3019;
  default: break;
  }
statement_3016:
  subts1(cmn);
  goto statement_2450;
statement_3017:
  subts2(cmn);
  goto statement_2450;
statement_3018:
  subts3(cmn);
  goto statement_2450;
statement_3019:
  subts4(cmn);
  goto statement_2450;
statement_99999:;

} // over16

void katalg(
  common& cmn)
{
#if 0
  common_read read(cmn);
  common_write write(cmn);
  auto& lunit2 = cmn.lunit2;
  int& memsav = cmn.memsav;
  int& ltlabl = cmn.ltlabl;
  int& indbuf = cmn.indbuf;
  int& mflush = cmn.mflush;
  int& newvec = cmn.newvec;
  auto& karray = static_cast<common_c29b01&>(cmn).karray;
  const auto& locker = cmn.locker;
  //
  auto& lunit6 = cmn.lunit6;
  int j = fem::int0;
  fem::str<132> ansi132 = fem::char0;
  //C     VAX-11/780  INSTALLATION-DEPENDENT MODULE WHICH IS USED           M28.6594
  //C     TO HONOR THE MISCELLANEOUS DATA CARD REQUEST FOR EMTP TABLE       M28.6595
  //C     SAVING, FOR LATER  "START AGAIN"  USAGE.   A CALL TO THE          M28.6596
  //C     UNIVERSAL MODULE  "TABLES"  ACTUALLY DUMPS MEMORY ONTO DISK.      M28.6597
  //C     LOGIC ASSOCIATED WITH OTHER THAN  MEMSAV=0  OR  MEMSAV=1          M30.1013
  //C     CAN GENERALLY BE IGNORED BY OTHER SYSTEMS;  IT APPLIES            M30.1014
  //C     ONLY TO RTM (REAL TIME MONITOR) USE OF BPA VAX.                   M30.1015
  //C Share with "OVER1" only
  if (cmn.iprsup >= 1) {
    write(lunit6,
      "(/,' ENTER  \"KATALG\" .','    ICAT  MEMSAV  LUNIT2  LTLABL',/,18x,"
      "10i8)"),
      cmn.icat, memsav, lunit2, ltlabl;
  }
  //C NO TABLE MOVING AT ALL
  if (memsav == 0) {
    goto statement_9800;
  }
  //C IF INTERACTIVE EMTP CONTROL, THEN
  //C MAKE END-TIME OF SIMULATION INFINITE
  if (cmn.m4plot == 1) {
    cmn.tmax = cmn.fltinf;
  }
  //C "RESTORE"   USE
  if (memsav == 1016) {
    goto statement_2634;
  }
  write(lunit6,
    "(/,20x,'----- \"MEMSAV = 1  REPRESENTS',"
    "' REQUEST FOR TABLE DUMPING ON DISK.')");
  cmn.io.close(lunit2);
  cmn.io.open(lunit2, "TPTABLES.BIN")
    .form("UNFORMATTED")
    .status("NEW");
  tables(cmn);
  write(lunit2, fem::unformatted), locker;
  cmn.io.rewind(79);
  FEM_DO_SAFE(j, 1, 9999) {
    try {
      read(79, "(a132)"), ansi132;
    }
    catch (fem::read_end const&) {
      goto statement_2479;
    }
    write(lunit2, fem::unformatted), ansi132;
  }
statement_2479:
  cmn.io.close(lunit2)
    .status("SAVE");
  karray(1) = indbuf;
  karray(2) = mflush;
  karray(3) = newvec;
  write(lunit6,
    "(26x,'SUCCESSFUL SAVING OF EMTP',' TABLES AS FILE  \"TPTABLES.BIN\" .',"
    "'    LTLABL  =',i8)"),
    ltlabl;
  //C EXIT MODULE (NO SPY)
  if (memsav == 1) {
    goto statement_9800;
  }
  //C EXIT MODULE AFTER "EMTSPY" LINKAGE SET
  goto statement_9700;
  //C     FOLLOWING CODE SERVICES  "RESTORE"  OF  "EMTSPY".  MEMORY         M35.1678
  //C     IS RESTORED FROM DUMPING OF PREVIOUS "SLEEP" OR "SAVE":           M35.1679
statement_2634:
  write(lunit6,
    "(' Begin EMTP table restoration.  LTLABL =',i7,"
    "' .  Wait for completion.')"),
    ltlabl;
  cmn.io.close(lunit2);
  cmn.io.open(lunit2, "TPTABLES.BIN")
    .form("UNFORMATTED")
    .status("OLD");
  tables(cmn);
  cmn.io.close(lunit2)
    .status("SAVE");
  //C     NEXT, FOR RTM USE, RESTORE KEY "OVDRIVKOM.FOR" VARIABLES:         M30.1068
  indbuf = karray(1);
  mflush = karray(2);
  newvec = karray(3);
  write(lunit6,
    "(' Restoration Complete, user can now',"
    "' begin  DEPOSITing  EMTP  variables via  SPY .')");
  //C  ?????????????  TABLE CHANGES DONE.
  memsav = 0;
  //C LOCK FLAG FOR "EMTSPY" DIALOGUE IN "OVER16"
statement_9700:
  cmn.kbreak = 1;
statement_9800:;
#endif
}

// PUNCH AND PRINT TERMINAL CONDITIONS (IF REQUESTED).          
// CATALOG PLOT-DATA POINTS ON THE DISK AS A PERMANENT FILE, IF 
// MISC. DATA PARAMETER 'ICAT' IS POSITIVE.   
void over20(
  common& cmn)
{
  common_write write(cmn);
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  double& aincr = cmn.aincr;
  double& t = cmn.t;
  const auto& begmax = cmn.begmax;
  const auto& peaknd = cmn.peaknd;
  auto& flstat = cmn.flstat;
  double& angle = cmn.angle;
  //auto& moncar = cmn.moncar;
  auto& lunit7 = cmn.lunit7;
  int& max99m = cmn.max99m;
  const auto& ipntv = cmn.ipntv;
  const auto& lstat = cmn.lstat;
  int& inonl = cmn.inonl;
  int& it1 = cmn.it1;
  int& it2 = cmn.it2;
  int& kcount = cmn.kcount;
  int& m4plot = cmn.m4plot;
  int& iplot = cmn.iplot;
  int& lsiz12 = cmn.lsiz12;
  int& lastov = cmn.lastov;
  int& numdcd = cmn.numdcd;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kswtch = cmn.kswtch;
  int& icat = cmn.icat;
  int& nenerg = cmn.nenerg;
  double& angtpe = cmn.angtpe;
  int& nswtpe = cmn.nswtpe;
  auto& xmax = cmn.xmax;
  const auto& crit = cmn.crit;
  const auto& energy = cmn.energy;
  const auto& nonlad = cmn.nonlad;
  const auto& nonle = cmn.nonle;
  const auto& curr = cmn.curr;
  const auto& nltype = cmn.nltype;
  const auto& cchar = cmn.cchar;
  const auto& vchar = cmn.vchar;
  const auto& gslope = cmn.gslope;
  const auto& nr = cmn.nr;
  const auto& length = cmn.length;
  const auto& cik = cmn.cik;
  const auto& ci = cmn.ci;
  const auto& ck = cmn.ck;
  const auto& nonlk = cmn.nonlk;
  const auto& nonlm = cmn.nonlm;
  const auto& imodel = cmn.imodel;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& kodsem = cmn.kodsem;
  const auto& kmswit = cmn.kmswit;
  const auto& nextsw = cmn.nextsw;
  const auto& tclose = cmn.tclose;
  const auto& adelay = cmn.adelay;
  const auto& kpos = cmn.kpos;
  const auto& e = cmn.e;
  const auto& kode = cmn.kode;
  auto& volti = static_cast<common_c0b123&>(cmn).volti;

  const auto& bus = cmn.bus;
  //
  auto& lunit6 = cmn.lunit6;
  double zero = fem::double0;
  int ll1 = fem::int0;
  int ll9 = fem::int0;
  int ll10 = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  int n10 = fem::int0;
  int n6 = fem::int0;
  int k = fem::int0;
  int i = fem::int0;
  int L = fem::int0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  int iold = fem::int0;
  int m = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int n5 = fem::int0;
  int n7 = fem::int0;
  int n8 = fem::int0;
  int n9 = fem::int0;
  int n11 = fem::int0;
  int ipp = fem::int0;
  int n12 = fem::int0;
  int n13 = fem::int0;
  int n14 = fem::int0;
  double a = fem::double0;
  int kn1 = fem::int0;
  int npl = fem::int0;
  int nstat = fem::int0;
  int ndx3 = fem::int0;
  static const char* format_1510 = "(1x,f6.2,1x,f6.2,1x,9e13.6)";
  static const char* format_4568 = "(' EXIT \"OVER20\".')";
  static const char* format_617 = "(1x,f9.4,5x,9e13.6)";
  static const char* format_618 = "(15x,9e13.6)";
  static const char* format_659 =
    "(' ----------------------------------------------------------------------"
    "-------------------------------------------------------------')";
  static const char* format_7020 = "(i2,2a6,4e15.8,i6)";
  static const char* format_7021 = "(' ',a6,1x,a6,4e13.5,i6)";
  static const char* format_7304 =
    "(' ***********************************************************',"
    "' LOOK, LOOK ',"
    "'************************************************************')";
  static const char* format_7305 = "(/,/,1x)";
  static const char* format_8003 = "(' TIMES OF MAXIMA :',/(15x,9e13.6))";

  auto& knt = cmn.moncar(1);
  auto& kbase = cmn.moncar(2);
  auto& ltdelt = cmn.moncar(3);
  auto& isw = cmn.moncar(4);
  auto& mtape = cmn.moncar(10);

  if (iprsup >= 1) {
    write(lunit6, "(' BEGIN MODULE \"OVER20\".')");
  }
  zero = 0.0f;
  ll1 = 1;
  ll9 = 9;
  ll10 = 10;
  runtym(d1, d2);
  n10 = 1;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,1x,'   IPLOT  NENERG  KBASE','  M4PLOT   MTAPE    ICAT LSTAT32',14x,"
      "'T',10x,'AINCR',/,1x,7i8,2e15.5)"),
      iplot, nenerg, kbase, m4plot, mtape, icat, lstat(32), t, aincr;
  }
  if (max99m < 0) {
    write(lunit6,
      "(' ++++  NUMBER OF SUPPRESSED TYPE-99 FLASHOVER',"
      "' OR CLEARING MESSAGES IS NEGATIVE OF',i7)"),
      max99m;
  }
  if (peaknd(1) == 0.0f) {
    goto statement_5019;
  }
  n6 = peaknd(3);
  write(lunit6,
    "(8x,'OVERALL SIMULATION PEAK NODE VOLTAGE =',e15.6,' .   TIME (SEC) =',"
    "e14.5,' .   BUS = ''',a6,''' .')"),
    peaknd(1), peaknd(2), bus(n6);
statement_5019:
  k = lstat(32) + 1;
  if (iplot < 0) {
    goto statement_8005;
  }
  volti(1) = -9999.f;
  if (m4plot == 0) {
    goto statement_5022;
  }
  pltfil(cmn, k);
  goto statement_8005;
statement_5022:
  {
    write_loop wloop(cmn, cmn.lunit4, fem::unformatted);
    FEM_DO_SAFE(i, 1, k) {
      wloop, volti(i);
    }
  }
statement_8005:
  if (icat > 0 || cmn.memsav > 0) {
    //w katalg(cmn);
  }
  cmn.io.close(79);
  k = lstat(32);
  //C      BOTH MAX AND MIN WILL BE PRINTED FOR EACH ENERGIZATION WHEN      M27.2620
  //C      'AINCR' IS SET TO BE GREATER THAN OR EQUAL TO '55.0'.            M27.2621
  if (kbase == 2 && aincr < 55.0f) {
    goto statement_3614;
  }
  if (begmax(1) <= 0.0f) {
    goto statement_3614;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' MAXIMA AND MINIMA WHICH OCCURRED DURING THE SIMULATION FOLLOW.   T"
      "HE ORDER AND COLUMN POSITIONING ARE THE',/,"
      "' SAME AS FOR THE REGULAR PRINTED OUTPUT VS. TIME.',/,"
      "' VARIABLE MAXIMA :',/(15x,9e13.6))");
    FEM_DO_SAFE(L, 1, k) {
      wloop, xmax(L);
    }
  }
  //C     EXTREMA VECTOR  "XMAX"  ACTUALLY HAS FOUR PARTITIONS,             M27.2628
  //C     EACH THE SIZE OF LIST 12:  (XMAX, TMAX, XMIN, TMIN) .             M27.2629
  ndx1 = lsiz12 + 1;
  ndx2 = lsiz12 + k;
  {
    write_loop wloop(cmn, lunit6, format_8003);
    FEM_DO_SAFE(L, ndx1, ndx2) {
      wloop, xmax(L);
    }
  }
  ndx1 += lsiz12;
  ndx2 += lsiz12;
  {
    write_loop wloop(cmn, lunit6, "(' VARIABLE MINIMA :',/(15x,9e13.6))");
    FEM_DO_SAFE(L, ndx1, ndx2) {
      wloop, xmax(L);
    }
  }
  ndx1 += lsiz12;
  ndx2 += lsiz12;
  {
    write_loop wloop(cmn, lunit6, "(' TIMES OF MINIMA :',/(15x,9e13.6))");
    FEM_DO_SAFE(L, ndx1, ndx2) {
      wloop, xmax(L);
    }
  }
statement_3614:
  if (nenerg != 0) {
    goto statement_605;
  }
  flstat(9) = d1;
  flstat(10) = d2;
  if (begmax(1) != 0.0f && begmax(2) != 0.0f) {
    write(lunit6,
      "(56x,'SEARCH FOR EXTREMA BEGAN AT TIME',e15.6,'   SEC.')"),
      begmax(2);
  }
  write(lunit6, "(1x)");
  if (cmn.ipunch <= 0) {
    goto statement_9800;
  }
  kcount = 2;
  iold = 3;
  if (n10 != 0) {
    write(lunit6,
      "(/,' PRINTOUT OF THE SAVING OF TERMINAL CONDITIONS FOR ALL COMPONENTS, "
      "AT TIME',e15.7,'   SECONDS.',/,' BEGIN WITH ALL NODE VOLTAGES.',/,"
      "3(21x,'NODE'),/,19x,'NUMBER',21x,'NAME',18x,'VOLTAGE')"),
      t;
  }
  FEM_DO_SAFE(k, 2, cmn.ntot) {
    if (n10 != 0) {
      write(lunit6, "(' ',a6,2e13.5,41x,i6)"), bus(k), e(k), zero, k;
    }
    write(lunit7, "(i2,a6,3e15.8,21x,i6)"), kcount, bus(k), e(k), zero, zero, k;
  }
  if (n10 != 0) {
    write(lunit6,
      "(/,' LINEAR BRANCH TABLE STATE VARIABLES ( ''CURRENTS'' ) FOLLOW.',/,"
      "7x,'ROW',9x,'''FROM'' NODE',11x,'''TO'' NODE',9x,"
      "'LINEAR BRANCH PARAMETERS, IDENTIFIED BY THE FORTRAN VECTOR STORAGE',/,"
      "9x,'I',8x,'BUS(KBUS(I))',8x,'BUS(MBUS(I))',19x,'CIK(I)',20x,'CI(I)',"
      "20x,'CK(I)')");
  }
  k = 1;
statement_7014:
  it2 = 1;
  if (kbus(k) < 0) {
    goto statement_7024;
  }
  if (nr(k) >= 0) {
    goto statement_7022;
  }
  ci1 = ci(k);
  ck1 = ck(k);
  if (ci1 == 0.f && ck1 == 0.f) {
    goto statement_7025;
  }
  L = kbus(k);
  m = fem::iabs(mbus(k));
  write(lunit7, format_7020), iold, bus(L), bus(m), ci1, ck1, zero, zero, k;
  if (n10 != 0) {
    write(lunit6, format_7021), bus(L), bus(m), ci1, ck1, zero, zero, k;
  }
  goto statement_7025;
statement_7022:
  it2 = fem::iabs(length(k));
  it1 = k + it2 - 1;
  FEM_DO_SAFE(i, k, it1) {
    n1 = kbus(i);
    n2 = fem::iabs(mbus(i));
    if (n10 != 0) {
      write(lunit6, format_7021), bus(n1), bus(n2), cik(i), ci(i), ck(i),
        zero, i;
    }
    write(lunit7, format_7020), iold, bus(n1), bus(n2), cik(i), ci(i),
      ck(i), zero, i;
  }
  goto statement_7025;
statement_7024:
  n1 = iabsz(kbus(k));
  n2 = iabsz(mbus(k));
  write(lunit6,
    "('  ****  WARNING.   ****   NO CURRENTS WILL',"
    "' BE PUNCHED FOR THE DISTRIBUTED LINE',' CONNECTING NODES  \"',a6,"
    "'\"  AND  \"',a6,'\" .')"),
    bus(n1), bus(n2);
  it2 = length(k);
  if (it2 < 0) {
    it2 = -it2;
  }
  if (length(k) > 0) {
    it2 = 1;
  }
  if (kodsem(k) != 0 && imodel(k) != 2) {
    it2 = iabsz(kodebr(k));
  }
statement_7025:
  k += it2;
  if (k <= cmn.ibr) {
    goto statement_7014;
  }
  if (inonl == 0) {
    goto statement_9207;
  }
  if (n10 != 0) {
    write(lunit6, "(/,' NONLINEAR ELEMENT TABLE STATE VARIABLES FOLLOW.')");
  }
  iold = 4;
  FEM_DO_SAFE(k, 1, inonl) {
    if (nonle(k) >= 0) {
      goto statement_7035;
    }
    n1 = nonlk(k);
    n2 = fem::iabs(nonlm(k));
    if (nltype(k) != -96) {
      goto statement_7031;
    }
    n5 = nonlad(k);
    n6 = n5 + 1;
    n7 = n5 + 2;
    n8 = n5 + 3;
    write(lunit7, format_7020), iold, bus(n1), bus(n2), vchar(n7), cchar(n8);
    n9 = cchar(n6);
    n11 = cchar(n7);
    {
      write_loop wloop(cmn, lunit7, "(2i10,4e15.8)");
      wloop, n9, n11;
      FEM_DO_SAFE(ipp, n5, n8) {
        wloop, vchar(ipp);
      }
    }
    n12 = n5 + 4;
    n13 = n5 + 5;
    n14 = cchar(n12);
    write(lunit7, "(i10,4e15.8)"), n14, vchar(n12), vchar(n13),
      gslope(n12), gslope(n13);
    if (n10 == 0) {
      goto statement_7035;
    }
    write(lunit6, format_7021), k, bus(n1), bus(n2), vchar(n7), cchar(n8);
    {
      write_loop wloop(cmn, lunit6, "(' ',i10,2x,i10,4(3x,e15.8))");
      wloop, n9, n11;
      FEM_DO_SAFE(ipp, n5, n8) {
        wloop, vchar(ipp);
      }
    }
    write(lunit6, "(' ',i10,4(3x,e15.8))"), n14, vchar(n13), vchar(n14),
      gslope(n12), gslope(n13);
    goto statement_7035;
  statement_7031:
    a = curr(k);
    if (a == 0.f) {
      goto statement_7035;
    }
    write(lunit7, format_7020), iold, bus(n1), bus(n2), a;
    if (n10 != 0) {
      write(lunit6, format_7021), bus(n1), bus(n2), a;
    }
  statement_7035:;
  }
statement_9207:
  if (kswtch == 0) {
    goto statement_4020;
  }
  if (n10 != 0) {
    write(lunit6,
      "(/,' STATUS VARIABLES FOR SWITCHES FOLLOW.',/,1x,'BUS(L)',1x,'BUS(M)',"
      "3x,'KPOS(K)',2x,' KODE(L)',2x,' KODE(M)',14x,'TCLOSE',14x,'ADELAY',14x,"
      "'ENERGY',16x,'CRIT')");
  }
  FEM_DO_SAFE(k, 1, kswtch) {
    L = fem::iabs(kmswit(k));
    kn1 = cmn.lswtch + k;
    m = fem::iabs(kmswit(kn1));
    npl = nextsw(k);
    if (npl != 0) {
      npl = 87;
    }
    write(lunit7, "(' 5',2a6,3i4,4e13.6,/,14x,i4)"), bus(L), bus(m),
      kpos(k), kode(L), kode(m), tclose(k), adelay(k), energy(k),
      crit(k), npl;
    if (n10 == 0) {
      goto statement_4010;
    }
    write(lunit6, "(1x,a6,1x,a6,3i10,4e20.10,/,14x,i10)"), bus(L),
      bus(m), kpos(k), kode(L), kode(m), tclose(k), adelay(k), energy(k),
      crit(k), nextsw(k);
  statement_4010:;
  }
statement_4020:
  goto statement_9800;
  //C     CODE BELOW IS JUST FOR  'STATISTICS'  OR  'SYSTEMATIC'  RUNS. ----M22.5409
statement_605:
  nstat = k;
  FEM_DO_SAFE(L, 1, nstat) {
    ndx1 = 2 * lsiz12 + L;
    if (-xmax(ndx1) <= xmax(L)) {
      goto statement_8010;
    }
    xmax(L) = xmax(ndx1);
    ndx3 = lsiz12 + L;
    ndx2 = ndx1 + lsiz12;
    xmax(ndx3) = xmax(ndx2);
  statement_8010:;
  }
  if (iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6,
        "(' ISW, NSTAT, KNT, NENERG = ',4i10,/,' (XMAX(I), I=1, NSTAT) = ',/,"
        "6(5x,e15.8))");
      wloop, isw, nstat, knt, nenerg;
      FEM_DO_SAFE(i, 1, nstat) {
        wloop, xmax(i);
      }
    }
  }
  knt++;
  {
    write_loop wloop(cmn, cmn.lunit9, fem::unformatted);
    FEM_DO_SAFE(L, 1, nstat) {
      wloop, xmax(L);
    }
  }
  if (begmax(1) == 0.0f) {
    goto statement_627;
  }
  if (nstat <= 9) {
    goto statement_609;
  }
  if (nenerg < 0) {
    goto statement_612;
  }
  if (nswtpe <= 1) {
    goto statement_1610;
  }
  {
    write_loop wloop(cmn, lunit6, format_1510);
    wloop, angle, angtpe;
    FEM_DO_SAFE(L, 1, ll9) {
      wloop, xmax(L);
    }
  }
  goto statement_611;
statement_1610:
  {
    write_loop wloop(cmn, lunit6, format_617);
    wloop, angle;
    FEM_DO_SAFE(L, 1, ll9) {
      wloop, xmax(L);
    }
  }
statement_611:
  {
    write_loop wloop(cmn, lunit6, format_618);
    FEM_DO_SAFE(L, ll10, nstat) {
      wloop, xmax(L);
    }
  }
  goto statement_624;
statement_612:
  {
    write_loop wloop(cmn, lunit6, format_618);
    FEM_DO_SAFE(L, 1, ll9) {
      wloop, xmax(L);
    }
  }
  goto statement_611;
statement_609:
  if (nenerg < 0) {
    goto statement_614;
  }
  if (nswtpe <= 1) {
    goto statement_1620;
  }
  {
    write_loop wloop(cmn, lunit6, format_1510);
    wloop, angle, angtpe;
    FEM_DO_SAFE(L, 1, nstat) {
      wloop, xmax(L);
    }
  }
  goto statement_624;
statement_1620:
  {
    write_loop wloop(cmn, lunit6, format_617);
    wloop, angle;
    FEM_DO_SAFE(L, 1, nstat) {
      wloop, xmax(L);
    }
  }
  goto statement_624;
statement_614:
  {
    write_loop wloop(cmn, lunit6, format_618);
    FEM_DO_SAFE(L, 1, nstat) {
      wloop, xmax(L);
    }
  }
statement_624:
  ndx1 = lsiz12 + 1;
  ndx2 = lsiz12 + nstat;
  if (begmax(1) > 0.0f) {
    {
      write_loop wloop(cmn, lunit6, format_8003);
      FEM_DO_SAFE(L, ndx1, ndx2) {
        wloop, xmax(L);
      }
    }
  }
statement_627:
  if (knt > fem::iabs(nenerg)) {
    goto statement_610;
  }
  lastov = nchain;
  nchain = 12;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
statement_610:
  write(lunit6, "(/,/,1x)");
  //? cmn.lunit5 = mtape;
  //C     RESET NUMDCD COUNTER IF IT IS NOT A OMIT BASE CASE                M36.1668
  if (lstat(15) != cmn.intinf) {
    numdcd = numdcd - ipntv(11);
  }
  write(lunit6, format_659);
  write(lunit6,
    "(' SIMULATION OF ALL  ''NENERG'' =',i4,"
    "'  ENERGIZATIONS IS NOW COMPLETE, AND THE EMTP IS READY TO BEGIN STATISTI"
    "CAL',/,"
    "' PROCESSING OF THE VOLTAGE SOLUTIONS.   BUT BEFORE DOING SO, TWO CAUTION"
    "S ABOUT DISCRETIZATION OF CONTINUOUS',/,"
    "' VARIABLES ARE PROBABLY APPROPRIATE TO MENTION AT THIS POINT.',/,5x,"
    "'1.  THE SWITCH CLOSING TIMES WHICH ARE PRINTED ALONG WITH PEAK VOLTAGES "
    "OF EACH ENERGIZATION ARE ONLY DESIRED',/,9x,"
    "'TIMES, JUST AS WITH ALL SUCH TIMES WHICH ARE PUNCHED ON DATA CARDS WHICH"
    " DEFINE SWITCHES UPON DATA INPUT.   SINCE')"),
    nenerg;
  write(lunit6,
    "(9x,'TIME IS DISCRETIZED IN MULTIPLES OF TIME-STEP-SIZE  ''DELTAT'' ,   A"
    "CTUAL CLOSURE WILL OCCUR AT THE FIRST DISCRETE',/,9x,"
    "'STEP WHICH DOES NOT PRECEDE THE REQUESTED TIME.',/,5x,"
    "'2.  IN THE TABULATION OF VOLTAGE DISTRIBUTIONS WHICH FOLLOW, AN ARBITRAR"
    "Y DECISION HAD TO BE MADE CONCERNING THE',/,9x,"
    "'COLUMN WHICH IS LABELED  ''FREQUENCY'' .    THE CONTINUOUS VARIABLE VOLT"
    "AGE HAS BEEN DISCRETIZED, DIVIDED INTO',/,9x,"
    "'COMPARTMENTS OF SIZE  ''AINCR''  (READ FROM COLUMNS 25-32 OF THE SPECIAL"
    " STATISTICS MISC. DATA CARD).   FOR AN ENTRY')");
  write(lunit6,
    "(9x,'WHICH IS PRINTED IN A ROW MARKED AS BEING FOR VOLTAGE  ''VROW'' ,   "
    "THE ASSOCIATED COMPARTMENT CONTAINS ALL',/,9x,"
    "'VOLTAGES  ''V''  WHICH SATISFY       VROW  .LE.  V  .LT.  (VROW + AINCR)"
    "  .',/,5x,'3.  FLOATING-POINT COUNTING (T = T + DELTAT)',"
    "' IS USED TO INCREMENT TIME.   SWITCHING TIMES',"
    "' WHICH ARE AN EXACT MULTIPLE',/,9x,"
    "'OF THE TIME-STEP THUS ARE AMBIGUOUS;  DIFFERENT',"
    "' COMPUTERS MAY SWITCH ONE STEP LATER, THEN.')");
  if (ltdelt <= 0) {
    goto statement_7314;
  }
  write(lunit6, format_7305);
  write(lunit6, format_7304);
  write(lunit6,
    "(/,' DURING THIS RUN, A TOTAL OF',i4,"
    "'  RANDOM SWITCH CLOSINGS LESS THAN TIME ZERO WERE GENERATED BY THE RANDO"
    "M',/,"
    "' NUMBER GENERATOR.   BUT THE EMTP HAS NO WAY OF HANDLING SUCHCLOSURES.  "
    " ALL SUCH ILLEGAL CLOSING TIMES WERE CONVERTED',/,"
    "' TO TIME ZERO (THEY SHOULD SHOW UP IN THE PRINTOUT THAT WAY) FOR SIMULAT"
    "ION PURPOSES.   THE IMPLICATIONS OF THIS',/,"
    "' MODIFICATION SHOULD BE UNDERSTOOD BY THE USER.   IF IN ANY DOUBT, THE U"
    "SER IS STRONGLY ADVISED TO SEEK EXPERIENCED',/,"
    "' COUNSEL ON THIS SUBJECT.',/,1x)"),
    ltdelt;
  write(lunit6, format_7304);
  write(lunit6, format_7305);
statement_7314:
  write(lunit6, format_659);
  flstat(9) = d1;
  flstat(10) = d2;
  lastov = nchain;
  nchain = 29;
  flstat(7) += d1;
  flstat(8) += d2;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
statement_9800:
  if (m4plot != 1) {
    goto statement_9810;
  }
  if (kbase == 1) {
    goto statement_9810;
  }
  //C     VAX SIMULATOR RETURN TO "OVER16" AFTER TABLE-SAVING:              M30.1008
  lastov = nchain;
  nchain = 16;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
statement_9810:
  if (lastov > nchain) {
    goto statement_9850;
  }
  flstat(7) += d1;
  flstat(8) += d2;
statement_9850:
  lastov = nchain;
  nchain = 31;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
statement_99999:;
} // over20



  void subr10(common& cmn)
  {
    const auto& iprsov = cmn.iprsov;
    int& nchain = cmn.nchain;
    int& iprsup = cmn.iprsup;
    //
    int n24 = fem::int0;
    int iprcbl = fem::int0;
    //C %INCLUDE  '//c/tsu/cables.INS.FTN'                                    M43.   3
    cmn.ktab = 0;
  statement_3000:
    if (nchain > 20) {
      goto statement_9000;
    }
    if (cmn.kill == 0) {
      goto statement_1679;
    }
    nchain = 51;
    goto statement_3000;
  statement_1679:
    n24 = nchain;
    if (n24 < 1) {
      n24 = 1;
    }
    iprsup = iprsov(n24);
    iprcbl = iprsup;
    if (cmn.m4plot == 1) {
      emtspy(cmn);
    }
    if (nchain == 0) {
      nchain = 1;
    }
    switch (nchain) {
    case 1: goto statement_3001;
    case 2: goto statement_3002;
    case 3: goto statement_3003;
    case 4: goto statement_3004;
    case 5: goto statement_3005;
    case 6: goto statement_3006;
    case 7: goto statement_3007;
    case 8: goto statement_3008;
    case 9: goto statement_3009;
    case 10: goto statement_3010;
    case 11: goto statement_3011;
    case 12: goto statement_3012;
    case 13: goto statement_3013;
    case 14: goto statement_3014;
    case 15: goto statement_3015;
    case 16: goto statement_3016;
    case 17: goto statement_3016;
    case 18: goto statement_3016;
    case 19: goto statement_3016;
    case 20: goto statement_3020;
    default: break;
    }
  statement_3001:
    over1(cmn);
    goto statement_3000;
  statement_3002:
    over2(cmn);
    goto statement_3000;
  statement_3003:
    stoptp(cmn);
    goto statement_3000;
  statement_3004:
    stoptp(cmn);
    goto statement_3000;
  statement_3005:
    over5(cmn);
    goto statement_3000;
  statement_3006:
    over6(cmn);
    goto statement_3000;
  statement_3007:
    over7(cmn);
    goto statement_3000;
  statement_3008:
    over8(cmn);
    goto statement_3000;
  statement_3009:
    over9(cmn);
    goto statement_3000;
  statement_3010:
    over10(cmn);
    goto statement_3000;
  statement_3011:
    over11(cmn);
    goto statement_3000;
  statement_3012:
    over12(cmn);
    goto statement_3000;
  statement_3013:
    over13(cmn);
    goto statement_3000;
  statement_3014:
    over14(cmn);
    goto statement_3000;
  statement_3015:
    over15(cmn);
    goto statement_3000;
  statement_3016:
    over16(cmn);
    goto statement_3000;
  statement_3020:
    over20(cmn);
    goto statement_3000;
    //C)                                                                      
    //C     THE EMTP SOLUTION PROCESS PROPER CONSISTS OF NUMEROUS SECONDARY-  
    //C     LEVEL OVERLAYS, EACH CALLED FROM MODULE  MAIN10  USING            
    //C     MODULE NUMBER 'NCHAIN' AS THE INDICATOR OF WHERE CONTROL IS TO  
    //C     PASS NEXT.   THE FOLLOWING IS A TABULATION OF VALID  'NCHAIN'     
    //C     VALUES, ALONG WITH THE FUNCTION OF THE CORRESPONDING CODE. WITH 
    //C     THE POSSIBLE EXCEPTION OF THE TIME-STEP LOOP,  'NCHAIN'  IS THE   
    //C     UTPF  OVERLAY NUMBER OF THE CODE TO WHICH CONTROL IS TO BE        
    //C     TRANSFERED NEXT.   THE OVERLAY NUMBER OF THE TIME-STEP LOOP       
    //C     IS GIVEN BY  'NCHAIN'  CORRESPONDING TO THE FIRST QUARTER OF      
    //C     THE TIME-STEP-LOOP SEGMENTATION, ON MACHINES NOT USING ECS        
    //C     OVERLAYING.                                                       
    //C                                                                       
    //C     1.  INPUT OF MISCELLANEOUS DATA CARDS.                            
    //C     2.  INPUT BRANCH DATA.                                            
    //C     3.  CODE ASSOCIATED WITH THE CASCADING OF PI-CIRCUITS FOR         
    //C         STEADY-STATE PHASOR SOLUTIONS ONLY.                           
    //C     4.  INPUT AND PROCESSING OF FREQUENCY-DEPENDENCE DATA FOR         
    //C         DISTRIBUTED-PARAMETER LINE MODE.                              
    //C     5.  INPUT OF SWITCH AND SOURCE DATA CARDS.                        
    //C     6.  NETWORK CONNECTIVITY OUTPUT.   SETUP OF TRANSIENT-NETWORK     
    //C         RENUMBERING TABLES.                                           
    //C     7.  NETWORK NODE RENUMBERING ROUTINE (JOHN WALKER'S OLD           
    //C         SUBROUTINE NUMBER).                                           
    //C     8.  CONVERT TABLES TO NEW NODE NUMBERS.   FIND STEADY-STATE       
    //C         PHASOR EQUIVALENTS FOR DISTRIBUTED BRANCHES.                  
    //C     9.  SET UP STEADY-STATE PHASOR NETWORK RENUMBERING TABLES.        
    //C     10.  FORM THE STEADY-STATE ADMITTANCE MATRIX (Y).   SOLVE FOR     
    //C          STEADY-STATE PHASOR VOLTAGES.                                
    //C     11.  OUTPUT STEADY-STATE PHASOR SOLUTION (IF REQUESTED).          
    //C     12.  BRANCH-TABLE AND SWITCH-TABLE PROCESSING, AS PREPARATION     
    //C          FOR THE INTEGRATION IN TIME-STEP LOOP.                       
    //C     13.  SETUP INITIAL CONDITIONS ON LUMPED ELEMENTS, AND PAST        
    //C          HISTORY FOR DISTRIBUTED LINES.                               
    //C     14.  FORM (Y) FOR THE TRANSIENTS NETWORK.   TRIANGULARIZE THE     
    //C          FIRST PARTITION (NONSWITCH/SOURCE NODES).                    
    //C     15.  FINAL SETUP OPERATIONS BEFORE TIME-STEP LOOP.                
    //C     16.  FIRST QUARTER OF TIME-STEP LOOP (CHECKING FOR CHANGES OF     
    //C          SWITCHES AND PSEUDO-NONLINEAR ELEMENTS, RETRIANGULARIZATION  
    //C          OF  YBB  AND CALCULATION OF THEVENIN IMPEDANCE VECTORS).     
    //C     17.  SECOND QUARTER OF TIME-STEP LOOP (BRANCH-TABLE HISTORY       
    //C          UPDATING, ADDITION OF BRANCH CONTRIBUTIONS TO NODAL          
    //C          INJECTED CURRENT VECTOR  I ).                                
    //C     18.  THIRD QUARTER OF TIME-STEP LOOP (SOURCE UPDATE, REPEAT       
    //C          SOLUTION OF   (Y)V = I   FOR NODE VOLTAGE VECTOR  V ).       
    //C     19.  FOURTH QUARTER OF TIME-STEP LOOP (SOLUTION OF 3-PHASE        
    //C          NONLINEARITIES AND COMPENSATION-BASED ROTATING               
    //C          MACHINERY [TYPE-50 S.M., U.M.],  SUPERPOSITION TO            
    //C          GIVE THE TOTAL SOLUTION INCLUDING COMPENSATION).             
    //C     20.  PUNCH AND PRINT TERMINAL CONDITIONS (IF REQUESTED).          
    //C          CATALOG PLOT-DATA POINTS ON THE DISK AS A PERMANENT FILE, IF 
    //C          MISC. DATA PARAMETER  'ICAT'  IS POSITIVE.                   
    //C                                                                       
  statement_9000:;
  }

  void fixs10(common& cmn)
  {
    //C!COMMON  / C10B01 /   JNDEX (    3002 )
    //C!COMMON  / C10B02 /   DIAGG (    3002 )
    //C!COMMON  / C10B03 /   DIABB (    3002 )
    //C!COMMON  / C10B04 /   SOLRSV(    3002 )
    //C!COMMON  / C10B05 /   SOLISV(    3002 )
    //C!COMMON  / C10B06 /   GNDD  (   30000 )
    //C!COMMON  / C10B07 /   BNDD  (   30000 )
    //C!COMMON  / C10B08 /   NEKFIX(     100 )
    //C!COMMON  / C10B09 /   FXTEM1(     100 )
    //C!COMMON  / C10B10 /   FXTEM2(     100 )
    //C!COMMON  / C10B11 /   FXTEM3(     100 )
    //C!COMMON  / C10B12 /   FXTEM4(     100 )
    //C!COMMON  / C10B13 /   FXTEM5(     100 )
    //C!COMMON  / C10B14 /   FXTEM6(     100 )
    //C!COMMON  / C10B15 /   FIXBU1(     100 )
    //C!COMMON  / C10B16 /   FIXBU2(     100 )
    //C!COMMON  / C10B17 /   FIXBU3(     100 )
    //C!COMMON  / C10B18 /   FIXBU4(     100 )
    //C!COMMON  / C10B19 /   FIXBU5(     100 )
    //C!COMMON  / C10B20 /   FIXBU6(     100 )
    //C!COMMON  / C10B21 /   FIXBU7(     100 )
    //C!COMMON  / C10B22 /   FIXBU8(     100 )
    //C!COMMON  / C10B23 /   FIXBU9(     100 )
    //C!COMMON  / C10B24 /   FIXB10(     100 )
    //C!COMMON  / C10B25 /   FIXB11(     100 )
    //C!COMMON  / C10B26 /   KNDEX (     100 )
    subr10(cmn);
  }

  void main10(common& cmn)
  {
    //C!COMMON  / C0B001 /   X     (   10000 )
    //C!COMMON  / C0B002 /   YKM   (   20000 )
    //C!COMMON  / C0B003 /   KM    (   20000 )
    //C!COMMON  / C0B004 /   XK    (  121080 )
    //C!COMMON  / C0B005 /   XM    (  121080 )
    //C!COMMON  / C0B006 /   WEIGHT(     460 )
    //C!COMMON  / C0B007 /   IWTENT(      31 )
    //C!COMMON  / C0B008 /   CON1  (      30 )
    //C!COMMON  / C0B009 /   ISKIP (       5 )
    //C!COMMON  / C0B010 /   ZINF  (       5 )
    //C!COMMON  / C0B011 /   ETA   (       5 )
    //C!COMMON  / C0B012 /   NHIST (       5 )
    //C!COMMON  / C0B013 /   STAILM(      90 )
    //C!COMMON  / C0B014 /   STAILK(      90 )
    //C!COMMON  / C0B015 /   XMAX  (    3600 )
    //C!COMMON  / C0B016 /   KOUTVP(     508 )
    //C!COMMON  / C0B017 /   BNRG  (     254 )
    //C!COMMON  / C0B018 /   SCONST(  100000 )
    //C!COMMON  / C0B019 /   CNVHST(   53000 )
    //C!COMMON  / C0B020 /   SFD   (    6000 )
    //C!COMMON  / C0B021 /   QFD   (    6000 )
    //C!COMMON  / C0B022 /   SEMAUX(   50000 )
    //C!COMMON  / C0B023 /   IBSOUT(     900 )
    //C!COMMON  / C0B024 /   BVALUE(     900 )
    //C!COMMON  / C0B025 /   SPTACS(   90000 )
    //C!COMMON  / C0B026 /   KSWTYP(    1200 )
    //C!COMMON  / C0B027 /   MODSWT(    1200 )
    //C!COMMON  / C0B028 /   KBEGSW(    1200 )
    //C!COMMON  / C0B029 /   LASTSW(    1200 )
    //C!COMMON  / C0B030 /   KENTNB(    1200 )
    //C!COMMON  / C0B031 /   NBHDSW(    3600 )
    //C!COMMON  / C0B032 /   TOPEN (    3600 )
    //C!COMMON  / C0B033 /   CRIT  (    1200 )
    //C!COMMON  / C0B034 /   KDEPSW(    3600 )
    //C!COMMON  / C0B035 /   TDNS  (    1200 )
    //C!COMMON  / C0B036 /   ISOURC(    1200 )
    //C!COMMON  / C0B037 /   ENERGY(    1200 )
    //C!COMMON  / C0B038 /   IARDUB(    3600 )
    //C!COMMON  / C0B039 /   ARDUBE(    4800 )
    //C!COMMON  / C0B040 /   NONLAD(     300 )
    //C!COMMON  / C0B041 /   NONLE (     300 )
    //C!COMMON  / C0B042 /   VNONL (     300 )
    //C!COMMON  / C0B043 /   CURR  (     300 )
    //C!COMMON  / C0B044 /   ANONL (     300 )
    //C!COMMON  / C0B045 /   VECNL1(     300 )
    //C!COMMON  / C0B046 /   VECNL2(     300 )
    //C!COMMON  / C0B047 /   NAMENL(     300 )
    //C!COMMON  / C0B048 /   VZERO (     300 )
    //C!COMMON  / C0B049 /   ILAST (     300 )
    //C!COMMON  / C0B050 /   NLTYPE(     300 )
    //C!COMMON  / C0B051 /   KUPL  (     300 )
    //C!COMMON  / C0B052 /   NLSUB (     300 )
    //C!COMMON  / C0B053 /   XOPTBR(    3000 )
    //C!COMMON  / C0B054 /   COPTBR(    3000 )
    //C!COMMON  / C0B055 /   CURSUB(     312 )
    //C!COMMON  / C0B056 /   CCHAR (     900 )
    //C!COMMON  / C0B057 /   VCHAR (     900 )
    //C!COMMON  / C0B058 /   GSLOPE(     900 )
    //C!COMMON  / C0B059 /   KTRANS(    3002 )
    //C!COMMON  / C0B060 /   KK    (    3002 )
    //C!COMMON  / C0B061 /   C     (   10000 )
    //C!COMMON  / C0B062 /   TR    (   20000 )
    //C!COMMON  / C0B063 /   TX    (   20000 )
    //C!COMMON  / C0B064 /   R     (   10000 )
    //C!COMMON  / C0B065 /   NR    (    3000 )
    //C!COMMON  / C0B066 /   LENGTH(    3000 )
    //C!COMMON  / C0B067 /   CIK   (    3000 )
    //C!COMMON  / C0B068 /   CI    (    3000 )
    //C!COMMON  / C0B069 /   CK    (    3000 )
    //C!COMMON  / C0B070 /   ISMOUT(    1052 )
    //C!COMMON  / C0B071 /   ELP   (     404 )
    //C!COMMON  / C0B072 /   CU    (      96 )
    //C!COMMON  / C0B073 /   SHP   (    1008 )
    //C!COMMON  / C0B074 /   HISTQ (     504 )
    //C!COMMON  / C0B075 /   ISMDAT(     120 )
    //C!COMMON  / C0B076 /   TEXVEC(    4000 )
    //C!REAL*8            TEXVEC
    //C!COMMON  / C0B077 /   IBRNCH(     900 )
    //C!COMMON  / C0B078 /   JBRNCH(     900 )
    //C!COMMON  / C0B079 /   TSTOP (     100 )
    //C!COMMON  / C0B080 /   NONLK (     300 )
    //C!COMMON  / C0B081 /   NONLM (     300 )
    //C!COMMON  / C0B082 /   SPUM  (   30000 )
    //C!COMMON  / C0B083 /   KKS   (    3002 )
    //C!COMMON  / C0B084 /   KKNONL(   72048 )
    //C!COMMON  / C0B085 /   ZNONL (   72048 )
    //C!COMMON  / C0B086 /   ZNONLB(    3002 )
    //C!COMMON  / C0B087 /   ZNONLC(    3002 )
    //C!COMMON  / C0B088 /   FINIT (    3002 )
    //C!COMMON  / C0B089 /   KSUB  (     312 )
    //C!COMMON  / C0B090 /   MSUB  (     312 )
    //C!COMMON  / C0B091 /   ISUBEG(     304 )
    //C!COMMON  / C0B092 /   LITYPE(    3000 )
    //C!COMMON  / C0B093 /   IMODEL(    3000 )
    //C!COMMON  / C0B094 /   KBUS  (    3000 )
    //C!COMMON  / C0B095 /   MBUS  (    3000 )
    //C!COMMON  / C0B096 /   KODEBR(    3000 )
    //C!COMMON  / C0B097 /   CKI   (    3000 )
    //C!COMMON  / C0B098 /   CKKJM (    3000 )
    //C!COMMON  / C0B099 /   INDHST(    3000 )
    //C!COMMON  / C0B100 /   KODSEM(    3000 )
    //C!COMMON  / C0B101 /   NAMEBR(   18000 )
    //C!COMMON  / C0B102 /   IFORM (     100 )
    //C!COMMON  / C0B103 /   NODE  (     100 )
    //C!COMMON  / C0B104 /   CREST (     100 )
    //C!COMMON  / C0B105 /   TIME1 (     100 )
    //C!COMMON  / C0B106 /   TIME2 (     100 )
    //C!COMMON  / C0B107 /   TSTART(     100 )
    //C!COMMON  / C0B108 /   SFREQ (     100 )
    //C!COMMON  / C0B109 /   KMSWIT(    3600 )
    //C!COMMON  / C0B110 /   NEXTSW(    1200 )
    //C!COMMON  / C0B111 /   RMFD  (       1 )
    //C!COMMON  / C0B112 /   CIKFD (       1 )
    //C!COMMON  / C0B113 /   IMFD  (     600 )
    //C!COMMON  / C0B114 /   TCLOSE(    1200 )
    //C!COMMON  / C0B115 /   ADELAY(    3600 )
    //C!COMMON  / C0B116 /   KPOS  (    1200 )
    //C!COMMON  / C0B117 /   NAMESW(    1200 )
    //C!COMMON  / C0B118 /   E     (    3002 )
    //C!COMMON  / C0B119 /   F     (    3002 )
    //C!COMMON  / C0B120 /   KSSFRQ(    3002 )
    //C!COMMON  / C0B121 /   KODE  (    3002 )
    //C!COMMON  / C0B122 /   KPSOUR(    3002 )
    //C!COMMON  / C0B123 /   VOLTI (    6000 )
    //C!COMMON  / C0B124 /   VOLTK (    3000 )
    //C!COMMON  / C0B125 /   VOLT  (    6000 )
    //C!COMMON  / C0B126 /   BUS   (    3002 )
    //C!REAL*8            BUS
    subr10(cmn);

  }

} // namespace emtp

