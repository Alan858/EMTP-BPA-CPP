#include "emtp_cmn.h"

namespace emtp {

  using namespace fem::major_types;


void
stoptp(
  common& cmn) try
{
  common_read read(cmn);
  common_write write(cmn);
  auto& texcol = cmn.texcol;
  const auto& abuff = cmn.abuff;
  int& lastov = cmn.lastov;
  int& nchain = cmn.nchain;
  //
  //C     TEMPORARY STOP STATEMENTS OF EMTP HAVE BEEN CONVERTED TO          M37. 130
  //C     "CALL STOPTP", ALLOWING INSTALLATION-DEPENDENT CLEAN UP.          M37. 131
  read(abuff, "(80a1)"), texcol;
  if (nchain == 31 && lastov == 1 && cmn.kill == 9999) {
    goto statement_9000;
  }
  write(cmn.lunit6,
    "(/,' TEMPORARY ERROR STOP IN \"STOPTP\".','   NCHAIN, LASTOV =',2i5,5x,"
    "'LAST-READ CARD IMAGE ABUFF FOLLOWS ....',/,80a1)"),
    nchain, lastov, texcol;
  statement_9000:
  throw std::runtime_error("stop");
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void copyi(
  int const& n1,
  arr_ref<int> ito,
  int const& kk) try
{
  ito(dimension(kk));
  //C     ROUTINE WHICH COPIES THE SAME INTEGER WORD  'N1'  INTO A          M22. 647
  //C     CONTIGUOUS REGION OF MEMORY ----  'KK'  WORDS IN LENGTH,          M22. 648
  //C     BEGINNING WITH WORD  ITO(1) .                                     M22. 649
  int i = fem::int0;
  FEM_DO_SAFE(i, 1, kk) {
    ito(i) = n1;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void time44(
  common& cmn,
  str_arr_ref<> a) try
{
  a(dimension(2));
  common_write write(cmn);
  //C)    THE PURPOSE OF SUBROUTINE  TIME44  IS TO INTERROGATE THE          M15. 277
  //C)    INSTALLATION CLOCK, AND RETURN THE WALL-CLOCK TIME THROUGH THE    M15. 278
  //C)    ARGUMENT OF THE SUBROUTINE.   EIGHT BCD CHARACTERS ARE ALLOWED,   M15. 279
  //C)    WITH THE FIRST (LEFT) FOUR CHARACTERS TO BE PLACED IN  A(1) ,     M15. 280
  //C)    AND THE FINAL (RIGHT) FOUR PLACED IN  A(2) .   A STATEMENT LIKE   M15. 281
  //C)             WRITE (LUNIT6, 4041)  A                                  M17.  97
  //C)        4041 FORMAT ( 1X, 2A4 )                                       M15. 283
  //C)    THUS OUTPUTS THE WALL-CLOCK TIME AS FIRST HOURS, THEN MINUTES,    M15. 284
  //C)    AND FINALLY SECONDS, SEPARATED BY PERIODS (HH.MM.SS) .            M15. 285
  //C)    SUBROUTINE  TIME44  IS OF COURSE INSTALLATION DEPENDENT.          M15. 286
  //C)    INSTALLATION-DEPENDENT  EMTP  MODULE WRITTEN FOR THE  DEC         M24.  93
  //C)    VAX-11/780.    'TIME'  IS A  DEC  SYSTEM SUBROUTINE WHICH         M24.  94
  //C)    RETURNS THE WALL-CLOCK TIME AS AN 8-BYTE CHARACTER STRING.        M24.  95
  //C)    THIS IS JUST WHAT THE EMTP NEEDS, EXCEPT THAT WE WANT PERIODS     M24.  96
  //C)    RATHER THAN COLONS, AND OF COURSE WE REQUIRE  2A4  FORMAT.        M24.  97
  //arr_1d<8, fem::str<1> > identifier_char(fem::fill0);
  //fem::time(identifier_char(1));
  //write(a(1), "(2a1,'.',a1)"), identifier_char(1), identifier_char(2),
  //  identifier_char(4);
  //write(a(2), "(a1,'.',2a1)"), identifier_char(5), identifier_char(7),
  //  identifier_char(8);

  time_t now = time(0);
  tm* timePtr = localtime(&now);
  std::stringstream ss;
  ss << std::setfill('0') << std::setw(2) << timePtr->tm_hour << '.' << std::setw(2) << timePtr->tm_min << '.' << std::setw(2) << timePtr->tm_sec;
  a(1) = ss.str().substr(0, 4);
  a(2) = ss.str().substr(4, 4);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void date44(
  common& cmn,
  str_arr_ref<> a) try
{
  a(dimension(2));
  common_write write(cmn);
  //C)    THE PURPOSE OF SUBROUTINE  DATE44  IS TO INTERROGATE THE          M15. 476
  //C)    INSTALLATION CALENDAR, AND RETURN THE CURRENT DATE THROUGH THE    M15. 477
  //C)    ARGUMENT OF THE SUBROUTINE.   EIGHT BCD CHARACTERS ARE ALLOWED,   M15. 478
  //C)    WITH THE FIRST (LEFT) FOUR CHARACTERS TO BE PLACED IN  A(1) ,     M15. 479
  //C)    AND THE FINAL (RIGHT) FOUR PLACED IN  A(2) .   A STATEMENT LIKE   M15. 480
  //C)             WRITE (LUNIT6, 4041)  A                                  M17. 205
  //C)        4041 FORMAT ( 1X, 2A4 )                                       M15. 482
  //C)    THUS OUTPUTS THE CURRENT DATE AS FIRST THE MONTH, THEN THE DAY,   M15. 483
  //C)    AND FINALLY THE YEAR, SEPARATED BY SLASHES (MM/DD/YY) .           M15. 484
  //C)    SUBROUTINE  DATE44  IS OF COURSE INSTALLATION DEPENDENT.          M15. 485
  //C)    EUROPEAN (OR GENERALLY NON-UNITED-STATES, PERHAPS) USERS OF THIS  M15. 486
  //C)    PROGRAM MAY WANT TO REVERSE THE ORDER OF APPEARANCE OF THE MONTH  M15. 487
  //C)    AND THE DAY, IN CONFORMITY WITH ESTABLISHED EUROPEAN USAGE.       M15. 488
  //C     INSTALLATION-DEPENDENT  EMTP  MODULE WRITTEN FOR THE  DEC         M24. 589
  //C     VAX-11/780.    'IDATE'  IS A  DEC  SYSTEM SUBROUTINE WHICH        M24. 590
  //C     RETURNS THE MONTH, DAY, AND YEAR (OF CENTURY) AS THREE  INTEGER*2 M24. 591
  //C     NUMERICAL VALUES.                                                 M24. 592
  //int n1 = 0;
  //int n2 = 0;
  //int n3 = 0;
  // idate(n1, n2, n3);
  //int n4 = n1 / 10;
  //int n5 = n1 - 10 * n4;
  //int n6 = n2 / 10;
  //int n7 = n2 - 10 * n6;
  //write(a(1), "(2i1,'/',1i1)"), n4, n5, n6;
  //write(a(2), "(i1,'/',i2)"), n7, n3;
  // format DD/MM/YY
  time_t now = time(0);
  tm* timePtr = localtime(&now);
  std::stringstream ss;
  ss << std::setfill('0') << std::setw(2) << timePtr->tm_mday << '/' << std::setw(2) << timePtr->tm_mon << '/' << std::setw(2) << 1900 + timePtr->tm_year - 2000;
  a(1) = ss.str().substr(0,4);
  a(2) = ss.str().substr(4, 4);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void runtym(
  double const& /* d1 */,
  double const& /* d2 */)
{
  //C)    THIS SUBROUTINE RETURNS WITH THE CURRENT JOB-EXECUTION TIME, AS   M15. 266
  //C)    BROKEN DOWN INTO TWO CATEGORIES ....                              M15. 267
  //C)           D1 = CENTRAL PROCESSOR JOB TIME, IN SECONDS                M15. 268
  //C)           D2 = PERIPHERAL PROCESSOR (OR INPUT/OUTPUT) JOB TIME,      M15. 269
  //C)                IN SECONDS.                                           M15. 270
  //C)    IF TWO SUCH FIGURES ARE NOT AVAILABLE ON THE USER'S COMPUTER,     M15. 271
  //C)    'D2'  SHOULD BE SET TO ZERO SO THAT CASE-SUMMARY STATISTICS       M15. 272
  //C)    WILL NOT PRINT OUT GARBAGE VALUES.   SUCH IS THE ONLY USE OF      M15. 273
  //C)    THE VALUES GOTTEN BY CALLING THIS SUBROUTINE ---- FOR THE CASE-   M15. 274
  //C)    SUMMARY PRINTOUT.   HENCE IF ONE WANTS TO CONVERT TIME INTO       M15. 275
  //C)    DOLLARS, OR SOME OTHER MEASURE OF JOB EFFORT, IT IS EASILY DONE.  M15. 276
  //C     INCLUDE  '[SCOTT]COMMUK.FOR' --- SHARE WITH "SETTYM" IN-LINE:     M37. 865
  //C!COMMON /TIMERS/ CPUTIME
  //C!INTEGER*4 CPUTIME
  //C!COMMON /TIMER2/ L4CPU,CPUTIME_CODE,CPUTIME_ADR,ZERO,ZEROFIN
  //C!INTEGER*2 L4CPU,CPUTIME_CODE
  //C!INTEGER*4 CPUTIME_ADR,ZERO,ZEROFIN,SYS$GETJPI,NOW_CPUTIME
  //C!DATA CPUTIME_CODE /1031/
  //C!DATA L4CPU /4/
  //C!CPUTIME_ADR=%LOC(NOW_CPUTIME)
  //C!IF (.NOT.SYS$GETJPI(,,,L4CPU,,,)) THEN
  //C!            WRITE(6,*) 'ERROR IN ANOTHER PRIVATE PLACE'
  //C!            ENDIF
  //C!D1=(NOW_CPUTIME-CPUTIME)/100.0
  //C!D2=0.0
}

//int
//locint(
//  arr_cref<int> iarray)
//{
//  int return_value = fem::int0;
//  iarray(dimension(1));
//  //C!IMPLICIT REAL*8 (A-H, O-Z),
//  //C     INSTALLATION-DEPENDENT EMTP MODULE.   THIS IS  VAX  VERSION.      M29. 926
//  //C     FUNCTION  'LOCINT'  IS DESIGNED TO RETURN THE ADDRESS IN MEMORY   M24. 168
//  //C     OF THE ARGUMENT, AS AN  INTEGER*4  WORD ADDRESS.   AN ARBITRARY   M24. 169
//  //C     CONSTANT OFFSET IS ALLOWED, SINCE ONLY DIFFERENCES WILL EVER BE   M24. 170
//  //C     USED BY THE EMTP.   NOTE VECTOR ARGUMENT  "IARRAY"  (WHICH        M29. 927
//  //C     IS AN ASSUMPTION FOR ALL EMTP USAGE).                             M29. 928
//  //C!LOCINT = ( %LOC( IARRAY(1) ) )/4
//  //Cdeb this is not used for the tes
//  return_value = (loc(iarray(1))) / 4;
//  return return_value;
//}
//template<typename T>
//int
//locint(
//  T& iarray) //arr_cref<int> iarray)
//{
//  int return_value = fem::int0;
//  //iarray(dimension(1));
//  return_value = 0; // not applied to the testing case (loc(iarray(1))) / 4;
//  return return_value;
//}

void move(
  arr_cref<int> inta,
  arr_ref<int> intb,
  int const& n) try
{
  inta(dimension(n));
  intb(dimension(n));
  //C)    SUBROUTINE  MOVE  IS IDENTICAL TO THE                             M15. 311
  //C)    BLOCK-TRANSFER ROUTINE  MOVER  EXCEPT                             M15. 312
  //C)    THAT  MOVE  IS FOR INTEGER ARRAYS, WHILE  MOVER  WAS FOR          M15. 313
  //C)    FLOATING-POINT ARRAYS.   THERE IS A DIFFERENCE, OF COURSE, ON     M15. 314
  //C)    MACHINES LIKE IBM, WHERE INTEGER WORDS MAY BE SHORTER THAN        M15. 315
  //C)    FLOATING-POINT WORDS.                                             M15. 316
  int i = fem::int0;
  FEM_DO_SAFE(i, 1, n) {
    intb(i) = inta(i);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void dimens(
  arr_ref<int> lsize,
  int const& nchain,
  str_ref bus1,
  str_ref bus2) try
{
  lsize(dimension(62));
  int n7 = fem::int0;
  //C!IMPLICIT REAL*8 (A-H, O-Z)
  if (nchain >= 29) {
    goto statement_2900;
  }
  lsize(1) = 3002;
  lsize(2) = 3000;
  lsize(3) = 10000;
  lsize(4) = 100;
  lsize(5) = 20000;
  lsize(6) = 1200;
  lsize(7) = 4000;
  lsize(8) = 120000;
  lsize(9) = 300;
  lsize(10) = 900;
  lsize(11) = 210;
  lsize(12) = 900;
  lsize(13) = 5;
  lsize(14) = 460;
  lsize(15) = 90;
  lsize(16) = 84;
  lsize(17) = 4;
  lsize(18) = 254;
  lsize(19) = 90000;
  lsize(20) = 100000;
  lsize(21) = 3000;
  lsize(22) = 50000;
  lsize(23) = 30000;
  lsize(24) = 24;
  lsize(25) = 30000;
  lsize(26) = 3000;
  lsize(27) = 600;
  lsize(28) = 1080;
  n7 = 28 + 1;
  lsize(n7) = 1842869;
  //C!w
  bus1 = "91205";
  bus2 = "123093";
  return;
  statement_2900:
  if (nchain > 29) {
    goto statement_3100;
  }
  lsize(1) = 0;
  lsize(2) = 1992869;
  lsize(3) = 23;
  lsize(4) = 30000;
  lsize(5) = 1;
  lsize(6) = 3002;
  lsize(7) = 9;
  lsize(8) = 300;
  return;
  statement_3100:
  if (nchain > 31) {
    goto statement_3900;
  }
  lsize(1) = 9;
  lsize(2) = 300;
  return;
  statement_3900:
  if (nchain > 39) {
    goto statement_1000;
  }
  lsize(1) = 71;
  lsize(2) = 10000;
  return;
  statement_1000:
  if (nchain > 10) {
    goto statement_4400;
  }
  lsize(1) = 1;
  lsize(2) = 3002;
  lsize(3) = 23;
  lsize(4) = 30000;
  lsize(5) = 4;
  lsize(6) = 100;
  return;
  statement_4400:
  if (nchain > 44) {
    goto statement_4500;
  }
  lsize(1) = 9;
  lsize(2) = 300;
  lsize(3) = 75;
  lsize(4) = 22155;
  lsize(5) = 71;
  lsize(6) = 210;
  lsize(7) = 76;
  lsize(8) = 420;
  lsize(9) = 74;
  lsize(10) = 5565;
  lsize(11) = 73;
  lsize(12) = 211;
  return;
  statement_4500:
  if (nchain > 45) {
    goto statement_4700;
  }
  lsize(1) = 9;
  lsize(2) = 300;
  return;
  statement_4700:
  if (nchain > 47) {
    goto statement_9900;
  }
  lsize(1) = 9;
  lsize(2) = 300;
  return;
  statement_9900:
  lsize(1) = locint(bus1) - locint(bus2);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void tapsav(
  common& cmn,
  arr_ref<int> narray,
  int const& n1,
  int const& n2,
  int const& n3) try
{
  narray(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& trash = cmn.trash;
  const auto& nbyte = cmn.nbyte;
  int& kburro = cmn.kburro;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& it = cmn.it;
  arr_ref<int> karray(static_cast<common_c29b01&>(cmn).karray,
    dimension(1992869));
  //
  int n9 = fem::int0;
  arr_1d<2, int> kpen(fem::fill0);
  int n4 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  int n13 = fem::int0;
  int kvecsv = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  //C     NEAR-UNIVERSAL MODULE FOR DUMPING OR RESTORING (CENTRAL MEMORY    M32. 251
  //C     VS. DISK) OF  /LABEL/ .   THIS DOES NOT WORK FOR THOSE            M28. 285
  //C     COMPUTERS LIKE PRIME AND BURROUGHS WHERE  COMMON  BLOCKS          M28. 286
  //C     ARE NOT ORDERED REGULARLY IN MEMORY.   SWITCH "KBURRO"            M29. 948
  //C     SELECTS BETWEEN DISK OR VIRTUAL MEMORY (/C29B01/).                M29. 949
  if (iprsup < 1) {
    goto statement_5840;
  }
  n9 = 0;
  kpen(2) = 0;
  n4 = locint(narray(1));
  write(lunit6,
    "(/,' TOP OF  ''TAPSAV''.',"
    "'      N1      N2      N3  KBURRO              N4',/,18x,4i8,i16)"),
    n1, n2, n3, kburro, n4;
  //C     FOLLOWING CHECK NORMALLY SENDS VAX EMTP TO 6327 (DISK IS          M32. 257
  //C     ONLY WANTED FOR TABLE SAVING WITHIN A SIMULATION FOR              M32. 258
  //C     TEST PURPOSES):                                                   M32. 259
  statement_5840:
  if (kburro == 1) {
    goto statement_6327;
  }
  statement_5448:
  if (n3 > 1) {
    goto statement_5891;
  }
  {
    write_loop wloop(cmn, n1, fem::unformatted);
    FEM_DO_SAFE(i, 1, n2) {
      wloop, narray(i);
    }
  }
  goto statement_9000;
  statement_5891:
  {
    read_loop rloop(cmn, n1, fem::unformatted);
    FEM_DO_SAFE(i, 1, n2) {
      rloop, narray(i);
    }
  }
  goto statement_9000;
  statement_6327:
  if (nchain == 20 && cmn.memsav == 1) {
    goto statement_5448;
  }
  if (nchain == 1) {
    goto statement_5448;
  }
  if (nchain == 6 || nchain == 8) {
    goto statement_9000;
  }
  //C     PRECEDING "IF" BRANCHES WILL SEND  "MEMSAV=1"  TABLE              M29. 964
  //C     SAVING OF OVERLAY 20 AND  "START AGAIN"  TABLE RESTORING          M29. 965
  //C     OF OVERLAY 1 TO DISK, ALWAYS.   THIS IS FOR PERMANENT             M29. 966
  //C     (DISK) STORAGE.   "STATISTICS"  AND  "SYSTEMATIC"  DATA           M29. 967
  //C     CASES, ON THE OTHER HAND, SHALL DUMP TO  /C29B01/ .               M29. 968
  //C     FIRST 50 CELLS OF /C29B01/ (KARRAY) ARE SAVED FOR RTM USE.        M30. 108
  n13 = 29;
  dimens(kpen(1), n13, trash, trash);
  kvecsv = 2 * (it + it + cmn.ibr + cmn.ntot + cmn.ioffd) +
    cmn.kswtch + cmn.lhist;
  n9 = cmn.ltlabl + kvecsv * nbyte(3) / nbyte(4);
  if (n9 < kpen(2) + 50) {
    goto statement_6342;
  }
  write(lunit6,
    "(' ERROR STOP IN \"TAPSAV\".  OVERFLOW OF',"
    "' /C29B01/ STORAGE.  N2, KPEN(2) =',2i8,'     NEEDED STORAGE N9 =',i8,/,"
    "' MEMORY REQUIREMENT IN INTEGER WORDS FOR VIRTUAL',"
    "' COMPUTER IMPLEMENTATION OF TAPSAV. STORAGE MUST',/,"
    "' PROVIDE FOR ALL OF --/LABEL/--( DECK \"LABCOM\" ),',"
    "' THE SEVERAL USAGES OF \"VECRSV\" AND \"VECISV\"(OVER6-11),',"
    "' PLUS 50 EXTRA CELLS.',/,' NCHAIN =',i5)"),
    n2, kpen(2), n9, nchain;
  stoptp(cmn);
  statement_6342:
  j = 50;
  if (n3 > 1) {
    goto statement_6352;
  }
  FEM_DO_SAFE(k, 1, n2) {
    j++;
    karray(j) = narray(k);
  }
  goto statement_9000;
  statement_6352:
  FEM_DO_SAFE(k, 1, n2) {
    j++;
    narray(k) = karray(j);
  }
  statement_9000:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT \"TAPSAV\".   N9, KPEN(2) =',2i8)"), n9, kpen(2);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct tables_save
{
  arr<int> iprsav;

  tables_save() :
    iprsav(dimension(4), fem::fill0)
  {}
};

void tables(
  common& cmn) try
{
  FEM_CMN_SVE(tables);
  common_read read(cmn);
  common_write write(cmn);
  const auto& voltbc = cmn.voltbc;
  auto& lunit2 = cmn.lunit2;
  const auto& lunsav = cmn.lunsav;
  auto& iprsov= cmn.iprsov;
  int& numsm = cmn.numsm;
  int& lastov = cmn.lastov;
  int& numdcd = cmn.numdcd;
  int& ltlabl = cmn.ltlabl;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& nword1 = cmn.nword1;
  int& nword2 = cmn.nword2;
  const auto& etac = cmn.etac;
  auto& locker = cmn.locker;
  const auto& z = static_cast<common_smach&>(cmn).z;
  const auto& busum = cmn.busum;
  //
  auto& iprsav = sve.iprsav;
  if (is_called_first_time) {
    static const int values[] = {
      0, 0, 0, 0
    };
    fem::data_of_type<int>(FEM_VALUES_AND_SIZE),
      iprsav;
  }
  int ll1 = fem::int0;
  int ll2 = fem::int0;
  int ll4 = fem::int0;
  arr_1d<1, int> kpen(fem::fill0);
  arr_1d<1, int> idistx(fem::fill0);
  int n4 = fem::int0;
  int n5 = fem::int0;
  //int kbase = fem::int0;
  arr_1d<1, double> busone(fem::fill0);
  int n9 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  arr_1d<1, int> integx(fem::fill0);
  arr_1d<1, int> ktemp(fem::fill0);
  arr_1d<1, int> jtemp(fem::fill0);
  arr_1d<1, int> itemp(fem::fill0);
  int n3 = fem::int0;
  int n2 = fem::int0;
  int n24 = fem::int0;
  int j = fem::int0;
  int n1 = fem::int0;
  //C     UTILITY WHICH IS USED TO BOTH DUMP AND RESTORE EMTP               M28. 288
  //C     TABLES (CENTRAL MEMORY VS. DISK).  USAGE IS FOR BOTH              M28. 289
  //C     "STATISTICS" (OVER12, OVER15, OVER20) AND  "START AGAIN"          M28. 290
  //C     (OVER1, OVER20).   CALL TO  "TAPSAV"  DUMPS  /LABEL/ .            M28. 291
  //C     ALSO USED BY  $RESTART  REQUEST OF  "CIMAGE"  (CALLED             M29. 974
  //C     FROM  "LOOKIE"  WHICH IS CALLED BY  "SUBTS3"  OF  OV16).          M29. 975
  //C     ALSO USED BY  "RESTORE"  REQUEST OF RTM, WHERE TABLE              M30. 111
  //C     RESTORATION IS IN  "KATALG"  OF OVERLAY 20.                       M37. 977
  //C     NOTE ABOUT DECK "SYNMAC".   IF EMTP S.M. MODELING                 M38. 188
  //C     BRANDWAJN (TYPE-59), IS TO BE DELETED,                            M38. 189
  //C     THEN ALL S.M. SUBROUTINES ( SMDAT, SMOUT, SMPFIT,                 M38. 190
  //C     SMINT, UNCOR, PREMEC, ELEC, PAST,                                 M38. 191
  //C     UPDATE, INCREM ) ARE TO BE DESTROYED,  AND                        M38. 192
  //C     DECK "SYNMAC" IS TO BE REMOVED FROM THE PRESENT MODULE.           M31. 167
  //C     BUT THEN  "DIMENSION Z(1)"  SHOULD BE ADDED IN ITS                M39.  69
  //C     PLACE,  AND THE  "N4 ="  CALCULATION INVOLVING "LOCINT"           M31. 169
  //C     SHOULD BE REPLACED BY THE SIMPLE STATEMENTS  "N4 = 1" .           M31. 170
  //C     COMMENT CARD IMMEDIATELY PRECEDING "SYNMAC" -------------         M31. 171
  //C     COMMENT CARD IMMEDIATELY FOLLOWING "SYNMAC" -------------         M31. 172
  //C!w EQUIVALENCE  ( X(1), INTEGX(1) )
  //C!w EQUIVALENCE  ( BUS1, BUSONE(1) ), ( NENERG, IDISTX(1) )
  //C!w EQUIVALENCE ( KPEN(1), BUS1 ),  ( ITEMP(1), BUSUM(1) )
  //C!w EQUIVALENCE  ( JTEMP(1), ETAC(1) ),  ( KTEMP(1), Z(1) )
  // solved EQUIVALENCE  ( MONCAR(2), KBASE )
  //C     BURROUGHS: PRESERVE LOCAL VARIABLE BETWEEN MODULE CALLS:          M42.1016
  //C
  ll1 = 1;
  ll2 = 2;
  ll4 = 4;
  nword1 = locint(voltbc(1)) - locint(kpen(1));
  nword2 = locint(idistx(1)) - locint(lunsav(15));
  n4 = locint(cmn.msmout) - locint(z(1)) + 1;
  n5 = locint(cmn.lbstac) - locint(etac(1)) + 1;
  auto& kbase = cmn.moncar(2);
  if (kbase == 0) {
    nword1 = locint(idistx(1)) - locint(busone(1));
  }
  n9 = locint(cmn.istart) - locint(busum(1)) + 1;
  cmn.io.rewind(lunit2);
  if (nchain == 1) {
    goto statement_3289;
  }
  if (nchain == 20) {
    goto statement_3289;
  }
  statement_3289:
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' WITHIN  \"TABLES\" .',"
      "'      N4      N5  NWORD1  NWORD2  LTLABL      N9',"
      "'  NCHAIN  LASTOV  LUNIT2',14x,'T',/,19x,9i8,e15.6)"),
      n4, n5, nword1, nword2, ltlabl, n9, nchain, lastov, lunit2,
      cmn.t;
  }
  if (nchain == 1) {
    goto statement_5342;
  }
  if (cmn.memsav == 1016) {
    goto statement_5342;
  }
  if (nchain < lastov) {
    goto statement_5342;
  }
  write(lunit2, fem::unformatted), locker;
  {
    write_loop wloop(cmn, lunit2, fem::unformatted);
    FEM_DO_SAFE(i, 1, nword1) {
      wloop, kpen(i);
    }
  }
  {
    write_loop wloop(cmn, lunit2, fem::unformatted);
    FEM_DO_SAFE(i, 35, nword2) {
      wloop, iprsov(i);
    }
  }
  //C     STORE IPRSOV(16-19) IN IPRSAV AT 1ST CALL TO TABLES FROM OVER12   M42.1019
  move(iprsov(16), iprsav(1), ll4);
  tapsav(cmn, integx(1), lunit2, ltlabl, ll1);
  if (numsm != 0) {
    {
      write_loop wloop(cmn, lunit2, fem::unformatted);
      FEM_DO_SAFE(i, 1, n4) {
        wloop, ktemp(i);
      }
      FEM_DO_SAFE(i, 1, n5) {
        wloop, jtemp(i);
      }
    }
  }
  {
    write_loop wloop(cmn, lunit2, fem::unformatted);
    FEM_DO_SAFE(i, 1, n9) {
      wloop, itemp(i);
    }
  }
  goto statement_5359;
  statement_5342:
  read(lunit2, fem::unformatted), locker;
  if (iprsup >= 9) {
    write(lunit6, "(' AFTER 1ST READ.  LOCKER =',2i8)"), locker;
  }
  n3 = nchain;
  n2 = iprsup;
  n24 = numdcd;
  {
    read_loop rloop(cmn, lunit2, fem::unformatted);
    FEM_DO_SAFE(i, 1, nword1) {
      rloop, kpen(i);
    }
  }
  {
    read_loop rloop(cmn, lunit2, fem::unformatted);
    FEM_DO_SAFE(i, 35, nword2) {
      rloop, iprsov(i);
    }
  }
  tapsav(cmn, integx(1), lunit2, ltlabl, ll2);
  if (iprsup >= 9) {
    write(lunit6, "(' AFTER TAPSAV: NUMSM,N4,N5,N9 = ',4i5)"), numsm,
      n4, n5, n9;
  }
  if (numsm != 0) {
    {
      read_loop rloop(cmn, lunit2, fem::unformatted);
      FEM_DO_SAFE(i, 1, n4) {
        rloop, ktemp(i);
      }
      FEM_DO_SAFE(i, 1, n5) {
        rloop, jtemp(i);
      }
    }
  }
  {
    read_loop rloop(cmn, lunit2, fem::unformatted);
    FEM_DO_SAFE(i, 1, n9) {
      rloop, itemp(i);
    }
  }
  nchain = n3;
  iprsup = n2;
  numdcd = n24;
  //C     RESTORE ALTERNATE TIME-STEP LOOP DIAGNOSTIC PRINTOUT              M42.1021
  //C     REQUEST FOR THE FIRST ENERGIZATION IN A STATISTICS CASE           M42.1022
  FEM_DO_SAFE(j, 1, 4) {
    if (iprsov(j + 15) != iprsav(j)) {
      goto statement_1482;
    }
  }
  goto statement_5359;
  statement_1482:
  FEM_DO_SAFE(j, 1, 4) {
    n1 = iprsov(j + 15);
    iprsov(j + 15) = iprsav(j);
    iprsov(j + 30) = n1;
  }
  statement_5359:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT \"TABLES\".')");
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void prompt(
  common& cmn)
{
  common_write write(cmn);
  fem::str<80>& prom80 = cmn.prom80;
  //
  int n2 = fem::int0;
  int j = fem::int0;
  auto& lunit6 = cmn.lunit6;
  //C       VAX-11  INSTALLATION-DEPENDENT EMTP MODULE USED ONLY            M35.4239
  //C     FOR INTERACTIVE EMTP ("EMTSPY").  INPUT IS PROGRAM                M35.4240
  //C     PROMPT IN CHARACTER*80 VARIABLE PROM80 OF DECK "DEKSPY".          M35.4241
  //C     THE PROMPT MUST END WITH COLON (":").  THEN LINE FEED             M35.4242
  //C     WILL BE SUPPRESSED, SO SUBSEQUENT READ IS TO RIGHT OF ":".        M35.4243
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4244
  n2 = 80;
  FEM_DO_SAFE(j, 1, 80) {
    if (prom80(n2, n2) != " ") {
      goto statement_1426;
    }
    n2 = n2 - 1;
  }
  return;
  //C     FOLLOWING LUNIT6 SHOULD REALLY GO TO 2ND SCREEN ("WINDOW")        M37.7289
  statement_1426:
  write(lunit6, "(a,$)"), prom80(1, n2);
  //C ",$" IS DEC MAGIC TO HOLD CURSOR

}

void pfatch(
  common& cmn) try
{
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& csepar = cmn.csepar;
  auto& texcol = cmn.texcol;
  int& kolbeg = cmn.kolbeg;
  int& ialter = cmn.ialter;
  int& iprsup = cmn.iprsup;
  //
  int j = fem::int0;
  int n4 = fem::int0;
  arr_1d<25, char> filen(fem::fill0);
  int k = fem::int0;
  int n7 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  //C     THIS INSTALLATION-DEPENDENT MODULE SERVES TO CONNECT A            M28.2820
  //C     FILE TO  I/O  CHANNEL  IALTER  (/BLANK/ VARIABLE),                M28.2821
  //C     BASED ON THE FILE SPECIFICATION CONTAINED ON LAST-                M28.2822
  //C     READ DATA CARD.   DIFFERENT USAGES INCLUDE:                       M28.2823
  //C           REPLOT, FILE SPECIFICATION                                  M28.2824
  //C           START AGAIN, FILE SPECIFICATION                             M28.2825
  //C     FREE-FORMAT IS HERE REQUIRED, TEMPORARILY.                        M28.2826
  //C        MODULE WRITTEN SPECIALLY FOR  DEC  VAX-11/780 .                M27. 633
  //C NOT INTERACTIVE EMTP
  if (cmn.m4plot != 1) {
    goto statement_4519;
  }
  write(cmn.prom80, "('    SEND VAX DISK FILE NAME:')");
  //C WRITE PROM80 WITH CURSOR CONTROL (NO LF)
  prompt(cmn);
  {
    read_loop rloop(cmn, cmn.munit5, "(30a1)");
    FEM_DO_SAFE(j, 1, 30) {
      rloop, texcol(j);
    }
  }
  //C PUT "," TERMINATOR AFTER NAME
  texcol(31) = csepar;
  //C CONNECT EMTP TABLES FILE TO THIS UNIT
  ialter = cmn.lunit2;
  statement_4519:
  n4 = 0;
  write(filen(1), "(25x)");
  FEM_DO_SAFE(k, kolbeg, 80) {
    if (texcol(k) == cmn.blank) {
      goto statement_4532;
    }
    if (texcol(k) == csepar) {
      goto statement_4536;
    }
    n4++;
    write(filen(n4), "(80a1)"), texcol(k);
    statement_4532:;
  }
  statement_4536:
  cmn.nfrfld = 1;
  kolbeg = k + 1;
  n7 = ialter;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' READY TO CONNECT FILE TO UNIT  \"IALTER\" =',i3,"
      "' .   \"FILEN\" =',25a1)"),
      ialter, filen;
  }
  cmn.io.close(n7);
  cmn.io.open(n7, std::string(filen.begin(), filen.size()))
    .form("UNFORMATTED")
    .status("OLD");
  if (iprsup >= 1) {
    write(lunit6, "(/,' SUCCESSFUL FILE OPENING IN  \"PFATCH\" .')");
  }
  cmn.icat = 2;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct frenum_save
{
  fem::str<8> blank;
  fem::logical_star_1 textb;

  frenum_save() :
    blank(fem::char0),
    textb(fem::zero<fem::logical_star_1>())
  {}
};

void frenum(
  common& cmn,
  str_arr_cref<> text1,
  int const& n3,
  double& d1) try
{
  FEM_CMN_SVE(frenum);
  text1(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& blank = sve.blank;
  fem::logical_star_1& textb = sve.textb;
  if (is_called_first_time) {
    blank = "      ";
    textb = " ";
  }
  int n9 = fem::int0;
  int n4 = fem::int0;
  int i = fem::int0;
  arr_1d<30, fem::logical_star_1> texta(fem::fill0);
  //C     VAX-11/780  INSTALLATION-DEPENDENT MODULE CALLED ONLY BY          M28. 250
  //C     THE FREE-FORMAT DATA MODULE  "FREFLD" .   PURPOSE IS TO           M28. 251
  //C     CONVERT INPUT CHARACTERS  (TEXT1(1) ... TEXT1(N3))  INTO          M28. 252
  //C     A FLOATING POINT NUMBER.                                          M28. 253
  n9 = 30;
  n4 = n3 + 1;
  FEM_DO_SAFE(i, 1, n3) {
    n4 = n4 - 1;
    if (text1(n4) == blank) {
      goto statement_4718;
    }
    if (n9 >= 2) {
      goto statement_4711;
    }
    write(6,
      "(/,' ERROR STOP IN \"FRENUM\". THERE ARE',"
      "' 33 OR MORE CHARACTERS IN A FREE-',"
      "' FORMAT NUMBER ON LAST DATA CARD.')");
    //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
    stoptp(cmn);
    statement_4711:
    write(texta(n9), "(80a1)"), text1(n4);
    n9 = n9 - 1;
    statement_4718:;
  }
  FEM_DO_SAFE(i, 1, n9) {
    texta(i) = textb;
  }
  read(texta(1), "(e30.0)"), d1;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void packa1(
  str_cref from,
  str_ref to,
  int const& kk) try
{
  //from(dimension(1));
  //to(dimension(6));
  //C     SYSTEM-DEPENDENT EMTP MODULE  'PACKA1'  FOR  VAX-11/780.          M28. 279
  //C     ARGUMENT  'FROM'  CONTAINS  A1  INFORMATION WHICH IS TO BE STORED M20. 374
  //C     IN CHARACTER POSITION  KK  OF ARGUMENT  'TO' .                    M20. 375
  //C     FOR ALL EMTP USAGE,  1ST 2 ARGUMENTS MUST BE VECTORS.             M29. 945
  to(kk,kk) = from(1);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

// forward declaration (dependency cycle)
struct frefld_save
{
  fem::str<8> chtacs;

  frefld_save() :
    chtacs(fem::char0)
  {}
};

void frefld(
  common& cmn,
  arr_ref<double> array) try
{
  FEM_CMN_SVE(frefld);
  array(dimension(1));
  common_write write(cmn);
  fem::str<8>& blank = cmn.blank;
  fem::str<8>& csepar = cmn.csepar;
  fem::str<8>& chcont = cmn.chcont;
  const auto& texcol = cmn.texcol;
  auto& texta6 = cmn.texta6;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  //
  fem::str<8>& chtacs = sve.chtacs;
  if (is_called_first_time) {
    chtacs = "TACS  ";
  }
  auto& lunit6 = cmn.lunit6;
  int jj = fem::int0;
  int n3 = fem::int0;
  fem::str<8> text1 = blank;
  arr_1d<30, fem::str<8> > texbuf(fem::fill0);
  int ll = fem::int0;
  arr_1d<1, fem::str<8> > texvec(fem::fill0);
  int n9 = fem::int0;
  int i = fem::int0;
  //C!REAL*8         TEXT1, CHTACS, TEXBUF, TEXVEC
  //C!w EQUIVALENCE  ( TEXVEC(1),  TEXT1 )
  if (iprsup >= 5) {
    write(lunit6,
      "(' TOP \"FREFLD\".  NFRFLD, NRIGHT, KOLBEG =',3i6)"), nfrfld,
      nright, kolbeg;
  }
  if (nright < 0) {
    goto statement_5913;
  }
  FEM_DO_SAFE(jj, 1, nfrfld) {
    if (kolbeg <= 80) {
      goto statement_5600;
    }
    lstat(19) = 5600;
    goto statement_9200;
    statement_5600:
    n3 = 0;
    goto statement_5805;
    statement_5603:
    if (chcont == chtacs) {
      goto statement_5614;
    }
    if (text1 == blank) {
      goto statement_5802;
    }
    if (text1 != csepar) {
      goto statement_5623;
    }
    statement_5609:
    kolbeg++;
    goto statement_5827;
    statement_5614:
    if (text1 != csepar) {
      goto statement_5623;
    }
    if (text1 == blank) {
      goto statement_5802;
    }
    goto statement_5609;
    statement_5623:
    if (n3 < 30) {
      goto statement_5627;
    }
    lstat(19) = 5623;
    goto statement_9200;
    statement_5627:
    n3++;
    texbuf(n3) = text1;
    statement_5802:
    kolbeg++;
    statement_5805:
    text1 = texcol(kolbeg);
    if (text1 != chcont) {
      goto statement_5819;
    }
    //C     READ INPUT CARD USING CIMAGE                                      M20. 325
    cimage(cmn);
    kolbeg = 1;
    if (n3 == 0) {
      goto statement_5805;
    }
    goto statement_5827;
    statement_5819:
    if (kolbeg <= 80) {
      goto statement_5603;
    }
    statement_5827:
    if (n3 > 0) {
      goto statement_5829;
    }
    array(jj) = 0.0f;
    goto statement_5831;
    statement_5829:
    frenum(cmn, texbuf(1), n3, array(jj));
    statement_5831:
    if (iprsup >= 5) {
      write(lunit6,
        "(/,' \"FREFLD\" NUMBER.','      JJ  KOLBEG      N3',21x,'ARRAY(JJ)',"
        "/,17x,3i8,e30.20)"),
        jj, kolbeg, n3, array(jj);
    }
  }
  goto statement_9900;
  statement_5913:
  if (nright <  - 1) {
    goto statement_6036;
  }
  FEM_DO_SAFE(jj, 1, nfrfld) {
    texta6(jj) = blank;
    ll = 0;
    if (kolbeg <= 80) {
      goto statement_5920;
    }
    lstat(19) = 5920;
    goto statement_9200;
    statement_5920:
    text1 = texcol(kolbeg);
    kolbeg++;
    if (chcont == chtacs) {
      goto statement_5928;
    }
    if (text1 == blank) {
      goto statement_5923;
    }
    if (text1 == csepar) {
      goto statement_5948;
    }
    statement_5921:
    if (ll <= 6) {
      goto statement_5922;
    }
    lstat(19) = 5922;
    goto statement_9200;
    statement_5928:
    if (text1 == csepar) {
      goto statement_5948;
    }
    if (text1 == blank) {
      goto statement_5923;
    }
    goto statement_5921;
    statement_5922:
    ll++;
    packa1(text1, texta6(jj), ll);
    statement_5923:
    if (kolbeg <= 80) {
      goto statement_5920;
    }
    statement_5948:;
  }
  goto statement_9900;
  statement_6036:
  ll = 0;
  jj = 0;
  goto statement_6054;
  statement_6042:
  jj++;
  if (jj > 10) {
    goto statement_6072;
  }
  texta6(jj) = blank;
  ll = 0;
  statement_6048:
  text1 = texcol(kolbeg);
  if (chcont == chtacs) {
    goto statement_6051;
  }
  if (text1 == blank) {
    goto statement_6054;
  }
  if (text1 == csepar) {
    goto statement_6072;
  }
  goto statement_6052;
  statement_6051:
  if (text1 == csepar) {
    goto statement_6072;
  }
  if (text1 == blank) {
    goto statement_6054;
  }
  statement_6052:
  if (ll == 6) {
    goto statement_6042;
  }
  ll++;
  packa1(text1, texta6(jj), ll);
  kolbeg++;
  goto statement_6048;
  statement_6054:
  n9 = kolbeg;
  FEM_DO_SAFE(i, kolbeg, 80) {
    if (texcol(i) != blank) {
      goto statement_6067;
    }
  }
  kolbeg = 79;
  goto statement_6072;
  statement_6067:
  kolbeg = i;
  if (kolbeg - n9 <= 2) {
    goto statement_6069;
  }
  if (jj > 0) {
    goto statement_6072;
  }
  statement_6069:
  if (texcol(kolbeg) != csepar) {
    goto statement_6042;
  }
  statement_6072:
  nfrfld = jj;
  kolbeg++;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' KEYWORD NEAR \"FREFLD\" EXIT.','      JJ      LL  KOLBEG',/,28x,"
      "3i8,/(' TEXCOL =',30a4))"),
      jj, ll, kolbeg, texcol;
  }
  goto statement_9900;
  statement_9200:
  kill = 166;
  if (iprsup >= 0) {
    write(lunit6, "(/,' ERROR STOP WITHIN  ''FREFLD'' .',6i8,/,1x)"),
      lstat(19), cmn.nchain, cmn.lastov, kolbeg, nfrfld, nright;
  }
  lstat(18) = -1;
  statement_9900:
  if (iprsup >= 2) {
    write(lunit6,
      "(' EXIT \"FREFLD\".  KILL, KOLBEG, ARRAY(1) =',2i6,e20.10)"),
      kill, kolbeg, array(1);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void freone(
  common& cmn,
  double& d1) try
{
  //C     SCALAR VERSION OF  "FREFLD"  WHICH ENTERS THE UTPF WITH           M29. 936
  //C     "M29."  VINTAGE, TO SATISFY BURROUGHS (SEE PROBLEM B,             M29. 937
  //C     SECTION II, PAGE ECWB-4, VOL. X  EMTP MEMO OF 14 FEB 1981.)       M31. 156
  arr_1d<1, double> array(fem::fill0);
  frefld(cmn, array(1));
  d1 = array(1);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}


struct cimage_save
{
  fem::str<8> charc;
  fem::str<8> chtacs;
  arr<int> jpntr;
  int n11;
  int n12;
  int n13;
  int n8;
  fem::str<8> text4;
  fem::str<8> text5;
  arr<fem::str<8> > textax;
  arr<fem::str<8> > textay;

  cimage_save() :
    charc(fem::char0),
    chtacs(fem::char0),
    jpntr(dimension(52), fem::fill0),
    n11(fem::int0),
    n12(fem::int0),
    n13(fem::int0),
    n8(fem::int0),
    text4(fem::char0),
    text5(fem::char0),
    textax(dimension(60), fem::fill0),
    textay(dimension(50), fem::fill0)
  {}
};


void cimage(
  common& cmn) try
{
  FEM_CMN_SVE(cimage);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& blank = cmn.blank;
  fem::str<8>& csepar = cmn.csepar;
  fem::str<8>& chcont = cmn.chcont;
  auto& texcol = cmn.texcol;
  const auto& texta6 = cmn.texta6;
  auto& abuff = cmn.abuff;
  double& epsiln = cmn.epsiln;
  double& xunits = cmn.xunits;
  double& copt = cmn.copt;
  double& xopt = cmn.xopt;
  auto& lunit4 = cmn.lunit4;
  auto& lunit5 = cmn.lunit5;
  auto& lunit7 = cmn.lunit7;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& ipntv = cmn.ipntv;
  const auto& lunsav = cmn.lunsav;
  int& kol132 = cmn.kol132;
  int& inecho = cmn.inecho;
  int& noutpr = cmn.noutpr;
  int& numdcd = cmn.numdcd;
  int& moldat = cmn.moldat;
  auto& muntsv = cmn.muntsv;
  int& iprsup = cmn.iprsup;
  int& intinf = cmn.intinf;
  int& ibr = cmn.ibr;
  auto& xoptbr = cmn.xoptbr;
  auto& coptbr = cmn.coptbr;
  //
  fem::str<8>& charc = sve.charc;
  fem::str<8>& chtacs = sve.chtacs;
  auto& jpntr = sve.jpntr;
  int& n11 = sve.n11;
  int& n12 = sve.n12;
  int& n13 = sve.n13;
  int& n8 = sve.n8;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  auto& textax = sve.textax;
  auto& textay = sve.textay;
  if (is_called_first_time) {
    n8 = 0;
    charc = "C";
    text4 = "9";
    chtacs = "TACS";
    text5 = "BLANK ";
    textay(1) = "A     ";
    jpntr(1) = 1;
    textax(1) = "ATTACH";
    textay(2) = "P     ";
    jpntr(2) = 2;
    textax(2) = "PUNCH ";
    textay(3) = "OUT   ";
    jpntr(3) = 3;
    textax(3) = "OUTPUT";
    textay(4) = "S     ";
    jpntr(4) = 4;
    textax(4) = "SAVE  ";
    textay(5) = "SPY   ";
    jpntr(5) = 5;
    textax(5) = "SPYDAT";
    textax(6) = "A     ";
    textay(6) = "D     ";
    jpntr(6) = 7;
    textax(7) = "DISABL";
    textax(8) = "E     ";
    textay(7) = "E     ";
    jpntr(7) = 9;
    textax(9) = "ENABLE";
    textay(8) = "R     ";
    jpntr(8) = 10;
    textax(10) = "RETURN";
    textay(9) = "N     ";
    jpntr(9) = 11;
    textax(11) = "NEWFIL";
    textax(12) = "E     ";
    textay(10) = "NE    ";
    jpntr(10) = 13;
    textax(13) = "NEW   ";
    textax(14) = "EPSILN";
    textay(11) = "DE    ";
    jpntr(11) = 15;
    textax(15) = "DELETE";
    textay(12) = "M     ";
    jpntr(12) = 16;
    textax(16) = "MONITO";
    textax(17) = "R     ";
    textay(13) = "LF    ";
    jpntr(13) = 18;
    textax(18) = "LISTOF";
    textax(19) = "F     ";
    textay(14) = "LN    ";
    jpntr(14) = 20;
    textax(20) = "LISTON";
    textay(15) = "V     ";
    jpntr(15) = 21;
    textax(21) = "VINTAG";
    textax(22) = "E     ";
    textay(16) = "OLD   ";
    jpntr(16) = 23;
    textax(23) = "OLDFIL";
    textax(24) = "E     ";
    textay(17) = "ST    ";
    jpntr(17) = 25;
    textax(25) = "STOP  ";
    textay(18) = "W     ";
    jpntr(18) = 26;
    textax(26) = "WATCH5";
    textay(19) = "COM   ";
    jpntr(19) = 27;
    textax(27) = "COMMEN";
    textax(28) = "T     ";
    textay(20) = "WI    ";
    jpntr(20) = 29;
    textax(29) = "WIDTH ";
    textay(21) = "U     ";
    jpntr(21) = 30;
    textax(30) = "UNITS ";
    jpntr(22) = 31;
    jpntr(23) = 0;
    n11 = 0;
    n12 = 99999;
    n13 = 99999;
  }
  auto& lunit6 = cmn.lunit6;
  //arr_1d<10, double> buff10(fem::fill0);
  fem::str<8> text1 = blank;
  fem::str<8> text2 = blank;
  int j = fem::int0;
  int i = fem::int0;
  int k = fem::int0;
  double d1 = fem::double0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int L = fem::int0;
  int n3 = fem::int0;
  double d11 = fem::double0;
  arr_1d<10, double> aupper(fem::fill0);
  int n7 = fem::int0;
  arr_1d<25, char> filen(fem::fill0);
  int n6 = fem::int0;
  int munit5 = fem::int0;
  int kfile5 = fem::int0;
  int n4 = fem::int0;
  static const char* format_3000 = "(10a8)";
  static const char* format_3006 = "(51x,'1',10a8)";
  static const char* format_3041 = "(80a1)";
  //C       VAX-11  INSTALLATION-DEPENDENT EMTP MODULE WHICH SERVES         M36. 215
  //C     TO RETURN THE NEXT INPUT CARD.  ALL SYSTEMS WILL SUBSTITUTE.      M36. 216
  //C!
  //C!w EQUIVALENCE ( BUFF10(1), ABUFF(1) )
  //C!w EQUIVALENCE ( AUPPER(1), TEXCOL(1) )
  //C     BURROUGHS: PRESERVE LOCAL VARIABLE BETWEEN MODULE CALLS:          M35. 244
  //C REMEMBER LAST $-CARD NUMBER
  //C               *****    REQUEST NO. 1.    "$ATTACH"      *****  *****  M27.  41
  //C               *****    REQUEST NO. 2.    "$PUNCH"       *****  *****  M27.  45
  //C               *****    REQUEST NO. 3.    "$OUTPUT"      *****  *****  M27.  49
  //C               *****    REQUEST NO. 4.    "$SAVE"        *****  *****  M27.  53
  //C               *****    REQUEST NO. 5.    "$SPYDATA"     *****  *****  M36. 217
  //C                   FORMER "$INCLUDE", WHICH IS NOW IN "EREXIT".        M36. 218
  //C               *****    REQUEST NO. 6.    "$DISABLE"     *****  *****  M27.  62
  //C               *****    REQUEST NO. 7.    "$ENABLE"      *****  *****  M27.  67
  //C               *****    REQUEST NO. 8.    "$RETURN"      *****  *****  M27.  71
  //C               *****    REQUEST NO. 9.    "NEWFILE"      *****  *****  M27.  75
  //C               *****    REQUEST NO. 10.   "NEW EPSILN"   *****  *****  M35. 246
  //C               *****    REQUEST NO. 11.   "DELETE"       *****  *****  M27.  85
  //C               *****    REQUEST NO. 12.   "MONITOR"      *****  *****  M27.  89
  //C               *****    REQUEST NO. 13.   "LISTOFF"      *****  *****  M27.  94
  //C               *****    REQUEST NO. 14.   "LISTON"       *****  *****  M27.  99
  //C               *****    REQUEST NO. 15.   "VINTAGE"      *****  *****  M28. 132
  //C               *****    REQUEST NO. 16.   "OLDFILE"      *****  *****  M28. 137
  //C               *****    REQUEST NO. 17.   "STOP"         *****  *****  M28. 142
  //C               *****    REQUEST NO. 18.   "WATCH5"       *****  *****  M28. 146
  //C               *****    REQUEST NO. 19.   "COMMENT"      *****  *****  M31. 112
  //C               *****    REQUEST NO. 20.   "WIDTH"        *****  *****  M32. 127
  //C               *****    REQUEST NO. 21.   "UNITS"        *****  *****  VAX.   4
  //C               *****   BOUNDS FOLLOW ...                               VAX.   7
  if (iprsup >= 10) {
    write(lunit6,
      "(' BEGIN CIMAGE.  LUNIT5, LUNIT6, NOUTPR,',' NUMDCD =',4i5)"),
      lunit5, lunit6, noutpr, numdcd;
  }
  //C INTERACTIVE USAGE
  statement_1000:
  if (cmn.m4plot == 1) {
    emtspy(cmn);
  }
  //if (lunit5 > 0) {
  //  try {
  //    read(lunit5, format_3000), abuff(1), abuff(9), abuff(17), abuff(25), abuff(33)
  //      , abuff(41), abuff(49), abuff(57), abuff(65), abuff(73); //buff10;
  //  }
  //  catch (fem::read_end const&) {
  //    goto statement_4000;
  //  }
  //}
  //if (lunit5 <= 0) {
  //  nextcard(cmn);
  //}
  //C "NEXTCARD" EOF JUMP
  nextcard(cmn);
  if (cmn.kill > 0) {
    goto statement_4000;
  }
  if (lunsav(5) !=  - 5) {
    numdcd++;
  }
  read(abuff, "(2a1)"), text1, text2;
  if (text1 != charc) {
    goto statement_3034;
  }
  if (text2 != blank) {
    goto statement_3034;
  }
  statement_1036:
  if (noutpr != 0) {
    goto statement_1000;
  }
  if (n11 != 0) {
    goto statement_1000;
  }
  if (kol132 == 132) {
    write(lunit6, "(' COMMENT CARD.',37x,'1',10a8)"), abuff(1), abuff(9), abuff(17), abuff(25), abuff(33)
      , abuff(41), abuff(49), abuff(57), abuff(65), abuff(73); //buff10;
  }
  if (kol132 != 132) {
    {
      //write_loop wloop(cmn, lunit6, "(' COMMENT CARD.',37x,'1',3a8,a5)");
      //FEM_DO_SAFE(j, 1, 4) {
      //  wloop, abuff(j);
      //}
      write(lunit6, "(' COMMENT CARD.',37x,'1',3a8,a5)"), abuff(1), abuff(9), abuff(17), abuff(25);
    }
  }
  goto statement_1000;
  statement_3034:
  if (noutpr != 0) {
    goto statement_3035;
  }
  if (kol132 == 132) {
    write(lunit6, format_3006), abuff(1), abuff(9), abuff(17), abuff(25), abuff(33)
      , abuff(41), abuff(49), abuff(57), abuff(65), abuff(73); //buff10;
  }
  if (kol132 != 132) {
    {
      //write_loop wloop(cmn, lunit6, "(51x,'1',3a8,a5)");
      //FEM_DO_SAFE(j, 1, 4) {
      //  wloop, abuff(j);
      //}
      write(lunit6, "(51x,'1',3a8,a5)"), abuff(1), abuff(9), abuff(17), abuff(25);
    }
  }
  statement_3035:
  if (n13 > 0) {
    goto statement_3011;
  }
  {
    //write_loop wloop(cmn, lunit6, "(1x,i5,' :',9a8)");
    //wloop, numdcd;
    //FEM_DO_SAFE(i, 1, 9) {
    //  wloop, abuff(i);
    //}
    write(lunit6, "(1x,i5,' :',9a8)"), numdcd, abuff(1), abuff(9), abuff(17), abuff(25), abuff(33)
      , abuff(41), abuff(49), abuff(57), abuff(65), abuff(73);
  }
  n13 = n12;
  statement_3011:
  n13 = n13 - 1;
  read(abuff, "(a6)"), text2;
  if (text2 != text5) {
    goto statement_3040;
  }
  if (n8 == 6) {
    goto statement_3044;
  }
  FEM_DO_SAFE(i, 1, 10) {
    abuff(i*8-7, i*8) = blank;
  }
  goto statement_3233;
  statement_3040:
  if (chcont == text4) {
    goto statement_3233;
  }
  read(abuff, format_3041), texcol;
  //C     DAN GOLDSWORTHY HAD TROUBLE WITH $LISTOFF WITHIN $INCLUDE         M36. 235
  //C     WHICH WAS WITHIN TACS SUPPLEMENTAL VARIABLES.  WSM+THL            M36. 236
  if (abuff(1,8) != "$LISTOFF" && abuff(1,8) != "$LISTON ") {
    goto statement_3042;
  }
  goto statement_3246;
  //C     CHCONT IS 'TACS' IF CIMAGE CALLED FROM WITHIN TACS FORTRAN EXPRESSM28. 162
  statement_3042:
  if (chcont == chtacs) {
    goto statement_3233;
  }
  if (texcol(1) == chcont) {
    goto statement_3246;
  }
  if (n8 != 6) {
    goto statement_1144;
  }
  statement_3044:
  if (noutpr == 0) {
    write(lunit6, "('+COMMENT CARD (IMPLICIT).')");
  }
  goto statement_1000;
  statement_1144:
  FEM_DO_SAFE(k, 1, 80) {
    if (texcol(k) == csepar) {
      goto statement_3237;
    }
    if (texcol(k) == chcont) {
      goto statement_3237;
    }
  }
  statement_3233:
  kolbeg = -intinf;
  goto statement_7014;
  statement_3237:
  kolbeg = 1;
  goto statement_7014;
  statement_3246:
  kolbeg = 2;
  nright = -2;
  freone(cmn, d1);
  if (iprsup >= 1) {
    write(lunit6, "(/,' NFRFLD =',i8,5x,'TEXTA6 =',2a7)"), nfrfld,
      texta6(1), texta6(2);
  }
  nright = 0;
  FEM_DO_SAFE(i, 1, 200) {
    n1 = jpntr(i);
    n2 = jpntr(i + 1) - 1;
    if (n2 < 0) {
      goto statement_3319;
    }
    if (iprsup >= 35) {
      {
        write_loop wloop(cmn, lunit6, "(' SPECIAL-REQUEST WORD',i4,' .',10a6)");
        wloop, i;
        FEM_DO_SAFE(j, n1, n2) {
          wloop, textax(j);
        }
      }
    }
    if (textax(n1) == blank) {
      goto statement_3306;
    }
    L = 0;
    n3 = n2 - n1 + 1;
    if (n3 != nfrfld) {
      goto statement_3306;
    }
    FEM_DO_SAFE(j, n1, n2) {
      L++;
      if (texta6(L) != textax(j)) {
        goto statement_3306;
      }
    }
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' KEY-WORD FOUND.  I, N8 =',2i5,5x,'TEXTA6, TEXTAY =',2a7)"),
        i, n8, texta6(1), textay(i);
    }
    statement_3294:
    if (n8 != 6) {
      goto statement_3301;
    }
    if (i != 7) {
      goto statement_1036;
    }
    statement_3301:
    n8 = i;
    switch (n8) {
      case 1: goto statement_4100;
      case 2: goto statement_4200;
      case 3: goto statement_4300;
      case 4: goto statement_4400;
      case 5: goto statement_4500;
      case 6: goto statement_4600;
      case 7: goto statement_4700;
      case 8: goto statement_4800;
      case 9: goto statement_4900;
      case 10: goto statement_5000;
      case 11: goto statement_5100;
      case 12: goto statement_5200;
      case 13: goto statement_5300;
      case 14: goto statement_5400;
      case 15: goto statement_5500;
      case 16: goto statement_5600;
      case 17: goto statement_5700;
      case 18: goto statement_5800;
      case 19: goto statement_5900;
      case 20: goto statement_6000;
      case 21: goto statement_6100;
      default: break;
    }
    statement_3306:
    if (texta6(1) == textay(i)) {
      goto statement_3294;
    }
  }
  statement_3319:
  write(lunit6,
    "(' ILLEGAL $-CARD.   STOP AT S.N. 3319 OF                  \"CIMAGE\" .')"
    "");
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  stoptp(cmn);
  //C               *****    REQUEST NO. 1.    "$ATTACH"      *****  *****  M27. 180
  statement_4100:
  text1 = "ATTACH";
  goto statement_4506;
  //C               *****    REQUEST NO. 2.    "$PUNCH"       *****  *****  M27. 183
  statement_4200:
  text1 = textax(2);
  statement_4206:
  n2 = lunit7;
  statement_4209:
  nfrfld = 1;
  freone(cmn, d11);
  n1 = d11;
  if (n1 <= 0) {
    n1 = n2;
  }
  if (n8 == 8) {
    goto statement_4817;
  }
  if (noutpr == 0) {
    write(lunit6, "('+COPY FILE',i4,'   TO ',a6,' .')"), n1, text1;
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29. 243
  cmn.io.rewind(n1);
  FEM_DO_SAFE(k, 1, intinf) {
    try {
      read(n1, format_3000), aupper;
    }
    catch (fem::read_end const&) {
      goto statement_4249;
    }
    //C     BECAUSE DEC FORTRAN DOES NOT HONOR THE CDC  "PUNCH"  STATEMENT    M27. 197
    //C     (TO DIRECTLY PUNCH CARDS), I WRITE TO UNIT 7 AS NEXT BEST         M27. 198
    //C     THING.  WSM.  JAN, 1980.                                          M27. 199
    if (n8 == 2) {
      write(lunit7, format_3000), aupper;
    }
    if (n8 == 3) {
      write(lunit6, "(20x,'RECORD',i5,' .  1',10a8)"), k, aupper;
    }
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29. 244
  statement_4249:
  cmn.io.rewind(n1);
  goto statement_1000;
  //C               *****    REQUEST NO. 3.    "$OUTPUT"      *****  *****  M27. 208
  statement_4300:
  text1 = textax(3);
  goto statement_4206;
  //C               *****    REQUEST NO. 4.    "$SAVE"        *****  *****  M27. 211
  statement_4400:
  text1 = "SAVED ";
  goto statement_4506;
  statement_4423:
  cmn.io.close(n7)
    .status("DELETE");
  cmn.io.open(n7, std::string(filen.begin(), filen.size()))
    .form("FORMATTED")
    .status("NEW");
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29. 245
  cmn.io.rewind(n6);
  FEM_DO_SAFE(k, 1, intinf) {
    try {
      read(n6, format_3000), aupper;
    }
    catch (fem::read_end const&) {
      goto statement_4436;
    }
    write(n7, format_3000), aupper;
  }
  statement_4436:
  cmn.io.close(n7)
    .status("SAVE");
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29. 246
  cmn.io.rewind(n6);
  goto statement_1000;
  //C               *****    REQUEST NO. 5.    "$SPY"         *****  *****  M36. 245
  statement_4500:
  text1 = "SPYING";
  //C REMEMBER $SPY FOR EOF TIME IN "SPYING"
  muntsv(2) = 2288;
  //C REMEMBER SPY INPUT CHANNEL TILL NOW
  muntsv(1) = munit5;
  //C SPECIAL I/O UNIT USED FOR $SPY CONNECTION
  munit5 = 17;
  //C FLAG SO "SPYING" KNOWS MUNIT5 OPENED TO DISK
  kfile5 = 1;
  statement_4506:
  n4 = 0;
  write(filen(1), "(25x)");
  FEM_DO_SAFE(k, kolbeg, 80) {
    if (texcol(k) == blank) {
      goto statement_4532;
    }
    if (texcol(k) == csepar) {
      goto statement_4536;
    }
    if (texcol(k) == " ") {
      goto statement_4536;
    }
    n4++;
    write(filen(n4), format_3041), texcol(k);
    statement_4532:;
  }
  k = 80;
  statement_4536:
  kolbeg = k + 1;
  nfrfld = 1;
  freone(cmn, d11);
  n7 = d11;
  if (n8 != 4) {
    goto statement_4557;
  }
  freone(cmn, d11);
  n6 = d11;
  statement_4557:
  if (n6 == 0) {
    n6 = lunit7;
  }
  //C $SPY USES THIS CHANNEL
  if (n8 == 5) {
    n7 = munit5;
  }
  if (n7 > 0) {
    goto statement_4570;
  }
  FEM_DO_SAFE(k, 1, 15) {
    if (lunsav(k) <= 0) {
      goto statement_4568;
    }
  }
  write(lunit6, "(/,10(' ERROR,'))");
  write(lunit6,
    "(5x,' ALL I/O CHANNELS OCCUPIED.  KILL RUN',"
    "' AT  S.N. 4566  OF  \"CIMAGE\" .',/,20i5)"),
    lunsav;
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  stoptp(cmn);
  statement_4568:
  n7 = k;
  statement_4570:
  if (noutpr == 0) {
    write(lunit6, "('+',a6,' FILE:',25a1,' UNIT =',i3)"), text1, filen, n7;
  }
  if (n8 == 4) {
    goto statement_4423;
  }
  if (n8 == 9) {
    goto statement_4907;
  }
  if (n8 == 11) {
    goto statement_5106;
  }
  if (n8 == 16) {
    goto statement_5608;
  }
  {
  cmn.io.close(n7);
  cmn.io.open(n7, std::string(filen.begin(), filen.size()))
    .form("FORMATTED")
    .status("OLD");
  cmn.io.rewind(n7);
  }
  //C PROCESS $SPY COMMAND FILE
  if (n8 == 5) {
    spying(cmn);
  }
  goto statement_1000;
  //C               *****    REQUEST NO. 6.    "$DISABLE"     *****  *****  M27. 266
  statement_4600:
  if (noutpr == 0) {
    write(lunit6, "('+BEGIN DATA TO BE IGNORED.')");
  }
  goto statement_1000;
  //C               *****    REQUEST NO. 7.    "$ENABLE"      *****  *****  M27. 271
  statement_4700:
  if (noutpr == 0) {
    write(lunit6, "('+END OF DATA TO BE IGNORED.')");
  }
  goto statement_1000;
  //C               *****    REQUEST NO. 8.    "$RETURN"      *****  *****  M27. 276
  statement_4800:
  n2 = lunit4;
  goto statement_4209;
  statement_4817:
  cmn.io.close(n1);
  if (noutpr == 0) {
    write(lunit6, "('+CLOSE FILE ON UNIT',i3,' .')"), n1;
  }
  if (n1 != lunit5) {
    goto statement_1000;
  }
  noutpr = 1;
  goto statement_1000;
  //C               *****    REQUEST NO. 9.    "$NEWFILE"     *****  *****  M27. 284
  statement_4900:
  text1 = "NEWFIL";
  n2 = lunit4;
  goto statement_4506;
statement_4907:
  {
  cmn.io.open(n7, std::string(filen.begin(), filen.size()))
    .form("UNFORMATTED")
    .status("NEW");
  }
  goto statement_1000;
  //C               *****    REQUEST NO. 10.   "NEW EPSILN"   *****  *****  M35. 255
  statement_5000:
  nfrfld = 1;
  d1 = epsiln;
  freone(cmn, epsiln);
  if (noutpr == 0) {
    write(lunit6, "('+ EPSILN CHANGE.  OLD, NEW =',2e11.2)"), d1, epsiln;
  }
  goto statement_1000;
  //C               *****    REQUEST NO. 11.   "DELETE"       *****  *****  M27. 298
  statement_5100:
  text1 = "DELETE";
  goto statement_4506;
statement_5106:
  {
  cmn.io.open(n7, std::string(filen.begin(), filen.size()))
    .status("OLD");
  cmn.io.close(n7)
    .status("DELETE");
  }
  goto statement_1000;
  //C               *****    REQUEST NO. 12.   "MONITOR"      *****  *****  M27. 304
  statement_5200:
  if (noutpr != 0) {
    goto statement_5219;
  }
  write(lunit6, format_3006), abuff(1), abuff(9), abuff(17), abuff(25), abuff(33)
    , abuff(41), abuff(49), abuff(57), abuff(65), abuff(73); //buff10;
  write(6, "('+CRT MONITOR.  CARD NUMBER =',i5)"), numdcd;
  statement_5219:
  goto statement_1000;
  //C               *****    REQUEST NO. 13.   "LISTOFF"      *****  *****  M27. 310
  statement_5300:
  if (noutpr != 0) {
    goto statement_5324;
  }
  write(lunit6, "('+TURN OFF INPUT LISTING AT CARD',i5)"), numdcd;
  noutpr = 1;
  statement_5324:
  goto statement_1000;
  //C               *****    REQUEST NO. 14.   "LISTON"       *****  *****  M27. 316
  statement_5400:
  write(lunit6, "(51x,'1$LISTON')");
  noutpr = 0;
  write(lunit6, "('+TURN ON INPUT LISTING AT CARD',i5)"), numdcd;
  goto statement_1000;
  //C               *****    REQUEST NO. 15.   "VINTAGE"      *****  *****  M28. 170
  statement_5500:
  nfrfld = 1;
  freone(cmn, d11);
  moldat = d11;
  if (noutpr == 0) {
    write(lunit6, "('+NEW MOLDAT =',i4,5x,'(DATA VINTAGE)')"), moldat;
  }
  goto statement_1000;
  //C               *****    REQUEST NO. 16.   "OLDFILE"      *****  *****  M28. 178
  statement_5600:
  text1 = "OLDFIL";
  n2 = cmn.lunit2;
  goto statement_4506;
  statement_5608:
  {
    cmn.io.close(n7);
    cmn.io.open(n7, std::string(filen.begin(), filen.size()))
      .form("UNFORMATTED")
      .status("OLD");
  }

  goto statement_1000;
  //C               *****    REQUEST NO. 17.   "STOP"         *****  *****  M28. 185
  statement_5700:
  write(lunit6, "('+STOP EXECUTION IMMEDIATELY, IN \"CIMAGE\".')");
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  stoptp(cmn);
  //C               *****    REQUEST NO. 18.   "WATCH5"       *****  *****  M28. 189
  statement_5800:
  nfrfld = 1;
  freone(cmn, d11);
  n12 = d11;
  n13 = n12;
  if (noutpr == 0) {
    write(lunit6, "('+PAINT INPUT DATA ON SCREEN.',i8)"), n12;
  }
  goto statement_1000;
  //C               *****    REQUEST NO. 19.   "COMMENT"      *****  *****  M31. 139
  statement_5900:
  n11++;
  if (n11 >= 2) {
    n11 = 0;
  }
  if (noutpr == 0) {
    write(lunit6, "('+TOGGLE COMMENT CARD DESTRUCTION FLAG.',i8)"), n11;
  }
  goto statement_1000;
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  statement_6000:
  stoptp(cmn);
  //C               *****    REQUEST NO. 21.   "UNITS"        *****  *****  VAX.  10
  statement_6100:
  nfrfld = 1;
  frefld(cmn, xopt);
  frefld(cmn, copt);
  if (noutpr == 0) {
    write(lunit6, "('+NEW  XOPT, COPT =',2e14.4)"), xopt, copt;
  }
  xunits = 1000.f;
  if (xopt > 0.0f) {
    xunits = cmn.twopi * xopt;
  }
  goto statement_1000;
  //C     ADDITIONAL KEY-WORD CODE GOES BELOW.                              VAX.  20
  statement_4000:
  write(lunit6,
    "(/,1x,85('='),/,' END OF FILE ENCOUNTED IN \"CIMAGE\" WHILE',"
    "' ATTEMPTING TO READ ANOTHER DATA CARD.   STOP.',/,1x,85('='))");
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  stoptp(cmn);
  //C     UNIQUE EXIT OF MODULE, POSSIBLY AFTER ECHOING CARD IMAGE:         M29. 506
  statement_7014:
  if (inecho == 0) {
    return;
  }
  // UNHANDLED: ENTRY cecho
  //C     "STATISTICS" OVER12 ECHOS LUNIT5 CARD IMAGES OF BASE CASE         M32. 162
  //C     (READ IN OVER13, OVER15, MAYBE SUBTS3, SUBR31) SO EACH            M32. 163
  //C     ENERGIZATION CAN RE-CIMAGE THIS LUNT12 DATA. 2ND AND LATER        M32. 164
  //C     ONE SKIPS OVERLAY 12-15 CARDS WITH LUNIT5 READ IN OVER12          M32. 165
  if (cmn.nchain <= 15) {
    ipntv(11)++;
  }
  write(inecho, format_3000), abuff(1), abuff(9), abuff(17), abuff(25), abuff(33)
    , abuff(41), abuff(49), abuff(57), abuff(65), abuff(73); //buff10;
  return;
  // UNHANDLED: ENTRY ibrinc
  ibr++;
  xoptbr(ibr) = xopt;
  coptbr(ibr) = copt;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void ibrinc(common& cmn) // for UNHANDLED: ENTRY ibrinc
{
  cmn.ibr++;
  cmn.xoptbr(cmn.ibr) = cmn.xopt;
  cmn.coptbr(cmn.ibr) = cmn.copt;
}



struct namea6_save
{
  int n17;
  fem::str<8> text2;

  namea6_save() :
    n17(fem::int0),
    text2(fem::char0)
  {}
};

void namea6(
  common& cmn,
  str_cref text1,
  int& n24) try
{
  FEM_CMN_SVE(namea6);
  common_write write(cmn);
  int& maxbus = cmn.maxbus;
  int& iprsup = cmn.iprsup;
  auto& texvec = cmn.texvec;
  //
  int& n17 = sve.n17;
  fem::str<8>& text2 = sve.text2;
  if (is_called_first_time) {
    n17 = 0;
    text2 = "UNUSED";
  }
  int j = fem::int0;
  auto& lunit6 = cmn.lunit6;
  //C     MODULE FOR MAINTAINANCE OF ALPHANUMERIC VECTOR TEXVEC OF          M38. 139
  //C     "LABCOM".  MAXBUS OF "BLKCOM" IS LAST USED CELL.  N24 CHOOSES     M38. 140
  //C     MODE OF USE:  0 WILL ADD TEXT1, POSITIVE WILL LOCATE IT,          M38. 141
  //C     AND NEGATIVE WILL DESTROY (REMOVE) IT.                            M38. 142
  //C     BURROUGHS: PRESERVE LOCAL VARIABLE BETWEEN MODULE CALLS:          M38. 146
  if (maxbus <= 0) {
    goto statement_3423;
  }
  FEM_DO_SAFE(j, 1, maxbus) {
    if (text1 == texvec(j)) {
      goto statement_3446;
    }
  }
  statement_3423:
  if (n24 != 0) {
    goto statement_3438;
  }
  if (n17 == 0) {
    goto statement_3434;
  }
  texvec(n17) = text1;
  n24 = n17;
  FEM_DO_SAFE(j, 1, maxbus) {
    if (texvec(j) != text2) {
      goto statement_3428;
    }
    n17 = j;
    goto statement_9000;
    statement_3428:;
  }
  n17 = 0;
  goto statement_9000;
  statement_3434:
  maxbus++;
  if (maxbus > cmn.lsize7) {
    FEM_STOP(0);
  }
  texvec(maxbus) = text1;
  n24 = maxbus;
  goto statement_9000;
  statement_3438:
  if (iprsup >= 1) {
    write(lunit6,
      "('  +++++  SEARCH OF EMTP NAME VECTOR BUS',' THROUGH CELL',i5,"
      "'   IN  \"NAMEA6\"  SHOWS NO MATCH FOR',/,'         \"',a6,"
      "'\".   RETURN -INTINF.',i10)"),
      maxbus, text1, n24;
  }
  n24 = -cmn.intinf;
  goto statement_9000;
  statement_3446:
  if (n24 < 0) {
    goto statement_3455;
  }
  n24 = j;
  goto statement_9000;
  statement_3455:
  texvec(j) = text2;
  n17 = j;
  statement_9000:
  if (iprsup >= 6) {
    write(lunit6,
      "(' EXIT \"NAMEA6\".  TEXT1, MAXBUS, N24, J =',2x,a6,3i10)"),
      text1, maxbus, n24, j;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

int locf(
  arr_cref<double> array) try
{
  int return_value = fem::int0;
  array(dimension(1));
  return_value = locint(array(1)) / 2;
  return return_value;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

//void
//move0( // using mover0
//  arr_ref<int> intb,
//  int const& n)
//{
//  intb(dimension(1));
//  //C)    SUBROUTINE  MOVE0  IS IDENTICAL TO  THE BLOCK-ZEROING ROUTINE     M15. 317
//  //C)    MOVER0  EXCEPT THAT  MOVE0  IS FOR INTEGER ARRAYS, WHILE  MOVER0  M15. 318
//  //C)    IS FOR FLOATING-POINT ARRAYS.   THERE IS A DIFFERENCE, ON         M15. 319
//  //C)    MACHINES LIKE IBM, WHERE INTEGER WORDS MAY BE SHORTER THAN        M15. 320
//  //C)    FLOATING-POINT WORDS.                                             M15. 321
//  int i = fem::int0;
//  FEM_DO_SAFE(i, 1, n) {
//    intb(i) = 0;
//  }
//}

struct tacs1a_save
{
  arr<fem::str<8> > alnrcl;
  fem::str<8> ch9;
  fem::str<8> cha;
  fem::str<8> chd;
  fem::str<8> chdolr;
  fem::str<8> che;
  fem::str<8> chg;
  fem::str<8> chl;
  fem::str<8> chn;
  fem::str<8> cho;
  fem::str<8> chq;
  fem::str<8> chr;
  fem::str<8> cht;
  fem::str<8> comma;
  fem::str<8> eqlsgn;
  arr<fem::str<8> > opname;
  arr<fem::str<8> > sepch;
  fem::str<8> sminus;
  fem::str<8> smultp;
  fem::str<8> splus;
  arr<fem::str<8> > supfn;
  arr<fem::str<8> > supop;
  fem::str<8> text1;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;

  tacs1a_save() :
    alnrcl(dimension(10), fem::fill0),
    ch9(fem::char0),
    cha(fem::char0),
    chd(fem::char0),
    chdolr(fem::char0),
    che(fem::char0),
    chg(fem::char0),
    chl(fem::char0),
    chn(fem::char0),
    cho(fem::char0),
    chq(fem::char0),
    chr(fem::char0),
    cht(fem::char0),
    comma(fem::char0),
    eqlsgn(fem::char0),
    opname(dimension(18), fem::fill0),
    sepch(dimension(8), fem::fill0),
    sminus(fem::char0),
    smultp(fem::char0),
    splus(fem::char0),
    supfn(dimension(35), fem::fill0),
    supop(dimension(6), fem::fill0),
    text1(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0)
  {}
};

void tacs1a(
  common& cmn) try
{
  FEM_CMN_SVE(tacs1a);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& blank = cmn.blank;
  fem::str<8>& csepar = cmn.csepar;
  auto& texcol = cmn.texcol;
  const auto& texta6 = cmn.texta6;
  const auto& abuff = cmn.abuff;
  double& deltat = cmn.deltat;
  auto& voltbc = cmn.voltbc;
  auto& flstat = cmn.flstat;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  int& noutpr = cmn.noutpr;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  auto& sptacs = cmn.sptacs;

  auto& alnrcl = sve.alnrcl;
  fem::str<8>& ch9 = sve.ch9;
  fem::str<8>& cha = sve.cha;
  fem::str<8>& chd = sve.chd;
  fem::str<8>& chdolr = sve.chdolr;
  fem::str<8>& che = sve.che;
  fem::str<8>& chg = sve.chg;
  fem::str<8>& chl = sve.chl;
  fem::str<8>& chn = sve.chn;
  fem::str<8>& cho = sve.cho;
  fem::str<8>& chq = sve.chq;
  fem::str<8>& chr = sve.chr;
  fem::str<8>& cht = sve.cht;
  fem::str<8>& comma = sve.comma;
  fem::str<8>& eqlsgn = sve.eqlsgn;
  auto& opname = sve.opname;
  auto& sepch = sve.sepch;
  fem::str<8>& sminus = sve.sminus;
  fem::str<8>& smultp = sve.smultp;
  fem::str<8>& splus = sve.splus;
  auto& supfn = sve.supfn;
  auto& supop = sve.supop;
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text4 = sve.text4;
  if (is_called_first_time) {
    alnrcl(1) = "1     ";
    alnrcl(2) = "2     ";
    alnrcl(3) = "3     ";
    alnrcl(4) = "4     ";
    alnrcl(5) = "5     ";
    alnrcl(6) = "6     ";
    alnrcl(7) = "7     ";
    alnrcl(8) = "8     ";
    alnrcl(9) = "9     ";
    alnrcl(10) = "0     ";
    sepch(1) = "(     ";
    sepch(2) = ")     ";
    sepch(3) = "+     ";
    sepch(4) = "-     ";
    sepch(5) = "/     ";
    sepch(6) = "*     ";
    sepch(7) = ".     ";
    sepch(8) = "**    ";
    opname(1) = "(     ";
    opname(2) = ".NOT. ";
    opname(3) = ".OR.  ";
    opname(4) = ".ORNOT";
    opname(5) = ".AND. ";
    opname(6) = ".ANDNT";
    opname(7) = ")     ";
    opname(8) = ".NE.  ";
    opname(9) = ".EQ.  ";
    opname(10) = ".LT.  ";
    opname(11) = ".LE.  ";
    opname(12) = ".GE.  ";
    opname(13) = ".GT.  ";
    opname(14) = "*     ";
    opname(15) = "/     ";
    opname(16) = "**    ";
    opname(17) = "+     ";
    opname(18) = "-     ";
    eqlsgn = "=     ";
    chdolr = "$     ";
    ch9 = "9     ";
    che = "E";
    chd = "D";
    comma = ",";
    cha = "A";
    chn = "N";
    cho = "O";
    cht = "T";
    chq = "Q";
    chl = "L";
    chg = "G";
    chr = "R";
    supfn(1) = "     ";
    supfn(2) = "AND. ";
    supfn(3) = "OR.  ";
    supfn(4) = "NOT. ";
    supfn(5) = "NAND.";
    supfn(6) = "NOR. ";
    supfn(7) = "     ";
    supfn(8) = "     ";
    supfn(9) = "     ";
    supfn(10) = "     ";
    supfn(11) = "     ";
    supfn(12) = "SIN  ";
    supfn(13) = "COS  ";
    supfn(14) = "TAN  ";
    supfn(15) = "COTAN";
    supfn(16) = "SINH ";
    supfn(17) = "COSH ";
    supfn(18) = "TANH ";
    supfn(19) = "ASIN ";
    supfn(20) = "ACOS ";
    supfn(21) = "ATAN ";
    supfn(22) = "EXP  ";
    supfn(23) = "LOG  ";
    supfn(24) = "LOG10";
    supfn(25) = "SQRT ";
    supfn(26) = "ABS  ";
    supfn(27) = "TRUNC";
    supfn(28) = "MINUS";
    supfn(29) = "INVRS";
    supfn(30) = "RAD  ";
    supfn(31) = "DEG  ";
    supfn(32) = "SEQ6 ";
    supfn(33) = "SIGN ";
    supfn(34) = "NOT  ";
    supfn(35) = "RAN  ";
    supop(1) = "+    ";
    supop(2) = "-    ";
    supop(3) = "*    ";
    supop(4) = "/    ";
    supop(5) = "0    ";
    supop(6) = ".    ";
    text4 = "COUNTR";
    sve.text5 = "INPUT ";
    sve.text6 = "OUTPUT";
    sve.text7 = "INSIDE";
    splus = "+";
    sminus = "-";
    smultp = "*";
    text1 = "VALUE ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  //int kspvar = fem::int0;
  //int kprsup = fem::int0;
  //int kivarb = fem::int0;
  //int kksus = fem::int0;
  //int kalksu = fem::int0;
  //int kinsup = fem::int0;
  //int nsu = fem::int0;
  //int nsup = fem::int0;
  //int karg = fem::int0;
  //int kpar = fem::int0;
  //int nsudv = fem::int0;
  int kjsup = fem::int0;
  int kksup = fem::int0;
  int n = fem::int0;
  fem::str<8> alnode = fem::char0;
  int m = fem::int0;
  int ndx1 = fem::int0;
  int n23 = fem::int0;
  fem::str<8> alnm1 = fem::char0;
  int iargel = fem::int0;
  int ilst = fem::int0;
  int icurch = fem::int0;
  int isrchl = fem::int0;
  int iflpnt = fem::int0;
  int ilglph = fem::int0;
  int ilgnum = fem::int0;
  int ilgcl = fem::int0;
  int itmpbf = fem::int0;
  int ifstch = fem::int0;
  fem::str<8> curch = fem::char0;
  fem::str<8> csprch = fem::char0;
  fem::str<8> contch = fem::char0;
  int ifree = fem::int0;
  arr_1d<100, int> iel(fem::fill0);
  fem::str<8> curch1 = fem::char0;
  int k1 = fem::int0;
  int j = fem::int0;
  fem::str<8> chdum1 = fem::char0;
  fem::str<8> chdum2 = fem::char0;
  int ikill1 = fem::int0;
  int ikill2 = fem::int0;
  arr_1d<20, fem::str<8> > atmpbf(fem::fill0);
  arr_1d<80, fem::str<8> > btmpbf(fem::fill0);
  int i1 = fem::int0;
  int k = fem::int0;
  arr_1d<100, double> argel(fem::fill0);
  arr_1d<100, fem::str<8> > el(fem::fill0);
  double d1 = fem::double0;
  int ifst = fem::int0;
  int ilst1 = fem::int0;
  int i2 = fem::int0;
  int i = fem::int0;
  int k2 = fem::int0;
  fem::str<8> alnm2 = fem::char0;
  int k3 = fem::int0;
  int i3 = fem::int0;
  int i4 = fem::int0;
  int k4 = fem::int0;
  double prx = fem::double0;
  arr_1d<5, fem::str<8> > alph(fem::fill0);
  arr_1d<13, fem::str<8> > dumj(fem::fill0);
  double pru = fem::double0;
  fem::str<8> text2 = fem::char0;
  arr_1d<3, double> dum(fem::fill0);
  int n1 = fem::int0;
  int mpar = fem::int0;
  int moon = fem::int0;
  double d9 = fem::double0;
  double d10 = fem::double0;
  int n6 = fem::int0;
  int ndx6 = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;

  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;
  auto& kspvar = isptacs(6);
  auto& kprsup = isptacs(9);
  auto& kivarb = isptacs(10);
  auto& kksus =  isptacs(21);
  auto& kalksu = isptacs(22);
  auto& kinsup = isptacs(23);

  auto& nsu = lstat(53);
  auto& nsup = lstat(55);
  auto& karg = lstat(56);
  auto& kpar = lstat(57);
  auto& nsudv = lstat(60);

  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE TACS1A.\"')");
  }
  kjsup = kinsup + lstat(65);
  kksup = kjsup + lstat(65);
  read(abuff, "(i2,a6,i2)"), n, alnode, m;
  nsup++;
  lstat(55) = nsup;
  if (nsup <= lstat(65)) {
    goto statement_2515;
  }
  kill = 122;
  lstat(19) = 2515;
  lstat(16) = lstat(65);
  lstat(17) = 5;
  goto statement_9000;
  statement_2515:
  ndx1 = kspvar + nsup;
  n23 = 0;
  namea6(cmn, alnode, n23);
  ivarb(ndx1) = n23;
  ivarb(kinsup + nsup) = 0;
  if (m != 0) {
    goto statement_10700;
  }
  read(abuff, "(10x,a1)"), alnm1;
  if (alnm1 != eqlsgn) {
    goto statement_12517;
  }
  if (noutpr == 0) {
    write(kunit6, "('+TACS SUPPLEMENTAL FORTRAN EXPRESSION ')");
  }
  //C     ***  READ  THIS  ARBITRARY  LOGICAL/ALGEBRAIC                     M28.2001
  //C     ***   FREE-FORMAT  FORTRAN  EXPRESSION                            M28.2002
  //C     ***  * * * * * * * * * * * * * * * * *   ***                      M28.2003
  //C                                                                       M28.2004
  iargel = 0;
  ilst = 0;
  icurch = 11;
  isrchl = 1;
  iflpnt = 0;
  ilglph = 0;
  ilgnum = 0;
  ilgcl = 0;
  itmpbf = 0;
  ifstch = 12;
  curch = chdolr;
  csprch = csepar;
  csepar = comma;
  contch = cmn.chcont;
  if (contch == ch9) {
    contch = chdolr;
  }
  ifree = 100;
  move0(iel, ifree);
  //C                                                                       M28.2020
  //C    :::  INTERPRET NEXT CHARACTER   :::                                M28.2021
  statement_50010:
  icurch++;
  if (icurch > 80) {
    goto statement_50030;
  }
  curch1 = curch;
  curch = texcol(icurch);
  if (curch == blank) {
    goto statement_50035;
  }
  if (curch == contch) {
    goto statement_50040;
  }
  k1 = 0;
  FEM_DO_SAFE(j, 1, 7) {
    if (curch == sepch(j)) {
      k1 = j;
    }
  }
  if (isrchl == 1) {
    goto statement_50065;
  }
  if (ilgcl == 1 && iflpnt == 2) {
    goto statement_50120;
  }
  if (k1 == 0) {
    goto statement_50020;
  }
  if (ilgnum == 0) {
    goto statement_50016;
  }
  if (k1 != 3 && k1 != 4) {
    goto statement_50016;
  }
  if (curch1 == che || curch1 == chd) {
    goto statement_50020;
  }
  statement_50016:
  if (k1 != 6 || curch1 != sepch(6)) {
    goto statement_50017;
  }
  k1 = 8;
  goto statement_50165;
  statement_50017:
  if (k1 >= 1 && k1 <= 6) {
    goto statement_50120;
  }
  //C                                                                       M28.2042
  //C     :::  THIS CHAR IS '.' NOT FIRST  :::                              M28.2043
  iflpnt++;
  if (ilgcl == 1) {
    goto statement_50020;
  }
  //C                                                                       M28.2046
  //C     :::  THIS  '.'  FOLLOWS ALPH OR NUM  :::                          M28.2047
  goto statement_50021;
  statement_50019:
  if (ilgcl == 1) {
    goto statement_50120;
  }
  //C                                                                       M28.2050
  //C     :::  THIS CHAR NOT FIRST NOT SEPAR  :::                           M28.2051
  statement_50020:
  if (ilglph > 0) {
    ilglph++;
  }
  if (ilgnum > 0) {
    ilgnum++;
  }
  goto statement_50010;
  //C                                                                       M28.2055
  //C     :::  PREREAD  4  CHAR  :::                                        M28.2056
  statement_50021:
  if (icurch > 77) {
    goto statement_50024;
  }
  curch1 = texcol(icurch + 1);
  chdum1 = texcol(icurch + 2);
  chdum2 = texcol(icurch + 3);
  if (chdum2 == sepch(7)) {
    goto statement_50022;
  }
  if (icurch > 76) {
    goto statement_50024;
  }
  if (texcol(icurch + 4) != sepch(7)) {
    goto statement_50024;
  }
  if (curch1 == chn && chdum1 == cho && chdum2 == cht) {
    goto statement_50023;
  }
  if (curch1 == cha && chdum1 == chn && chdum2 == chd) {
    goto statement_50023;
  }
  goto statement_50024;
  statement_50022:
  if (curch1 == cho && chdum1 == chr) {
    goto statement_50023;
  }
  if (curch1 == chn && chdum1 == che) {
    goto statement_50023;
  }
  if (curch1 == che && chdum1 == chq) {
    goto statement_50023;
  }
  if (chdum1 != cht && chdum1 != che) {
    goto statement_50024;
  }
  if (curch1 != chl && curch1 != chg) {
    goto statement_50024;
  }
  statement_50023:
  ilgcl = 1;
  statement_50024:
  if (ilglph + ilgnum > 0) {
    goto statement_50019;
  }
  if (ilgcl == 0) {
    goto statement_50025;
  }
  ilglph = 1;
  goto statement_50010;
  statement_50025:
  FEM_DO_SAFE(j, 1, 10) {
    if (curch1 == alnrcl(j)) {
      goto statement_50028;
    }
  }
  statement_50027:
  ikill1 = 12;
  ikill2 = 50026;
  lstat(16) = icurch;
  goto statement_50900;
  statement_50028:
  ilgnum = 1;
  goto statement_50010;
  //C                                                                       M28.2088
  //C    :::  HIT COL. 81  :::                                              M28.2089
  statement_50030:
  if (isrchl == 1) {
    goto statement_50185;
  }
  isrchl = -1;
  goto statement_50120;
  //C                                                                       M28.2093
  //C    :::  HIT A BLANK  :::                                              M28.2094
  statement_50035:
  if (isrchl == 1) {
    goto statement_50010;
  }
  if (iflpnt == 1 && curch1 == sepch(7) && ilgnum == 0) {
    goto statement_50027;
  }
  isrchl = 1;
  goto statement_50120;
  //C                                                                       M28.2100
  //C    :::  HIT CONTINUATION-CHARACTER  :::                               M28.2101
  statement_50040:
  if (isrchl == 1) {
    goto statement_50050;
  }
  icurch = icurch - 1;
  if (icurch < ifstch) {
    goto statement_50050;
  }
  FEM_DO_SAFE(j, ifstch, icurch) {
    itmpbf++;
    atmpbf(itmpbf) = texcol(j);
  }
  statement_50050:
  icurch = 0;
  ifstch = 1;
  cimage(cmn);
  goto statement_50010;
  //C                                                                       M28.2112
  //C    :::  FIRST CHARACTER OF A NEW WORD  :::                            M28.2113
  statement_50065:
  isrchl = 0;
  ifstch = icurch;
  if (k1 != 6) {
    goto statement_50070;
  }
  if (icurch == 80) {
    goto statement_50070;
  }
  if (texcol(icurch + 1) == sepch(6)) {
    goto statement_50010;
  }
  statement_50070:
  if (k1 != 7) {
    goto statement_50075;
  }
  iflpnt = 1;
  goto statement_50021;
  statement_50075:
  if (k1 >= 1 && k1 <= 6) {
    goto statement_50165;
  }
  //C                                                                       M28.2123
  //C    :::  FIRST CHAR. OF NUMER.  OR  ALPHANUM.  :::                     M28.2124
  FEM_DO_SAFE(j, 1, 10) {
    if (curch == alnrcl(j)) {
      goto statement_50090;
    }
  }
  ilglph = 1;
  goto statement_50010;
  statement_50090:
  ilgnum = 1;
  goto statement_50010;
  //C                                                                       M28.2132
  //C    :::  CURRENT WORD IS COMPLETE  :::                                 M28.2133
  statement_50120:
  curch1 = texcol(icurch);
  texcol(icurch) = comma;
  if (ilgnum <= 20) {
    goto statement_50125;
  }
  ikill1 = 10;
  ikill2 = 50120;
  lstat(16) = icurch - 1;
  goto statement_50900;
  statement_50125:
  if (ilglph <= 6) {
    goto statement_50130;
  }
  ikill1 = 11;
  ikill2 = 50125;
  lstat(16) = icurch - 1;
  goto statement_50900;
  statement_50130:
  if (itmpbf == 0) {
    goto statement_50150;
  }
  //C     : WORD IS SPREAD OVER MORE THAN ONE CARD                          M28.2147
  FEM_DO_SAFE(j, 1, 80) {
    btmpbf(j) = texcol(j);
  }
  FEM_DO_SAFE(j, 1, itmpbf) {
    texcol(j) = atmpbf(j);
  }
  i1 = ilgnum + ilglph + 1;
  itmpbf++;
  FEM_DO_SAFE(j, itmpbf, i1) {
    k = j - itmpbf + 1;
    texcol(j) = btmpbf(k);
  }
  statement_50150:
  if (ilgnum > 0) {
    goto statement_50155;
  }
  if (ilglph > 0) {
    goto statement_50160;
  }
  //C                                                                       M28.2159
  //C    :::  STORING NUMERICAL WORD  :::                                   M28.2160
  statement_50155:
  if (iflpnt <= 1) {
    goto statement_50156;
  }
  ikill1 = 13;
  ikill2 = 50155;
  lstat(16) = icurch - 1;
  statement_50156:
  nfrfld = 1;
  nright = 0;
  kolbeg = ifstch;
  iargel++;
  frefld(cmn, argel(iargel));
  ilst++;
  iel(ilst) = -ilst - 1;
  //C!EL( ILST)  = IARGEL
  write(el(ilst), star), iargel;
  ilgnum = 0;
  iflpnt = 0;
  goto statement_50170;
  //C                                                                       M28.2176
  //C    :::  STORING ALPHANUMERIC WORD  :::                                M28.2177
  statement_50160:
  nfrfld = 1;
  nright = -1;
  kolbeg = ifstch;
  freone(cmn, d1);
  ilst++;
  iel(ilst) = ilst + 1;
  el(ilst) = texta6(1);
  ilglph = 0;
  ilgcl = 0;
  iflpnt = 0;
  goto statement_50170;
  //C                                                                       M28.2189
  //C     :::  STORING  OPERATOR  :::                                       M28.2190
  statement_50165:
  isrchl = 1;
  ilst++;
  iel(ilst) = ilst + 1;
  el(ilst) = sepch(k1);
  goto statement_50010;
  //C                                                                       M28.2196
  //C    :::  RESTORE CURRENT LINE  :::                                     M28.2197
  statement_50170:
  if (itmpbf == 0) {
    goto statement_50180;
  }
  itmpbf = 0;
  FEM_DO_SAFE(j, 1, 80) {
    texcol(j) = btmpbf(j);
  }
  statement_50180:
  texcol(icurch) = curch1;
  switch (fem::if_arithmetic(isrchl)) {
    case -1: goto statement_50185;
    case  0: goto statement_50065;
    default: goto statement_50010;
  }
  //C                                                                       M28.2204
  //C    :::  OUT : WHOLE EXPRESSION HAS BEEN INTERPRETED  :::              M28.2205
  statement_50185:
  if (ilst != 0) {
    goto statement_50190;
  }
  ikill1 = 2;
  ikill2 = 50185;
  goto statement_50900;
  statement_50190:
  if (ilst <= 100) {
    goto statement_50195;
  }
  ikill1 = 8;
  ikill2 = 50190;
  goto statement_50900;
  statement_50195:
  j = iel(ilst);
  iel(ilst) = 999;
  if (j < 0) {
    iel(ilst) = -999;
  }
  csepar = csprch;
  //C                                                                       M28.2218
  //C     ***  CHECK  VALIDITY  AND  PRE-PROCESS                            M28.2219
  //C     ***   THIS  FORTRAN  EXPRESSION                                   M28.2220
  //C     ***   * * * * * * * * * * * * * * * * *                           M28.2221
  //C                                                                       M28.2222
  ifst = 1;
  ilst1 = ilst;
  //C                                                                       M28.2226
  //C    :::  CHECK BRACKETS  :::                                           M28.2227
  statement_50200:
  i1 = 0;
  k1 = 0;
  i2 = 0;
  i = ifst;
  statement_50201:
  alnm1 = el(i);
  if (alnm1 == opname(1)) {
    goto statement_50215;
  }
  if (alnm1 != opname(7)) {
    goto statement_50220;
  }
  i1 = i1 - 1;
  switch (fem::if_arithmetic(i1)) {
    case -1: goto statement_50205;
    case  0: goto statement_50210;
    default: goto statement_50220;
  }
  statement_50205:
  ikill1 = 3;
  ikill2 = 50205;
  goto statement_50900;
  statement_50210:
  if (k1 == 1) {
    goto statement_50220;
  }
  k1 = 1;
  if (i2 == 0 || i < ilst) {
    goto statement_50220;
  }
  el(ifst) = blank;
  el(ilst) = blank;
  iel(ifst) = 0;
  iel(ilst) = 0;
  ifst++;
  ilst = ilst - 1;
  ilst1 = ilst;
  j = iel(ilst);
  iel(ilst) = 999;
  if (j < 0) {
    iel(ilst) = -999;
  }
  if (ifst <= ilst) {
    goto statement_50200;
  }
  ikill1 = 2;
  ikill2 = 50210;
  goto statement_50900;
  statement_50215:
  if (i == ifst) {
    i2 = 1;
  }
  i1++;
  statement_50220:
  i++;
  if (i <= ilst) {
    goto statement_50201;
  }
  if (i1 <= 0) {
    goto statement_50225;
  }
  ikill1 = 1;
  ikill2 = 50220;
  goto statement_50900;
  //C                                                                       M28.2264
  //C    :::  CHECK ALL PAIRS OF ADJACENT ELEMENTS  :::                     M28.2265
  statement_50225:
  i = ifst - 1;
  statement_50230:
  i++;
  if (i > ilst) {
    goto statement_50485;
  }
  statement_50235:
  k1 = 0;
  alnm1 = el(i);
  if (alnm1 == blank) {
    goto statement_50230;
  }
  FEM_DO_SAFE(j, 1, 18) {
    if (alnm1 == opname(j)) {
      k1 = j;
    }
  }
  k2 = 0;
  k = i;
  statement_50245:
  k++;
  if (k > ilst) {
    goto statement_50255;
  }
  alnm2 = el(k);
  if (alnm2 == blank) {
    goto statement_50245;
  }
  FEM_DO_SAFE(j, 1, 18) {
    if (alnm2 == opname(j)) {
      k2 = j;
    }
  }
  statement_50255:
  if (k1 != 0) {
    goto statement_50265;
  }
  k3 = 0;
  FEM_DO_SAFE(j, 12, 35) {
    if (alnm1 == supfn(j)) {
      k3 = j;
    }
  }
  statement_50265:
  if (i == ilst) {
    goto statement_50470;
  }
  if (k1 == 0) {
    goto statement_50380;
  }
  if (k2 < 2) {
    goto statement_50270;
  }
  if (k1 >= 14) {
    goto statement_50300;
  }
  statement_50270:
  if (k2 < 2 || k2 > 16) {
    goto statement_50275;
  }
  if (k1 == 3 || k1 == 5 || k1 == 7) {
    goto statement_50275;
  }
  if (k1 >= 2 && k1 <= 13) {
    goto statement_50300;
  }
  statement_50275:
  if (k2 < 3 || k2 > 16) {
    goto statement_50280;
  }
  if (k1 == 3 || k1 == 5) {
    goto statement_50300;
  }
  statement_50280:
  if (k2 < 5 || k2 > 16) {
    goto statement_50285;
  }
  if (k2 == 7) {
    goto statement_50285;
  }
  if (k1 == 1) {
    goto statement_50300;
  }
  statement_50285:
  if (k2 > 2) {
    goto statement_50290;
  }
  if (k1 == 7) {
    goto statement_50300;
  }
  statement_50290:
  if (i != ifst) {
    goto statement_50295;
  }
  if (k1 >= 5 && k1 <= 16) {
    goto statement_50315;
  }
  statement_50295:
  goto statement_50320;
  statement_50300:
  ikill1 = 5;
  ikill2 = 50300;
  bus2 = alnm1;
  bus3 = alnm2;
  goto statement_50900;
  statement_50315:
  ikill1 = 6;
  ikill2 = 50315;
  bus2 = alnm1;
  goto statement_50900;
  statement_50320:
  if (k1 != 1 || k2 != 7) {
    goto statement_50355;
  }
  el(i) = blank;
  el(k) = blank;
  if (i == ifst) {
    goto statement_50330;
  }
  statement_50325:
  i = i - 1;
  if (el(i) == blank) {
    goto statement_50325;
  }
  statement_50330:
  if (k == ilst) {
    goto statement_50340;
  }
  statement_50335:
  k++;
  if (el(k) == blank) {
    goto statement_50335;
  }
  statement_50340:
  if (i != ifst) {
    goto statement_50345;
  }
  ifst = k;
  goto statement_50200;
  statement_50345:
  if (k != ilst) {
    goto statement_50350;
  }
  ilst = i;
  ilst1 = ilst;
  j = iel(ilst);
  iel(ilst) = 999;
  if (j < 0) {
    iel(ilst) = -999;
  }
  if (ifst <= ilst) {
    goto statement_50200;
  }
  ikill1 = 2;
  ikill2 = 50345;
  goto statement_50900;
  statement_50350:
  j = iel(i);
  iel(i) = k;
  if (j < 0) {
    iel(i) = -k;
  }
  goto statement_50235;
  statement_50355:
  if (k2 != 2) {
    goto statement_50380;
  }
  if (k1 != 3) {
    goto statement_50360;
  }
  el(k) = opname(4);
  goto statement_50365;
  statement_50360:
  if (k1 != 5) {
    goto statement_50380;
  }
  el(k) = opname(6);
  statement_50365:
  el(i) = blank;
  if (i != ifst) {
    goto statement_50370;
  }
  ifst = k;
  goto statement_50375;
  statement_50370:
  i = i - 1;
  if (el(i) == blank) {
    goto statement_50370;
  }
  i1 = iel(i);
  iel(i) = k;
  if (i1 < 0) {
    iel(i) = -k;
  }
  statement_50375:
  i = k;
  goto statement_50235;
  statement_50380:
  if (k1 == 2) {
    el(i) = opname(4);
  }
  if (k1 != 0) {
    goto statement_50400;
  }
  if (k2 != 0 && k2 != 2) {
    goto statement_50385;
  }
  ikill1 = 5;
  ikill2 = 50380;
  bus2 = alnm1;
  bus3 = alnm2;
  goto statement_50900;
  statement_50385:
  if (k3 != 0 || k2 != 1) {
    goto statement_50390;
  }
  ikill1 = 5;
  ikill2 = 50385;
  bus2 = alnm1;
  bus3 = alnm2;
  goto statement_50900;
  statement_50390:
  if (k3 == 0 || k2 == 1) {
    goto statement_50400;
  }
  ikill1 = 7;
  ikill2 = 50390;
  bus2 = alnm1;
  goto statement_50900;
  //C    :::  INSERT  '+'  OR  '.OR.'  WHERE NEEDED  :::                    M28.2380
  statement_50400:
  i1 = 0;
  i2 = 0;
  i3 = k;
  i4 = 0;
  if (k1 != 0 || i != ifst) {
    goto statement_50405;
  }
  if (k3 == 0) {
    goto statement_50445;
  }
  i1 = 1;
  goto statement_50435;
  statement_50405:
  if (k1 != 1) {
    goto statement_50230;
  }
  if (i != ifst) {
    goto statement_50410;
  }
  i1 = 1;
  i4 = 1;
  k = i;
  goto statement_50435;
  statement_50410:
  if (k2 >= 17) {
    goto statement_50230;
  }
  if (k2 == 2 || k2 == 3) {
    goto statement_50230;
  }
  if (k2 == 0) {
    goto statement_50420;
  }
  i1 = 1;
  goto statement_50435;
  statement_50420:
  k4 = 0;
  FEM_DO_SAFE(j, 12, 35) {
    if (alnm2 == supfn(j)) {
      k4 = j;
    }
  }
  if (k4 != 0) {
    goto statement_50435;
  }
  statement_50430:
  k++;
  if (el(k) == blank) {
    goto statement_50430;
  }
  goto statement_50445;
  statement_50435:
  k++;
  if (k <= ilst) {
    goto statement_50440;
  }
  if (k1 == 0 && k3 != 0) {
    goto statement_50455;
  }
  ikill1 = 1;
  ikill2 = 50435;
  goto statement_50900;
  statement_50440:
  if (el(k) == opname(1)) {
    i1++;
  }
  if (i1 == 0) {
    goto statement_50445;
  }
  if (el(k) == opname(7)) {
    i1 = i1 - 1;
  }
  goto statement_50435;
  statement_50445:
  if (el(k) != opname(3) && el(k) != opname(4) && el(k) != opname(
      5) && el(k) != opname(6)) {
    goto statement_50450;
  }
  i2 = 1;
  statement_50450:
  if (i == ifst) {
    goto statement_50455;
  }
  j = iel(i);
  iel(i) = ifree;
  if (j < 0) {
    iel(i) = -ifree;
  }
  iel(ifree) = i3;
  goto statement_50460;
  statement_50455:
  ifst = ifree;
  iel(ifree) = i;
  statement_50460:
  if (ifree > ilst1) {
    goto statement_50465;
  }
  ikill1 = 8;
  ikill2 = 50460;
  goto statement_50900;
  statement_50465:
  el(ifree) = opname(17);
  if (i2 == 1) {
    el(ifree) = opname(3);
  }
  ifree = ifree - 1;
  if (i4 == 1) {
    goto statement_50235;
  }
  goto statement_50230;
  statement_50470:
  if (k1 == 0 || k1 == 7) {
    goto statement_50475;
  }
  ikill1 = 4;
  ikill2 = 50470;
  bus2 = alnm1;
  goto statement_50900;
  statement_50475:
  if (k1 != 0) {
    goto statement_50485;
  }
  if (k3 == 0) {
    goto statement_50480;
  }
  ikill1 = 7;
  ikill2 = 50475;
  bus2 = alnm1;
  goto statement_50900;
  statement_50480:
  if (i != ifst) {
    goto statement_50485;
  }
  i2 = 0;
  goto statement_50455;
  //C                                                                       M28.2453
  //C    :::  CHANGE  ".NN.EXPRESSION"  INTO  ".NN.+EXPRESSION)"            M28.2454
  statement_50485:
  i = ifst;
  statement_50490:
  i = iel(i);
  if (i < 0) {
    i = -i;
  }
  if (i == 999) {
    goto statement_50535;
  }
  k1 = 0;
  alnm1 = el(i);
  FEM_DO_SAFE(j, 8, 13) {
    if (alnm1 == opname(j)) {
      k1 = j;
    }
  }
  if (k1 == 0) {
    goto statement_50490;
  }
  k = i;
  i1 = 0;
  i3 = 0;
  statement_50500:
  i2 = k;
  k = iel(k);
  if (k < 0) {
    k = -k;
  }
  if (k == 999) {
    goto statement_50515;
  }
  k2 = 0;
  alnm2 = el(k);
  FEM_DO_SAFE(j, 1, 7) {
    if (alnm2 == opname(j)) {
      k2 = j;
    }
  }
  if (i3 != 0) {
    goto statement_50510;
  }
  i3 = 1;
  if (k2 > 2) {
    goto statement_50510;
  }
  el(ifree) = opname(17);
  goto statement_50525;
  statement_50510:
  if (k2 == 0) {
    goto statement_50500;
  }
  if (k2 == 1) {
    i1++;
  }
  if (i1 == 0) {
    goto statement_50520;
  }
  if (k2 == 7) {
    i1 = i1 - 1;
  }
  goto statement_50500;
  statement_50515:
  ilst = ifree;
  statement_50520:
  el(ifree) = opname(7);
  statement_50525:
  j = iel(i2);
  iel(i2) = ifree;
  if (j < 0) {
    iel(i2) = -ifree;
  }
  iel(ifree) = k;
  if (ifree > ilst1) {
    goto statement_50530;
  }
  ikill1 = 8;
  ikill2 = 50525;
  goto statement_50900;
  statement_50530:
  ifree = ifree - 1;
  if (i2 == i) {
    goto statement_50500;
  }
  goto statement_50490;
  //C                                                                       M28.2500
  //C    :::  CHANGE  "EXPRESSION.NN."  INTO  "(EXPRESSION.NN."             M28.2501
  statement_50535:
  j = ilst;
  goto statement_50550;
  statement_50540:
  FEM_DO_SAFE(j, 1, 100) {
    if (iel(j) == i) {
      goto statement_50550;
    }
    if (iel(j) ==  - i) {
      goto statement_50550;
    }
  }
  statement_50550:
  if (j == ifst) {
    goto statement_50600;
  }
  i = j;
  k1 = 0;
  alnm1 = el(i);
  FEM_DO_SAFE(j, 8, 13) {
    if (alnm1 == opname(j)) {
      k1 = j;
    }
  }
  if (k1 == 0) {
    goto statement_50540;
  }
  i2 = i;
  i1 = 0;
  statement_50560:
  FEM_DO_SAFE(k, 1, 100) {
    if (iel(k) == i2) {
      goto statement_50570;
    }
    if (iel(k) ==  - i2) {
      goto statement_50570;
    }
  }
  statement_50570:
  k2 = 0;
  alnm2 = el(k);
  i2 = k;
  FEM_DO_SAFE(j, 1, 7) {
    if (alnm2 == opname(j)) {
      k2 = j;
    }
  }
  if (k2 != 0) {
    goto statement_50580;
  }
  if (k != ifst) {
    goto statement_50560;
  }
  ifst = ifree - 2;
  goto statement_50590;
  statement_50580:
  if (k2 == 7) {
    i1++;
  }
  if (i1 == 0) {
    goto statement_50585;
  }
  if (k2 == 1) {
    i1 = i1 - 1;
  }
  goto statement_50560;
  statement_50585:
  i2 = iel(k);
  iel(k) = ifree - 2;
  if (k2 == 1) {
    goto statement_50590;
  }
  iel(k) = ifree - 1;
  goto statement_50592;
  statement_50590:
  iel(ifree - 2) = ifree - 1;
  el(ifree - 2) = opname(3);
  statement_50592:
  iel(ifree - 1) = ifree;
  iel(ifree) = i2;
  el(ifree - 1) = opname(1);
  el(ifree) = opname(17);
  ifree = ifree - 3;
  if (k2 > 1) {
    ifree++;
  }
  if (ifree >= ilst1) {
    goto statement_50540;
  }
  ikill1 = 8;
  ikill2 = 50590;
  goto statement_50900;
  //C                                                                       M28.2550
  //C    :::  CHECK HOMOLOGY OF SUCCESSIVE OPERATORS  :::                   M28.2551
  statement_50600:
  i = ifst;
  goto statement_50610;
  statement_50605:
  i = iel(i);
  if (i < 0) {
    i = -i;
  }
  if (i == 999) {
    goto statement_50645;
  }
  statement_50610:
  k1 = 0;
  alnm1 = el(i);
  FEM_DO_SAFE(j, 3, 6) {
    if (alnm1 == opname(j)) {
      k1 = 2;
    }
  }
  FEM_DO_SAFE(j, 14, 18) {
    if (alnm1 == opname(j)) {
      k1 = 1;
    }
  }
  if (k1 == 0) {
    goto statement_50605;
  }
  k = i;
  i1 = 0;
  statement_50625:
  k = iel(k);
  if (k < 0) {
    k = -k;
  }
  if (k == 999) {
    goto statement_50605;
  }
  k2 = 0;
  alnm2 = el(k);
  FEM_DO_SAFE(j, 1, 18) {
    if (alnm2 == opname(j)) {
      k2 = j;
    }
  }
  if (k2 == 0) {
    goto statement_50625;
  }
  if (k2 == 1) {
    i1++;
  }
  if (i1 == 0) {
    goto statement_50635;
  }
  if (k2 == 7) {
    i1 = i1 - 1;
  }
  goto statement_50625;
  statement_50635:
  if (k1 != 1) {
    goto statement_50640;
  }
  if (k2 < 3 || k2 > 6) {
    goto statement_50605;
  }
  ikill1 = 9;
  ikill2 = 50635;
  bus2 = alnm1;
  bus3 = alnm2;
  goto statement_50900;
  statement_50640:
  if (k2 < 14) {
    goto statement_50605;
  }
  ikill1 = 9;
  ikill2 = 50640;
  bus2 = alnm1;
  bus3 = alnm2;
  goto statement_50900;
  //C                                                                       M28.2594
  //C    :::  STORE 'EL' INTO IVARB, PARSUP  :::                            M39. 659
  statement_50645:
  ndx1 = kjsup + nsup;
  ivarb(ndx1) = karg + 3;
  i = ifst;
  goto statement_50655;
  statement_50650:
  if (k == 999) {
    goto statement_50685;
  }
  i = k;
  statement_50655:
  k = iel(i);
  if (k > 0) {
    goto statement_50660;
  }
  //C     : NUMERICAL ARGUMENT                                              M28.2604
  k = -k;
  ivarb(karg + 1) = -1;
  kpar++;
  lstat(57) = kpar;
  ivarb(karg + 3) = kpar;
  //C!J = EL( I)
  read(el(i), star), j;
  ndx1 = kprsup + kpar;
  sptacs(ndx1) = argel(j);
  goto statement_50650;
  statement_50660:
  alnm1 = el(i);
  FEM_DO_SAFE(j, 1, 18) {
    if (alnm1 == opname(j)) {
      goto statement_50675;
    }
  }
  FEM_DO_SAFE(j, 12, 35) {
    if (alnm1 == supfn(j)) {
      goto statement_50680;
    }
  }
  //C     : TACS VARIABLE                                                   M28.2622
  ivarb(karg + 1) = 1;
  n23 = 0;
  namea6(cmn, alnm1, n23);
  ivarb(karg + 3) = n23;
  goto statement_50650;
  //C     : OPERATOR                                                        M28.2628
  statement_50675:
  karg += 3;
  lstat(56) = karg;
  ivarb(karg + 2) = j;
  ivarb(karg + 1) = 0;
  ivarb(karg + 3) = 0;
  goto statement_50650;
  //C     : FUNCTION                                                        M28.2637
  statement_50680:
  ivarb(karg + 1) = 2;
  ivarb(karg + 3) = j - 1;
  goto statement_50650;
  //C     : EXIT                                                            M28.2643
  statement_50685:
  ndx1 = kksup + nsup;
  ivarb(ndx1) = -karg;
  ndx1 = kjsup + nsup;
  if (karg - ivarb(ndx1) < 150) {
    goto statement_12599;
  }
  ikill1 = 8;
  ikill2 = 50685;
  //C                                                                       M28.2651
  //C     ***  KILL  CODES  FOR  FORTRAN  EXPRESSION  ***                   M28.2652
  //C     ***  * * * * * * * * * * * * * * * * * * *  ***                   M28.2653
  statement_50900:
  kill = 218;
  lstat(19) = ikill2;
  lstat(17) = ikill1;
  bus1 = alnode;
  goto statement_9000;
  //C                                                                       M28.2659
  //C     ***  OLD  FIXED-FORMAT  PSEUDO-FORTRAN  EXPRESSION  ***           M28.2660
  //C     ***  * * * * * * * * * * * * * * * * * * * * * * *  ***           M28.2661
  statement_12517:
  if (noutpr == 0) {
    write(kunit6, "('+TACS SUPPLEMENTAL VARIABLE ')");
  }
  read(abuff, "(10x,e10.0,2(a1,a5,a6),a1,a5,e6.0,2(a1,a5,a6))"),
    prx, alph(1), dumj(1), dumj(6), alph(2), dumj(2), dumj(7), alph(3),
    dumj(3), pru, alph(4), dumj(4), dumj(9), alph(5), dumj(5), dumj(
    10);
  ndx1 = kjsup + nsup;
  ivarb(ndx1) = karg + 3;
  if (prx == 0.0f) {
    goto statement_126;
  }
  karg += 3;
  lstat(56) = karg;
  ivarb(karg + 1) = -1;
  ivarb(karg + 2) = 0;
  kpar++;
  lstat(57) = kpar;
  ivarb(karg + 3) = kpar;
  ndx1 = kprsup + kpar;
  sptacs(ndx1) = prx;
  statement_126:
  FEM_DO_SAFE(i, 1, 5) {
    if (alph(i) != blank) {
      goto statement_12601;
    }
    //C     PREVIOUS RECORD FAILS OCCASIONALLY FOR BURROUGHS EMTP             M32. 923
    //C     (SEE VOL. XI  EMTP MEMO,  PAGE DTTM-4,  24 DEC 1981).             M32. 924
    //C     YET FOLLOWING BURROUGHS PATCH PRODUCES FATAL VAX ERROR:           M32. 925
    //C     IF ( .NOT. (ALPH(I) .IS. BLANK) )   GO TO 12601                   M32. 926
    if (i == 3) {
      goto statement_12602;
    }
    if (dumj(i + 5) == blank) {
      goto statement_125;
    }
    if (i != 1) {
      goto statement_12603;
    }
    alph(1) = splus;
    goto statement_12700;
    statement_12603:
    lstat(14) = 1;
    bus1 = dumj(i + 5);
    goto statement_12610;
    statement_12602:
    if (pru == 0.0f) {
      goto statement_125;
    }
    lstat(14) = 2;
    flstat(16) = pru;
    goto statement_12610;
    statement_12601:
    if (i != 3 && dumj(i + 5) != blank) {
      goto statement_12700;
    }
    if (i == 3 && pru != 0.0f) {
      goto statement_12700;
    }
    lstat(14) = 3;
    bus2 = alph(i);
    statement_12610:
    kill = 139;
    lstat(19) = 12610;
    bus3 = alnode;
    goto statement_9000;
    statement_12700:
    karg += 3;
    lstat(56) = karg;
    FEM_DO_SAFE(j, 1, 6) {
      if (alph(i) == supop(j)) {
        goto statement_12702;
      }
    }
    kill = 130;
    lstat(19) = 12702;
    bus1 = alph(i);
    bus2 = alnode;
    goto statement_9000;
    statement_12702:
    ivarb(karg + 1) = j;
    FEM_DO_SAFE(j, 1, 35) {
      if (dumj(i) == supfn(j)) {
        goto statement_12704;
      }
    }
    kill = 132;
    lstat(19) = 12704;
    bus1 = dumj(i);
    bus2 = alnode;
    goto statement_9000;
    statement_12704:
    ivarb(karg + 2) = j - 1;
    if (i == 3) {
      goto statement_12710;
    }
    n23 = 0;
    text2 = dumj(i + 5);
    namea6(cmn, text2, n23);
    ivarb(karg + 3) = n23;
    goto statement_125;
    statement_12710:
    ivarb(karg + 1) = -ivarb(karg + 1);
    kpar++;
    lstat(57) = kpar;
    ivarb(karg + 3) = kpar;
    ndx1 = kprsup + kpar;
    sptacs(ndx1) = pru;
    statement_125:;
  }
  ndx1 = kksup + nsup;
  ivarb(ndx1) = karg;
  statement_12599:
  if (karg - kivarb < lstat(66)) {
    goto statement_12721;
  }
  kill = 122;
  lstat(19) = 12721;
  lstat(16) = lstat(66);
  lstat(17) = 6;
  goto statement_9000;
  statement_12721:
  if (kpar <= lstat(67)) {
    goto statement_12722;
  }
  kill = 122;
  lstat(19) = 12722;
  lstat(16) = lstat(67);
  lstat(17) = 7;
  goto statement_9000;
  statement_12722:
  ndx1 = kjsup + nsup;
  if (karg >= ivarb(ndx1)) {
    goto statement_9000;
  }
  kill = 133;
  bus1 = alnode;
  lstat(19) = 104;
  goto statement_9000;
  statement_10700:
  if (noutpr == 0) {
    write(kunit6, "('+TACS SUPPLEMENTAL DEVICE TYPE ',i2)"), m;
  }
  {
    read_loop rloop(abuff, "(10x,5(a1,a6,1x),3e6.0,2a6)");
    rloop, alph(1), dumj(1), alph(2), dumj(2), alph(3), dumj(3), alph(4),
      dumj(4), alph(5), dumj(5);
    FEM_DO_SAFE(i, 1, 3) {
      rloop, dum(i);
    }
    rloop, alnm1, alnm2;
  }
  if (m >= 50) {
    goto statement_10701;
  }
  kill = 134;
  lstat(19) = 10701;
  bus1 = alnode;
  lstat(14) = m;
  goto statement_9000;
  statement_10701:
  karg += 4;
  lstat(56) = karg;
  if ((karg - kivarb + 4) <= lstat(66)) {
    goto statement_10703;
  }
  kill = 122;
  lstat(16) = lstat(66);
  lstat(17) = 6;
  lstat(19) = 10703;
  goto statement_9000;
  statement_10703:
  ndx1 = kjsup + nsup;
  ivarb(ndx1) = -karg;
  ndx1 = kksup + nsup;
  ivarb(ndx1) = m;
  ivarb(karg) = kprsup + kpar + 1;
  ivarb(karg + 2) = nsudv;
  n1 = 0;
  FEM_DO_SAFE(i, 1, 5) {
    if (m == 61 || m == 63) {
      goto statement_1107;
    }
    if (dumj(i) == blank) {
      goto statement_1071;
    }
    n1++;
    statement_1107:
    if (nsudv > nsu) {
      goto statement_1072;
    }
    kill = 122;
    lstat(16) = lstat(63);
    lstat(17) = 3;
    lstat(19) = 1072;
    goto statement_9000;
    statement_1072:
    ndx1 = kalksu + nsudv;
    n23 = 0;
    text2 = dumj(i);
    namea6(cmn, text2, n23);
    ivarb(ndx1) = n23;
    ndx1 = kksus + nsudv;
    ivarb(ndx1) = 1;
    if (alph(i) == sminus) {
      ivarb(ndx1) = -1;
    }
    if (alph(i) == smultp) {
      ivarb(ndx1) = 9;
    }
    nsudv = nsudv - 1;
    lstat(60) = nsudv;
    statement_1071:;
  }
  if (n1 > 0) {
    goto statement_1073;
  }
  if (m == 61 || m == 63) {
    goto statement_1073;
  }
  kill = 135;
  bus1 = alnode;
  lstat(19) = 1073;
  goto statement_9000;
  statement_1073:
  ivarb(karg + 1) = nsudv + 1;
  mpar = kprsup + kpar;
  sptacs(mpar + 1) = dum(1);
  sptacs(mpar + 2) = dum(2);
  sptacs(mpar + 3) = dum(3);
  n23 = -9999;
  if (alnm1 == text4) {
    goto statement_1177;
  }
  n23 = 0;
  namea6(cmn, alnm1, n23);
  statement_1177:
  ivarb(karg + 3) = n23;
  n23 = 0;
  namea6(cmn, alnm2, n23);
  ivarb(karg + 4) = n23;
  if (m > 67) {
    goto statement_6799;
  }
  moon = m - 49;
  switch (moon) {
    case 1: goto statement_650;
    case 2: goto statement_651;
    case 3: goto statement_651;
    case 4: goto statement_653;
    case 5: goto statement_654;
    case 6: goto statement_655;
    case 7: goto statement_655;
    case 8: goto statement_655;
    case 9: goto statement_658;
    case 10: goto statement_659;
    case 11: goto statement_660;
    case 12: goto statement_661;
    case 13: goto statement_662;
    case 14: goto statement_663;
    case 15: goto statement_663;
    case 16: goto statement_6511;
    case 17: goto statement_666;
    case 18: goto statement_667;
    default: break;
  }
  statement_650:
  ivarb(karg + 3) = 0;
  kpar += 4;
  lstat(57) = kpar;
  sptacs(mpar + 4) = dum(2);
  if (dum(2) == 0.0f) {
    sptacs(mpar + 4) = 0.5f;
  }
  goto statement_3636;
  statement_651:
  if (dum(3) == 0.0f) {
    sptacs(mpar + 3) = 2.0f;
  }
  statement_6511:
  kpar += 3;
  lstat(57) = kpar;
  statement_3636:
  karg++;
  lstat(56) = karg;
  if (kpar <= lstat(67)) {
    goto statement_9000;
  }
  kill = 122;
  lstat(16) = lstat(67);
  lstat(17) = 7;
  lstat(19) = 3636;
  goto statement_9000;
  statement_653:
  if (alnm1 == blank) {
    sptacs(mpar + 3) = sptacs(mpar + 2);
  }
  d9 = sptacs(mpar + 3) / deltat - cmn.flzero * 10.f;
  i = 0;
  statement_10706:
  i++;
  d10 = i;
  if (d9 > d10) {
    goto statement_10706;
  }
  sptacs(mpar + 3) = d10;
  kpar += 5;
  lstat(57) = kpar;
  sptacs(mpar + 1) = kpar;
  sptacs(mpar + 4) = 0.0f;
  ivarb(karg + 4) = -kpar;
  n6 = kpar + i - 1;
  //C     WSM PATCH FOR DAN GOLDSWORTH TYPE-53 HISTORY.  27 MAR 83          M35. 677
  if (alnm2 == text1) {
    goto statement_1707;
  }
  sptacs(mpar + 4) = dum(1);
  dum(1) = 0.0f;
  statement_1707:
  if (iprsup >= 1) {
    write(lunit6, "(' TEST DELAY LINE I.C., VALUE =',a6)"), alnm2;
  }
  FEM_DO_SAFE(i1, kpar, n6) {
    ndx6 = kprsup + i1;
    sptacs(ndx6) = dum(1);
  }
  kpar = n6;
  lstat(57) = kpar;
  goto statement_3636;
  statement_654:
  if (sptacs(mpar + 1) == 0.0f) {
    sptacs(mpar + 1) = -9999.f;
  }
  if (sptacs(mpar + 3) == 0.0f) {
    sptacs(mpar + 3) = -9999.f;
  }
  goto statement_6511;
  statement_655:
  ivarb(karg + 3) = -kpar - 4;
  kpar += 3;
  lstat(57) = kpar;
  //C     READ INPUT CARD USING CIMAGE                                      M22.2102
  statement_10711:
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_6544;
  }
  read(abuff, "(2e16.0)"), prx, pru;
  goto statement_6547;
  statement_6544:
  nfrfld = 1;
  frefld(cmn, voltbc(1));
  prx = voltbc(1);
  if (prx == 9999.f) {
    goto statement_10713;
  }
  frefld(cmn, voltbc(1));
  pru = voltbc(1);
  statement_6547:
  if (prx == 9999.f) {
    goto statement_10713;
  }
  if (noutpr == 0) {
    write(kunit6, "('+DATA VALUES.     ',2e13.4)"), prx, pru;
  }
  kpar++;
  lstat(57) = kpar;
  ndx1 = kprsup + kpar;
  sptacs(ndx1) = prx;
  if (m == 55 || m == 57) {
    goto statement_10711;
  }
  kpar++;
  lstat(57) = kpar;
  ndx1 = kprsup + kpar;
  sptacs(ndx1) = pru;
  goto statement_10711;
  statement_10713:
  ivarb(karg + 4) = -kpar;
  if (noutpr == 0) {
    write(kunit6, "('+END OF DATA VALUES FOR LAST-READ DEVICE.')");
  }
  if (m == 57) {
    sptacs(mpar + 2) = 0.f;
  }
  if (m == 57) {
    sptacs(mpar + 3) = 0.f;
  }
  goto statement_3636;
  statement_658:
  if (sptacs(mpar + 1) == 0.0f) {
    sptacs(mpar + 1) = 1.0f;
  }
  sptacs(mpar + 3) = 2.0f / deltat * sptacs(mpar + 3) / sptacs(mpar + 1);
  sptacs(mpar + 1) = sptacs(mpar + 2) / sptacs(mpar + 1);
  sptacs(mpar + 2) = sptacs(mpar + 1) + sptacs(mpar + 3);
  sptacs(mpar + 3) = sptacs(mpar + 1) - sptacs(mpar + 3);
  if (sptacs(mpar + 2) != 0.0f || alnm1 == text4) {
    goto statement_6511;
  }
  kill = 214;
  bus1 = alnode;
  lstat(19) = 10714;
  goto statement_9000;
  statement_659:
  if (sptacs(mpar + 1) == 0.0f) {
    sptacs(mpar + 1) = 1.0f;
  }
  sptacs(mpar + 1) = sptacs(mpar + 1) / deltat;
  goto statement_6511;
  statement_660:
  if (alnm1 == blank) {
    goto statement_10720;
  }
  if (dumj(1) == blank) {
    goto statement_10720;
  }
  if (dumj(2) == blank) {
    goto statement_10720;
  }
  if (dumj(3) == blank) {
    goto statement_10720;
  }
  if (dumj(4) != blank) {
    goto statement_10720;
  }
  if (dumj(5) != blank) {
    goto statement_10720;
  }
  kpar += 2;
  lstat(57) = kpar;
  goto statement_3636;
  statement_10720:
  kill = 215;
  bus1 = alnode;
  lstat(19) = 10720;
  goto statement_9000;
  statement_661:
  if (alnm2 != blank) {
    goto statement_6511;
  }
  kill = 216;
  bus1 = alnode;
  lstat(19) = 10721;
  goto statement_9000;
  statement_662:
  sptacs(mpar + 1) = 0.0f;
  goto statement_6511;
  statement_663:
  if (dum(2) ==  - 1.0f || dum(2) == 1.0f) {
    goto statement_6511;
  }
  kill = 217;
  bus1 = alnode;
  lstat(19) = 10723;
  lstat(17) = m;
  flstat(14) = dum(2);
  goto statement_9000;
  statement_666:
  sptacs(mpar + 1) = dum(1) * deltat;
  ivarb(karg + 3) = -1.0f / sptacs(mpar + 1) - 0.5f;
  ivarb(karg + 4) = -1;
  kpar = kpar - ivarb(karg + 3) + 1;
  lstat(57) = kpar;
  if (alnm2 != text1) {
    dum(2) = 0.0f;
  }
  j1 = mpar + 2;
  j2 = mpar + n + 1;
  FEM_DO_SAFE(j, j1, j2) {
    sptacs(j) = dum(2);
  }
  goto statement_3636;
  statement_667:
  sptacs(mpar + 2) = sptacs(mpar + 2) * dum(1);
  sptacs(mpar + 3) = sptacs(mpar + 3) * dum(1);
  kpar += 4;
  lstat(57) = kpar;
  goto statement_3636;
  statement_6799:
  if (noutpr == 0) {
    write(kunit6, "('+NO SUCH SUP. DEVICE. ')");
  }
  statement_9000:
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE TACS1A.\"')");
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

//void
//move0(
//  arr_ref<double> b,
//  int const& n)
//{
//  //C)    SUBROUTINE  MOVER0  IS A BLOCK-ZEROING ROUTINE FOR FLOATING-POINT 
//  //C)    ARRAYS OR VARIABLES.   OF THE TWO ARGUMENTS, THE SECOND,  'N' ,   
//  //C)    IS THE NUMBER OF WORDS OF CORE TO BE ZEROED. THE FIRST ARGUMENT 
//  //C)    SPECIFIES THE ADDRESS OF THE FIRST WORD OF THE BLOCK OF  'N'      
//  //C)    WORDS OF CORE WHICH IS TO BE ZEROED.                              
//  int i = 0;
//  FEM_DO_SAFE(i, 1, std::min(int(b.size()), n)) {
//    b(i) = 0.0f;
//  }
//}
//
//void move0(
//  vectorEx<double>& b,
//  int i0,
//  int const n)
//{
//  --i0;
//  int size = b.size() - i0;
//  int i = fem::int0;
//  FEM_DO_SAFE(i, 1, std::min(size, n)) {
//    b(i0 + i) = 0.0f;
//  }
//}
//
//void
//move0(
//  arr_ref<int> b,
//  int const& n)
//{
//  //C)    SUBROUTINE  MOVER0  IS A BLOCK-ZEROING ROUTINE FOR FLOATING-POINT M15. 306
//  //C)    ARRAYS OR VARIABLES.   OF THE TWO ARGUMENTS, THE SECOND,  'N' ,   M15. 307
//  //C)    IS THE NUMBER OF WORDS OF CORE TO BE ZEROED.   THE FIRST ARGUMENT M15. 308
//  //C)    SPECIFIES THE ADDRESS OF THE FIRST WORD OF THE BLOCK OF  'N'      M15. 309
//  //C)    WORDS OF CORE WHICH IS TO BE ZEROED.                              M15. 310
//  int siz = int(b.size());
//  int i = 0;
//  FEM_DO_SAFE(i, 1, std::min(siz, n)) {
//    b(i) = 0;
//  }
//}
//
//void move0(
//  arr_ref<int> b,
//  int i0,
//  int const n)
//{
//  --i0;
//  int size = b.size() - i0;
//  int i = fem::int0;
//  FEM_DO_SAFE(i, 1, std::min(size, n)) {
//    b(i) = 0.0f;
//  }
//}
//
//void move0(
//  vectorEx<int>& b,
//  int const n)
//{
//  int size = b.size();
//  int i = fem::int0;
//  FEM_DO_SAFE(i, 1, std::min(size, n)) {
//    b(i) = 0.0f;
//  }
//}
//void move0(
//  vectorEx<int>& b,
//  int i0,
//  int const n)
//{
//  --i0;
//  int size = b.size() - i0;
//  int i = fem::int0;
//  FEM_DO_SAFE(i, 1, std::min(size, n)) {
//    b(i) = 0.0f;
//  }
//}




void nmincr(
  common& cmn,
  str_ref texta,
  int const& n12) try
{
  common_read read(cmn);
  common_write write(cmn);
  fem::str<6> text1 = fem::char0;
  int j = fem::int0;
  fem::str<6> text2 = fem::char0;
  static const char* format_4556 = "(a6)";
  //C     MODULE DESIGNED TO SERIALIZE INPUT ROOT NAME  TEXTA  WITH DECIMAL M40. 449
  //C     COMPONENT NUMBER  N12,  ENCODING ONLY REQUIRED DIGITS.   IT IS    M40. 450
  //C     ASSUMED THAT A FORTRAN 77 COMPILER IS BEING USED, AND THAT        M40. 451
  //C     "ALPHANUMERIC" IS TRANSLATED TO SOMETHING OTHER THAN  CHARACTER*6 M40. 452
  //C INPUT ARGUMENT CARRIES A6 ROOT
  //C LOCAL CHARACTER-HANDLING VARIABLES
  //C ENCODE COMPONENT NUMBER
  write(text1, "(i6)"), n12;
  //C 6-DIGIT FORMAT ALLOWS NUMBER THROUGH 999999
  //C SEARCH FOR FIRST NON-BLANK IN ENCODED NUMBER
  FEM_DO_SAFE(j, 1, 6) {
    //C  IF NONBLANK, EXIT
    if (text1(j, j) != " ") {
      goto statement_4552;
    }
    //C END  DO 4538  LOOP TO FIND NON-BLANK LEFT EDGE
  }
  //C TRANSFER INPUT ALPHANUMERIC TO CHAR*6
  statement_4552:
  write(text2, format_4556), texta;
  //C ALPHANUMERIC VARIABLES ARE 6 CHARACTERS WIDE
  //C ADD COMPONENT NUMBER ONTO INPUT NAME
  text2(j, 6) = text1(j, 6);
  //C CONVERT BACK FROM CHAR*6 TO ALPHANUM.
  read(text2, format_4556), texta;
  //C     WRITE (*,*)  ' Exit "NMINCR".   N12 =',  N12,  '   TEXTA =', TEXTAM40. 464
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct tacs1b_save
{
  fem::str<8> delay;

  tacs1b_save() :
    delay(fem::char0)
  {}
};

void tacs1b(
  common& cmn) try
{
  FEM_CMN_SVE(tacs1b);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus6 = cmn.bus6;
  const auto& date1= cmn.date1;
  const auto& tclock= cmn.tclock;
  double& fltinf = cmn.fltinf;
  auto& lunit4 = cmn.lunit4;
  auto& lstat = cmn.lstat;
  auto& iprsov= cmn.iprsov;
  int& maxbus = cmn.maxbus;
  int& ktab = cmn.ktab;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  auto& sptacs = cmn.sptacs;
  const auto& texvec = cmn.texvec;


  fem::str<8>& delay = sve.delay;
  if (is_called_first_time) {
    delay = "DELAY ";
  }

  auto& lunit6 = cmn.lunit6;
  int ll0 = fem::int0;
  int ll1 = fem::int0;
  int ll2 = fem::int0;
  int ll3 = fem::int0;
  int llm1 = fem::int0;
  int isour = fem::int0;
  int kjsup = fem::int0;
  int kksup = fem::int0;
  int kxai = fem::int0;
  int kbtcs = fem::int0;
  int kbwkcs = fem::int0;
  int i = fem::int0;
  int nuki = fem::int0;
  int nexd = fem::int0;
  int kargsa = fem::int0;
  int ndxb = fem::int0;
  int mc = fem::int0;
  int mins = fem::int0;
  int iuser = fem::int0;
  int kint = fem::int0;
  int mpq = fem::int0;
  int mpp = fem::int0;
  int mkk = fem::int0;
  int ngp = fem::int0;
  int mpk = fem::int0;
  int infir = fem::int0;
  int inlst = fem::int0;
  int namout = fem::int0;
  int izs = fem::int0;
  int j = fem::int0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  int m = fem::int0;
  double dn = fem::double0;
  int L = fem::int0;
  int namin = fem::int0;
  int k = fem::int0;
  int namsbk = fem::int0;
  int ndy = fem::int0;
  int nnn = fem::int0;
  int jjj = fem::int0;
  int mmm = fem::int0;
  int mm = fem::int0;
  int is = fem::int0;
  int n1 = fem::int0;
  int n3 = fem::int0;
  int n2 = fem::int0;
  int nstep = fem::int0;
  int k2 = fem::int0;
  int n4 = fem::int0;
  int namsup = fem::int0;
  int nn = fem::int0;
  int nukr = fem::int0;
  int lc = fem::int0;
  int n23 = fem::int0;
  int jc = fem::int0;
  int np = fem::int0;
  int j11 = fem::int0;
  int j12 = fem::int0;
  int j13 = fem::int0;
  int mnp = fem::int0;
  int nukm = fem::int0;
  int nq = fem::int0;
  int nukq = fem::int0;
  int nukj = fem::int0;
  int n11 = fem::int0;
  int n12 = fem::int0;
  int nik = fem::int0;
  int nukl = fem::int0;
  int namexm = fem::int0;
  int irr = fem::int0;
  int nj = fem::int0;
  int np1 = fem::int0;
  int jk2 = fem::int0;
  int jj = fem::int0;
  int jk1 = fem::int0;
  int ijk = fem::int0;
  int jk = fem::int0;
  int nukk = fem::int0;
  int jl = fem::int0;
  int nukjl = fem::int0;
  int jm = fem::int0;
  int jn = fem::int0;
  int jni = fem::int0;
  int mjump = fem::int0;
  int nfun = fem::int0;
  int nom = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  int ij9 = fem::int0;
  int ij = fem::int0;
  int kofsce = fem::int0;
  int k1 = fem::int0;
  int n = fem::int0;
  int nivarb = fem::int0;
  int ndx3 = fem::int0;
  int n6 = fem::int0;
  int nukn = fem::int0;
  int min = fem::int0;
  int nkn = fem::int0;
  int jr = fem::int0;
  int j8 = fem::int0;
  int kxtcs2 = fem::int0;

  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;
  auto& kcolcs = isptacs(5);
  auto& kspvar = isptacs(6);
  auto& katcs =  isptacs(7);
  auto& konsup = isptacs(8);
  auto& kprsup = isptacs(9);
  auto& kivarb = isptacs(10);
  auto& kaliu =  isptacs(11);
  auto& kjout =  isptacs(12);
  auto& kiuty =  isptacs(13);
  auto& kawkcs = isptacs(15);
  auto& kxar =   isptacs(16);
  auto& kxtcs =  isptacs(17);
  auto& klntab = isptacs(18);
  auto& kisblk = isptacs(19);
  auto& krsblk = isptacs(20);
  auto& kksus =  isptacs(21);
  auto& kalksu = isptacs(22);
  auto& kinsup = isptacs(23);

  auto& nuk = lstat(51);
  auto& ia = lstat(52);
  auto& nsu = lstat(53);
  auto& niu = lstat(54);
  auto& nsup = lstat(55);
  auto& karg = lstat(56);
  auto& kpar = lstat(57);
  auto& kxic = lstat(58);
  auto& ioutcs = lstat(59);
  auto& nsudv = lstat(60);
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE TACS1B.\"')");
  }
  ll0 = 0;
  ll1 = 1;
  ll2 = 2;
  ll3 = 3;
  llm1 = -1;
  isour = lstat(64);
  kjsup = kinsup + lstat(65);
  kksup = kjsup + lstat(65);
  kxai = kxar + lstat(68);
  kbtcs = katcs + lstat(62);
  kbwkcs = kawkcs + lstat(68);
  if (nchain == 1) {
    goto statement_5566;
  }
  i = nsup;
  goto statement_5577;
  statement_5566:
  nuki = kisblk - 8;
  nexd = 1;
  kargsa = karg + 3;
  ivarb(kiuty + 7) = karg + 4;
  iprsov(35) = -8888;
  ndxb = nuk + 1;
  mc = 1;
  mins = 0;
  iuser = 0;
  //C                               $$$  ORDERING  $$$                      M37.1577
  kint = -1000;
  goto statement_1555;
  statement_4747:
  if (fem::iabs(ia) != 1) {
    goto statement_1984;
  }
  i = 1;
  iuser = 9999;
  if (ia <= 0) {
    nuki += nuk * 8 + 8;
  }
  statement_555:
  nuki += 8;
  if (ia < 0) {
    nuki = nuki - 16;
  }
  goto statement_6677;
  statement_2555:
  i++;
  if (i <= nuk) {
    goto statement_555;
  }
  goto statement_2254;
  statement_1984:
  mpq = 0;
  mpp = 0;
  mkk = 0;
  ngp = 0;
  kint = 1000;
  statement_1900:
  mpk = 0;
  i = 1;
  nuki = kisblk - 8;
  statement_1910:
  nuki += 8;
  if (i > nuk) {
    goto statement_8103;
  }
  if (ivarb(nuki + 4) > 0) {
    goto statement_1950;
  }
  infir = fem::iabs(ivarb(nuki + 1));
  inlst = fem::iabs(ivarb(nuki + 9)) - 1;
  if (i == nuk) {
    inlst = nsu;
  }
  namout = sptacs(katcs + i);
  izs = ivarb(nuki + 2);
  if (mpq == 0 || izs == 1) {
    goto statement_1911;
  }
  j = ivarb(nuki + 3);
  ndx1 = kprsup + j;
  ndx2 = ndx1 + 1;
  if (sptacs(ndx2) == 0) {
    goto statement_1911;
  }
  m = izs * 6 + j - 4;
  dn = -sptacs(ndx1) / sptacs(ndx2);
  FEM_DOSTEP(L, j, m, 6) {
    dn = -dn;
    ndx1 = kprsup + L;
    if (sptacs(ndx1) != sptacs(ndx1 + 1) * dn) {
      goto statement_1911;
    }
    if (sptacs(ndx2) * sptacs(ndx1 + 1) < 0) {
      goto statement_1911;
    }
  }
  goto statement_1983;
  statement_1911:
  FEM_DO_SAFE(j, infir, inlst) {
    namin = ivarb(kalksu + j);
    FEM_DO_SAFE(k, 1, niu) {
      if (namin == ivarb(kaliu + k)) {
        goto statement_1940;
      }
    }
    FEM_DO_SAFE(k, 1, nsup) {
      ndx2 = kspvar + k;
      if (namin != ivarb(ndx2)) {
        goto statement_1920;
      }
      if (ivarb(kinsup + k) != 0) {
        goto statement_1940;
      }
      goto statement_1950;
      statement_1920:;
    }
    FEM_DO_SAFE(k, 1, nuk) {
      namsbk = sptacs(katcs + k);
      if (namin != namsbk) {
        goto statement_1919;
      }
      ndx1 = kisblk + k * 8 - 4;
      if (ivarb(ndx1) > 0) {
        goto statement_1940;
      }
      goto statement_1950;
      statement_1919:;
    }
    statement_1940:;
  }
  statement_1983:
  mpk = 1;
  statement_6677:
  ndxb = ndxb - 1;
  ivarb(nuki + 4) = ndxb;
  ndy = kisblk + ndxb * 8 - 1;
  ivarb(ndy) = 0;
  statement_1555:
  if (mins == nsup) {
    goto statement_1950;
  }
  nnn = 0;
  statement_4646:
  jjj = 0;
  mmm = 0;
  mm = mc;
  FEM_DO_SAFE(is, mm, nsup) {
    if (ivarb(kinsup + is) != 0) {
      goto statement_1980;
    }
    n1 = ivarb(kjsup + is);
    n3 = ivarb(kksup + is);
    n2 = fem::iabs(n3);
    nstep = 1;
    if (n1 < 0) {
      goto statement_1970;
    }
    j = n1;
    k2 = n2;
    nstep = 3;
    statement_1973:
    if (n1 < 0) {
      goto statement_2973;
    }
    n4 = ivarb(j + 1);
    if (n4 < 0) {
      goto statement_1959;
    }
    if (n3 <= 0 && n4 != 1) {
      goto statement_1959;
    }
    namsup = ivarb(j + 3);
    goto statement_1853;
    statement_2973:
    namsup = ivarb(kalksu + j);
    statement_1853:
    FEM_DO_SAFE(k, 1, nuk) {
      namsbk = sptacs(katcs + k);
      if (namsbk != namsup) {
        goto statement_1951;
      }
      ndx1 = kisblk + k * 8 - 4;
      if (ivarb(ndx1) > 0) {
        goto statement_1959;
      }
      goto statement_1990;
      statement_1951:;
    }
    FEM_DO_SAFE(k, 1, nsup) {
      if (ivarb(kspvar + k) != namsup) {
        goto statement_1953;
      }
      if (ivarb(kinsup + k) != 0) {
        goto statement_1959;
      }
      goto statement_1990;
      statement_1953:;
    }
    statement_1959:
    j += nstep;
    if (j <= k2) {
      goto statement_1973;
    }
    if (n1 > 0) {
      goto statement_1978;
    }
    if (j > k2 + 1) {
      goto statement_1851;
    }
    namsup = ivarb(nn + 3);
    if (namsup > 1) {
      goto statement_1853;
    }
    goto statement_1959;
    statement_1851:
    if (j > k2 + 2) {
      goto statement_1978;
    }
    namsup = ivarb(nn + 4);
    if (namsup > 1) {
      goto statement_1853;
    }
    statement_1978:
    mmm = 1;
    if (ndxb <= nuk || kint !=  - 1000) {
      goto statement_4848;
    }
    ivarb(kiuty + 4) = is;
    kint = -100;
    goto statement_4949;
    statement_4848:
    if (nnn == 0) {
      ivarb(ndy) = is;
    }
    if (nnn != 0) {
      ivarb(kinsup + nnn) = is;
    }
    statement_4949:
    nnn = is;
    ivarb(kinsup + is) = -1;
    mins++;
    goto statement_1980;
    statement_1970:
    if (n2 == 53 && ivarb(nn + 3) == 1) {
      goto statement_1978;
    }
    nn = -n1;
    k2 = ivarb(nn + 2);
    j = ivarb(nn + 1);
    goto statement_1973;
    statement_1990:
    if (jjj == 1) {
      goto statement_1980;
    }
    jjj = 1;
    mc = is;
    statement_1980:;
  }
  if (mmm == 1 && mins < nsup) {
    goto statement_4646;
  }
  statement_1950:
  if (iuser == 9999) {
    goto statement_2555;
  }
  if (ndxb == 1) {
    goto statement_2254;
  }
  if (kint < 0) {
    goto statement_4747;
  }
  if (i == 0) {
    goto statement_1900;
  }
  i++;
  goto statement_1910;
  statement_7104:
  kill = 122;
  lstat(16) = lstat(68);
  lstat(17) = 8;
  lstat(19) = 7104;
  goto statement_9000;
  statement_777:
  nukr = krsblk + nuk * 4;
  write(lunit6,
    "(' --------- MORE THAN ONE LIMITER IN THE ZS LOOP',"
    "' INSERT A DELAY S-BLOCK TO DECOUPLE THE LOOP')");
  nuki = kisblk - 4;
  FEM_DO_SAFE(lc, 1, nuk) {
    nuki += 8;
    if (ivarb(nuki) > 0) {
      ivarb(nuki)++;
    }
  }
  nuk++;
  lstat(51) = nuk;
  if (nuk <= lstat(61)) {
    goto statement_1347;
  }
  kill = 122;
  lstat(16) = lstat(61);
  lstat(17) = 1;
  lstat(19) = 1347;
  goto statement_9000;
  statement_1347:
  nsu++;
  lstat(53) = nsu;
  if (nsu <= nsudv) {
    goto statement_1357;
  }
  kill = 122;
  lstat(16) = lstat(63);
  lstat(17) = 3;
  lstat(19) = 1357;
  goto statement_9000;
  statement_1357:
  j = kpar + 1;
  ndx1 = kprsup + kpar;
  kpar += 10;
  lstat(57) = kpar;
  if (kpar <= lstat(67)) {
    goto statement_1367;
  }
  kill = 122;
  lstat(16) = lstat(67);
  lstat(17) = 7;
  lstat(19) = 1367;
  goto statement_9000;
  statement_1367:
  nuki += 4;
  ivarb(nuki + 1) = nsu;
  ivarb(nuki + 2) = 2;
  ivarb(nuki + 3) = j;
  ivarb(nuki + 4) = ndxb;
  nmincr(cmn, delay, nexd);
  nexd++;
  n23 = 0;
  namea6(cmn, delay, n23);
  sptacs(katcs + nuk) = n23;
  ivarb(kksus + nsu) = 1;
  ivarb(kalksu + nsu) = ivarb(kalksu + k);
  ivarb(kalksu + k) = n23;
  sptacs(nukr + 4) = 0.0f;
  sptacs(kxar + nuk) = 0.0f;
  sptacs(kxai + nuk) = 0.0f;
  sptacs(kawkcs + nuk) = 1.0f;
  sptacs(kbwkcs + nuk) = 1.0f;
  sptacs(ndx1 + 1) = 1.0f;
  sptacs(ndx1 + 2) = 1.0f;
  sptacs(ndx1 + 3) = 1.0f;
  sptacs(ndx1 + 4) = 1.0f;
  sptacs(ndx1 + 5) = 0.0f;
  sptacs(ndx1 + 6) = 0.0f;
  sptacs(ndx1 + 7) = -cmn.deltat / 2.0f;
  sptacs(ndx1 + 8) = -sptacs(ndx1 + 5);
  sptacs(ndx1 + 9) = sptacs(ndx1 + 7);
  sptacs(ndx1 + 10) = sptacs(ndx1 + 8);
  FEM_DO_SAFE(jc, 2, nuk) {
    ivarb(nuki + 7) = ivarb(nuki - 1);
    nuki = nuki - 8;
  }
  mkk = 0;
  ndy = kisblk + ndxb * 8 - 1;
  ivarb(ndy) = 0;
  goto statement_1900;
  statement_8103:
  mpq = 0;
  if (mpk == 1) {
    goto statement_1900;
  }
  if (ngp > 0) {
    goto statement_8811;
  }
  if (mkk > 0) {
    goto statement_1997;
  }
  if (mpp == 1) {
    goto statement_1996;
  }
  mpq = 1;
  mpp = 1;
  goto statement_1900;
  statement_1996:
  nuki = kisblk - 8;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    if (ivarb(nuki + 4) >= 0) {
      goto statement_1414;
    }
    namout = sptacs(katcs + i);
    np = 1;
    sptacs(kbtcs + np) = namout;
    ivarb(kisblk + 8) = 0;
    j11 = kisblk + 5;
    j12 = j11 + nuk * 8 - 2;
    FEM_DOSTEP(j13, j11, j12, 8) {
      ivarb(j13) = 0;
      ivarb(j13 + 1) = 0;
    }
    ivarb(kisblk + 5) = i;
    mnp = 1;
    nukm = kisblk;
    statement_1444:
    nq = np;
    nukq = kisblk + nq * 8 - 8;
    j = 1;
    nukj = kisblk - 8;
    statement_1427:
    nukj += 8;
    if (ivarb(nukj + 4) > 0) {
      goto statement_1429;
    }
    n11 = fem::iabs(ivarb(nukj + 1));
    n12 = fem::iabs(ivarb(nukj + 9)) - 1;
    if (j == nuk) {
      n12 = nsu;
    }
    namsbk = sptacs(katcs + j);
    nik = 0;
    FEM_DO_SAFE(k, n11, n12) {
      namin = ivarb(kalksu + k);
      L = 1;
      nukl = kisblk - 8;
      statement_1423:
      nukl += 8;
      namexm = sptacs(kbtcs + L);
      if (namin != namexm) {
        goto statement_1425;
      }
      if (ivarb(nukj + 6) > 0) {
        goto statement_1429;
      }
      irr = ivarb(nukl + 8);
      if (irr == 1 && namsbk == namout) {
        goto statement_777;
      }
      if (namsbk == namout) {
        goto statement_1421;
      }
      if (ivarb(nukj + 4) < 0 || irr == 1) {
        ivarb(nukj + 6) = 1;
      }
      if (ivarb(nukj + 6) < 0) {
        goto statement_1421;
      }
      if (nik == 1) {
        goto statement_1474;
      }
      nik = 1;
      nq++;
      nukq += 8;
      sptacs(kbtcs + nq) = namsbk;
      if (ivarb(nukj + 6) == 0) {
        ivarb(nukj + 6) = -1;
      }
      statement_1474:
      ivarb(nukq + 8) = ivarb(nukj + 6);
      if (ivarb(nukj + 6) < 0) {
        goto statement_1421;
      }
      if (ivarb(nukj + 4) < 0) {
        goto statement_1616;
      }
      goto statement_1429;
      statement_1616:
      mnp++;
      nukm += 8;
      ivarb(nukm + 5) = j;
      goto statement_1429;
      statement_1425:
      L++;
      if (L <= np) {
        goto statement_1423;
      }
      statement_1421:;
    }
    statement_1429:
    j++;
    if (j <= nuk) {
      goto statement_1427;
    }
    if (nq == np) {
      goto statement_1714;
    }
    nj = nq - np;
    np1 = np * 8;
    nukj = kisblk - 8;
    FEM_DO_SAFE(j, 1, nj) {
      nukj += 8;
      sptacs(kbtcs + j) = sptacs(kbtcs + j + np);
      ivarb(nukj + 8) = ivarb(nukj + 8 + np1);
    }
    np = nj;
    goto statement_1444;
    statement_1714:
    if (mkk != 0) {
      goto statement_1814;
    }
    jk2 = kcolcs + lstat(62);
    mkk = jk2 - mnp;
    nukm = kisblk - 8;
    FEM_DO_SAFE(jj, 1, mnp) {
      nukm += 8;
      ivarb(mkk + jj) = ivarb(nukm + 5);
    }
    goto statement_1414;
    statement_1814:
    jk1 = mkk + 1;
    ijk = 0;
    nukm = kisblk - 8;
    FEM_DO_SAFE(jj, 1, mnp) {
      nukm += 8;
      FEM_DO_SAFE(jk, jk1, jk2) {
        if (ivarb(jk) != ivarb(nukm + 5)) {
          goto statement_1861;
        }
        if (jj == 1) {
          goto statement_1878;
        }
        ivarb(nukm + 5) = 0;
        ijk++;
        goto statement_1840;
        statement_1861:;
      }
      statement_1840:;
    }
    if (ijk != 0) {
      goto statement_1888;
    }
    mkk = mkk - mnp;
    nukk = kisblk - 3;
    FEM_DO_SAFE(jl, 1, mnp) {
      nukk += 8;
      ivarb(mkk + jl) = ivarb(nukk);
    }
    goto statement_1414;
    statement_1878:
    if (mnp == 1) {
      goto statement_1414;
    }
    jjj = jk;
    nukjl = kisblk - 8;
    FEM_DO_SAFE(jl, 2, mnp) {
      nukjl += 8;
      FEM_DO_SAFE(jm, jk1, jk2) {
        if (ivarb(jm) != ivarb(nukjl + 5)) {
          goto statement_1897;
        }
        if (jm > jjj) {
          goto statement_1898;
        }
        jjj = jm;
        goto statement_1898;
        statement_1897:;
      }
      stoptp(cmn);
      statement_1898:;
    }
    if (jjj == jk) {
      goto statement_1414;
    }
    mnp = ivarb(jk);
    nnn = jk - jjj;
    FEM_DO_SAFE(jn, 1, nnn) {
      jni = jk - jn + 1;
      ivarb(jni) = ivarb(jni - 1);
    }
    ivarb(jjj) = mnp;
    goto statement_1414;
    statement_1888:
    mkk = mkk - mnp + ijk;
    mjump = mkk;
    nukm = kisblk - 8;
    FEM_DO_SAFE(jl, 1, mnp) {
      nukm += 8;
      if (ivarb(nukm + 5) == 0) {
        goto statement_1893;
      }
      mjump++;
      ivarb(mjump) = ivarb(nukm + 5);
      statement_1893:;
    }
    statement_1414:;
  }
  if (mkk == 0) {
    goto statement_8811;
  }
  statement_1997:
  mkk++;
  if (mkk > jk2) {
    goto statement_8811;
  }
  nfun = ivarb(mkk);
  nuki = kisblk + nfun * 8 - 8;
  if (ivarb(nuki + 4) > 0) {
    goto statement_1997;
  }
  statement_4141:
  infir = fem::iabs(ivarb(nuki + 1));
  inlst = fem::iabs(ivarb(nuki + 9)) - 1;
  if (nfun == nuk) {
    inlst = nsu;
  }
  nom = 0;
  FEM_DO_SAFE(j1, infir, inlst) {
    namin = ivarb(kalksu + j1);
    FEM_DO_SAFE(j2, 1, nsup) {
      ndx2 = kspvar + j2;
      if (namin != ivarb(ndx2)) {
        goto statement_4667;
      }
      if (ivarb(kinsup + j2) != 0) {
        goto statement_4556;
      }
      if (nom > 0) {
        goto statement_4343;
      }
      nom = 1;
      kargsa++;
      ivarb(kargsa) = -nfun;
      ivarb(nuki + 1) = -ivarb(nuki + 1);
      statement_4343:
      kargsa++;
      ivarb(kargsa) = j2;
      ivarb(kiuty + 8) = kargsa;
      if (kargsa - kivarb < lstat(66)) {
        goto statement_4556;
      }
      kill = 122;
      lstat(19) = 4343;
      lstat(16) = lstat(66);
      lstat(17) = 6;
      goto statement_9000;
      statement_4667:;
    }
    statement_4556:;
  }
  i = 0;
  goto statement_6677;
  statement_8811:
  ngp = 0;
  i = 0;
  nukj = kisblk - 8;
  FEM_DO_SAFE(jj, 1, nuk) {
    nukj += 8;
    if (ivarb(nukj + 4) > 0) {
      goto statement_8822;
    }
    ij9 = fem::iabs(ivarb(nukj + 9));
    if (jj == nuk) {
      ij9 = nsu + 1;
    }
    ij = ij9 - fem::iabs(ivarb(nukj + 1));
    if (ij <= ngp) {
      goto statement_8822;
    }
    ngp = ij;
    nfun = jj;
    statement_8822:;
  }
  nuki = kisblk + nfun * 8 - 8;
  goto statement_4141;
  statement_2254:
  if (mins < nsup) {
    goto statement_9200;
  }
  nj = lstat(64) + nsup;
  ktab = nuk + nj;
  if (ktab > lstat(68)) {
    goto statement_7104;
  }
  kofsce = ktab;
  sptacs(4) = kofsce;
  kaliu = klntab + nuk;
  sptacs(11) = kaliu;
  kspvar = kaliu + lstat(64);
  ndx1 = klntab + ktab + 1;
  ndx2 = klntab + nj + 1;
  FEM_DO_SAFE(i, 1, nj) {
    ivarb(ndx1 - i) = ivarb(ndx2 - i);
  }
  nuki = kisblk - 8;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    k = klntab + ivarb(nuki + 4);
    ivarb(k) = sptacs(katcs + i);
  }
  if (iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6, "('  $$$ ILNTAB $$$ =',/(5x,15i8))");
      FEM_DO_SAFE(i, 1, nuk) {
        wloop, ivarb(klntab + i);
      }
    }
  }
  //C                                                 $$$  FORM TABLES  $$$ M37.1855
  if (nsup == 0) {
    goto statement_21100;
  }
  i = 1;
  statement_5577:
  j = ivarb(kjsup + i);
  k = ivarb(kksup + i);
  if (j < 0) {
    goto statement_2116;
  }
  k1 = k;
  if (k < 0) {
    k = -k;
  }
  FEM_DOSTEP(n, j, k, 3) {
    if (ivarb(n + 1) < 0) {
      goto statement_2113;
    }
    if (k1 < 0 && ivarb(n + 1) != 1) {
      goto statement_2113;
    }
    nivarb = ivarb(n + 3);
    FEM_DO_SAFE(m, 1, ktab) {
      ndx2 = klntab + m;
      if (nivarb == ivarb(ndx2)) {
        goto statement_2175;
      }
    }
    kill = 143;
    bus1 = texvec(nivarb);
    bus2 = texvec(ivarb(kspvar + i));
    lstat(19) = 2115;
    goto statement_9000;
    statement_2175:
    ivarb(n + 3) = m;
    statement_2113:;
  }
  goto statement_2111;
  statement_2116:
  j = -j;
  if (ivarb(j + 4) > 1) {
    goto statement_7162;
  }
  if (ivarb(j + 4) == 1) {
    ivarb(j + 4) = 0;
  }
  ivarb(j + 4) = -ivarb(j + 4);
  goto statement_7165;
  statement_7162:
  FEM_DO_SAFE(m, 1, ktab) {
    ndx2 = klntab + m;
    if (ivarb(j + 4) == ivarb(ndx2)) {
      goto statement_2719;
    }
  }
  kill = 143;
  bus1 = texvec(ivarb(j + 4));
  bus2 = texvec(ivarb(kspvar + i));
  lstat(19) = 2119;
  goto statement_9000;
  statement_2719:
  ivarb(j + 4) = m;
  statement_7165:
  if (ivarb(j + 3) > 1 || ivarb(j + 3) ==  - 9999) {
    goto statement_7163;
  }
  if (ivarb(j + 3) == 1) {
    ivarb(j + 3) = 0;
  }
  ivarb(j + 3) = -ivarb(j + 3);
  goto statement_7161;
  statement_7163:
  FEM_DO_SAFE(m, 1, ktab) {
    ndx2 = klntab + m;
    if (ivarb(j + 3) == ivarb(ndx2)) {
      goto statement_2199;
    }
  }
  if (k == 58 && ivarb(j + 3) ==  - 9999) {
    goto statement_7161;
  }
  kill = 143;
  bus1 = texvec(ivarb(j + 3));
  bus2 = texvec(ivarb(kspvar + i));
  lstat(19) = 2192;
  goto statement_9000;
  statement_2199:
  ivarb(j + 3) = m;
  statement_7161:
  jk = ivarb(j + 2);
  jm = ivarb(j + 1);
  FEM_DO_SAFE(n, jm, jk) {
    ndx1 = kalksu + n;
    if (ivarb(ndx1) != 1) {
      goto statement_1171;
    }
    ivarb(ndx1) = 0;
    goto statement_1170;
    statement_1171:
    FEM_DO_SAFE(m, 1, ktab) {
      ndx2 = klntab + m;
      if (ivarb(ndx1) == ivarb(ndx2)) {
        goto statement_1199;
      }
    }
    kill = 143;
    bus1 = texvec(ivarb(ndx1));
    bus2 = texvec(ivarb(kspvar + i));
    lstat(19) = 1190;
    goto statement_9000;
    statement_1199:
    ivarb(ndx1) = m;
    statement_1170:;
  }
  if (k != 50) {
    goto statement_2111;
  }
  nn = ivarb(j);
  mm = kxtcs + nuk + i + lstat(64);
  sptacs(mm) = sptacs(nn);
  statement_2111:
  i++;
  if (i <= nsup) {
    goto statement_5577;
  }
  if (nchain != 18) {
    goto statement_21100;
  }
  ndx1 = kinsup + nsup;
  ivarb(ndx1) = -1;
  if (nsup == konsup + 1) {
    goto statement_9000;
  }
  ivarb(ndx1 - 1) = nsup;
  goto statement_9000;
  statement_9200:
  kill = 500;
  write(lunit6,
    "('  THE CASE WILL BE KILLED BECAUSE THERE ARE',"
    "' SOME LOOPS IN SUPPLEMENTAL VARIABLES OR DEVICES. ',/,"
    "'  THIS IS NOT ALLOWED.    THE LOOPED SUPPLEMENTAL',"
    "'  BLOCKS ARE AS FOLLOWS :')");
  j = 0;
  FEM_DO_SAFE(i, 1, nsup) {
    if (ivarb(kinsup + i) != 0) {
      goto statement_9208;
    }
    j++;
    ndx1 = ivarb(kspvar + i);
    write(lunit6, "('  ********',2x,i5,4x,a6,'  ********')"), j, texvec(ndx1);
    statement_9208:;
  }
  goto statement_9000;
  statement_21100:
  FEM_DO_SAFE(i, 1, nsu) {
    ndx3 = kalksu + i;
    FEM_DO_SAFE(j, 1, ktab) {
      ndx2 = klntab + j;
      if (ivarb(ndx3) == ivarb(ndx2)) {
        goto statement_213;
      }
    }
    nukk = kisblk - 8;
    FEM_DO_SAFE(k, 1, nuk) {
      nukk += 8;
      ndx1 = fem::iabs(ivarb(nukk + 1));
      ndx2 = fem::iabs(ivarb(nukk + 9)) - 1;
      if (k == nuk) {
        ndx2 = nsu;
      }
      if (i >= ndx1 && i <= ndx2) {
        goto statement_469;
      }
    }
    stoptp(cmn);
    statement_469:
    k = ivarb(nukk + 4);
    kill = 121;
    lstat(19) = 472;
    bus1 = texvec(ivarb(ndx3));
    ndx1 = klntab + k;
    bus2 = texvec(ivarb(klntab + k));
    write(lunit6,
      "('0 ERROR.  ENTRY =',a6,'= REFERENCED IN FUNCTION =',a6,"
      "'= IS UNDEFINED.')"),
      bus1, bus2;
    goto statement_9000;
    statement_213:
    ivarb(ndx3) = j;
  }
  nuki = kisblk - 8;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    m = ivarb(nuki + 4);
    nukm = kisblk + m * 8 - 8;
    nukr = krsblk + m * 4 - 4;
    ivarb(nukm + 5) = 0;
    ivarb(nukm + 6) = 0;
    sptacs(nukr + 2) = -fltinf;
    sptacs(nukr + 3) = fltinf;
    FEM_DO_SAFE(L, 1, 2) {
      if (L == 2) {
        goto statement_50;
      }
      n6 = sptacs(kawkcs + i);
      goto statement_51;
      statement_50:
      n6 = sptacs(kbwkcs + i);
      statement_51:
      if (n6 == 1) {
        goto statement_20;
      }
      FEM_DO_SAFE(j, 1, ktab) {
        if (n6 == ivarb(klntab + j)) {
          goto statement_40;
        }
      }
      kill = 131;
      bus1 = texvec(ivarb(klntab + m));
      bus6 = texvec(n6);
      lstat(14) = L;
      lstat(19) = 30;
      write(lunit6,
        "(' ERROR.  NAME OF LIMIT  ',a6,'  AT BLOCK = ',a6,"
        "'  IS UNIDENTIFIABLE.')"),
        bus6, bus1;
      goto statement_9000;
      statement_40:
      if (L == 2) {
        goto statement_41;
      }
      ivarb(nukm + 5) = j;
      goto statement_20;
      statement_41:
      ivarb(nukm + 6) = j;
      statement_20:;
    }
    if (sptacs(kxar + i) == 0.0f && sptacs(kxai + i) == 0.0f) {
      goto statement_10;
    }
    sptacs(nukr + 2) = sptacs(kxar + i);
    sptacs(nukr + 3) = sptacs(kxai + i);
    statement_10:;
  }
  if (iprsup < 2) {
    goto statement_1006;
  }
  write(lunit6, "('         N    IFLS   ILIM1   ILIM2   NUKSP')");
  nukn = kisblk - 8;
  FEM_DO_SAFE(n, 1, nuk) {
    nukn += 8;
    write(lunit6, "(2x,5i8)"), n, ivarb(nukn + 4), ivarb(nukn + 5),
      ivarb(nukn + 6), ivarb(nukn + 7);
  }
  {
    write_loop wloop(cmn, lunit6, "('0',17x,'KSU',/(2x,2i8))");
    FEM_DO_SAFE(n, 1, nsu) {
      wloop, n, ivarb(kalksu + n);
    }
  }
  if (nsup == 0) {
    goto statement_1012;
  }
  write(lunit6,
    "('  KARG = ',i8,/,'       N  IOPSUP  IFNSUP',"
    "'  IRGSUP    IDEV     KDJ     KDK  ILDEV1  ILDEV2')"),
    karg;
  FEM_DO_SAFE(i, 1, nsup) {
    n1 = ivarb(kjsup + i);
    if (n1 < 0) {
      goto statement_2014;
    }
    n2 = ivarb(kksup + i);
    {
      write_loop wloop(cmn, lunit6, "(4i8)");
      FEM_DOSTEP(n, n1, n2, 3) {
        wloop, n, ivarb(n + 1), ivarb(n + 2), ivarb(n + 2);
      }
    }
    goto statement_2034;
    statement_2014:
    n1 = -n1;
    write(lunit6, "(i8,24x,5i8)"), n1, ivarb(n1), ivarb(n1 + 1),
      ivarb(n1 + 2), ivarb(n1 + 3), ivarb(n1 + 4);
    statement_2034:;
  }
  if (nsudv < lstat(63)) {
    {
      write_loop wloop(cmn, lunit6, "('0',11x,'ALKSU    KSUS',/(1x,3i8))");
      FEM_DO_SAFE(n, nsudv + 1, lstat(63)) {
        wloop, n, ivarb(kalksu + n), ivarb(kksus + n);
      }
    }
  }
  statement_1012:
  {
    write_loop wloop(cmn, lunit6, "('0 KTAB = ',i5,/,9x,' ILNTAB',/(1x,2i8))");
    wloop, ktab;
    FEM_DO_SAFE(n, 1, ktab) {
      wloop, n, ivarb(klntab + n);
    }
  }
  write(lunit6, "('   NUK  = ',i6)"), nuk;
  statement_1006:
  n2 = 0;
  min = nuk + niu;
  nkn = nuk + lstat(64);
  FEM_DO_SAFE(k, 1, ktab) {
    if (k > min && k <= nkn) {
      goto statement_2046;
    }
    ndx1 = klntab + k;
    n6 = ivarb(klntab + k);
    n1 = k + 1;
    FEM_DO_SAFE(j, n1, ktab) {
      ndx1 = klntab + j;
      if (ivarb(ndx1) != n6) {
        goto statement_2045;
      }
      n2++;
      bus6 = texvec(n6);
      write(lunit6,
        "(/,' ENTRIES NUMBER',i5,'   AND',i5,"
        "'   OF THE TACS NAME-VECTOR BOTH HAVE CONTENTS  ''',a6,''' .')"),
        k, j, bus6;
      statement_2045:;
    }
    statement_2046:;
  }
  if (n2 == 0) {
    goto statement_2072;
  }
  kill = 189;
  lstat(15) = n2;
  lstat(19) = 2059;
  goto statement_9000;
  //C                            *****  OUTPUT REQUEST  *****               M38.1007
  statement_2072:
  if (ivarb(kiuty + 6) != 9999) {
    goto statement_153;
  }
  ioutcs = 0;
  lstat(59) = ioutcs;
  n1 = nuk + niu;
  n2 = nuk + lstat(64);
  FEM_DO_SAFE(i, 1, ktab) {
    if (i > n1 && i <= n2) {
      goto statement_157;
    }
    ioutcs++;
    lstat(59) = ioutcs;
    ndx1 = kjout + ioutcs;
    ivarb(ndx1) = i;
    statement_157:;
  }
  goto statement_3072;
  statement_153:
  jr = 0;
  if (ioutcs <= 0) {
    goto statement_3712;
  }
  FEM_DO_SAFE(i, 1, ioutcs) {
    j8 = ivarb(kjout + i);
    FEM_DO_SAFE(j, 1, ktab) {
      if (j8 == ivarb(klntab + j)) {
        goto statement_229;
      }
    }
    if (cmn.noutpr == 0) {
      write(lunit6,
        "(/,'   THE USER HAS REQUESTED A TACS VARIABLE NAMED \"',a6,"
        "'\" FOR OUTPUT PURPOSES. BUT THIS IS A NON-EXISTANT TACS ',/,"
        "' VARIABLE, SO THE REQUEST WILL BE DISREGARDED. ')"),
        texvec(j8);
    }
    goto statement_109;
    statement_229:
    jr++;
    ndx1 = kjout + jr;
    ivarb(ndx1) = j;
    statement_109:;
  }
  statement_3712:
  ioutcs = jr;
  lstat(59) = ioutcs;
  if (ioutcs > 0) {
    goto statement_111;
  }
  if (cmn.tmax <= 0.0f) {
    goto statement_111;
  }
  if (cmn.ntcsex + cmn.nstacs > 0) {
    goto statement_111;
  }
  kill = 140;
  lstat(19) = 23153;
  goto statement_9000;
  statement_111:
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "('0PROGRAM OUTPUT WILL BE PREPARED FOR NODES 0',/(1x,16i8))");
      FEM_DO_SAFE(i, 1, ioutcs) {
        wloop, ivarb(kjout + i);
      }
    }
  }
  //C                             ******   INITIAL CONDITION   **********   M38.1078
  statement_3072:
  if (kxic == 0) {
    goto statement_231;
  }
  kxtcs2 = kxtcs + lstat(68);
  FEM_DO_SAFE(i, 1, kxic) {
    sptacs(kawkcs + i) = sptacs(kxtcs + i);
    sptacs(kxtcs + i) = 0.0f;
  }
  jr = 0;
  FEM_DO_SAFE(i, 1, kxic) {
    j8 = sptacs(kawkcs + i);
    FEM_DO_SAFE(k, 1, ktab) {
      if (j8 == ivarb(klntab + k)) {
        goto statement_412;
      }
    }
    write(lunit6,
      "(' $$$$$ IGNOR THE INITIAL CONDITION CARD SINCE',' NO SUCH NAME ( ',a6,"
      "' ) IN THE TACS TABLE $$$$$ ')"),
      texvec(j8);
    goto statement_4111;
    statement_412:
    jr++;
    sptacs(kxtcs + k) = sptacs(kxtcs2 + i);
    statement_4111:;
  }
  move0(sptacs, kxtcs2 + 1, kxic);
  kxic = jr;
  lstat(58) = kxic;
  if (kxic == 0 || iprsup < 2) {
    goto statement_231;
  }
  FEM_DO_SAFE(i, 1, ktab) {
    ndx1 = ivarb(klntab + i);
    if (sptacs(kxtcs + i) != 0.0f) {
      write(lunit6,
        "('  USER-DEFINED INITIAL CONDITION  ',a6,e20.8)"), texvec(ndx1),
        sptacs(kxtcs + i);
    }
  }
  statement_231:
  if (cmn.iplot < 0) {
    goto statement_9000;
  }
  n1 = 0;
  {
    write_loop wloop(cmn, lunit4, fem::unformatted);
    wloop, date1, tclock, maxbus, ioutcs, n1, n1;
    FEM_DO_SAFE(i, 1, maxbus) {
      wloop, texvec(i);
    }
  }
  n2 = kcolcs + 1;
  n3 = kcolcs + ioutcs;
  FEM_DO_SAFE(i, n2, n3) {
    n1++;
    j = ivarb(kjout + n1);
    ivarb(i) = ivarb(klntab + j);
  }
  {
    write_loop wloop(cmn, lunit4, fem::unformatted);
    FEM_DO_SAFE(i, n2, n3) {
      wloop, ivarb(i);
    }
  }
  statement_9000:
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE TACS1B.\"')");
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct tacs1_save
{
  arr<fem::str<8> > sbn;
  fem::str<8> sminus;
  fem::str<8> splus;
  arr<fem::str<8> > stacs;

  tacs1_save() :
    sbn(dimension(2), fem::fill0),
    sminus(fem::char0),
    splus(fem::char0),
    stacs(dimension(11), fem::fill0)
  {}
};

void tacs1(
  common& cmn) try
{
  FEM_CMN_SVE(tacs1);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& blank = cmn.blank;
  const auto& texcol = cmn.texcol;
  const auto& texta6 = cmn.texta6;
  const auto& abuff = cmn.abuff;
  double& deltat = cmn.deltat;
  double& fltinf = cmn.fltinf;
  auto& voltbc = cmn.voltbc;
  double& pu = cmn.pu;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  int& ltacst = cmn.ltacst;
  int& noutpr = cmn.noutpr;
  int& ktab = cmn.ktab;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  auto& sptacs = cmn.sptacs;
  const auto& texvec = cmn.texvec;
  const auto& kmswit = cmn.kmswit;
  const auto& bus = cmn.bus;
  //arr_ref<int> ivarb(cmn.ivarb, dimension(90000));
  const auto& etac = cmn.etac;
  const auto& ismtac = cmn.ismtac;
  //
  auto& sbn = sve.sbn;
  fem::str<8>& sminus = sve.sminus;
  fem::str<8>& splus = sve.splus;
 auto& stacs = sve.stacs;

  if (is_called_first_time) {
    stacs(1) = "TIMEX ";
    stacs(2) = "ISTEP ";
    stacs(3) = "DELTAT";
    stacs(4) = "FREQHZ";
    stacs(5) = "OMEGAR";
    stacs(6) = "ZERO  ";
    stacs(7) = "PLUS1 ";
    stacs(8) = "MINUS1";
    stacs(9) = "UNITY ";
    stacs(10) = "INFNTY";
    stacs(11) = "PI    ";
    splus = "+";
    sminus = "-";
    sbn(1) = "NUM.  ";
    sbn(2) = "DEN.  ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  //int kcolcs = fem::int0;
  //int kspvar = fem::int0;
  //int katcs = fem::int0;
  //int kprsup = fem::int0;
  //int kivarb = fem::int0;
  //int kaliu = fem::int0;
  //int kiuty = fem::int0;
  //int kawkcs = fem::int0;
  //int kxtcs = fem::int0;
  //int kjout = fem::int0;
  //int kud1 = fem::int0;
  //int kxar = fem::int0;
  //int klntab = fem::int0;
  //int kisblk = fem::int0;
  //int krsblk = fem::int0;
  //int kksus = fem::int0;
  //int kalksu = fem::int0;
  //int kinsup = fem::int0;
  //int nuk = fem::int0;
  //int nsu = fem::int0;
  //int niu = fem::int0;
  //int nsup = fem::int0;
  //int karg = fem::int0;
  //int kpar = fem::int0;
  //int kxic = fem::int0;
  //int ioutcs = fem::int0;
  //int nsudv = fem::int0;
  int i = fem::int0;
  int ndy5 = fem::int0;
  int kxai = fem::int0;
  int kbwkcs = fem::int0;
  int kbtcs = fem::int0;
  int n1 = fem::int0;
  int koncur = fem::int0;
  int isour = fem::int0;
  int n23 = fem::int0;
  fem::str<8> alnm1 = fem::char0;
  int n23m = fem::int0;
  double d1 = fem::double0;
  int nuki = fem::int0;
  int nukr = fem::int0;
  int niunrs = fem::int0;
  int ll0 = fem::int0;
  int ll1 = fem::int0;
  int ll2 = fem::int0;
  int ll3 = fem::int0;
  int n = fem::int0;
  arr_1d<13, fem::str<8> > dumj(fem::fill0);
  fem::str<8> alnode = fem::char0;
  arr_1d<5, fem::str<8> > alph(fem::fill0);
  arr_1d<3, double> dum(fem::fill0);
  fem::str<8> alnm2 = fem::char0;
  int ndx1 = fem::int0;
  int mm = fem::int0;
  int ij = fem::int0;
  int j = fem::int0;
  int kcc = fem::int0;
  int n3 = fem::int0;
  int j1 = fem::int0;
  int ndx3 = fem::int0;
  int ijk = fem::int0;
  int j2 = fem::int0;
  int ndx2 = fem::int0;
  int n22 = fem::int0;
  int is = fem::int0;
  int konsce = fem::int0;
  int konsup = fem::int0;
  int ndx5 = fem::int0;
  int kjsup = fem::int0;
  int kksup = fem::int0;
  int n2 = fem::int0;
  double prx = fem::double0;
  double pru = fem::double0;
  int k = fem::int0;
  int m = fem::int0;
  int jr = fem::int0;
  static const char* format_2306 = "(1x,i3,1x,a8,i6,5e15.6)";
  static const char* format_4455 = "('+IGNOR THE ILLEGAL CARD.')";

  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;
  auto& kcolcs = isptacs(5);
  auto& kspvar = isptacs(6);
  auto& katcs =  isptacs(7);
  auto& kprsup = isptacs(9);
  auto& kivarb = isptacs(10);
  auto& kaliu =  isptacs(11);
  auto& kiuty =  isptacs(13);
  auto& kawkcs = isptacs(15);
  auto& kxtcs =  isptacs(17);
  auto& kjout =  isptacs(12);
  auto& kud1 =   isptacs(14);
  auto& kxar =   isptacs(16);
  auto& klntab = isptacs(18);
  auto& kisblk = isptacs(19);
  auto& krsblk = isptacs(20);
  auto& kksus =  isptacs(21);
  auto& kalksu = isptacs(22);
  auto& kinsup = isptacs(23);

  auto& nuk =  lstat(51);
  auto& nsu =  lstat(53);
  auto& niu =  lstat(54);
  auto& nsup = lstat(55);
  auto& karg = lstat(56);
  auto& kpar = lstat(57);
  auto& kxic = lstat(58);
  auto& ioutcs = lstat(59);
  auto& nsudv = lstat(60);
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE TACS1.\"')");
  }
  if (iprsup > 0) {
    {
      write_loop wloop(cmn, lunit6,
        "(6x,'LTACST, (LSTACS(I), I=1, 8) ... .  ',/,9i10,/)");
      wloop, ltacst;
      FEM_DO_SAFE(i, 61, 68) {
        wloop, lstat(i);
      }
    }
  }
  if (nchain == 1) {
    goto statement_1001;
  }
  ndy5 = kud1 + (niu - 12) * 5;
  goto statement_2210;
  statement_1001:
  krsblk = 30;
  sptacs(20) = krsblk;
  kud1 = krsblk + lstat(61) * 4;
  sptacs(14) = kud1;
  kprsup = kud1 + lstat(64) * 5;
  sptacs(9) = kprsup;
  kxar = kprsup + lstat(67);
  sptacs(16) = kxar;
  kxai = kxar + lstat(68);
  kxtcs = kxai + lstat(68);
  sptacs(17) = kxtcs;
  kawkcs = kxtcs + lstat(68) * 2;
  sptacs(15) = kawkcs;
  kbwkcs = kawkcs + lstat(68);
  katcs = kbwkcs + lstat(68);
  sptacs(7) = katcs;
  kbtcs = katcs + lstat(62);
  kisblk = (kbtcs + lstat(62)) * nbyte(3) / nbyte(4) + 1;
  sptacs(19) = kisblk;
  kksus = kisblk + lstat(61) * 8;
  sptacs(21) = kksus;
  kalksu = kksus + lstat(63);
  sptacs(22) = kalksu;
  kiuty = kalksu + lstat(63);
  sptacs(13) = kiuty;
  kinsup = kiuty + lstat(64);
  sptacs(23) = kinsup;
  kivarb = kinsup + lstat(65) * 3;
  sptacs(10) = kivarb;
  klntab = kivarb + lstat(66);
  sptacs(18) = klntab;
  kjout = klntab + lstat(68);
  sptacs(12) = kjout;
  kcolcs = kjout + lstat(68);
  n1 = (kcolcs + lstat(62)) * nbyte(4) / nbyte(3) + 1;
  kaliu = klntab;
  sptacs(11) = kaliu;
  kspvar = kaliu + lstat(64);
  sptacs(6) = kspvar;
  if (iprsup < 2) {
    goto statement_7811;
  }
  write(lunit6,
    "('  USE CELLS  N1 = ',i8,/,'  KISBLK = ',i5,'  KRSBLK = ',i5,"
    "'  KKSUS  = ',i5,'  KALKSU = ',i5,'  KIUTY  = ',i5,'  KUD1   = ',i5,"
    "'  KINSUP = ',i5,'  KIVARB = ',i5,/,'  KPRSUP = ',i5,'  KAWKCS = ',i5,"
    "'  KXAR   = ',i5,'  KXTCS  = ',i5,'  KLNTAB = ',i5,'  KATCS  = ',i5,"
    "'  KCOLCS = ',i5,'  KJOUT  = ',i5,/)"),
    n1, kisblk, krsblk, kksus, kalksu, kiuty, kud1, kinsup, kivarb,
    kprsup, kawkcs, kxar, kxtcs, klntab, katcs, kcolcs, kjout;
  statement_7811:
  lstat(39) = n1;
  koncur = 0;
  if (n1 < ltacst) {
    goto statement_781;
  }
  kill = 1;
  lstat(19) = 781;
  lstat(16) = 19;
  goto statement_9000;
  statement_781:
  FEM_DO_SAFE(i, 1, 8) {
    lstat(i) = lstat(i + 60);
  }
  FEM_DO_SAFE(i, 30, ltacst) {
    sptacs(i) = 0.0f;
  }
  isour = lstat(4);
  FEM_DO_SAFE(i, 1, isour) {
    n23 = 0;
    if (i > 11) {
      goto statement_3388;
    }
    alnm1 = stacs(i);
    namea6(cmn, alnm1, n23);
    statement_3388:
    ivarb(kaliu + i) = n23m;
    ivarb(kiuty + i) = 0;
  }
  ivarb(kiuty + 3) = 20;
  sptacs(29) = fltinf;
  if (pu == fltinf) {
    goto statement_4499;
  }
  sptacs(29) = pu;
  ivarb(kiuty + 2) = nuk;
  ivarb(kiuty + 3) = 0;
  if (pu <= 0.f) {
    ivarb(kiuty + 3) = nuk;
  }
  statement_4499:
  d1 = alog1z(fltinf);
  ivarb(kiuty + 11) = d1 + 0.5f;
  //C                                                        $$$  INPUT  $$$M13. 364
  cmn.lbstac = locf(ismtac(1)) - locf(etac(1));
  cmn.ntotac = 0;
  nsu = 0;
  lstat(53) = nsu;
  nsudv = lstat(63);
  lstat(60) = nsudv;
  nuk = 0;
  lstat(51) = nuk;
  nuki = kisblk - 8;
  nukr = krsblk - 4;
  niu = 11;
  lstat(54) = niu;
  ndy5 = kud1 - 5;
  niunrs = 12;
  ivarb(kiuty + 1) = niunrs;
  nsup = 0;
  lstat(55) = nsup;
  karg = kivarb - 3;
  lstat(56) = karg;
  kpar = 0;
  lstat(57) = kpar;
  ioutcs = 0;
  lstat(59) = ioutcs;
  kxic = 0;
  lstat(58) = kxic;
  ll0 = 0;
  ll1 = 1;
  ll2 = 2;
  ll3 = 3;
  goto statement_2210;
  statement_100:
  cimage(cmn);
  statement_2210:
  if (kill > 0) {
    goto statement_9000;
  }
  if (kolbeg > 0) {
    goto statement_6574;
  }
  read(abuff, "(i2)"), n;
  statement_1234:
  if (n == 88 || n == 98 || n == 99) {
    goto statement_113;
  }
  if (n == 33) {
    goto statement_2222;
  }
  if (n == 77) {
    goto statement_3333;
  }
  if (n > 10 && n < 25) {
    goto statement_1066;
  }
  if (n > 89 && n < 94) {
    goto statement_1066;
  }
  if (kolbeg > 0) {
    goto statement_1111;
  }
  {
    read_loop rloop(abuff(1), "(10x,5(1x,a6,1x))");
    FEM_DO_SAFE(i, 1, 5) {
      rloop, dumj(i);
    }
  }
  {
    read_loop rloop(abuff(1), "(i2,a6,2x,5(a1,7x),3e6.0,2a6)");
    rloop, n, alnode;
    FEM_DO_SAFE(i, 1, 5) {
      rloop, alph(i);
    }
    FEM_DO_SAFE(i, 1, 3) {
      rloop, dum(i);
    }
    rloop, alnm1, alnm2;
  }
  goto statement_6590;
  statement_6574:
  nfrfld = 1;
  frefld(cmn, voltbc(1));
  n = voltbc(1);
  goto statement_1234;
  statement_1111:
  nright = -1;
  freone(cmn, d1);
  alnode = texta6(1);
  FEM_DO_SAFE(i, 1, 5) {
    statement_6576:
    bus1 = texcol(kolbeg);
    if (bus1 != blank) {
      goto statement_6577;
    }
    kolbeg++;
    goto statement_6576;
    statement_6577:
    if (bus1 == sminus) {
      goto statement_6578;
    }
    if (bus1 == splus) {
      goto statement_6578;
    }
    if (bus1 == cmn.csepar) {
      goto statement_6584;
    }
    alph(i) = splus;
    goto statement_6581;
    statement_6578:
    alph(i) = bus1;
    kolbeg++;
    statement_6581:
    freone(cmn, d1);
    dumj(i) = texta6(1);
    goto statement_6587;
    statement_6584:
    alph(i) = blank;
    dumj(i) = blank;
    kolbeg++;
    statement_6587:;
  }
  nright = 0;
  nfrfld = 3;
  frefld(cmn, dum(1));
  nright = -1;
  nfrfld = 2;
  freone(cmn, d1);
  alnm1 = texta6(1);
  alnm2 = texta6(2);
  nright = 0;
  statement_6590:
  n1 = 0;
  FEM_DO_SAFE(i, 1, 5) {
    if (dumj(i) == blank) {
      goto statement_136;
    }
    if (alph(i) == sminus) {
      goto statement_135;
    }
    if (alph(i) == splus) {
      goto statement_135;
    }
    kill = 137;
    lstat(14) = i;
    bus1 = alnode;
    cmn.bus2 = dumj(i);
    cmn.bus3 = alph(i);
    lstat(19) = 133;
    goto statement_9000;
    statement_135:
    n1 = 1;
    statement_136:;
  }
  if (n1 > 0) {
    goto statement_139;
  }
  if (alnode != blank) {
    goto statement_139;
  }
  if (n != 1) {
    goto statement_1399;
  }
  ivarb(kiuty + 6) = 9999;
  if (noutpr == 0) {
    write(kunit6, "('+REQUEST FOR OUTPUT OF ALL TACS VARIABLES.')");
  }
  goto statement_100;
  statement_1399:
  if (n != 0) {
    goto statement_139;
  }
  if (noutpr == 0) {
    write(kunit6, "('+BLANK CARD TERMINATING ALL TACS DATA CARDS .')");
  }
  goto statement_101;
  statement_139:
  if (dum(1) == 0.0f) {
    dum(1) = 1.0f;
  }
  if (noutpr == 0) {
    write(kunit6,
      "('+TACS FUNCTION ''',a6,''', ORDER',i2,'.',e14.4)"), alnode,
      n, dum(1);
  }
  if (n < 8 && n >= 0) {
    goto statement_118;
  }
  kill = 115;
  lstat(19) = 118;
  if (noutpr == 0) {
    write(lunit6,
      "('0LIMIT.  DIMENSIONS IN TACS HAVE NOT BEEN SET TO ACCEPT AN ORDER GREA"
      "TER THAN  7. ',/,"
      "' IT IS SUGGESTED TO BREAK THIS MONSTRUOUS BLOCK INTO A SET OF SMALLER "
      "ONES IN CASCADE.')");
  }
  statement_7433:
  bus1 = alnode;
  lstat(14) = n;
  goto statement_9000;
  statement_118:
  nuk++;
  lstat(51) = nuk;
  nuki += 8;
  nukr += 4;
  if (nuk <= lstat(61)) {
    goto statement_8101;
  }
  kill = 122;
  lstat(16) = lstat(61);
  lstat(17) = 1;
  lstat(19) = 8101;
  goto statement_9000;
  statement_8101:
  ndx1 = katcs + nuk;
  n23 = 0;
  namea6(cmn, alnode, n23);
  sptacs(ndx1) = n23;
  ivarb(nuki + 1) = nsu + 1;
  ivarb(nuki + 4) = 0;
  n1 = 0;
  FEM_DO_SAFE(i, 1, 5) {
    if (dumj(i) == blank) {
      goto statement_7413;
    }
    n1++;
    nsu++;
    lstat(53) = nsu;
    if (nsu <= nsudv) {
      goto statement_8102;
    }
    kill = 122;
    lstat(16) = lstat(63);
    lstat(17) = 3;
    lstat(19) = 8102;
    goto statement_9000;
    statement_8102:
    ndx1 = kalksu + nsu;
    n23 = 0;
    alnode = dumj(i);
    namea6(cmn, alnode, n23);
    ivarb(ndx1) = n23;
    ndx1 = kksus + nsu;
    ivarb(ndx1) = 1;
    if (alph(i) == sminus) {
      ivarb(ndx1) = -1;
    }
    if (i == 5) {
      goto statement_7413;
    }
    mm = i + 1;
    FEM_DO_SAFE(ij, mm, 5) {
      if (dumj(i) != dumj(ij)) {
        goto statement_7418;
      }
      dumj(ij) = blank;
      ivarb(ndx1)++;
      if (alph(ij) == sminus) {
        ivarb(ndx1) = ivarb(ndx1) - 2;
      }
      statement_7418:;
    }
    if (ivarb(ndx1) != 0) {
      goto statement_7413;
    }
    nsu = nsu - 1;
    lstat(53) = nsu;
    n1 = n1 - 1;
    statement_7413:;
  }
  if (n1 > 0) {
    goto statement_7420;
  }
  kill = 136;
  ndx1 = sptacs(katcs + nuk);
  bus1 = texvec(ndx1);
  lstat(14) = n;
  lstat(19) = 7420;
  write(lunit6, "(/,' ERROR.  NO INPUT NODE SPECIFIED. ')");
  goto statement_9000;
  statement_7420:
  if (n == 0) {
    goto statement_103;
  }
  sptacs(nukr + 1) = 999999.99f;
  j = kpar + 1;
  ivarb(nuki + 3) = j;
  kcc = n * 6;
  kpar = j + kcc + 3;
  lstat(57) = kpar;
  if (kpar <= lstat(67)) {
    goto statement_8103;
  }
  kill = 122;
  lstat(16) = lstat(67);
  lstat(17) = 7;
  lstat(19) = 8103;
  goto statement_9000;
  statement_103:
  sptacs(nukr + 1) = dum(1);
  ivarb(nuki + 3) = 0;
  statement_8103:
  ivarb(nuki + 2) = n + 1;
  ndx1 = kxar + nuk;
  sptacs(ndx1) = dum(2);
  ndx1 = kxai + nuk;
  sptacs(ndx1) = dum(3);
  ndx1 = kawkcs + nuk;
  n23 = 0;
  namea6(cmn, alnm1, n23);
  sptacs(ndx1) = n23;
  ndx1 = kbwkcs + nuk;
  n23 = 0;
  namea6(cmn, alnm2, n23);
  sptacs(ndx1) = n23;
  if (alnm1 != blank || alnm2 != blank || dum(2) != 0.0f || dum(3) != 0.0f) {
    ivarb(nuki + 4) = -1;
  }
  if (n == 0) {
    goto statement_100;
  }
  n3 = kcc;
  if (kcc > 18) {
    n3 = 18;
  }
  j1 = j + 1;
  ndx3 = kprsup + j1 + n3;
  ijk = 0;
  FEM_DO_SAFE(j2, j, j1) {
    cimage(cmn);
    ijk++;
    ndx1 = kprsup + j2;
    if (kolbeg > 0) {
      goto statement_6514;
    }
    ndx2 = kprsup + kpar;
    {
      read_loop rloop(abuff(1), "(8e10.0)");
      FEM_DOSTEP(i, ndx1, ndx2, 6) {
        rloop, sptacs(i);
      }
    }
    goto statement_6517;
    statement_6514:
    nfrfld = 1;
    n22 = n + 1;
    FEM_DO_SAFE(is, 1, n22) {
      frefld(cmn, sptacs(ndx1));
      ndx1 += 6;
    }
    ndx1 = kprsup + j2;
    statement_6517:
    if (noutpr == 0) {
      {
        write_loop wloop(cmn, kunit6, "('+  ',a6,4e10.2)");
        wloop, sbn(ijk);
        FEM_DOSTEP(i, ndx1, ndx3, 6) {
          wloop, sptacs(i);
        }
      }
    }
  }
  FEM_DOSTEP(i, j, kpar, 6) {
    ndx1 = kprsup + i;
    sptacs(ndx1 + 3) = sptacs(ndx1 + 1);
    if (sptacs(ndx1) == 0.0f) {
      goto statement_119;
    }
    sptacs(ndx1) = sptacs(ndx1) * dum(1);
    sptacs(ndx1 + 2) = sptacs(ndx1);
    goto statement_102;
    statement_119:
    if (i != kpar - 3 && i != j) {
      goto statement_102;
    }
    if (sptacs(ndx1 + 1) != 0.0f) {
      goto statement_102;
    }
    kill = 116;
    lstat(19) = 119;
    lstat(17) = 0;
    if (i == j && i != kpar - 3) {
      lstat(17) = 1;
    }
    goto statement_7433;
    statement_102:;
  }
  goto statement_100;
  statement_101:
  konsce = niu;
  konsup = nsup;
  sptacs(8) = konsup;
  if (nuk > 0) {
    goto statement_231;
  }
  nuk = 1;
  lstat(51) = nuk;
  nsu = 1;
  lstat(53) = nsu;
  sptacs(katcs + 1) = 1;
  ivarb(kisblk + 4) = 0;
  ivarb(kisblk + 1) = 1;
  ivarb(kalksu + 1) = 1;
  ivarb(kksus + 1) = 1;
  sptacs(krsblk + 1) = 1.0f;
  ivarb(kisblk + 3) = 0;
  ivarb(kisblk + 2) = 1;
  sptacs(kawkcs + 1) = 1;
  sptacs(kbwkcs + 1) = 1;
  statement_231:
  if (iprsup < 2) {
    goto statement_4444;
  }
  if (nuk == 0) {
    goto statement_2315;
  }
  write(lunit6, "(' NUK = ',i4,/,10x,' ALKSX    KSJ   KFST    KNI')"), nuk;
  nuki = kisblk - 8;
  FEM_DO_SAFE(n, 1, nuk) {
    nuki += 8;
    write(lunit6, "(2x,i4,2x,f8.0,3i7)"), n, sptacs(katcs + n), ivarb(
      nuki + 1), ivarb(nuki + 2), ivarb(nuki + 3);
  }
  {
    write_loop wloop(cmn, lunit6,
      "('0 NSU = ',i3,/,8x,'KSU    KSUS',/(1x,i3,1x,2i6))");
    wloop, nsu;
    FEM_DO_SAFE(n, 1, nsu) {
      wloop, n, ivarb(kalksu + n), ivarb(kksus + n);
    }
  }
  statement_2315:
  write(lunit6,
    "('0 NIU = ',i3,/,8x,'ALIU   IUTY',7x,'UD1',12x,'UD2',12x,'UD3',12x,'UD4',"
    "12x,'UD5')"),
    niu;
  ndx5 = kud1 - 5;
  FEM_DO_SAFE(n, 1, niu) {
    n1 = ivarb(kaliu + n);
    if (n > 11) {
      goto statement_2121;
    }
    write(lunit6, format_2306), n, texvec(n1);
    goto statement_2323;
    statement_2121:
    ndx5 += 5;
    write(lunit6, format_2306), n, texvec(n1), ivarb(kiuty + n),
      sptacs(ndx5 + 1), sptacs(ndx5 + 2), sptacs(ndx5 + 3), sptacs(ndx5 + 4),
      sptacs(ndx5 + 5);
    statement_2323:;
  }
  if (nsup == 0) {
    goto statement_4444;
  }
  {
    write_loop wloop(cmn, lunit6,
      "('0 NSUP=',i6,/,8x,'  SUPVAR    JSUP    KSUP',/(4i8))");
    wloop, nsup;
    FEM_DO_SAFE(n, 1, nsup) {
      wloop, n, ivarb(kspvar + n), ivarb(kjsup + n), ivarb(kksup + n);
    }
  }
  write(lunit6,
    "('  KARG = ',i8,/,'       N  IOPSUP  IFNSUP',"
    "'  IRGSUP    IDEV     KDJ     KDK  ILDEV1  ILDEV2')"),
    karg;
  FEM_DO_SAFE(i, 1, nsup) {
    n1 = ivarb(kjsup + i);
    if (n1 < 0) {
      goto statement_2014;
    }
    n2 = ivarb(kksup + i);
    {
      write_loop wloop(cmn, lunit6, "(4i8)");
      FEM_DOSTEP(n, n1, n2, 3) {
        wloop, n, ivarb(n + 1), ivarb(n + 2), ivarb(n + 2);
      }
    }
    goto statement_2034;
    statement_2014:
    n1 = -n1;
    write(lunit6, "(i8,24x,5i8)"), n1, ivarb(n1), ivarb(n1 + 1),
      ivarb(n1 + 2), ivarb(n1 + 3), ivarb(n1 + 4);
    statement_2034:;
  }
  if (kpar != 0) {
    {
      write_loop wloop(cmn, lunit6,
        "('  KPAR=',i8,6x,'PARSUP AS FOLLOWS:',/(8e16.6))");
      wloop, kpar;
      FEM_DO_SAFE(n, 1, kpar) {
        wloop, sptacs(kprsup + n);
      }
    }
  }
  n22 = nsudv + 1;
  if (nsudv < lstat(63)) {
    {
      write_loop wloop(cmn, lunit6,
        "('0 NSUDV=',i4,/,12x,'ALKSU    KSUS',/(1x,3i8))");
      wloop, nsudv;
      FEM_DO_SAFE(n, n22, lstat(63)) {
        wloop, n, ivarb(kalksu + n), ivarb(kksus + n);
      }
    }
  }
  goto statement_4444;
  statement_1066:
  if (kill > 0) {
    goto statement_9000;
  }
  if (kolbeg > 0) {
    goto statement_6534;
  }
  read(abuff, "(i2,a6,2x,3e10.0,20x,2e10.0)"), n, alnode, dum(1),
    dum(3), dum(2), prx, pru;
  goto statement_6537;
  statement_6534:
  nright = -1;
  freone(cmn, d1);
  alnode = texta6(1);
  nright = 0;
  nfrfld = 5;
  frefld(cmn, voltbc(1));
  dum(1) = voltbc(1);
  dum(3) = voltbc(2);
  dum(2) = voltbc(3);
  prx = voltbc(4);
  pru = voltbc(5);
  statement_6537:
  niu++;
  lstat(54) = niu;
  ndy5 += 5;
  if (niu > lstat(64)) {
    goto statement_8107;
  }
  ndx1 = kiuty + niu;
  ivarb(ndx1) = n;
  ndx1 = kaliu + niu;
  n23 = 0;
  namea6(cmn, alnode, n23);
  ivarb(ndx1) = n23;
  sptacs(ndy5 + 1) = dum(1);
  sptacs(ndy5 + 2) = dum(2);
  if (n != 14) {
    goto statement_8108;
  }
  sptacs(ndy5 + 2) = dum(2) * cmn.twopi / 360.f;
  statement_8108:
  if (n != 23) {
    goto statement_8109;
  }
  if (sptacs(ndy5 + 2) < deltat) {
    sptacs(ndy5 + 2) = deltat;
  }
  statement_8109:
  sptacs(ndy5 + 3) = dum(3);
  sptacs(ndy5 + 4) = prx;
  sptacs(ndy5 + 5) = fltinf;
  if (pru != 0.0f) {
    sptacs(ndy5 + 5) = pru;
  }
  if (noutpr == 0) {
    {
      write_loop wloop(cmn, kunit6, "('+TACS SOURCE.',3e12.3)");
      FEM_DO_SAFE(i, 1, 3) {
        wloop, dum(i);
      }
    }
  }
  if (nchain == 1) {
    goto statement_100;
  }
  if (n != 90) {
    goto statement_1091;
  }
  FEM_DO_SAFE(j, 2, cmn.ntot) {
    if (alnode == bus(j)) {
      goto statement_479;
    }
  }
  write(lunit6,
    "('  TYPE 90 SOURCE \"',a6,'\" IS NOT A RECOGNIZABLE',"
    "' NODE NAME IN EMTP. THE CARD WILL BE DISCARD ')"),
    alnode;
  goto statement_8579;
  statement_1091:
  if (n1 != 91 && n1 != 93) {
    goto statement_1092;
  }
  FEM_DO_SAFE(j, 1, cmn.kswtch) {
    k = fem::iabs(kmswit(j));
    ndx2 = cmn.lswtch + j;
    m = fem::iabs(kmswit(ndx2));
    if (alnode == bus(k)) {
      goto statement_479;
    }
    if (alnode == bus(m)) {
      goto statement_479;
    }
  }
  write(lunit6,
    "('  SOURCE 90 OR 91 \"',a6,'\" IS NOT A RECOGNIZABLE',"
    "' SWITCH NODE NAME IN EMTP. THE CARD WILL BE DISCARD ')"),
    alnode;
  statement_8579:
  niu = niu - 1;
  lstat(54) = niu;
  ndy5 = ndy5 - 5;
  goto statement_9000;
  statement_1092:
  if (n1 != 92) {
    goto statement_8579;
  }
  write(lunit6,
    "('  ----- THIS CARD WILL BE IGNORED, BECAUSE #92',"
    "' SOURCE CANNOT BE CHANGED   ---- ')");
  goto statement_8579;
  statement_479:
  sptacs(ndy5 + 2) = j;
  goto statement_9000;
  statement_8107:
  kill = 122;
  lstat(16) = lstat(64);
  lstat(17) = 4;
  lstat(19) = 8107;
  goto statement_9000;
  statement_2222:
  if (kolbeg > 0) {
    goto statement_6554;
  }
  {
    read_loop rloop(abuff(1), "(2x,13a6)");
    FEM_DO_SAFE(i, 1, 13) {
      rloop, dumj(i);
    }
  }
  goto statement_6557;
  statement_6554:
  nfrfld = 13;
  nright = -1;
  freone(cmn, d1);
  nright = 0;
  FEM_DO_SAFE(i, 1, 13) {
    dumj(i) = texta6(i);
  }
  statement_6557:
  jr = 0;
  FEM_DO_SAFE(i, 1, 13) {
    if (dumj(i) == blank) {
      goto statement_1199;
    }
    ioutcs++;
    lstat(59) = ioutcs;
    if (ioutcs > lstat(68)) {
      goto statement_4466;
    }
    jr = 1;
    n23 = 0;
    alnode = dumj(i);
    namea6(cmn, alnode, n23);
    ndx1 = kjout + ioutcs;
    ivarb(ndx1) = n23;
    statement_1199:;
  }
  if (jr == 1) {
    goto statement_3535;
  }
  if (noutpr == 0) {
    write(kunit6, format_4455);
  }
  statement_3535:
  if (noutpr == 0) {
    write(kunit6, "('+TACS VARIABLES FOR EMTP OUTPUT VECTOR.')");
  }
  goto statement_100;
  statement_4466:
  lstat(19) = 1199;
  statement_9300:
  kill = 122;
  lstat(16) = lstat(68);
  lstat(17) = 8;
  goto statement_9000;
  statement_3333:
  if (kolbeg > 0) {
    goto statement_6564;
  }
  read(abuff, "(2x,a6,2x,e10.0)"), alnode, prx;
  goto statement_6567;
  statement_6564:
  nfrfld = 1;
  nright = -1;
  freone(cmn, d1);
  alnode = texta6(1);
  nright = 0;
  freone(cmn, prx);
  statement_6567:
  if (alnode != blank) {
    goto statement_3838;
  }
  if (noutpr == 0) {
    write(kunit6, format_4455);
  }
  goto statement_100;
  statement_3838:
  kxic++;
  lstat(58) = kxic;
  if (kxic < lstat(68)) {
    goto statement_3377;
  }
  lstat(19) = 3377;
  goto statement_9300;
  statement_3377:
  ndx1 = kxtcs + lstat(68) + kxic;
  sptacs(ndx1) = prx;
  ndx2 = kxtcs + kxic;
  n23 = 0;
  namea6(cmn, alnode, n23);
  sptacs(ndx2) = n23;
  if (noutpr == 0) {
    write(kunit6, "('+INIT. COND. ''',a6,'''',e16.6)"), alnode, prx;
  }
  goto statement_100;
  statement_113:
  tacs1a(cmn);
  if (kill > 0) {
    goto statement_9000;
  }
  if (nchain == 1) {
    goto statement_100;
  }
  ktab++;
  if (ktab <= lstat(68)) {
    goto statement_4444;
  }
  lstat(19) = 113;
  goto statement_9300;
  statement_4444:
  tacs1b(cmn);
  statement_9000:
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE TACS1.\"')");
  }
  sptacs(5) = kcolcs;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void mover(
  arr_cref<double> a,
  arr_ref<double> b,
  int const& n) try
{
  a(dimension(n));
  b(dimension(n));
  //C)    SUBROUTINE  MOVER  (WITH ENTRY POINT MOVER0) IS USED FOR BLOCK    M15. 297
  //C)    TRANSFERS BETWEEN CONTIGUOUS CELLS OF CORE STORAGE.   'N'  IS THE M15. 298
  //C)    NUMBER OF WORDS TO BE TRANSFERED.                                 M15. 299
  //C)         1.  USING 'MOVER', THE TRANSFER IS FROM  A(J)  TO  B(J),     M15. 300
  //C)             FOR  J=1, N.                                             M15. 301
  //C)         2.  USING  'MOVER0',  A(1)  IS COPIED INTO ALL  N  CELLS     M15. 302
  //C)             OF ARRAY  'B'.   FOR ZEROING ARRAY  'B' ,  THE SUBROUTINEM15. 303
  //C)             CALL IS MADE WITH THE FIRST ARGUMENT EXPLICITELY         M15. 304
  //C)             PUNCHED AS ZERO.                                         M15. 305
  int i = fem::int0;
  FEM_DO_SAFE(i, 1, n) {
    b(i) = a(i);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}



void csup(
  common& cmn,
  int const& L) try
{
  common_write write(cmn);
  double& deltat = cmn.deltat;
  double& t = cmn.t;
  double& twopi = cmn.twopi;
  double& onehaf = cmn.onehaf;
  double& flzero = cmn.flzero;
  const auto& lstat = cmn.lstat;
  int& iprsup = cmn.iprsup;
  auto& sptacs = cmn.sptacs;
  const auto& texvec = cmn.texvec;
  //
  //int kspvar = fem::int0;
  //int kprsup = fem::int0;
  //int kiuty = fem::int0;
  //int kxtcs = fem::int0;
  //int kksus = fem::int0;
  //int kalksu = fem::int0;
  //int kinsup = fem::int0;
  //int nuk = fem::int0;
  //int nsup = fem::int0;
  //int karg = fem::int0;
  //int kpar = fem::int0;
  int kjsup = fem::int0;
  int kksup = fem::int0;

  auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int n = fem::int0;
  int nnn = fem::int0;
  double a = fem::double0;
  int nop = fem::int0;
  int k = fem::int0;
  int m = fem::int0;
  int m1 = fem::int0;
  int m2 = fem::int0;
  double b = fem::double0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  double div = fem::double0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  double d2 = fem::double0;
  int j = fem::int0;
  arr_1d<50, int> iop(fem::fill0);
  arr_1d<50, double> arg(fem::fill0);
  int i1 = fem::int0;
  int i2 = fem::int0;
  int ndx4 = fem::int0;
  double zfl = fem::double0;
  int jfl = fem::int0;
  arr_1d<20, int> ifl(fem::fill0);
  arr_1d<20, int> idn(fem::fill0);
  arr_1d<20, double> acc(fem::fill0);
  arr_1d<20, double> amx(fem::fill0);
  int k1 = fem::int0;
  int nn = fem::int0;
  double d9 = fem::double0;
  double d = fem::double0;
  double g = fem::double0;
  double h = fem::double0;
  int ndx1 = fem::int0;
  int kdev2 = fem::int0;
  int ndx6 = fem::int0;
  double d4 = fem::double0;
  int n4 = fem::int0;
  int n3 = fem::int0;
  double d5 = fem::double0;
  int ndx2 = fem::int0;
  int ndx3 = fem::int0;
  double d1 = fem::double0;
  double d11 = fem::double0;
  double d10 = fem::double0;
  int ndx5 = fem::int0;
  double rdev1 = fem::double0;
  int ji = fem::int0;
  int mj = fem::int0;
  double bb = fem::double0;
  int nj = fem::int0;
  double aa = fem::double0;

  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;

  auto& kspvar = isptacs(6);
  auto& kprsup = isptacs(9);
  auto& kiuty =  isptacs(13);
  auto& kxtcs =  isptacs(17);
  auto& kksus =  isptacs(21);
  auto& kalksu = isptacs(22);
  auto& kinsup = isptacs(23);

  auto& nuk = lstat(51);
  auto& nsup = lstat(55);
  auto& karg = lstat(56);
  auto& kpar = lstat(57);
  //C     000  B = THE ARGUMENT AND LATER THE VALUE OF THE FUNCTION,        M14. 232
  //C     000      BEFORE IT IS AFFECTED BY THE ALGEBRAIC OPERATION         M14. 233
  //C     000      WHICH WILL UPDATE 'A' .                                  M14. 234
  //C     000  A = INTERMEDIATE VALUES OF THE SUPPLEMENTAL                  M14. 235
  //C     000      VARIABLE OR DEVICE .                                     M14. 236
  //C     000  XTCS( L) = THE FINAL VALUE OF THE VARIABLE OR DEVICE .       M14. 237
  kjsup = kinsup + lstat(65);
  kksup = kjsup + lstat(65);
  if (iprsup < 6) {
    goto statement_1000;
  }
  write(lunit6,
    "('0ENTERING SUBROUTINE  CSUP  AT  T=',e13.6,/,'0E NSUP=',i6,'   KARG=',"
    "i8,'   KPAR=',i6)"),
    t, nsup, karg, kpar;
  {
    write_loop wloop(cmn, lunit6,
      "('  NUMBER  SUPVAR    JSUP    KSUP',/(4i8))");
    FEM_DO_SAFE(i, 1, nsup) {
      wloop, i, ivarb(i + kspvar), ivarb(i + kjsup), ivarb(i + kksup);
    }
  }
  write(lunit6,
    "('  KARG = ',i8,/,'       N  IOPSUP  IFNSUP',"
    "'  IRGSUP    IDEV     KDJ     KDK  ILDEV1  ILDEV2')"),
    karg;
  FEM_DO_SAFE(i, 1, nsup) {
    n1 = ivarb(kjsup + i);
    if (n1 < 0) {
      goto statement_2014;
    }
    n2 = ivarb(kksup + i);
    {
      write_loop wloop(cmn, lunit6, "(4i8)");
      FEM_DOSTEP(n, n1, n2, 3) {
        wloop, n, ivarb(n + 1), ivarb(n + 2), ivarb(n + 2);
      }
    }
    goto statement_2034;
    statement_2014:
    n1 = -n1;
    write(lunit6, "(i8,24x,5i8)"), n1, ivarb(n1), ivarb(n1 + 1),
      ivarb(n1 + 2), ivarb(n1 + 3), ivarb(n1 + 4);
    statement_2034:;
  }
  if (kpar != 0) {
    {
      write_loop wloop(cmn, lunit6,
        "('0E',5x,'PARSUP ...',/(' E ',5(i3,1x,e15.6,3x)))");
      FEM_DO_SAFE(i, 1, kpar) {
        wloop, i, sptacs(i + kprsup);
      }
    }
  }
  statement_1000:
  nnn = kxtcs + nuk + lstat(64);
  i = L;
  statement_1234:
  a = 0.0f;
  n1 = ivarb(kjsup + i);
  n2 = ivarb(kksup + i);
  if (n1 < 0) {
    goto statement_600;
  }
  if (n2 < 0) {
    goto statement_5000;
  }
  //C     ------  OLD TACS PSEUDO-FORTRAN "VARIABLE"  ------                M28. 350
  nop = 0;
  k = n1 - 3;
  statement_20:
  k += 3;
  if (k > n2) {
    goto statement_11;
  }
  m = ivarb(k + 2);
  m1 = ivarb(k + 3);
  m2 = ivarb(k + 1);
  if (m2 > 0) {
    b = sptacs(kxtcs + m1);
  }
  if (m2 < 0) {
    b = sptacs(kprsup + m1);
  }
  if (m > 10) {
    goto statement_30;
  }
  if (m <= 0 || m > 5) {
    goto statement_100;
  }
  switch (m) {
    case 1: goto statement_101;
    case 2: goto statement_102;
    case 3: goto statement_103;
    case 4: goto statement_104;
    case 5: goto statement_105;
    default: break;
  }
  statement_30:
  if (m > 20) {
    goto statement_40;
  }
  m = m - 10;
  switch (m) {
    case 1: goto statement_111;
    case 2: goto statement_112;
    case 3: goto statement_113;
    case 4: goto statement_114;
    case 5: goto statement_115;
    case 6: goto statement_116;
    case 7: goto statement_117;
    case 8: goto statement_118;
    case 9: goto statement_119;
    case 10: goto statement_120;
    default: break;
  }
  statement_40:
  if (m > 30) {
    goto statement_50;
  }
  m = m - 20;
  switch (m) {
    case 1: goto statement_121;
    case 2: goto statement_122;
    case 3: goto statement_123;
    case 4: goto statement_124;
    case 5: goto statement_125;
    case 6: goto statement_126;
    case 7: goto statement_127;
    case 8: goto statement_128;
    case 9: goto statement_129;
    case 10: goto statement_130;
    default: break;
  }
  statement_50:
  if (m > 40) {
    goto statement_60;
  }
  m = m - 30;
  switch (m) {
    case 1: goto statement_131;
    case 2: goto statement_132;
    case 3: goto statement_133;
    case 4: goto statement_134;
    default: break;
  }
  statement_60:
  statement_101:
  if (a >= 1.0f && b >= 1.0f) {
    goto statement_99;
  }
  goto statement_98;
  statement_102:
  if (a >= 1.0f || b >= 1.0f) {
    goto statement_99;
  }
  goto statement_98;
  statement_103:
  if (b < 1.0f) {
    goto statement_99;
  }
  goto statement_98;
  statement_104:
  if (a >= 1.0f && b >= 1.0f) {
    goto statement_98;
  }
  goto statement_99;
  statement_105:
  if (a < 1.0f && b < 1.0f) {
    goto statement_99;
  }
  goto statement_98;
  statement_99:
  a = 1.0f;
  goto statement_20;
  statement_98:
  a = 0.0f;
  goto statement_20;
  statement_111:
  b = sinz(b);
  goto statement_100;
  statement_112:
  b = cosz(b);
  goto statement_100;
  statement_113:
  b = std::tan(b);
  goto statement_100;
  statement_114:
  b = cotanz(b);
  goto statement_100;
  statement_115:
  b = sinhz(b);
  goto statement_100;
  statement_116:
  b = std::cosh(b);
  goto statement_100;
  statement_117:
  b = std::tanh(b);
  goto statement_100;
  statement_118:
  b = std::asin(b);
  goto statement_100;
  statement_119:
  b = acosz(b);
  goto statement_100;
  statement_120:
  b = std::atan(b);
  goto statement_100;
  statement_121:
  b = expz(b);
  goto statement_100;
  statement_122:
  b = alogz(b);
  goto statement_100;
  statement_123:
  b = alog1z(b);
  goto statement_100;
  statement_124:
  b = sqrtz(b);
  goto statement_100;
  statement_125:
  b = std::abs(b);
  goto statement_100;
  statement_126:
  b = std::floor(b); // aintz(b);
  goto statement_100;
  statement_127:
  b = -b;
  goto statement_100;
  statement_128:
  d7 = 1.0f;
  d8 = b;
  FEM_THROW_UNHANDLED("executable assign: assign7128toidiv");
  goto statement_500;
  statement_7128:
  b = div;
  goto statement_100;
  statement_129:
  b = b * twopi / 360.0f;
  goto statement_100;
  statement_130:
  b = b / twopi * 360.0f;
  goto statement_100;
  statement_131:
  n5 = b;
  n6 = n5 / 6;
  if (n5 < 0) {
    n5 += 6 * (n6 + 1);
  }
  n7 = n5 - 6 * n6;
  if (n7 == 0) {
    n7 = 6;
  }
  b = n7;
  goto statement_100;
  statement_132:
  d7 = b;
  b = 1.0f;
  if (d7 < 0.0f) {
    b = -1.0f;
  }
  goto statement_100;
  statement_133:
  d7 = b;
  b = 1.0f;
  if (d7 > 10.0f * flzero) {
    b = 0.0f;
  }
  goto statement_100;
  statement_134:
  d2 = 0.0f;
  b = randnm(cmn, d2);
  statement_100:
  if (nop > 0) {
    goto statement_6113;
  }
  m = fem::iabs(m2);
  switch (m) {
    case 1: goto statement_201;
    case 2: goto statement_202;
    case 3: goto statement_203;
    case 4: goto statement_204;
    case 5: goto statement_205;
    default: break;
  }
  statement_201:
  a += b;
  goto statement_20;
  statement_202:
  a = a - b;
  goto statement_20;
  statement_203:
  a = a * b;
  goto statement_20;
  statement_204:
  d7 = a;
  d8 = b;
  FEM_THROW_UNHANDLED("executable assign: assign7204toidiv");
  goto statement_500;
  statement_7204:
  a = div;
  goto statement_20;
  statement_205:
  a = fem::pow(a, b);
  goto statement_20;
  statement_500:
  if (d7 == 0.0f) {
    goto statement_510;
  }
  if (d8 == 0.0f) {
    goto statement_520;
  }
  n = alog1z(std::abs(d7)) - alog1z(std::abs(d8));
  if (n <  - ivarb(kiuty + 11)) {
    goto statement_510;
  }
  if (n > ivarb(kiuty + 11)) {
    goto statement_520;
  }
  div = d7 / d8;
  goto statement_530;
  statement_520:
  div = cmn.fltinf;
  if (d7 < 0.0f) {
    div = -div;
  }
  if (d8 < 0.0f) {
    div = -div;
  }
  goto statement_530;
  statement_510:
  div = 0.0f;
  statement_530:
  switch (int(div)) {
    case 1: goto statement_7128;
    case 2: goto statement_7204;
    case 3: goto statement_6120;
    default: break;
  }
  //C     ------  FREE-FORMAT FORTRAN EXPRESSION  ------                    M28. 371
  statement_5000:
  n2 = -n2;
  //C     :: LOAD IOP( NOP)  AND  ARG( NOP)                                 M28. 373
  k = 0;
  FEM_DOSTEP(j, n1, n2, 3) {
    k++;
    iop(k) = ivarb(j + 2);
    arg(k) = 0.0f;
    i1 = ivarb(j + 1) + 2;
    i2 = ivarb(j + 3);
    switch (i1) {
      case 1: goto statement_5010;
      case 2: goto statement_5025;
      case 3: goto statement_5015;
      case 4: goto statement_5020;
      default: break;
    }
    //C      :: NUMERICAL ARGUMENT                                            M28. 385
    statement_5010:
    ndx4 = kprsup + i2;
    arg(k) = sptacs(ndx4);
    goto statement_5025;
    //C      :: TACS VARIABLE                                                 M28. 389
    statement_5015:
    ndx4 = kxtcs + i2;
    arg(k) = sptacs(ndx4);
    goto statement_5025;
    //C      :: FORTRAN TACS FUNCTION                                         M28. 393
    statement_5020:
    arg(k) = i2;
    statement_5025:;
  }
  //C    :::  CALCULATE VALUE OF FORTRAN EXPRESSION  :::                    M28. 397
  zfl = 10.0f * flzero;
  jfl = 1;
  ifl(1) = k;
  nop = k;
  statement_6010:
  idn(jfl) = 0;
  idn(jfl + 1) = 0;
  statement_6015:
  acc(jfl) = 0.0f;
  amx(jfl) = 1.0f;
  statement_6020:
  if (jfl == 0) {
    goto statement_6200;
  }
  i1 = ifl(jfl);
  if (i1 == 0) {
    goto statement_6111;
  }
  k1 = iop(i1);
  if (k1 == 0) {
    goto statement_6028;
  }
  if (k1 > 7) {
    goto statement_6025;
  }
  switch (k1) {
    case 1: goto statement_6110;
    case 2: goto statement_6121;
    case 3: goto statement_6130;
    case 4: goto statement_6121;
    case 5: goto statement_6150;
    case 6: goto statement_6121;
    case 7: goto statement_6170;
    default: break;
  }
  statement_6025:
  if (k1 < 14) {
    goto statement_6180;
  }
  k1 = k1 - 13;
  switch (k1) {
    case 1: goto statement_6114;
    case 2: goto statement_6115;
    case 3: goto statement_6116;
    case 4: goto statement_6117;
    case 5: goto statement_6118;
    default: break;
  }
  statement_6026:
  amx(jfl) = 1.0f;
  statement_6027:
  iop(i1) = 0;
  statement_6028:
  ifl(jfl) = ifl(jfl) - 1;
  goto statement_6020;
  //C                                     ::  K1 = (  ::                    M28. 420
  statement_6110:
  if (idn(jfl) !=  - 1) {
    goto statement_6112;
  }
  statement_6111:
  jfl = jfl - 1;
  goto statement_6020;
  statement_6112:
  b = acc(jfl);
  m = arg(i1 - 1);
  if (m != 0) {
    goto statement_30;
  }
  statement_6113:
  arg(i1 - 1) = b;
  jfl = jfl - 1;
  iop(i1) = 0;
  goto statement_6020;
  //C                                      ::  K1 = *  ::                   M28. 432
  statement_6114:
  amx(jfl) = amx(jfl) * arg(i1);
  goto statement_6027;
  //C                                      ::  K1 = /  ::                   M28. 436
  statement_6115:
  d7 = amx(jfl);
  d8 = arg(i1);
  FEM_THROW_UNHANDLED("executable assign: assign6120toidiv");
  goto statement_500;
  statement_6120:
  amx(jfl) = div;
  goto statement_6027;
  //C                                       ::  K1 = **  ::                 M28. 444
  statement_6116:
  i2 = i1;
  statement_6776:
  i2 = i2 - 1;
  if (iop(i2) == 0) {
    goto statement_6776;
  }
  if (iop(i2) == 7) {
    goto statement_6119;
  }
  arg(i2) = fem::pow(arg(i2), arg(i1));
  goto statement_6027;
  statement_6119:
  i1 = i2;
  goto statement_6170;
  //C                                       ::  K1 = -  ::                  M28. 453
  statement_6118:
  arg(i1) = -arg(i1);
  //C                                       ::  K1 = +  ::                  M28. 456
  statement_6117:
  acc(jfl) += arg(i1) * amx(jfl);
  goto statement_6026;
  //C                                       ::  K1 = NOT  ::                M28. 460
  statement_6121:
  d7 = arg(i1);
  arg(i1) = 1.0f;
  if (d7 > zfl) {
    arg(i1) = 0.0f;
  }
  if (k1 == 6) {
    goto statement_6150;
  }
  //C                                       ::  K1 = OR  ::                 M28. 466
  statement_6130:
  d7 = arg(i1);
  arg(i1) = 0.0f;
  if (d7 > zfl && amx(jfl) > zfl) {
    arg(i1) = 1.0f;
  }
  d7 = acc(jfl);
  acc(jfl) = 0.0f;
  if (d7 > zfl || arg(i1) > zfl) {
    acc(jfl) = 1.0f;
  }
  goto statement_6026;
  //C                                       ::  K1 = AND  ::                M28. 475
  statement_6150:
  d7 = amx(jfl);
  amx(jfl) = 0.0f;
  if (d7 > zfl && arg(i1) > zfl) {
    amx(jfl) = 1.0f;
  }
  goto statement_6027;
  //C                                       :: K1 = )                       M28. 481
  statement_6170:
  jfl++;
  ifl(jfl) = i1 - 1;
  iop(i1) = 0;
  goto statement_6010;
  //C                                       :: K1 = .NN.                    M28. 487
  statement_6180:
  if (idn(jfl + 1) ==  - 1) {
    goto statement_6185;
  }
  jfl++;
  ifl(jfl) = i1 - 1;
  idn(jfl) = -1;
  goto statement_6015;
  statement_6185:
  iop(i1) = 0;
  idn(jfl + 1) = 0;
  d7 = acc(jfl);
  d8 = acc(jfl + 1);
  acc(jfl) = 0.0f;
  i2 = k1 - 7;
  switch (i2) {
    case 1: goto statement_6188;
    case 2: goto statement_6189;
    case 3: goto statement_6190;
    case 4: goto statement_6191;
    case 5: goto statement_6192;
    case 6: goto statement_6193;
    default: break;
  }
  statement_6188:
  if (d8 != d7) {
    goto statement_6195;
  }
  goto statement_6020;
  statement_6189:
  if (d8 == d7) {
    goto statement_6195;
  }
  goto statement_6020;
  statement_6190:
  if (d8 < d7) {
    goto statement_6195;
  }
  goto statement_6020;
  statement_6191:
  if (d8 <= d7) {
    goto statement_6195;
  }
  goto statement_6020;
  statement_6192:
  if (d8 >= d7) {
    goto statement_6195;
  }
  goto statement_6020;
  statement_6193:
  if (d8 > d7) {
    goto statement_6195;
  }
  goto statement_6020;
  statement_6195:
  acc(jfl) = 1.0f;
  goto statement_6020;
  //C     :: EXIT FORTRAN EXPRESSION                                        M28. 515
  statement_6200:
  a = acc(1);
  goto statement_11;
  //C     ------  DEVICES  START  HERE  ------                              M14. 384
  statement_600:
  n1 = -n1;
  nn = ivarb(n1);
  if (n2 == 60 || n2 == 61) {
    goto statement_602;
  }
  if (n2 == 63 || n2 == 67) {
    goto statement_602;
  }
  j = ivarb(n1 + 1);
  k = ivarb(n1 + 2);
  b = 0.0f;
  FEM_DO_SAFE(n, j, k) {
    m = kxtcs + ivarb(kalksu + n);
    b += sptacs(m) * ivarb(kksus + n);
  }
  statement_602:
  if (n2 > 67) {
    goto statement_10;
  }
  n2 = n2 - 49;
  switch (n2) {
    case 1: goto statement_650;
    case 2: goto statement_651;
    case 3: goto statement_651;
    case 4: goto statement_653;
    case 5: goto statement_654;
    case 6: goto statement_655;
    case 7: goto statement_656;
    case 8: goto statement_657;
    case 9: goto statement_658;
    case 10: goto statement_659;
    case 11: goto statement_660;
    case 12: goto statement_661;
    case 13: goto statement_662;
    case 14: goto statement_663;
    case 15: goto statement_664;
    case 16: goto statement_664;
    case 17: goto statement_666;
    case 18: goto statement_667;
    default: break;
  }
  //C     ---  FREQUENCY SENSORS  ---                                       M14. 393
  statement_650:
  n = 1;
  if (b < 0.0f) {
    n = -1;
  }
  m = ivarb(n1 + 3);
  d9 = sptacs(nn + 1);
  d = sptacs(nn + 2);
  d7 = sptacs(nn);
  a = d7;
  if (m != 0) {
    goto statement_6501;
  }
  sptacs(nn + 1) = -1.0f;
  goto statement_6507;
  statement_6501:
  if (n == m) {
    goto statement_6508;
  }
  if (d == 0.0f) {
    goto statement_6507;
  }
  if (b != 0.0f) {
    goto statement_6502;
  }
  d8 = t;
  goto statement_6503;
  statement_6502:
  d8 = t - deltat / (1.0f - d / b);
  statement_6503:
  if (d9 < 0.0f) {
    goto statement_6506;
  }
  g = onehaf / (d8 - d9);
  if (d7 == 0.0f) {
    goto statement_6505;
  }
  h = g / d7 - 1.0f;
  if (h < sptacs(nn + 3)) {
    goto statement_6505;
  }
  if (ivarb(kiuty + 3) == 0) {
    goto statement_6507;
  }
  ivarb(kiuty + 3) = ivarb(kiuty + 3) - 1;
  ndx1 = ivarb(kspvar + i);
  write(lunit6,
    "(5x,'WARNING.  ----  FREQUENCY SENSOR  ''',a6,'''  HAS ZERO CROSSING AT',"
    "e15.6,'    SEC.   BUT NEW FREQUENCY',/,21x,'OF',e13.4,"
    "' HZ   DIFFERS BY OVER FIFTY PERCENT FROM THE OLD FREQUENCY OF',e13.4,"
    "' HZ .    REJECT IT.')"),
    texvec(ndx1), t, d7, g;
  goto statement_6507;
  statement_6505:
  sptacs(nn) = g;
  a = g;
  statement_6506:
  sptacs(nn + 1) = d8;
  statement_6507:
  ivarb(n1 + 3) = n;
  statement_6508:
  ndx1 = kdev2 - n1;
  sptacs(nn + 2) = b;
  goto statement_11;
  //C     ---  RELAYS AND LEVEL-TRIGGERS  ---                               M14. 426
  statement_651:
  if (sptacs(nn) != 0.0f) {
    b = b * sptacs(nn);
  }
  m = ivarb(n1 + 3);
  n = ivarb(n1 + 4);
  d9 = sptacs(nn + 1);
  d8 = std::abs(sptacs(nn + 2));
  if (m != 0) {
    d9 += sptacs(kxtcs + m);
  }
  d = 0.0f;
  if (n != 0) {
    d = sptacs(kxtcs + n);
  }
  if (n2 == 2) {
    d = std::abs(d);
  }
  if (d >= d9 && d8 > 1.5f) {
    a = b;
  }
  if (d < d9 && d8 < 1.5f) {
    a = b;
  }
  goto statement_11;
  //C     ---  VARIABLE TRANSPORT DELAY  ---                                M28. 533
  statement_653:
  n5 = sptacs(nn);
  n6 = sptacs(nn + 2);
  n7 = ivarb(n1 + 4);
  d7 = sptacs(nn + 1);
  j = ivarb(n1 + 3);
  ndx6 = kxtcs + j;
  if (j != 0) {
    d7 += sptacs(ndx6);
  }
  d7 = d7 / deltat;
  statement_65310:
  d8 = d7 + flzero * 10.f;
  d9 = d7 - flzero * 10.f;
  if (d8 >= 0.0f) {
    goto statement_65320;
  }
  if (ivarb(kiuty + 3) == 0) {
    goto statement_65313;
  }
  ivarb(kiuty + 3) = ivarb(kiuty + 3) - 1;
  ndx6 = ivarb(kspvar + i);
  write(lunit6,
    "(5x,'WARNING.  ----  VALUE OF DELAY BECAME NEGATIVE ','FOR ''',a6,"
    "''' AT TIME =',e14.6,' BUT LOWER LIMIT NALUE = 0.0 .',/,21x,"
    "'THIS MESSAGE WILL NOT BE REPEATED.')"),
    texvec(ndx6), t;
  statement_65313:
  d7 = 0.0f;
  goto statement_65310;
  statement_65320:
  if (d9 > 0.0f) {
    goto statement_65330;
  }
  a = b;
  goto statement_11;
  statement_65330:
  m1 = 0;
  j = 0;
  statement_65350:
  j++;
  if (d9 > j) {
    goto statement_65350;
  }
  if (j <= d8) {
    m1 = 1;
  }
  if (j <= n6) {
    goto statement_65360;
  }
  if (ivarb(kiuty + 2) == 0) {
    goto statement_65353;
  }
  ivarb(kiuty + 3) = ivarb(kiuty + 3) - 1;
  ndx6 = ivarb(kspvar + i);
  d4 = deltat * n6;
  write(lunit6,
    "(5x,'WARNING.  ----  VALUE OF DELAY EXCEEDED ','MAX. DELAY VALUE OF ''',"
    "e14.6,''' FOR ''',a6,''' AT TIME =',e14.6,/,21x,"
    "'THIS MESSAGE WILL NOT BE REPEATED.')"),
    d4, texvec(ndx6), t;
  statement_65353:
  j = n6;
  m1 = 1;
  statement_65360:
  n4 = n7 - j;
  if (n4 < n5) {
    n4 += n6;
  }
  ndx6 = kprsup + n4;
  a = sptacs(ndx6);
  if (m1 == 1) {
    goto statement_11;
  }
  n3 = n4 + 1;
  if (n3 >= n5 + n6) {
    n3 = n3 - n6;
  }
  d5 = b;
  ndx6 = kprsup + n3;
  if (j > 1) {
    d5 = sptacs(ndx6);
  }
  a = a - (j - d7) * (a - d5);
  goto statement_11;
  //C     ---  PULSE VARIABLE TRANSPORT DELAY  ---                          M28. 598
  statement_654:
  m = ivarb(n1 + 3);
  d9 = sptacs(nn + 1);
  ndx1 = kxtcs + m;
  if (m != 0) {
    d9 += sptacs(ndx1);
  }
  d = sptacs(nn);
  d7 = sptacs(nn + 2);
  if (d7 ==  - 9999.f) {
    goto statement_65400;
  }
  ndx1 = ivarb(kspvar + i);
  if (b <= 0.0f) {
    goto statement_65402;
  }
  if (ivarb(kiuty + 3) == 0) {
    goto statement_65402;
  }
  ivarb(kiuty + 3) = ivarb(kiuty + 3) - 1;
  write(lunit6,
    "(5x,'WARNING.  ----  THE PULSE FREQUENCY AT THE PULSE TRANSPORT DELAY  ''"
    "',a6,'''  IS TOO FAST FOR THE PRESENT',/,21x,'DELAY OF',e13.4,"
    "' SEC   AT SIMULATION TIME',e13.4,"
    "' SEC. USE DEVICE TYPE 53 INSTEAD OF TYPE 54 . ',/,21x,"
    "' ******** THE ANSWER MAY BE WRONG LATER ********  ')"),
    texvec(ndx1), d9, t;
  goto statement_65402;
  statement_65400:
  if (b > 0.0f && d ==  - 9999.f) {
    sptacs(nn) = t;
  }
  if (b <= 0.0f && d !=  - 9999.f) {
    sptacs(nn + 2) = t;
  }
  statement_65402:
  if (t < d + d9 - 10.f * flzero || d ==  - 9999.f) {
    goto statement_11;
  }
  if (t >= d7 + d9 - 10.f * flzero && d7 !=  - 9999.f) {
    goto statement_65403;
  }
  a = 1.0f;
  goto statement_11;
  statement_65403:
  sptacs(nn) = -9999.f;
  sptacs(nn + 2) = -9999.f;
  goto statement_11;
  //C     ---  DIGITIZER  ---                                               M14. 494
  statement_655:
  m = ivarb(n1 + 3);
  n = ivarb(n1 + 4);
  if (sptacs(nn) != 0.0f) {
    b = b * sptacs(nn);
  }
  ndx1 = kprsup + m;
  a = sptacs(ndx1);
  if (m == n) {
    goto statement_11;
  }
  j = m + 1;
  FEM_DO_SAFE(k, j, n) {
    m = n - k + j;
    ndx1 = kprsup + m;
    if (b >= sptacs(ndx1)) {
      goto statement_65501;
    }
  }
  goto statement_11;
  statement_65501:
  ndx1 = kprsup + m;
  a = sptacs(ndx1);
  goto statement_11;
  //C     ---  POINT-BY-POINT NON-LINEARITY  ---                            M14. 508
  statement_656:
  m = ivarb(n1 + 3);
  n = ivarb(n1 + 4);
  if (sptacs(nn) != 0.0f) {
    b = b * sptacs(nn);
  }
  ndx1 = kprsup + m + 1;
  a = sptacs(ndx1);
  if (n <= m + 1) {
    goto statement_11;
  }
  ndx1 = kprsup + m;
  if (b <= sptacs(ndx1)) {
    goto statement_11;
  }
  j = m + 2;
  FEM_DOSTEP(k, j, n, 2) {
    ndx1 = kprsup + k;
    if (b <= sptacs(ndx1)) {
      goto statement_65601;
    }
  }
  ndx1 = kprsup + n;
  a = sptacs(ndx1);
  goto statement_11;
  statement_65601:
  ndx1 = kprsup + k + 1;
  ndx2 = kprsup + k - 1;
  ndx3 = kprsup + k;
  ndx4 = kprsup + k - 2;
  d9 = (sptacs(ndx1) - sptacs(ndx2)) / (sptacs(ndx3) - sptacs(ndx4));
  a = sptacs(ndx2) + d9 * (b - sptacs(ndx4));
  goto statement_11;
  //C     ---  TIME - SEQUENCED  SWITCH  ---                                M15. 343
  statement_657:
  m = ivarb(n1 + 3);
  n = ivarb(n1 + 4);
  n3 = sptacs(nn + 1);
  n4 = sptacs(nn + 2);
  if (n4 == n) {
    goto statement_65701;
  }
  if (n4 == 0) {
    n4 = m - 1;
  }
  j = n4 + 1;
  ndx1 = kprsup + j;
  if (t < sptacs(ndx1)) {
    goto statement_65701;
  }
  sptacs(nn + 2) = j;
  n3++;
  if (n3 == 2) {
    n3 = 0;
  }
  sptacs(nn + 1) = n3;
  statement_65701:
  if (n3 == 0) {
    goto statement_11;
  }
  a = b;
  goto statement_11;
  //C     ---  CONTROLLED INTEGRATOR AND COUNTER  ---                       M28. 607
  statement_658:
  if (ivarb(n1 + 3) !=  - 9999) {
    goto statement_4658;
  }
  ndx6 = nnn + i;
  a = sptacs(ndx6) + b;
  goto statement_11;
  statement_4658:
  n5 = ivarb(n1 + 3);
  if (n5 == 0) {
    goto statement_4721;
  }
  ndx6 = kxtcs + n5;
  if (sptacs(ndx6) > 0.0f) {
    goto statement_4721;
  }
  a = 0.0f;
  sptacs(nn) = 0.0f;
  n6 = ivarb(n1 + 4);
  if (n6 == 0) {
    goto statement_11;
  }
  ndx6 = kxtcs + n6;
  a = sptacs(ndx6);
  sptacs(nn) = (sptacs(nn + 1) - sptacs(nn + 2)) / 2.0f * a;
  goto statement_11;
  statement_4721:
  a = (b + sptacs(nn)) / sptacs(nn + 1);
  sptacs(nn) = b - sptacs(nn + 2) * a;
  goto statement_11;
  //C     ---  SIMPLE  DERIVATIVE  ---                                      M28. 633
  statement_659:
  a = (b - sptacs(nn + 1)) * sptacs(nn);
  sptacs(nn + 1) = b;
  goto statement_11;
  //C     ---  INPUT  IF - BLOCK  ---                                       M28. 640
  statement_660:
  d7 = sptacs(nn);
  n3 = ivarb(n1 + 3);
  n4 = ivarb(n1 + 4);
  ndx1 = kxtcs + n4;
  if (n4 != 0) {
    d7 += sptacs(ndx1);
  }
  ndx1 = kxtcs + n3;
  d7 = sptacs(ndx1) - d7;
  n = 2;
  if (d7 >  - flzero) {
    n = 1;
  }
  if (d7 >  + flzero) {
    n = 0;
  }
  j = ivarb(n1 + 1) + n;
  ndx2 = kalksu + j;
  ndx3 = kksus + j;
  ndx4 = kxtcs + ivarb(ndx2);
  a = sptacs(ndx4) * ivarb(ndx3);
  goto statement_11;
  //C     ---  INPUT  SIGNAL  SELECTOR  ---                                 M28. 662
  statement_661:
  ndx3 = kxtcs + ivarb(n1 + 3);
  ndx4 = kxtcs + ivarb(n1 + 4);
  d1 = sptacs(ndx4);
  a = sptacs(nn + 1);
  if (d1 < 0.5f) {
    goto statement_11;
  }
  a = sptacs(nn + 2);
  if (d1 >= 6.5f) {
    goto statement_11;
  }
  a = 0.0f;
  if (d1 < 5.5f) {
    goto statement_66110;
  }
  if (ndx3 == kxtcs) {
    goto statement_11;
  }
  a = sptacs(ndx3);
  goto statement_11;
  statement_66110:
  j = d1 - onehaf;
  j = ivarb(n1 + 2) - j;
  ndx1 = kalksu + j;
  m = ivarb(ndx1);
  if (m == 0) {
    goto statement_11;
  }
  ndx1 = kxtcs + m;
  ndx2 = kksus + j;
  a = sptacs(ndx1) * ivarb(ndx2);
  goto statement_11;
  //C     ---  TRACK  AND  SAMPLE  ---                                      M28. 690
  statement_662:
  a = sptacs(nn + 2);
  n = ivarb(n1 + 3);
  if (n == 0) {
    goto statement_66210;
  }
  ndx2 = kxtcs + n;
  if (sptacs(ndx2) > flzero) {
    a = b;
  }
  statement_66210:
  n = ivarb(n1 + 4);
  m = 0;
  if (n == 0) {
    goto statement_66220;
  }
  ndx3 = kxtcs + n;
  if (sptacs(ndx3) > flzero) {
    m = 1;
  }
  statement_66220:
  if (sptacs(nn) == 1.0f || m == 0) {
    goto statement_66230;
  }
  a = b;
  sptacs(nn) = 1.0f;
  goto statement_66240;
  statement_66230:
  if (sptacs(nn) == 1.0f && m == 0) {
    sptacs(nn) = 0.0f;
  }
  statement_66240:
  sptacs(nn + 2) = a;
  goto statement_11;
  //C     ---  INSTANTANEOUS  MIN/MAX  ---                                  M28. 714
  statement_663:
  ndx1 = kalksu + ivarb(n1 + 1);
  k = 2;
  statement_66310:
  if (ivarb(ndx1) > 0) {
    goto statement_66320;
  }
  ndx1++;
  k++;
  goto statement_66310;
  statement_66320:
  ndx4 = kxtcs + ivarb(ndx1);
  ndx2 = ndx1 - lstat(63);
  d11 = sptacs(ndx4) * ivarb(ndx2);
  d10 = d11;
  if (k > 5) {
    goto statement_66330;
  }
  ndx3 = ndx1;
  FEM_DO_SAFE(j, k, 5) {
    ndx3++;
    ndx2++;
    n = ivarb(ndx3);
    if (n == 0) {
      goto statement_66340;
    }
    ndx6 = kxtcs + n;
    d4 = sptacs(ndx6) * ivarb(ndx2);
    if (d4 < d10) {
      d10 = d4;
    }
    if (d4 > d11) {
      d11 = d4;
    }
    if (iprsup >= 1) {
      write(lunit6,
        "(' NEXT INPUT; K, J, NDX2, NDX3, NDX6,',' KSUS(NDX2), XTCS(NDX6) =',"
        "6i8,e13.3)"),
        k, j, ndx2, ndx3, ndx6, ivarb(ndx2), sptacs(ndx6);
    }
    statement_66340:;
  }
  statement_66330:
  a = d11;
  if (sptacs(nn + 1) >= 0.0f) {
    goto statement_11;
  }
  a = d10;
  goto statement_11;
  //C     --- MIN/MAX TRACKING, CONTROLLED ACCUMULATOR OR COUHTER ---       M39. 255
  statement_664:
  ndx4 = kxtcs + ivarb(n1 + 3);
  if (ndx4 == kxtcs) {
    goto statement_6641;
  }
  if (sptacs(ndx4) <= flzero) {
    goto statement_6641;
  }
  a = sptacs(nn + 2);
  goto statement_6643;
  statement_6641:
  ndx5 = kxtcs + ivarb(n1 + 4);
  if (ndx5 == kxtcs) {
    goto statement_6642;
  }
  if (sptacs(ndx5) <= flzero) {
    goto statement_6642;
  }
  a = sptacs(nn);
  goto statement_11;
  statement_6642:
  if (n2 == 16) {
    goto statement_665;
  }
  a = sptacs(nn);
  rdev1 = sptacs(nn + 1);
  if (rdev1 ==  - 1.0f && b < a) {
    a = b;
  }
  if (rdev1 ==  + 1.0f && b > a) {
    a = b;
  }
  goto statement_6643;
  statement_665:
  a = sptacs(nn) + b;
  statement_6643:
  sptacs(nn) = a;
  goto statement_11;
  statement_666:
  ivarb(n1 + 4)++;
  k = ivarb(n1 + 3);
  if (ivarb(n1 + 4) > k) {
    ivarb(n1 + 4) = 1;
  }
  ndx1 = nn + ivarb(n1 + 4);
  sptacs(ndx1) = b * b;
  FEM_DO_SAFE(ji, 1, k) {
    a += sptacs(nn + ji);
  }
  a = sqrtz(a * sptacs(nn));
  goto statement_11;
  statement_667:
  j = ivarb(n1 + 1);
  k = ivarb(n1 + 2);
  b = 0.0f;
  FEM_DO_SAFE(mj, j, k) {
    n = kksus + mj;
    if (ivarb(n) == 9) {
      goto statement_1166;
    }
    m = kalksu + mj;
    bb = sptacs(kxtcs + ivarb(m)) * ivarb(n);
    nj = mj;
    statement_1144:
    nj = nj - 1;
    n = n - 1;
    m = m - 1;
    if (nj < j) {
      goto statement_1155;
    }
    if (ivarb(n) != 9) {
      goto statement_1155;
    }
    bb = bb * sptacs(kxtcs + ivarb(m));
    goto statement_1144;
    statement_1155:
    b += bb;
    statement_1166:;
  }
  a = b * sptacs(nn + 3);
  aa = a * sptacs(nn);
  if (aa >= sptacs(nn + 1)) {
    goto statement_6677;
  }
  a = sptacs(nn + 1) / sptacs(nn);
  goto statement_11;
  statement_6677:
  if (aa <= sptacs(nn + 2)) {
    goto statement_11;
  }
  a = sptacs(nn + 2) / sptacs(nn);
  statement_11:
  ndx1 = nnn + i;
  sptacs(ndx1) = a;
  statement_10:
  i = ivarb(kinsup + i);
  if (i > 0) {
    goto statement_1234;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void tacs3(
  common& cmn) try
{
  common_write write(cmn);
  double& t = cmn.t;
  double& twopi = cmn.twopi;
  double& flzero = cmn.flzero;
  const auto& lstat = cmn.lstat;
  int& istep = cmn.istep;
  int& iprsup = cmn.iprsup;
  auto& sptacs = cmn.sptacs;
  const auto& texvec = cmn.texvec;
  const auto& tclose = cmn.tclose;
  const auto& kpos = cmn.kpos;
  const auto& e = cmn.e;
  const auto& etac = cmn.etac;
  //
  //int kcolcs = fem::int0;
  //int katcs = fem::int0;
  //int konsup = fem::int0;
  //int kprsup = fem::int0;
  //int kaliu = fem::int0;
  //int kiuty = fem::int0;
  //int kud1 = fem::int0;
  //int kxtcs = fem::int0;
  //int klntab = fem::int0;
  //int kisblk = fem::int0;
  //int krsblk = fem::int0;
  //int kksus = fem::int0;
  //int kalksu = fem::int0;
  //int kinsup = fem::int0;
  //int nuk = fem::int0;
  //int ia = fem::int0;
  //int nsu = fem::int0;
  //int niu = fem::int0;
  //int nsup = fem::int0;
  //int ioutcs = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int niunrs = fem::int0;
  int kjsup = fem::int0;
  int kksup = fem::int0;
  int ma1 = fem::int0;
  int ma2 = fem::int0;
  int ndx1 = fem::int0;
  int konsce = fem::int0;
  int i = fem::int0;
  int ndy5 = fem::int0;
  int n1 = fem::int0;
  int j = fem::int0;
  int n13 = fem::int0;
  double d1 = fem::double0;
  int k = fem::int0;
  int L = fem::int0;
  int n2 = fem::int0;
  int ndx2 = fem::int0;
  int ndx5 = fem::int0;
  int nuki = fem::int0;
  int nukr = fem::int0;
  int m = fem::int0;
  int ndx4 = fem::int0;
  int mm = fem::int0;
  int n = fem::int0;
  int j1 = fem::int0;
  int k1 = fem::int0;
  double b = fem::double0;
  int nn = fem::int0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  int ndx6 = fem::int0;
  double prx = fem::double0;
  int i1 = fem::int0;
  int ma3 = fem::int0;
  int i2 = fem::int0;
  int ma4 = fem::int0;
  double pru = fem::double0;
  int i3 = fem::int0;
  int jcm = fem::int0;
  int n22 = fem::int0;
  double ppp = fem::double0;

  // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;

  auto& kcolcs = isptacs(5);
  auto& katcs =  isptacs(7);
  auto& konsup = isptacs(8);
  auto& kprsup = isptacs(9);
  auto& kaliu =  isptacs(11);
  auto& kiuty =  isptacs(13);
  auto& kud1 =   isptacs(14);
  auto& kxtcs =  isptacs(17);
  auto& klntab = isptacs(18);
  auto& kisblk = isptacs(19);
  auto& krsblk = isptacs(20);
  auto& kksus =  isptacs(21);
  auto& kalksu = isptacs(22);
  auto& kinsup = isptacs(23);

  auto& nuk = lstat(51);
  auto& ia = lstat(52);
  auto& nsu = lstat(53);
  auto& niu = lstat(54);
  auto& nsup = lstat(55);
  auto& ioutcs = lstat(59);
  //C     INTRINSIC  ABSZ, COSZ                                             M32.5939
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE TACS3.\"')");
  }
  niunrs = ivarb(kiuty + 1);
  kjsup = kinsup + lstat(65);
  kksup = kjsup + lstat(65);
  ma1 = ivarb(kiuty + 7);
  ma2 = ivarb(kiuty + 8);
  if (iprsup < 2) {
    goto statement_3219;
  }
  write(lunit6,
    "('  IOUTCS  ISPRIN  ISPLOT  LIMSTP    IOUT',/,5i8)"), ioutcs,
    cmn.isprin, cmn.isplot, cmn.limstp, cmn.iout;
  write(lunit6,
    "('    KTAB     NIU     NUK  NENERG  INFEXP',/,1x,i7,12i8)"),
    cmn.ktab, niu, nuk, cmn.nenerg, ivarb(kiuty + 11);
  write(lunit6,
    "(1x,14x,'T',10x,'TWOPI',9x,'FLTINF',11x,'XOPT',11x,'COPT',/,1x,8e15.6)"),
    t, twopi, cmn.fltinf, cmn.xopt, cmn.copt;
  //C                                       $$$  UPDATE  INPUT  SOURCES  $$$M13.2618
  statement_3219:
  if (cmn.nchain == 18) {
    goto statement_900;
  }
  ndx1 = kxtcs + nuk + 1;
  sptacs(ndx1) = t;
  ndx1++;
  sptacs(ndx1) = istep;
  ndx1++;
  sptacs(ndx1) = cmn.deltat;
  konsce = sptacs(1);
  if (konsce < niunrs) {
    goto statement_505;
  }
  i = niunrs;
  ndy5 = kud1;
  statement_3456:
  n1 = ivarb(kiuty + i);
  j = i + nuk;
  statement_510:
  ndx1 = kxtcs + j;
  sptacs(ndx1) = 0.0f;
  n13 = 0;
  d1 = std::abs(sptacs(ndy5 + 5) - sptacs(ndy5 + 4) - cmn.onehaf);
  if (d1 < flzero) {
    n13 = 1;
  }
  if (iprsup >= 6) {
    write(lunit6,
      "(/,1x,'   ISTEP       I',17x,'UD5',17x,'UD4',18x,'D1',/,1x,2i8,"
      "3e20.11)"),
      istep, i, sptacs(ndy5 + 5), sptacs(ndy5 + 4), d1;
  }
  if (t < sptacs(ndy5 + 4) - flzero * 10.f) {
    goto statement_500;
  }
  if (t >= sptacs(ndy5 + 5) - flzero * 10.f) {
    goto statement_500;
  }
  if (n1 < 90) {
    goto statement_501;
  }
  k = sptacs(ndy5 + 2);
  L = fem::iabs(kpos(k));
  if (n1 > 93) {
    goto statement_500;
  }
  n2 = n1 - 89;
  switch (n2) {
    case 1: goto statement_502;
    case 2: goto statement_503;
    case 3: goto statement_504;
    case 4: goto statement_506;
    default: break;
  }
  statement_502:
  sptacs(ndx1) = e(k);
  goto statement_500;
  statement_503:
  if (n13 == 0) {
    goto statement_509;
  }
  if (L == 11) {
    sptacs(ndx1) = tclose(k);
  }
  goto statement_500;
  statement_509:
  if (L <= 3) {
    sptacs(ndx1) = tclose(k);
  }
  goto statement_500;
  statement_504:
  sptacs(ndx1) = etac(k);
  goto statement_500;
  statement_506:
  if (L <= 3) {
    sptacs(ndx1) = 1.0f;
  }
  goto statement_500;
  statement_501:
  sptacs(ndx1) = sptacs(ndy5 + 1);
  if (n1 == 11) {
    goto statement_500;
  }
  if (n1 != 14) {
    goto statement_511;
  }
  sptacs(ndx1) = sptacs(ndx1) * cosz(twopi * sptacs(ndy5 + 3) * t +
    sptacs(ndy5 + 2));
  statement_511:
  if (n1 != 23) {
    goto statement_512;
  }
  if (t < sptacs(ndy5 + 4) + sptacs(ndy5 + 2) - flzero * 10.f) {
    goto statement_500;
  }
  sptacs(ndy5 + 4) += sptacs(ndy5 + 3);
  goto statement_510;
  statement_512:
  if (n1 != 24) {
    goto statement_500;
  }
  if (t < sptacs(ndy5 + 4) + sptacs(ndy5 + 3) - flzero * 10.f) {
    goto statement_513;
  }
  sptacs(ndy5 + 4) += sptacs(ndy5 + 3);
  goto statement_512;
  statement_513:
  ndx2 = kxtcs + j;
  sptacs(ndx2) = sptacs(ndx2) * (t - sptacs(ndy5 + 4)) / sptacs(ndy5 + 3);
  if (std::abs(sptacs(ndx2)) <= 10.f * flzero) {
    sptacs(ndx2) = 0.0f;
  }
  statement_500:
  i++;
  ndy5 += 5;
  if (i <= konsce) {
    goto statement_3456;
  }
  statement_505:
  if (iprsup < 6) {
    goto statement_3030;
  }
  write(lunit6,
    "(/,' TABLES IN  ''TACS3'' .',/,5x,'ROW',4x,'IUTY',6x,'IU',4x,'KPOS',14x,"
    "'E',12x,'UD1',12x,'UD2',12x,'UD3',9x,'TCLOSE',11x,'XTCS')");
  ndx5 = kud1 - 5;
  FEM_DO_SAFE(k, 1, konsce) {
    ndx1 = ivarb(kaliu + k);
    if (k > 11) {
      goto statement_4848;
    }
    write(lunit6, "(2i8,2x,a6,i8,e15.6,45x,2e15.6)"), k, ivarb(kiuty + k),
      texvec(ndx1), kpos(k), e(k), tclose(k), sptacs(kxtcs + nuk + k);
    goto statement_4040;
    statement_4848:
    ndx5 += 5;
    write(lunit6, "(2i8,2x,a6,i8,6e15.6)"), k, ivarb(k + kiuty),
      texvec(ndx1), kpos(k), e(k), sptacs(ndx5 + 1), sptacs(ndx5 + 2),
      sptacs(ndx5 + 3), tclose(k), sptacs(kxtcs + nuk + k);
    statement_4040:;
  }
  statement_3030:
  L = ivarb(kiuty + 4);
  if (L > 0) {
    csup(cmn, L);
  }
  //C                                                 $$$  FORM  RHSIDE  $$$M13.2653
  ndx1 = nuk * 4;
  FEM_DOSTEP(i, 4, ndx1, 4) {
    sptacs(krsblk + i) = 0.0f;
  }
  nuki = kisblk - 8;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    if (ivarb(nuki + 2) == 1) {
      goto statement_304;
    }
    k = kprsup + ivarb(nuki + 3) + 4;
    j = krsblk + ivarb(nuki + 4) * 4;
    sptacs(j) += sptacs(k);
    statement_304:;
  }
  //C                                          $$$  FORWARD  ON  RHSIDE  $$$M13.2660
  nuki = kisblk - 8;
  nukr = krsblk - 4;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    nukr += 4;
    m = ivarb(nuki + 8);
    statement_301:
    k = ivarb(kcolcs + m);
    if (k >= i) {
      goto statement_305;
    }
    ndx4 = krsblk + k * 4;
    sptacs(nukr + 4) = sptacs(nukr + 4) - sptacs(katcs + m) * sptacs(ndx4);
    m++;
    goto statement_301;
    statement_305:
    sptacs(nukr + 4) = sptacs(nukr + 4) * sptacs(katcs + m);
  }
  //C                                           $$$  BACKWARD  ON  XTCS  $$$M37.5260
  mm = 1;
  nuki = kisblk + 8 * nuk;
  nukr = krsblk + 4 * nuk;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki = nuki - 8;
    nukr = nukr - 4;
    j = nuk + 1 - i;
    ndx1 = kxtcs + j;
    sptacs(ndx1) = sptacs(nukr + 4);
    m = ivarb(nuki + 8);
    n = ia;
    if (j != nuk) {
      n = ivarb(nuki + 16) - 1;
    }
    statement_309:
    if (ivarb(kcolcs + m) == j) {
      goto statement_334;
    }
    m++;
    goto statement_309;
    statement_334:
    m++;
    if (m > n) {
      goto statement_324;
    }
    k = ivarb(kcolcs + m);
    ndx4 = kxtcs + k;
    sptacs(ndx1) = sptacs(ndx1) - sptacs(katcs + m) * sptacs(ndx4);
    goto statement_334;
    statement_324:
    j1 = ivarb(nuki + 5);
    k1 = ivarb(nuki + 6);
    if (j1 > 0) {
      sptacs(nukr + 2) = sptacs(kxtcs + j1);
    }
    if (k1 > 0) {
      sptacs(nukr + 3) = sptacs(kxtcs + k1);
    }
    if (sptacs(ndx1) < sptacs(nukr + 2)) {
      sptacs(ndx1) = sptacs(nukr + 2);
    }
    if (sptacs(ndx1) > sptacs(nukr + 3)) {
      sptacs(ndx1) = sptacs(nukr + 3);
    }
    if (sptacs(nukr + 2) <= sptacs(nukr + 3)) {
      goto statement_308;
    }
    if (ivarb(kiuty + 3) == 0) {
      goto statement_308;
    }
    ndx1 = ivarb(klntab + j);
    write(lunit6,
      "(5x,'WARNING. ---- THE VARIABLE LIMITS WHICH APPLY TO THE TACS FUNCTION"
      " BLOCK WITH (OUTPUT) NAME  ''',a6,'''  HAVE',/,19x,"
      "'CRISS-CROSSED.   THAT IS, THE UPPER LIMIT IS NOW LESS THAN THE LOWER L"
      "IMIT, AT TIME',e14.5,'  SECONDS.',/,19x,"
      "'ALTHOUGH THE SIMULATION WILL CONTINUE, STRANGE RESULTS MIGHT BE EXPECT"
      "ED (BE SKEPTICAL).   THERE SHALL BE',/,19x,"
      "'NO WARNING MESSAGE FOR ANY SUBSEQUENT CRISS-CROSSING OF THE LIMITS OF "
      "ANY TACS BLOCK.')"),
      texvec(ndx1), t;
    ivarb(kiuty + 3) = ivarb(kiuty + 3) - 1;
    statement_308:
    L = ivarb(nuki + 7);
    if (L > 0) {
      csup(cmn, L);
    }
  }
  //C                                                       $$$  OUTPUT  $$$M13.2708
  FEM_DO_SAFE(i, 1, nsup) {
    n1 = -ivarb(kjsup + i);
    if (n1 < 0) {
      goto statement_1010;
    }
    if (ivarb(kksup + i) != 53) {
      goto statement_1010;
    }
    j = ivarb(n1 + 1);
    k = ivarb(n1 + 2);
    b = 0.0f;
    FEM_DO_SAFE(n, j, k) {
      m = ivarb(kalksu + n);
      b += sptacs(kxtcs + m) * ivarb(kksus + n);
    }
    nn = ivarb(n1);
    n5 = sptacs(nn);
    n6 = sptacs(nn + 2);
    n7 = ivarb(n1 + 4);
    ndx6 = kprsup + n7;
    sptacs(ndx6) = b;
    n7++;
    if (n7 == n5 + n6) {
      n7 = n5;
    }
    ivarb(n1 + 4) = n7;
    statement_1010:;
  }
  if (t > cmn.tmax) {
    goto statement_9900;
  }
  //C                                                  $$$  UPDATE  HST  $$$M13.2740
  if (nuk == 0) {
    goto statement_340;
  }
  nuki = kisblk - 8;
  nukr = krsblk - 4;
  FEM_DO_SAFE(i, 1, nuk) {
    nuki += 8;
    nukr += 4;
    if (ivarb(nuki + 2) == 1) {
      goto statement_3111;
    }
    L = ivarb(nuki + 4);
    prx = sptacs(kxtcs + L);
    j = fem::iabs(ivarb(nuki + 1));
    k = fem::iabs(ivarb(nuki + 9)) - 1;
    if (i == nuk) {
      k = nsu;
    }
    if (ivarb(nuki + 1) > 0) {
      goto statement_2345;
    }
    FEM_DO_SAFE(i1, ma1, ma2) {
      if (ivarb(i1) !=  - i) {
        goto statement_5656;
      }
      ma3 = i1 + 1;
      FEM_DO_SAFE(i2, ma3, ma2) {
        if (ivarb(i2) < 0) {
          goto statement_2345;
        }
        ma4 = i2;
      }
      goto statement_2345;
      statement_5656:;
    }
    statement_2345:
    pru = 0.0f;
    FEM_DO_SAFE(m, j, k) {
      n = ivarb(kalksu + m);
      if (ivarb(nuki + 1) > 0) {
        goto statement_5678;
      }
      n1 = n - lstat(64) - nuk;
      FEM_DO_SAFE(i3, ma3, ma4) {
        if (ivarb(i3) != n1) {
          goto statement_6789;
        }
        n += lstat(68);
        goto statement_5678;
        statement_6789:;
      }
      statement_5678:
      ndx1 = kxtcs + n;
      pru += sptacs(ndx1) * ivarb(kksus + m);
    }
    jcm = kprsup + ivarb(nuki + 3);
    k = ivarb(nuki + 2) - 1;
    j = jcm + 6 * k - 2;
    n1 = krsblk + L * 4 - 2;
    n2 = n1 + 1;
    if (prx == sptacs(n1) || prx == sptacs(n2)) {
      goto statement_2810;
    }
    if (k == 1) {
      goto statement_330;
    }
    n22 = jcm + 6;
    FEM_DOSTEP(n, n22, j, 6) {
      ppp = sptacs(n) * pru - sptacs(n + 1) * prx - sptacs(n - 2);
      sptacs(n - 2) = ppp + sptacs(n + 4);
    }
    statement_330:
    sptacs(j) = sptacs(j + 2) * pru - sptacs(j + 3) * prx;
    goto statement_311;
    //C                               $$$  DYNAMIC  LIMITER  HST  $$$         M42.6746
    statement_2810:
    n = j;
    sptacs(j) = sptacs(j + 2) * pru - sptacs(j + 3) * prx;
    statement_2840:
    if (k == 1) {
      goto statement_311;
    }
    k = k - 1;
    n = n - 6;
    sptacs(n) = (sptacs(n + 2) * pru - sptacs(n + 3) * prx + sptacs(
      n + 6)) / 2.0f;
    goto statement_2840;
    statement_311:
    if (iprsup >= 4) {
      {
        write_loop wloop(cmn, lunit6, "('  FUNCTION',i6,'  HST ',7e14.6)");
        wloop, i;
        FEM_DOSTEP(n, jcm, j, 6) {
          wloop, sptacs(n + 4);
        }
      }
    }
    statement_3111:;
  }
  ndx1 = kxtcs + nuk + lstat(64) + 1;
  ndx2 = ndx1 + lstat(68);
  mover(sptacs(ndx1), sptacs(ndx2), nsup);
  statement_340:
  return;
  //C                                                  $$$  TERMINATION  $$$M13.2769
  statement_900:
  L = nuk + lstat(64) + konsup + 1;
  csup(cmn, L);
  statement_9900:
  if (iprsup >= 1) {
    write(lunit6, "(/,' NORMAL TERMINATION OF RUN WITHIN  ''TACS3'' .')");
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void kwiter(
  common& cmn,
  arr_cref<int> /* idum */) try
{
  //C       VAX-11  INSTALLATION-DEPENDENT EMTP MODULE WHICH SERVES         M35.2872
  //C       CONTROL INTERACTIVE USAGE.  IF NONE, DESTROY THE MODULE.        M35.2873
  //C       PURPOSE IS TO SENSE USER-KEYED INTERRUPT, AND SET FLAG.         M35.2874
  //C       NAME "COMKWT" IS RESERVED (CONNECTED TO "CONTROLC.OBJ")         M35.2875
  cmn.kwtvax = 1;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void window(
  common& cmn)
{
  common_write write(cmn);
  fem::str<132>& munit6 = cmn.munit6;
  //
  int j = fem::int0;
  int k = fem::int0;
  auto& lunit6 = cmn.lunit6;
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M37.7059
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M37.7060
  //C     FOR CHARACTER*132 SPY DISPLAY CHANNEL MUNIT6, THIS SERVES         M37.7061
  //C     TO ACTUALLY OUTPUT THE LINE TO THE SPY DISPLAY DEVICE.            M37.7062
  //C       VAX-11  INSTALLATION-DEPENDENT EMTP MODULE.                     M37.7063
  //C     TEMPORARILY, UNTIL WE LEARN HOW TO WRITE TO A 2ND CRT FOR         M37.7066
  //C     VAX/VMS, WE WILL JUST WRITE TO LUNIT6:                            M37.7067
  //C NO SPY WINDOWS
  if (fem::iabs(cmn.kverfy) == 34543) {
    goto statement_9000;
  }
  //C SEARCH LINE FOR RIGHT MOST NON-BLANK
  FEM_DO_SAFE(j, 1, 132) {
    //C REVERSE INDEX (STEP FROM RIGHT TO LEFT)
    k = 133 - j;
    //C END OF LINE
    if (munit6(k, k) != " ") {
      goto statement_5621;
    }
    //C END  DO 5614  LOOP TO FIND RIGHT EDGE OF LINE
  }
  //C OUTPUT NONBLANK PART
  statement_5621:
  write(lunit6, "(a)"), munit6(1, k);
  statement_9000:;
}

void flager(
  common& cmn) try
{
  common_read read(cmn);
  common_write write(cmn);
  int& kwtspy = cmn.kwtspy;
  int& lastov = cmn.lastov;
  int& kfile5 = cmn.kfile5;
  int& kspsav = cmn.kspsav;
  int& iprspy = cmn.iprspy;
  fem::str<80>& buff77 = cmn.buff77;
  auto& file6 = cmn.file6;
  fem::str<132>& munit6 = cmn.munit6;
  int& kwtvax = cmn.kwtvax;
  //
  //C     MODULE OF INTERACTIVE EMTP ONLY, WHICH SERVICES "EMTSPY".         M35.2852
  //C     IF NO INTERACTIVE USE, CONVERT TO DUMMY MODULE ("RETURN").        M35.2853
  //C       VAX-11 INSTALLATION-DEPENDENT EMTP MODULE WHICH SERVES          M35.2854
  //C       TO READ SPY COMMAND FROM MUNIT5 IF: 1) CTRL-C INTERRUPT         M38.4529
  //C       HAS OCCURRED, OR 2) IF  LOCKBR = 1  UPON ENTRY.                 M38.4530
  //C MAGIC BLOCK FOR CTRL-C TRAPPING
  //C  DUMMY VECTOR FOR CTRL-C HANDLING
  //C NEEDED FOR CTRL-C INITIALIZATION
  //C JUMP AROUND DIAGNOSTIC
  if (iprspy < 10) {
    goto statement_3456;
  }
  write(munit6,
    "(' TOP FLAGER.  ISTEP, KWTSPY, ITYPE, LASTOV =',4i6)"),
    cmn.istep, kwtspy, cmn.itype, lastov;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C NOT "PLTFIL" OVERFLOW
  statement_3456:
  if (lastov != 9911) {
    goto statement_3614;
  }
  //C NEXT SPY COMMAND WE WANT TO EXECUTE
  buff77 = "SPACE";
  //C SET FLAG FOR GLOBAL EMTP USE (REMEMBER)
  kwtspy = 1;
  //C SIGNAL TO "SPYING" THAT BUFF77 NOW READ
  kfile5 = 2;
  //C EXIT MODULE AFTER POSSIBLE DIAGNOSTIC
  goto statement_3651;
  //C NO USER-KEYED INTERRUPT
  statement_3614:
  if (kwtvax == 0) {
    goto statement_3642;
  }
  //C PROMPT FOR SPY KEYBOARD INPUT
  write(cmn.prom80, "(' SPY:')");
  //C WRITE PROM80 WITH CURSOR CONTROL (NO LF)
  prompt(cmn);
  //C RESET FLAG OF CTRL-C INTERCEPTION FOR NEXT
  kwtvax = 0;
  //C     CALL ENABLE_CTRL_C ( KWITER, IDUM(1) )  ! RE-ENABLE IT            M35.2865
  //C JUMP AROUND DIAGNOSTIC
  if (iprspy < 1) {
    goto statement_3491;
  }
  write(munit6, "(' ENABLE VAX CTRL-C INTERCEPTION IN \"FLAGER\".')");
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C JUMP TO READ FROM UNIT MUNIT5 (KEYBOARD)
  statement_3491:
  goto statement_3643;
  //C NO FORCED INPUT
  statement_3642:
  if (cmn.lockbr != 1) {
    goto statement_3651;
  }
  //C "@" READ OUT IN EMTSPY
  if (kfile5 == 1) {
    goto statement_3651;
  }
  //C READ NEXT SPY INPUT
  statement_3643:
  read(cmn.munit5, "(a80)"), buff77;
  //C SET FLAG FOR GLOBAL EMTP USE (REMEMBER)
  kwtspy = 1;
  //C SIGNAL TO "SPYING" THAT BUFF77 NOW READ
  kfile5 = 2;
  //C NO ECHOING OF SPY COMMAND
  if (kspsav == 0) {
    goto statement_3650;
  }
  if (buff77(1, 7) != "CANCEL ") {
    goto statement_3648;
  }
  //C ERASE PREVIOUS, ERRONEOUS COMMAND
  kspsav++;
  //C LOOP BACK FOR ANOTHER, A REAL, COMMAND
  goto statement_3643;
  //C NEXT FILE6 CELL TO SAVE BUFF77 IN
  statement_3648:
  kspsav = kspsav - 1;
  //C NO OVERLAP YET
  if (kspsav > cmn.numcrd) {
    goto statement_3649;
  }
  write(6, star), " ERROR STOP; OVERFLOW IN \"FLAGER\".";
  //C INSTALLATION-DEPENDENT FORTRAN STOP
  stoptp(cmn);
  //C ACCUMULATE USER-KEYED SPY INPUT
  statement_3649:
  file6(kspsav) = buff77;
  //C EXIT MODULE WITH 80-COL. BUFF77 CARD NOW READ
  statement_3650:
  goto statement_3651;
  statement_3651:
  if (iprspy < 9) {
    goto statement_9000;
  }
  write(munit6,
    "(' EXIT \"FLAGER\".  KWTSPY =',i4,'   BUFF77 = ',a80)"), kwtspy,
    buff77;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  statement_9000:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void quiter(
  common& cmn) try
{
  // COMMON spykom
  int& kfile5 = cmn.kfile5;
  int& lockbr = cmn.lockbr;
  //
  //C     MODULE OF INTERACTIVE EMTP ONLY, WHICH SERVICES "EMTSPY".         M38.4568
  //C     IF NO INTERACTIVE USE, CONVERT TO DUMMY MODULE ("RETURN").        M38.4569
  //C     THIS MODULE PROVIDES A SPECIAL-PURPOSE CONNECTION TO THE          M38.4570
  //C     MORE GENERAL "FLAGER".  HERE, WE ONLY WANT TO SENSE A             M38.4571
  //C     USER-KEYED INTERRUPT (NO SPY INPUT IS TO BE READ).                M38.4572
  //C SAVE CURRENT TIME-SLICING FLAG VALUE
  int n24 = lockbr;
  //C SAVE CURRENT STATUS OF INPUT CONNECTION
  int n25 = kfile5;
  //C TEMPORARILY TURN TIME-SHARING ON
  lockbr = 0;
  //C CHECK FOR USER-KEYED INTERRUPT, AND RETURN
  flager(cmn);
  //C RESTORE ORIGINAL VALUE OF B4 FLAGER USE
  lockbr = n24;
  //C RESTORE ORIGINAL VALUE OF B4 FLAGER USE
  kfile5 = n25;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct spyout_save
{
  arr<fem::str<1> > filbyt;
  arr<double> fkar1;
  arr<double> fkar2;
  arr<double> forbyt;
  int j;
  int k;
  int n11;
  int n12;
  arr<double> pltbuf;
  fem::str<8> terra;
  arr<fem::str<8> > text10;

  spyout_save() :
    filbyt(dimension(1), fem::fill0),
    fkar1(dimension(1), fem::fill0),
    fkar2(dimension(1), fem::fill0),
    forbyt(dimension(600), fem::fill0),
    j(fem::int0),
    k(fem::int0),
    n11(fem::int0),
    n12(fem::int0),
    pltbuf(dimension(1), fem::fill0),
    terra(fem::char0),
    text10(dimension(10), fem::fill0)
  {}
};

void spyout(
  common& cmn,
  int const& n1,
  int const& n2) try
{
  FEM_CMN_SVE(spyout);
  common_write write(cmn);
  const auto& bus = cmn.bus;
  fem::str<132>& munit6 = cmn.munit6;
  //
  int& j = sve.j;
  int& k = sve.k;
  int& n11 = sve.n11;
  int& n12 = sve.n12;
  fem::str<8>& terra = sve.terra;
  auto& text10 = sve.text10;
  if (is_called_first_time) {
    terra = "TERRA ";
  }
  //C     MODULE OF INTERACTIVE EMTP ONLY, WHICH SERVICES "EMTSPY".         M37.7087
  //C     IF NO INTERACTIVE USE, THIS MODULE CAN BE DELETED.                M37.7088
  //C     ARGUMENTS N1 AND N2 ARE NODE NOS., WITH POSSIBLE "-" SIGNS.       M37.7089
  //C     PURPOSE IS TO LOAD AND PRINT CORRESPONDING NAMES FOR "OUTPUT"     M37.7090
  n11 = n1;
  n12 = n2;
  //C     FIRST CHECK FOR SPECIAL INITIALIZATION OR FLUSHING CALLS:         M37.7098
  if (n11 != 7878) {
    goto statement_4618;
  }
  k = 0;
  goto statement_9000;
  statement_4618:
  if (n11 !=  - 7878) {
    goto statement_4626;
  }
  statement_4621:
  if (k <= 0) {
    goto statement_9000;
  }
  {
    write_loop wloop(munit6, "(7x,10a7)");
    FEM_DO_SAFE(j, 1, k) {
      wloop, text10(j);
    }
  }
  window(cmn);
  k = 0;
  goto statement_9000;
  //C     INSERT FIRST NODE NAME INTO BUFFER:                               M37.7108
  statement_4626:
  if (n11 < 0) {
    n11 = -n11;
  }
  k++;
  text10(k) = bus(n11);
  if (n11 == 1) {
    text10(k) = terra;
  }
  if (k == 10) {
    goto statement_4621;
  }
  if (n12 == 0) {
    goto statement_9000;
  }
  if (n12 < 0) {
    n12 = -n12;
  }
  k++;
  text10(k) = bus(n12);
  if (n12 == 1) {
    text10(k) = terra;
  }
  if (k == 10) {
    goto statement_4621;
  }
  statement_9000:
  if (cmn.iprspy < 3) {
    goto statement_9007;
  }
  write(munit6, "(' EXIT \"SPYOUT\".  N1, N2, K, N11, N12 =',5i6)"),
    n1, n2, k, n11, n12;
  window(cmn);
  statement_9007:;
  //C
  //C     %%%%  BOUNDARY FOR OVER6 AND OVER8 "LABCOM" DUMPING               M32.  66
  //C!REAL*8  BUS
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void frefix(
  common& cmn,
  str_ref ansi,
  int const& n8) try
{
  common_write write(cmn);
  int& iprspy = cmn.iprspy;
  const auto& digit = cmn.digit;
  fem::str<132>& munit6 = cmn.munit6;
  //
  fem::str<80> hold = fem::char0;
  int kk = fem::int0;
  int i = fem::int0;
  int n5 = fem::int0;
  int n13 = fem::int0;
  int n14 = fem::int0;
  int j = fem::int0;
  int n3 = fem::int0;
  int n16 = fem::int0;
  int k = fem::int0;
  int n2 = fem::int0;
  int n1 = fem::int0;
  //C     UNIVERSAL MODULE USED ONLY BY INTERACTIVE EMTP ("EMTSPY").        M35.4320
  //C     FOR NON-INTERACTIVE USE ONLY, IT CAN BE DESTROYED.                M35.4321
  //C     THIS MODULE IS CALLED BY "FREFP1", "FREIN1", ETC. --- ALL         M35.4322
  //C     OF THE FREE-FIELD INPUT MODULES OF SPY USAGE.  IT CHECKS          M35.4323
  //C     FOR LEGAL NUMERICAL DATA, AND WILL RE-PROMPT FOR MORE IF          M35.4324
  //C     THE USER HAS MADE A MISTAKE, THEREBY AVOIDING POSSIBLE            M35.4325
  //C     DEATH OF INTERACTIVE EMTP EXECUTION DUE TO TYPING ERROR.          M35.4326
  //C     ANSI IS THE INPUT BEING PROCESSED, FOR N8 NUMBERS.  UPON          M35.4327
  //C     EXIT, ANSI WILL BE CONVERTED TO 4E20.0 FIXED-FORMAT DATA.         M35.4328
  if (iprspy < 3) {
    goto statement_3582;
  }
  write(munit6,
    "(' TOP OF \"FREFIX\".  N8 =',i5,'   ANSI(1:40) = ',a40)"), n8,
    ansi(1, 40);
  window(cmn);
  statement_3582:
  hold(1, 80) = " ";
  kk = 0;
  i = 0;
  goto statement_3648;
  statement_3612:
  if (ansi(i, i) == " " || ansi(i, i) == "," || i >= 80) {
    goto statement_3615;
  }
  i++;
  goto statement_3612;
  statement_3615:
  n5 = i - 1;
  kk++;
  n13 = 0;
  n14 = 0;
  FEM_DO_SAFE(j, n3, n5) {
    if (ansi(j, j) != "+" && ansi(j, j) != "-") {
      goto statement_3617;
    }
    if (j == n3) {
      goto statement_3642;
    }
    n16 = j - 1;
    if (ansi(n16, n16) == "E" || ansi(n16, n16) == "D") {
      goto statement_3642;
    }
    goto statement_3758;
    statement_3617:
    if (ansi(j, j) != ".") {
      goto statement_3626;
    }
    n14++;
    if (n14 <= 1) {
      goto statement_3642;
    }
    goto statement_3758;
    statement_3626:
    if (ansi(j, j) != "D" && ansi(j, j) != "E") {
      goto statement_3634;
    }
    n13++;
    if (n13 <= 1) {
      goto statement_3642;
    }
    goto statement_3758;
    statement_3634:
    FEM_DO_SAFE(k, 1, 10) {
      if (ansi(j, j) == digit(k)) {
        goto statement_3642;
      }
    }
    goto statement_3758;
    statement_3642:;
  }
  n2 = 20 * kk;
  n1 = n2 - (n5 - n3);
  hold(n1, n2) = ansi(n3, n5);
  if (kk >= n8) {
    goto statement_4100;
  }
  statement_3648:
  i++;
  if (i > 80) {
    goto statement_3758;
  }
  if (ansi(i, i) == " ") {
    goto statement_3648;
  }
  n3 = i;
  goto statement_3612;
  statement_3758:
  write(cmn.prom80,
    "('   @@@  Illegal data in column',i3,' [',a5,'].  Resend line or END :')"),
    j, ansi(j - 2, j + 2);
  prompt(cmn);
  write(6, star), " OK, \"FREFIX\" CALL TO \"FLAGER\" BEGINS.";
  cmn.lockbr = 1;
  flager(cmn);
  write(6, star), " OK, BACK IN \"FREFIX\" WITH BUFF77 AGAIN.";
  ansi = cmn.buff77;
  if (ansi(1, 4) != "END ") {
    goto statement_3582;
  }
  ansi(1, 80) = " ";
  goto statement_4103;
  statement_4100:
  ansi(1, n2) = hold(1, n2);
  statement_4103:
  if (iprspy < 2) {
    goto statement_4109;
  }
  write(munit6, "(' EXIT \"FREFIX\".  ANSI(1:N2) =',a80)"), ansi(1, n2);
  window(cmn);
  statement_4109:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void frein2(
  common& cmn,
  str_ref ansi,
  int& n12,
  int& n13) try
{
  common_read read(cmn);
  //C     UNIVERSAL MODULE (WORKS FOR ANY COMPUTER) USED ONLY FOR THE       M35.4306
  //C     INTERACTIVE EMTP ("EMTSPY").  IT IS CALLED TO DECODE TWO          M35.4307
  //C     INTEGER NUMBERS N12 AND N13 FROM CHARACTER*80 INPUT ANSI.         M35.4308
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4309
  int n8 = 2;
  frefix(cmn, ansi, n8);
  double d12 = fem::double0;
  double d13 = fem::double0;
  read(ansi, "(3e20.0)"), d12, d13;
  n12 = d12;
  n13 = d13;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void intpar(
  common& cmn,
  int const& max,
  int& n1,
  int& n2,
  int& kill) try
{
  common_write write(cmn);
  fem::str<20>& bytbuf = cmn.bytbuf;
  const auto& digit = cmn.digit;
  fem::str<132>& munit6 = cmn.munit6;
  //
  int i = fem::int0;
  int n13 = fem::int0;
  int n6 = fem::int0;
  int j = fem::int0;
  int n22 = fem::int0;
  int n17 = fem::int0;
  int n33 = fem::int0;
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M35.4064
  //C     THIS MODULE IS DESIGNED TO EXTRACT TWO FREE-FORMAT ROW NUMBERS    M35.4065
  //C     FROM  BYTBUF(20)  INPUT BUFFER OF COMMON.   THESE NUMBERS MUST    M35.4066
  //C     BE POSITIVE, ORDERED (1ST LESS THAN OR EQUAL TO 2ND), AND NOT     M35.4067
  //C     IN EXCESS OF THE LAST TABLE ROW "MAX".   THE TO ROW NUMBERS ARE   M35.4068
  //C     PASSED BACK AS  "N1"  AND  "N2"  ARGUMENTS.   IF THIS EXTRACTION  M35.4069
  //C     WAS SUCCESSFUL,  "KILL"  IS SET TO ZERO;  IF IT FAILED,  KILL = 1.M35.4070
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4071
  kill = 0;
  //C     CHECK FOR ENGLISH REQUEST "TOP" (FOR THE TOP OF THE FILE):        M35.4074
  if (bytbuf(1, 1) != "T") {
    goto statement_2071;
  }
  n1 = 1;
  n2 = 1;
  goto statement_2110;
  //C     CHECK FOR ENGLISH REQUEST "BOT" (FOR THE BOTTOM OF THE FILE):     M35.4079
  statement_2071:
  if (bytbuf(1, 1) != "B") {
    goto statement_2075;
  }
  n1 = max;
  n2 = max;
  goto statement_2110;
  //C     CHECK FOR ENGLISH REQUEST "ALL" (FOR THE ENTIRE FILE):            M35.4084
  statement_2075:
  if (bytbuf(1, 1) != "A") {
    goto statement_2088;
  }
  n1 = 1;
  n2 = max;
  goto statement_2110;
  statement_2088:
  FEM_DO_SAFE(i, 1, 20) {
    n13 = 21 - i;
    if (bytbuf(n13, n13) == " ") {
      goto statement_2046;
    }
    if (bytbuf(n13, n13) != ",") {
      goto statement_2054;
    }
    n6 = 20 - i;
    FEM_DO_SAFE(j, 1, n6) {
      n13 = 21 - i + j;
      bytbuf(n13, n13) = bytbuf(j, j);
    }
    goto statement_2054;
    statement_2046:;
  }
  statement_2054:
  n22 = 0;
  n13 = 0;
  FEM_DO_SAFE(i, 1, 20) {
    n17 = i - 1;
    if (bytbuf(i, i) != " ") {
      goto statement_2091;
    }
    //C     BLANK IS IGNORED IF BEFORE 1ST DIGIT, OF IF NOT 1ST OF STRING:    M35.4104
    if (n22 == 0) {
      goto statement_2104;
    }
    if (bytbuf(n17, n17) == " ") {
      goto statement_2104;
    }
    if (bytbuf(n17, n17) == ",") {
      goto statement_2104;
    }
    n13++;
    goto statement_2104;
    //C     BEGIN PROCESSING OF NON-BLANK CHARACTER  BYTBUF(I) :              M35.4110
    statement_2091:
    n22++;
    if (bytbuf(i, i) != ",") {
      goto statement_2093;
    }
    if (bytbuf(n17, n17) == " ") {
      goto statement_2104;
    }
    n13++;
    goto statement_2104;
    statement_2093:
    FEM_DO_SAFE(j, 1, 10) {
      if (bytbuf(i, i) == digit(j)) {
        goto statement_2104;
      }
    }
    statement_2104:;
  }
  if (n22 > 0) {
    goto statement_2109;
  }
  //C     BLANK RESPONSE IS INTERPRETED AS A REQUEST FOR MORE OF SAME:      M35.4123
  n1 = n2 + 1;
  if (n1 <= max) {
    goto statement_2107;
  }
  write(munit6, "('    ---- Wrap around, end to beginning ----')");
  window(cmn);
  n1 = 1;
  statement_2107:
  n2 = n1 + n33;
  goto statement_2110;
  statement_2109:
  if (n13 == 2) {
    goto statement_2132;
  }
  write(munit6,
    "(' \?\?\?\?  ILLEGAL DATA (NOT BLANK OR TWO DEC',"
    "' FREE-FORMAT INTEGERS.   TRY AGAIN.')");
  window(cmn);
  write(munit6,
    "('       IS IT POSSIBLE USER\"S DATA HAS NO',"
    "' SUCH TABLE (OTHER CAUSE OF MESSAGE)?')");
  window(cmn);
  kill = 1;
  goto statement_9000;
  statement_2132:
  frein2(cmn, bytbuf, n1, n2);
  n33 = n2 - n1;
  statement_2110:
  if (n1 <= 0) {
    n1 = 1;
  }
  if (n2 > max) {
    n2 = max;
  }
  statement_9000:
  if (cmn.iprspy < 1) {
    goto statement_9006;
  }
  write(munit6,
    "(' RETURN FROM \"INTPAR\".  MAX, N1, N2, KILL =',4i6)"), max,
    n1, n2, kill;
  window(cmn);
  statement_9006:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void getnum(
  common& cmn,
  int& num) try
{
  common_write write(cmn);
  int& ibegcl = cmn.ibegcl;
  int& iendcl = cmn.iendcl;
  int& iprspy = cmn.iprspy;
  fem::str<20>& bytbuf = cmn.bytbuf;
  const auto& digit = cmn.digit;
  fem::str<132>& munit6 = cmn.munit6;
  //
  int n1 = fem::int0;
  int i = fem::int0;
  fem::str<1> c4 = fem::char0;
  int j = fem::int0;
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M35.4009
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4010
  if (iprspy < 1) {
    goto statement_4204;
  }
  write(munit6,
    "(' BEGIN  \"GETNUM\".   IBEGCL =',i5,'      BYTBUF(IBEGCL) =',a1)"),
    ibegcl, bytbuf(ibegcl, ibegcl);
  window(cmn);
  statement_4204:
  n1 = 1;
  num = 0;
  FEM_DO_SAFE(i, ibegcl, 20) {
    c4 = bytbuf(i, i);
    if (c4 == " ") {
      goto statement_4286;
    }
    if (c4 == ":") {
      goto statement_4286;
    }
    if (c4 == "#") {
      goto statement_4286;
    }
    if (c4 == ",") {
      goto statement_4286;
    }
    if (c4 == "+") {
      goto statement_4265;
    }
    if (c4 != "-") {
      goto statement_4218;
    }
    n1 = -1;
    goto statement_4265;
    statement_4218:
    FEM_DO_SAFE(j, 1, 10) {
      if (c4 == digit(j)) {
        goto statement_4256;
      }
    }
    write(munit6,
      "('    -- Illegal byte in \"NUMBER\".',1x,i4,3x,a1,3x,'Try again ...')"),
      i, c4;
    window(cmn);
    num = -87654;
    goto statement_4294;
    statement_4256:
    if (j == 10) {
      j = 0;
    }
    num = 10 * num + j;
    if (iprspy < 2) {
      goto statement_4265;
    }
    write(munit6, "(' NEXT DIGIT.  J, NUM =',2i8)"), j, num;
    window(cmn);
    statement_4265:;
  }
  write(munit6, "(' STOP AT 4271 OF \"GETNUM\".  NUM =',i8)"), num;
  window(cmn);
  stoptp(cmn);
  statement_4286:
  if (n1 < 0) {
    num = -num;
  }
  iendcl = i - 1;
  if (iprspy < 1) {
    goto statement_4294;
  }
  write(munit6, "(' EXIT \"NUMBER\".   IENDCL, NUM =',2i8)"), iendcl, num;
  window(cmn);
  statement_4294:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void sosrng(
  common& cmn,
  int& kill) try
{
  common_write write(cmn);
  int& ibegcl = cmn.ibegcl;
  int& lidnt1 = cmn.lidnt1;
  int& lidnt2 = cmn.lidnt2;
  int& linnow = cmn.linnow;
  int& numcrd = cmn.numcrd;
  int& iprspy = cmn.iprspy;
  fem::str<1>& char1 = cmn.char1;
  fem::str<20>& bytbuf = cmn.bytbuf;
  fem::str<132>& munit6 = cmn.munit6;
  //
  int n12 = fem::int0;
  int n1 = fem::int0;
  int n13 = fem::int0;
  int n24 = fem::int0;
  double char2 = fem::double0;
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M35.4140
  //C     THIS MODULE SERVES TO EXTRACT A BEGINNING AND ENDING LINE NUMBER  M35.4141
  //C     FOR SOS-LIKE EDITING OPERATIONS OF  "EDIT"  COMMAND.   THESE TWO  M35.4142
  //C     INTEGER OUTPUTS ARE  (LIDNT1, LIDNT2)  OF COMMON.   THE ONLY      M35.4143
  //C     ARGUMENT IS  "KILL",  WHICH TELLS WHETHER THE OPERATION WAS A     M35.4144
  //C     SUCCESS:  "0" MEANS SUCCESS,  "1" MEANS ERROR.                    M35.4145
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4146
  if (iprspy < 1) {
    goto statement_2615;
  }
  write(munit6, "(' TOP \"SOSRANGE\".  BYTBUF(A20) =',a20)"), bytbuf;
  window(cmn);
  write(munit6, "(' NUMSYM, LIDNT1, LINNOW, CHAR1 =',3i5,2x,a1)"),
    cmn.numsym, lidnt1, linnow, char1;
  window(cmn);
  statement_2615:
  kill = 0;
  if (char1 != " ") {
    goto statement_2629;
  }
  //C     BLANK MEANS WE JUST CONTINUE DISPLAYING AS MANY LINES AS LAST TIMEM35.4156
  n12 = cmn.linspn;
  lidnt1 = lidnt2 + 1;
  lidnt2 = lidnt1 + n12;
  goto statement_2662;
  statement_2629:
  if (bytbuf(1, 1) != "#") {
    goto statement_2632;
  }
  //C     FOLLOWING CODE PROCESSES A COMMAND LIKE  "*P22" :                 M35.4161
  ibegcl = 2;
  getnum(cmn, n1);
  if (n1 !=  - 87654) {
    goto statement_2630;
  }
  statement_2621:
  kill = 1;
  goto statement_9000;
  statement_2630:
  lidnt1 = linnow + 1;
  lidnt2 = linnow + n1;
  goto statement_2662;
  statement_2632:
  if (bytbuf(1, 1) != " ") {
    goto statement_2635;
  }
  //C     FOLLOWING CODE PROCESS SIMPLE "*P" ---- NEXT 16 LINES, LIKE SOS:  M35.4171
  if (linnow < numcrd) {
    goto statement_2634;
  }
  write(6, star), " No such lines exist";
  goto statement_2621;
  statement_2634:
  n1 = 16;
  goto statement_2630;
  statement_2635:
  ibegcl = 0;
  n13 = 0;
  lidnt1 = 0;
  lidnt2 = 0;
  statement_2636:
  ibegcl++;
  n24 = 0;
  if (iprspy < 2) {
    goto statement_2644;
  }
  write(munit6,
    "(' BEGIN NEXT LIDNT.',"
    "'    IBEG     N13  LIDNT1  JPOINT      N1     N24')");
  window(cmn);
  write(munit6, "('                  ',6i8)"), ibegcl, n13, lidnt1,
    linnow, n1, n24;
  window(cmn);
  statement_2644:
  if (bytbuf(ibegcl, ibegcl) != ".") {
    goto statement_2645;
  }
  n24 = linnow;
  goto statement_2654;
  statement_2645:
  if (bytbuf(ibegcl, ibegcl) != "^") {
    goto statement_2648;
  }
  n24 = 1;
  goto statement_2654;
  statement_2648:
  if (bytbuf(ibegcl, ibegcl) != "*") {
    goto statement_2657;
  }
  n24 = numcrd;
  statement_2654:
  ibegcl++;
  statement_2657:
  getnum(cmn, n1);
  if (n1 ==  - 87654) {
    goto statement_2621;
  }
  n13++;
  if (n13 == 1) {
    lidnt1 = n24 + n1;
  }
  if (n13 == 2) {
    lidnt2 = n24 + n1;
  }
  if (n13 == 2) {
    goto statement_2662;
  }
  ibegcl = cmn.iendcl + 1;
  if (bytbuf(ibegcl, ibegcl) == ":") {
    goto statement_2636;
  }
  if (bytbuf(ibegcl, ibegcl) != "#") {
    goto statement_2659;
  }
  //C     WE GET HERE WITH A REQUEST LIKE  "*P200!5",  AFTER "200" IS KNOWN M35.4206
  ibegcl++;
  getnum(cmn, n1);
  if (n1 ==  - 87654) {
    goto statement_2621;
  }
  lidnt2 = lidnt1 + n1 - 1;
  goto statement_2662;
  //C     WE REACH 2659 IF NOTHING FOLLOWS FIRST NUMBER (E.G., "*P200"):    M35.4212
  statement_2659:
  lidnt2 = lidnt1;
  //C     NOW WE DISPLAY LINES  LIDNT1, ...., LIDNT2,  AFTER LIMIT CHECK:   M35.4214
  statement_2662:
  if (lidnt1 >= 1) {
    goto statement_2663;
  }
  write(6, star), " Illegal syntax of command";
  goto statement_2621;
  statement_2663:
  if (lidnt1 <= numcrd) {
    goto statement_2664;
  }
  write(6, star), " Range given does not contain any lines";
  goto statement_2621;
  statement_2664:
  if (lidnt2 > numcrd) {
    lidnt2 = numcrd;
  }
  statement_9000:
  if (iprspy < 1) {
    goto statement_9006;
  }
  write(munit6,
    "(' EXIT \"SOSRNG\".  LIDNT1, LIDNT2, KILL, CHAR2 =',3i6,2x,a1)"),
    lidnt1, lidnt2, kill, char2;
  window(cmn);
  statement_9006:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void movesp(
  arr_cref<double> from,
  arr_ref<double> to,
  int const& n15) try
{
  from(dimension(1));
  to(dimension(1));
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M35.4229
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4230
  //C     THIS ROUTINE TRANSFERS SINGLE-PRECISION FROM(1:N15) TO            M35.4231
  //C     TO(1:N15).  EXCEPT FOR MISSING IMPLICIT, IT EQUALS "MOVER".       M35.4232
  int j = fem::int0;
  FEM_DO_SAFE(j, 1, n15) {
    to(j) = from(j);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void frefp1(
  common& cmn,
  str_ref ansi,
  double& d12) try
{
  common_read read(cmn);
  //C     UNIVERSAL MODULE (WORKS FOR ANY COMPUTER) USED ONLY FOR THE       M35.4256
  //C     INTERACTIVE EMTP ("EMTSPY").  IT IS CALLED TO DECODE A            M35.4257
  //C     SINGLE FLOATING POINT NUMBER.  THE INPUT IS CHARACTER*80          M35.4258
  //C     VARIABLE  ANSI,  AND THE OUTPUT IS DOUBLE PRECISION D12.          M35.4259
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4260
  int n8 = 1;
  frefix(cmn, ansi, n8);
  read(ansi, "(e20.0)"), d12;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void frefp2(
  common& cmn,
  str_ref ansi,
  double& d12,
  double& d13) try
{
  common_read read(cmn);
  //C     UNIVERSAL MODULE (WORKS FOR ANY COMPUTER) USED ONLY FOR THE       M35.4269
  //C     INTERACTIVE EMTP ("EMTSPY").  IT IS CALLED TO DECODE TWO          M35.4270
  //C     FLOATING POINT NUMBERS D12 AND D13 FROM CHARACTER*80 ANSI.        M35.4271
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4272
  int n8 = 2;
  frefix(cmn, ansi, n8);
  read(ansi, "(2e20.0)"), d12, d13;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void frein1(
  common& cmn,
  str_ref ansi,
  int& n12) try
{
  common_read read(cmn);
  //C     UNIVERSAL MODULE (WORKS FOR ANY COMPUTER) USED ONLY FOR THE       M35.4293
  //C     INTERACTIVE EMTP ("EMTSPY").  IT IS CALLED TO DECODE A            M35.4294
  //C     SINGLE INTEGER NUMBER N12 FROM CHARACTER*80 INPUT ANSI.           M35.4295
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4296
  int n8 = 1;
  frefix(cmn, ansi, n8);
  double d12 = fem::double0;
  read(ansi, "(3e20.0)"), d12;
  n12 = d12;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct spyink_save
{
  fem::str<8> d12;
  fem::str<8> d13;
  double d13z;
  double d14;
  double d15;
  double d17;
  double d18;
  double d24;
  double d8;
  arr<fem::str<1> > filbyt;
  arr<double> fkar1;
  arr<double> fkar2;
  arr<double> forbyt;
  int i;
  int ioutcs;
  int ip;
  int j;
  int k;
  int kaliu;
  int kiuty;
  int klntab;
  int kofsce;
  int koncur;
  int konsce;
  int konsup;
  int kontot;
  int kptplt;
  int kud1;
  int kud2;
  int kud3;
  int kxtcs;
  int L;
  int lunit6;
  int m;
  int mmfind;
  arr<int> mmhold;
  int mstrng;
  int n1;
  int n11;
  int n12;
  int n13;
  int n14;
  int n15;
  int n16;
  int n17;
  int n18;
  int n2;
  int n22;
  int n23;
  int n24;
  int n3;
  int n33;
  int n4;
  int n42;
  int n43;
  int n5;
  int n6;
  int n66;
  int n7;
  int n77;
  int n8;
  int n9;
  int ndx1;
  int ndx2;
  int ndx3;
  int ndx4;
  int niu;
  int nsmout;
  int nsup;
  int nuk;
  int numnv0;
  arr<double> pltbuf;
  fem::str<8> text1;
  fem::str<8> text2;

  spyink_save() :
    d12(fem::char0),
    d13(fem::char0),
    d13z(fem::double0),
    d14(fem::double0),
    d15(fem::double0),
    d17(fem::double0),
    d18(fem::double0),
    d24(fem::double0),
    d8(fem::double0),
    filbyt(dimension(1), fem::fill0),
    fkar1(dimension(1), fem::fill0),
    fkar2(dimension(1), fem::fill0),
    forbyt(dimension(600), fem::fill0),
    i(fem::int0),
    ioutcs(fem::int0),
    ip(fem::int0),
    j(fem::int0),
    k(fem::int0),
    kaliu(fem::int0),
    kiuty(fem::int0),
    klntab(fem::int0),
    kofsce(fem::int0),
    koncur(fem::int0),
    konsce(fem::int0),
    konsup(fem::int0),
    kontot(fem::int0),
    kptplt(fem::int0),
    kud1(fem::int0),
    kud2(fem::int0),
    kud3(fem::int0),
    kxtcs(fem::int0),
    L(fem::int0),
    lunit6(fem::int0),
    m(fem::int0),
    mmfind(fem::int0),
    mmhold(dimension(20), fem::fill0),
    mstrng(fem::int0),
    n1(fem::int0),
    n11(fem::int0),
    n12(fem::int0),
    n13(fem::int0),
    n14(fem::int0),
    n15(fem::int0),
    n16(fem::int0),
    n17(fem::int0),
    n18(fem::int0),
    n2(fem::int0),
    n22(fem::int0),
    n23(fem::int0),
    n24(fem::int0),
    n3(fem::int0),
    n33(fem::int0),
    n4(fem::int0),
    n42(fem::int0),
    n43(fem::int0),
    n5(fem::int0),
    n6(fem::int0),
    n66(fem::int0),
    n7(fem::int0),
    n77(fem::int0),
    n8(fem::int0),
    n9(fem::int0),
    ndx1(fem::int0),
    ndx2(fem::int0),
    ndx3(fem::int0),
    ndx4(fem::int0),
    niu(fem::int0),
    nsmout(fem::int0),
    nsup(fem::int0),
    nuk(fem::int0),
    numnv0(fem::int0),
    pltbuf(dimension(1), fem::fill0),
    text1(fem::char0),
    text2(fem::char0)
  {}
};


void spyink(
  common& cmn) try
{
#if 0
  FEM_CMN_SVE(spyink);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& terra = cmn.terra;
  auto& date1= cmn.date1;
  auto& tclock= cmn.tclock;
  const auto& abuff = cmn.abuff;
  double& fltinf = cmn.fltinf;
  auto& lunit4 = cmn.lunit4;
  auto& lunit5 = cmn.lunit5;
  auto& kprchg = cmn.kprchg;
  auto& multpr = cmn.multpr;
  auto& lstat = cmn.lstat;
  int& inonl = cmn.inonl;
  int& iout = cmn.iout;
  int& kol132 = cmn.kol132;
  int& istep = cmn.istep;
  int& kwtspy = cmn.kwtspy;
  int& ldata = cmn.ldata;
  int& lbrnch = cmn.lbrnch;
  int& lswtch = cmn.lswtch;
  int& nv = cmn.nv;
  int& kpartb = cmn.kpartb;
  int& lastov = cmn.lastov;
  int& ktab = cmn.ktab;
  int& ialter = cmn.ialter;
  int& ichar = cmn.ichar;
  int& numout = cmn.numout;
  int& isprin = cmn.isprin;
  int& nchain = cmn.nchain;
  int& kconst = cmn.kconst;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  int& limstp = cmn.limstp;
  int& indstp = cmn.indstp;
  int& nc = cmn.nc;
  int& numnvo = cmn.numnvo;
  const auto& x = static_cast<common_c0b001&>(cmn).x;
  const auto& ykm = cmn.ykm;
  const auto& km = cmn.km;
  const auto& ibsout = cmn.ibsout;
  auto& sptacs = cmn.sptacs;
  const auto& kswtyp = cmn.kswtyp;
  const auto& modswt = cmn.modswt;
  const auto& kentnb = cmn.kentnb;
  const auto& topen = cmn.topen;
  const auto& crit = cmn.crit;
  const auto& energy = cmn.energy;
  const auto& nonlad = cmn.nonlad;
  const auto& nonle = cmn.nonle;
  const auto& vnonl = cmn.vnonl;
  const auto& curr = cmn.curr;
  const auto& anonl = cmn.anonl;
  const auto& vecnl1 = cmn.vecnl1;
  const auto& vecnl2 = cmn.vecnl2;
  const auto& namenl = cmn.namenl;
  const auto& vzer5 = cmn.vzer5;
  const auto& ilast = cmn.ilast;
  const auto& nltype = cmn.nltype;
  const auto& kupl = cmn.kupl;
  const auto& nlsub = cmn.nlsub;
  const auto& cchar = cmn.cchar;
  const auto& vchar = cmn.vchar;
  const auto& gslope = cmn.gslope;
  const auto& kk = cmn.kk;
  auto& c = cmn.c;
  auto& tr = cmn.tr;
  auto& tx = cmn.tx;
  auto& r = static_cast<common_c0b064&>(cmn).r;
  auto& nr = cmn.nr;
  auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  auto& ck = cmn.ck;
  const auto& texvec = cmn.texvec;
  const auto& ibrnch = cmn.ibrnch;
  const auto& jbrnch = cmn.jbrnch;
  const auto& nonlk = cmn.nonlk;
  const auto& nonlm = cmn.nonlm;
  const auto& kks = cmn.kks;
  const auto& kknonl = cmn.kknonl;
  const auto& znonl = cmn.znonl;
  const auto& finit = cmn.finit;
  auto& litype = cmn.litype;
  auto& imodel = cmn.imodel;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  auto& cki = cmn.cki
  auto& ckkjm = cmn.ckkjm;
  auto& namebr = cmn.namebr;
  const auto& iform = cmn.iform;
  const auto& node = cmn.node;
  const auto& crest = cmn.crest;
  const auto& time1 = cmn.time1;
  const auto& tstart = cmn.tstart;
  const auto& sfreq = cmn.sfreq;
  const auto& kmswit = cmn.kmswit;
  const auto& nextsw = cmn.nextsw;
  const auto& tclose = cmn.tclose;
  const auto& adelay = cmn.adelay;
  const auto& kpos = cmn.kpos;
  const auto& namesw = cmn.namesw;
  const auto& e = cmn.e;
  const auto& f = static_cast<common_c0b119&>(cmn).f;
  const auto& kssfrq = cmn.kssfrq;
  const auto& kode = cmn.kode;
  const auto& volti = static_cast<common_c0b123&>(cmn).volti;
  const auto& bus = cmn.bus;
  arr_ref<double> epskon(cmn.epskon, dimension(14));
  auto& iascii = cmn.iascii;

  int& jjroll = cmn.jjroll;
  int& jword = cmn.jword;
  int& lidnt1 = cmn.lidnt1;
  int& lidnt2 = cmn.lidnt2;
  int& linnow = cmn.linnow;
  int& numcrd = cmn.numcrd;
  int& munit5 = cmn.munit5;
  int& numkey = cmn.numkey;
  int& indbuf = cmn.indbuf;
  int& indbeg = cmn.indbeg;
  int& mflush = cmn.mflush;
  int& lserlc = cmn.lserlc;
  int& kserlc = cmn.kserlc;
  int& kbrser = cmn.kbrser;
  int& lockbr = cmn.lockbr;
  int& iprspy = cmn.iprspy;
  int& monitr = cmn.monitr;
  int& monits = cmn.monits;
  int& kbreak = cmn.kbreak;
  int& limbuf = cmn.limbuf;
  int& nexmod = cmn.nexmod;
  arr_ref<int> kontac(cmn.kontac, dimension(14));
  arr_ref<int> konadd(cmn.konadd, dimension(14));
  const auto& kar1 = cmn.kar1;
  fem::str<20>& bytfnd = cmn.bytfnd;
  fem::str<1>& char1 = cmn.char1;
  fem::str<20>& bytbuf = cmn.bytbuf;
  fem::str<80>& buff77 = cmn.buff77;
  str_arr_ref<1> file6b(cmn.file6b, dimension(20));
  auto& file6 = cmn.file6;
  fem::str<80>& blan80 = cmn.blan80;
  fem::str<80>& prom80 = cmn.prom80;
  const auto& digit = cmn.digit;
  auto& spykwd = cmn.spykwd;
  fem::str<8>& ansi8 = cmn.ansi8;
  fem::str<32>& ansi32 = cmn.ansi32;
  fem::str<35>& spycd2 = cmn.spycd2;
  fem::str<80>& answ80 = cmn.answ80;
  fem::str<8>& brobus = cmn.brobus;
  fem::str<132>& munit6 = cmn.munit6;
  //
  fem::str<8>& d12 = sve.d12;
  fem::str<8>& d13 = sve.d13;
  double& d13z = sve.d13z;
  double& d14 = sve.d14;
  double& d15 = sve.d15;
  double& d17 = sve.d17;
  double& d18 = sve.d18;
  double& d24 = sve.d24;
  double& d8 = sve.d8;
  arr_ref<double> fkar1(sve.fkar1, dimension(1));
  arr_ref<double> forbyt(sve.forbyt, dimension(600));
  int& i = sve.i;
  //int& ioutcs = sve.ioutcs;
  int& ip = sve.ip;
  int& j = sve.j;
  int& k = sve.k;
  //int& kaliu = sve.kaliu;
  //int& kiuty = sve.kiuty;
  //int& klntab = sve.klntab;
  int& kofsce = sve.kofsce;
  //int& koncur = sve.koncur;
  int& konsce = sve.konsce;
  //int& konsup = sve.konsup;
  int& kontot = sve.kontot;
  int& kptplt = sve.kptplt;
  //int& kud1 = sve.kud1;
  int& kud2 = sve.kud2;
  int& kud3 = sve.kud3;
  //int& kxtcs = sve.kxtcs;
  int& L = sve.L;
  auto& lunit6 = cmn.lunit6;
  int& m = sve.m;
  int& mmfind = sve.mmfind;
  arr_ref<int> mmhold(sve.mmhold, dimension(20));
  int& mstrng = sve.mstrng;
  int& n1 = sve.n1;
  int& n11 = sve.n11;
  int& n12 = sve.n12;
  int& n13 = sve.n13;
  int& n14 = sve.n14;
  int& n15 = sve.n15;
  int& n16 = sve.n16;
  int& n17 = sve.n17;
  int& n18 = sve.n18;
  int& n2 = sve.n2;
  int& n22 = sve.n22;
  int& n23 = sve.n23;
  int& n24 = sve.n24;
  int& n3 = sve.n3;
  int& n33 = sve.n33;
  int& n4 = sve.n4;
  int& n42 = sve.n42;
  int& n43 = sve.n43;
  int& n5 = sve.n5;
  int& n6 = sve.n6;
  int& n66 = sve.n66;
  int& n7 = sve.n7;
  int& n77 = sve.n77;
  int& n8 = sve.n8;
  int& n9 = sve.n9;
  int& ndx1 = sve.ndx1;
  int& ndx2 = sve.ndx2;
  int& ndx3 = sve.ndx3;
  int& ndx4 = sve.ndx4;
  int& niu = sve.niu;
  int& nsmout = sve.nsmout;
  //int& nsup = sve.nsup;
  //int& nuk = sve.nuk;
  arr_ref<double> pltbuf(sve.pltbuf, dimension(1));
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  if (is_called_first_time) {
    text1 = "TAMPER";
  }
  static const char* format_2623 = "(a1,a20)";
  static const char* format_2692 = "(i5,1x,a80)";
  static const char* format_2788 = "(10a8)";
  static const char* format_2796 =
    "('    ? ? ?   Sorry,  no such symbol found.','   Try again ...')";
  static const char* format_2805 =
    "('   ---  Sorry, no such elements available in',"
    "' this data case.  Try another key word ...')";
  static const char* format_3691 = "(a6,2x)";
  static const char* format_3708 = "('    %% Linear branches :',20i5)";
  static const char* format_4056 = "('+      Still reading.',i8)";
  static const char* format_4071 = "(1x,10e13.4)";
  static const char* format_4217 = "('    SEND  N-from, N-to (1, 2, ...) :')";
  static const char* format_4497 = "(1x,4(i5,e15.6))";
  static const char* format_4763 = "(a6,i6,e8.0)";
  static const char* format_4851 = "(1x,i4,3e13.4,i4,2i7,i6,1x,a6)";
  //C     MODULE OF INTERACTIVE EMTP ONLY, WHICH SERVICES "EMTSPY".         M36.1887
  //C     THIS IS THE 2ND HALF OF PRINCIPLE MODULE "SPYING".                M36.1888

    // handling equivalence in tacsar.inc
  auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
  auto& ivarb = isptacs;

  auto& koncur = isptacs(2);
  auto& konsup = isptacs(8);
  auto& kaliu =  isptacs(11);
  auto& kiuty =  isptacs(13);
  auto& kud1 =   isptacs(14);
  auto& kxtcs =  isptacs(17);
  auto& klntab = isptacs(18);

  auto& nuk = lstat(51);
  auto& nsup = lstat(55);
  auto& ioutcs = lstat(59);

  if (iprspy < 1) {
    goto statement_1003;
  }
  write(munit6,
    "(' ENTER \"SPYING\".  NCHAIN  JJROLL  KBREAK','  LOCKBR, NEXMOD =',5i5)"),
    nchain, jjroll, kbreak, lockbr, nexmod;
  window(cmn);
  statement_1003:
  if (nexmod != 3) {
    goto statement_1004;
  }
  nexmod = 0;
  //C!GO TO NEXTSN
  statement_1004:
  if (jword > 63) {
    goto statement_1007;
  }
  //C       HEADING  STOP    PLOT    HELP  EXAMINE  DEPOSIT  SWITCH  (1-7)  M36.1898
  //C        REST    SAVE   RESTORE   GO    BLANK    FIND    LIST    (8-14) M36.1900
  //C         SPY    BREAK   WHEN  COMMENT    @?     ROLL   TYPE?   (15-21) M36.1902
  //C       VERIFY   FILES   SLEEP  SOURCE   EDIT    WAKE  LANGUAGE (22-28) M36.1904
  //C      CATALOG  BEGIN    STEP    DEBUG   DATA    RAMP    TIME   (29-35) M36.1906
  //C         TEK   BRANCH   YFORM    NOY   FACTOR    NOF    RLC    (36-42) M36.1908
  //C        WIDTH    BUS    SIZE   LIMIT    IOUT    NODE   NONLIN  (43-49) M36.1910
  //C        SPACE  LUNIT4  SERIES   LOCK     [Y]     [F]   NOROLL  (50-56) M36.1912
  //C        OPEN    CLOSE  UNLOCK   HONK   CHOICE   TACS    WAIT   (57-63) M37.6400
  switch (jword) {
    case 1: goto statement_9999;
    case 2: goto statement_9999;
    case 3: goto statement_9999;
    case 4: goto statement_9999;
    case 5: goto statement_9999;
    case 6: goto statement_9999;
    case 7: goto statement_2804;
    case 8: goto statement_9999;
    case 9: goto statement_9999;
    case 10: goto statement_9999;
    case 11: goto statement_9999;
    case 12: goto statement_9999;
    case 13: goto statement_9999;
    case 14: goto statement_9999;
    case 15: goto statement_9999;
    case 16: goto statement_9999;
    case 17: goto statement_9999;
    case 18: goto statement_9999;
    case 19: goto statement_9999;
    case 20: goto statement_9999;
    case 21: goto statement_9999;
    case 22: goto statement_9999;
    case 23: goto statement_9999;
    case 24: goto statement_9999;
    case 25: goto statement_2856;
    case 26: goto statement_2617;
    case 27: goto statement_9999;
    case 28: goto statement_2782;
    case 29: goto statement_9999;
    case 30: goto statement_9999;
    case 31: goto statement_9999;
    case 32: goto statement_9999;
    case 33: goto statement_9999;
    case 34: goto statement_9999;
    case 35: goto statement_9999;
    case 36: goto statement_9999;
    case 37: goto statement_9999;
    case 38: goto statement_9999;
    case 39: goto statement_9999;
    case 40: goto statement_9999;
    case 41: goto statement_9999;
    case 42: goto statement_3456;
    case 43: goto statement_3526;
    case 44: goto statement_3541;
    case 45: goto statement_3635;
    case 46: goto statement_3647;
    case 47: goto statement_3662;
    case 48: goto statement_3684;
    case 49: goto statement_3752;
    case 50: goto statement_3842;
    case 51: goto statement_4002;
    case 52: goto statement_4163;
    case 53: goto statement_4436;
    case 54: goto statement_4471;
    case 55: goto statement_4512;
    case 56: goto statement_4563;
    case 57: goto statement_9999;
    case 58: goto statement_9999;
    case 59: goto statement_9999;
    case 60: goto statement_9999;
    case 61: goto statement_4592;
    case 62: goto statement_4716;
    case 63: goto statement_9999;
    default: break;
  }
  stoptp(cmn);
  statement_1007:
  n14 = jword - 63;
  //C         V-I                                                   (64-64) M37.6405
  switch (n14) {
    case 1: goto statement_4823;
    default: break;
  }
  stoptp(cmn);
  //C     $$$$$$$  KEY WORD NO. 26:  "EDIT"     $$$$  $$$$  $$$$  $$$$  $$$$M36.1916
  //C     "EDIT"  COMMAND ALLOWS THE USER TO LOOK AT THE EMTP DATA CASE     M36.1917
  //C     WHICH IS STORED IN THE RTM DATA BASE; DISPLAY COMMANDS ARE        M36.1918
  //C     SIMILAR TO  VAX/VMS  EDITOR  "SOS" :                              M36.1919
  statement_2617:
  linnow = 0;
  statement_2618:
  write(prom80, "(' *')");
  FEM_THROW_UNHANDLED("executable assign: assign2620tonextsn");
  goto statement_9800;
  read(buff77, format_2623), char1, bytbuf;
  if (iprspy < 1) {
    goto statement_2626;
  }
  write(munit6, "(' CHAR1, BYTBUF(1:10) AFTER READ:',a2,1x,a10)"),
    char1, bytbuf(ip, ip + 9);
  window(cmn);
  statement_2626:
  if (char1 == "F") {
    goto statement_2669;
  }
  if (char1 == "S") {
    goto statement_2669;
  }
  if (char1 == "E") {
    goto statement_1240;
  }
  if (char1 == "8") {
    goto statement_2734;
  }
  if (char1 == "C" && bytbuf(1, 1) == "O" && bytbuf(2, 2) == "L") {
    goto statement_2756;
  }
  if (char1 == "P") {
    goto statement_2629;
  }
  if (char1 == "D") {
    goto statement_2629;
  }
  if (char1 == "I") {
    goto statement_2629;
  }
  if (char1 == "R") {
    goto statement_2629;
  }
  if (char1 == " ") {
    goto statement_2629;
  }
  write(munit6,
    "('     Sorry, 1st character is meaningless.','   Try again .... ')");
  window(cmn);
  goto statement_2618;
  statement_2629:
  sosrng(cmn, n17);
  if (iprspy < 2) {
    goto statement_2633;
  }
  write(munit6, "(' N17, LIDNT1, LIDNT2 =',3i8)"), n17, lidnt1, lidnt2;
  window(cmn);
  statement_2633:
  if (n17 > 0) {
    goto statement_2618;
  }
  if (char1 == "I") {
    goto statement_2695;
  }
  if (char1 == "D") {
    goto statement_2719;
  }
  if (char1 == "R") {
    goto statement_2719;
  }
  //C     WE REACH HERE READY TO PRINT LINES  (LIDNT1, LIDNT2) :  *P  CASE  M36.1952
  statement_2634:
  FEM_DO_SAFE(j, lidnt1, lidnt2) {
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_2639;
    }
    kwtspy = 0;
    linnow = j - 1;
    lidnt1 = j - 1;
    lidnt2 = j - 1;
    goto statement_2618;
    statement_2639:
    write(munit6, "(1x,i4,1x,a80)"), j, file6(j);
    window(cmn);
  }
  cmn.linspn = lidnt2 - lidnt1;
  linnow = lidnt2;
  goto statement_2618;
  //C     FOLLOWING CODE IS FOR  "*F[string]@"  LOCATE REQUEST (LIKE SOS):  M36.1966
  statement_2669:
  n4 = 0;
  n5 = 0;
  FEM_DO_SAFE(i, 2, 20) {
    if (bytbuf(i, i) == "@") {
      n4 = 1;
    }
    if (bytbuf(i, i) != " ") {
      n5 = 1;
    }
  }
  if (n5 == 0) {
    goto statement_2671;
  }
  if (n4 == 1) {
    goto statement_2673;
  }
  write(munit6, "('  Illegal \"*F\" --- string not terminated by \"@\".')");
  window(cmn);
  goto statement_2618;
  statement_2671:
  if (mstrng == 1) {
    goto statement_2672;
  }
  write(munit6,
    "('  Illegal \"*F\" --- blank string, but no',"
    "' earlier usage for reference.')");
  window(cmn);
  goto statement_2618;
  //C2672 CALL MOVERS ( BYTFND(1), BYTBUF(1), 20 )    ! RESTORE OLD STRING  M36.1984
  statement_2672:
  bytbuf = bytfnd;
  linnow++;
  statement_2673:
  n6 = linnow;
  FEM_DO_SAFE(j, n6, numcrd) {
    L = 1;
    FEM_DO_SAFE(k, 1, 80) {
      if (file6(j)(k, k) == bytbuf(L, L)) {
        goto statement_2674;
      }
      L = 1;
      goto statement_2677;
      statement_2674:
      if (bytbuf(L + 1, L + 1) != "@") {
        goto statement_2676;
      }
      linnow = j;
      lidnt2 = j;
      if (char1 == "S") {
        goto statement_2763;
      }
      goto statement_2691;
      statement_2676:
      L++;
      statement_2677:;
    }
  }
  L = 0;
  write(munit6, "(' String not found, search failed')");
  window(cmn);
  linnow = linnow - 1;
  statement_2691:
  if (L <= 0) {
    goto statement_2693;
  }
  write(munit6, format_2692), j, file6(j);
  window(cmn);
  statement_2693:
  bytfnd = bytbuf;
  mstrng = 1;
  goto statement_2618;
  //C     FOLLOWING CODE IS TO PROCESS  "*I"  COMMAND:                      M36.2012
  //C     FOLLOWING CODE IS FOR  "*I"  REQUEST :                            M36.2013
  statement_2695:
  n1 = 0;
  linnow = lidnt1;
  statement_2701:
  if (n1 < 20) {
    goto statement_2703;
  }
  write(munit6,
    "('    Filled working storage of 20 lines.',"
    "'   Truncated insertion now in progress.')");
  window(cmn);
  goto statement_2704;
  statement_2703:
  linnow++;
  write(prom80, "(1x,i4,' ')"), linnow;
  FEM_THROW_UNHANDLED("executable assign: assign52703tonextsn");
  goto statement_9800;
  if (buff77(1, 1) != "@") {
    goto statement_2711;
  }
  statement_2704:
  j = numcrd;
  statement_2706:
  file6(j + n1) = file6(j);
  j = j - 1;
  if (j > lidnt1) {
    goto statement_2706;
  }
  FEM_DO_SAFE(j, 1, n1) {
    file6(linnow + j) = file6b(j);
  }
  linnow = linnow - 1;
  lidnt1 = linnow;
  lidnt2 = linnow;
  numcrd += n1 / 10;
  goto statement_2618;
  statement_2711:
  n1++;
  file6b(n1) = buff77;
  goto statement_2701;
  //C     FOLLOWING CODE IS FOR  "*D"  OR  "*R"  REQUEST:                   M36.2042
  statement_2719:
  n2 = lidnt1;
  j = lidnt2 + 1;
  statement_2723:
  file6(n2) = file6(j);
  n2++;
  j++;
  if (j <= numcrd) {
    goto statement_2723;
  }
  numcrd = numcrd - (lidnt2 - lidnt1 + 1);
  linnow = lidnt1 - 1;
  lidnt1 = linnow;
  lidnt2 = linnow;
  if (char1 != "R") {
    goto statement_2618;
  }
  goto statement_2695;
  //C     FOLLOWING CODE IS FOR  "*8"  REQUEST :                            M36.2055
  statement_2734:
  if (bytbuf(1, 4) != "    ") {
    goto statement_2743;
  }
  j = linnow;
  statement_2736:
  if (file6(j)(80, 80) == " ") {
    goto statement_2738;
  }
  write(munit6, format_2692), j, file6(j);
  window(cmn);
  read(munit5, format_2623), bytbuf;
  if (bytbuf(1, 1) == "E") {
    goto statement_2618;
  }
  if (bytbuf(1, 1) == " ") {
    goto statement_2738;
  }
  bytbuf(2, 2) = file6(j)(80, 80);
  if (bytbuf(1, 1) == "0") {
    file6b(j)(80, 80) = " ";
  }
  if (bytbuf(1, 1) == "1" || bytbuf(1, 1) == "2" || bytbuf(1,
      1) == "3" || bytbuf(1, 1) == "4") {
    file6b(j)(80, 80) = bytbuf(1, 1);
  }
  if (bytbuf(2, 2) != file6(j)(80, 80)) {
    goto statement_2738;
  }
  write(munit6,
    "('   Illegal col. 80 value  \"',a1,'\" .   Cancel substitution.')"),
    bytbuf(1, 1);
  window(cmn);
  statement_2738:
  j++;
  if (j <= numcrd) {
    goto statement_2736;
  }
  linnow = numcrd;
  goto statement_2618;
  //C     FOLLOWING CODE IS FOR  "*8,?"  CASE, TO DEPOSIT IN COLUMN 80:     M36.2077
  statement_2743:
  if (bytbuf(1, 1) == ",") {
    goto statement_2749;
  }
  write(munit6,
    "(' Sorry,  \"*8\"  must be followed by a',"
    "' comma and digit 1-4, or blanks.')");
  window(cmn);
  goto statement_2618;
  statement_2749:
  file6b(linnow)(80, 80) = bytbuf(2, 2);
  lidnt1 = linnow;
  lidnt2 = linnow;
  goto statement_2634;
  //C     FOLLOWING CODE IS FOR  "*RULE"  REQUEST FOR COLUMN MARKING:       M36.2087
  statement_2756:
  if (bytbuf(3, 3) == " ") {
    goto statement_2758;
  }
  write(munit6,
    "(1x,'1234567890123456789012345678901234567890',"
    "'1234567890123456789012345678901234567890')");
  window(cmn);
  goto statement_2761;
  statement_2758:
  write(munit6,
    "(5x,'1234567890123456789012345678901234567890',"
    "'1234567890123456789012345678901234567890')");
  window(cmn);
  statement_2761:
  goto statement_2618;
  //C     THE FOLLOWING IS FOR  "*S"  PROCESSING, AFTER BRANCH FROM THE     M36.2097
  //C     MIDDLE OF  "*F"  (WHERE STRING WAS FOUND):                        M36.2098
  statement_2763:
  k++;
  if (iprspy < 1) {
    goto statement_32764;
  }
  write(munit6, "(' *S EXITED TO 2763.  K, L =',2i8)"), k, L;
  window(cmn);
  statement_32764:
  n7 = k - L;
  n12 = 81 - k;
  buff77(1, n12) = file6(linnow)(k, 80);
  buff77(n12 + 1, n12 + 20) = blan80(1, 20);
  L += 2;
  goto statement_2767;
  statement_2765:
  file6(linnow)(n7, n7) = bytbuf(L, L);
  if (n7 == 80) {
    goto statement_2781;
  }
  n7++;
  L++;
  if (L > 20) {
    goto statement_2769;
  }
  statement_2767:
  if (bytbuf(L, L) != "@") {
    goto statement_2765;
  }
  n14 = 81 - n7;
  file6(linnow)(n7, 80) = buff77(1, n14);
  if (iprspy < 1) {
    goto statement_2781;
  }
  write(munit6, "(' DONE WITH STRING SUB.  EXIT TO 2772.')");
  window(cmn);
  goto statement_2781;
  statement_2769:
  write(munit6, "('   Illegal  \"*S\" ---- 2nd  \"@\"  missing.')");
  window(cmn);
  goto statement_2618;
  statement_2781:
  j = linnow;
  if (iprspy < 1) {
    goto statement_2691;
  }
  write(munit6, "(' AT 2781.  J, N3, N4 =',3i8)"), j, n3, n4;
  window(cmn);
  goto statement_2691;
  //C     $$$$$$$  KEY WORD NO. 28:  "LANGUAGE" $$$$  $$$$  $$$$  $$$$  $$$$M36.2129
  statement_2782:
  write(prom80,
    "('   NEXT COMMAND LANGUAGE OPERATION (SINGLE,',' ENTIRE, SHOW, SPY :')");
  FEM_THROW_UNHANDLED("executable assign: assign2786tonextsn");
  goto statement_9800;
  ansi8 = buff77(1, 8);
  if (ansi8 != "ENTIRE  ") {
    goto statement_32788;
  }
  n13 = 1;
  n14 = 10;
  statement_32786:
  FEM_THROW_UNHANDLED("executable assign: assign2787tonextsn");
  goto statement_9800;
  {
    read_loop rloop(buff77, format_2788);
    FEM_DO_SAFE(j, n13, n14) {
      rloop, spykwd(j);
    }
  }
  if (n14 == numkey) {
    goto statement_2782;
  }
  n13 += 10;
  n14 += 10;
  if (n14 > numkey) {
    n14 = numkey;
  }
  goto statement_32786;
  statement_32788:
  if (ansi8 != "SHOW    ") {
    goto statement_2790;
  }
  FEM_DOSTEP(j, 1, numkey, 10) {
    {
      write_loop wloop(munit6, "(1x,10a8)");
      FEM_DO_SAFE(ip, j, j + 9) {
        wloop, spykwd(ip);
      }
    }
    window(cmn);
  }
  goto statement_2782;
  statement_2790:
  if (ansi8 != "SINGLE  ") {
    goto statement_2782;
  }
  statement_2791:
  write(prom80, "('      SEND NEXT OLD AND NEW SYMBOLS',' AS 2A8 (END) : ')");
  prompt(cmn);
  FEM_THROW_UNHANDLED("executable assign: assign2793tonextsn");
  goto statement_9800;
  ansi8 = buff77(1, 8);
  buff77(1, 8) = buff77(9, 16);
  if (ansi8 == "END     ") {
    goto statement_2782;
  }
  FEM_DO_SAFE(j, 1, numkey) {
    if (ansi8 == spykwd(j)) {
      goto statement_2798;
    }
  }
  write(munit6, format_2796), ansi8;
  window(cmn);
  goto statement_2791;
  statement_2798:
  spykwd(j) = buff77(1, 8);
  goto statement_2791;
  //C     $$$$$$$  KEY WORD NO.  7:  "SWITCH"   $$$$  $$$$  $$$$  $$$$  $$$$M36.2159
  statement_2804:
  bytbuf(1, 4) = answ80(1, 4);
  n33 = 0;
  if (kswtch > 0) {
    goto statement_2808;
  }
  write(munit6, format_2805);
  window(cmn);
  goto statement_1240;
  statement_2806:
  FEM_THROW_UNHANDLED("executable assign: assign2807tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  statement_2808:
  if (bytbuf(1, 4) == "END ") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) == "STOP") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) != "EXTR") {
    goto statement_2814;
  }
  statement_2810:
  write(prom80,
    "('  Name ',10x,'AKEY',10x,'CRIT',8x,'ENERGY','  KSWTYP  MODSWT  NEXTSW',"
    "' :')");
  n33 = 1;
  goto statement_2806;
  statement_2814:
  if (bytbuf(1, 4) != spykwd(7)(1, 4) && bytbuf(1, 4) != spykwd(1)(1, 4)) {
    goto statement_2822;
  }
  write(prom80,
    "(' Row name-K name-M K(KMSWIT)M KPOS KENTNB',3x,'TCLOSE',7x,'ADELAY',7x,"
    "'TOPEN:')");
  prompt(cmn);
  if (n33 > 0) {
    goto statement_2810;
  }
  goto statement_2806;
  //C     WE GET TO 2822 IF NO KNOWN KEY WORD;  EXTRACT INTEGER PAIR.   THISM36.2192
  //C     IS DEC FREE-FORMAT; "KSWTCH" IS MAXIMUM;  "N17" IS ERROR FLAG:    M36.2193
  statement_2822:
  intpar(cmn, kswtch, n1, n2, n17);
  if (n17 > 0) {
    goto statement_2806;
  }
  FEM_DO_SAFE(i, n1, n2) {
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_2825;
    }
    kwtspy = 0;
    goto statement_2806;
    statement_2825:
    n5 = fem::iabs(kmswit(i));
    n6 = fem::iabs(kmswit(lswtch + i));
    d12 = bus(n5);
    if (n5 == 1) {
      d12 = terra;
    }
    d13 = bus(n6);
    if (n6 == 1) {
      d13 = terra;
    }
    write(munit6, "(1x,i3,1x,a6,1x,a6,i6,i5,i5,i7,3e13.4)"), i, d12,
      d13, kmswit(i), kmswit(lswtch + i), kpos(i), kentnb(i), tclose(i),
      adelay(i), topen(i);
    window(cmn);
    if (n33 != 1) {
      goto statement_2834;
    }
    n7 = namesw(i);
    write(munit6, "(1x,a6,3e14.5,3i8)"), texvec(n7), adelay(i), crit(i),
      energy(i), kswtyp(i), modswt(i), nextsw(i);
    window(cmn);
    statement_2834:;
  }
  goto statement_2806;
  //C     $$$$$$$  KEY WORD NO. 25:  "SOURCE"   $$$$  $$$$  $$$$  $$$$  $$$$M36.2218
  statement_2856:
  n33 = 0;
  statement_2859:
  prom80 = "        ";
  FEM_THROW_UNHANDLED("executable assign: assign42859tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  if (bytbuf(1, 4) == "END ") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) == "STOP") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) != "TACS") {
    goto statement_2862;
  }
  n33 = 1;
  n14 = kxtcs + nuk;
  write(munit6,
    "(' Row  A6 TACS  Source value',3x,'Data field-A',4x,'Data field-B',4x,"
    "'Data field-C')");
  window(cmn);
  write(prom80,
    "(' no.   name',4x,'offset',i6,3x,'offset',i6,4x,'offset',i6,4x,'offset',"
    "i6,' :')"),
    n14, kud1, kud3, kud2;
  goto statement_2859;
  statement_2862:
  if (bytbuf(1, 4) != "ELEC") {
    goto statement_2868;
  }
  //C     "ELEC" IS THE COMMAND FOR A NEW HEADING FOR ELECTRIC-NETWORK      M36.2243
  //C     SOURCE TABLE:                                                     M36.2244
  n33 = 0;
  write(prom80,
    "(' Row  name  NODE IFORM',6x,'CREST',9x,'SFREQ',10x,'TIME1',9x,"
    "'TSTART :')");
  goto statement_2859;
  statement_2868:
  if (n33 == 1) {
    goto statement_2884;
  }
  //C     FOLLOWING IS DISPLAY CODE FOR ELECTRIC-NETWORK SOURCE TABLE:      M36.2252
  intpar(cmn, kconst, n1, n2, n17);
  if (n17 > 0) {
    goto statement_2859;
  }
  FEM_DO_SAFE(i, n1, n2) {
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_2873;
    }
    kwtspy = 0;
    goto statement_2859;
    statement_2873:
    n5 = fem::iabs(node(i));
    write(munit6, "(1x,i3,1x,a6,i5,i6,2e14.5,2e15.6)"), i, bus(n5),
      node(i), iform(i), crest(i), sfreq(i), time1(i), tstart(i);
    window(cmn);
  }
  prom80(1, 8) = blan80(1, 8);
  goto statement_2859;
  //C     WE REACH 2884 WITH REQUEST TO OUTPUT ANOTHER SET OF TACS SOURCES: M36.2267
  statement_2884:
  intpar(cmn, niu, n1, n2, n17);
  if (n17 > 0) {
    goto statement_2859;
  }
  FEM_DO_SAFE(i, n1, n2) {
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_2887;
    }
    kwtspy = 0;
    goto statement_2859;
    statement_2887:
    ansi8 = blan80(1, 8);
    if (ivarb(kiuty + i) < 90) {
      write(ansi8, format_3691), sptacs(kaliu + i);
    }
    write(munit6, "(1x,i3,1x,a6,4e16.6)"), i, ansi8, sptacs(kxtcs + nuk + i),
      sptacs(kud1 + i), sptacs(kud3 + i), sptacs(kud2 + i);
    window(cmn);
  }
  prom80(1, 8) = blan80(1, 8);
  goto statement_2859;
  //C     $$$$$$$  KEY WORD NO. 42:  "RLC"      $$$$  $$$$  $$$$  $$$$  $$$$M36.2284
  statement_3456:
  bytbuf(1, 4) = answ80(1, 4);
  n33 = 0;
  goto statement_3467;
  statement_3462:
  FEM_THROW_UNHANDLED("executable assign: assign3464tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  statement_3467:
  if (bytbuf(1, 4) == "END ") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) == "STOP") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) != "EXTR") {
    goto statement_3490;
  }
  n33++;
  if (n33 >= 2) {
    n33 = 0;
  }
  statement_3471:
  if (n33 == 1) {
    write(prom80, "(' NO EXTENSION YET IN USE.  BUT STRUCTURE ALLOWS IT.')");
  }
  if (n33 == 0) {
    write(prom80,
      "(' Row',9x,'TR(I)',9x,'TX(I)',10x,'R(I)',10x,'C(I)',10x,'X(I):')");
  }
  goto statement_3462;
  statement_3490:
  if (bytbuf(1, 4) == spykwd(42)(1, 4) || bytbuf(1, 4) == spykwd(1)(1, 4)) {
    goto statement_3471;
  }
  //C     WE GET HERE IF NO KNOWN KEY WORD;  EXTRACT INTEGER PAIR.   THIS   M38.4179
  //C     IS DEC FREE-FORMAT; "IT" IS MAXIMUM;  "N17" IS ERROR FLAG:        M36.2308
  intpar(cmn, cmn.it, n1, n2, n17);
  if (n17 > 0) {
    goto statement_3462;
  }
  FEM_DO_SAFE(i, n1, n2) {
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_3497;
    }
    kwtspy = 0;
    goto statement_3462;
    statement_3497:
    write(munit6, "(1x,i3,5e14.5)"), i, tr(i), tx(i), r(i), c(i), x(i);
    window(cmn);
  }
  prom80(1, 8) = blan80(1, 8);
  goto statement_3462;
  //C     $$$$$$$  KEY WORD NO. 43:  "WIDTH"    $$$$  $$$$  $$$$  $$$$  $$$$M36.2321
  statement_3526:
  n13 = kol132;
  if (n13 != 80) {
    goto statement_3529;
  }
  write(munit6,
    "('   ---  Switch from 80- to 132-column',' LUNIT6 EMTP output.')");
  window(cmn);
  goto statement_3532;
  statement_3529:
  write(munit6,
    "('   ---  Switch from 132- to 80-column',' LUNIT6 EMTP output.')");
  window(cmn);
  statement_3532:
  kol132 = 132;
  if (n13 == 132) {
    kol132 = 80;
  }
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 44:  "BUS"      $$$$  $$$$  $$$$  $$$$  $$$$M36.2330
  statement_3541:
  bytbuf(1, 4) = answ80(1, 4);
  n33 = 0;
  goto statement_3567;
  statement_3562:
  FEM_THROW_UNHANDLED("executable assign: assign3564tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  statement_3567:
  if (bytbuf(1, 4) == "END ") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) == "STOP") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) != "EXTR") {
    goto statement_3590;
  }
  n33++;
  if (n33 >= 2) {
    n33 = 0;
  }
  statement_3572:
  if (n33 == 1) {
    write(prom80,
      "('  Row',8x,'FINIT',6x,'ZNONL-A KKNONL',6x,'ZNONL-B KKNONL',6x,"
      "'ZNONL-C KKNONL',' :')");
  }
  if (n33 == 0) {
    write(prom80,
      "(' node  name  KODE  KSSFRQ    KK     KKS',12x,'E(I)',12x,'F(I) :')");
  }
  goto statement_3562;
  statement_3590:
  if (bytbuf(1, 4) == spykwd(44)(1, 4) || bytbuf(1, 4) == spykwd(1)(1, 4)) {
    goto statement_3572;
  }
  //C     WE GET HERE IF NO KNOWN KEY WORD;  EXTRACT INTEGER PAIR.   THIS   M38.4206
  //C     IS DEC FREE-FORMAT; "IT" IS MAXIMUM;  "N17" IS ERROR FLAG:        M36.2355
  intpar(cmn, ntot, n1, n2, n17);
  if (n17 > 0) {
    goto statement_3562;
  }
  FEM_DO_SAFE(i, n1, n2) {
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_3597;
    }
    kwtspy = 0;
    goto statement_3562;
    statement_3597:
    if (n33 == 0) {
      write(munit6, "(1x,i4,2x,a6,i4,i8,i6,i8,2e16.6)"), i, bus(i),
        kode(i), kssfrq(i), kk(i), kks(i), e(i), f(i);
    }
    n22 = ntot + i;
    n23 = ntot + n22;
    if (n33 == 1) {
      write(munit6, "(1x,i4,f13.4,3(f14.5,i6))"), i, finit(i), znonl(i),
        kknonl(i), znonl(n22), kknonl(n22), znonl(n23), kknonl(n23);
    }
    window(cmn);
  }
  prom80(1, 8) = blan80(1, 8);
  goto statement_3562;
  //C     $$$$$$$  KEY WORD NO. 45:  "SIZE"     $$$$  $$$$  $$$$  $$$$  $$$$M36.2375
  statement_3635:
  {
    write_loop wloop(munit6, "('   Size  1-10:',10i6)");
    FEM_DO_SAFE(i, 1, 10) {
      wloop, lstat(i + 20);
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, "('   Size 11-20:',10i6)");
    FEM_DO_SAFE(i, 11, 20) {
      wloop, lstat(i + 20);
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, "('   Size 21-on:',10i6)");
    FEM_DO_SAFE(i, 21, 27) {
      wloop, lstat(i + 20);
    }
  }
  window(cmn);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 46:  "LIMIT"    $$$$  $$$$  $$$$  $$$$  $$$$M36.2382
  statement_3647:
  write(munit6, "('   Limit  1-10:',10i6)"), cmn.lbus, lbrnch, ldata,
    cmn.lexct, cmn.lymat, lswtch, cmn.lsize7, cmn.lpast, cmn.lnonl,
    cmn.lchar;
  window(cmn);
  write(munit6, "('   Limit 11-20:',10i6)"), cmn.lsmout, cmn.lsiz12,
    cmn.lfdep, cmn.lwt, cmn.ltails, cmn.limass, cmn.lsyn, cmn.maxpe,
    cmn.ltacst, cmn.lfsem;
  window(cmn);
  write(munit6, "('   Limit 21-ON:',10i6)"), cmn.lfd, cmn.lhist,
    cmn.lsiz23, cmn.lcomp, cmn.lspcum, cmn.lsiz26, cmn.lsiz27;
  window(cmn);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 47:  "IOUT"     $$$$  $$$$  $$$$  $$$$  $$$$M36.2392
  statement_3662:
  write(prom80, "('    SEND NEW PRINTOUT FREQUENCY [',i5,' ] : ')"), iout;
  FEM_THROW_UNHANDLED("executable assign: assign3665tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, n6);
  limstp = 999999;
  if (n6 <= 0) {
    n6 = 1;
  }
  copyi(n6, multpr(1), 5);
  n7 = istep - 1;
  FEM_DO_SAFE(j, 1, 9999) {
    n7++;
    n8 = n7 / n6;
    if (n6 * n8 != n7) {
      goto statement_3668;
    }
    if (cmn.iprsup < 1) {
      goto statement_3667;
    }
    write(munit6, "(' NEW ROUND STOP.  N7 =',i8)"), n7;
    window(cmn);
    statement_3667:
    if (n6 < 20) {
      n7 += n6;
    }
    if (n7 < istep + 20) {
      n7 += n6;
    }
    kprchg(2) = n7;
    kprchg(5) = 999999;
    kprchg(4) = 999999;
    kprchg(3) = 999999;
    goto statement_3675;
    statement_3668:;
  }
  statement_3675:
  iout = n6;
  if (isprin > iout) {
    isprin = iout;
  }
  limstp = n7;
  indstp = 2;
  if (iprspy < 1) {
    goto statement_3679;
  }
  write(munit6, "(' LIMSTP, INDSTP, ISTEP, IOUT, ISPRIN =',5i8)"),
    limstp, indstp, istep, iout, isprin;
  window(cmn);
  statement_3679:
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 48:  "NODE"     $$$$  $$$$  $$$$  $$$$  $$$$M36.2426
  statement_3684:
  write(prom80, "('       SEND  A6  BUS NAME (CONNECT) :')");
  statement_3688:
  FEM_THROW_UNHANDLED("executable assign: assign3690tonextsn");
  goto statement_9800;
  spycd2 = buff77(1, 35);
  if (spycd2(1, 8) == "STOP    " || spycd2(1, 8) == "END     ") {
    goto statement_1240;
  }
  if (spycd2(1, 8) == "CONNECT ") {
    goto statement_3701;
  }
  FEM_DO_SAFE(j, 1, ntot) {
    write(brobus, format_3691), bus(j);
    if (brobus != spycd2(1, 8)) {
      goto statement_3693;
    }
    write(prom80, "('       >>> Node =',i4,15x,':')"), j;
    goto statement_3688;
    statement_3693:;
  }
  write(munit6, "('        \?\?\?\?  Sorry, no such bus.  Try again ...')");
  window(cmn);
  goto statement_3684;
  statement_3701:
  mmfind = j;
  n6 = 0;
  FEM_DO_SAFE(k, 1, ibr) {
    if (mmfind != fem::iabs(kbus(k)) && mmfind != fem::iabs(mbus(k))) {
      goto statement_3705;
    }
    if (n6 < 20) {
      goto statement_3703;
    }
    {
      write_loop wloop(munit6, format_3708);
      FEM_DO_SAFE(ip, 1, n6) {
        wloop, mmhold(ip);
      }
    }
    window(cmn);
    n6 = 0;
    statement_3703:
    n6++;
    mmhold(n6) = k;
    statement_3705:;
  }
  if (n6 <= 0) {
    goto statement_3709;
  }
  {
    write_loop wloop(munit6, format_3708);
    FEM_DO_SAFE(k, 1, n6) {
      wloop, mmhold(k);
    }
  }
  window(cmn);
  statement_3709:
  n6 = 0;
  FEM_DO_SAFE(k, 1, kswtch) {
    if (mmfind != fem::iabs(kmswit(k)) && mmfind != fem::iabs(kmswit(
        lswtch + k))) {
      goto statement_3719;
    }
    n6++;
    mmhold(n6) = k;
    statement_3719:;
  }
  if (n6 <= 0) {
    goto statement_3722;
  }
  {
    write_loop wloop(munit6, "('    %% EMTP  switches  :',20i5)");
    FEM_DO_SAFE(k, 1, n6) {
      wloop, mmhold(k);
    }
  }
  window(cmn);
  statement_3722:
  n6 = 0;
  FEM_DO_SAFE(k, 1, inonl) {
    if (mmfind != fem::iabs(nonlk(k)) && mmfind != fem::iabs(nonlm(k))) {
      goto statement_3726;
    }
    n6++;
    mmhold(n6) = k;
    statement_3726:;
  }
  if (n6 <= 0) {
    goto statement_3731;
  }
  {
    write_loop wloop(munit6, "('    %% Nonlinear elem. :',20i5)");
    FEM_DO_SAFE(k, 1, n6) {
      wloop, mmhold(k);
    }
  }
  window(cmn);
  statement_3731:
  n6 = 0;
  FEM_DO_SAFE(k, 1, kconst) {
    if (mmfind != fem::iabs(node(k))) {
      goto statement_3734;
    }
    n6++;
    mmhold(n6) = k;
    statement_3734:;
  }
  if (n6 <= 0) {
    goto statement_3739;
  }
  {
    write_loop wloop(munit6, "('    %% EMTP  sources  : ',20i5)");
    FEM_DO_SAFE(k, 1, n6) {
      wloop, mmhold(k);
    }
  }
  window(cmn);
  statement_3739:
  mmfind = 0;
  goto statement_3684;
  //C     $$$$$$$  KEY WORD NO. 49:  "NONLIN"   $$$$  $$$$  $$$$  $$$$  $$$$M36.2491
  statement_3752:
  bytbuf(1, 4) = answ80(1, 4);
  n33 = 0;
  if (inonl > 0) {
    goto statement_3762;
  }
  write(munit6, format_2805);
  window(cmn);
  goto statement_1240;
  statement_3758:
  FEM_THROW_UNHANDLED("executable assign: assign3760tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  statement_3762:
  if (bytbuf(1, 4) == "END ") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) == "STOP") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) != "EXTR") {
    goto statement_3774;
  }
  statement_3766:
  write(prom80,
    "(9x,'ANONL',8x,'VZERO',8x,'VNONL',9x,'CURR',7x,'VECNL1',7x,'VECNL1:')");
  n33 = 1;
  goto statement_3758;
  statement_3774:
  if (bytbuf(1, 4) != spykwd(49)(1, 4)) {
    goto statement_3781;
  }
  write(prom80,
    "(' Row  name  name-K name-M  NONLK  NONLM NLTYPE',"
    "' NONLAD NONLE ILAST KUPL NLSUB :')");
  prompt(cmn);
  if (n33 > 0) {
    goto statement_3766;
  }
  prom80(1, 8) = blan80(1, 8);
  goto statement_3758;
  //C     WE GET TO 3781 IF NO KNOWN KEY WORD;  EXTRACT INTEGER PAIR.   THISM36.2520
  //C     IS DEC FREE-FORMAT; "INONL" IS MAXIMUM;  "N17" IS ERROR FLAG:     M36.2521
  statement_3781:
  intpar(cmn, inonl, n1, n2, n17);
  if (n17 > 0) {
    goto statement_3758;
  }
  FEM_DO_SAFE(i, n1, n2) {
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_3785;
    }
    kwtspy = 0;
    goto statement_3758;
    statement_3785:
    n5 = fem::iabs(nonlk(i));
    d12 = bus(n5);
    if (n5 == 1) {
      d12 = terra;
    }
    n6 = fem::iabs(nonlm(i));
    d13 = bus(n6);
    if (n6 == 1) {
      d13 = terra;
    }
    n7 = namenl(i);
    write(munit6, "(1x,i3,3(1x,a6),4i7,2i6,i5,i6)"), i, texvec(n7),
      d12, d13, nonlk(i), nonlm(i), nltype(i), nonlad(i), nonle(i),
      ilast(i), kupl(i), nlsub(i);
    window(cmn);
    if (n33 != 1) {
      goto statement_3796;
    }
    write(munit6, "(1x,6e13.4)"), anonl(i), vzer5(i), vnonl(i), curr(i),
      vecnl1(i), vecnl2(i);
    window(cmn);
    statement_3796:;
  }
  prom80(1, 8) = blan80(1, 8);
  goto statement_3758;
  //C     $$$$$$$  KEY WORD NO. 50:  "SPACE"    $$$$  $$$$  $$$$  $$$$  $$$$M36.2547
  statement_3842:
  d14 = pltbuf(indbeg + 1);
  kptplt = lstat(32);
  n77 = 0;
  n22 = kptplt + 1;
  write(munit6,
    "(2x,' Current values.  INDBUF  INDBEG  LIMBUF',"
    "'  MFLUSH  NUMDCD  NUMCRD  LIMCRD')");
  window(cmn);
  write(munit6, "(18x,7i8)"), indbuf, indbeg, limbuf, mflush,
    cmn.numdcd, numcrd, cmn.limcrd;
  window(cmn);
  write(munit6,
    "(3x,'Plot timespan now in memory (in sec) =',2e15.6)"), d14,
    cmn.t;
  window(cmn);
  if (mflush < 1000) {
    goto statement_3848;
  }
  statement_3846:
  buff77(1, 6) = "FLUSH ";
  d17 = -1;
  d18 = fltinf;
  n4 = 1;
  goto statement_3876;
  statement_3848:
  if (lastov != 9911) {
    goto statement_3851;
  }
  lastov = nchain - 1;
  goto statement_3857;
  statement_3851:
  write(prom80, "('    CHOOSE CLASS (CARDS, PLOT) :')");
  FEM_THROW_UNHANDLED("executable assign: assign3855tonextsn");
  goto statement_9800;
  if (buff77(1, 4) != "PLOT") {
    goto statement_3934;
  }
  //C     BEGIN LOGIC TO FREE SOME STORAGE SPACE FOR EMTP PLOT DATA:        M36.2571
  statement_3857:
  write(prom80,
    "('   OPERATION (WRITE, THIN, FLUSH,',"
    "' DELETE, AUTO, READ, OUT, HELP) :')");
  FEM_THROW_UNHANDLED("executable assign: assign43858tonextsn");
  goto statement_9800;
  if (buff77(1, 6) == "DELETE") {
    n77 = 1;
  }
  if (buff77(1, 6) == "READ  ") {
    n77 = 2;
  }
  if (buff77(1, 6) == "THIN  ") {
    n77 = 3;
  }
  if (buff77(1, 6) == "WRITE ") {
    n77 = 4;
  }
  if (buff77(1, 6) == "FLUSH ") {
    n77 = 5;
  }
  if (buff77(1, 4) != "HELP") {
    goto statement_3861;
  }
  write(munit6,
    "('        To free memory for more simulation',"
    "' plot points,  use one of these:')");
  window(cmn);
  write(munit6,
    "('        Either: 1) Begin by saving',"
    "' points on disk, prior to loss (\"WRITE\");')");
  window(cmn);
  write(munit6,
    "('                2) thin out present',"
    "' storage by regular omission (\"THIN\");')");
  window(cmn);
  write(munit6,
    "('                3) Delete older',"
    "' points, and shift the remainder (\"DELETE\") :')");
  window(cmn);
  write(munit6,
    "('                4) combined \"WRITE\" and',"
    "' \"THIN\", with common IPLOT (\"FLUSH\").')");
  window(cmn);
  write(munit6,
    "('        Send  \"READ\"  to load memory',"
    "' with plot data now on disk (LUNIT4).')");
  window(cmn);
  write(munit6,
    "('        Send  \"OUT\"  to switch from plot',"
    "' file to cards,  or  \"SPY\"  to abort.')");
  window(cmn);
  write(munit6,
    "('        Finally, send  \"AUTO\"  for automatic',"
    "' full flush to disk from now on.')");
  window(cmn);
  goto statement_3857;
  statement_3861:
  if (buff77(1, 4) != "AUTO") {
    goto statement_3862;
  }
  if (mflush < 1000) {
    mflush += 1000;
  }
  goto statement_3846;
  statement_3862:
  if (buff77(1, 4) == "OUT ") {
    goto statement_3851;
  }
  write(prom80, "('     SEND [Tmin, Tmax]',' (ALL, HALF) :')");
  FEM_THROW_UNHANDLED("executable assign: assign3865tonextsn");
  goto statement_9800;
  answ80 = buff77;
  if (answ80(1, 4) != "ALL ") {
    goto statement_3867;
  }
  d17 = -1.f;
  d18 = fltinf;
  goto statement_3874;
  statement_3867:
  if (answ80(1, 4) != "HALF") {
    goto statement_3871;
  }
  n1 = (indbuf - indbeg) / 2;
  n2 = (n1 / n22) * n22;
  n3 = indbeg + n2 + 1;
  d17 = -1.f;
  d18 = pltbuf(n3);
  if (iprspy >= 1) {
    write(6, "(' \"HALF\" computed.  N22, N3, D18 =',2i8,e14.5)"), n22, n3, d18;
  }
  goto statement_3874;
  statement_3871:
  frefp2(cmn, answ80, d17, d18);
  statement_3874:
  n4 = cmn.intinf;
  if (n77 == 1) {
    goto statement_3876;
  }
  write(prom80, "('      PROCESS EVERY  N-TH  STEP.  SEND N:')");
  FEM_THROW_UNHANDLED("executable assign: assign43875tonextsn");
  goto statement_9800;
  prom80 = buff77;
  frein1(cmn, prom80, n4);
  if (n4 == 0) {
    n4 = 1;
  }
  if (n4 < 0) {
    goto statement_3857;
  }
  if (n77 == 2) {
    goto statement_3915;
  }
  statement_3876:
  n13 = indbeg + 1;
  statement_3877:
  if (pltbuf(n13) >= d17) {
    goto statement_3886;
  }
  n13 += n22;
  if (n13 < indbuf) {
    goto statement_3877;
  }
  write(munit6,
    "('       \?\? \?\?  Sorry, no plot points in the',"
    "' requested time span.  Abort.')");
  window(cmn);
  goto statement_1240;
  statement_3886:
  if (n77 != 4 && n77 != 5) {
    goto statement_3904;
  }
  mflush++;
  write(lunit6,
    "('   ++++  Begin plot-data copy from',' memory to disk.   MFLUSH, N6,',"
    "' N4, Tbeg, Tend =',i3,2i8,2e14.5)"),
    mflush, n6, n4, d17, d18;
  goto statement_3906;
  statement_3904:
  write(lunit6,
    "('   ****  Begin thinning of plot data',"
    "' points, to reduce memory burden.','   N4, Tbeg, Tend =',i10,2e14.5)"),
    n4, d17, d18;
  statement_3906:
  ip = 0;
  n8 = n13 + kptplt;
  n6 = n13;
  FEM_DO_SAFE(L, 1, 999999) {
    if (pltbuf(n13) > d18) {
      goto statement_3911;
    }
    ip++;
    if (ip < n4) {
      goto statement_3908;
    }
    ip = 0;
    if (n77 != 4 && n77 != 5) {
      goto statement_3907;
    }
    {
      write_loop wloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(m, n13, n8) {
        wloop, pltbuf(m);
      }
    }
    if (n77 == 4) {
      goto statement_3908;
    }
    statement_3907:
    movesp(pltbuf(n13), pltbuf(n6), n22);
    n6 += n22;
    statement_3908:
    n13 += n22;
    if (n13 >= indbuf) {
      goto statement_3911;
    }
    n8 += n22;
  }
  statement_3911:
  if (n77 == 4) {
    goto statement_3914;
  }
  n14 = indbuf - n13 + 1;
  if (n14 > kptplt) {
    movesp(pltbuf(n13), pltbuf(n6), n14);
  }
  indbuf = n6 + n14 - 1;
  iascii(1000) = n13 - n6;
  if (n77 != 5) {
    goto statement_3914;
  }
  n5 = limbuf - indbuf;
  write(lunit6,
    "(9x,'Completed \"FLUSH\", leaving',i8,"
    "'  free cells for new plot points.')"),
    n5;
  if (mflush >= 1000) {
    goto statement_1240;
  }
  statement_3914:
  goto statement_3857;
  //C     BEGIN "READ" SERVICING (PLOT DATA GOES DISK TO MEMORY):           M36.2703
  statement_3915:
  write(prom80, "('      DESTINATION (0--START; 1--AS NOW) :')");
  FEM_THROW_UNHANDLED("executable assign: assign3917tonextsn");
  goto statement_9800;
  prom80 = buff77;
  frein1(cmn, prom80, n3);
  n13 = indbuf;
  if (n3 == 0) {
    n13 = indbeg;
  }
  ip = 0;
  n8 = n13 + kptplt;
  n11 = 0;
  FEM_DO_SAFE(j, 1, 999999) {
    ip++;
    if (ip >= n4) {
      goto statement_3919;
    }
    try {
      read(lunit4, fem::unformatted), d15;
    }
    catch (fem::read_end const&) {
      goto statement_3926;
    }
    if (d15 > d18) {
      goto statement_3928;
    }
    goto statement_3921;
    statement_3919:
    try {
      read_loop rloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(L, n13, n8) {
        rloop, pltbuf(L);
      }
    }
    catch (fem::read_end const&) {
      goto statement_3926;
    }
    if (pltbuf(n13) > d18) {
      goto statement_3934;
    }
    n11++;
    statement_3921:
    n8 += n22;
    if (n8 <= limbuf) {
      goto statement_3925;
    }
    write(munit6,
      "('   ###  Squish.  Memory space for plot data',"
      "' has run out after storing T=',e14.5)"),
      pltbuf(n13);
    window(cmn);
    goto statement_3928;
    statement_3925:
    n13 += n22;
  }
  j = 999999;
  goto statement_3928;
  statement_3926:
  write(munit6,
    "('     EOF during READ (LUNIT4).  Quit search',' for Tend =',e13.4)"),
    d18;
  window(cmn);
  statement_3928:
  indbuf = n13;
  n6 = limbuf - indbuf;
  write(munit6,
    "('     Steps read and retained =',i7,i6,'   Remaining free words =',i8)"),
    j, n11, n6;
  window(cmn);
  goto statement_3857;
  //C     BEGIN "CARDS" SERVICING (FILE6 CHARACTER STORAGE):                M36.2741
  statement_3934:
  write(prom80, "('   CHOOSE OPERATION (MOVE, BLANK,',' OUT, SPACE) :')");
  FEM_THROW_UNHANDLED("executable assign: assign3938tonextsn");
  goto statement_9800;
  if (buff77(1, 4) == "OUT ") {
    goto statement_3851;
  }
  if (buff77(1, 6) == "SPACE ") {
    goto statement_3851;
  }
  n66 = 0;
  if (buff77(1, 6) == "BLANK ") {
    n66 = 1;
  }
  write(prom80, "('      NUMBER OF CARDS TO BE HANDLED :')");
  FEM_THROW_UNHANDLED("executable assign: assign3942tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, n11);
  if (n11 <= 0) {
    goto statement_3851;
  }
  if (n66 == 1) {
    goto statement_3955;
  }
  write(prom80, "('      CARD ADDRESSES N-from and N-to :')");
  FEM_THROW_UNHANDLED("executable assign: assign3947tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, n11);
  if (n17 <= 0) {
    goto statement_3934;
  }
  if (n18 < n17) {
    goto statement_3934;
  }
  FEM_DO_SAFE(j, 1, n11) {
    file6(n18) = file6(n17);
    n17++;
    n18++;
  }
  goto statement_3934;
  statement_3955:
  write(prom80, "('      CARD ADDRESS :')");
  FEM_THROW_UNHANDLED("executable assign: assign3959tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, n17);
  if (n17 <= 0) {
    goto statement_3851;
  }
  FEM_DO_SAFE(j, 1, n11) {
    file6(n17) = blan80;
    n17++;
  }
  goto statement_3934;
  //C     $$$$$$$  KEY WORD NO. 51:  "LUNIT4"   $$$$  $$$$  $$$$  $$$$  $$$$M36.2778
  statement_4002:
  forbyt(1) = -fltinf;
  kptplt = lstat(32);
  d24 = fltinf;
  statement_4008:
  write(prom80,
    "('   OPERATION (OPEN, CLOSE,',' TOP, BOT, NEXT, BACK, TIME) :')");
  FEM_THROW_UNHANDLED("executable assign: assign4011tonextsn");
  goto statement_9800;
  if (buff77(1, 5) != "CLOSE") {
    goto statement_4022;
  }
  write(prom80, "('     SAVE PERMANENTLY? (Y OR N) :')");
  FEM_THROW_UNHANDLED("executable assign: assign4016tonextsn");
  goto statement_9800;
  ansi8 = "KEEP    ";
  if (buff77(1, 1) == "N") {
    ansi8 = "DELETE  ";
  }
  cmn.io.close(lunit4)
    .status(ansi8);
  goto statement_4008;
  statement_4022:
  if (buff77(1, 5) != "OPEN ") {
    goto statement_4036;
  }
  write(prom80, "('     DESIRED DISK FILE NAME :')");
  FEM_THROW_UNHANDLED("executable assign: assign4026tonextsn");
  goto statement_9800;
  ansi32 = buff77(1, 32);
  write(prom80, "('     DESIRED STATUS (NEW, OLD) :')");
  FEM_THROW_UNHANDLED("executable assign: assign4029tonextsn");
  goto statement_9800;
  cmn.io.open(lunit4, ansi32)
    .form("UNFORMATTED")
    .status(buff77);
  goto statement_4008;
  statement_4036:
  if (buff77(1, 4) != "TOP ") {
    goto statement_4051;
  }
  statement_4037:
  cmn.io.rewind(lunit4);
  read(lunit4, fem::unformatted), date1, tclock, n1, n2, n3, n4;
  if (nchain <= 16 || nchain > 20) {
    goto statement_4044;
  }
  if (n2 == numnvo && n3 == nc - nv && n4 == nc) {
    goto statement_4044;
  }
  write(munit6,
    "('   ++++  Error.  Inconsistent LUNIT4 plot',"
    "' file.  Automatic close.  Try again.')");
  window(cmn);
  write(munit6,
    "('         DATE1, TCLOCK =',2(1x,2a4),5x,'N1:N4 =',4i8)"),
    date1, tclock, n1, n2, n3, n4;
  window(cmn);
  cmn.io.close(lunit4);
  goto statement_4008;
  statement_4044:
  if (n2 > 0) {
    read(lunit4, fem::unformatted), n5;
  }
  if (n4 > 0) {
    read(lunit4, fem::unformatted), n6;
  }
  kptplt = numnvo + nc;
  if (buff77(1, 5) == "TIME ") {
    goto statement_24085;
  }
  goto statement_4008;
  statement_4051:
  if (buff77(1, 4) != "BOT ") {
    goto statement_4068;
  }
  n15 = 0;
  FEM_DO_SAFE(k, 1, 100) {
    FEM_DO_SAFE(j, 1, 1000) {
      try {
        read(lunit4, fem::unformatted), forbyt(1);
      }
      catch (fem::read_end const&) {
        goto statement_4062;
      }
    }
    n15 += 1000;
    write(munit6, format_4056), n15;
    window(cmn);
  }
  goto statement_4008;
  statement_4062:
  n15 += j;
  write(munit6,
    "('       Ok, at end LUNIT4.  T-end =',e15.6,'   Steps taken =',i8)"),
    forbyt(1), n15;
  window(cmn);
  goto statement_4008;
  statement_4068:
  if (buff77(1, 4) != "NEXT") {
    goto statement_4079;
  }
  try {
    read_loop rloop(cmn, lunit4, fem::unformatted);
    FEM_DO_SAFE(j, 1, kptplt + 1) {
      rloop, forbyt(j);
    }
  }
  catch (fem::read_end const&) {
    goto statement_4075;
  }
  {
    write_loop wloop(munit6, format_4071);
    FEM_DO_SAFE(j, 1, kptplt + 1) {
      wloop, forbyt(j);
    }
  }
  window(cmn);
  if (forbyt(1) < d24) {
    d24 = forbyt(1);
  }
  goto statement_4008;
  statement_4075:
  write(munit6, "('     ===   Sorry,  no more  LUNIT4  data.','   EOF hit.')");
  window(cmn);
  goto statement_4008;
  statement_4079:
  if (buff77(1, 4) != "BACK") {
    goto statement_4083;
  }
  if (cmn.noback != 1) {
    goto statement_4082;
  }
  write(munit6,
    "('    Ok,  but wait for  \"TOP\"  and  \"TIME\"',"
    "'  using  t = t - 2*DELTAT')");
  window(cmn);
  buff77(1, 5) = "TIME ";
  d8 = forbyt(1) - 2 * cmn.deltat;
  goto statement_4037;
  statement_4082:
  cmn.io.backspace(lunit4);
  try {
    read_loop rloop(cmn, lunit4, fem::unformatted);
    FEM_DO_SAFE(j, 1, kptplt + 1) {
      rloop, forbyt(j);
    }
  }
  catch (fem::read_end const&) {
    goto statement_4075;
  }
  {
    write_loop wloop(munit6, format_4071);
    FEM_DO_SAFE(j, 1, kptplt + 1) {
      wloop, forbyt(j);
    }
  }
  window(cmn);
  if (forbyt(1) > d24) {
    cmn.io.backspace(lunit4);
  }
  goto statement_4008;
  statement_4083:
  if (buff77(1, 4) != "TIME") {
    goto statement_4098;
  }
  write(prom80, "('       SEND DESIRED TIME [',e15.6,' ] :')"), forbyt(1);
  FEM_THROW_UNHANDLED("executable assign: assign4085tonextsn");
  goto statement_9800;
  frefp1(cmn, buff77, d8);
  statement_24085:
  n15 = 0;
  FEM_DO_SAFE(k, 1, 100) {
    FEM_DO_SAFE(j, 1, 1000) {
      try {
        read(lunit4, fem::unformatted), forbyt(1);
      }
      catch (fem::read_end const&) {
        goto statement_4090;
      }
      if (forbyt(1) >= d8) {
        goto statement_4094;
      }
    }
    n15 += 1000;
    write(munit6, format_4056), n15;
    window(cmn);
  }
  goto statement_4008;
  statement_4090:
  n15 += j;
  write(munit6,
    "('      ? ? ?   Search fails with EOF after',i8,'   steps.')"),
    n15;
  window(cmn);
  goto statement_4008;
  statement_4094:
  n15 += j;
  write(munit6,
    "('      Ok, record of  t =',e15.6,'  just read on try number',i7)"),
    forbyt(1), n15;
  window(cmn);
  goto statement_4008;
  //C     PUT ANY LATER OPERATION CHOICES HERE AND BELOW:                   M36.2882
  statement_4098:
  write(munit6, format_2796);
  window(cmn);
  goto statement_4008;
  //C     $$$$$$$  KEY WORD NO. 52:  "SERIES"   $$$$  $$$$  $$$$  $$$$  $$$$M36.2884
  statement_4163:
  if (nchain <= 11) {
    kbrser = 1;
  }
  n42 = lstat(22);
  n43 = lstat(23);
  if (kbrser != 2) {
    goto statement_4165;
  }
  write(munit6,
    "('   @ @ @ @ @ @   Ok, guy, this is the',"
    "' \"OVER12\" break for \"SERIES\" usage.')");
  window(cmn);
  kbrser = 0;
  statement_4165:
  write(prom80, "('  OPERATION (SHOW, EXTRA, CHANGE,',' STEP, REWIND) :')");
  FEM_THROW_UNHANDLED("executable assign: assign4169tonextsn");
  goto statement_9800;
  ansi32 = buff77(1, 32);
  if (ansi32(1, 6) != "REWIND") {
    goto statement_4172;
  }
  kserlc = 0;
  lserlc = 0;
  goto statement_4165;
  statement_4172:
  if (ansi32(1, 5) != "SHOW ") {
    goto statement_4184;
  }
  write(munit6,
    "('  MEMORY:  LIST-2 ---',2i5,'     LIST-3 ---',2i5,'    LSERLC =',i4)");
  window(cmn);
  write(munit6,
    "(' num row use  bus-K  bus-M   name \?\?\?\?',5x,'present-R',5x,"
    "'present-L',5x,'present-C')"),
    n42, lbrnch, n43, ldata, lserlc;
  window(cmn);
  FEM_DO_SAFE(j, 1, lserlc) {
    ndx1 = n42 + j;
    ndx2 = n43 + j;
    k = kbus(ndx1);
    if (k == 0) {
      goto statement_4180;
    }
    m = mbus(ndx1);
    ndx3 = namebr(ndx1);
    write(munit6, "(1x,i3,2i4,3(1x,a6),5x,3e13.4)"), j, litype(ndx1),
      nr(ndx1), bus(k), bus(m), namebr(ndx3), ci(ndx1), ck(ndx1), cik(
      ndx1);
    window(cmn);
    statement_4180:;
  }
  goto statement_4165;
  statement_4184:
  if (ansi32(1, 5) != "EXTRA") {
    goto statement_4197;
  }
  write(munit6,
    "(4x,'starting-R',3x,'starting-L',3x,'starting-C',7x,'next-R',7x,'next-L',"
    "7x,'next-C')");
  window(cmn);
  FEM_DO_SAFE(j, 1, lserlc) {
    ndx1 = n42 + j;
    if (kbus(ndx1) == 0) {
      goto statement_4192;
    }
    ndx2 = n43 + j;
    write(munit6, "(1x,6e13.4)"), cki(ndx1), ckkjm(ndx1), r(ndx2), tr(ndx2),
      tx(ndx2), c(ndx2);
    window(cmn);
    statement_4192:;
  }
  goto statement_4165;
  statement_4197:
  if (ansi32(1, 5) != "STEP ") {
    goto statement_4211;
  }
  kserlc = 1;
  goto statement_4165;
  statement_4211:
  if (ansi32(1, 6) != "CHANGE") {
    goto statement_4165;
  }
  statement_4214:
  write(prom80,
    "('    CHANGE TYPE (DATA, MOVE, BLANK, USE, VALUE,',' END) :')");
  FEM_THROW_UNHANDLED("executable assign: assign34215tonextsn");
  goto statement_9800;
  ansi32 = buff77(1, 32);
  if (ansi32(1, 4) == "END ") {
    goto statement_4165;
  }
  if (ansi32(1, 6) == "SERIES") {
    goto statement_4165;
  }
  if (ansi32(1, 5) != "MOVE ") {
    goto statement_4223;
  }
  statement_4216:
  write(prom80, format_4217);
  FEM_THROW_UNHANDLED("executable assign: assign4219tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  if (bytbuf(1, 4) == "END ") {
    goto statement_4214;
  }
  frein2(cmn, bytbuf, n13, n14);
  if (n14 > lserlc) {
    lserlc = n14;
  }
  n13 += n42;
  n14 += n42;
  kbus(n14) = kbus(n13);
  mbus(n14) = mbus(n13);
  n24 = 0;
  namea6(cmn, text1, n24);
  namebr(n14) = n24;
  litype(n14) = litype(n13);
  imodel(n14) = imodel(n13);
  nr(n14) = nr(n13);
  ci(n14) = ci(n13);
  ck(n14) = ck(n13);
  cik(n14) = cik(n13);
  cki(n14) = cki(n13);
  ckkjm(n14) = ckkjm(n13);
  n13 = n13 - n42 + n43;
  n14 = n14 - n42 + n43;
  tr(n14) = tr(n13);
  tx(n14) = tx(n13);
  r(n14) = r(n13);
  c(n14) = c(n13);
  goto statement_4216;
  statement_4223:
  if (ansi32(1, 5) != "DATA ") {
    goto statement_4232;
  }
  statement_4225:
  write(prom80, format_4217);
  FEM_THROW_UNHANDLED("executable assign: assign4227tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  if (bytbuf(1, 4) == "END ") {
    goto statement_4214;
  }
  frein2(cmn, bytbuf, n13, n14);
  if (n14 > lserlc) {
    lserlc = n14;
  }
  n14 += n42;
  kbus(n14) = fem::iabs(kbus(n13));
  mbus(n14) = fem::iabs(mbus(n13));
  nr(n14) = 0;
  n24 = 0;
  namea6(cmn, text1, n24);
  namebr(n14) = n24;
  litype(n14) = n13;
  n13 = fem::iabs(nr(n13));
  cki(n14) = tr(n13);
  ckkjm(n14) = tx(n13);
  ci(n14) = tr(n13);
  ck(n14) = tx(n13);
  cik(n14) = c(n13);
  n14 = n14 - n42 + n43;
  tr(n14) = tr(n13);
  tx(n14) = tx(n13);
  c(n14) = c(n13);
  r(n14) = c(n13);
  goto statement_4225;
  statement_4232:
  if (ansi32(1, 5) != "BLANK") {
    goto statement_4245;
  }
  statement_4235:
  write(prom80, "('    SEND N-beg AND N-end LINE NUMBERS :')");
  FEM_THROW_UNHANDLED("executable assign: assign4237tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  if (bytbuf(1, 4) == "END ") {
    goto statement_4214;
  }
  frein2(cmn, bytbuf, n13, n14);
  if (n14 < lserlc) {
    goto statement_4239;
  }
  lserlc = n13 - 1;
  goto statement_4235;
  statement_4239:
  FEM_DO_SAFE(j, n13, n14) {
    kbus(j + n42) = 0;
  }
  goto statement_4235;
  statement_4245:
  if (ansi32(1, 4) != "USE ") {
    goto statement_4256;
  }
  {
    write_loop wloop(munit6, "('    NR:',10i7)");
    FEM_DO_SAFE(j, 1, lserlc) {
      wloop, nr(j + n42);
    }
  }
  window(cmn);
  statement_4251:
  write(prom80, "('    SEND NUMBER TO TOGGLE (0=END) :')");
  FEM_THROW_UNHANDLED("executable assign: assign4254tonextsn");
  goto statement_9800;
  if (buff77(1, 4) == "END ") {
    goto statement_4214;
  }
  frein1(cmn, buff77, n6);
  if (n6 <= 0) {
    goto statement_4214;
  }
  n7 = n6 + n42;
  nr(n7)++;
  if (nr(n7) >= 2) {
    nr(n7) = 0;
  }
  goto statement_4251;
  //C     PLACE ANY ADDITIONAL SUBCOMMANDS HERE:                            M36.3030
  statement_4256:
  goto statement_4214;
  //C     $$$$$$$  KEY WORD NO. 53:  "LOCK"     $$$$  $$$$  $$$$  $$$$  $$$$M36.3032
  statement_4436:
  lockbr = 1;
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 54:  "[Y]"      $$$$  $$$$  $$$$  $$$$  $$$$M36.3035
  statement_4471:
  j = 1;
  statement_4473:
  write(prom80, "('   SEND ROW NAME OR NUMBER (END) :')");
  FEM_THROW_UNHANDLED("executable assign: assign54474tonextsn");
  goto statement_9800;
  prom80 = buff77;
  if (prom80(1, 4) == "END ") {
    goto statement_1240;
  }
  if (prom80(1, 6) != "      " && prom80(1, 6) != "NEXT  ") {
    goto statement_4475;
  }
  j++;
  goto statement_4494;
  statement_4475:
  if (prom80(1, 4) != "TOP ") {
    goto statement_4476;
  }
  j = 2;
  goto statement_4494;
  statement_4476:
  if (prom80(1, 4) != "BOT ") {
    goto statement_4477;
  }
  j = -9999;
  goto statement_4494;
  statement_4477:
  FEM_DO_SAFE(j, 1, 10) {
    if (prom80(1, 1) == digit(j)) {
      goto statement_4491;
    }
  }
  read(prom80, "(a6)"), text2;
  FEM_DO_SAFE(j, 1, kpartb) {
    if (text2 == bus(j)) {
      goto statement_4494;
    }
  }
  write(munit6, "('  %% %% == ++  Sorry, no such row.  Try again.')");
  window(cmn);
  goto statement_4473;
  statement_4491:
  frein1(cmn, prom80, j);
  statement_4494:
  if (answ80(1, 3) == "[F]") {
    goto statement_4515;
  }
  if (j <= 1) {
    j = kpartb;
  }
  if (j > kpartb) {
    j = 2;
  }
  n17 = kks(j) - 1;
  n16 = kks(j + 1);
  if (j == kpartb) {
    n16 = kks(1);
  }
  write(munit6,
    "(' Row',i4,'   Name = ',a6,'   Limits =',2i5,"
    "'    nonzero  (m, Ykm)  follow ....')"),
    j, bus(j), n16, n17;
  window(cmn);
  FEM_DOSTEP(L, n16, n17, 4) {
    n23 = L + 3;
    if (n23 > n17) {
      n23 = n17;
    }
    {
      write_loop wloop(munit6, format_4497);
      FEM_DO_SAFE(m, L, n23) {
        wloop, km(m), ykm(m);
      }
    }
    window(cmn);
  }
  goto statement_4473;
  //C     $$$$$$$  KEY WORD NO. 55:  "[F]"      $$$$  $$$$  $$$$  $$$$  $$$$M36.3077
  statement_4512:
  goto statement_4473;
  statement_4515:
  if (j <= 1) {
    j = kpartb;
  }
  if (j > kpartb) {
    j = 2;
  }
  n17 = kk(j - 1) + 1;
  write(munit6,
    "(' Row',i4,'   Name = ',a6,'   Limits =',2i5,"
    "'    nonzero  (m, Fkm)  follow ....')"),
    j, bus(j), n17, kk(j);
  window(cmn);
  FEM_DOSTEP(L, n17, kk(j), 4) {
    n23 = L + 3;
    if (n23 > kk(j)) {
      n23 = kk(j);
    }
    {
      write_loop wloop(munit6, format_4497);
      FEM_DO_SAFE(m, L, n23) {
        wloop, km(m), ykm(m);
      }
    }
    window(cmn);
  }
  goto statement_4512;
  //C     $$$$$$$  KEY WORD NO. 56:  "NOROLL"   $$$$  $$$$  $$$$  $$$$  $$$$M36.3088
  statement_4563:
  if (monits == 0) {
    goto statement_4571;
  }
  monits = 0;
  write(munit6, "(6x,'===  Cancel previous rolling printer plot.')");
  window(cmn);
  statement_4571:
  if (monitr == 0) {
    goto statement_1240;
  }
  monitr = 0;
  write(munit6, "(6x,'===  Cancel previous rolling vector plot.')");
  window(cmn);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 61:  "CHOICE"   $$$$  $$$$  $$$$  $$$$  $$$$M37.6624
  statement_4592:
  n17 = nc - nv;
  n24 = numnvo + nc + nsmout + ioutcs + numout;
  write(munit6,
    "('     Total number of EMTP outputs (sum of 5',' classes) =',i5)"),
    n24;
  window(cmn);
  write(munit6,
    "('     Ordered class limits :   NUMNVO      NV',"
    "'   NC-NV  NSMOUT  IOUTCS   NUMOUT')");
  window(cmn);
  write(munit6, "(28x,6i8)"), numnvo, nv, n17, nsmout, ioutcs, numout;
  window(cmn);
  write(munit6,
    "('     Selective node voltage outputs (cells  1','  through',i3,' ) :')"),
    numnvo;
  window(cmn);
  FEM_DOSTEP(j, 1, numnvo, 7) {
    n17 = j + 6;
    if (n17 > sve.numnv0) {
      n17 = numnvo;
    }
    {
      write_loop wloop(munit6, "(7x,10a7)");
      FEM_DO_SAFE(m, j, n17) {
        wloop, bus(ibsout(m));
      }
    }
    window(cmn);
  }
  n7 = numnvo + 1;
  n8 = numnvo + nv;
  if (n8 < n7) {
    goto statement_4631;
  }
  write(munit6,
    "('     Branch voltage node-name pairs (cells',i3,'  through',i3,' ) :')"),
    n7, n8;
  window(cmn);
  n9 = 7878;
  spyout(cmn, n9, n9);
  FEM_DO_SAFE(j, 1, nv) {
    spyout(cmn, ibrnch(j), jbrnch(j));
  }
  n9 = -7878;
  spyout(cmn, n9, n9);
  statement_4631:
  n7 = numnvo + nv + 1;
  n8 = numnvo + nc;
  write(munit6,
    "('     Element current node-name pairs (cells',i3,'  through',i3,' ) :')"),
    n7, n8;
  window(cmn);
  if (n17 <= 0) {
    goto statement_4658;
  }
  n9 = 7878;
  spyout(cmn, n9, n9);
  FEM_DO_SAFE(j, 1, kswtch) {
    if (kmswit(lswtch + j) > 0) {
      goto statement_4639;
    }
    spyout(cmn, kmswit(j), kmswit(lswtch + j));
    statement_4639:;
  }
  FEM_DO_SAFE(j, 1, inonl) {
    if (nonlm(j) > 0) {
      goto statement_4644;
    }
    spyout(cmn, nonlk(j), nonlm(j));
    statement_4644:;
  }
  FEM_DO_SAFE(j, 1, ibr) {
    if (mbus(j) > 0) {
      goto statement_4649;
    }
    spyout(cmn, kbus(j), mbus(j));
    statement_4649:;
  }
  n9 = -7878;
  spyout(cmn, n9, n9);
  statement_4658:
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 62:  "TACS"     $$$$  $$$$  $$$$  $$$$  $$$$M37.6682
  statement_4716:
  write(prom80,
    "(' SEND CONTROL (REWIND, SOURCE,',' SUPPLEMENTAL, PATCH, SHOW, END) :')");
  FEM_THROW_UNHANDLED("executable assign: assign4719tonextsn");
  goto statement_9800;
  prom80 = buff77;
  if (prom80(1, 4) == "END ") {
    goto statement_1240;
  }
  if (prom80(1, 6) != "REWIND") {
    goto statement_4724;
  }
  {
    // handling equivalence in tacsar.inc
    auto isptacs = ArraySpan(reinterpret_cast<int*>(&sptacs(1)), sptacs.size() * sizeof(sptacs(1)) / sizeof(int));
    auto& konsce = isptacs(1);
    auto& kofsce = isptacs(4);
    niu = konsce;
    nsup = konsup;
    lstat(55) = nsup;
    ktab = kofsce;
    koncur = 0;
  }
  goto statement_4716;
  statement_4724:
  if (prom80(1, 6) != "SOURCE") {
    goto statement_4726;
  }
  koncur = 1;
  goto statement_4734;
  statement_4726:
  if (prom80(1, 6) != "SUPPLE") {
    goto statement_4752;
  }
  koncur = 2;
  statement_4734:
  n23 = lunit5;
  //C     READ INPUT DATA CARD USING CIMAGE.                                M37.6703
  statement_4738:
  cimage(cmn);
  read(abuff, format_2788), ansi8;
  if (ansi8(1, 4) != "END ") {
    goto statement_4741;
  }
  goto statement_4716;
  statement_4741:
  if (ansi8(1, 4) != "SPY ") {
    goto statement_4745;
  }
  //lunit5 = n23;
  goto statement_1240;
  statement_4745:
  if (koncur == 1) {
    tacs1(cmn);
  }
  if (koncur == 2) {
    tacs1a(cmn);
  }
  goto statement_4738;
  statement_4752:
  if (prom80(1, 6) != "PATCH ") {
    goto statement_4792;
  }
  n11 = locint(kar1(1));
  n12 = locint(volti(1));
  n13 = (n12 - n11) / 2;
  if (iprspy <= 1) {
    goto statement_34753;
  }
  write(munit6,
    "(' VOLTI MEMORY INDICES.  N11, N12, N13 =',3i8,"
    "'    FKAR1(J), J=N13+1, N13+9) ....')"),
    n11, n12, n13;
  window(cmn);
  {
    write_loop wloop(munit6, "(9e14.4)");
    FEM_DO_SAFE(j, n13 + 1, n13 + 9) {
      wloop, fkar1(j);
    }
  }
  window(cmn);
  statement_34753:
  n14 = 0;
  statement_4754:
  write(prom80, "(' SEND SOURCE NAME, ADDRESS (A6, I6), OR \"END\":')");
  FEM_THROW_UNHANDLED("executable assign: assign4759tonextsn");
  goto statement_9800;
  prom80 = buff77;
  if (prom80(1, 4) == "END ") {
    goto statement_4776;
  }
  read(prom80, format_4763), bus1, n7;
  FEM_DO_SAFE(j, 1, niu) {
    ndx3 = ivarb(kaliu + j);
    bus2 = texvec(ndx3);
    if (bus1 != bus2) {
      goto statement_4769;
    }
    n14++;
    ndx4 = j + kxtcs + nuk;
    kontac(n14) = ndx4;
    epskon(n14) = 0.0f;
    konadd(n14) = n7;
    goto statement_4754;
    statement_4769:;
  }
  write(munit6,
    "('  ? ? ?   Sorry, no such TACS source named  \"',a6,"
    "'\".  Try again ....')");
  window(cmn);
  goto statement_4754;
  statement_4776:
  write(prom80,
    "(' SEND USAGE NAME, ADDRESS, TOLERANCE',' (A6, I6, E8.0), OR \"END\":')");
  FEM_THROW_UNHANDLED("executable assign: assign4778tonextsn");
  goto statement_9800;
  prom80 = buff77;
  if (prom80(1, 4) != "END ") {
    goto statement_4780;
  }
  kontot = n14;
  sptacs(3) = kontot;
  goto statement_4716;
  read(d13, star), d13z;
  statement_4780:
  read(prom80, format_4763), bus1, n7, d13z;
  FEM_DO_SAFE(j, 1, ktab) {
    ndx1 = kxtcs + j;
    ndx2 = ivarb(klntab + j);
    if (bus1 != texvec(ndx2)) {
      goto statement_4785;
    }
    if (koncur == 0) {
      koncur = n14;
    }
    n14++;
    kontac(n14) = ndx1;
    konadd(n14) = n7;
    epskon(n14) = d13z;
    goto statement_4776;
    statement_4785:;
  }
  write(munit6,
    "('  ? ? ?   Sorry, no such TACS output named  \"',a6,"
    "'\".  Try again ....')");
  window(cmn);
  goto statement_4776;
  statement_4792:
  if (prom80(1, 5) != "SHOW ") {
    goto statement_4807;
  }
  write(munit6,
    "(' Concurrent sequential processing (CSP)',' controls.  KONCUR =',i4,5x,"
    "'KONTOT =',i4)"),
    koncur, kontot;
  window(cmn);
  write(munit6, "('     row    name   index  memory    threshold')");
  window(cmn);
  FEM_DO_SAFE(i, 1, kontot) {
    n13 = ivarb(kontac(i) + klntab - kxtcs);
    write(munit6, "(i8,2x,a6,2i8,e13.4)"), i, texvec(n13), kontac(i),
      konadd(i), epskon(i);
    window(cmn);
  }
  //C     ANY ADDITIONAL RESPONSES TO TACS PROMPT GO HERE:                  M37.6789
  statement_4807:
  goto statement_4716;
  //C     $$$$$$$  KEY WORD NO. 64:  "V-I"      $$$$  $$$$  $$$$  $$$$  $$$$M37.6791
  statement_4823:
  n17 = 0;
  n8 = 0;
  write(munit6,
    "(' LISTS 9, 10 =',2i4,'      (NEXT, <CR>, LAST, ALL, MODE).')"),
    inonl, ichar;
  window(cmn);
  statement_4824:
  write(prom80,
    "(1x,' ROW        VCHAR        CCHAR       GSLOPE',"
    "' ROW NLTYPE NONLAD NONLE  CLASS :')");
  FEM_THROW_UNHANDLED("executable assign: assign4828tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  if (bytbuf(1, 4) == "END ") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) == "STOP") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) != "NEXT" && bytbuf(1, 4) != "    ") {
    goto statement_4829;
  }
  n17++;
  if (n17 > inonl) {
    n17 = 1;
  }
  goto statement_4844;
  statement_4829:
  if (bytbuf(1, 4) != "LAST") {
    goto statement_4831;
  }
  n17 = n17 - 1;
  if (n17 <= 0) {
    n17 = inonl;
  }
  goto statement_4844;
  statement_4831:
  if (bytbuf(1, 4) != "ALL ") {
    goto statement_4832;
  }
  n1 = 1;
  n2 = ichar;
  goto statement_4854;
  statement_4832:
  if (bytbuf(1, 4) != "MODE") {
    goto statement_4834;
  }
  n8++;
  if (n8 >= 2) {
    n8 = 0;
  }
  write(munit6, "('    ----  New mode flag N8 =',i2)"), n8;
  window(cmn);
  goto statement_4824;
  statement_4834:
  frein2(cmn, bytbuf, n1, n2);
  if (n8 == 1) {
    goto statement_4854;
  }
  FEM_DO_SAFE(n17, 1, inonl) {
    if (iabsz(nonlad(n17)) < n1) {
      goto statement_4837;
    }
    if (iabsz(nonlad(n17)) <= n2) {
      goto statement_4844;
    }
    statement_4837:;
  }
  goto statement_4824;
  statement_4844:
  n1 = iabsz(nonlad(n17));
  n2 = iabsz(nonle(n17));
  ansi8(1, 6) = "PSEUDO";
  if (nltype(n17) > 0) {
    ansi8(1, 6) = " TRUE ";
  }
  write(munit6, format_4851), n1, vchar(n1), cchar(n1), gslope(n1),
    n17, nltype(n17), nonlad(n17), nonle(n17), ansi8(1, 6);
  window(cmn);
  n1++;
  statement_4854:
  FEM_DO_SAFE(j, n1, n2) {
    write(munit6, format_4851), j, vchar(j), cchar(j), gslope(j);
    window(cmn);
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_4858;
    }
    kwtspy = 0;
    goto statement_4824;
    statement_4858:;
  }
  goto statement_4824;
  statement_1240:
  nexmod = 0;
  goto statement_9804;
  statement_9800:
  nexmod = 3;
  statement_9804:
  if (iprspy < 1) {
    goto statement_9999;
  }
  write(munit6,
    "(' EXIT \"SPYINK\".  JJROLL, KBREAK, LOCKBR,',' NCHAIN =',4i5,"
    "'   PROM80(1:20) =',a20)"),
    jjroll, kbreak, lockbr, nchain, prom80(1, 20);
  window(cmn);
  statement_9999:
  return;
  // UNHANDLED: ENTRY spytac
  //C     CALLED ONLY BY "SUBTS3", ONCE, FOR TACS CSP APPLICATION.          M37.6860
  FEM_DO_SAFE(j, 1, koncur) {
    n7 = kontac(j);
    n13 = konadd(j);
    sptacs(n7) = fkar1(n13);
  }
  tacs3(cmn);
  FEM_DO_SAFE(j, koncur + 1, kontot) {
    n7 = kontac(j);
    n13 = konadd(j);
    d8 = fkar1(n13) - sptacs(n7);
    if (std::abs(d8) <= epskon(j)) {
      goto statement_3486;
    }
    fkar1(n13) = sptacs(n7);
    ialter = 1;
    statement_3486:;
  }
  if (iprspy < 1) {
    goto statement_3496;
  }
  write(munit6,
    "(' EXIT \"SPYTAC\" AFTER CSP.  KONCUR,',' KONTOT, IALTER =',3i5)"),
    koncur, kontot, ialter;
  window(cmn);
  sptacs(2) = koncur;
  sptacs(3) = kontot;
statement_3496:;
#endif
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}


void tdelay(
  common& cmn,
  double& d8) try
{
  common_write write(cmn);
  int& kwtspy = cmn.kwtspy;
  //
  int n23 = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  //C     MODULE OF INTERACTIVE EMTP ONLY, WHICH SERVICES "EMTSPY".         M37.6933
  //C     IF NO INTERACTIVE USE, THIS MODULE CAN BE DELETED.                M37.6934
  //C       VAX-11   MODULE DESIGNED TO STALL FOR  D8  SECONDS.             M37.6935
  //C       PRESENT USE OF DISK WRITES IS TEMPORARY ONLY, AND SHOULD        M37.6936
  //C       LATER BE REPLACED BY A LESS-WASTEFUL, TRUE HIBERNATION.         M37.6937
  //C INTEGER NUMBER OF SECONDS FOR HIBERNATION
  n23 = d8;
  //C LOOP ONCE FOR EACH SECOND OF DELAY
  FEM_DO_SAFE(j, 1, n23) {
    //C ONE SECOND = ABOUT 6 WRITES TO DISK
    FEM_DO_SAFE(k, 1, 6) {
      //C REWIND UNUSED, DUMMY I/O CHANNEL 36
      cmn.io.rewind(36);
      //C DUMMY WRITE TO DISK
      write(36, "(i2)"), k;
    }
    //C CHECK FOR USER-KEYED INTERRUPT SIGNAL
    quiter(cmn);
    //C NO USER ABORT OF ALARM
    if (kwtspy == 0) {
      goto statement_3641;
    }
    //C RESET INTERRUPT INDICATOR AS WE BEGIN SERVICE
    kwtspy = 0;
    //C ARGUMENT FLAG REMEMBERING ABORT (FOR HONKER)
    d8 = -7654;
    //C JUMP OUT OF TIME-DELAY LOOP, TO RETURN
    goto statement_9000;
    //C END  DO 3641  LOOP OVER SECONDS
    statement_3641:;
  }
  statement_9000:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void honker(
  common& cmn,
  int const& klevel) try
{
  common_write write(cmn);
  int& kwtspy = cmn.kwtspy;
  fem::str<80>& buff77 = cmn.buff77;
  //
  double d13 = fem::double0;
  arr_1d<2, fem::str<8> > spytim(fem::fill0);
  arr_1d<2, fem::str<8> > spdate(fem::fill0);
  //C     MODULE OF INTERACTIVE EMTP ONLY, WHICH SERVICES "EMTSPY".         M36.3187
  //C     IF NO INTERACTIVE USE, THIS MODULE CAN BE DELETED.                M36.3188
  //C       VAX-11 INSTALLATION-DEPENDENT EMTP MODULE WHICH ISSUES          M36.3189
  //C       AN AUDIBLE ALARM (VIA A TERMINAL SPEAKER) OF INTENSITY          M36.3190
  //C       CONTROLLED BY ARGUMENT KLEVEL.  THIS IS ON A SCALE OF           M36.3191
  //C       ONE TO TEN, WITH ZERO MEANING NO NOISE AT ALL, AND TEN          M36.3192
  //C       CORRESPONDING TO A DISASTER ALERT (E.G., AIR RAID SIRENS).      M36.3193
  //C     THIS VAX-11 MODULE IS DESIGNED FOR DEC VT100 TERMINAL.  THE       M37.6901
  //C     IDEA IS BY ALBERT H. SCHMIDT, BPA ROUTE EOGA.  AT THE KEYBOARD,   M37.6902
  //C     CTRL-G WILL RING THE BELL, AND THE ASCII CHARACTER 7 IS           M37.6903
  //C     EQUIVALENT WITHIN A PROGRAM.  SHORTAGE OF 1 BELL IS DUE TO        M37.6904
  //C     CARRIAGE CONTROL, MAYBE (SEE N8 = J + 1, RATHER THAN J, BELOW).   M37.6905
  //C INITIALIZE TIME DELAY AT TWO SECONDS
  d13 = 2.0f;
  //C EMTP WALL-CLOCK TIME
  time44(cmn, spytim(1));
  //C EMTP DATE UTILITY
  date44(cmn, spdate(1));
  //C ASCII "7" = CTRL-G OF KEYBOARD = 1 BELL
  buff77(1, 1) = fem::fchar(7);
  //C DEFINE 2ND BELL, IF NEEDED
  buff77(2, 2) = buff77(1, 1);
  //C DEFINE 3RD BELL, IF NEEDED
  buff77(3, 3) = buff77(1, 1);
  //C DEFINE BELLS NUMBER 4 TO 6
  buff77(4, 6) = buff77(1, 3);
  //C DEFINE BELLS NUMBER 7-10
  buff77(7, 10) = buff77(1, 4);
  statement_3608:
  write(cmn.munit6,
    "(' AUDIBLE ALARM BEGAN AT  ',2a4,2x,2a4,5x,i3,' BELLS.',a)"),
    spytim, spdate, klevel, buff77(1, klevel);
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C EXIT MODULE (NO LOOP)
  if (klevel < 10) {
    goto statement_9000;
  }
  //C NOW STALL FOR D13 SECONDS
  tdelay(cmn, d13);
  //C INTERRUPT IN "TDELAY"
  if (d13 ==  - 7654) {
    goto statement_9000;
  }
  //C CHECK FOR USER-KEYED INTERRUPT SIGNAL
  flager(cmn);
  //C NO USER ABORT OF ALARM
  if (kwtspy == 0) {
    goto statement_3643;
  }
  //C RESET INTERRUPT INDICATOR AS WE BEGIN SERVICE
  kwtspy = 0;
  //C JUMP OUT OF LOOP (ABORT HONKING)
  goto statement_9000;
  //C LENGTHEN DELAY AFTER NEXT TEN BELLS
  statement_3643:
  d13 = 1.5f * d13;
  //C LOOP BACK TO REPEAT STRING OF 10 BELLS
  goto statement_3608;
  statement_9000:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void numchk(
  common& cmn,
  str_arr_cref<> vbyte,
  int const& nchar,
  int& kill) try
{
  vbyte(dimension(1));
  common_write write(cmn);
  const auto& digit = cmn.digit;
  fem::str<132>& munit6 = cmn.munit6;
  //
  int koldig = fem::int0;
  int nper = fem::int0;
  int nsign = fem::int0;
  int nume = fem::int0;
  int kk = fem::int0;
  int i = fem::int0;
  int kolexp = fem::int0;
  int kolper = fem::int0;
  int j = fem::int0;
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M35.3948
  //C     THIS UTILITY SERVES TO SCRUTINIZE THE INPUT CHARACTER STRING      M35.3949
  //C     (VBYTE(J), J=1, NCHAR)  TO SEE IF IT IS A LEGAL FLOATING-POINT    M35.3950
  //C     NUMBER.   IF SO,  "KILL"  IS TO BE SET TO ZERO;  IF NUMBER IS     M35.3951
  //C     STRUCTURALLY DEFICIENT,  "KILL"  IS TO BE SET POSITIVE.           M35.3952
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.3953
  kill = 0;
  koldig = 0;
  nper = 0;
  nsign = 0;
  nume = 0;
  kk = 0;
  FEM_DO_SAFE(i, 1, nchar) {
    if (vbyte(i) == " ") {
      goto statement_3481;
    }
    kk++;
    if (vbyte(i) != "+" && vbyte(i) != "-") {
      goto statement_3412;
    }
    //C     FOLLOWING CODE CONSIDERS RAMIFICATIONS OF JUST-FOUND "+" OR "-" : M35.3967
    nsign++;
    if (nsign > 2) {
      kill = 1;
    }
    if (kk == 1) {
      goto statement_3481;
    }
    if (kolexp == i - 1) {
      goto statement_3481;
    }
    kill = 1;
    goto statement_3481;
    statement_3412:
    if (vbyte(i) != "E" && vbyte(i) != "D") {
      goto statement_3425;
    }
    //C     FOLLOWING CODE CONSIDERS RAMIFICATIONS OF JUST-FOUND "D" OR "E":  M35.3976
    nume++;
    kolexp = i;
    if (nume > 1) {
      kill = 1;
    }
    goto statement_3481;
    statement_3425:
    if (vbyte(i) != ".") {
      goto statement_3428;
    }
    //C     FOLLOWING CODE CONSIDERS RAMIFICATIONS OF JUST-FOUND DECIMAL POINTM35.3982
    nper++;
    if (nper > 1) {
      kill = 1;
    }
    kolper = i;
    goto statement_3481;
    statement_3428:
    FEM_DO_SAFE(j, 1, 10) {
      if (vbyte(i) == digit(j)) {
        goto statement_3438;
      }
    }
    kill = 1;
    goto statement_3481;
    //C     FOLLOWING CODE CONSIDERS RAMIFICATIONS OF JUST-FOUND DIGIT:       M35.3992
    statement_3438:
    koldig = i;
    statement_3481:;
  }
  if (nume == 1 && kolexp > koldig) {
    kill = 1;
  }
  if (nume == 1 && kolper > kolexp) {
    kill = 1;
  }
  if (kill == 0) {
    return;
  }
  {
    write_loop wloop(munit6,
      "(' \?\?? SORRY, ILLEGAL NUMERIC JUST READ:',50a1)");
    FEM_DO_SAFE(j, 1, nchar) {
      wloop, vbyte(j);
    }
  }
  write(munit6, "('            MAKE A SECOND TRY, PLEASE ....')");
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void examin(
  common& cmn) try
{
  common_write write(cmn);
  const auto& ivec = cmn.ivec;
  const auto& iascii = cmn.iascii;
  int& memkar = cmn.memkar;
  int& iprspy = cmn.iprspy;
  const auto& locate = cmn.locate;
  int& kolout = cmn.kolout;
  const auto& imin = cmn.imin;
  const auto& imax = cmn.imax;
  int& numex = cmn.numex;
  const auto& locout = cmn.locout;
  const auto& intout = cmn.intout;
  const auto& kar1 = cmn.kar1;
  fem::str<8>& ansi8 = cmn.ansi8;
  fem::str<16>& ansi16 = cmn.ansi16;
  fem::str<132>& munit6 = cmn.munit6;
  fem::str<132>& outlin = cmn.outlin;
  //
  int jj = fem::int0;
  int n5 = fem::int0;
  int n3 = fem::int0;
  int n8 = fem::int0;
  int n9 = fem::int0;
  int n10 = fem::int0;
  arr_1d<1, double> fkar1(fem::fill0);
  arr_1d<1, double> fkar2(fem::fill0);
  int n17 = fem::int0;
  static const char* format_1620 = "(e15.6)";
  static const char* format_1624 = "(4x,'\"',a6,'\"',3x)";
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M37.7127
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M37.7128
  //C     THIS NEAR-UNIVERSAL MODULE SERVES TO BUILD THE CHARACTER*132      M37.7129
  //C     OUTPUT VECTOR OUTLIN OF THE "EXAMINE" COMMAND OF SPY.             M37.7130
  //C     COMPUTERS WITH INDEX PROBLEMS (E.G., PRIME) NEED REPLACEMENT      M37.7131
  if (iprspy < 1) {
    goto statement_1718;
  }
  write(munit6,
    "(' TOP OF \"EXAMIN\".  NUMEX, IMIN(1), LOCOUT(1) =',3i6)"),
    numex, imin(1), locout(1);
  window(cmn);
  statement_1718:
  jj = 0;
  outlin(1, 1) = " ";
  kolout = 2;
  if (numex <= 0) {
    goto statement_9000;
  }
  statement_1540:
  jj++;
  n5 = imin(jj);
  n3 = locout(jj);
  n8 = locate(n3) + n5 - 1;
  if (intout(jj) == 0) {
    n8 += n5 - 1;
  }
  if (iprspy < 3) {
    goto statement_1560;
  }
  write(munit6,
    "(' NEXT  EXAMINE.  JJ, N5, N3, N8, INTOUT(JJ)',5i8)"), jj, n5,
    n3, n8, intout(jj);
  window(cmn);
  statement_1560:
  if (intout(jj) == 0) {
    goto statement_1600;
  }
  n9 = n8 - memkar;
  n8++;
  if (ivec(n3) == 1) {
    goto statement_1577;
  }
  if (n5 == 1 && imax(jj) == 1) {
    goto statement_1640;
  }
  statement_1577:
  write(ansi16, "(i10)"), kar1(1 + n9);
  outlin(kolout, kolout + 9) = ansi16(1, 10);
  outlin(kolout + 10, kolout + 14) = cmn.blan80(1, 5);
  kolout += 15;
  goto statement_1664;
  statement_1600:
  n9 = (n8 - memkar) / 2;
  n10 = memkar + 2 * n9 - n8;
  n8 += 2;
  if (n10 != 0) {
    goto statement_1628;
  }
  //C     FOLLOWING REAL*8 EXTRACTIONS LINE UP (NO NEED FOR 4-BYTE SHIFT):  M37.7165
  if (iascii(n3) == 0) {
    write(ansi16, format_1620), fkar1(1 + n9);
  }
  if (iascii(n3) == 1) {
    write(ansi16, format_1624), fkar1(1 + n9);
  }
  goto statement_1633;
  //C     FOLLOWING REAL*8 EXTRACTIONS REQUIRE A 4-BYTE SHIFT (FKAR2 USE).  M37.7173
  //C     FKAR2 HAS HIGHER MEMORY ADDRESS THAN FKAR1, SO IT IS CORRECT WITH M37.7174
  //C     N9 OFFSET IF N9 IS POSITIVE.   BUT IF N9 IS NEGATIVE, THE HALF    M37.7175
  //C     WORD SHIFT REALLY SHOULD BE TOWARD LOWER ADDRESSES, WHICH WE      M37.7176
  //C     COMPENSATE FOR BY THE CONTINUED USE OF FKAR2 BUT WITH ONE SMALLER M37.7177
  //C     N9 VALUE:                                                         M37.7178
  statement_1628:
  if (n9 < 0) {
    n9 = n9 - 1;
  }
  if (iascii(n3) == 0) {
    write(ansi16, format_1620), fkar2(1 + n9);
  }
  if (iascii(n3) == 1) {
    write(ansi16, format_1624), fkar2(1 + n9);
  }
  statement_1633:
  outlin(kolout, kolout + 14) = ansi16(1, 15);
  kolout += 15;
  goto statement_1664;
  statement_1640:
  write(ansi8, "(i6)"), kar1(1 + n9);
  outlin(kolout, kolout + 5) = ansi8(1, 6);
  if (iprspy < 3) {
    goto statement_1662;
  }
  write(munit6,
    "(' I6 INTEGER ENCODED FOR EXAMINE.  N9,KAR1(1+N9) =',2i8)"), n9,
    kar1(1 + n9);
  window(cmn);
  statement_1662:
  kolout += 6;
  statement_1664:
  n5++;
  if (n5 <= imax(jj)) {
    goto statement_1560;
  }
  if (jj < numex) {
    goto statement_1540;
  }
  if (kolout < 132) {
    outlin(kolout, 132) = " ";
  }
  if (iprspy < 1) {
    goto statement_9000;
  }
  n17 = kolout;
  if (n17 > 80) {
    n17 = 80;
  }
  write(munit6,
    "(' EXIT \"EXAMIN\".   KOLOUT =',i5,'    OUTLIN(1:80) =',a)"),
    kolout, outlin(1, n17);
  window(cmn);
  statement_9000:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void deposi(
  common& cmn,
  int const& ind,
  int const& intype,
  int& n1,
  int const& n2,
  double& d4) try
{
  common_read read(cmn);
  common_write write(cmn);
  const auto& iascii = cmn.iascii;
  int& memkar = cmn.memkar;
  int& iprspy = cmn.iprspy;
  const auto& locate = cmn.locate;
  auto& kar1 = cmn.kar1;
  fem::str<8>& ansi8 = cmn.ansi8;
  fem::str<132>& munit6 = cmn.munit6;
  //
  int n8 = fem::int0;
  int n9 = fem::int0;
  int n10 = fem::int0;
  arr_1d<1, double> fkar2(fem::fill0);
  arr_1d<1, double> fkar1(fem::fill0);
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M37.7206
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M37.7207
  //C     THIS NEAR-UNIVERSAL MODULE SERVICES "DEPOSIT", TO ACTUALLY        M37.7208
  //C     PERFORM THE TAMPERING.   SYMBOL IS IN ROW IND.  IF IT IS          M37.7209
  //C     OF TYPE ALPHANUMERIC, ANSI8(1:6) IN "DEKSPY" CARRIES THE          M37.7210
  //C     NEW CONTENTS.  OTHERWISE, D4 IS THE NUMERIC VALUE TO BE           M37.7211
  //C     DEPOSITED, AND INTYPE GIVES THE MODE (1=INTEGER, 0=REAL).         M37.7212
  //C     BOUNDING SUBSCRIPTS ON THE DEPOSIT ARE N1 AND N2, RESPECTIVELY.   M37.7213
  //C     COMPUTERS WITH INDEX PROBLEMS (E.G., PRIME) NEED REPLACEMENT      M37.7214
  if (iprspy < 1) {
    goto statement_1846;
  }
  write(munit6,
    "(' TOP OF \"DEPOSI\".   IND, INTYPE, IASCII(IND),',' D4, ANSI8 =',3i8,"
    "e15.4,3x,a8)"),
    ind, intype, iascii(ind), d4, ansi8;
  window(cmn);
  statement_1846:
  n8 = locate(ind);
  //C     FOLLOWING USE OF REAL*8 DEPOSIT LOGIC TO ALSO HANDLE              M37.7222
  //C     ALPHANUMERIC ONLY WORKS FOR COMPUTERS WITH THIS EQUALITY:         M37.7223
  if (iascii(ind) == 1) {
    read(ansi8, "(a6)"), d4;
  }
  if (intype == 0) {
    goto statement_1880;
  }
  n9 = n8 - memkar + n1;
  //C     ENTER LOOP OF INTEGER DEPOSITS, SUBSCRIPTS N1 THROUGH N2:         M37.7229
  statement_1854:
  kar1(n9) = d4;
  n1++;
  n9++;
  if (n1 <= n2) {
    goto statement_1854;
  }
  goto statement_8000;
  //C     OUR VECTOR IS  REAL*8, SO REQUIRES THE FOLLOWING SPECIAL DEPOSIT: M37.7235
  statement_1880:
  n9 = (n8 - memkar) / 2 + n1;
  n10 = memkar + 2 * (n9 - n1) - n8;
  //C     ENTER LOOP OF REAL DEPOSITS, SUBSCRIPTS N1 THROUGH N2:            M37.7238
  statement_1904:
  if (n10 > 0) {
    fkar2(n9) = d4;
  }
  if (n10 == 0) {
    fkar1(n9) = d4;
  }
  n1++;
  n9++;
  if (n1 <= n2) {
    goto statement_1904;
  }
  statement_8000:
  if (iprspy < 1) {
    goto statement_9000;
  }
  write(munit6, "(' EXIT \"DEPOSI\".')");
  window(cmn);
  statement_9000:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void append()
{
  //C     MODULE CONNECTED TO KEY WORD "APPEND" OF SPY.  OTHERS             M39.3272
  //C     CAN PERFECT AND USE THEIR OWN INSTALLATION-DEPENDENT              M39.3273
  //C     (AND PERHAPS PROPRIETARY) EXTENSIONS VIA THIS MODULE.             M39.3274
}

void helper(
  common& cmn,
  int const& n1) try
{
  common_write write(cmn);
  int& numkey = cmn.numkey;
  const auto& kbegtx = cmn.kbegtx;
  fem::str<132>& munit6 = cmn.munit6;
  const auto& texspy = cmn.texspy;
  fem::str<80>& buffin = cmn.buffin;
  //
  int n8 = fem::int0;
  int k = fem::int0;
  int n23 = fem::int0;
  int n24 = fem::int0;
  int j = fem::int0;
  //C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.6262
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.6263
  //C     THIS MODULE DOES NOTHING OTHER THAN SERVICE THE "HELP"            M37.7390
  //C     SUBCOMMAND OF THE "PLOT" COMMAND OF SPY.                          M37.7391
  n8 = n1;
  if (buffin(5, 10) != "      ") {
    goto statement_3618;
  }
  statement_3613:
  k = numkey + n8 + 1;
  n23 = kbegtx(k);
  n24 = kbegtx(k + 1) - 1;
  goto statement_3673;
  statement_3618:
  if (buffin(6, 10) != "OUTER") {
    goto statement_3622;
  }
  n8 = 1;
  goto statement_3613;
  statement_3622:
  if (buffin(6, 11) != "MIDDLE") {
    goto statement_3627;
  }
  n8 = 2;
  goto statement_3613;
  statement_3627:
  if (buffin(6, 10) != "INNER") {
    goto statement_3634;
  }
  n8 = 3;
  goto statement_3613;
  statement_3634:
  n23 = kbegtx(numkey + 1);
  n24 = kbegtx(numkey + 5) - 1;
  if (buffin(6, 8) == "ALL") {
    goto statement_3673;
  }
  FEM_DO_SAFE(j, n23, n24) {
    if (texspy(j)(1, 3) == "   ") {
      goto statement_3642;
    }
    if (texspy(j)(3, 10) == buffin(6, 13)) {
      goto statement_3649;
    }
    statement_3642:;
  }
  write(munit6,
    "('    ? ? ?   Sorry, no such plot command.','   Try again ... ')");
  window(cmn);
  goto statement_9000;
  statement_3649:
  n23 = j;
  FEM_DO_SAFE(j, n23 + 1, n24) {
    if (texspy(j)(1, 3) != "   ") {
      goto statement_3658;
    }
  }
  statement_3658:
  n24 = j - 1;
  statement_3673:
  FEM_DO_SAFE(j, n23, n24) {
    write(munit6, "(a80)"), texspy(j);
    window(cmn);
  }
  statement_9000:
  if (cmn.iprspy < 1) {
    goto statement_9011;
  }
  write(munit6, "(' EXIT  \"HELPER\".  N1, N8, N23, N24 =',4i6)"),
    n1, n8, n23, n24;
  window(cmn);
  statement_9011:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
  //C     USAGE IS RESTRICTED TO "PLOT" FUNCTION OF "EMTSPY", DUE           M35.  37
  //C     TO VARIABLE-LENGTH CONFLICT (THIS IS SINGLE-PRECISION).           M35.  38
  //C!w nc -> ncz, numnvo -> numnvz, numout -> numouz, nv -> nvz
  //C     EVNBYT PUTS BUSLST ON REAL*8 BYTE BOUNDARY (IBM LEVEL 4 ERROR):   M39.  44
  //C!w EQUIVALENCE  ( EV(   1), BUSLST(1) ),  ( EV(1001), IBSOUT(1) )
  //C!w EQUIVALENCE  ( EV(1301), IBRNCH(1) ),  ( EV(1601), JBRNCH(1) )
  //C!w EQUIVALENCE  ( FVCOM( 1),   VMIN ),  ( FVCOM( 2),   VMAX )
  //C!w EQUIVALENCE  ( FVCOM( 3),   HMIN ),  ( FVCOM( 4),   HMAX )
  //C!w EQUIVALENCE  ( FVCOM( 5),     HA ),  ( FVCOM( 6), TAXISL )
  //C!w EQUIVALENCE  ( FVCOM( 7), TOLRCE ),  ( FVCOM( 8),   HTAX )
  //C!w EQUIVALENCE  ( FVCOM( 9),   XTIT ),  ( FVCOM(10),   YTIT )
  //C!w EQUIVALENCE  ( FVCOM(11), SIZTIT ),  ( FVCOM(12), XSUPER )
  //C!w EQUIVALENCE  ( FVCOM(13), YSUPER ),  ( FVCOM(14), SIZSUP )
  //C!w EQUIVALENCE  ( FVCOM(15),  FLINE ),  ( FVCOM(16),  SIZID )
  //C!w EQUIVALENCE  ( FVCOM(17),    XID ),  ( FVCOM(18),    YID )
  //C!w EQUIVALENCE  ( FVCOM(19),   FACT ),  ( FVCOM(20), DXGRD1 )
  //C!w EQUIVALENCE  ( FVCOM(21), DYGRD1 ),  ( FVCOM(22), DXGRD2 )
  //C!w EQUIVALENCE  ( FVCOM(23), DYGRD2 ),  ( FVCOM(24),  FILL1 )
  //C!w EQUIVALENCE  ( FVCOM(25),  FILL2 ),  ( FVCOM(26),     VS )
  //C!w EQUIVALENCE  ( FVCOM(27),     VL ),  ( FVCOM(28),     VH )
  //C!w EQUIVALENCE  ( FVCOM(29), PAPMAX ),  ( FVCOM(30), TIMBEG )
  //C!w EQUIVALENCE  ( FVCOM(31), TIMEND ),  ( FVCOM(32), FHTAX  )
  //C!w EQUIVALENCE  ( FVCOM(33), FXSUP  ),  ( FVCOM(34), FYSUP  )
  //C!w EQUIVALENCE  ( FVCOM(35), FXTIT  ),  ( FVCOM(36), FYTIT  )
  //C!w EQUIVALENCE  ( FVCOM(37), FXID   ),  ( FVCOM(38), FYID   )
  //C!w EQUIVALENCE  ( FVCOM(39), FTCARR ),  ( FVCOM(40), VAXISL )
  //C!w EQUIVALENCE  ( FVCOM(41), FXNUMV ),  ( FVCOM(42), FXNUMH )
  //C!w EQUIVALENCE  ( FVCOM(43), FVAXTT ),  ( FVCOM(44), FXVERT )
  //C!w EQUIVALENCE  ( FVCOM(45), FSYMB  ),  ( FVCOM(46), PAPLIM )
  //C!w EQUIVALENCE  ( IVCOM( 1),  KLEVL ),  ( IVCOM( 2),  KEXTR )
  //C!w EQUIVALENCE  ( IVCOM( 3),    IHS ),  ( IVCOM( 4), LU7PLT )
  //C!w EQUIVALENCE  ( IVCOM( 5), IPRSRT ),  ( IVCOM( 6), LIMCOL )
  //C!w EQUIVALENCE  ( IVCOM( 7), LINEPR ),  ( IVCOM( 8),  IBAUD )
  //C!w EQUIVALENCE  ( IVCOM( 9),   LTEK ),  ( IVCOM(10), NUMTIT )
  //C!w EQUIVALENCE  ( IVCOM(11), MAXSYM ),  ( IVCOM(12),   MTIT )
  //C!w EQUIVALENCE  ( IVCOM(13), MAXISX ),  ( IVCOM(14), MAXISY )
  //C!w EQUIVALENCE  ( IVCOM(15), MGRID1 ),  ( IVCOM(16), MGRID2 )
  //C!w EQUIVALENCE  ( IVCOM(17), MSUPER ),  ( IVCOM(18),    MID )
  //C!w EQUIVALENCE  ( IVCOM(19),  MLINE ),  ( IVCOM(20),  NCUT1 )
  //C!w EQUIVALENCE  ( IVCOM(21),  NCUT2 ),  ( IVCOM(22), NSMPLT )
  //C!w EQUIVALENCE  ( IVCOM(23),  LSYMB ),  ( IVCOM(24),  NXMAX )
  //C!w EQUIVALENCE  ( IVCOM(25),  NYMAX ),  ( IVCOM(26),  LCHID )
  //C!w EQUIVALENCE  ( IVCOM(27), NXINCH ),  ( IVCOM(28), NYINCH )
  //C!w EQUIVALENCE  ( IVCOM(29),  NXOFF ),  ( IVCOM(30),  NYOFF )
  //C!w EQUIVALENCE  ( IVCOM(31),   LOOK ),  ( IVCOM(32), LCHSUP )
  //C!w EQUIVALENCE  ( IVCOM(33), LCHTIT ),  ( IVCOM(34), LCHXAX )
  //C!w EQUIVALENCE  ( IVCOM(35), LCHYAX ),  ( IVCOM(36),  ITERM )
  //C!w EQUIVALENCE  ( IVCOM(37),   LTIC ),  ( IVCOM(38),  IZTIT )
  //C!w EQUIVALENCE  ( IVCOM(39),  IZGR1 ),  ( IVCOM(40),  IZGR2 )
  //C!w EQUIVALENCE  ( IVCOM(41), LDSHG1 ),  ( IVCOM(42), LDSHG2 )
  //C!w EQUIVALENCE  ( IVCOM(43),  IZXAX ),  ( IVCOM(44),  IZYAX )
  //C!w EQUIVALENCE  ( IVCOM(45),  NXID6 ),  ( IVCOM(46),  NYID6 )
  //C!w EQUIVALENCE  ( IVCOM(47),  NXEND ),  ( IVCOM(48),  NYEND )
  //C!w EQUIVALENCE  ( IVCOM(49),   IZID ),  ( IVCOM(50), NXVERN )
  //C!w EQUIVALENCE  ( IVCOM(51), ICHREF ),  ( IVCOM(52), ICHEND )
  //C!w EQUIVALENCE  ( IVCOM(53), INCHPX ),  ( IVCOM(54), INCHPY )
  //C!w EQUIVALENCE  ( IVCOM(55), INWAIT ),  ( IVCOM(56), NOLABL )
  //C!w EQUIVALENCE  ( IVCOM(57), LCHFIL ),  ( IVCOM(58), LCHLIM )
  //C!w EQUIVALENCE  ( IVCOM(59), MU6STD )
  //C       NEXT TYPE KEY CHARACTER KEY WORDS IN COMMON, IN ORDER:          M35. 120
  //C!w EQUIVALENCE ( ANPLT( 1), CHOICE ),  ( ANPLT( 2),   STOP )
  //C!w EQUIVALENCE ( ANPLT( 3),  PURGE ),  ( ANPLT( 4),    OUT )
  //C!w EQUIVALENCE ( ANPLT( 5),   HELP ),  ( ANPLT( 6), SMOOTH )
  //C!w EQUIVALENCE ( ANPLT( 7),   SIZE ),  ( ANPLT( 8),   SHOW )
  //C!w EQUIVALENCE ( ANPLT( 9), LINEZZ ),  ( ANPLT(10),  PHOTO )
  //C!w EQUIVALENCE ( ANPLT(11), REPEAT ),  ( ANPLT(12),  FLUSH )
  //C!w EQUIVALENCE ( ANPLT(13), PLAYBA ),  ( ANPLT(14),    PEN )
  //C!w EQUIVALENCE ( ANPLT(15), MULTIP ),  ( ANPLT(16), OFFSET )
  //C!w EQUIVALENCE ( ANPLT(17), LIMITS ),  ( ANPLT(18),  DEBUG )
  //C!w EQUIVALENCE ( ANPLT(19),    TEK ),  ( ANPLT(20),  STACK )
  //C!w EQUIVALENCE ( ANPLT(21), PRINTE ),  ( ANPLT(22), METRIC )
  //C!w EQUIVALENCE ( ANPLT(23), ALLTIM ),  ( ANPLT(24), COLUMN )
  //C!w EQUIVALENCE ( ANPLT(25), SETCOL ),  ( ANPLT(26), LONGER )
  //C!w EQUIVALENCE ( ANPLT(27), AVERAG ),  ( ANPLT(28),  INNER )
  //C!w EQUIVALENCE ( ANPLT(29), RESCAL ),  ( ANPLT(30),  LASTPL)
  //C!w EQUIVALENCE ( ANPLT(31),  BATCH ),  ( ANPLT(32),  PUNCH )
  //C!w EQUIVALENCE ( ANPLT(33), EXTREM ),  ( ANPLT(34),  LEVEL )
  //C!w EQUIVALENCE ( ANPLT(35), NOPLOT ),  ( ANPLT(36), MESSAG )
  //C!w EQUIVALENCE ( ANPLT(37),    END ),  ( ANPLT(38), TIMESP )
  //C!w EQUIVALENCE ( ANPLT(39),  LABEL ),  ( ANPLT(40), TIMEUN )
  //C!w EQUIVALENCE ( ANPLT(41), CURSOR ),  ( ANPLT(42), XYPLOT )
  //C!w EQUIVALENCE ( ANPLT(43),  SLOPE ),  ( ANPLT(44),   BACK )
  //C!w EQUIVALENCE ( ANPLT(45), REFILE ),  ( ANPLT(46), TEXBLK )
  //C!w EQUIVALENCE ( ANPLT(47), SETDAT )
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void spylin(
  common& cmn) try
{
  common_write write(cmn);
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M37.7076
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M37.7077
  //C     ONE BLANK LINE IS WRITTEN ON SPY SCREEN BY THIS MODULE.           M37.7078
  //C     TEMPORARILY, UNTIL WE LEARN HOW TO WRITE TO A 2ND CRT FOR         M37.7081
  //C     VAX/VMS, WE WILL JUST WRITE TO LUNIT6 IN UNIVERSAL FORM:          M37.7082
  auto& lunit6 = cmn.lunit6;
  write(lunit6, "(1x)");
}
catch (...) { 
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void fresp1(
  common& cmn,
  str_ref ansi,
  double& d12) try
{
  common_read read(cmn);
  //C     UNIVERSAL MODULE (WORKS FOR ANY COMPUTER) USED ONLY FOR THE       M38.4600
  //C     INTERACTIVE EMTP ("EMTSPY").  IT IS CALLED TO DECODE ONE          M38.4601
  //C     FLOATING POINT NUMBERS D12 FROM CHARACTER*80 ANSI.   THIS         M38.4602
  //C     IS IDENTICAL TO "FREFP1", EXCEPT FOR SINGLE PRECISION.            M38.4603
  int n8 = 1;
  frefix(cmn, ansi, n8);
  read(ansi, "(e20.0)"), d12;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void fresp2(
  common& cmn,
  str_ref ansi,
  double& d12,
  double& d13) try
{
  common_read read(cmn);
  //C     UNIVERSAL MODULE (WORKS FOR ANY COMPUTER) USED ONLY FOR THE       M38.4612
  //C     INTERACTIVE EMTP ("EMTSPY").  IT IS CALLED TO DECODE TWO          M38.4613
  //C     FLOATING POINT NUMBERS D12 AND D13 FROM CHARACTER*80 ANSI.        M38.4614
  //C     THIS IS IDENTICAL TO "FREFP2", EXCEPT FOR SINGLE PRECISION.       M38.4615
  int n8 = 2;
  frefix(cmn, ansi, n8);
  read(ansi, "(2e20.0)"), d12, d13;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct setrtm_save
{
  fem::str<8> alltim;
  fem::str<8> averag;
  fem::str<8> back;
  fem::str<8> batch;
  arr<double> buslst;
  fem::str<8> char20;
  fem::str<8> choice;
  fem::str<8> column;
  fem::str<8> cursor;
  double d1;
  double d6;
  fem::str<8> debug;
  fem::str<8> end;
  fem::str<8> extrem;
  arr<fem::str<1> > filbyt;
  fem::str<30> file30;
  arr<double> fkar1;
  arr<double> fkar2;
  fem::str<8> flush;
  arr<double> forbyt;
  fem::str<8> help;
  arr<int> ibrnch;
  arr<int> ibsout;
  fem::str<8> inner;
  int ip;
  int j;
  arr<int> jbrnch;
  int jj;
  fem::str<8> label;
  fem::str<8> lastpl;
  fem::str<8> level;
  fem::str<8> limits;
  fem::str<8> linezz;
  fem::str<8> longer;
  int lunt15;
  fem::str<8> messag;
  fem::str<8> metric;
  fem::str<8> multip;
  int n1;
  int n2;
  int n22;
  int n23;
  fem::str<8> noplot;
  fem::str<8> offset;
  fem::str<8> out;
  fem::str<8> pen;
  fem::str<8> photo;
  fem::str<8> playba;
  arr<double> pltbuf;
  fem::str<8> printe;
  fem::str<8> punch;
  fem::str<8> purge;
  fem::str<8> refile;
  fem::str<8> repeat;
  fem::str<8> rescal;
  fem::str<8> setcol;
  fem::str<8> setdat;
  fem::str<8> show;
  fem::str<8> size;
  fem::str<8> slope;
  fem::str<8> smooth;
  fem::str<8> stack;
  fem::str<8> stop;
  fem::str<8> tek;
  fem::str<8> texblk;
  fem::str<8> timesp;
  fem::str<8> timeun;
  fem::str<8> xyplot;

  setrtm_save() :
    alltim(fem::char0),
    averag(fem::char0),
    back(fem::char0),
    batch(fem::char0),
    buslst(dimension(1), fem::fill0),
    char20(fem::char0),
    choice(fem::char0),
    column(fem::char0),
    cursor(fem::char0),
    d1(fem::double0),
    d6(fem::double0),
    debug(fem::char0),
    end(fem::char0),
    extrem(fem::char0),
    filbyt(dimension(1), fem::fill0),
    file30(fem::char0),
    fkar1(dimension(1), fem::fill0),
    fkar2(dimension(1), fem::fill0),
    flush(fem::char0),
    forbyt(dimension(600), fem::fill0),
    help(fem::char0),
    ibrnch(dimension(1), fem::fill0),
    ibsout(dimension(1), fem::fill0),
    inner(fem::char0),
    ip(fem::int0),
    j(fem::int0),
    jbrnch(dimension(1), fem::fill0),
    jj(fem::int0),
    label(fem::char0),
    lastpl(fem::char0),
    level(fem::char0),
    limits(fem::char0),
    linezz(fem::char0),
    longer(fem::char0),
    lunt15(fem::int0),
    messag(fem::char0),
    metric(fem::char0),
    multip(fem::char0),
    n1(fem::int0),
    n2(fem::int0),
    n22(fem::int0),
    n23(fem::int0),
    noplot(fem::char0),
    offset(fem::char0),
    out(fem::char0),
    pen(fem::char0),
    photo(fem::char0),
    playba(fem::char0),
    pltbuf(dimension(1), fem::fill0),
    printe(fem::char0),
    punch(fem::char0),
    purge(fem::char0),
    refile(fem::char0),
    repeat(fem::char0),
    rescal(fem::char0),
    setcol(fem::char0),
    setdat(fem::char0),
    show(fem::char0),
    size(fem::char0),
    slope(fem::char0),
    smooth(fem::char0),
    stack(fem::char0),
    stop(fem::char0),
    tek(fem::char0),
    texblk(fem::char0),
    timesp(fem::char0),
    timeun(fem::char0),
    xyplot(fem::char0)
  {}
};

void setrtm(
  common& cmn) try
{
  FEM_CMN_SVE(setrtm);
  common_read read(cmn);
  common_write write(cmn);
  int& iprspy = cmn.iprspy;
  fem::str<80>& prom80 = cmn.prom80;
  fem::str<132>& munit6 = cmn.munit6;
  auto& fvcom = cmn.fvcom;
  auto& ivcom = cmn.ivcom;
  fem::str<8>& ansi = cmn.ansi;
  fem::str<80>& buffin = cmn.buffin;
  fem::str<8>& textd1 = cmn.textd1;
  auto& anplt = cmn.anplt;
  //
  double& d1 = sve.d1;
  double& d6 = sve.d6;
  int& ip = sve.ip;
  int& j = sve.j;
  int& jj = sve.jj;
  int& lunt15 = sve.lunt15;
  int& n1 = sve.n1;
  int& n2 = sve.n2;
  int& n22 = sve.n22;
  int& n23 = sve.n23;
  fem::str<8>& setdat = sve.setdat;
  static const char* format_5100 = "(a80)";
  //C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.7399
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.7400
  lunt15 = 15;
  cmn.io.close(lunt15);
  cmn.io.open(lunt15, "TPPARAM")
    .status("OLD");
  if (iprspy < 1) {
    goto statement_2719;
  }
  write(munit6, "(' AFTER UNIT LUNT15 CONNECTION TPPARAM.')");
  window(cmn);
  statement_2719:
  n22 = 0;
  n23 = 0;
  cmn.io.rewind(lunt15);
  try {
    read(lunt15, format_5100), buffin;
  }
  catch (fem::read_end const&) {
    goto statement_2729;
  }
  cmn.io.rewind(lunt15);
  if (buffin(1, 8) != setdat) {
    goto statement_2732;
  }
  write(prom80, "('  SEND SUBSET NUMBER :')");
  prompt(cmn);
  read(cmn.munit5, format_5100), prom80;
  frein1(cmn, prom80, n1);
  if (n1 == 0) {
    n1 = 1;
  }
  FEM_DO_SAFE(j, 1, 9999) {
    try {
      read(lunt15, "(a16)"), buffin;
    }
    catch (fem::read_end const&) {
      goto statement_2729;
    }
    if (buffin(1, 8) != setdat) {
      goto statement_2728;
    }
    write(ansi, format_5100), buffin(9, 16);
    read(ansi, "(i2)"), n2;
    if (n2 == n1) {
      goto statement_2732;
    }
    statement_2728:;
  }
  statement_2729:
  write(munit6,
    "(' ** ERROR.   SUBSET NUMBER',i4,'  DOES NOT EXIST.   TRY AGAIN.')"),
    n1;
  window(cmn);
  goto statement_2751;
  statement_2732:
  read(lunt15, format_5100), prom80;
  fresp2(cmn, prom80, d6, d1);
  jj = d6;
  if (jj == 0) {
    goto statement_2741;
  }
  if (jj > n23) {
    n23 = jj;
  }
  if (iprspy < 5) {
    goto statement_2736;
  }
  write(munit6, "(' NEXT REAL DATUM.  JJ, FVCOM, D1 =',i6,2e14.5)"),
    jj, fvcom(jj), d1;
  window(cmn);
  statement_2736:
  fvcom(jj) = d1;
  goto statement_2732;
  statement_2741:
  read(lunt15, format_5100), prom80;
  frein2(cmn, prom80, jj, n1);
  if (jj == 0) {
    goto statement_2745;
  }
  if (jj > n22) {
    n22 = jj;
  }
  if (iprspy < 5) {
    goto statement_2744;
  }
  write(munit6, "(' NEXT INTEGER DATUM.  JJ, IVCOM, N1 =',3i8)"), jj,
    ivcom(jj), n1;
  window(cmn);
  statement_2744:
  ivcom(jj) = n1;
  goto statement_2741;
  statement_2745:
  read(lunt15, "(i2,a8)"), jj, textd1;
  if (jj <= 0) {
    goto statement_2751;
  }
  if (iprspy < 5) {
    goto statement_2748;
  }
  write(munit6, "(' NEXT KEY WORD.  J =',i3,1x,a8,1x,a8)"), jj, anplt(jj),
    textd1;
  window(cmn);
  statement_2748:
  anplt(jj) = textd1;
  goto statement_2745;
  statement_2751:
  if (iprspy < 3) {
    goto statement_2763;
  }
  write(munit6,
    "(' FINAL REAL DATA FVCOM THROUGH THE LAST',"
    "' MODIFIED CELL FOLLOWS ....')");
  window(cmn);
  FEM_DOSTEP(j, 1, n23, 6) {
    {
      write_loop wloop(munit6, "(1x,6e13.4)");
      FEM_DO_SAFE(ip, j, j + 5) {
        wloop, fvcom(ip);
      }
    }
    window(cmn);
  }
  write(munit6,
    "(' FINAL INTEGER DATA IVCOM THROUGH THE LAST',"
    "' MODIFIED CELL FOLLOWS ....')");
  window(cmn);
  FEM_DOSTEP(j, 1, n22, 10) {
    {
      write_loop wloop(munit6, "(1x,10i7)");
      FEM_DO_SAFE(ip, j, j + 9) {
        wloop, ivcom(ip);
      }
    }
    window(cmn);
  }
  statement_2763:
  cmn.io.close(lunt15)
    .status("KEEP");
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
  //C     USAGE IS RESTRICTED TO "PLOT" FUNCTION OF "EMTSPY", DUE           M35.  37
  //C     TO VARIABLE-LENGTH CONFLICT (THIS IS SINGLE-PRECISION).           M35.  38
  //C!w nc -> ncz, numnvo -> numnvz, numout -> numouz, nv -> nvz
  //C     EVNBYT PUTS BUSLST ON REAL*8 BYTE BOUNDARY (IBM LEVEL 4 ERROR):   M39.  44
  //C!w EQUIVALENCE  ( EV(   1), BUSLST(1) ),  ( EV(1001), IBSOUT(1) )
  //C!w EQUIVALENCE  ( EV(1301), IBRNCH(1) ),  ( EV(1601), JBRNCH(1) )
  //C!w EQUIVALENCE  ( FVCOM( 1),   VMIN ),  ( FVCOM( 2),   VMAX )
  //C!w EQUIVALENCE  ( FVCOM( 3),   HMIN ),  ( FVCOM( 4),   HMAX )
  //C!w EQUIVALENCE  ( FVCOM( 5),     HA ),  ( FVCOM( 6), TAXISL )
  //C!w EQUIVALENCE  ( FVCOM( 7), TOLRCE ),  ( FVCOM( 8),   HTAX )
  //C!w EQUIVALENCE  ( FVCOM( 9),   XTIT ),  ( FVCOM(10),   YTIT )
  //C!w EQUIVALENCE  ( FVCOM(11), SIZTIT ),  ( FVCOM(12), XSUPER )
  //C!w EQUIVALENCE  ( FVCOM(13), YSUPER ),  ( FVCOM(14), SIZSUP )
  //C!w EQUIVALENCE  ( FVCOM(15),  FLINE ),  ( FVCOM(16),  SIZID )
  //C!w EQUIVALENCE  ( FVCOM(17),    XID ),  ( FVCOM(18),    YID )
  //C!w EQUIVALENCE  ( FVCOM(19),   FACT ),  ( FVCOM(20), DXGRD1 )
  //C!w EQUIVALENCE  ( FVCOM(21), DYGRD1 ),  ( FVCOM(22), DXGRD2 )
  //C!w EQUIVALENCE  ( FVCOM(23), DYGRD2 ),  ( FVCOM(24),  FILL1 )
  //C!w EQUIVALENCE  ( FVCOM(25),  FILL2 ),  ( FVCOM(26),     VS )
  //C!w EQUIVALENCE  ( FVCOM(27),     VL ),  ( FVCOM(28),     VH )
  //C!w EQUIVALENCE  ( FVCOM(29), PAPMAX ),  ( FVCOM(30), TIMBEG )
  //C!w EQUIVALENCE  ( FVCOM(31), TIMEND ),  ( FVCOM(32), FHTAX  )
  //C!w EQUIVALENCE  ( FVCOM(33), FXSUP  ),  ( FVCOM(34), FYSUP  )
  //C!w EQUIVALENCE  ( FVCOM(35), FXTIT  ),  ( FVCOM(36), FYTIT  )
  //C!w EQUIVALENCE  ( FVCOM(37), FXID   ),  ( FVCOM(38), FYID   )
  //C!w EQUIVALENCE  ( FVCOM(39), FTCARR ),  ( FVCOM(40), VAXISL )
  //C!w EQUIVALENCE  ( FVCOM(41), FXNUMV ),  ( FVCOM(42), FXNUMH )
  //C!w EQUIVALENCE  ( FVCOM(43), FVAXTT ),  ( FVCOM(44), FXVERT )
  //C!w EQUIVALENCE  ( FVCOM(45), FSYMB  ),  ( FVCOM(46), PAPLIM )
  //C!w EQUIVALENCE  ( IVCOM( 1),  KLEVL ),  ( IVCOM( 2),  KEXTR )
  //C!w EQUIVALENCE  ( IVCOM( 3),    IHS ),  ( IVCOM( 4), LU7PLT )
  //C!w EQUIVALENCE  ( IVCOM( 5), IPRSRT ),  ( IVCOM( 6), LIMCOL )
  //C!w EQUIVALENCE  ( IVCOM( 7), LINEPR ),  ( IVCOM( 8),  IBAUD )
  //C!w EQUIVALENCE  ( IVCOM( 9),   LTEK ),  ( IVCOM(10), NUMTIT )
  //C!w EQUIVALENCE  ( IVCOM(11), MAXSYM ),  ( IVCOM(12),   MTIT )
  //C!w EQUIVALENCE  ( IVCOM(13), MAXISX ),  ( IVCOM(14), MAXISY )
  //C!w EQUIVALENCE  ( IVCOM(15), MGRID1 ),  ( IVCOM(16), MGRID2 )
  //C!w EQUIVALENCE  ( IVCOM(17), MSUPER ),  ( IVCOM(18),    MID )
  //C!w EQUIVALENCE  ( IVCOM(19),  MLINE ),  ( IVCOM(20),  NCUT1 )
  //C!w EQUIVALENCE  ( IVCOM(21),  NCUT2 ),  ( IVCOM(22), NSMPLT )
  //C!w EQUIVALENCE  ( IVCOM(23),  LSYMB ),  ( IVCOM(24),  NXMAX )
  //C!w EQUIVALENCE  ( IVCOM(25),  NYMAX ),  ( IVCOM(26),  LCHID )
  //C!w EQUIVALENCE  ( IVCOM(27), NXINCH ),  ( IVCOM(28), NYINCH )
  //C!w EQUIVALENCE  ( IVCOM(29),  NXOFF ),  ( IVCOM(30),  NYOFF )
  //C!w EQUIVALENCE  ( IVCOM(31),   LOOK ),  ( IVCOM(32), LCHSUP )
  //C!w EQUIVALENCE  ( IVCOM(33), LCHTIT ),  ( IVCOM(34), LCHXAX )
  //C!w EQUIVALENCE  ( IVCOM(35), LCHYAX ),  ( IVCOM(36),  ITERM )
  //C!w EQUIVALENCE  ( IVCOM(37),   LTIC ),  ( IVCOM(38),  IZTIT )
  //C!w EQUIVALENCE  ( IVCOM(39),  IZGR1 ),  ( IVCOM(40),  IZGR2 )
  //C!w EQUIVALENCE  ( IVCOM(41), LDSHG1 ),  ( IVCOM(42), LDSHG2 )
  //C!w EQUIVALENCE  ( IVCOM(43),  IZXAX ),  ( IVCOM(44),  IZYAX )
  //C!w EQUIVALENCE  ( IVCOM(45),  NXID6 ),  ( IVCOM(46),  NYID6 )
  //C!w EQUIVALENCE  ( IVCOM(47),  NXEND ),  ( IVCOM(48),  NYEND )
  //C!w EQUIVALENCE  ( IVCOM(49),   IZID ),  ( IVCOM(50), NXVERN )
  //C!w EQUIVALENCE  ( IVCOM(51), ICHREF ),  ( IVCOM(52), ICHEND )
  //C!w EQUIVALENCE  ( IVCOM(53), INCHPX ),  ( IVCOM(54), INCHPY )
  //C!w EQUIVALENCE  ( IVCOM(55), INWAIT ),  ( IVCOM(56), NOLABL )
  //C!w EQUIVALENCE  ( IVCOM(57), LCHFIL ),  ( IVCOM(58), LCHLIM )
  //C!w EQUIVALENCE  ( IVCOM(59), MU6STD )
  //C       NEXT TYPE KEY CHARACTER KEY WORDS IN COMMON, IN ORDER:          M35. 120
  //C!w EQUIVALENCE ( ANPLT( 1), CHOICE ),  ( ANPLT( 2),   STOP )
  //C!w EQUIVALENCE ( ANPLT( 3),  PURGE ),  ( ANPLT( 4),    OUT )
  //C!w EQUIVALENCE ( ANPLT( 5),   HELP ),  ( ANPLT( 6), SMOOTH )
  //C!w EQUIVALENCE ( ANPLT( 7),   SIZE ),  ( ANPLT( 8),   SHOW )
  //C!w EQUIVALENCE ( ANPLT( 9), LINEZZ ),  ( ANPLT(10),  PHOTO )
  //C!w EQUIVALENCE ( ANPLT(11), REPEAT ),  ( ANPLT(12),  FLUSH )
  //C!w EQUIVALENCE ( ANPLT(13), PLAYBA ),  ( ANPLT(14),    PEN )
  //C!w EQUIVALENCE ( ANPLT(15), MULTIP ),  ( ANPLT(16), OFFSET )
  //C!w EQUIVALENCE ( ANPLT(17), LIMITS ),  ( ANPLT(18),  DEBUG )
  //C!w EQUIVALENCE ( ANPLT(19),    TEK ),  ( ANPLT(20),  STACK )
  //C!w EQUIVALENCE ( ANPLT(21), PRINTE ),  ( ANPLT(22), METRIC )
  //C!w EQUIVALENCE ( ANPLT(23), ALLTIM ),  ( ANPLT(24), COLUMN )
  //C!w EQUIVALENCE ( ANPLT(25), SETCOL ),  ( ANPLT(26), LONGER )
  //C!w EQUIVALENCE ( ANPLT(27), AVERAG ),  ( ANPLT(28),  INNER )
  //C!w EQUIVALENCE ( ANPLT(29), RESCAL ),  ( ANPLT(30),  LASTPL)
  //C!w EQUIVALENCE ( ANPLT(31),  BATCH ),  ( ANPLT(32),  PUNCH )
  //C!w EQUIVALENCE ( ANPLT(33), EXTREM ),  ( ANPLT(34),  LEVEL )
  //C!w EQUIVALENCE ( ANPLT(35), NOPLOT ),  ( ANPLT(36), MESSAG )
  //C!w EQUIVALENCE ( ANPLT(37),    END ),  ( ANPLT(38), TIMESP )
  //C!w EQUIVALENCE ( ANPLT(39),  LABEL ),  ( ANPLT(40), TIMEUN )
  //C!w EQUIVALENCE ( ANPLT(41), CURSOR ),  ( ANPLT(42), XYPLOT )
  //C!w EQUIVALENCE ( ANPLT(43),  SLOPE ),  ( ANPLT(44),   BACK )
  //C!w EQUIVALENCE ( ANPLT(45), REFILE ),  ( ANPLT(46), TEXBLK )
  //C!w EQUIVALENCE ( ANPLT(47), SETDAT )
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct chrplt_save
{
  fem::str<8> alltim;
  fem::str<8> averag;
  fem::str<8> back;
  fem::str<8> batch;
  arr<double> buslst;
  fem::str<8> char20;
  fem::str<8> choice;
  fem::str<8> column;
  fem::str<8> cursor;
  double d1;
  double d2;
  double d3;
  fem::str<8> debug;
  double din1;
  double din2;
  arr<fem::str<1> > dol;
  double dt;
  fem::str<8> end;
  fem::str<8> extrem;
  arr<fem::str<1> > filbyt;
  fem::str<30> file30;
  arr<double> fkar1;
  arr<double> fkar2;
  fem::str<8> flush;
  arr<double> forbyt;
  fem::str<8> help;
  double hmax;
  double hmin;
  arr<int> ibrnch;
  arr<int> ibsout;
  int idat;
  int inch;
  fem::str<8> inner;
  int ip;
  int j;
  int j1;
  arr<int> jbrnch;
  int k;
  fem::str<9> kunit6;
  int kwtspy;
  int kzero;
  int L;
  fem::str<8> label;
  fem::str<8> lastpl;
  arr<fem::str<1> > letter;
  fem::str<8> level;
  int limcol;
  fem::str<8> limits;
  int linepr;
  fem::str<8> linezz;
  fem::str<8> longer;
  int m;
  fem::str<8> messag;
  fem::str<8> metric;
  int mu6std;
  fem::str<8> multip;
  int n4;
  fem::str<8> noplot;
  int numtit;
  fem::str<8> offset;
  fem::str<8> out;
  fem::str<8> pen;
  fem::str<8> photo;
  fem::str<8> playba;
  arr<double> pltbuf;
  fem::str<8> printe;
  fem::str<8> punch;
  fem::str<8> purge;
  fem::str<8> refile;
  fem::str<8> repeat;
  fem::str<8> rescal;
  fem::str<8> setcol;
  fem::str<8> setdat;
  fem::str<8> show;
  fem::str<8> size;
  fem::str<8> slope;
  fem::str<8> smooth;
  fem::str<8> stack;
  fem::str<8> stop;
  double t;
  fem::str<8> tek;
  arr<double> temp;
  fem::str<8> texblk;
  fem::str<8> timesp;
  fem::str<8> timeun;
  double vmax;
  double vmin;
  double vspan;
  fem::str<8> xyplot;

  chrplt_save() :
    alltim(fem::char0),
    averag(fem::char0),
    back(fem::char0),
    batch(fem::char0),
    buslst(dimension(1), fem::fill0),
    char20(fem::char0),
    choice(fem::char0),
    column(fem::char0),
    cursor(fem::char0),
    d1(fem::double0),
    d2(fem::double0),
    d3(fem::double0),
    debug(fem::char0),
    din1(fem::double0),
    din2(fem::double0),
    dol(dimension(131), fem::fill0),
    dt(fem::double0),
    end(fem::char0),
    extrem(fem::char0),
    filbyt(dimension(1), fem::fill0),
    file30(fem::char0),
    fkar1(dimension(1), fem::fill0),
    fkar2(dimension(1), fem::fill0),
    flush(fem::char0),
    forbyt(dimension(600), fem::fill0),
    help(fem::char0),
    hmax(fem::double0),
    hmin(fem::double0),
    ibrnch(dimension(1), fem::fill0),
    ibsout(dimension(1), fem::fill0),
    idat(fem::int0),
    inch(fem::int0),
    inner(fem::char0),
    ip(fem::int0),
    j(fem::int0),
    j1(fem::int0),
    jbrnch(dimension(1), fem::fill0),
    k(fem::int0),
    kunit6(fem::char0),
    kwtspy(fem::int0),
    kzero(fem::int0),
    L(fem::int0),
    label(fem::char0),
    lastpl(fem::char0),
    letter(dimension(20), fem::fill0),
    level(fem::char0),
    limcol(fem::int0),
    limits(fem::char0),
    linepr(fem::int0),
    linezz(fem::char0),
    longer(fem::char0),
    m(fem::int0),
    messag(fem::char0),
    metric(fem::char0),
    mu6std(fem::int0),
    multip(fem::char0),
    n4(fem::int0),
    noplot(fem::char0),
    numtit(fem::int0),
    offset(fem::char0),
    out(fem::char0),
    pen(fem::char0),
    photo(fem::char0),
    playba(fem::char0),
    pltbuf(dimension(1), fem::fill0),
    printe(fem::char0),
    punch(fem::char0),
    purge(fem::char0),
    refile(fem::char0),
    repeat(fem::char0),
    rescal(fem::char0),
    setcol(fem::char0),
    setdat(fem::char0),
    show(fem::char0),
    size(fem::char0),
    slope(fem::char0),
    smooth(fem::char0),
    stack(fem::char0),
    stop(fem::char0),
    t(fem::double0),
    tek(fem::char0),
    temp(dimension(6), fem::fill0),
    texblk(fem::char0),
    timesp(fem::char0),
    timeun(fem::char0),
    vmax(fem::double0),
    vmin(fem::double0),
    vspan(fem::double0),
    xyplot(fem::char0)
  {}
};

void chrplt(
  common& cmn) try
{
  FEM_CMN_SVE(chrplt);
  common_read read(cmn);
  common_write write(cmn);
  int& iprspy = cmn.iprspy;
  int& monits = cmn.monits;
  fem::str<8>& ansi8 = cmn.ansi8;
  fem::str<132>& munit6 = cmn.munit6;
  double& tmult = cmn.tmult;
  double& dy = cmn.dy;
  const auto& ew = cmn.ew;
  const auto& aaa = cmn.aaa;
  const auto& bbb = cmn.bbb;
  auto& kp = cmn.kp;
  const auto& mstart = cmn.mstart;
  const auto& mplot = cmn.mplot;
  int& jplt = cmn.jplt;
  int& ind1 = cmn.ind1;
  int& kptplt = cmn.kptplt;
  const auto& sext = cmn.sext;
  //
  double& d1 = sve.d1;
  double& d2 = sve.d2;
  double& d3 = sve.d3;
  str_arr_ref<1> dol(sve.dol, dimension(131));
  double& dt = sve.dt;
  double& hmax = sve.hmax;
  double& hmin = sve.hmin;
  int& idat = sve.idat;
  int& inch = sve.inch;
  int& ip = sve.ip;
  int& j = sve.j;
  int& j1 = sve.j1;
  int& k = sve.k;
  fem::str<9>& kunit6 = sve.kunit6;
  int& kwtspy = sve.kwtspy;
  int& kzero = sve.kzero;
  int& L = sve.L;
  str_arr_ref<1> letter(sve.letter, dimension(20));
  int& limcol = sve.limcol;
  int& m = sve.m;
  int& mu6std = sve.mu6std;
  int& n4 = sve.n4;
  arr_cref<double> pltbuf(sve.pltbuf, dimension(1));
  double& t = sve.t;
  arr_ref<double> temp(sve.temp, dimension(6));
  double& vmax = sve.vmax;
  double& vmin = sve.vmin;
  double& vspan = sve.vspan;
  if (is_called_first_time) {
    letter(1) = "A";
    letter(2) = "B";
    letter(3) = "C";
    letter(4) = "D";
    letter(5) = "E";
    letter(6) = "F";
    letter(7) = "G";
    letter(8) = "H";
    letter(9) = "I";
    letter(10) = "J";
    letter(11) = "K";
    letter(12) = "L";
    letter(13) = "M";
    letter(14) = "N";
    letter(15) = "O";
    letter(16) = "P";
    letter(17) = "Q";
    letter(18) = "R";
    letter(19) = "S";
    letter(20) = "T";
  }
  static const char* format_6543 = "(1x,131a1)";
  //C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.7463
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.7464
  if (monits == 1) {
    goto statement_2513;
  }
  vspan = vmax - vmin;
  d3 = limcol / vspan;
  kzero = -vmin * d3;
  if (kzero == 0) {
    kzero = 1;
  }
  if (kzero < 0) {
    kzero = 0;
  }
  kp(1) = 1;
  dy = vspan / (0.1f * limcol);
  if (cmn.mfake == jplt) {
    goto statement_6413;
  }
  write(munit6, "(' Hidden variable scalings follow :')");
  window(cmn);
  {
    write_loop wloop(munit6, "('  FACTOR :',10e11.3)");
    FEM_DO_SAFE(j, 1, jplt) {
      wloop, aaa(j);
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, "('  OFFSET :',10e11.3)");
    FEM_DO_SAFE(j, 1, jplt) {
      wloop, bbb(j);
    }
  }
  window(cmn);
  statement_6413:
  sve.din1 = hmin * tmult;
  sve.din2 = hmax * tmult;
  FEM_DO_SAFE(ip, 1, sve.numtit) {
    write(munit6, "(' Graph title : ',a80)"), sext(ip);
    window(cmn);
  }
  if (cmn.mxypl > 0) {
    goto statement_6582;
  }
  if (jplt <= 1) {
    goto statement_6447;
  }
  FEM_DO_SAFE(k, 2, jplt) {
    kp(k) = mstart(k - 1) + 5;
  }
  statement_6447:
  dt = cmn.hpi / 6.0f;
  temp(1) = vmin + dy;
  d2 = 2.0f * dy;
  n4 = 6;
  if (limcol <= 79) {
    n4 = 4;
  }
  FEM_DO_SAFE(k, 2, n4) {
    temp(k) = temp(k - 1) + d2;
  }
  {
    write_loop wloop(munit6, "(3x,6(e14.5,6x))");
    FEM_DO_SAFE(k, 1, n4) {
      wloop, temp(k);
    }
  }
  window(cmn);
  if (limcol <= 79) {
    goto statement_6453;
  }
  write(munit6,
    "(1x,'1---------1---------1---------1',"
    "'---------1---------1---------1---------1',"
    "'---------1---------1---------1---------1','---------1---------1')");
  window(cmn);
  goto statement_6456;
  statement_6453:
  write(munit6,
    "(1x,'1---------1---------1---------1---------1',"
    "'---------1---------1---------1---------1')");
  window(cmn);
  statement_6456:
  if (iprspy < 1) {
    goto statement_6460;
  }
  write(munit6,
    "(' Begin character plot.',11x,'HMIN',11x,'HMAX',13x,'DT',11x,'VMIN',11x,"
    "'VMAX')");
  window(cmn);
  write(munit6, "(22x,5e15.6)"), hmin, hmax, dt, vmin, vmax;
  window(cmn);
  statement_6460:
  inch = 0;
  idat = jplt;
  t = hmin;
  statement_6461:
  t += dt;
  inch++;
  quiter(cmn);
  if (kwtspy == 1) {
    goto statement_9000;
  }
  if (t > hmax) {
    goto statement_6582;
  }
  FEM_DO_SAFE(k, 1, limcol) {
    dol(k) = " ";
  }
  FEM_DO_SAFE(k, 1, jplt) {
    L = kp(k);
    if (iprspy != 34) {
      goto statement_6483;
    }
    write(munit6,
      "(1x,'       K       L  MSTART',10x,'EW(L)',14x,'T')"), k, L,
      mstart(k), ew(L), t;
    window(cmn);
    write(munit6, "(1x,3i8,2e15.6)"), k, L, mstart(k), ew(L), t;
    window(cmn);
    statement_6483:
    if (L == 0) {
      goto statement_6531;
    }
    statement_6485:
    if (ew(L) <= t) {
      goto statement_6493;
    }
    kp(k) = L;
    goto statement_6531;
    statement_6493:
    d1 = ew(L + 1);
    if (d1 > vmin) {
      goto statement_6503;
    }
    dol(1) = letter(k);
    goto statement_6518;
    statement_6503:
    if (d1 < vmax) {
      goto statement_6508;
    }
    dol(limcol) = letter(k);
    goto statement_6518;
    statement_6508:
    m = (d1 - vmin) * d3;
    dol(m) = letter(k);
    if (iprspy != 34) {
      goto statement_6518;
    }
    write(munit6, "(' In-bounds insert..  M, DOL(M) =',i4,1x,a1)"), m, dol(m);
    window(cmn);
    statement_6518:
    L += 2;
    if (L < mstart(k)) {
      goto statement_6485;
    }
    kp(k) = 0;
    idat = idat - 1;
    statement_6531:;
  }
  if (inch >= 6) {
    goto statement_6548;
  }
  if (kzero <= 9) {
    goto statement_6542;
  }
  if (dol(kzero) == " ") {
    dol(kzero) = "1";
  }
  statement_6542:
  {
    write_loop wloop(munit6, format_6543);
    FEM_DO_SAFE(k, 1, limcol) {
      wloop, dol(k);
    }
  }
  window(cmn);
  goto statement_6559;
  statement_6548:
  if (t <= 9.999999f) {
    write(kunit6, "(' ',f8.6)"), t;
  }
  if (t >= 10.0f) {
    write(kunit6, "(' ',f8.5)"), t;
  }
  if (kzero <= 9) {
    goto statement_6555;
  }
  if (dol(kzero) == " ") {
    dol(kzero) = "1";
  }
  statement_6555:
  {
    write_loop wloop(munit6, "(1x,a9,123a1)");
    wloop, kunit6;
    FEM_DO_SAFE(k, 10, limcol) {
      wloop, dol(k);
    }
  }
  window(cmn);
  inch = 0;
  statement_6559:
  if (idat > 0) {
    goto statement_6461;
  }
  statement_6582:
  if (mu6std == 6) {
    goto statement_2694;
  }
  mu6std = 6;
  write(munit6,
    "('   ***  Line printer copy completed on',' unit',i3,' .  ***')"),
    sve.linepr;
  window(cmn);
  statement_2694:
  if (monits == 0) {
    goto statement_9000;
  }
  if (iprspy < 1) {
    goto statement_2501;
  }
  write(munit6, "(' Begin rolling.  IND1 =',i8)"), ind1;
  window(cmn);
  statement_2501:
  t += dt;
  quiter(cmn);
  if (kwtspy == 1) {
    goto statement_9000;
  }
  inch++;
  FEM_DO_SAFE(k, 1, limcol) {
    dol(k) = " ";
  }
  statement_2507:
  if (ind1 <= cmn.indbuf - kptplt) {
    goto statement_2513;
  }
  goto statement_9000;
  statement_2513:
  if (iprspy < 3) {
    goto statement_2517;
  }
  write(munit6,
    "(' Past 1/6 inch? IND1, JPLT, PLTBUF(IND1), T =',2i7,2e15.5)"),
    ind1, jplt, pltbuf(ind1), t;
  window(cmn);
  statement_2517:
  if (pltbuf(ind1) > t) {
    goto statement_2564;
  }
  FEM_DO_SAFE(k, 1, jplt) {
    j1 = fem::iabs(mplot(k));
    d1 = pltbuf(ind1 + j1);
    if (mplot(k) < 0) {
      d1 = -d1;
    }
    if (d1 > vmin) {
      goto statement_2532;
    }
    dol(1) = letter(k);
    goto statement_2542;
    statement_2532:
    if (d1 < vmax) {
      goto statement_2537;
    }
    dol(limcol) = letter(k);
    goto statement_2542;
    statement_2537:
    m = (d1 - vmin) * d3;
    dol(m) = letter(k);
    statement_2542:;
  }
  ind1 += kptplt + 1;
  goto statement_2507;
  statement_2564:
  if (inch < 6) {
    goto statement_2571;
  }
  write(ansi8, "(1x,f7.4)"), t;
  {
    read_loop rloop(ansi8, "(8a1)");
    FEM_DO_SAFE(ip, 1, 8) {
      rloop, dol(ip);
    }
  }
  inch = 0;
  goto statement_2574;
  statement_2571:
  if (kzero == 0) {
    goto statement_2574;
  }
  if (dol(kzero) == " ") {
    dol(kzero) = "1";
  }
  statement_2574:
  {
    write_loop wloop(munit6, format_6543);
    FEM_DO_SAFE(k, 1, limcol) {
      wloop, dol(k);
    }
  }
  window(cmn);
  goto statement_2501;
  statement_9000:
  if (iprspy < 1) {
    goto statement_9008;
  }
  write(munit6, "(' Exit \"CHRPLT\".')");
  window(cmn);
  statement_9008:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
  //C     USAGE IS RESTRICTED TO "PLOT" FUNCTION OF "EMTSPY", DUE           M35.  37
  //C     TO VARIABLE-LENGTH CONFLICT (THIS IS SINGLE-PRECISION).           M35.  38
  //C!w nc -> ncz, numnvo -> numnvz, numout -> numouz, nv -> nvz
  //C     EVNBYT PUTS BUSLST ON REAL*8 BYTE BOUNDARY (IBM LEVEL 4 ERROR):   M39.  44
  //C!w EQUIVALENCE  ( EV(   1), BUSLST(1) ),  ( EV(1001), IBSOUT(1) )
  //C!w EQUIVALENCE  ( EV(1301), IBRNCH(1) ),  ( EV(1601), JBRNCH(1) )
  //C!w EQUIVALENCE  ( FVCOM( 1),   VMIN ),  ( FVCOM( 2),   VMAX )
  //C!w EQUIVALENCE  ( FVCOM( 3),   HMIN ),  ( FVCOM( 4),   HMAX )
  //C!w EQUIVALENCE  ( FVCOM( 5),     HA ),  ( FVCOM( 6), TAXISL )
  //C!w EQUIVALENCE  ( FVCOM( 7), TOLRCE ),  ( FVCOM( 8),   HTAX )
  //C!w EQUIVALENCE  ( FVCOM( 9),   XTIT ),  ( FVCOM(10),   YTIT )
  //C!w EQUIVALENCE  ( FVCOM(11), SIZTIT ),  ( FVCOM(12), XSUPER )
  //C!w EQUIVALENCE  ( FVCOM(13), YSUPER ),  ( FVCOM(14), SIZSUP )
  //C!w EQUIVALENCE  ( FVCOM(15),  FLINE ),  ( FVCOM(16),  SIZID )
  //C!w EQUIVALENCE  ( FVCOM(17),    XID ),  ( FVCOM(18),    YID )
  //C!w EQUIVALENCE  ( FVCOM(19),   FACT ),  ( FVCOM(20), DXGRD1 )
  //C!w EQUIVALENCE  ( FVCOM(21), DYGRD1 ),  ( FVCOM(22), DXGRD2 )
  //C!w EQUIVALENCE  ( FVCOM(23), DYGRD2 ),  ( FVCOM(24),  FILL1 )
  //C!w EQUIVALENCE  ( FVCOM(25),  FILL2 ),  ( FVCOM(26),     VS )
  //C!w EQUIVALENCE  ( FVCOM(27),     VL ),  ( FVCOM(28),     VH )
  //C!w EQUIVALENCE  ( FVCOM(29), PAPMAX ),  ( FVCOM(30), TIMBEG )
  //C!w EQUIVALENCE  ( FVCOM(31), TIMEND ),  ( FVCOM(32), FHTAX  )
  //C!w EQUIVALENCE  ( FVCOM(33), FXSUP  ),  ( FVCOM(34), FYSUP  )
  //C!w EQUIVALENCE  ( FVCOM(35), FXTIT  ),  ( FVCOM(36), FYTIT  )
  //C!w EQUIVALENCE  ( FVCOM(37), FXID   ),  ( FVCOM(38), FYID   )
  //C!w EQUIVALENCE  ( FVCOM(39), FTCARR ),  ( FVCOM(40), VAXISL )
  //C!w EQUIVALENCE  ( FVCOM(41), FXNUMV ),  ( FVCOM(42), FXNUMH )
  //C!w EQUIVALENCE  ( FVCOM(43), FVAXTT ),  ( FVCOM(44), FXVERT )
  //C!w EQUIVALENCE  ( FVCOM(45), FSYMB  ),  ( FVCOM(46), PAPLIM )
  //C!w EQUIVALENCE  ( IVCOM( 1),  KLEVL ),  ( IVCOM( 2),  KEXTR )
  //C!w EQUIVALENCE  ( IVCOM( 3),    IHS ),  ( IVCOM( 4), LU7PLT )
  //C!w EQUIVALENCE  ( IVCOM( 5), IPRSRT ),  ( IVCOM( 6), LIMCOL )
  //C!w EQUIVALENCE  ( IVCOM( 7), LINEPR ),  ( IVCOM( 8),  IBAUD )
  //C!w EQUIVALENCE  ( IVCOM( 9),   LTEK ),  ( IVCOM(10), NUMTIT )
  //C!w EQUIVALENCE  ( IVCOM(11), MAXSYM ),  ( IVCOM(12),   MTIT )
  //C!w EQUIVALENCE  ( IVCOM(13), MAXISX ),  ( IVCOM(14), MAXISY )
  //C!w EQUIVALENCE  ( IVCOM(15), MGRID1 ),  ( IVCOM(16), MGRID2 )
  //C!w EQUIVALENCE  ( IVCOM(17), MSUPER ),  ( IVCOM(18),    MID )
  //C!w EQUIVALENCE  ( IVCOM(19),  MLINE ),  ( IVCOM(20),  NCUT1 )
  //C!w EQUIVALENCE  ( IVCOM(21),  NCUT2 ),  ( IVCOM(22), NSMPLT )
  //C!w EQUIVALENCE  ( IVCOM(23),  LSYMB ),  ( IVCOM(24),  NXMAX )
  //C!w EQUIVALENCE  ( IVCOM(25),  NYMAX ),  ( IVCOM(26),  LCHID )
  //C!w EQUIVALENCE  ( IVCOM(27), NXINCH ),  ( IVCOM(28), NYINCH )
  //C!w EQUIVALENCE  ( IVCOM(29),  NXOFF ),  ( IVCOM(30),  NYOFF )
  //C!w EQUIVALENCE  ( IVCOM(31),   LOOK ),  ( IVCOM(32), LCHSUP )
  //C!w EQUIVALENCE  ( IVCOM(33), LCHTIT ),  ( IVCOM(34), LCHXAX )
  //C!w EQUIVALENCE  ( IVCOM(35), LCHYAX ),  ( IVCOM(36),  ITERM )
  //C!w EQUIVALENCE  ( IVCOM(37),   LTIC ),  ( IVCOM(38),  IZTIT )
  //C!w EQUIVALENCE  ( IVCOM(39),  IZGR1 ),  ( IVCOM(40),  IZGR2 )
  //C!w EQUIVALENCE  ( IVCOM(41), LDSHG1 ),  ( IVCOM(42), LDSHG2 )
  //C!w EQUIVALENCE  ( IVCOM(43),  IZXAX ),  ( IVCOM(44),  IZYAX )
  //C!w EQUIVALENCE  ( IVCOM(45),  NXID6 ),  ( IVCOM(46),  NYID6 )
  //C!w EQUIVALENCE  ( IVCOM(47),  NXEND ),  ( IVCOM(48),  NYEND )
  //C!w EQUIVALENCE  ( IVCOM(49),   IZID ),  ( IVCOM(50), NXVERN )
  //C!w EQUIVALENCE  ( IVCOM(51), ICHREF ),  ( IVCOM(52), ICHEND )
  //C!w EQUIVALENCE  ( IVCOM(53), INCHPX ),  ( IVCOM(54), INCHPY )
  //C!w EQUIVALENCE  ( IVCOM(55), INWAIT ),  ( IVCOM(56), NOLABL )
  //C!w EQUIVALENCE  ( IVCOM(57), LCHFIL ),  ( IVCOM(58), LCHLIM )
  //C!w EQUIVALENCE  ( IVCOM(59), MU6STD )
  //C       NEXT TYPE KEY CHARACTER KEY WORDS IN COMMON, IN ORDER:          M35. 120
  //C!w EQUIVALENCE ( ANPLT( 1), CHOICE ),  ( ANPLT( 2),   STOP )
  //C!w EQUIVALENCE ( ANPLT( 3),  PURGE ),  ( ANPLT( 4),    OUT )
  //C!w EQUIVALENCE ( ANPLT( 5),   HELP ),  ( ANPLT( 6), SMOOTH )
  //C!w EQUIVALENCE ( ANPLT( 7),   SIZE ),  ( ANPLT( 8),   SHOW )
  //C!w EQUIVALENCE ( ANPLT( 9), LINEZZ ),  ( ANPLT(10),  PHOTO )
  //C!w EQUIVALENCE ( ANPLT(11), REPEAT ),  ( ANPLT(12),  FLUSH )
  //C!w EQUIVALENCE ( ANPLT(13), PLAYBA ),  ( ANPLT(14),    PEN )
  //C!w EQUIVALENCE ( ANPLT(15), MULTIP ),  ( ANPLT(16), OFFSET )
  //C!w EQUIVALENCE ( ANPLT(17), LIMITS ),  ( ANPLT(18),  DEBUG )
  //C!w EQUIVALENCE ( ANPLT(19),    TEK ),  ( ANPLT(20),  STACK )
  //C!w EQUIVALENCE ( ANPLT(21), PRINTE ),  ( ANPLT(22), METRIC )
  //C!w EQUIVALENCE ( ANPLT(23), ALLTIM ),  ( ANPLT(24), COLUMN )
  //C!w EQUIVALENCE ( ANPLT(25), SETCOL ),  ( ANPLT(26), LONGER )
  //C!w EQUIVALENCE ( ANPLT(27), AVERAG ),  ( ANPLT(28),  INNER )
  //C!w EQUIVALENCE ( ANPLT(29), RESCAL ),  ( ANPLT(30),  LASTPL)
  //C!w EQUIVALENCE ( ANPLT(31),  BATCH ),  ( ANPLT(32),  PUNCH )
  //C!w EQUIVALENCE ( ANPLT(33), EXTREM ),  ( ANPLT(34),  LEVEL )
  //C!w EQUIVALENCE ( ANPLT(35), NOPLOT ),  ( ANPLT(36), MESSAG )
  //C!w EQUIVALENCE ( ANPLT(37),    END ),  ( ANPLT(38), TIMESP )
  //C!w EQUIVALENCE ( ANPLT(39),  LABEL ),  ( ANPLT(40), TIMEUN )
  //C!w EQUIVALENCE ( ANPLT(41), CURSOR ),  ( ANPLT(42), XYPLOT )
  //C!w EQUIVALENCE ( ANPLT(43),  SLOPE ),  ( ANPLT(44),   BACK )
  //C!w EQUIVALENCE ( ANPLT(45), REFILE ),  ( ANPLT(46), TEXBLK )
  //C!w EQUIVALENCE ( ANPLT(47), SETDAT )
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void tekplt()
{
}

void timval(
  common& cmn) try
{
  common_read read(cmn);
  common_write write(cmn);
  int& munit5 = cmn.munit5;
  int& indbuf = cmn.indbuf;
  int& newvec = cmn.newvec;
  int& iprspy = cmn.iprspy;
  int& monitr = cmn.monitr;
  int& monits = cmn.monits;
  int& nexmod = cmn.nexmod;
  int& inchlp = cmn.inchlp;
  fem::str<80>& buff77 = cmn.buff77;
  fem::str<80>& prom80 = cmn.prom80;
  fem::str<132>& munit6 = cmn.munit6;
  double& tmult = cmn.tmult;
  double& dy = cmn.dy;
  double& dx = cmn.dx;
  double& hpi = cmn.hpi;
  double& tstep = static_cast<common_cblock&>(cmn).tstep;
  double& gxmin = cmn.gxmin;
  double& gxmax = cmn.gxmax;
  auto& ew = cmn.ew;
  double& finfin = cmn.finfin;
 auto& yymin = cmn.yymin;
  auto& yymax = cmn.yymax;
  auto& ttmin = cmn.ttmin;
  auto& ttmax = cmn.ttmax;
  auto& ylevel = cmn.ylevel;
  auto& ttlev= cmn.ttlev;
  auto& dyold= cmn.dyold;
  auto& mlevel = cmn.mlevel;
  auto& aaa = cmn.aaa;
  auto& bbb = cmn.bbb;
  auto& ev = cmn.ev;
  auto& bx = cmn.bx;
  double& vminr = cmn.vminr;
  double& vmaxr = cmn.vmaxr;
  auto& mmm = cmn.mmm;
  auto& mstart = cmn.mstart;
  auto& numpts = cmn.numpts;
  const auto& mplot = cmn.mplot;
  int& jplt = cmn.jplt;
  int& icurse = cmn.icurse;
  int& mxypl = cmn.mxypl;
  int& indexp = cmn.indexp;
  int& ind1 = cmn.ind1;
  int& mfake = cmn.mfake;
  int& kptplt = cmn.kptplt;
  int& jplt1 = cmn.jplt1;
  int& limfix = cmn.limfix;
  int& maxew = cmn.maxew;
  fem::str<80>& buffin = cmn.buffin;
  const auto& slot1 = cmn.slot1;
  fem::str<8>& textd1 = cmn.textd1;
  fem::str<8>& textd2 = cmn.textd2;
  fem::str<24>& xytitl = cmn.xytitl;
  //
  int maxevk = fem::int0;
  double vmin = fem::double0;
  double vmax = fem::double0;
  int n16 = fem::int0;
  int i = fem::int0;
  fem::str<8> setdat = fem::char0;
  double d3 = fem::double0;
  int n4 = fem::int0;
  arr_1d<1, double> pltbuf(fem::fill0);
  double din2 = fem::double0;
  double din1 = fem::double0;
  double spsave = fem::double0;
  fem::str<8> xyplot = fem::char0;
  fem::str<8> texblk = fem::char0;
  fem::str<8> cursor = fem::char0;
  fem::str<8> debug = fem::char0;
  fem::str<8> extrem = fem::char0;
  int kextr = fem::int0;
  fem::str<8> level = fem::char0;
  int klevl = fem::int0;
  int j = fem::int0;
  int ltek = fem::int0;
  fem::str<8> stop = fem::char0;
  int kill = fem::int0;
  fem::str<8> smooth = fem::char0;
  double tolrce = fem::double0;
  fem::str<8> size = fem::char0;
  double taxisl = fem::double0;
  double d1 = fem::double0;
  fem::str<8> show = fem::char0;
  int limcol = fem::int0;
  int n1 = fem::int0;
  int linepr = fem::int0;
  int lu7plt = fem::int0;
  int ihs = fem::int0;
  int ibaud = fem::int0;
  int nxmax = fem::int0;
  fem::str<8> help = fem::char0;
  int numnvo = fem::int0;
  fem::str<8> out = fem::char0;
  fem::str<8> multip = fem::char0;
  fem::str<8> offset = fem::char0;
  fem::str<8> limits = fem::char0;
  fem::str<8> averag = fem::char0;
  int nsmplt = fem::int0;
  fem::str<8> rescal = fem::char0;
  double hmin = fem::double0;
  double hmax = fem::double0;
  double d6 = fem::double0;
  double d7 = fem::double0;
  int kplt = fem::int0;
  fem::str<8> inner = fem::char0;
  fem::str<8> alltim = fem::char0;
  double timbeg = fem::double0;
  double timend = fem::double0;
  double vh = fem::double0;
  double vs = fem::double0;
  double vl = fem::double0;
  int j1 = fem::int0;
  int ip = fem::int0;
  int k = fem::int0;
  int n7 = fem::int0;
  int n8 = fem::int0;
  double gymin = fem::double0;
  double gymax = fem::double0;
  int kk = fem::int0;
  double d2 = fem::double0;
  double d4 = fem::double0;
  int L = fem::int0;
  double evmx = fem::double0;
  int k9 = fem::int0;
  double evh = fem::double0;
  double evdh = fem::double0;
  int isw = fem::int0;
  int itimes = fem::int0;
  int ipj = fem::int0;
  double evp = fem::double0;
  double evdp = fem::double0;
  int isww = fem::int0;
  double a = fem::double0;
  double evmxf = fem::double0;
  int ipl = fem::int0;
  int kpltq = fem::int0;
  int istore = fem::int0;
  int istold = fem::int0;
  int ibase = fem::int0;
  int num = fem::int0;
  int n13 = fem::int0;
  double vold = fem::double0;
  double evbasx = fem::double0;
  double evbasy = fem::double0;
  double hvec = fem::double0;
  double vvec = fem::double0;
  double denom = fem::double0;
  int ipontr = fem::int0;
  double hdif = fem::double0;
  double vnew = fem::double0;
  double vdif = fem::double0;
  double disqr = fem::double0;
  double vchnge = fem::double0;
  int n5 = fem::int0;
  int kl = fem::int0;
  fem::str<8> linezz = fem::char0;
  int mu6std = fem::int0;
  fem::str<8> noplot = fem::char0;
  int iprsup = fem::int0;
  static const char* format_1956 = "(1x)";
  static const char* format_1959 = "(10e8.0)";
  static const char* format_3303 = "(' ')";
  static const char* format_3317 = "(1x,7e10.2)";
  static const char* format_3374 = "(1x,10e13.4)";
  //C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.6856
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.6857
  maxevk = cmn.maxev - 30;
  if (iprspy < 1) {
    goto statement_1549;
  }
  write(munit6,
    "(' Begin  \"TIMVAL\".  MONITR, LIMFIX =',2i6,'    VMIN, VMAX =',2e13.4)"),
    monitr, limfix, vmin, vmax;
  window(cmn);
  n16 = jplt;
  if (n16 > 20) {
    n16 = 20;
  }
  {
    write_loop wloop(munit6, "(' MPLOT:',20i6)");
    FEM_DO_SAFE(i, 1, n16) {
      wloop, mplot(i);
    }
  }
  window(cmn);
  statement_1549:
  if (nexmod != 6) {
    goto statement_31549;
  }
  nexmod = 0;
  //C!GO TO NEXTSN
  statement_31549:
  if (monitr == 8765) {
    goto statement_1926;
  }
  statement_1550:
  write(prom80, "(' --- INNER :')");
  FEM_THROW_UNHANDLED("executable assign: assign1556tonextsn");
  goto statement_9800;
  buffin = buff77;
  //C     IF ( BUFFIN(1:4) .EQ. 'SPY ' ) GO TO 9835   ! EXIT MODULE         M38.4767
  if (buffin(1, 8) != setdat) {
    goto statement_2713;
  }
  setrtm(cmn);
  goto statement_1550;
  statement_2713:
  if (buffin(1, 8) != "ROLLV   ") {
    goto statement_2715;
  }
  monitr++;
  if (monitr >= 2) {
    monitr = 0;
  }
  if (monitr != 0) {
    write(munit6,
      "('            ===  Begin  ROLLing  of',' vector-graphic  PLOT.')");
  }
  if (monitr == 0) {
    write(munit6,
      "('            ===  Previous  ROLLing  of',"
      "' vector plot is hereby cancelled.  ===')");
  }
  window(cmn);
  goto statement_1550;
  statement_2715:
  if (buffin(1, 8) != "ROLLC   ") {
    goto statement_42715;
  }
  monits++;
  if (monits >= 2) {
    monits = 0;
  }
  if (monits != 0) {
    goto statement_1550;
  }
  write(munit6,
    "('            ===  Previous  ROLLing  of',"
    "' character plot is hereby cancelled.  ===')");
  window(cmn);
  goto statement_1550;
  statement_42715:
  if (buffin(1, 8) != "SPAN    ") {
    goto statement_2718;
  }
  write(prom80, "(' SEND DESIRED TMAX-TMIN:')");
  FEM_THROW_UNHANDLED("executable assign: assign52716tonextsn");
  goto statement_9800;
  fresp1(cmn, buff77, d3);
  statement_2717:
  n4 = (indbuf - newvec) / (kptplt + 1);
  if (iprspy < 1) {
    goto statement_82717;
  }
  write(munit6,
    "(' Timespan calculation.','  INDBUF, NEWVEC, KPTPLT, N4=',4i8)"),
    indbuf, newvec, kptplt, n4;
  window(cmn);
  statement_82717:
  n4 = newvec + n4 * (kptplt + 1);
  din2 = pltbuf(n4);
  din1 = din2 - d3;
  goto statement_1927;
  statement_2718:
  if (buffin(1, 8) != "FRONT   ") {
    goto statement_2720;
  }
  d3 = spsave;
  goto statement_2717;
  statement_2720:
  if (buffin(1, 8) != xyplot) {
    goto statement_2728;
  }
  mxypl++;
  if (mxypl >= 2) {
    mxypl = 0;
  }
  if (mxypl == 0) {
    goto statement_2724;
  }
  write(prom80, "(' SEND X-AXIS LABEL (',a16,'...) :')"), xytitl(1, 16);
  FEM_THROW_UNHANDLED("executable assign: assign42721tonextsn");
  goto statement_9800;
  buffin = buff77;
  if (buffin(1, 8) == "        ") {
    goto statement_2724;
  }
  if (buffin(1, 8) == texblk) {
    goto statement_2722;
  }
  xytitl(1, 24) = buffin(1, 24);
  goto statement_2724;
  statement_2722:
  xytitl = "                        ";
  statement_2724:
  goto statement_1550;
  statement_2728:
  if (buffin(1, 8) != cursor) {
    goto statement_2733;
  }
  icurse++;
  if (icurse == 2) {
    icurse = 0;
  }
  goto statement_1550;
  statement_2733:
  if (buffin(1, 8) != debug) {
    goto statement_2742;
  }
  write(prom80, "('  SUPPLY LEVEL-NUMBER  IPRSPY  (',i3,' ) :')"), iprspy;
  FEM_THROW_UNHANDLED("executable assign: assign2740tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, iprspy);
  goto statement_1550;
  statement_2742:
  if (buffin(1, 8) != extrem) {
    goto statement_4774;
  }
  kextr++;
  if (kextr > 1) {
    kextr = 0;
  }
  goto statement_1550;
  statement_4774:
  if (buffin(1, 8) != level) {
    goto statement_4781;
  }
  klevl++;
  if (klevl > 1) {
    klevl = 0;
  }
  if (klevl == 0) {
    goto statement_4777;
  }
  {
    write_loop wloop(munit6, "('   INPUT VECTOR OF LEVELS :')");
    FEM_DO_SAFE(j, 1, jplt) {
      wloop, ylevel(j);
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, "(1x,7e10.2)");
    FEM_DO_SAFE(j, 1, jplt) {
      wloop, ylevel(j);
    }
  }
  window(cmn);
  if (ltek <= 0) {
    goto statement_34776;
  }
  write(munit6, format_3303);
  window(cmn);
  statement_34776:
  {
    read_loop rloop(cmn, munit5, star);
    FEM_DO_SAFE(j, 1, jplt) {
      rloop, ylevel(j);
    }
  }
  statement_4777:
  goto statement_1550;
  statement_4781:
  if (buffin(1, 8) != stop) {
    goto statement_4784;
  }
  kill = 99;
  goto statement_9835;
  statement_4784:
  if (buffin(1, 8) != smooth) {
    goto statement_4805;
  }
  write(prom80,
    "(' SUPPLY NEW TOLERANCE IN',' INCHES**2 (',e9.2,' ) :')"),
    tolrce;
  FEM_THROW_UNHANDLED("executable assign: assign4794tonextsn");
  goto statement_9800;
  fresp1(cmn, buff77, tolrce);
  goto statement_1550;
  statement_4805:
  if (buffin(1, 8) != size) {
    goto statement_4823;
  }
  write(prom80,
    "(' SUPPLY NEW TIME-AXIS LENGTH',' IN INCHES (',f5.1,' ) :')"),
    taxisl;
  FEM_THROW_UNHANDLED("executable assign: assign4811tonextsn");
  goto statement_9800;
  fresp1(cmn, buff77, d1);
  if (d1 > 2.0f) {
    taxisl = d1;
  }
  goto statement_1550;
  statement_4823:
  if (buffin(1, 8) != show) {
    goto statement_4841;
  }
  n1 = limcol + 1;
  write(munit6, "(' Parameter settings follow ....')");
  window(cmn);
  write(munit6, "(i15,' = Number of columns in character plot')"), n1;
  window(cmn);
  write(munit6, "(i15,' = Diagnostic (DEBUG) printout level')"), iprspy;
  window(cmn);
  write(munit6, "(e15.3,' = Length of time axis in inches')"), taxisl;
  window(cmn);
  write(munit6, "(e15.3,' = smoothing tolerance in inches')"), tolrce;
  window(cmn);
  write(munit6, "(i15,' = Logical unit number of line printer.')"), linepr;
  window(cmn);
  write(munit6, "(i15,' = Logical unit number of current output')"), lu7plt;
  window(cmn);
  write(munit6, "(i15,' = LTEK (1 if vector plot, 0 otherwise)')"), ltek;
  window(cmn);
  write(munit6, "(i15,' = Time units code IHS')"), ihs;
  window(cmn);
  write(munit6, "(i15,' = IBAUD (Tektronix PLOT10 characters/sec)')"), ibaud;
  window(cmn);
  write(munit6, "(i15,' = NXMAX (vector points horizontally)')"), nxmax;
  window(cmn);
  goto statement_1550;
  statement_4841:
  if (buffin(1, 5) != help(1, 5)) {
    goto statement_1990;
  }
  helper(cmn, 3);
  goto statement_1550;
  statement_1990:
  if (iprspy < 1) {
    goto statement_8992;
  }
  write(munit6, "(' KPTPLT, NUMNVO, NUMBRN below 1990 =',3i8)"),
    kptplt, numnvo, cmn.numbrn;
  window(cmn);
  statement_8992:
  if (buffin(1, 8) != out) {
    goto statement_1921;
  }
  goto statement_9835;
  statement_1921:
  if (buffin(1, 8) != multip) {
    goto statement_1960;
  }
  write(munit6, "('   INPUT VECTOR OF MULTIPLIERS :')");
  window(cmn);
  {
    write_loop wloop(munit6, format_3317);
    FEM_DO_SAFE(j, 1, jplt) {
      wloop, aaa(j);
    }
  }
  window(cmn);
  if (ltek <= 0) {
    goto statement_1957;
  }
  write(munit6, format_1956);
  window(cmn);
  statement_1957:
  FEM_THROW_UNHANDLED("executable assign: assign1958tonextsn");
  goto statement_9800;
  {
    read_loop rloop(buff77, format_1959);
    FEM_DO_SAFE(j, 1, jplt) {
      rloop, aaa(j);
    }
  }
  goto statement_1550;
  statement_1960:
  if (buffin(1, 8) != offset) {
    goto statement_1970;
  }
  write(munit6, "('   INPUT VECTOR OF OFFSETS :')");
  window(cmn);
  {
    write_loop wloop(munit6, format_3317);
    FEM_DO_SAFE(j, 1, jplt) {
      wloop, bbb(j);
    }
  }
  window(cmn);
  if (ltek <= 0) {
    goto statement_1969;
  }
  write(munit6, format_1956);
  window(cmn);
  statement_1969:
  FEM_THROW_UNHANDLED("executable assign: assign31969tonextsn");
  goto statement_9800;
  {
    read_loop rloop(buff77, format_1959);
    FEM_DO_SAFE(j, 1, jplt) {
      rloop, bbb(j);
    }
  }
  goto statement_1550;
  statement_1970:
  if (buffin(1, 8) != limits) {
    goto statement_1980;
  }
  write(prom80, "('   VERTICAL MIN & MAX (',2e12.3,' ) :')"), vmin, vmax;
  FEM_THROW_UNHANDLED("executable assign: assign1975tonextsn");
  goto statement_9800;
  fresp2(cmn, buff77, vmin, vmax);
  limfix = 1;
  if (vmin == 0.0f && vmax == 0.0f) {
    limfix = 0;
  }
  goto statement_1550;
  statement_1980:
  if (buffin(1, 8) != averag) {
    goto statement_1989;
  }
  write(prom80,
    "('   SUPPLY CONSECUTIVE-OSCILLATION LIMIT (',i6,' ) :')"),
    nsmplt;
  FEM_THROW_UNHANDLED("executable assign: assign1985tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, n1);
  if (n1 > 0) {
    nsmplt = n1;
  }
  goto statement_1550;
  statement_1989:
  if (buffin(1, 8) != rescal) {
    goto statement_1992;
  }
  limfix = 0;
  FEM_DO_SAFE(j, 1, 20) {
    aaa(j) = 1.0f;
    bbb(j) = 0.0f;
  }
  goto statement_1550;
  statement_1992:
  if (buffin(1, 8) != cmn.time) {
    goto statement_5618;
  }
  din1 = hmin * tmult;
  din2 = hmax * tmult;
  write(prom80, "('   SUPPLY TMIN & TMAX (',2e12.3,' ) :')"), din1, din2;
  FEM_THROW_UNHANDLED("executable assign: assign31925tonextsn");
  goto statement_9800;
  fresp2(cmn, buff77, din1, din2);
  if (din1 != 0.0f) {
    goto statement_1927;
  }
  if (din2 != 0.0f) {
    goto statement_1927;
  }
  goto statement_1928;
  //C     AUTO INTERNAL "TIME", CALLED FROM "PLTFIL" IF ROLLING PLOT NEEDS  M38.4807
  //C     A NEW PAGE:                                                       M38.4808
  statement_1926:
  d6 = din2 - din1;
  d7 = inchlp;
  din1 = din2 - (d7 / 100.f) * d6;
  din2 = din1 + d6;
  if (iprspy <= 0) {
    goto statement_1927;
  }
  write(munit6,
    "(' \"TIMVAL\", S.N. 1926.  LIMFIX, INCHLP, VMIN,',' VMAX, DIN1, DIN2 =',"
    "2i8,4e13.4)"),
    limfix, inchlp, vmin, vmax, din1, din2;
  window(cmn);
  statement_1927:
  hmin = din1;
  hmax = din2;
  spsave = din2 - din1;
  hmin = hmin / tmult;
  hmax = hmax / tmult;
  hpi = (hmax - hmin) / taxisl;
  statement_1928:
  if (iprspy < 1) {
    goto statement_1942;
  }
  write(munit6, "(' B4 read points.  KPLT, JPLT =',2i8)"), kplt, jplt;
  window(cmn);
  write(munit6,
    "('         HMIN, HMAX, HPI, TAXISL, TMULT =',5e15.6)"), hmin,
    hmax, hpi, taxisl, tmult;
  window(cmn);
  statement_1942:
  if (monitr != 2345) {
    goto statement_5648;
  }
  goto statement_1550;
  statement_5618:
  if (buffin(1, 8) != "        " && buffin(1, 8) != inner) {
    goto statement_4431;
  }
  if (hmax > hmin) {
    goto statement_5648;
  }
  goto statement_4437;
  statement_4431:
  if (buffin(1, 8) != alltim) {
    goto statement_5623;
  }
  statement_4437:
  hmin = timbeg;
  hmax = timend;
  hpi = (hmax - hmin) / taxisl;
  goto statement_5648;
  statement_5623:
  write(munit6, "(' \?\?? Unrecognizable data.  Try again ....')");
  window(cmn);
  goto statement_1550;
  statement_5648:
  kplt = 0;
  if (iprspy < 1) {
    goto statement_75648;
  }
  write(munit6, "(' Begin points extraction.  MPLOT =',20i4)"), mplot;
  window(cmn);
  statement_75648:
  if (limfix == 1) {
    goto statement_5647;
  }
  vmin = -finfin;
  vmax = finfin;
  statement_5647:
  vmaxr = vmin + (vmax - vmin) * (vh - vs) / (vl - vs);
  vminr = vmin - (vmax - vmin) * vs / (vl - vs);
  mfake = 0;
  FEM_DO_SAFE(j, 1, jplt) {
    mmm(j) = 1;
    if (aaa(j) == 0.0f) {
      goto statement_5646;
    }
    if (aaa(j) == 1.0f) {
      goto statement_5646;
    }
    goto statement_5645;
    statement_5646:
    if (bbb(j) != 0.0f) {
      goto statement_5645;
    }
    mmm(j) = 0;
    mfake++;
    statement_5645:;
  }
  indexp = newvec - (kptplt + 1);
  if (iprspy < 1) {
    goto statement_1940;
  }
  write(munit6, "(' Reinitialize pointer:  NEWVEC, KPTPLT =',2i9)"),
    newvec, kptplt;
  window(cmn);
  statement_1940:
  indexp += kptplt + 1;
  if (iprspy < 3) {
    goto statement_81940;
  }
  write(munit6, "(' INDEXP at the time test =',i9)"), indexp;
  window(cmn);
  statement_81940:
  if (indexp >= indbuf) {
    goto statement_2200;
  }
  tstep = pltbuf(indexp);
  if (tstep >= hmin) {
    goto statement_2060;
  }
  goto statement_1940;
  statement_2060:
  if (tstep > hmax) {
    goto statement_2205;
  }
  if (indexp > indbuf) {
    goto statement_2200;
  }
  if (kplt <= maxevk) {
    goto statement_2100;
  }
  write(munit6,
    "(2x,'Plot truncated to',e11.3,' seconds due to filled storage. ')"),
    tstep;
  window(cmn);
  goto statement_2205;
  statement_2100:
  kplt++;
  ev(kplt) = tstep;
  FEM_DO_SAFE(j, 1, jplt) {
    j1 = mplot(j);
    if (j1 >= 0) {
      goto statement_2120;
    }
    j1 = -j1;
    bx(j1) = -bx(j1);
    statement_2120:
    if (mxypl == 0) {
      goto statement_2126;
    }
    if (j == 1) {
      goto statement_2127;
    }
    statement_2126:
    kplt++;
    statement_2127:
    ev(kplt) = pltbuf(indexp + j1);
    if (mplot(j) < 0) {
      ev(kplt) = -ev(kplt);
    }
    if (mmm(j) == 0) {
      goto statement_2140;
    }
    if (aaa(j) != 0.0f) {
      ev(kplt) = ev(kplt) * aaa(j);
    }
    ev(kplt) += bbb(j);
    statement_2140:;
  }
  goto statement_1940;
  statement_2200:
  tstep = 1.e+30f;
  statement_2205:
  if (iprspy < 4) {
    goto statement_3342;
  }
  FEM_DOSTEP(j, 1, kplt, 8) {
    {
      write_loop wloop(munit6, "(' EV(',i5,':)=',8e15.6)");
      wloop, j;
      FEM_DO_SAFE(ip, j, j + 7) {
        wloop, ev(ip);
      }
    }
    window(cmn);
  }
  statement_3342:
  ind1 = indexp - (kptplt + 1);
  if (iprspy < 1) {
    goto statement_3343;
  }
  write(munit6, "(' Another IND1 change.  IND1 =',i8)"), ind1;
  window(cmn);
  statement_3343:
  if (mxypl == 0) {
    goto statement_2218;
  }
  k = 0;
  n7 = 0;
  n8 = 2 * kplt / jplt + 4;
  gxmin = finfin;
  gymin = finfin;
  gxmax = -gxmin;
  gymax = -gymin;
  statement_8303:
  if (k >= kplt) {
    goto statement_8317;
  }
  kk = n7;
  FEM_DOSTEP(j, 1, jplt, 2) {
    if (ev(k + 1) < gxmin) {
      gxmin = ev(k + 1);
    }
    if (ev(k + 1) > gxmax) {
      gxmax = ev(k + 1);
    }
    if (ev(k + 2) < gymin) {
      gymin = ev(k + 2);
    }
    if (ev(k + 2) > gymax) {
      gymax = ev(k + 2);
    }
    ew(kk + 1) = ev(k + 1);
    ew(kk + 2) = ev(k + 2);
    k += 2;
    kk += n8;
  }
  n7 += 2;
  goto statement_8303;
  statement_8317:
  write(munit6,
    "('  X-MIN, Y-MIN =',2e12.4,'  Y-MIN, Y-MAX =',2e12.4)"), gxmin,
    gxmax, gymin, gymax;
  window(cmn);
  write(prom80, "(' SEND AXIS LIMITS :')");
  FEM_THROW_UNHANDLED("executable assign: assign43356tonextsn");
  goto statement_9800;
  read(buff77, format_1959), d1, d2, d3, d4;
  if (d1 != 0.0f) {
    gxmin = d1;
  }
  if (d2 != 0.0f) {
    gxmax = d2;
  }
  if (d3 != 0.0f) {
    gymin = d3;
  }
  if (d4 != 0.0f) {
    gymax = d4;
  }
  vmin = gymin;
  vmax = gymax;
  mfake = mfake / 2;
  L = 0;
  kk = n8;
  FEM_DOSTEP(j, 1, jplt, 2) {
    L++;
    mstart(L) = kk - 4;
    ew(kk - 3) = gxmin;
    ew(kk - 2) = gymin;
    ew(kk - 1) = (gxmax - gxmin) / taxisl;
    ew(kk) = (gymax - gymin) / 8.0f;
    kk += n8;
  }
  kk = kk - n8;
  jplt = L;
  if (iprspy < 1) {
    goto statement_8382;
  }
  {
    write_loop wloop(munit6,
      "(' Done with X-Y pack.   JPLT =',i3,5x,'MSTART(J) :',5i5)");
    wloop, jplt;
    FEM_DO_SAFE(j, 1, jplt) {
      wloop, mstart(j);
    }
  }
  window(cmn);
  statement_8382:
  if (iprspy < 9) {
    goto statement_7309;
  }
  FEM_DOSTEP(j, 1, kk, 8) {
    {
      write_loop wloop(munit6, "(' EW(',i5,':)=',8e15.6)");
      wloop, j;
      FEM_DO_SAFE(ip, j, j + 7) {
        wloop, ew(ip);
      }
    }
    window(cmn);
  }
  goto statement_7309;
  statement_2218:
  dx = hpi;
  evmx = 0.0f;
  k9 = kplt + jplt1 + jplt1;
  FEM_DO_SAFE(j, 1, jplt) {
    evh = 0.0f;
    evdh = 0.0f;
    isw = 0;
    itimes = 0;
    FEM_DOSTEP(i, 1, kplt, jplt1) {
      ipj = i + j;
      evp = ev(ipj);
      if (isw > 0) {
        goto statement_2240;
      }
      evdp = evp - evh;
      if (evdp * evdh >= 0.0f) {
        goto statement_2250;
      }
      if (isww == 1) {
        goto statement_2255;
      }
      itimes++;
      if (itimes <= nsmplt) {
        goto statement_2260;
      }
      isw = 1;
      statement_2240:
      ev(ipj) = (evh + evp) / 2.0f;
      goto statement_2260;
      statement_2250:
      isww = 1;
      goto statement_2260;
      statement_2255:
      itimes = 1;
      isww = 0;
      statement_2260:
      evdh = evdp;
      evh = evp;
      evmx = fem::amax1(evmx, fem::abs(ev(ipj)));
      if (ev(ipj) < vminr) {
        goto statement_2280;
      }
      if (ev(ipj) > vmaxr) {
        goto statement_2300;
      }
      goto statement_2320;
      statement_2280:
      ev(ipj) = vminr;
      goto statement_2320;
      statement_2300:
      ev(ipj) = vmaxr;
      statement_2320:;
    }
  }
  if (iprspy < 4) {
    goto statement_3369;
  }
  write(munit6,
    "(' After points discard.',11x,'EVMX',11x,'VMAX',11x,'VMIN',9x,'FINFIN',"
    "13x,'VL',13x,'VS')");
  window(cmn);
  write(munit6, "(22x,6e15.5)"), evmx, vmax, vmin, finfin, vl, vs;
  window(cmn);
  statement_3369:
  if (limfix == 1) {
    goto statement_2540;
  }
  if (evmx == 0.0f) {
    evmx = 1.0f;
  }
  statement_2357:
  a = 8.0f;
  evmxf = evmx * 0.8f;
  statement_2360:
  d1 = evmxf - a;
  if (d1 == 0.0f) {
    goto statement_2400;
  }
  if (d1 > 0.0f) {
    goto statement_2380;
  }
  a = a / 10.f;
  goto statement_2360;
  statement_2380:
  a = a * 10.f;
  d1 = evmxf - a;
  if (d1 == 0.0f) {
    goto statement_2400;
  }
  if (d1 > 0.0f) {
    goto statement_2380;
  }
  d1 = evmxf - 0.5f * a;
  if (d1 == 0.0f) {
    goto statement_2440;
  }
  if (d1 < 0.0f) {
    goto statement_2420;
  }
  statement_2400:
  vmax = a;
  goto statement_2520;
  statement_2420:
  d1 = evmxf - .25f * a;
  if (d1 < 0.0f) {
    goto statement_2460;
  }
  if (d1 == 0.0f) {
    goto statement_2480;
  }
  statement_2440:
  vmax = a / 2.0f;
  goto statement_2520;
  statement_2460:
  if (evmxf - a / 8.0f <= 0.0f) {
    goto statement_2500;
  }
  statement_2480:
  vmax = a / 4.0f;
  goto statement_2520;
  statement_2500:
  vmax = a / 8.0f;
  statement_2520:
  vmin = -vmax;
  if (vmax >= 0.99f * evmx) {
    goto statement_2540;
  }
  evmx = evmx * 1.1f;
  goto statement_2357;
  statement_2540:
  dy = (vmax - vmin) / (vl - vs);
  if (kplt > 0) {
    goto statement_2543;
  }
  write(munit6,
    "('   ** Sorry.  No data available between times',2e13.4,'sec.')"),
    hmin, hmax;
  window(cmn);
  goto statement_1550;
  statement_2543:
  ipl = 0;
  kpltq = kplt / jplt1;
  istore = 0;
  if (iprspy < 4) {
    goto statement_3382;
  }
  write(munit6, "(' Dump cells 1-20 of EV at S.N. 2548 . . . .')");
  window(cmn);
  {
    write_loop wloop(munit6, format_3374);
    FEM_DO_SAFE(i, 1, 10) {
      wloop, ev(i);
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, format_3374);
    FEM_DO_SAFE(i, 11, 20) {
      wloop, ev(i);
    }
  }
  window(cmn);
  statement_3382:
  FEM_DO_SAFE(i, 1, jplt) {
    yymin(i) = 1.e30f;
    yymax(i) = -yymin(i);
    mlevel(i) = 0;
    if (klevl == 0) {
      goto statement_2567;
    }
    mlevel(i) = -1;
    ttlev(i) = -9999.f;
    statement_2567:;
  }
  FEM_DO_SAFE(i, 1, jplt) {
    istold = istore;
    ibase = 1;
    num = 0;
    n13 = 1 + jplt1 + i;
    vold = ev(n13);
    istore++;
    statement_3000:
    evbasx = ev(ibase);
    evbasy = ev(ibase + i);
    ew(istore) = evbasx;
    ew(istore + 1) = evbasy;
    istore += 2;
    if (istore <= maxew) {
      goto statement_3004;
    }
    write(munit6, "(' Sorry, tables have overflowed during smoothing.')");
    window(cmn);
    write(munit6, "(' Either try a larger tolerance (to discard more')");
    window(cmn);
    write(munit6, "(' points), or decrease the time span, or expand')");
    window(cmn);
    write(munit6, "(' array  EW(',i6,')  in deck \"DEKSPY\" .')"), maxew;
    window(cmn);
    goto statement_1550;
    statement_3004:
    if (kextr == 0) {
      goto statement_2949;
    }
    if (evbasy <= yymax(i)) {
      goto statement_2941;
    }
    yymax(i) = evbasy;
    ttmax(i) = evbasx;
    statement_2941:
    if (evbasy >= yymin(i)) {
      goto statement_2949;
    }
    yymin(i) = evbasy;
    ttmin(i) = evbasx;
    statement_2949:
    if (mlevel(i) == 0) {
      goto statement_3010;
    }
    d1 = evbasy - ylevel(i);
    if (d1 * dyold(i) > 0.0f) {
      goto statement_2956;
    }
    if (mlevel(i) ==  - 1) {
      goto statement_2954;
    }
    d3 = d1 * (evbasx - ew(istore - 4));
    ttlev(i) = evbasx - d3 / (d1 - dyold(i));
    mlevel(i) = 0;
    goto statement_3010;
    statement_2954:
    mlevel(i) = 1;
    statement_2956:
    dyold(i) = d1;
    statement_3010:
    hvec = (ev(ibase + jplt1) - evbasx) / dx;
    n13 = ibase + jplt1 + i;
    vvec = (ev(n13) - evbasy) / dy;
    denom = hvec * hvec + vvec * vvec;
    ipontr = ibase + jplt1;
    statement_3020:
    ipontr += jplt1;
    if (ipontr > kplt) {
      goto statement_3140;
    }
    hdif = (ev(ipontr) - evbasx) / dx;
    vnew = ev(ipontr + i);
    vdif = (vnew - evbasy) / dy;
    disqr = hdif * hdif + vdif * vdif - fem::pow2((hvec * hdif +
      vvec * vdif)) / denom;
    if (disqr > tolrce) {
      goto statement_3040;
    }
    vchnge = vnew - vold;
    vold = vnew;
    if (vvec == 0.0f && vchnge == 0.0f) {
      goto statement_3020;
    }
    if (vvec * vchnge > 0.0f) {
      goto statement_3020;
    }
    statement_3040:
    vold = vnew;
    ibase = ipontr - jplt1;
    goto statement_3000;
    statement_3140:
    ipontr = ipontr - jplt1;
    ew(istore) = ev(ipontr);
    ew(istore + 1) = ev(ipontr + i);
    mstart(i) = istore + 1;
    istore++;
    ew(istore + 1) = hmin;
    ew(istore + 3) = hpi;
    ew(istore + 2) = vmin;
    ew(istore + 4) = (vmax - vmin) / 8.0f;
    n5 = istore + 4;
    if (iprspy < 2) {
      goto statement_3406;
    }
    write(munit6,
      "(' Store CalComp scaling.','       I  ISTORE',10x,"
      "'(EW(J), J=ISTORE, N5)')");
    window(cmn);
    {
      write_loop wloop(munit6, "(23x,2i8,5e15.6)");
      wloop, i, istore;
      FEM_DO_SAFE(kl, istore, n5) {
        wloop, ew(kl);
      }
    }
    window(cmn);
    statement_3406:
    istore = n5;
    if (iprspy < 1) {
      goto statement_3235;
    }
    write(munit6,
      "(' Done smoothing next curve.  I, ISTORE =',2i8)"), i, istore;
    window(cmn);
    statement_3235:
    numpts(i) = (istore - istold) / 2;
  }
  statement_3263:
  if (kextr == 1) {
    goto statement_3270;
  }
  if (klevl == 1) {
    goto statement_3288;
  }
  goto statement_7309;
  statement_3270:
  write(munit6,
    "(' MPLOT  NAME-1  NAME-2',7x,'MINIMUM',7x,'MAXIMUM',6x,'T OF MIN',6x,"
    "'T OF MAX')");
  window(cmn);
  L = 1;
  FEM_DO_SAFE(j, 1, jplt) {
    textd1 = slot1(L);
    textd2 = "        ";
    L++;
    if (fem::iabs(mplot(j)) <= numnvo) {
      goto statement_3279;
    }
    textd2 = slot1(L);
    L++;
    write(munit6, "(1x,i5,2(2x,a6),4e14.5)"), mplot(j), textd1,
      textd2, yymin(j), yymax(j), ttmin(j), ttmax(j);
    window(cmn);
    statement_3279:;
  }
  if (klevl == 0) {
    goto statement_3296;
  }
  statement_3288:
  {
    write_loop wloop(munit6, "(' Levels sought :',4e15.4)");
    FEM_DO_SAFE(j, 1, jplt) {
      wloop, ylevel(j);
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, "(' 1ST hit time :',4e16.6)");
    FEM_DO_SAFE(j, 1, jplt) {
      wloop, ttlev(j);
    }
  }
  window(cmn);
  statement_3296:
  if (ltek <= 0) {
    goto statement_43305;
  }
  write(munit6, format_3303);
  window(cmn);
  statement_43305:
  read(munit5, "(a8)"), textd1;
  if (textd1 == "        ") {
    goto statement_7309;
  }
  if (textd1 != linezz) {
    goto statement_3306;
  }
  mu6std = linepr;
  goto statement_3263;
  statement_3306:
  if (textd1 == noplot) {
    goto statement_1550;
  }
  statement_7309:
  if (ltek != 0) {
    tekplt();
  }
  if (ltek == 0) {
    chrplt(cmn);
  }
  if (monitr != 8765) {
    goto statement_1550;
  }
  //C     CHECK IF SPECIAL "PLTVAR" CALL FOR ROLLING PLOT PAGING:           M38.4826
  if (iprsup <= 0) {
    goto statement_7324;
  }
  write(munit6,
    "(' DONE WITH \"TEKPLT\", MONITR = 8765 SO',' EXIT \"TIMVAL\".')");
  window(cmn);
  statement_7324:
  goto statement_9835;
  statement_9800:
  if (iprspy < 1) {
    goto statement_9817;
  }
  write(munit6, "(' EXIT \"TIMVAL\".   PROM80(1:40) =',a40)"), prom80(1, 40);
  window(cmn);
  statement_9817:
  nexmod = 6;
  statement_9835:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
  //C     USAGE IS RESTRICTED TO "PLOT" FUNCTION OF "EMTSPY", DUE           M35.  37
  //C     TO VARIABLE-LENGTH CONFLICT (THIS IS SINGLE-PRECISION).           M35.  38
  //C!w nc -> ncz, numnvo -> numnvz, numout -> numouz, nv -> nvz
  //C     EVNBYT PUTS BUSLST ON REAL*8 BYTE BOUNDARY (IBM LEVEL 4 ERROR):   M39.  44
  //C!w EQUIVALENCE  ( EV(   1), BUSLST(1) ),  ( EV(1001), IBSOUT(1) )
  //C!w EQUIVALENCE  ( EV(1301), IBRNCH(1) ),  ( EV(1601), JBRNCH(1) )
  //C!w EQUIVALENCE  ( FVCOM( 1),   VMIN ),  ( FVCOM( 2),   VMAX )
  //C!w EQUIVALENCE  ( FVCOM( 3),   HMIN ),  ( FVCOM( 4),   HMAX )
  //C!w EQUIVALENCE  ( FVCOM( 5),     HA ),  ( FVCOM( 6), TAXISL )
  //C!w EQUIVALENCE  ( FVCOM( 7), TOLRCE ),  ( FVCOM( 8),   HTAX )
  //C!w EQUIVALENCE  ( FVCOM( 9),   XTIT ),  ( FVCOM(10),   YTIT )
  //C!w EQUIVALENCE  ( FVCOM(11), SIZTIT ),  ( FVCOM(12), XSUPER )
  //C!w EQUIVALENCE  ( FVCOM(13), YSUPER ),  ( FVCOM(14), SIZSUP )
  //C!w EQUIVALENCE  ( FVCOM(15),  FLINE ),  ( FVCOM(16),  SIZID )
  //C!w EQUIVALENCE  ( FVCOM(17),    XID ),  ( FVCOM(18),    YID )
  //C!w EQUIVALENCE  ( FVCOM(19),   FACT ),  ( FVCOM(20), DXGRD1 )
  //C!w EQUIVALENCE  ( FVCOM(21), DYGRD1 ),  ( FVCOM(22), DXGRD2 )
  //C!w EQUIVALENCE  ( FVCOM(23), DYGRD2 ),  ( FVCOM(24),  FILL1 )
  //C!w EQUIVALENCE  ( FVCOM(25),  FILL2 ),  ( FVCOM(26),     VS )
  //C!w EQUIVALENCE  ( FVCOM(27),     VL ),  ( FVCOM(28),     VH )
  //C!w EQUIVALENCE  ( FVCOM(29), PAPMAX ),  ( FVCOM(30), TIMBEG )
  //C!w EQUIVALENCE  ( FVCOM(31), TIMEND ),  ( FVCOM(32), FHTAX  )
  //C!w EQUIVALENCE  ( FVCOM(33), FXSUP  ),  ( FVCOM(34), FYSUP  )
  //C!w EQUIVALENCE  ( FVCOM(35), FXTIT  ),  ( FVCOM(36), FYTIT  )
  //C!w EQUIVALENCE  ( FVCOM(37), FXID   ),  ( FVCOM(38), FYID   )
  //C!w EQUIVALENCE  ( FVCOM(39), FTCARR ),  ( FVCOM(40), VAXISL )
  //C!w EQUIVALENCE  ( FVCOM(41), FXNUMV ),  ( FVCOM(42), FXNUMH )
  //C!w EQUIVALENCE  ( FVCOM(43), FVAXTT ),  ( FVCOM(44), FXVERT )
  //C!w EQUIVALENCE  ( FVCOM(45), FSYMB  ),  ( FVCOM(46), PAPLIM )
  //C!w EQUIVALENCE  ( IVCOM( 1),  KLEVL ),  ( IVCOM( 2),  KEXTR )
  //C!w EQUIVALENCE  ( IVCOM( 3),    IHS ),  ( IVCOM( 4), LU7PLT )
  //C!w EQUIVALENCE  ( IVCOM( 5), IPRSRT ),  ( IVCOM( 6), LIMCOL )
  //C!w EQUIVALENCE  ( IVCOM( 7), LINEPR ),  ( IVCOM( 8),  IBAUD )
  //C!w EQUIVALENCE  ( IVCOM( 9),   LTEK ),  ( IVCOM(10), NUMTIT )
  //C!w EQUIVALENCE  ( IVCOM(11), MAXSYM ),  ( IVCOM(12),   MTIT )
  //C!w EQUIVALENCE  ( IVCOM(13), MAXISX ),  ( IVCOM(14), MAXISY )
  //C!w EQUIVALENCE  ( IVCOM(15), MGRID1 ),  ( IVCOM(16), MGRID2 )
  //C!w EQUIVALENCE  ( IVCOM(17), MSUPER ),  ( IVCOM(18),    MID )
  //C!w EQUIVALENCE  ( IVCOM(19),  MLINE ),  ( IVCOM(20),  NCUT1 )
  //C!w EQUIVALENCE  ( IVCOM(21),  NCUT2 ),  ( IVCOM(22), NSMPLT )
  //C!w EQUIVALENCE  ( IVCOM(23),  LSYMB ),  ( IVCOM(24),  NXMAX )
  //C!w EQUIVALENCE  ( IVCOM(25),  NYMAX ),  ( IVCOM(26),  LCHID )
  //C!w EQUIVALENCE  ( IVCOM(27), NXINCH ),  ( IVCOM(28), NYINCH )
  //C!w EQUIVALENCE  ( IVCOM(29),  NXOFF ),  ( IVCOM(30),  NYOFF )
  //C!w EQUIVALENCE  ( IVCOM(31),   LOOK ),  ( IVCOM(32), LCHSUP )
  //C!w EQUIVALENCE  ( IVCOM(33), LCHTIT ),  ( IVCOM(34), LCHXAX )
  //C!w EQUIVALENCE  ( IVCOM(35), LCHYAX ),  ( IVCOM(36),  ITERM )
  //C!w EQUIVALENCE  ( IVCOM(37),   LTIC ),  ( IVCOM(38),  IZTIT )
  //C!w EQUIVALENCE  ( IVCOM(39),  IZGR1 ),  ( IVCOM(40),  IZGR2 )
  //C!w EQUIVALENCE  ( IVCOM(41), LDSHG1 ),  ( IVCOM(42), LDSHG2 )
  //C!w EQUIVALENCE  ( IVCOM(43),  IZXAX ),  ( IVCOM(44),  IZYAX )
  //C!w EQUIVALENCE  ( IVCOM(45),  NXID6 ),  ( IVCOM(46),  NYID6 )
  //C!w EQUIVALENCE  ( IVCOM(47),  NXEND ),  ( IVCOM(48),  NYEND )
  //C!w EQUIVALENCE  ( IVCOM(49),   IZID ),  ( IVCOM(50), NXVERN )
  //C!w EQUIVALENCE  ( IVCOM(51), ICHREF ),  ( IVCOM(52), ICHEND )
  //C!w EQUIVALENCE  ( IVCOM(53), INCHPX ),  ( IVCOM(54), INCHPY )
  //C!w EQUIVALENCE  ( IVCOM(55), INWAIT ),  ( IVCOM(56), NOLABL )
  //C!w EQUIVALENCE  ( IVCOM(57), LCHFIL ),  ( IVCOM(58), LCHLIM )
  //C!w EQUIVALENCE  ( IVCOM(59), MU6STD )
  //C       NEXT TYPE KEY CHARACTER KEY WORDS IN COMMON, IN ORDER:          M35. 120
  //C!w EQUIVALENCE ( ANPLT( 1), CHOICE ),  ( ANPLT( 2),   STOP )
  //C!w EQUIVALENCE ( ANPLT( 3),  PURGE ),  ( ANPLT( 4),    OUT )
  //C!w EQUIVALENCE ( ANPLT( 5),   HELP ),  ( ANPLT( 6), SMOOTH )
  //C!w EQUIVALENCE ( ANPLT( 7),   SIZE ),  ( ANPLT( 8),   SHOW )
  //C!w EQUIVALENCE ( ANPLT( 9), LINEZZ ),  ( ANPLT(10),  PHOTO )
  //C!w EQUIVALENCE ( ANPLT(11), REPEAT ),  ( ANPLT(12),  FLUSH )
  //C!w EQUIVALENCE ( ANPLT(13), PLAYBA ),  ( ANPLT(14),    PEN )
  //C!w EQUIVALENCE ( ANPLT(15), MULTIP ),  ( ANPLT(16), OFFSET )
  //C!w EQUIVALENCE ( ANPLT(17), LIMITS ),  ( ANPLT(18),  DEBUG )
  //C!w EQUIVALENCE ( ANPLT(19),    TEK ),  ( ANPLT(20),  STACK )
  //C!w EQUIVALENCE ( ANPLT(21), PRINTE ),  ( ANPLT(22), METRIC )
  //C!w EQUIVALENCE ( ANPLT(23), ALLTIM ),  ( ANPLT(24), COLUMN )
  //C!w EQUIVALENCE ( ANPLT(25), SETCOL ),  ( ANPLT(26), LONGER )
  //C!w EQUIVALENCE ( ANPLT(27), AVERAG ),  ( ANPLT(28),  INNER )
  //C!w EQUIVALENCE ( ANPLT(29), RESCAL ),  ( ANPLT(30),  LASTPL)
  //C!w EQUIVALENCE ( ANPLT(31),  BATCH ),  ( ANPLT(32),  PUNCH )
  //C!w EQUIVALENCE ( ANPLT(33), EXTREM ),  ( ANPLT(34),  LEVEL )
  //C!w EQUIVALENCE ( ANPLT(35), NOPLOT ),  ( ANPLT(36), MESSAG )
  //C!w EQUIVALENCE ( ANPLT(37),    END ),  ( ANPLT(38), TIMESP )
  //C!w EQUIVALENCE ( ANPLT(39),  LABEL ),  ( ANPLT(40), TIMEUN )
  //C!w EQUIVALENCE ( ANPLT(41), CURSOR ),  ( ANPLT(42), XYPLOT )
  //C!w EQUIVALENCE ( ANPLT(43),  SLOPE ),  ( ANPLT(44),   BACK )
  //C!w EQUIVALENCE ( ANPLT(45), REFILE ),  ( ANPLT(46), TEXBLK )
  //C!w EQUIVALENCE ( ANPLT(47), SETDAT )
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void pltvar(
  common& cmn) try
{
  common_write write(cmn);
  int& indbuf = cmn.indbuf;
  int& newvec = cmn.newvec;
  int& iprspy = cmn.iprspy;
  int& nexmod = cmn.nexmod;
  fem::str<80>& buff77 = cmn.buff77;
  fem::str<80>& prom80 = cmn.prom80;
  fem::str<132>& munit6 = cmn.munit6;
  arr_cref<double> bbus(cmn.bbus, dimension(300));
  double& tmult = cmn.tmult;
  arr_ref<int> mplot(cmn.mplot, dimension(20));
  int& jplt = cmn.jplt;
  int& icp = cmn.icp;
  int& namvar = cmn.namvar;
  int& nchsup = cmn.nchsup;
  int& nchver = cmn.nchver;
  int& kptplt = cmn.kptplt;
  int& jbegbv = cmn.jbegbv;
  int& jbegbc = cmn.jbegbc;
  fem::str<8>& ansi = cmn.ansi;
  auto& sext = cmn.sext;
  fem::str<80>& headl = cmn.headl;
  fem::str<80>& vertl = cmn.vertl;
  fem::str<80>& buffin = cmn.buffin;
  auto& slot1 = cmn.slot1;
  fem::str<8>& textd1 = cmn.textd1;
  fem::str<8>& textd2 = cmn.textd2;
  fem::str<8>& brclas = cmn.brclas;
  fem::str<80>& alpha = cmn.alpha;
  //
  double tolrce = fem::double0;
  fem::str<8> refile = fem::char0;
  fem::str<8> inner = fem::char0;
  fem::str<8> timesp = fem::char0;
  arr_1d<1, double> pltbuf(fem::fill0);
  double timbeg = fem::double0;
  int n4 = fem::int0;
  double timend = fem::double0;
  int m = fem::int0;
  int j = fem::int0;
  int ip = fem::int0;
  int ihs = fem::int0;
  fem::str<8> choice = fem::char0;
  int i = fem::int0;
  int nv = fem::int0;
  int nc = fem::int0;
  int numnvo = fem::int0;
  int n13 = fem::int0;
  int jj = fem::int0;
  int numout = fem::int0;
  fem::str<8> stop = fem::char0;
  int kill = fem::int0;
  fem::str<8> purge = fem::char0;
  fem::str<8> out = fem::char0;
  fem::str<8> help = fem::char0;
  fem::str<8> label = fem::char0;
  fem::str<8> timeun = fem::char0;
  int L = fem::int0;
  fem::str<8> lastpl = fem::char0;
  fem::str<8> end = fem::char0;
  fem::str<8> back = fem::char0;
  fem::str<8> repeat = fem::char0;
  int k = fem::int0;
  int ib = fem::int0;
  int il = fem::int0;
  int n1 = fem::int0;
  int n14 = fem::int0;
  int ievsw = fem::int0;
  int kplt = fem::int0;
  fem::str<8> texblk = fem::char0;
  int n3 = fem::int0;
  int numtit = fem::int0;
  fem::str<8> flush = fem::char0;
  fem::str<8> playba = fem::char0;
  static const char* format_1641 = "(a6,2x)";
  static const char* format_3232 = "(1x,4(2a7,3x))";
  //C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.6601
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.6602
  if (iprspy < 1) {
    goto statement_1003;
  }
  write(munit6, "(' ENTER \"PLTVAR\".  NEXMOD =',i4)"), nexmod;
  window(cmn);
  statement_1003:
  if (nexmod == 6) {
    goto statement_1550;
  }
  if (nexmod != 5) {
    goto statement_1005;
  }
  nexmod = 0;
  //C!GO TO NEXTSN
  statement_1005:
  tolrce = 0.0f;
  goto statement_1008;
  statement_1053:
  write(prom80, "(' --- MIDDLE :')");
  FEM_THROW_UNHANDLED("executable assign: assign1048tonextsn");
  goto statement_9800;
  buffin = buff77;
  if (buffin(1, 4) == "STOP") {
    return;
  }
  //C     IF ( BUFFIN(1:4) .EQ. 'SPY ' )  RETURN  ! ABORT "PLOT" USE        M38.4722
  if (buffin(1, 8) != refile) {
    goto statement_1007;
  }
  write(prom80, "(' FILE :')");
  FEM_THROW_UNHANDLED("executable assign: assign1052tonextsn");
  goto statement_9800;
  buffin = buff77;
  cmn.newfil = 1;
  goto statement_1053;
  statement_1007:
  if (buffin(1, 8) == inner) {
    goto statement_1550;
  }
  if (buffin(1, 8) != timesp) {
    goto statement_5681;
  }
  statement_1008:
  timbeg = pltbuf(newvec);
  n4 = (indbuf - newvec) / (kptplt + 1);
  if (iprspy < 1) {
    goto statement_5673;
  }
  write(munit6,
    "(' Timespan calc.  INDBUF, NEWVEC, KPTPLT, N4 =',4i8)"), indbuf,
    newvec, kptplt, n4;
  window(cmn);
  statement_5673:
  n4 = newvec + n4 * (kptplt + 1);
  timend = pltbuf(n4);
  if (iprspy < 1) {
    goto statement_35675;
  }
  write(munit6,
    "(' PLTBUF cells',2i8,'     TMIN, TMAX',' (SEC) =',2e14.5)"),
    newvec, n4, timbeg, timend;
  window(cmn);
  statement_35675:
  if (iprspy < 5) {
    goto statement_3218;
  }
  FEM_DOSTEP(m, newvec, n4, 8) {
    {
      write_loop wloop(munit6, "(' PLTBUF(',i6,':)',8e14.5)");
      wloop, j;
      FEM_DO_SAFE(ip, j, j + 7) {
        wloop, pltbuf(ip);
      }
    }
    window(cmn);
  }
  statement_3218:
  write(munit6, "('   Time limits are :',2e14.6)"), timbeg, timend;
  window(cmn);
  if (ihs == 0) {
    ihs = 3;
  }
  goto statement_7531;
  statement_5681:
  if (buffin(1, 8) != choice) {
    goto statement_1957;
  }
  spylin(cmn);
  i = 1;
  nc = 2 * nv;
  write(munit6, "(' Type-1 entries (node voltages).')");
  window(cmn);
  FEM_DOSTEP(j, 1, numnvo, 10) {
    n13 = j + 9;
    if (n13 > numnvo) {
      n13 = numnvo;
    }
    {
      write_loop wloop(munit6, "(1x,10a7)");
      FEM_DO_SAFE(ip, j, n13) {
        wloop, bbus(ip);
      }
    }
    window(cmn);
  }
  i += numnvo;
  jj = i + nc - 1;
  write(munit6, "(' Type-8 entries (branch voltages or powers).')");
  window(cmn);
  FEM_DOSTEP(j, i, jj, 8) {
    n13 = j + 7;
    if (n13 > jj) {
      n13 = jj;
    }
    {
      write_loop wloop(munit6, format_3232);
      FEM_DO_SAFE(ip, j, n13) {
        wloop, bbus(ip);
      }
    }
    window(cmn);
  }
  i += nc;
  write(munit6, "(' Type-9 entries (branch currents or energies).')");
  window(cmn);
  FEM_DOSTEP(j, i, numout, 8) {
    n13 = j + 7;
    if (n13 > numout) {
      n13 = numout;
    }
    {
      write_loop wloop(munit6, format_3232);
      FEM_DO_SAFE(ip, j, n13) {
        wloop, bbus(ip);
      }
    }
    window(cmn);
  }
  goto statement_1053;
  statement_1957:
  if (buffin(1, 8) != stop) {
    goto statement_4423;
  }
  kill = 99;
  return;
  statement_4423:
  if (buffin(1, 8) != purge) {
    goto statement_1958;
  }
  cmn.io.close(14)
    .status("DELETE");
  return;
  statement_1958:
  if (buffin(1, 8) != out) {
    goto statement_1931;
  }
  return;
  statement_1931:
  if (buffin(1, 5) != help(1, 5)) {
    goto statement_1059;
  }
  helper(cmn, 2);
  goto statement_1053;
  statement_1059:
  if (buffin(1, 8) == label) {
    goto statement_1210;
  }
  if (buffin(1, 8) != timeun) {
    goto statement_1167;
  }
  statement_1155:
  write(prom80, "('   SEND TIME-UNITS CODE (',i2,' ) :')"), ihs;
  FEM_THROW_UNHANDLED("executable assign: assign1165tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, n4);
  if (n4 > 0) {
    ihs = n4;
  }
  if (ihs > 0 && ihs < 8) {
    goto statement_7531;
  }
  write(munit6, "('  ? ? ?  Illegal value.  Try again ...')");
  window(cmn);
  goto statement_1155;
  statement_7531:
  if (ihs == 1) {
    tmult = 21600.f;
  }
  if (ihs == 2) {
    tmult = 60.f;
  }
  if (ihs == 3) {
    tmult = 1.0f;
  }
  if (ihs == 4) {
    tmult = 1000.f;
  }
  if (ihs == 5) {
    tmult = 1.e6f;
  }
  if (ihs == 6) {
    tmult = 1.0f;
  }
  if (ihs == 7) {
    tmult = 1.0f;
  }
  goto statement_1053;
  statement_1167:
  L = 1;
  icp = 4;
  jplt = 0;
  statement_7338:
  write(prom80, "('   SEND NODE NAME OR END (',a6,') :')"), slot1(L);
  FEM_THROW_UNHANDLED("executable assign: assign7342tonextsn");
  goto statement_9800;
  textd1 = buff77(1, 8);
  if (textd1 == lastpl) {
    goto statement_1175;
  }
  if (textd1 != end) {
    goto statement_7348;
  }
  icp = 8;
  brclas = cmn.voltag;
  goto statement_1168;
  statement_7348:
  if (textd1 == "        ") {
    textd1 = slot1(L);
  }
  if (textd1 == back) {
    goto statement_1053;
  }
  if (L == 1 && jplt > 0 && textd1 == repeat) {
    goto statement_1210;
  }
  k = 0;
  statement_1600:
  k++;
  if (k <= numnvo) {
    goto statement_1640;
  }
  write(munit6,
    "(' \?\?? List of node voltages does not include  \"',a6,"
    "'\" .   Try again ....')"),
    textd1;
  window(cmn);
  goto statement_7338;
  statement_1640:
  write(ansi, format_1641), bbus(k);
  if (textd1 != ansi) {
    goto statement_1600;
  }
  jplt = L;
  L++;
  mplot(jplt) = k;
  slot1(jplt) = textd1;
  goto statement_7338;
  statement_1168:
  write(prom80,
    "('   SEND BRANCH ',a7,' NAMES OR END (',a6,',',a6,' ) :')"),
    brclas, slot1(L), slot1(L + 1);
  FEM_THROW_UNHANDLED("executable assign: assign31169tonextsn");
  goto statement_9800;
  textd1 = buff77(1, 6);
  textd2 = buff77(7, 12);
  if (textd1 == back) {
    goto statement_1053;
  }
  if (textd1 == end) {
    goto statement_1175;
  }
  if (textd1 == lastpl) {
    goto statement_1175;
  }
  if (textd1 == "        " && textd2 == "        ") {
    goto statement_1173;
  }
  slot1(L) = textd1;
  slot1(L + 1) = textd2;
  statement_1173:
  if (slot1(L) == "        " && slot1(L + 1) == "        ") {
    goto statement_1168;
  }
  if (icp == 9) {
    goto statement_1720;
  }
  ib = jbegbv;
  il = jbegbc;
  n1 = ib;
  goto statement_1740;
  statement_1720:
  ib = jbegbc;
  il = numout;
  n1 = jbegbv + nv;
  statement_1740:
  if (ib < il) {
    goto statement_1780;
  }
  write(munit6,
    "(' \?\?? Branch ',a7,' list does not include',' an entry from  \"',a6,"
    "'\"  to  \"',a6,' \" .   Try again ....')"),
    brclas, slot1(L), slot1(L + 1);
  window(cmn);
  goto statement_1168;
  statement_1780:
  write(ansi, format_1641), bbus(ib);
  if (slot1(L) != ansi) {
    goto statement_1800;
  }
  write(ansi, format_1641), bbus(ib + 1);
  if (slot1(L + 1) != ansi) {
    goto statement_1820;
  }
  //C               NODE PAIR FOUND - SIGN CORRECT                          M35.6753
  mplot(jplt + 1) = n1;
  goto statement_1840;
  statement_1800:
  write(ansi, format_1641), bbus(ib);
  if (slot1(L + 1) != ansi) {
    goto statement_1820;
  }
  write(ansi, format_1641), bbus(ib + 1);
  if (slot1(L) != ansi) {
    goto statement_1820;
  }
  //C               NODE PAIR FOUND - SIGN NEGATIVE                         M35.6760
  mplot(jplt + 1) = -n1;
  goto statement_1840;
  statement_1820:
  ib += 2;
  n1++;
  goto statement_1740;
  statement_1840:
  jplt++;
  L += 2;
  goto statement_1168;
  statement_1175:
  namvar = L - 1;
  if (iprspy < 1) {
    goto statement_1218;
  }
  write(munit6, "(' Done class.    JPLT, ICP, NAMVAR =',3i8)"), jplt,
    icp, namvar;
  window(cmn);
  statement_1218:
  if (iprspy < 1) {
    goto statement_3252;
  }
  n14 = jplt;
  if (n14 > 20) {
    n14 = 20;
  }
  {
    write_loop wloop(munit6, "(' MPLOT:',20i6)");
    FEM_DO_SAFE(i, 1, n14) {
      wloop, mplot(i);
    }
  }
  window(cmn);
  statement_3252:
  if (textd1 != lastpl && icp < 9) {
    goto statement_1204;
  }
  if (jplt > 0) {
    goto statement_1210;
  }
  write(munit6,
    "('  \?\??  Error.   No valid plot variables of',"
    "' any type were specified.   Try again ....')");
  window(cmn);
  goto statement_1167;
  statement_1204:
  icp = 9;
  brclas = cmn.curren;
  goto statement_1168;
  statement_1210:
  nc = namvar + 1;
  FEM_DO_SAFE(i, nc, 20) {
    slot1(i) = "        ";
  }
  ievsw = 0;
  nc = cmn.nt2 / 2 - nv;
  if (iprspy < 1) {
    goto statement_1880;
  }
  write(munit6,
    "(' Assign KPTPLT.  KPTPLT, NUMNVO, NUMBRN =',3i10)"), kptplt,
    numnvo, cmn.numbrn;
  window(cmn);
  statement_1880:
  cmn.jplt1 = jplt + 1;
  kplt = 0;
  write(prom80, "('   SEND SUPER-TITLE (',a16,'...) :')"), headl(1, 16);
  FEM_THROW_UNHANDLED("executable assign: assign31882tonextsn");
  goto statement_9800;
  alpha = buff77;
  if (alpha(1, 8) == repeat) {
    goto statement_1550;
  }
  if (alpha(1, 8) == texblk) {
    goto statement_1536;
  }
  FEM_DO_SAFE(j, 1, 80) {
    n3 = 81 - j;
    if (alpha(n3, n3) == " ") {
      goto statement_1535;
    }
    headl = alpha;
    nchsup = n3;
    goto statement_1885;
    statement_1535:;
  }
  statement_1536:
  nchsup = 0;
  statement_1885:
  write(prom80, "('   SEND VERTICAL AXIS LABEL (',a16,'...) :')"), vertl(1, 16);
  FEM_THROW_UNHANDLED("executable assign: assign1887tonextsn");
  goto statement_9800;
  vertl = buff77;
  if (vertl(1, 8) == repeat) {
    goto statement_1550;
  }
  if (vertl(1, 8) == texblk) {
    goto statement_1545;
  }
  FEM_DO_SAFE(j, 1, 78) {
    n3 = 81 - j;
    if (vertl(n3, n3) == " ") {
      goto statement_1544;
    }
    nchver = n3;
    goto statement_1888;
    statement_1544:;
  }
  statement_1545:
  nchver = 0;
  statement_1888:
  n3 = numtit + 1;
  write(prom80, "('   SEND CASE-TITLE LINE',i2,' (',a16,'...) :')"),
    n3, sext(n3)(1, 16);
  FEM_THROW_UNHANDLED("executable assign: assign1892tonextsn");
  goto statement_9800;
  alpha = buff77;
  if (alpha(1, 8) != flush) {
    goto statement_1894;
  }
  numtit = 0;
  goto statement_1888;
  statement_1894:
  if (alpha(1, 8) != playba) {
    goto statement_1896;
  }
  write(munit6, "(6x,'Playback of total title (80A1 FORMAT) ...')");
  window(cmn);
  FEM_DO_SAFE(ip, 1, numtit) {
    write(munit6, "(1x,a80)"), sext(ip);
    window(cmn);
  }
  goto statement_1888;
  statement_1896:
  if (alpha(1, 8) == "        ") {
    goto statement_1899;
  }
  if (alpha(1, 8) == end) {
    goto statement_1550;
  }
  if (alpha(1, 8) != texblk) {
    goto statement_1897;
  }
  alpha(1, 8) = "        ";
  statement_1897:
  sext(n3) = alpha;
  statement_1899:
  numtit = n3;
  if (numtit < 5) {
    goto statement_1901;
  }
  write(munit6,
    "(' ** Warning.  Title storage is now full.',"
    "'   No additional lines can be accepted.')");
  window(cmn);
  statement_1901:
  goto statement_1888;
  statement_1550:
  timval(cmn);
  if (nexmod > 0) {
    goto statement_9835;
  }
  if (kill == 99) {
    goto statement_9835;
  }
  if (buffin(1, 4) == "STOP") {
    goto statement_9835;
  }
  //C     IF ( BUFFIN(1:4) .EQ. 'SPY ' ) GO TO 9835 ! ABORT "PLOT" USE      M38.4749
  goto statement_1053;
  statement_9800:
  if (iprspy < 1) {
    goto statement_9817;
  }
  write(munit6, "(' EXIT \"PLTVAR\".   PROM80(1:40) =',a40)"), prom80(1, 40);
  window(cmn);
  statement_9817:
  nexmod = 5;
  statement_9835:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
  //C     USAGE IS RESTRICTED TO "PLOT" FUNCTION OF "EMTSPY", DUE           M35.  37
  //C     TO VARIABLE-LENGTH CONFLICT (THIS IS SINGLE-PRECISION).           M35.  38
  //C!w nc -> ncz, numnvo -> numnvz, numout -> numouz, nv -> nvz
  //C     EVNBYT PUTS BUSLST ON REAL*8 BYTE BOUNDARY (IBM LEVEL 4 ERROR):   M39.  44
  //C!w EQUIVALENCE  ( EV(   1), BUSLST(1) ),  ( EV(1001), IBSOUT(1) )
  //C!w EQUIVALENCE  ( EV(1301), IBRNCH(1) ),  ( EV(1601), JBRNCH(1) )
  //C!w EQUIVALENCE  ( FVCOM( 1),   VMIN ),  ( FVCOM( 2),   VMAX )
  //C!w EQUIVALENCE  ( FVCOM( 3),   HMIN ),  ( FVCOM( 4),   HMAX )
  //C!w EQUIVALENCE  ( FVCOM( 5),     HA ),  ( FVCOM( 6), TAXISL )
  //C!w EQUIVALENCE  ( FVCOM( 7), TOLRCE ),  ( FVCOM( 8),   HTAX )
  //C!w EQUIVALENCE  ( FVCOM( 9),   XTIT ),  ( FVCOM(10),   YTIT )
  //C!w EQUIVALENCE  ( FVCOM(11), SIZTIT ),  ( FVCOM(12), XSUPER )
  //C!w EQUIVALENCE  ( FVCOM(13), YSUPER ),  ( FVCOM(14), SIZSUP )
  //C!w EQUIVALENCE  ( FVCOM(15),  FLINE ),  ( FVCOM(16),  SIZID )
  //C!w EQUIVALENCE  ( FVCOM(17),    XID ),  ( FVCOM(18),    YID )
  //C!w EQUIVALENCE  ( FVCOM(19),   FACT ),  ( FVCOM(20), DXGRD1 )
  //C!w EQUIVALENCE  ( FVCOM(21), DYGRD1 ),  ( FVCOM(22), DXGRD2 )
  //C!w EQUIVALENCE  ( FVCOM(23), DYGRD2 ),  ( FVCOM(24),  FILL1 )
  //C!w EQUIVALENCE  ( FVCOM(25),  FILL2 ),  ( FVCOM(26),     VS )
  //C!w EQUIVALENCE  ( FVCOM(27),     VL ),  ( FVCOM(28),     VH )
  //C!w EQUIVALENCE  ( FVCOM(29), PAPMAX ),  ( FVCOM(30), TIMBEG )
  //C!w EQUIVALENCE  ( FVCOM(31), TIMEND ),  ( FVCOM(32), FHTAX  )
  //C!w EQUIVALENCE  ( FVCOM(33), FXSUP  ),  ( FVCOM(34), FYSUP  )
  //C!w EQUIVALENCE  ( FVCOM(35), FXTIT  ),  ( FVCOM(36), FYTIT  )
  //C!w EQUIVALENCE  ( FVCOM(37), FXID   ),  ( FVCOM(38), FYID   )
  //C!w EQUIVALENCE  ( FVCOM(39), FTCARR ),  ( FVCOM(40), VAXISL )
  //C!w EQUIVALENCE  ( FVCOM(41), FXNUMV ),  ( FVCOM(42), FXNUMH )
  //C!w EQUIVALENCE  ( FVCOM(43), FVAXTT ),  ( FVCOM(44), FXVERT )
  //C!w EQUIVALENCE  ( FVCOM(45), FSYMB  ),  ( FVCOM(46), PAPLIM )
  //C!w EQUIVALENCE  ( IVCOM( 1),  KLEVL ),  ( IVCOM( 2),  KEXTR )
  //C!w EQUIVALENCE  ( IVCOM( 3),    IHS ),  ( IVCOM( 4), LU7PLT )
  //C!w EQUIVALENCE  ( IVCOM( 5), IPRSRT ),  ( IVCOM( 6), LIMCOL )
  //C!w EQUIVALENCE  ( IVCOM( 7), LINEPR ),  ( IVCOM( 8),  IBAUD )
  //C!w EQUIVALENCE  ( IVCOM( 9),   LTEK ),  ( IVCOM(10), NUMTIT )
  //C!w EQUIVALENCE  ( IVCOM(11), MAXSYM ),  ( IVCOM(12),   MTIT )
  //C!w EQUIVALENCE  ( IVCOM(13), MAXISX ),  ( IVCOM(14), MAXISY )
  //C!w EQUIVALENCE  ( IVCOM(15), MGRID1 ),  ( IVCOM(16), MGRID2 )
  //C!w EQUIVALENCE  ( IVCOM(17), MSUPER ),  ( IVCOM(18),    MID )
  //C!w EQUIVALENCE  ( IVCOM(19),  MLINE ),  ( IVCOM(20),  NCUT1 )
  //C!w EQUIVALENCE  ( IVCOM(21),  NCUT2 ),  ( IVCOM(22), NSMPLT )
  //C!w EQUIVALENCE  ( IVCOM(23),  LSYMB ),  ( IVCOM(24),  NXMAX )
  //C!w EQUIVALENCE  ( IVCOM(25),  NYMAX ),  ( IVCOM(26),  LCHID )
  //C!w EQUIVALENCE  ( IVCOM(27), NXINCH ),  ( IVCOM(28), NYINCH )
  //C!w EQUIVALENCE  ( IVCOM(29),  NXOFF ),  ( IVCOM(30),  NYOFF )
  //C!w EQUIVALENCE  ( IVCOM(31),   LOOK ),  ( IVCOM(32), LCHSUP )
  //C!w EQUIVALENCE  ( IVCOM(33), LCHTIT ),  ( IVCOM(34), LCHXAX )
  //C!w EQUIVALENCE  ( IVCOM(35), LCHYAX ),  ( IVCOM(36),  ITERM )
  //C!w EQUIVALENCE  ( IVCOM(37),   LTIC ),  ( IVCOM(38),  IZTIT )
  //C!w EQUIVALENCE  ( IVCOM(39),  IZGR1 ),  ( IVCOM(40),  IZGR2 )
  //C!w EQUIVALENCE  ( IVCOM(41), LDSHG1 ),  ( IVCOM(42), LDSHG2 )
  //C!w EQUIVALENCE  ( IVCOM(43),  IZXAX ),  ( IVCOM(44),  IZYAX )
  //C!w EQUIVALENCE  ( IVCOM(45),  NXID6 ),  ( IVCOM(46),  NYID6 )
  //C!w EQUIVALENCE  ( IVCOM(47),  NXEND ),  ( IVCOM(48),  NYEND )
  //C!w EQUIVALENCE  ( IVCOM(49),   IZID ),  ( IVCOM(50), NXVERN )
  //C!w EQUIVALENCE  ( IVCOM(51), ICHREF ),  ( IVCOM(52), ICHEND )
  //C!w EQUIVALENCE  ( IVCOM(53), INCHPX ),  ( IVCOM(54), INCHPY )
  //C!w EQUIVALENCE  ( IVCOM(55), INWAIT ),  ( IVCOM(56), NOLABL )
  //C!w EQUIVALENCE  ( IVCOM(57), LCHFIL ),  ( IVCOM(58), LCHLIM )
  //C!w EQUIVALENCE  ( IVCOM(59), MU6STD )
  //C       NEXT TYPE KEY CHARACTER KEY WORDS IN COMMON, IN ORDER:          M35. 120
  //C!w EQUIVALENCE ( ANPLT( 1), CHOICE ),  ( ANPLT( 2),   STOP )
  //C!w EQUIVALENCE ( ANPLT( 3),  PURGE ),  ( ANPLT( 4),    OUT )
  //C!w EQUIVALENCE ( ANPLT( 5),   HELP ),  ( ANPLT( 6), SMOOTH )
  //C!w EQUIVALENCE ( ANPLT( 7),   SIZE ),  ( ANPLT( 8),   SHOW )
  //C!w EQUIVALENCE ( ANPLT( 9), LINEZZ ),  ( ANPLT(10),  PHOTO )
  //C!w EQUIVALENCE ( ANPLT(11), REPEAT ),  ( ANPLT(12),  FLUSH )
  //C!w EQUIVALENCE ( ANPLT(13), PLAYBA ),  ( ANPLT(14),    PEN )
  //C!w EQUIVALENCE ( ANPLT(15), MULTIP ),  ( ANPLT(16), OFFSET )
  //C!w EQUIVALENCE ( ANPLT(17), LIMITS ),  ( ANPLT(18),  DEBUG )
  //C!w EQUIVALENCE ( ANPLT(19),    TEK ),  ( ANPLT(20),  STACK )
  //C!w EQUIVALENCE ( ANPLT(21), PRINTE ),  ( ANPLT(22), METRIC )
  //C!w EQUIVALENCE ( ANPLT(23), ALLTIM ),  ( ANPLT(24), COLUMN )
  //C!w EQUIVALENCE ( ANPLT(25), SETCOL ),  ( ANPLT(26), LONGER )
  //C!w EQUIVALENCE ( ANPLT(27), AVERAG ),  ( ANPLT(28),  INNER )
  //C!w EQUIVALENCE ( ANPLT(29), RESCAL ),  ( ANPLT(30),  LASTPL)
  //C!w EQUIVALENCE ( ANPLT(31),  BATCH ),  ( ANPLT(32),  PUNCH )
  //C!w EQUIVALENCE ( ANPLT(33), EXTREM ),  ( ANPLT(34),  LEVEL )
  //C!w EQUIVALENCE ( ANPLT(35), NOPLOT ),  ( ANPLT(36), MESSAG )
  //C!w EQUIVALENCE ( ANPLT(37),    END ),  ( ANPLT(38), TIMESP )
  //C!w EQUIVALENCE ( ANPLT(39),  LABEL ),  ( ANPLT(40), TIMEUN )
  //C!w EQUIVALENCE ( ANPLT(41), CURSOR ),  ( ANPLT(42), XYPLOT )
  //C!w EQUIVALENCE ( ANPLT(43),  SLOPE ),  ( ANPLT(44),   BACK )
  //C!w EQUIVALENCE ( ANPLT(45), REFILE ),  ( ANPLT(46), TEXBLK )
  //C!w EQUIVALENCE ( ANPLT(47), SETDAT )
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct tpplot_save
{
  fem::str<8> alltim;
  fem::str<8> averag;
  fem::str<8> back;
  fem::str<8> batch;
  arr<double> buslst;
  fem::str<8> char20;
  fem::str<8> choice;
  fem::str<8> column;
  fem::str<8> cursor;
  fem::str<8> debug;
  fem::str<8> end;
  fem::str<8> extrem;
  arr<fem::str<1> > filbyt;
  fem::str<30> file30;
  arr<double> fkar1;
  arr<double> fkar2;
  fem::str<8> flush;
  arr<double> forbyt;
  fem::str<8> help;
  double hmax;
  double hmin;
  int i;
  arr<int> ibrnch;
  arr<int> ibsout;
  int ihs;
  fem::str<8> inner;
  int j;
  arr<int> jbrnch;
  int k;
  int kill;
  int L;
  fem::str<8> label;
  fem::str<8> lastpl;
  fem::str<8> level;
  int limcol;
  fem::str<8> limits;
  fem::str<8> linezz;
  fem::str<8> longer;
  int ltek;
  int m;
  fem::str<8> messag;
  fem::str<8> metric;
  int mline;
  fem::str<8> multip;
  int n1;
  fem::str<8> noplot;
  int numbco;
  int numnam;
  int numnvo;
  int numout;
  int nv;
  fem::str<8> offset;
  fem::str<8> out;
  fem::str<8> pen;
  fem::str<8> photo;
  fem::str<8> playba;
  arr<double> pltbuf;
  fem::str<8> printe;
  fem::str<8> punch;
  fem::str<8> purge;
  fem::str<8> refile;
  fem::str<8> repeat;
  fem::str<8> rescal;
  fem::str<8> setcol;
  fem::str<8> setdat;
  fem::str<8> show;
  fem::str<8> size;
  fem::str<8> slope;
  fem::str<8> smooth;
  fem::str<8> stack;
  fem::str<8> stop;
  fem::str<8> tek;
  fem::str<8> texblk;
  fem::str<8> timesp;
  fem::str<8> timeun;
  fem::str<8> xyplot;

  tpplot_save() :
    alltim(fem::char0),
    averag(fem::char0),
    back(fem::char0),
    batch(fem::char0),
    buslst(dimension(1), fem::fill0),
    char20(fem::char0),
    choice(fem::char0),
    column(fem::char0),
    cursor(fem::char0),
    debug(fem::char0),
    end(fem::char0),
    extrem(fem::char0),
    filbyt(dimension(1), fem::fill0),
    file30(fem::char0),
    fkar1(dimension(1), fem::fill0),
    fkar2(dimension(1), fem::fill0),
    flush(fem::char0),
    forbyt(dimension(600), fem::fill0),
    help(fem::char0),
    hmax(fem::double0),
    hmin(fem::double0),
    i(fem::int0),
    ibrnch(dimension(1), fem::fill0),
    ibsout(dimension(1), fem::fill0),
    ihs(fem::int0),
    inner(fem::char0),
    j(fem::int0),
    jbrnch(dimension(1), fem::fill0),
    k(fem::int0),
    kill(fem::int0),
    L(fem::int0),
    label(fem::char0),
    lastpl(fem::char0),
    level(fem::char0),
    limcol(fem::int0),
    limits(fem::char0),
    linezz(fem::char0),
    longer(fem::char0),
    ltek(fem::int0),
    m(fem::int0),
    messag(fem::char0),
    metric(fem::char0),
    mline(fem::int0),
    multip(fem::char0),
    n1(fem::int0),
    noplot(fem::char0),
    numbco(fem::int0),
    numnam(fem::int0),
    numnvo(fem::int0),
    numout(fem::int0),
    nv(fem::int0),
    offset(fem::char0),
    out(fem::char0),
    pen(fem::char0),
    photo(fem::char0),
    playba(fem::char0),
    pltbuf(dimension(1), fem::fill0),
    printe(fem::char0),
    punch(fem::char0),
    purge(fem::char0),
    refile(fem::char0),
    repeat(fem::char0),
    rescal(fem::char0),
    setcol(fem::char0),
    setdat(fem::char0),
    show(fem::char0),
    size(fem::char0),
    slope(fem::char0),
    smooth(fem::char0),
    stack(fem::char0),
    stop(fem::char0),
    tek(fem::char0),
    texblk(fem::char0),
    timesp(fem::char0),
    timeun(fem::char0),
    xyplot(fem::char0)
  {}
};

void tpplot(
  common& cmn) try
{
  FEM_CMN_SVE(tpplot);
  common_read read(cmn);
  common_write write(cmn);
  int& iprspy = cmn.iprspy;
  int& nexmod = cmn.nexmod;
  fem::str<80>& buff77 = cmn.buff77;
  fem::str<80>& prom80 = cmn.prom80;
  fem::str<132>& munit6 = cmn.munit6;
  auto& datepl = cmn.datepl;
  auto& tclopl = cmn.tclopl;
  auto& bbus = cmn.bbus;
  auto& mcurve = cmn.mcurve;
  double& tstep = static_cast<common_cblock&>(cmn).tstep;
  const auto& ew = cmn.ew;
  auto& ylevel = cmn.ylevel;
  auto& aaa = cmn.aaa;
  auto& bbb = cmn.bbb;
  const auto& ev = cmn.ev;
  const auto& bx = cmn.bx;
  auto& mmm = cmn.mmm;
  int& numbrn = cmn.numbrn;
  int& jbegbv = cmn.jbegbv;
  int& nt2 = cmn.nt2;
  int& maxew = cmn.maxew;
  int& l4plot = cmn.l4plot;
  fem::str<80>& buffin = cmn.buffin;
  auto& sext = cmn.sext;
  auto& slot1 = cmn.slot1;
  //
  int& i = sve.i;
  arr_ref<double> buslst(sve.buslst, dimension(1));
  arr_ref<int> ibrnch(sve.ibrnch, dimension(1));
  arr_ref<int> ibsout(sve.ibsout, dimension(1));
  arr_ref<int> jbrnch(sve.jbrnch, dimension(1));
  int& j = sve.j;
  int& k = sve.k;
  int& kill = sve.kill;
  int& L = sve.L;
  int& limcol = sve.limcol;
  int& ltek = sve.ltek;
  int& m = sve.m;
  int& n1 = sve.n1;
  int& numbco = sve.numbco;
  int& numnam = sve.numnam;
  int& numnvo = sve.numnvo;
  int& numout = sve.numout;
  int& nv = sve.nv;
  //C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.6108
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.6109
  if (nexmod > 4) {
    goto statement_3769;
  }
  if (nexmod != 4) {
    goto statement_1742;
  }
  nexmod = 0;
  //C!GO TO NEXTSN
  statement_1742:
  sve.hmax = 0.0f;
  sve.hmin = 0.0f;
  sve.ihs = 3;
  cmn.tmult = 1.0f;
  cmn.maxev = locint(bx(1)) - locint(ev(1));
  maxew = locint(cmn.finfin) - locint(ew(1));
  maxew = maxew - 50;
  FEM_DO_SAFE(j, 1, 6) {
    sext(j) = cmn.blan80;
  }
  FEM_DO_SAFE(i, 1, 20) {
    aaa(i) = 1.0f;
    bbb(i) = 0.0f;
    mmm(i) = 0;
    ylevel(i) = 0.0f;
    slot1(i) = "        ";
  }
  statement_563:
  FEM_DO_SAFE(j, 1, 20) {
    mcurve(j) = sve.mline;
  }
  statement_1000:
  write(prom80, "(' --- OUTER :')");
  FEM_THROW_UNHANDLED("executable assign: assign5003tonextsn");
  goto statement_9800;
  buffin = buff77;
  kill = 0;
  if (buffin(1, 8) != sve.purge) {
    goto statement_2716;
  }
  cmn.io.close(14)
    .status("DELETE");
  goto statement_1000;
  statement_2716:
  if (buffin(1, 8) != sve.setdat) {
    goto statement_2757;
  }
  setrtm(cmn);
  goto statement_563;
  statement_2757:
  if (buffin(1, 8) != sve.debug) {
    goto statement_7368;
  }
  write(prom80, "('  SUPPLY LEVEL-NUMBER  IPRSPY  (',i3,' ) :')"), iprspy;
  FEM_THROW_UNHANDLED("executable assign: assign7361tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, iprspy);
  goto statement_1000;
  statement_7368:
  if (iprspy < 1) {
    goto statement_3877;
  }
  write(munit6, "('  BUFFIN vector =',a80)"), buffin;
  window(cmn);
  statement_3877:
  if (buffin(1, 8) == sve.stop) {
    goto statement_3818;
  }
  if (buffin(1, 8) != sve.tek) {
    goto statement_5136;
  }
  if (ltek == 1) {
    goto statement_7387;
  }
  write(munit6,
    "('  ---- Switch from character to vector-','graphic plotting.')");
  window(cmn);
  goto statement_7388;
  statement_7387:
  write(munit6,
    "('  ---- Switch from vector-graphic to',' character plotting')");
  window(cmn);
  statement_7388:
  ltek++;
  if (ltek == 2) {
    ltek = 0;
  }
  goto statement_1000;
  statement_5136:
  if (buffin(1, 8) != sve.column) {
    goto statement_5143;
  }
  n1 = limcol;
  if (n1 != 131) {
    limcol = 131;
  }
  if (n1 != 79) {
    limcol = 79;
  }
  write(munit6, "('   Character-plot column width was',i5,'  columns.')"), n1;
  window(cmn);
  write(munit6, "('   It is now being toggled to',i5,' .')"), limcol;
  window(cmn);
  goto statement_1000;
  statement_5143:
  if (buffin(1, 8) != sve.setcol) {
    goto statement_5154;
  }
  write(prom80, "('  SUPPLY PRINTER-PLOT COLUMN WIDTH (',i4,' ) :')"), limcol;
  FEM_THROW_UNHANDLED("executable assign: assign5147tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, limcol);
  write(munit6, "('   Confirmation.   New value =',i4,' .')"), limcol;
  window(cmn);
  goto statement_1000;
  statement_5154:
  if (buffin(1, 8) == sve.inner) {
    goto statement_3769;
  }
  if (buffin(1, 4) == "STOP") {
    return;
  }
  if (buffin(1, 5) != sve.help(1, 5)) {
    goto statement_5200;
  }
  helper(cmn, 1);
  goto statement_1000;
  statement_5200:
  cmn.newfil = 0;
  tstep = -1.0f;
  cmn.io.rewind(l4plot);
  {
    read_loop rloop(cmn, l4plot, fem::unformatted);
    rloop, datepl, tclopl, numnam, numnvo, numbco, numbrn;
    FEM_DO_SAFE(i, 1, numnam) {
      rloop, buslst(i);
    }
  }
  if (iprspy < 2) {
    goto statement_5739;
  }
  write(munit6, "(' Plot-file header info.',2(1x,2a4),4i6)"), datepl,
    tclopl, numnam, numnvo, numbco, numbrn;
  window(cmn);
  FEM_DOSTEP(j, 1, numnam, 10) {
    {
      write_loop wloop(munit6, "(1x,10a7)");
      FEM_DO_SAFE(k, j, j + 9) {
        wloop, buslst(k);
      }
    }
    window(cmn);
  }
  statement_5739:
  cmn.kptplt = numnvo + numbrn;
  if (numnvo > 0) {
    {
      read_loop rloop(cmn, l4plot, fem::unformatted);
      FEM_DO_SAFE(j, 1, numnvo) {
        rloop, ibsout(j);
      }
    }
  }
  if (numbrn > 0) {
    {
      read_loop rloop(cmn, l4plot, fem::unformatted);
      FEM_DO_SAFE(j, 1, numbrn) {
        rloop, ibrnch(j);
      }
      FEM_DO_SAFE(j, 1, numbrn) {
        rloop, jbrnch(j);
      }
    }
  }
  if (iprspy < 2) {
    goto statement_5754;
  }
  FEM_DOSTEP(j, 1, numnvo, 10) {
    {
      write_loop wloop(munit6, "(' Node numbers IBSOUT:',10i5)");
      FEM_DO_SAFE(k, j, j + 9) {
        wloop, ibsout(k);
      }
    }
    window(cmn);
  }
  FEM_DOSTEP(j, 1, numbrn, 5) {
    {
      write_loop wloop(munit6, "(' Branch node pairs:',5(2x,2i4))");
      FEM_DO_SAFE(k, j, j + 4) {
        wloop, ibrnch(k), jbrnch(k);
      }
    }
    window(cmn);
  }
  statement_5754:
  numout = numnvo + 2 * numbrn;
  nv = numbrn - numbco;
  jbegbv = numnvo + 1;
  cmn.jbegbc = jbegbv + 2 * nv;
  nt2 = numbrn * 2;
  i = 1;
  statement_1008:
  if (i > numnvo) {
    goto statement_1009;
  }
  j = ibsout(i);
  bbus(i) = buslst(j);
  i++;
  goto statement_1008;
  statement_1009:
  j = 1;
  statement_1012:
  if (j > numbrn) {
    goto statement_1013;
  }
  k = ibrnch(j);
  L = jbrnch(j);
  bbus(i) = buslst(k);
  i++;
  bbus(i) = buslst(L);
  i++;
  j++;
  goto statement_1012;
  statement_1013:
  if (iprspy < 2) {
    goto statement_3769;
  }
  write(munit6, "(' NUMOUT, NUMNVO, NV, NT2, I =',5i6)"), numout,
    numnvo, nv, nt2, i;
  window(cmn);
  FEM_DOSTEP(j, 1, numout, 10) {
    {
      write_loop wloop(munit6, "(1x,10a6)");
      FEM_DO_SAFE(m, j, j + 9) {
        wloop, bbus(m);
      }
    }
    window(cmn);
  }
  statement_3769:
  pltvar(cmn);
  if (nexmod > 0) {
    goto statement_9835;
  }
  if (buffin(1, 4) == "STOP") {
    return;
  }
  //C     IF ( BUFFIN(1:4) .EQ. 'SPY ' )  RETURN  ! ABORT "PLOT" USE        M38.4702
  if (kill == 0) {
    goto statement_1000;
  }
  statement_3818:
  cmn.io.close(14)
    .status("KEEP");
  //C     NOW STOP.   IF THERE WERE TEKTRONIX CRT PLOTS, CALL FOR           M38.4703
  //C     BUFFER FLUSHING IN  #TEKPLT# .                                    M35.6256
  if (cmn.numtek > 0) {
    tekplt();
  }
  statement_9800:
  if (iprspy < 1) {
    goto statement_9817;
  }
  write(munit6, "(' EXIT \"TPPLOT\".   PROM80(1:40) =',a40)"), prom80(1, 40);
  window(cmn);
  statement_9817:
  nexmod = 4;
  statement_9835:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
  //C     USAGE IS RESTRICTED TO "PLOT" FUNCTION OF "EMTSPY", DUE           M35.  37
  //C     TO VARIABLE-LENGTH CONFLICT (THIS IS SINGLE-PRECISION).           M35.  38
  //C!w nc -> ncz, numnvo -> numnvz, numout -> numouz, nv -> nvz
  //C     EVNBYT PUTS BUSLST ON REAL*8 BYTE BOUNDARY (IBM LEVEL 4 ERROR):   M39.  44
  //C!w EQUIVALENCE  ( EV(   1), BUSLST(1) ),  ( EV(1001), IBSOUT(1) )
  //C!w EQUIVALENCE  ( EV(1301), IBRNCH(1) ),  ( EV(1601), JBRNCH(1) )
  //C!w EQUIVALENCE  ( FVCOM( 1),   VMIN ),  ( FVCOM( 2),   VMAX )
  //C!w EQUIVALENCE  ( FVCOM( 3),   HMIN ),  ( FVCOM( 4),   HMAX )
  //C!w EQUIVALENCE  ( FVCOM( 5),     HA ),  ( FVCOM( 6), TAXISL )
  //C!w EQUIVALENCE  ( FVCOM( 7), TOLRCE ),  ( FVCOM( 8),   HTAX )
  //C!w EQUIVALENCE  ( FVCOM( 9),   XTIT ),  ( FVCOM(10),   YTIT )
  //C!w EQUIVALENCE  ( FVCOM(11), SIZTIT ),  ( FVCOM(12), XSUPER )
  //C!w EQUIVALENCE  ( FVCOM(13), YSUPER ),  ( FVCOM(14), SIZSUP )
  //C!w EQUIVALENCE  ( FVCOM(15),  FLINE ),  ( FVCOM(16),  SIZID )
  //C!w EQUIVALENCE  ( FVCOM(17),    XID ),  ( FVCOM(18),    YID )
  //C!w EQUIVALENCE  ( FVCOM(19),   FACT ),  ( FVCOM(20), DXGRD1 )
  //C!w EQUIVALENCE  ( FVCOM(21), DYGRD1 ),  ( FVCOM(22), DXGRD2 )
  //C!w EQUIVALENCE  ( FVCOM(23), DYGRD2 ),  ( FVCOM(24),  FILL1 )
  //C!w EQUIVALENCE  ( FVCOM(25),  FILL2 ),  ( FVCOM(26),     VS )
  //C!w EQUIVALENCE  ( FVCOM(27),     VL ),  ( FVCOM(28),     VH )
  //C!w EQUIVALENCE  ( FVCOM(29), PAPMAX ),  ( FVCOM(30), TIMBEG )
  //C!w EQUIVALENCE  ( FVCOM(31), TIMEND ),  ( FVCOM(32), FHTAX  )
  //C!w EQUIVALENCE  ( FVCOM(33), FXSUP  ),  ( FVCOM(34), FYSUP  )
  //C!w EQUIVALENCE  ( FVCOM(35), FXTIT  ),  ( FVCOM(36), FYTIT  )
  //C!w EQUIVALENCE  ( FVCOM(37), FXID   ),  ( FVCOM(38), FYID   )
  //C!w EQUIVALENCE  ( FVCOM(39), FTCARR ),  ( FVCOM(40), VAXISL )
  //C!w EQUIVALENCE  ( FVCOM(41), FXNUMV ),  ( FVCOM(42), FXNUMH )
  //C!w EQUIVALENCE  ( FVCOM(43), FVAXTT ),  ( FVCOM(44), FXVERT )
  //C!w EQUIVALENCE  ( FVCOM(45), FSYMB  ),  ( FVCOM(46), PAPLIM )
  //C!w EQUIVALENCE  ( IVCOM( 1),  KLEVL ),  ( IVCOM( 2),  KEXTR )
  //C!w EQUIVALENCE  ( IVCOM( 3),    IHS ),  ( IVCOM( 4), LU7PLT )
  //C!w EQUIVALENCE  ( IVCOM( 5), IPRSRT ),  ( IVCOM( 6), LIMCOL )
  //C!w EQUIVALENCE  ( IVCOM( 7), LINEPR ),  ( IVCOM( 8),  IBAUD )
  //C!w EQUIVALENCE  ( IVCOM( 9),   LTEK ),  ( IVCOM(10), NUMTIT )
  //C!w EQUIVALENCE  ( IVCOM(11), MAXSYM ),  ( IVCOM(12),   MTIT )
  //C!w EQUIVALENCE  ( IVCOM(13), MAXISX ),  ( IVCOM(14), MAXISY )
  //C!w EQUIVALENCE  ( IVCOM(15), MGRID1 ),  ( IVCOM(16), MGRID2 )
  //C!w EQUIVALENCE  ( IVCOM(17), MSUPER ),  ( IVCOM(18),    MID )
  //C!w EQUIVALENCE  ( IVCOM(19),  MLINE ),  ( IVCOM(20),  NCUT1 )
  //C!w EQUIVALENCE  ( IVCOM(21),  NCUT2 ),  ( IVCOM(22), NSMPLT )
  //C!w EQUIVALENCE  ( IVCOM(23),  LSYMB ),  ( IVCOM(24),  NXMAX )
  //C!w EQUIVALENCE  ( IVCOM(25),  NYMAX ),  ( IVCOM(26),  LCHID )
  //C!w EQUIVALENCE  ( IVCOM(27), NXINCH ),  ( IVCOM(28), NYINCH )
  //C!w EQUIVALENCE  ( IVCOM(29),  NXOFF ),  ( IVCOM(30),  NYOFF )
  //C!w EQUIVALENCE  ( IVCOM(31),   LOOK ),  ( IVCOM(32), LCHSUP )
  //C!w EQUIVALENCE  ( IVCOM(33), LCHTIT ),  ( IVCOM(34), LCHXAX )
  //C!w EQUIVALENCE  ( IVCOM(35), LCHYAX ),  ( IVCOM(36),  ITERM )
  //C!w EQUIVALENCE  ( IVCOM(37),   LTIC ),  ( IVCOM(38),  IZTIT )
  //C!w EQUIVALENCE  ( IVCOM(39),  IZGR1 ),  ( IVCOM(40),  IZGR2 )
  //C!w EQUIVALENCE  ( IVCOM(41), LDSHG1 ),  ( IVCOM(42), LDSHG2 )
  //C!w EQUIVALENCE  ( IVCOM(43),  IZXAX ),  ( IVCOM(44),  IZYAX )
  //C!w EQUIVALENCE  ( IVCOM(45),  NXID6 ),  ( IVCOM(46),  NYID6 )
  //C!w EQUIVALENCE  ( IVCOM(47),  NXEND ),  ( IVCOM(48),  NYEND )
  //C!w EQUIVALENCE  ( IVCOM(49),   IZID ),  ( IVCOM(50), NXVERN )
  //C!w EQUIVALENCE  ( IVCOM(51), ICHREF ),  ( IVCOM(52), ICHEND )
  //C!w EQUIVALENCE  ( IVCOM(53), INCHPX ),  ( IVCOM(54), INCHPY )
  //C!w EQUIVALENCE  ( IVCOM(55), INWAIT ),  ( IVCOM(56), NOLABL )
  //C!w EQUIVALENCE  ( IVCOM(57), LCHFIL ),  ( IVCOM(58), LCHLIM )
  //C!w EQUIVALENCE  ( IVCOM(59), MU6STD )
  //C       NEXT TYPE KEY CHARACTER KEY WORDS IN COMMON, IN ORDER:          M35. 120
  //C!w EQUIVALENCE ( ANPLT( 1), CHOICE ),  ( ANPLT( 2),   STOP )
  //C!w EQUIVALENCE ( ANPLT( 3),  PURGE ),  ( ANPLT( 4),    OUT )
  //C!w EQUIVALENCE ( ANPLT( 5),   HELP ),  ( ANPLT( 6), SMOOTH )
  //C!w EQUIVALENCE ( ANPLT( 7),   SIZE ),  ( ANPLT( 8),   SHOW )
  //C!w EQUIVALENCE ( ANPLT( 9), LINEZZ ),  ( ANPLT(10),  PHOTO )
  //C!w EQUIVALENCE ( ANPLT(11), REPEAT ),  ( ANPLT(12),  FLUSH )
  //C!w EQUIVALENCE ( ANPLT(13), PLAYBA ),  ( ANPLT(14),    PEN )
  //C!w EQUIVALENCE ( ANPLT(15), MULTIP ),  ( ANPLT(16), OFFSET )
  //C!w EQUIVALENCE ( ANPLT(17), LIMITS ),  ( ANPLT(18),  DEBUG )
  //C!w EQUIVALENCE ( ANPLT(19),    TEK ),  ( ANPLT(20),  STACK )
  //C!w EQUIVALENCE ( ANPLT(21), PRINTE ),  ( ANPLT(22), METRIC )
  //C!w EQUIVALENCE ( ANPLT(23), ALLTIM ),  ( ANPLT(24), COLUMN )
  //C!w EQUIVALENCE ( ANPLT(25), SETCOL ),  ( ANPLT(26), LONGER )
  //C!w EQUIVALENCE ( ANPLT(27), AVERAG ),  ( ANPLT(28),  INNER )
  //C!w EQUIVALENCE ( ANPLT(29), RESCAL ),  ( ANPLT(30),  LASTPL)
  //C!w EQUIVALENCE ( ANPLT(31),  BATCH ),  ( ANPLT(32),  PUNCH )
  //C!w EQUIVALENCE ( ANPLT(33), EXTREM ),  ( ANPLT(34),  LEVEL )
  //C!w EQUIVALENCE ( ANPLT(35), NOPLOT ),  ( ANPLT(36), MESSAG )
  //C!w EQUIVALENCE ( ANPLT(37),    END ),  ( ANPLT(38), TIMESP )
  //C!w EQUIVALENCE ( ANPLT(39),  LABEL ),  ( ANPLT(40), TIMEUN )
  //C!w EQUIVALENCE ( ANPLT(41), CURSOR ),  ( ANPLT(42), XYPLOT )
  //C!w EQUIVALENCE ( ANPLT(43),  SLOPE ),  ( ANPLT(44),   BACK )
  //C!w EQUIVALENCE ( ANPLT(45), REFILE ),  ( ANPLT(46), TEXBLK )
  //C!w EQUIVALENCE ( ANPLT(47), SETDAT )
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void rtmplt(
  common& cmn)
{
  //C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.5927
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.5928
  tpplot(cmn);
}

struct spying_save
{
  fem::str<8> chard7;
  double d1;
  double d13;
  double d2;
  double d3;
  double d34;
  double d4;
  double d5;
  double d6;
  double d8;
  arr<fem::str<1> > filbyt;
  arr<double> fkar1;
  arr<double> fkar2;
  arr<double> forbyt;
  int i;
  int icomm;
  int idmxxx;
  int ind;
  int intype;
  int j;
  int jwdsav;
  int k;
  int k1;
  int k2;
  int k3;
  int kansav;
  int khead;
  int kp;
  int L;
  int m;
  int n1;
  int n10;
  int n12;
  int n13;
  int n14;
  int n15;
  int n16;
  int n17;
  int n18;
  int n2;
  int n22;
  int n23;
  int n24;
  int n26;
  int n27;
  int n33;
  int n4;
  int n5;
  int n6;
  int n7;
  int n8;
  int n9;
  int nchd2;
  int num2;
  int num3;
  int num5;
  int numask;
  int numbco;
  int numbrn;
  int numnam;
  arr<double> pltbuf;
  arr<fem::str<8> > spdate;
  arr<fem::str<8> > spytim;
  double tim1rp;
  double tim2rp;
  double twhen;
  double val1rp;
  double val2rp;
  double xl;

  spying_save() :
    chard7(fem::char0),
    d1(fem::double0),
    d13(fem::double0),
    d2(fem::double0),
    d3(fem::double0),
    d34(fem::double0),
    d4(fem::double0),
    d5(fem::double0),
    d6(fem::double0),
    d8(fem::double0),
    filbyt(dimension(1), fem::fill0),
    fkar1(dimension(1), fem::fill0),
    fkar2(dimension(1), fem::fill0),
    forbyt(dimension(600), fem::fill0),
    i(fem::int0),
    icomm(fem::int0),
    idmxxx(fem::int0),
    ind(fem::int0),
    intype(fem::int0),
    j(fem::int0),
    jwdsav(fem::int0),
    k(fem::int0),
    k1(fem::int0),
    k2(fem::int0),
    k3(fem::int0),
    kansav(fem::int0),
    khead(fem::int0),
    kp(fem::int0),
    L(fem::int0),
    m(fem::int0),
    n1(fem::int0),
    n10(fem::int0),
    n12(fem::int0),
    n13(fem::int0),
    n14(fem::int0),
    n15(fem::int0),
    n16(fem::int0),
    n17(fem::int0),
    n18(fem::int0),
    n2(fem::int0),
    n22(fem::int0),
    n23(fem::int0),
    n24(fem::int0),
    n26(fem::int0),
    n27(fem::int0),
    n33(fem::int0),
    n4(fem::int0),
    n5(fem::int0),
    n6(fem::int0),
    n7(fem::int0),
    n8(fem::int0),
    n9(fem::int0),
    nchd2(fem::int0),
    num2(fem::int0),
    num3(fem::int0),
    num5(fem::int0),
    numask(fem::int0),
    numbco(fem::int0),
    numbrn(fem::int0),
    numnam(fem::int0),
    pltbuf(dimension(1), fem::fill0),
    spdate(dimension(2), fem::fill0),
    spytim(dimension(2), fem::fill0),
    tim1rp(fem::double0),
    tim2rp(fem::double0),
    twhen(fem::double0),
    val1rp(fem::double0),
    val2rp(fem::double0),
    xl(fem::double0)
  {}
};

void spying(
  common& cmn) try
{
  FEM_CMN_SVE(spying);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& terra = cmn.terra;
  auto& date1= cmn.date1;
  auto& tclock= cmn.tclock;
  double& deltat = cmn.deltat;
  double& epsiln = cmn.epsiln;
  double& t = cmn.t;
  double& tmax = cmn.tmax;
  double& flzero = cmn.flzero;
  auto& flstat = cmn.flstat;
  auto& lunit4 = cmn.lunit4;
  auto& lunt14 = cmn.lunt14;
  auto& lstat = cmn.lstat;
  int& kwtspy = cmn.kwtspy;
  int& kanal = cmn.kanal;
  int& ialter = cmn.ialter;
  int& memsav = cmn.memsav;
  auto& muntsv = cmn.muntsv;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& ibr = cmn.ibr;
  int& numnvo = cmn.numnvo;
  auto& ibsout = cmn.ibsout;
  const auto& nr = cmn.nr;
  const auto& length = cmn.length;
  const auto& cik = cmn.cik;
  const auto& ci = cmn.ci;
  const auto& ck = cmn.ck;
  const auto& elp = cmn.elp;
  const auto& cu = cmn.cu;
  const auto& shp = cmn.shp;
  const auto& histq = cmn.histq;
  const auto& ismdat = cmn.ismdat;
  const auto& texvec = cmn.texvec;
  const auto& litype = cmn.litype;
  const auto& imodel = cmn.imodel;
  auto& kbus = cmn.kbus;
  auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& cki = cmn.cki;
  const auto& ckkjm = cmn.ckkjm;
  const auto& indhst = cmn.indhst;
  const auto& kodsem = cmn.kodsem;
  const auto& namebr = cmn.namebr;
  auto& bus = cmn.bus;
  double& factom = cmn.factom;
  double& tminrp = cmn.tminrp;
  double& tmaxrp = cmn.tmaxrp;
  auto& rampcn = cmn.rampcn;
  auto& rampsl = cmn.rampsl;
  auto& kyramp = cmn.kyramp;
  auto& fendrp = cmn.fendrp;
  auto& tbegrp = cmn.tbegrp;
  auto& tendrp = cmn.tendrp;
  auto& fbegrp = cmn.fbegrp;
  double& tbreak = cmn.tbreak;
  auto& indxrp = cmn.indxrp;
  const auto& ivec = cmn.ivec;
  const auto& iascii = cmn.iascii;
  int& numsym = cmn.numsym;
  int& jjroll = cmn.jjroll;
  int& maxarg = cmn.maxarg;
  int& kfile5 = cmn.kfile5;
  int& kverfy = cmn.kverfy;
  int& jword = cmn.jword;
  int& nbreak = cmn.nbreak;
  int& numcrd = cmn.numcrd;
  int& munit5 = cmn.munit5;
  int& numkey = cmn.numkey;
  int& memkar = cmn.memkar;
  auto& ksmspy = cmn.ksmspy;
  int& lockbr = cmn.lockbr;
  int& komadd = cmn.komadd;
  int& iprspy = cmn.iprspy;
  int& monitr = cmn.monitr;
  const auto& locate = cmn.locate;
  int& kbreak = cmn.kbreak;
  int& kolout = cmn.kolout;
  auto& limarr = cmn.limarr;
  auto& imin = cmn.imin;
  auto& imax = cmn.imax;
  auto& locout = cmn.locout;
  auto& intout = cmn.intout;
  auto& looprp = cmn.looprp;
  auto& n10rmp = cmn.n10rmp;
  auto& memrmp = cmn.memrmp;
  auto& symbrp = cmn.symbrp;
  auto& texpar = cmn.texpar;
  int& numex = cmn.numex;
  int& nexmod = cmn.nexmod;
  int& inchlp = cmn.inchlp;
  int& ksymbl = cmn.ksymbl;
  int& kslowr = cmn.kslowr;
  int& limcrd = cmn.limcrd;
  const auto& kbegtx = cmn.kbegtx;
  const auto& kar1 = cmn.kar1;
  int& numrmp = cmn.numrmp;
  int& luntsp = cmn.luntsp;
  bool& logvar = cmn.logvar;
  const auto& smoutv = cmn.smoutv;
  const auto& filext = cmn.filext;
  const auto& symb = cmn.symb;
  const auto& spykwd = cmn.spykwd;
  fem::str<20>& bytbuf = cmn.bytbuf;
  fem::str<80>& buff77 = cmn.buff77;
  auto& file6 = cmn.file6;
  fem::str<80>& blan80 = cmn.blan80;
  fem::str<80>& prom80 = cmn.prom80;
  const auto& digit = cmn.digit;
  fem::str<8>& ansi8 = cmn.ansi8;
  fem::str<32>& ansi32 = cmn.ansi32;
  fem::str<35>& spycd2 = cmn.spycd2;
  fem::str<80>& answ80 = cmn.answ80;
  fem::str<132>& munit6 = cmn.munit6;
  fem::str<132>& outlin = cmn.outlin;
  fem::str<132>& outsav = cmn.outsav;
  fem::str<132>& heding = cmn.heding;
  const auto& texspy = cmn.texspy;
  //
  fem::str<8>& chard7 = sve.chard7;
  double& d1 = sve.d1;
  double& d13 = sve.d13;
  double& d2 = sve.d2;
  double& d3 = sve.d3;
  double& d34 = sve.d34;
  double& d4 = sve.d4;
  double& d5 = sve.d5;
  double& d6 = sve.d6;
  double& d8 = sve.d8;
  int& i = sve.i;
  int& icomm = sve.icomm;
  int& idmxxx = sve.idmxxx;
  int& ind = sve.ind;
  int& intype = sve.intype;
  int& j = sve.j;
  int& jwdsav = sve.jwdsav;
  int& k = sve.k;
  int& k1 = sve.k1;
  int& k2 = sve.k2;
  int& k3 = sve.k3;
  int& kansav = sve.kansav;
  int& khead = sve.khead;
  int& kp = sve.kp;
  int& L = sve.L;
  int& m = sve.m;
  int& n1 = sve.n1;
  int& n10 = sve.n10;
  int& n12 = sve.n12;
  int& n13 = sve.n13;
  int& n14 = sve.n14;
  int& n15 = sve.n15;
  int& n16 = sve.n16;
  int& n17 = sve.n17;
  int& n18 = sve.n18;
  int& n2 = sve.n2;
  int& n22 = sve.n22;
  int& n23 = sve.n23;
  int& n24 = sve.n24;
  int& n26 = sve.n26;
  int& n27 = sve.n27;
  int& n33 = sve.n33;
  int& n4 = sve.n4;
  int& n5 = sve.n5;
  int& n6 = sve.n6;
  int& n7 = sve.n7;
  int& n8 = sve.n8;
  int& n9 = sve.n9;
  int& nchd2 = sve.nchd2;
  int& num2 = sve.num2;
  int& num3 = sve.num3;
  int& num5 = sve.num5;
  int& numask = sve.numask;
  int& numbco = sve.numbco;
  int& numbrn = sve.numbrn;
  int& numnam = sve.numnam;
  str_arr_ref<1> spdate(sve.spdate, dimension(2));
  str_arr_ref<1> spytim(sve.spytim, dimension(2));
  double& tim1rp = sve.tim1rp;
  double& tim2rp = sve.tim2rp;
  double& twhen = sve.twhen;
  double& val1rp = sve.val1rp;
  double& val2rp = sve.val2rp;
  double& xl = sve.xl;
  static const char* format_11312 =
    "('    Available key-word responses to the  \"SPY:\"',"
    "'  prompt are as follows:')";
  static const char* format_1269 = "(a80)";
  static const char* format_1313 = "(5x,8a9)";
  static const char* format_1760 =
    "('   ? ?  Sorry, no symbol match for  \"',a6,'\" .')";
  static const char* format_2088 = "('    Sorry, no matches.   Try again :')";
  static const char* format_2526 =
    "('   \?\? \?\?  Sorry, no such file named : ',a32)";
  static const char* format_2991 = "(a80)";
  static const char* format_3158 =
    "(3x,'T =',e13.6,3x,'TMAX =',e11.4,3x,'DELTAT =',e11.4,3x,2a4,2x,2a4)";
  static const char* format_3576 = "(i2,a32)";
  static const char* format_53614 = "(5e15.7)";
  //C     MODULE OF INTERACTIVE EMTP ONLY, WHICH SERVICES "EMTSPY".         M35.1702
  //C     THIS IS THE PRINCIPLE MODULE, CALLED BY "EMTSPY".                 M35.1703
  if (iprspy < 1) {
    goto statement_31006;
  }
  write(munit6,
    "(' ENTER \"SPYING\".  NCHAIN, JJROLL, KBREAK,',' LOCKBR, NEXMOD =',5i5,"
    "'    BUFF77(1:20) =',a20)"),
    nchain, jjroll, kbreak, lockbr, nexmod, buff77(1, 20);
  window(cmn);
  write(6, star), " TOP SPYING, KSMSPY(1:3) =", ksmspy;
  statement_31006:
  if (buff77(1, 4) != "SPY ") {
    goto statement_51006;
  }
  nexmod = 0;
  ksmspy(1) = 2;
  ksmspy(3) = 0;
  statement_51006:
  if (nexmod != 2) {
    goto statement_1007;
  }
  nexmod = 0;
  //C!GO TO NEXTSN
  statement_1007:
  if (nexmod == 3) {
    goto statement_8500;
  }
  if (nexmod == 1) {
    goto statement_3208;
  }
  if (nexmod == 7) {
    goto statement_1320;
  }
  if (nexmod >= 4) {
    goto statement_1319;
  }
  if (jjroll > 0) {
    goto statement_1520;
  }
  if (cmn.kbrser != 2) {
    goto statement_1009;
  }
  jword = 52;
  goto statement_8500;
  statement_1009:
  memkar = locint(kar1(1));
  if (kfile5 != 2) {
    goto statement_1240;
  }
  kfile5 = 0;
  goto statement_31269;
  statement_1240:
  FEM_THROW_UNHANDLED("executable assign: assign31269tonextsn");
  write(prom80, "(' SPY:')");
  statement_51269:
  goto statement_9800;
  statement_31269:
  answ80 = buff77;
  if (iprspy <= 9) {
    goto statement_39843;
  }
  write(munit6, "('  --- JUST READ ANSW80:',a80)"), answ80;
  window(cmn);
  statement_39843:
  if (answ80(1, 4) == "TYPE") {
    goto statement_2506;
  }
  if (answ80(1, 2) != "C ") {
    goto statement_1275;
  }
  if (kfile5 == 1 && kverfy == 0) {
    goto statement_51269;
  }
  if (icomm != 0) {
    goto statement_51269;
  }
  write(munit6, "(' COMMENT:',a80)"), answ80;
  window(cmn);
  goto statement_51269;
  statement_1275:
  if (answ80(1, 1) != "@") {
    goto statement_1289;
  }
  //C     $$$$$$$  KEY WORD NO. 19:  "@?"       $$$$  $$$$  $$$$  $$$$  $$$$M35.1737
  //C     NOW PROCESS USER REQUEST FOR DISK-FILE CONNECTION TO KEYBOARD (5):M35.1738
  if (kfile5 != 1) {
    goto statement_1278;
  }
  write(munit6,
    "('  === Reject  \"@\"  usage;  one such',"
    "' file is presently connected.  Try again.')");
  window(cmn);
  goto statement_1240;
  statement_1278:
  if (answ80(2, 2) != "/") {
    goto statement_51278;
  }
  answ80(1, 2) = "  ";
  frein1(cmn, answ80, komadd);
  komadd = komadd - 1;
  n13 = 6;
  goto statement_1276;
  statement_51278:
  ansi32 = "INCLSPY .DAT                    ";
  komadd = 0;
  n26 = 2;
  goto statement_2511;
  //C     OK, SO FILE IS LEGAL;  NEXT CHECK FOR ARGUMENT LIST;  EXTRACT ANY:M35.1747
  statement_1276:
  n6 = n13 + 1;
  maxarg = 0;
  FEM_DO_SAFE(j, n6, 80) {
    if (answ80(j, j) != " ") {
      goto statement_4535;
    }
  }
  goto statement_1271;
  statement_4535:
  maxarg = 0;
  FEM_DO_SAFE(idmxxx, 1, 10) {
    m = 0;
    ansi8(1, 8) = blan80(1, 8);
    FEM_DO_SAFE(L, 1, 80) {
      if (n6 > 80) {
        goto statement_4542;
      }
      if (iprspy < 1) {
        goto statement_8900;
      }
      write(munit6,
        "(' NEXT CHARACTER. L, M, N6, ANSW80(N6) =',3i5,1x,a1)"), L,
        m, n6, answ80(n6, n6);
      window(cmn);
      statement_8900:
      if (m == 0 && answ80(n6, n6) == "(") {
        answ80(n6, n6) = " ";
      }
      if (answ80(n6, n6) == ")") {
        goto statement_4544;
      }
      if (answ80(n6, n6) == " ") {
        goto statement_4541;
      }
      if (answ80(n6, n6) == ",") {
        goto statement_4544;
      }
      m++;
      if (m <= 8) {
        goto statement_4540;
      }
      write(munit6,
        "('  \?\?? ARGUMENT NUMBER',i3,"
        "'  OF  \"@?\"  HAS OVER 8 DIGITS.  TRY AGAIN.')"),
        idmxxx;
      window(cmn);
      goto statement_1240;
      statement_4540:
      ansi8(m, m) = answ80(n6, n6);
      if (ansi8(m, m) == "#") {
        ansi8(m, m) = " ";
      }
      statement_4541:
      n6++;
    }
    //C     NO ")" ON "@?"  ARGUMENT LIST MEANS WE RAN THROUGH COLUMN 80:     M35.1780
    statement_4542:
    if (m == 0) {
      goto statement_1271;
    }
    //C     ONE OR MORE NON-BLANK CHARACTERS SINCE LAST "," IS FINAL ARGUMENT:M35.1782
    maxarg++;
    texpar(maxarg) = ansi8;
    if (iprspy < 1) {
      goto statement_1271;
    }
    write(munit6, "(' MAXARG =',i8)"), maxarg;
    window(cmn);
    goto statement_1271;
    statement_4544:
    maxarg++;
    read(ansi8, "(15a1)"), texpar(maxarg);
    if (answ80(n6, n6) == ")") {
      goto statement_1271;
    }
    n6++;
  }
  write(munit6,
    "('   ? ? ?  Illegal  \"@?\"  use.','   Over 10 arguments.   Try again.')");
  window(cmn);
  goto statement_1240;
  //C     ANY ARGUMENTS HAVE BEEN SUCCESSFULLY FOUND;  NOW USE FILE         M35.1795
  statement_1271:
  kfile5 = 1;
  cmn.itexp = 0;
  goto statement_51269;
  //C       FORMER EOF S.N. 1286 WITH FILE CLOSE AND OTHER RESETTING        M38.3643
  statement_1289:
  if (answ80(1, 8) != blan80(1, 8)) {
    goto statement_1293;
  }
  //C     BLANK (JUST <CR>) REPRESENTS REQUEST FOR REPEAT "EXAMINE"         M38.3644
  goto statement_1520;
  //C     CHECK FOR  "%%%%%%%%"  FIELD OF  "@?"  ARGUMENTS;  REPLACE ANY:   M35.1804
  //C     NEXT CHECK CARD IMAGE FOR ONE OF THE "NUMKEY" KEY-WORDS:          M35.1805
  statement_1293:
  n13 = 0;
  if (answ80(1, 5) != "WAKE4") {
    goto statement_1296;
  }
  n13 = 1;
  answ80(5, 5) = " ";
  statement_1296:
  FEM_DO_SAFE(jword, 1, numkey) {
    if (answ80(1, 8) == spykwd(jword)) {
      goto statement_1307;
    }
  }
  //C     WE REACH HERE IF ILLEGAL RESPONSE TO "SPY:" PROMPT HAS BEEN READ: M35.1812
  statement_1303:
  write(munit6,
    "('   ? ? ?  Illegal SPY command  \"',a,'\" .   Try again  .....')"),
    answ80(1, 8);
  window(cmn);
  goto statement_1240;
  statement_1307:
  if (iprspy < 1) {
    goto statement_1309;
  }
  write(munit6, "('   KEYWORD FOUND IS  JWORD =',i8)"), jword;
  window(cmn);
  statement_1309:
  jwdsav = jword;
  if (jword > 63) {
    goto statement_71309;
  }
  //C       HEADING  STOP    PLOT    HELP  EXAMINE  DEPOSIT  SWITCH  (1-7)  M35.1820
  //C       APPEND   SAVE   RESTORE   GO     ECHO    FIND    LIST    (8-14) M39.3167
  //C         SPY    BREAK   WHEN  COMMENT    @?     ROLL   TYPE?   (15-21) M35.1823
  //C       VERIFY   FILES   SLEEP  SOURCE   EDIT    WAKE  LANGUAGE (22-28) M35.1825
  //C      CATALOG  BEGIN    STEP    DEBUG   DATA    RAMP    TIME   (29-35) M35.1826
  //C         TEK   BRANCH   YFORM    NOY   FACTOR    NOF    RLC    (36-42) M35.1828
  //C        WIDTH    BUS    SIZE   LIMIT    IOUT    NODE   NONLIN  (43-49) M35.1829
  //C        SPACE  LUNIT4  SERIES   LOCK     [Y]     [F]   NOROLL  (50-56) M36.1715
  //C        OPEN    CLOSE    SM     HONK   CHOICE   TACS    WAIT   (57-63) M38.3650
  switch (jword) {
    case 1: goto statement_1500;
    case 2: goto statement_9000;
    case 3: goto statement_1319;
    case 4: goto statement_1311;
    case 5: goto statement_1337;
    case 6: goto statement_1460;
    case 7: goto statement_8500;
    case 8: goto statement_1320;
    case 9: goto statement_2206;
    case 10: goto statement_2317;
    case 11: goto statement_2402;
    case 12: goto statement_3673;
    case 13: goto statement_2040;
    case 14: goto statement_2092;
    case 15: goto statement_1240;
    case 16: goto statement_2124;
    case 17: goto statement_2430;
    case 18: goto statement_2486;
    case 19: goto statement_1303;
    case 20: goto statement_1424;
    case 21: goto statement_1303;
    case 22: goto statement_2494;
    case 23: goto statement_2563;
    case 24: goto statement_2591;
    case 25: goto statement_8500;
    case 26: goto statement_8500;
    case 27: goto statement_2604;
    case 28: goto statement_8500;
    case 29: goto statement_2907;
    case 30: goto statement_2926;
    case 31: goto statement_2937;
    case 32: goto statement_2964;
    case 33: goto statement_2974;
    case 34: goto statement_3095;
    case 35: goto statement_3153;
    case 36: goto statement_3174;
    case 37: goto statement_3256;
    case 38: goto statement_3357;
    case 39: goto statement_3381;
    case 40: goto statement_3394;
    case 41: goto statement_3406;
    case 42: goto statement_8500;
    case 43: goto statement_8500;
    case 44: goto statement_8500;
    case 45: goto statement_8500;
    case 46: goto statement_8500;
    case 47: goto statement_8500;
    case 48: goto statement_8500;
    case 49: goto statement_8500;
    case 50: goto statement_8500;
    case 51: goto statement_8500;
    case 52: goto statement_8500;
    case 53: goto statement_8500;
    case 54: goto statement_8500;
    case 55: goto statement_8500;
    case 56: goto statement_8500;
    case 57: goto statement_3568;
    case 58: goto statement_3584;
    case 59: goto statement_3606;
    case 60: goto statement_3623;
    case 61: goto statement_8500;
    case 62: goto statement_8500;
    case 63: goto statement_3644;
    default: break;
  }
  stoptp(cmn);
  statement_71309:
  n14 = jword - 63;
  //C         V-I                                                   (64-64) M37.6190
  switch (n14) {
    case 1: goto statement_8500;
    default: break;
  }
  stoptp(cmn);
  //C     $$$$$$$  KEY WORD NO.  4:  "HELP"     $$$$  $$$$  $$$$  $$$$  $$$$M35.1831
  statement_1311:
  write(munit6, format_11312);
  window(cmn);
  FEM_DOSTEP(j, 1, numkey, 8) {
    n15 = j + 7;
    if (n15 > numkey) {
      n15 = numkey;
    }
    {
      write_loop wloop(munit6, format_1313);
      FEM_DO_SAFE(k, j, n15) {
        wloop, spykwd(k);
      }
    }
    window(cmn);
  }
  jword = jwdsav;
  statement_21314:
  write(prom80,
    "('       KEY-WORD OF INTEREST (ALL, <CR>,',' TOP, BOT, BACK):')");
  FEM_THROW_UNHANDLED("executable assign: assign1315tonextsn");
  goto statement_9800;
  spycd2 = buff77(1, 35);
  if (spycd2(1, 4) == "    ") {
    goto statement_11315;
  }
  if (spycd2(1, 4) == "END ") {
    goto statement_1240;
  }
  if (spycd2(1, 4) != "BOT ") {
    goto statement_51315;
  }
  jword = numkey;
  goto statement_1317;
  statement_51315:
  if (spycd2(1, 4) != "BACK") {
    goto statement_61315;
  }
  jword = jword - 1;
  if (jword > 0) {
    goto statement_1317;
  }
  jword = numkey;
  write(munit6, "('      //// wrap around, beginning to end ////')");
  window(cmn);
  goto statement_1317;
  statement_61315:
  if (spycd2(1, 4) == "TOP ") {
    goto statement_41315;
  }
  if (spycd2(1, 4) != "NEXT") {
    goto statement_21315;
  }
  statement_11315:
  jword++;
  if (jword <= numkey) {
    goto statement_1317;
  }
  if (spycd2(1, 4) == "ALL ") {
    goto statement_21314;
  }
  write(munit6, "('      //// wrap around, end to beginning ////')");
  window(cmn);
  statement_41315:
  jword = 1;
  goto statement_1317;
  statement_21315:
  jword = 1;
  if (spycd2(1, 4) == "ALL ") {
    goto statement_1317;
  }
  FEM_DO_SAFE(jword, 1, numkey) {
    if (spycd2(1, 8) == spykwd(jword)) {
      goto statement_1317;
    }
  }
  write(munit6, format_1760), spycd2;
  window(cmn);
  goto statement_1318;
  statement_1317:
  n17 = kbegtx(jword);
  n18 = kbegtx(jword + 1) - 1;
  FEM_DO_SAFE(j, n17, n18) {
    munit6(1, 81) = " " + texspy(j);
    window(cmn);
  }
  if (jword != 4) {
    goto statement_61317;
  }
  write(munit6, format_11312);
  window(cmn);
  FEM_DOSTEP(j, 1, numkey, 8) {
    {
      write_loop wloop(munit6, format_1313);
      FEM_DO_SAFE(k, j, j + 7) {
        wloop, spykwd(k);
      }
    }
    window(cmn);
  }
  statement_61317:
  jwdsav = jword;
  if (spycd2(1, 4) != "ALL ") {
    goto statement_1318;
  }
  quiter(cmn);
  if (kwtspy == 0) {
    goto statement_11315;
  }
  kwtspy = 0;
  statement_1318:
  goto statement_21314;
  //C     $$$$$$$  KEY WORD NO.  3:  "PLOT"     $$$$  $$$$  $$$$  $$$$  $$$$M35.1879
  statement_1319:
  rtmplt(cmn);
  if (nexmod >= 4) {
    goto statement_9803;
  }
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO.  8:  "APPEND"   $$$$  $$$$  $$$$  $$$$  $$$$M39.3168
  statement_1320:
  append();
  if (nexmod == 7) {
    goto statement_9803;
  }
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO.  5:  "EXAMINE"  $$$$  $$$$  $$$$  $$$$  $$$$M35.1885
  statement_1337:
  numex = 0;
  khead = 2;
  heding = " ";
  goto statement_1460;
  //C     ENCODE HEADING BUFFER WITH VARIABLE REQUEST NOW KNOWN:            M35.1889
  statement_1340:
  numex++;
  intout(numex) = intype;
  if (nchd2 < 6) {
    spycd2(nchd2 + 1, 6) = blan80(nchd2 + 1, 6);
  }
  n14 = n1;
  statement_1354:
  if (n14 > n2) {
    goto statement_1460;
  }
  heding(khead, khead + 14) = blan80(khead, khead + 14);
  //C     REALS OR VECTORS OCCUPY 15 COLS, SO CAN BE SHIFTED:               M35.1902
  if (intype == 0 || ivec(ind) == 1 || n2 != 1) {
    khead += 2;
  }
  //C     REAL SCALARS CAN BE SHIFTED 3 MORE COLUMNS:                       M35.1905
  if (intype == 0 && ivec(ind) == 0 && n2 == 1) {
    khead += 3;
  }
  //C     NEXT SEE IF SYMBOL CAN BE PROFITABLY CENTERED IN 6-COLUMN SLOT:   M35.1908
  n15 = 6;
  if (nchd2 <= 4) {
    goto statement_1373;
  }
  if (nchd2 == 6) {
    goto statement_1377;
  }
  if (heding(khead - 1, khead - 1) == " ") {
    goto statement_1377;
  }
  n17 = 1;
  goto statement_1374;
  statement_1373:
  n17 = (6 - nchd2) / 2;
  statement_1374:
  khead += n17;
  n15 = n15 - n17;
  statement_1377:
  heding(khead, khead + 5) = spycd2(1, 6);
  khead += n15;
  //C     REAL SCALARS END UP WITH FOUR BLANKS ON THE RIGHT:                M35.1922
  if (intype == 0 && ivec(ind) == 0 && n2 == 1) {
    khead += 4;
  }
  locout(numex) = ind;
  imin(numex) = n1;
  imax(numex) = n2;
  //C     IF ( IVEC(IND)  .EQ.  0 )   GO TO 1460    ! ORIGINAL RECORD.      M35.1928
  //C     NEXT WE WANT TO EXECUTE S.N. 1394 IF SUBSCRIPTING IS INVOLVED:    M35.1929
  if (ivec(ind) == 1) {
    goto statement_1394;
  }
  if (n1 == 1 && n2 == 1) {
    goto statement_1460;
  }
  statement_1394:
  write(ansi8, "('(',i4,') ')"), n14;
  heding(khead, khead + 6) = ansi8(1, 7);
  khead += 7;
  n14++;
  goto statement_1354;
  //C     $$$$$$$  KEY WORD NO. 20:  "ROLL"     $$$$  $$$$  $$$$  $$$$  $$$$M35.1939
  statement_1424:
  jjroll = 1;
  goto statement_1496;
  //C     $$$$$$$  KEY WORD NO.  6:  "DEPOSIT"  $$$$  $$$$  $$$$  $$$$  $$$$M35.1943
  statement_1460:
  write(prom80, "('  SEND EMTP VARIABLE:')");
  FEM_THROW_UNHANDLED("executable assign: assign1485tonextsn");
  goto statement_9800;
  spycd2 = buff77(1, 35);
  if (spycd2(1, 1) != "C" || spycd2(2, 2) != " ") {
    goto statement_1491;
  }
  if (icomm != 0) {
    goto statement_1460;
  }
  write(munit6, "(' COMMENT:',a35)"), spycd2;
  window(cmn);
  goto statement_1460;
  statement_1491:
  if (spycd2(1, 4) != "END ") {
    goto statement_1720;
  }
  //C     IF PROCESSING "DEPOSIT" = SPYKWD(6), THEN BACK TO "SPY:":         M36.1728
  statement_1496:
  if (answ80(1, 8) == spykwd(6)) {
    goto statement_1240;
  }
  //C     IF INTERNAL "DEPOSIT" ISSUED FROM "RAMP"= SPYKWD(34), RETURN:     M36.1730
  if (answ80(1, 8) == spykwd(34)) {
    goto statement_3138;
  }
  //C     IF INTERNAL "DEPOSIT", ISSUED FROM "RESTORE", THEN BACK TO "SPY:":M35.1961
  if (answ80(1, 8) == spykwd(10)) {
    goto statement_1240;
  }
  //C     OK, THIS IS "EXAMINE";  FIRST, BLANK UNUSED RIGHT PORTION:        M38.3680
  if (khead < 132) {
    heding(khead + 1, 132) = " ";
  }
  //C     IF DISK FILE IS CONNECTED TO UNIT 5, WE WANT RETURN TO  "SPY:" :  M35.1962
  if (kfile5 == 1) {
    goto statement_1240;
  }
  //C     $$$$$$$  KEY WORD NO.  1:  "HEADING"  $$$$  $$$$  $$$$  $$$$  $$$$M35.1964
  statement_1500:
  munit6 = heding;
  window(cmn);
  //C     FOLLOWING CODE OUTPUTS TABLE DUMPING IN ACCORD WITH EARLIER       M35.1969
  //C     SETUP USING  "EXAMINE"  SPECIFICATION.                            M35.1970
  statement_1520:
  examin(cmn);
  if (jjroll == 0) {
    goto statement_1682;
  }
  jjroll++;
  if (jjroll <= 2) {
    goto statement_1669;
  }
  quiter(cmn);
  if (kwtspy == 0) {
    goto statement_1523;
  }
  jjroll = 0;
  goto statement_1240;
  statement_1523:
  if (outsav == outlin) {
    goto statement_1684;
  }
  statement_1669:
  outsav = outlin;
  //C     OUTPUT LINE OF "EXAMINE" IS ALL BUILT;  DISPLAY IT:               M37.6236
  statement_1682:
  if (kfile5 != 1 && jjroll == 0 && kolout <= 81) {
    goto statement_1685;
  }
  munit6 = outlin;
  window(cmn);
  prom80(1, 8) = blan80(1, 8);
  statement_1684:
  if (jjroll > 0) {
    goto statement_9833;
  }
  goto statement_1714;
  statement_1685:
  prom80 = outlin(1, kolout - 1);
  statement_1714:
  FEM_THROW_UNHANDLED("executable assign: assign31269tonextsn");
  goto statement_9800;
  //C     PROCESS EMTP SYMBOL NAME (SPYCD2) WHICH HAS JUST BEEN READ;       M35.2093
  statement_1720:
  nchd2 = 0;
  n13 = 0;
  FEM_DO_SAFE(j, 1, 8) {
    if (spycd2(j, j) == "(") {
      goto statement_1726;
    }
    if (spycd2(j, j) == ",") {
      goto statement_1726;
    }
    if (spycd2(j, j) != " ") {
      goto statement_1721;
    }
    if (nchd2 == 0) {
      nchd2 = j - 1;
    }
    goto statement_1723;
    statement_1721:
    if (spycd2(j, j) != "=") {
      goto statement_1723;
    }
    n13 = j;
    if (nchd2 == 0) {
      nchd2 = j - 1;
    }
    statement_1723:;
  }
  n1 = 1;
  n2 = 1;
  j = n13;
  if (n13 == 0) {
    j = 7;
  }
  goto statement_1735;
  statement_1726:
  if (nchd2 == 0) {
    nchd2 = j - 1;
  }
  n9 = 0;
  FEM_DO_SAFE(k, j, 20) {
    if (spycd2(k, k) != "-") {
      goto statement_1727;
    }
    n12 = -1;
    goto statement_1733;
    statement_1727:
    if (spycd2(k, k) == " ") {
      goto statement_1733;
    }
    if (spycd2(k, k) != "=") {
      goto statement_21727;
    }
    n13 = k;
    goto statement_1734;
    statement_21727:
    FEM_DO_SAFE(i, 1, 10) {
      if (spycd2(k, k) == digit(i)) {
        goto statement_1730;
      }
    }
    if (n9 > 0) {
      limarr(n9) = limarr(n9) * n12;
    }
    //C     NON-DIGIT MEANS WE INITIALIZE FOR NEXT NUMBER TO BE BUILT:        M35.2125
    n9++;
    n12 = 1;
    limarr(n9) = 0;
    goto statement_1733;
    statement_1730:
    if (i == 10) {
      i = 0;
    }
    limarr(n9) = 10 * limarr(n9) + i;
    statement_1733:;
  }
  statement_1734:
  n1 = limarr(1);
  n2 = limarr(2);
  if (n9 <= 2) {
    n2 = n1;
  }
  statement_1735:
  spycd2(j, 8) = blan80(j, 8);
  //C     NEXT IDENTIFY THE EMTP NAME INVOLVED IN THIS REQUEST:             M35.2138
  FEM_DO_SAFE(ind, 1, numsym) {
    if (spycd2(1, 8) == symb(ind)) {
      goto statement_1780;
    }
  }
  write(munit6, format_1760), spycd2;
  window(cmn);
  goto statement_1460;
  statement_1780:
  intype = 0;
  if (spycd2(1, 1) == "I") {
    intype = 1;
  }
  if (spycd2(1, 1) == "J") {
    intype = 1;
  }
  if (spycd2(1, 1) == "K") {
    intype = 1;
  }
  if (spycd2(1, 1) == "L") {
    intype = 1;
  }
  if (spycd2(1, 1) == "M") {
    intype = 1;
  }
  if (spycd2(1, 1) == "N") {
    intype = 1;
  }
  if (ivec(ind) == 1 || n2 <= n1) {
    goto statement_31807;
  }
  write(munit6,
    "('    Note :  This is a vector dump using a scalar',' EMTP variable.')");
  window(cmn);
  statement_31807:
  if (answ80(1, 8) == spykwd(5)) {
    goto statement_1340;
  }
  if (answ80(1, 8) == spykwd(34)) {
    goto statement_3134;
  }
  //C     FOR THE CASE OF "DEPOSIT", THE USER-DESIRED VALUE MUST BE READ:   M35.2156
  if (n13 == 0) {
    goto statement_1837;
  }
  if (iascii(ind) == 1) {
    goto statement_1819;
  }
  n13++;
  n22 = 0;
  FEM_DO_SAFE(j, n13, 35) {
    if (spycd2(j, j) == " ") {
      goto statement_1813;
    }
    n22++;
    if (n22 <= 20) {
      goto statement_1808;
    }
    write(munit6, "(' Sorry, SPY buffer overflow.  Try again ....')");
    window(cmn);
    goto statement_1837;
    statement_1808:
    bytbuf(n22, n22) = spycd2(j, j);
    statement_1813:;
  }
  if (n22 < 20) {
    bytbuf(n22 + 1, 20) = blan80(n22 + 1, 20);
  }
  //C     FOLLOWING CODE IS FOR ALPHANUMERIC EMTP SYMBOL AFTER "=" :        M35.2172
  statement_1819:
  ansi8(1, 6) = spycd2(n13 + 1, n13 + 6);
  if (iprspy < 1) {
    goto statement_1824;
  }
  write(munit6, "(' ANSI8 AFTER ALPHANUMERIC TRANSFER =',a)"), ansi8;
  window(cmn);
  statement_1824:
  goto statement_1846;
  //C     NO EQUAL SIGN MEANS THAT WE PROMPT FOR SEPARATE NUMBER:           M35.2179
  statement_1837:
  write(prom80, "(4x,'NEW VALUE:')");
  FEM_THROW_UNHANDLED("executable assign: assign1842tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  if (iascii(ind) == 0) {
    goto statement_1844;
  }
  ansi8(1, 6) = bytbuf(1, 6);
  goto statement_1846;
  //C     FOLLOWING CODE FIRST CHECKS 20-COLUMN "BYTBUF" WORKING VECTOR     M35.2192
  //C     FOR A LEGAL FORTRAN NUMBER;  THEN FREE-FORMAT WRITE/READ GETS IT: M35.2193
  statement_1844:
  numchk(cmn, bytbuf, 20, n33);
  if (n33 == 1) {
    goto statement_1837;
  }
  frefp1(cmn, bytbuf, d4);
  statement_1846:
  deposi(cmn, ind, intype, n1, n2, d4);
  goto statement_1460;
  //C     $$$$$$$  KEY WORD NO. 13:  "FIND"     $$$$  $$$$  $$$$  $$$$  $$$$M35.2222
  statement_2040:
  write(munit6, "(1x,'    Symbol      Word   Address      Next')");
  window(cmn);
  statement_2043:
  write(prom80, "('      index   address    change      symbol :')");
  statement_2050:
  FEM_THROW_UNHANDLED("executable assign: assign2048tonextsn");
  goto statement_9800;
  spycd2 = buff77(1, 35);
  if (spycd2(1, 8) == "END     ") {
    goto statement_1240;
  }
  if (spycd2(1, 8) == "STOP    ") {
    goto statement_1240;
  }
  if (spycd2(1, 8) != blan80(1, 8)) {
    goto statement_2052;
  }
  write(prom80,
    "('   ? ? ?  Blank EMTP symbol is clearly wrong.','  Try again :')");
  goto statement_2050;
  //C     FIRST WE MUST SEE IF  "SPYCD2"  HAS ANY WILD-CARD CHARACTERS:     M35.2234
  statement_2052:
  FEM_DO_SAFE(i, 1, 8) {
    if (spycd2(i, i) == "*") {
      goto statement_2069;
    }
  }
  //C     SIMPLE CASE WITH NO WILD-CARD CHARACTERS:                         M35.2238
  FEM_DO_SAFE(ind, 1, numsym) {
    if (spycd2(1, 8) == symb(ind)) {
      goto statement_2063;
    }
  }
  write(munit6, format_2088);
  window(cmn);
  goto statement_2050;
  statement_2063:
  n4 = locate(ind) - n5;
  n5 = locate(ind);
  write(prom80, "(1x,3i10,4x,':')"), ind, n5, n4;
  prompt(cmn);
  goto statement_2050;
  //C     BEGIN SEARCH FOR CASE WHERE "D2" HAS ONE OR MORE WILD CARDS ("*"):M35.2248
  statement_2069:
  n4 = 0;
  FEM_DO_SAFE(ind, 1, numsym) {
    chard7 = symb(ind);
    n7 = 1;
    n2 = 1;
    //C     ENTER LOOP WHICH COMPARES  CHARD2(N2)  AGAINST  CHARD7(N7):       M35.2254
    statement_2071:
    if (spycd2(n2, n2) != "*") {
      goto statement_2079;
    }
    //C     ENTER CODE WHERE "*" IMPLIES SKIPPING INDETERMINATE NUMBER OF     M35.2256
    //C     CHARACTERS IN  "D7" :                                             M35.2257
    statement_2072:
    n2++;
    if (n2 >= 9) {
      goto statement_2081;
    }
    if (spycd2(n2, n2) == "*") {
      goto statement_2072;
    }
    if (spycd2(n2, n2) == " ") {
      goto statement_2081;
    }
    //C     NONBLANK  SPYCD2(N2:N2) MEANS WE MUST SEARCH "D7" FOR IT:         M35.2262
    FEM_DO_SAFE(i, n7, 6) {
      if (chard7(i, i) == spycd2(n2, n2)) {
        goto statement_2077;
      }
    }
    goto statement_2086;
    statement_2077:
    n2++;
    n7 = i + 1;
    if (n2 >= 9) {
      goto statement_2081;
    }
    goto statement_2071;
    //C     NOW WE ARE READY TO CHECK CHARACTERS OF TWO WORDS FOR MATCH:      M35.2271
    statement_2079:
    if (spycd2(n2, n2) != chard7(n7, n7)) {
      goto statement_2086;
    }
    n2++;
    n7++;
    if (n2 >= 9) {
      goto statement_2081;
    }
    if (spycd2(n2, n2) != " ") {
      goto statement_2071;
    }
    //C     BLANK IN "D2" MEANS SUCCESS;  WE HAVE FOUND A MATCH.  NOW OUTPUT: M35.2277
    statement_2081:
    n4 = locate(ind) - n5;
    n6 = locate(ind);
    write(munit6, "(1x,3i10,6x,a6,' = Name  ')"), ind, n6, n4, chard7;
    window(cmn);
    statement_2086:
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_2087;
    }
    kwtspy = 0;
    goto statement_2040;
    statement_2087:;
  }
  if (n4 != 0) {
    goto statement_2043;
  }
  write(prom80, format_2088);
  goto statement_2050;
  //C     $$$$$$$  KEY WORD NO. 14:  "LIST"     $$$$  $$$$  $$$$  $$$$  $$$$M35.2293
  statement_2092:
  write(munit6,
    "('    Row    Symbol    Word    Vector?    Ascii?   Next',5x,i4,"
    "' Symbols')"),
    numsym;
  window(cmn);
  write(prom80, "('  Number    Name   Address   (Yes=1)   (Yes=1)   :')");
  n33 = 0;
  statement_2099:
  FEM_THROW_UNHANDLED("executable assign: assign2101tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  if (bytbuf(1, 4) == "END ") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) == "STOP") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) != "    " && bytbuf(1, 4) != "NEXT") {
    goto statement_2102;
  }
  n1 = n2 + 1;
  n2 = n1;
  goto statement_2108;
  statement_2102:
  if (bytbuf(1, 4) != "TOP ") {
    goto statement_2103;
  }
  n1 = 1;
  n2 = 1;
  goto statement_2109;
  statement_2103:
  if (bytbuf(1, 4) != "BOT ") {
    goto statement_2105;
  }
  n1 = numsym;
  n2 = numsym;
  goto statement_2109;
  statement_2105:
  if (bytbuf(1, 4) != "ALL ") {
    goto statement_2107;
  }
  n1 = 1;
  n2 = numsym;
  goto statement_2109;
  statement_2107:
  frein2(cmn, bytbuf, n1, n2);
  statement_2108:
  if (n1 <= 0) {
    n1 = 1;
  }
  if (n1 > numsym) {
    n1 = numsym;
  }
  if (n2 <= n1) {
    n2 = n1;
  }
  if (n2 > numsym) {
    n2 = numsym;
  }
  statement_2109:
  FEM_DO_SAFE(i, n1, n2 - 1) {
    write(munit6, "(i8,4x,a6,i9,i8,i10)"), i, symb(i), locate(i),
      ivec(i), iascii(i);
    window(cmn);
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_2116;
    }
    kwtspy = 0;
    goto statement_2092;
    statement_2116:;
  }
  write(prom80, "(i8,4x,a6,i9,i8,i10,4x,':')"), n2, symb(n2), locate(n2),
    ivec(n2), iascii(n2);
  goto statement_2099;
  //C     $$$$$$$  KEY WORD NO. 16:  "BREAK"    $$$$  $$$$  $$$$  $$$$  $$$$M35.2314
  statement_2124:
  write(prom80, "('   SEND  T-break  IN',' SEC. (\"-\" MEANS STEP #):')");
  FEM_THROW_UNHANDLED("executable assign: assign2126tonextsn");
  goto statement_9800;
  frefp1(cmn, buff77, tbreak);
  nbreak = 16;
  if (tbreak > 0.0f) {
    goto statement_2142;
  }
  if (tbreak == 0.0f) {
    goto statement_2131;
  }
  d13 = -tbreak * deltat;
  write(munit6,
    "('    Ok, using  DELTAT =',e12.3,'  this gives  T-break =',e13.5)"),
    deltat, d13;
  window(cmn);
  tbreak = d13;
  goto statement_2142;
  statement_2131:
  write(prom80, "('    SEND UTPF OVERLAY NUMBER NCHAIN FOR',' THE BREAK :')");
  FEM_THROW_UNHANDLED("executable assign: assign2139tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, nbreak);
  if (nbreak <  - 1 || nbreak > 20) {
    goto statement_2131;
  }
  if (nbreak != 16) {
    tbreak = -9876.e33f;
  }
  statement_2142:
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO.  9:  "SAVE"     $$$$  $$$$  $$$$  $$$$  $$$$M35.2323
  statement_2206:
  tmax = t - epsiln;
  if (twhen > flzero) {
    tmax = twhen;
  }
  memsav = 16;
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 10:  "RESTORE"  $$$$  $$$$  $$$$  $$$$  $$$$M35.2328
  statement_2317:
  tmax = t - epsiln;
  if (twhen > flzero) {
    tmax = twhen;
  }
  memsav = 1016;
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 11:  "GO"       $$$$  $$$$  $$$$  $$$$  $$$$M35.2333
  statement_2402:
  lockbr = 0;
  if (iprspy < 1) {
    goto statement_2409;
  }
  write(munit6, "(' \"GO\" ACKNOWLEDGED, SET LOCKBR = 0.')");
  window(cmn);
  statement_2409:
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 17:  "WHEN"     $$$$  $$$$  $$$$  $$$$  $$$$M35.2338
  statement_2430:
  write(prom80,
    "('  SUPPLY TMAX FOR \"SAVE\" & \"RESTORE\"  [',f8.4,' ] :')"),
    twhen;
  FEM_THROW_UNHANDLED("executable assign: assign2436tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  if (bytbuf(1, 4) == "    ") {
    goto statement_2439;
  }
  frefp1(cmn, bytbuf, d34);
  if (d34 > 0.0f) {
    twhen = d34;
  }
  statement_2439:
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 18:  "COMMENT"  $$$$  $$$$  $$$$  $$$$  $$$$M35.2352
  statement_2486:
  if (icomm == 0) {
    goto statement_2491;
  }
  icomm = 0;
  write(munit6, "('   Begin displaying comment cards of  \"@\"  usage.')");
  window(cmn);
  goto statement_1240;
  statement_2491:
  icomm = 1;
  write(munit6, "('   Stop showing comment cards of  \"@\"  usage.')");
  window(cmn);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 22:  "VERIFY"   $$$$  $$$$  $$$$  $$$$  $$$$M35.2358
  statement_2494:
  if (kverfy == 0) {
    goto statement_2497;
  }
  kverfy = 0;
  write(munit6, "('   Begin echoing commands of  \"@\"  file usage.')");
  window(cmn);
  goto statement_1240;
  statement_2497:
  kverfy = 1;
  write(munit6, "('   Stop echoing commands of  \"@\"  file usage.')");
  window(cmn);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 21:  "TYPE?"    $$$$  $$$$  $$$$  $$$$  $$$$M35.2364
  statement_2506:
  n16 = 0;
  n26 = 5;
  ansi32 = "INCLSPY .DAT                    ";
  if (iprspy < 1) {
    goto statement_2509;
  }
  write(munit6,
    "('   Start \"TYPE\" service.  ANSW80(1:20) =',a20)"), answ80(1,
    20);
  window(cmn);
  statement_2509:
  if (answ80(5, 7) == "?  ") {
    n16 = 1;
  }
  if (answ80(5, 7) == " ? ") {
    n16 = 1;
  }
  if (answ80(5, 7) == "  ?") {
    n16 = 1;
  }
  if (answ80(1, 8) == "TYPE    ") {
    n16 = 1;
  }
  if (n16 == 0) {
    goto statement_2511;
  }
  n18 = 0;
  goto statement_2548;
  statement_2511:
  n12 = 0;
  n13 = 0;
  FEM_DO_SAFE(j, n26, 32) {
    if (n12 > 0) {
      goto statement_2514;
    }
    if (answ80(j, j) == " ") {
      goto statement_2517;
    }
    n12 = j;
    statement_2514:
    if (answ80(j, j) == " ") {
      goto statement_2519;
    }
    n13 = j;
    statement_2517:;
  }
  statement_2519:
  if (iprspy < 1) {
    goto statement_32521;
  }
  write(munit6, "(' FILE NAME BOUNDED.  N12, N13 =',2i5)"), n12, n13;
  window(cmn);
  statement_32521:
  if (n13 != n12) {
    goto statement_2524;
  }
  ansi32(8, 8) = answ80(n12, n12);
  FEM_DO_SAFE(i, 1, 9) {
    if (answ80(n12, n12) == digit(i) && filext(i) == "X") {
      goto statement_2536;
    }
  }
  write(munit6, format_2526), answ80(n12, n12);
  window(cmn);
  goto statement_1240;
  statement_2524:
  cmn.io.inquire_file(answ80(n12, n13))
    .exist(logvar);
  if (logvar) {
    goto statement_2529;
  }
  write(munit6, format_2526), answ80(n12, n13);
  window(cmn);
  goto statement_1240;
  statement_2529:
  ansi32 = blan80(1, 32);
  ansi32(1, n13 - n12 + 1) = answ80(n12, n13);
  if (answ80(1, 1) == "@") {
    goto statement_2536;
  }
  write(munit6, "(20x,' ******  Listing of file : ',a32)"), ansi32;
  window(cmn);
  statement_2536:
  muntsv(1) = munit5;
  munit5 = muntsv(2);
  statement_2537:
  cmn.io.open(munit5, ansi32)
    .status("OLD");
  if (answ80(1, 1) == "@") {
    goto statement_1276;
  }
  FEM_DO_SAFE(i, 1, 9999) {
    quiter(cmn);
    if (kwtspy == 0) {
      goto statement_2538;
    }
    kwtspy = 0;
    goto statement_2545;
    statement_2538:
    try {
      read(munit5, format_1269), buff77;
    }
    catch (fem::read_end const&) {
      goto statement_2545;
    }
    write(munit6, "(' Line',i4,': ',a80)"), i, buff77;
    window(cmn);
  }
  statement_2545:
  cmn.io.close(munit5)
    .status("KEEP");
  if (n16 == 0) {
    goto statement_2551;
  }
  statement_2548:
  n18++;
  if (n18 == 10) {
    goto statement_2551;
  }
  if (filext(n18) != "X") {
    goto statement_2548;
  }
  ansi32(8, 8) = digit(n18);
  goto statement_2537;
  statement_2551:
  munit5 = muntsv(1);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 23:  "FILES"    $$$$  $$$$  $$$$  $$$$  $$$$M35.2419
  //C     "FILES"  RESULTS IN A DISPLAY OF THE STATUS OF "@?" FILES, AS     M35.2420
  //C     PREVIOUSLY DETERMINED BY  "INITSP"  AS SIMULATION BEGAN.          M35.2421
  statement_2563:
  {
    write_loop wloop(munit6, "('   File number :',9i5)");
    FEM_DO_SAFE(j, 1, 9) {
      wloop, j;
    }
  }
  window(cmn);
  {
    write_loop wloop(munit6, "('   INCLSPY?.DAT:',9(4x,a1))");
    FEM_DO_SAFE(j, 1, 9) {
      wloop, filext(j);
    }
  }
  window(cmn);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 24:  "SLEEP"    $$$$  $$$$  $$$$  $$$$  $$$$M35.2426
  //C     "SLEEP"  PROVIDES FOR EXIT TO OVERLAY 20, FOLLOWED BY THE         M35.2427
  //C     SAVING OF EMTP TABLES ON DISK.   THE SUBSEQUENT USE OF            M35.2428
  //C     "WAKE" CAN REVIVE THE SUSPENDED SIMULATION.                       M35.2429
  statement_2591:
  tmax = -9999.f;
  memsav = 2016;
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 25:  "WAKE"     $$$$  $$$$  $$$$  $$$$  $$$$M35.2433
  statement_2604:
  write(munit6, "('     Begin  \"WAKE\"  processing.')");
  window(cmn);
  if (n13 != 1) {
    goto statement_2611;
  }
  //C     REGENERATE HEADER OF PLOT FILE ATTACHED TO UNIT LUNIT4:           M35.2435
  write(munit6, "('    Start regenerating LUNIT4 header.')");
  window(cmn);
  cmn.io.rewind(lunit4);
  read(lunit4, fem::unformatted), date1, tclock, numnam, numnvo, numbco, numbrn;
  if (cmn.lbus >= numnam && cmn.lsiz12 >= numnvo && cmn.lbrnch >= numbrn) {
    goto statement_2608;
  }
  write(munit6,
    "('   $$$$  Overflow.  EMTP List Sizes',"
    "' are too small to regenerate the header',"
    "' information of the plot file.')");
  window(cmn);
  write(munit6,
    "('       Abort this command.  Sorry.','   NUMNAM, NUMNVO, NUMBRN =',3i5)"),
    numnam, numnvo, numbrn;
  window(cmn);
  goto statement_1240;
  statement_2608:
  cmn.io.rewind(lunit4);
  {
    read_loop rloop(cmn, lunit4, fem::unformatted);
    rloop, date1, tclock, numnam, numnvo, numbco, numbrn;
    FEM_DO_SAFE(j, 1, numnam) {
      rloop, bus(j);
    }
  }
  if (numnvo > 0) {
    {
      read_loop rloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(j, 1, numnvo) {
        rloop, ibsout(j);
      }
    }
  }
  if (numbrn > 0) {
    {
      read_loop rloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(j, 1, numbrn) {
        rloop, kbus(j), mbus(j);
      }
    }
  }
  cmn.io.rewind(lunit4);
  {
    write_loop wloop(cmn, lunit4, fem::unformatted);
    wloop, date1, tclock, numnam, numnvo, numbco, numbrn;
    FEM_DO_SAFE(j, 1, numnam) {
      wloop, bus(j);
    }
  }
  if (numnvo > 0) {
    {
      write_loop wloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(j, 1, numnvo) {
        wloop, ibsout(j);
      }
    }
  }
  if (numbrn > 0) {
    {
      write_loop wloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(j, 1, numbrn) {
        wloop, kbus(j), mbus(j);
      }
    }
  }
  statement_2611:
  runtym(d1, d2);
  pfatch(cmn);
  tables(cmn);
  flstat(1) = -d1;
  flstat(2) = -d2;
  if (lstat(16) == cmn.ltlabl) {
    goto statement_2614;
  }
  write(munit6,
    "('   \?\?\?\?  Sorry, present EMTP dimensions',"
    "' do not agree with those of the disk file')");
  window(cmn);
  write(munit6,
    "(9x,'just attached.  Sleeping simulation can not',"
    "' be awakened.  Abort the command.  Sorry.')");
  window(cmn);
  goto statement_1240;
  statement_2614:
  kill = 7733;
  lstat(15) = 16;
  goto statement_2402;
  //C     $$$$$$$  KEY WORD NO. 29:  "CATALOG"  $$$$  $$$$  $$$$  $$$$  $$$$M35.2478
  statement_2907:
  write(prom80, "(' SEND COMPLETE, LEGAL DISK-FILE NAME:')");
  FEM_THROW_UNHANDLED("executable assign: assign2913tonextsn");
  goto statement_9800;
  ansi32 = buff77(1, 32);
  if (ansi32 == blan80(1, 32)) {
    ansi32 = "SPYDATA                         ";
  }
  cmn.io.close(luntsp);
  cmn.io.open(luntsp, ansi32)
    .status("NEW");
  n1 = 1;
  n2 = 80;
  FEM_DO_SAFE(j, 1, numcrd) {
    write(luntsp, format_1269), file6(j);
  }
  write(munit6,
    "('    ---- Write to disk via unit',i4,"
    "'   is now complete.  Number of cards =',i5)"),
    luntsp, numcrd;
  window(cmn);
  cmn.io.close(luntsp)
    .status("KEEP");
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 30:  "BEGIN"    $$$$  $$$$  $$$$  $$$$  $$$$M35.2494
  statement_2926:
  kill = 7733;
  cmn.llbuff = -3333;
  lstat(15) = 1;
  cmn.indbuf = 0;
  cmn.mflush = 0;
  goto statement_2402;
  //C     $$$$$$$  KEY WORD NO. 31:  "STEP"     $$$$  $$$$  $$$$  $$$$  $$$$M35.2501
  statement_2937:
  if (kbreak == 0) {
    goto statement_2944;
  }
  write(munit6, "('   ---  Toggle to \"off\"  (no more STEPping)')");
  window(cmn);
  goto statement_2946;
  statement_2944:
  write(munit6, "('   ---  Toggle to \"on\"  (begin STEPping)')");
  window(cmn);
  statement_2946:
  kbreak++;
  if (kbreak >= 2) {
    kbreak = 0;
  }
  if (kbreak == 1) {
    lockbr = 1;
  }
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 32:  "DEBUG"    $$$$  $$$$  $$$$  $$$$  $$$$M35.2513
  statement_2964:
  write(prom80, "('   SEND NEW \"IPRSPY\" VALUE  [',i3,'  ] :')"), iprspy;
  FEM_THROW_UNHANDLED("executable assign: assign2969tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, iprspy);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 33:  "DATA"     $$$$  $$$$  $$$$  $$$$  $$$$M35.2522
  statement_2974:
  n12 = 1;
  n13 = 9999;
  n14 = 1;
  n15 = 0;
  statement_2975:
  write(prom80, "('   SEND EMTP DATA FILE NAME (CONTROL) :')");
  FEM_THROW_UNHANDLED("executable assign: assign2979tonextsn");
  goto statement_9800;
  ansi32 = buff77(1, 32);
  if (ansi32(1, 8) != "CONTROL ") {
    goto statement_2984;
  }
  write(prom80, "(' SEND DISK CARD NUMBERS N-beg AND N-end :')");
  FEM_THROW_UNHANDLED("executable assign: assign32981tonextsn");
  goto statement_9800;
  frein2(cmn, buff77, n12, n13);
  write(prom80, "(' SEND N-beg IN EMTP, LUNIT5 OFFSET :')");
  FEM_THROW_UNHANDLED("executable assign: assign2983tonextsn");
  goto statement_9800;
  frein2(cmn, buff77, n14, n15);
  goto statement_2975;
  statement_2984:
  if (iprspy < 1) {
    goto statement_32985;
  }
  write(munit6, "(' PREPARE TO OPEN.  N12, N13, N14, N15 =',4i8)"),
    n12, n13, n14, n15;
  window(cmn);
  statement_32985:
  cmn.io.close(lunt14);
  cmn.io.open(lunt14, ansi32)
    .status("UNKNOWN");
  if (iprspy < 1) {
    goto statement_2987;
  }
  write(munit6, "(' AFTER FILE OPEN (IT WORKED).')");
  window(cmn);
  statement_2987:
  FEM_DO_SAFE(L, 1, n13) {
    if (L >= n12) {
      goto statement_2988;
    }
    read(lunt14, format_2991), ansi8;
    goto statement_2994;
    statement_2988:
    try {
      read(lunt14, format_2991), file6(n14);
    }
    catch (fem::read_end const&) {
      goto statement_2998;
    }
    if (file6(n14)(1, 4) == "EOF ") {
      goto statement_2998;
    }
    n14++;
    if (n14 <= limcrd) {
      goto statement_2994;
    }
    write(munit6,
      "('   ****  WARNING.   CARD IMAGE BUFFER HAS',"
      "' FILLED.  DISK READ IS TRUNCATED.')");
    window(cmn);
    write(munit6,
      "('                    STORAGE CAPACITY IN',' CARDS = LIMCRD =',i5)"),
      limcrd;
    window(cmn);
    goto statement_2998;
    statement_2994:;
  }
  write(munit6,
    "('    NOTE :  NO  END-OF-FILE  ENCOUNTERED.',"
    "'   STOP READING AFTER CARD NUMBER',i5)"),
    n13;
  window(cmn);
  statement_2998:
  if (numcrd < n14) {
    numcrd = n14 - 1;
  }
  write(munit6,
    "(i9,'  =  NUMCRD  (upper bound on card-image',"
    "' storage in FILE6 cache).')"),
    numcrd;
  window(cmn);
  if (L > 1) {
    goto statement_3006;
  }
  write(munit6,
    "('  ? ? ? ? ?   Warning.  Data file is empty.',"
    "'   Did user misspell the file name?')");
  window(cmn);
  statement_3006:
  cmn.io.close(lunt14);
  cmn.numdcd = n15;
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 34:  "RAMP"     $$$$  $$$$  $$$$  $$$$  $$$$M35.2578
  statement_3095:
  if (numrmp <= 0) {
    goto statement_3099;
  }
  //C     BEGINNING OF LOOP OVER RAMPS HAVING SAME BEGIN AND ENDING TIMES:  M35.2580
  statement_3096:
  write(prom80, "(' SEND \"T-begin\", \"T-end\" (END, SHOW, REWIND) :')");
  FEM_THROW_UNHANDLED("executable assign: assign33098tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  if (bytbuf(1, 4) == "END ") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) == "STOP") {
    stoptp(cmn);
  }
  if (bytbuf(1, 6) != "REWIND") {
    goto statement_3100;
  }
  statement_3099:
  numrmp = 0;
  kanal = 0;
  tmaxrp = -1.e20f;
  tminrp = 1.e20f;
  goto statement_3096;
  statement_3100:
  if (bytbuf(1, 4) != "SHOW") {
    goto statement_3116;
  }
  //C     FOLLOWING CODE PROVIDES CONFIRMATION OF THE RAMPED DEPOSITS:      M35.2596
  write(munit6,
    "(' Row  Name   Index   Num    T-begin        T-end',"
    "'        F-begin        F-end')");
  window(cmn);
  FEM_DO_SAFE(j, 1, numrmp) {
    write(munit6, "(1x,i2,2x,a6,2i6,4e14.5)"), j, symbrp(j), indxrp(j),
      looprp(j), tbegrp(j), tendrp(j), fbegrp(j), fendrp(j);
    window(cmn);
  }
  write(munit6,
    "('         No RAMPing before',e13.4,'  or after',e13.4,'  sec.')"),
    tminrp, tmaxrp;
  window(cmn);
  goto statement_3096;
  statement_3116:
  frefp2(cmn, bytbuf, tim1rp, tim2rp);
  if (tim1rp == 0.0f) {
    tim1rp = t;
  }
  if (tim2rp < 0.0f) {
    tim2rp = tim1rp + fem::abs(tim2rp);
  }
  //C     BEGINNING OF LOOP OVER FUNCTION VALUES (FOR GIVEN TIMES):         M35.2611
  statement_3122:
  write(prom80, "(' SEND \"F-begin\", \"F-end\" (END) : ')");
  FEM_THROW_UNHANDLED("executable assign: assign3128tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  if (bytbuf(1, 4) == "END ") {
    goto statement_3096;
  }
  if (bytbuf(1, 4) == "STOP") {
    stoptp(cmn);
  }
  frefp2(cmn, bytbuf, val1rp, val2rp);
  //C     BEGINNING OF LOOP OVER VARIABLES (FOR GIVEN F VS. T RAMPS):       M35.2620
  statement_3131:
  goto statement_1460;
  //C     WE RETURN TO 3134 AFTER "DEPOSIT" LOGIC HAS FOUND VARIABLE INFO.  M35.2622
  //C     ACTUAL TRANSFER BACK HERE IS FROM JUST BELOW 1807.                M35.2623
  statement_3134:
  n8 = locate(ind) + 2 * (n1 - 1);
  n9 = (n8 - memkar) / 2;
  n10 = memkar + 2 * n9 - n8;
  if (n10 != 0 && n9 < 0) {
    n9 = n9 - 1;
  }
  numrmp++;
  kanal = 1;
  if (numrmp <= 20) {
    goto statement_3135;
  }
  write(munit6,
    "('  ** **  Table overflow.   Erase all',"
    "'  \"RAMP\"  entries, and start again ....')");
  window(cmn);
  goto statement_3095;
  statement_3135:
  memrmp(numrmp) = n9 + 1;
  n10rmp(numrmp) = n10;
  looprp(numrmp) = n2 - n1 + 1;
  tbegrp(numrmp) = tim1rp;
  if (tim1rp < tminrp) {
    tminrp = tim1rp;
  }
  tendrp(numrmp) = tim2rp;
  if (tim2rp > tmaxrp) {
    tmaxrp = tim2rp;
  }
  fbegrp(numrmp) = val1rp;
  fendrp(numrmp) = val2rp;
  symbrp(numrmp) = symb(ind);
  indxrp(numrmp) = n1;
  rampsl(numrmp) = (val2rp - val1rp) / (tim2rp - tim1rp);
  rampcn(numrmp) = val2rp - rampsl(numrmp) * tim2rp;
  write(prom80, "('     [Y] CHANGE? (0=NO, 1=YES) :')");
  FEM_THROW_UNHANDLED("executable assign: assign43137tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, n8);
  kyramp(numrmp) = n8;
  if (n8 == 0) {
    goto statement_3131;
  }
  tendrp(numrmp) = tim2rp + deltat;
  if (tmaxrp < tendrp(numrmp)) {
    tmaxrp = tendrp(numrmp);
  }
  if (n1 > ibr) {
    goto statement_3131;
  }
  write(munit6,
    "('  %%  %%  Cancel last \"RAMP\" request.','  Row number',i4,"
    "'  does not exceed IBR =',i4)"),
    n1, ibr;
  window(cmn);
  numrmp = numrmp - 1;
  goto statement_3131;
  //C     WE RETURN TO 3138 FROM BELOW 1496, IF "END" READ DURING "DEPOSIT" M35.2651
  statement_3138:
  goto statement_3122;
  //C     $$$$$$$  KEY WORD NO. 35:  "TIME"     $$$$  $$$$  $$$$  $$$$  $$$$M35.2653
  statement_3153:
  time44(cmn, spytim(1));
  date44(cmn, spdate(1));
  write(munit6, format_3158), t, tmax, deltat, spytim, spdate;
  window(cmn);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 36:  "TEK"      $$$$  $$$$  $$$$  $$$$  $$$$M35.2660
  statement_3174:
  write(munit6,
    "('  >< To tamper with the ROLLing vector plot,  send',' choice.')");
  window(cmn);
  statement_3178:
  write(prom80,
    "('  >< OPTION (MARK, DELAY, INNER, OVERLAP,',' END, HELP) : ')");
  FEM_THROW_UNHANDLED("executable assign: assign3180tonextsn");
  goto statement_9800;
  ansi8 = buff77(1, 8);
  if (ansi8 != "HELP    ") {
    goto statement_3186;
  }
  write(munit6,
    "('     MARK  ---- for instantaneous marking of curves',"
    "' on Tek screen;')");
  window(cmn);
  write(munit6,
    "('     DELAY  --- to control how simultaneous the',' ROLLing is to be;')");
  window(cmn);
  write(munit6,
    "('     INNER  ---- to  CALL TIMVAL  (the \"INNER:\"',"
    "' level of PLOTing);')");
  window(cmn);
  write(munit6,
    "('     OVERLAP  -- to modify the percent overlap',' for new-page plot;')");
  window(cmn);
  write(munit6, "('     END   ---- for return to  \"SPY:\"  prompt.')");
  window(cmn);
  goto statement_3178;
  statement_3186:
  if (ansi8 != "MARK    ") {
    goto statement_3193;
  }
  write(prom80,
    "('    SEND REPEAT FREQUENCY AFTER',' IMMEDIATE 1ST ONE [',i6,' ] :')"),
    ksymbl;
  FEM_THROW_UNHANDLED("executable assign: assign3191tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, ksymbl);
  goto statement_3178;
  statement_3193:
  if (ansi8 != "DELAY   ") {
    goto statement_3207;
  }
  write(prom80, "('  SEND NEW ROLLING FREQUENCY [',i5,' ] :')"), kslowr;
  FEM_THROW_UNHANDLED("executable assign: assign3204tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, kslowr);
  goto statement_3178;
  statement_3207:
  if (ansi8 != "INNER   ") {
    goto statement_3209;
  }
  statement_3208:
  monitr = 2345;
  timval(cmn);
  monitr = 1;
  if (nexmod == 0) {
    goto statement_3178;
  }
  nexmod = 1;
  goto statement_9803;
  statement_3209:
  if (ansi8 != "OVERLAP ") {
    goto statement_3214;
  }
  write(prom80, "('    SEND TIME-OVERLAP PERCENTAGE [',i3,' ] :')"), inchlp;
  FEM_THROW_UNHANDLED("executable assign: assign3204tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, inchlp);
  goto statement_3178;
  statement_3214:
  if (ansi8 == "END     ") {
    goto statement_1240;
  }
  write(munit6, "('   Sorry,  SPY  does not understand.   Come again ...')");
  window(cmn);
  goto statement_3178;
  //C     $$$$$$$  KEY WORD NO. 37:  "BRANCH"   $$$$  $$$$  $$$$  $$$$  $$$$M35.2717
  statement_3256:
  bytbuf(1, 4) = answ80(1, 4);
  n33 = 0;
  n24 = 0;
  goto statement_3308;
  statement_3306:
  FEM_THROW_UNHANDLED("executable assign: assign3307tonextsn");
  goto statement_9800;
  bytbuf = buff77(1, 20);
  statement_3308:
  if (bytbuf(1, 4) == "END ") {
    goto statement_1240;
  }
  if (bytbuf(1, 4) == "STOP") {
    goto statement_1240;
  }
  if (bytbuf(1, 6) != "SERIES") {
    goto statement_3309;
  }
  n24 = 1;
  goto statement_3306;
  statement_3309:
  if (bytbuf(1, 4) != "EXTR") {
    goto statement_3317;
  }
  n33++;
  if (n33 >= 2) {
    n33 = 0;
  }
  statement_3310:
  if (n33 == 0) {
    goto statement_3314;
  }
  write(prom80,
    "(' Row',13x,'CI',13x,'CK',12x,'CIK',12x,'CIK',10x,'CKKJM',':')");
  goto statement_3306;
  statement_3314:
  write(prom80,
    "(' Row  name  name-K name-M KBUS MBUS LGTH  NR',"
    "' KODEBR KODSEM LITYPE IMODEL INDHST:')");
  goto statement_3306;
  statement_3317:
  if (bytbuf(1, 4) == spykwd(37)(1, 4) || bytbuf(1, 4) == spykwd(1)(1, 4)) {
    goto statement_3310;
  }
  //C     SINCE NOT KEY-WORD RESPONSE, WE EXTRACT (N1,N2) INTEGER           M38.3919
  //C     PAIR (FREE-FORMAT); "IBR" IS MAXIMUM; "N17" IS ERROR FLAG:        M38.3920
  intpar(cmn, ibr, n1, n2, n17);
  if (n17 > 0) {
    goto statement_3306;
  }
  n27 = 1;
  i = n1;
  statement_3323:
  quiter(cmn);
  if (kwtspy == 0) {
    goto statement_3325;
  }
  kwtspy = 0;
  goto statement_3306;
  statement_3325:
  n5 = fem::iabs(kbus(i));
  n6 = fem::iabs(mbus(i));
  bus1 = bus(n5);
  if (n5 == 1) {
    bus1 = terra;
  }
  bus2 = bus(n6);
  if (n6 == 1) {
    bus2 = terra;
  }
  if (n24 == 0) {
    goto statement_3327;
  }
  n27 = length(i);
  if (n5 < 0) {
    goto statement_3334;
  }
  if (kodebr(i) > 0) {
    goto statement_3334;
  }
  if (n27 != 1) {
    goto statement_3334;
  }
  if (nr(i) >= 0) {
    goto statement_3334;
  }
  statement_3327:
  if (n33 != 0) {
    goto statement_3329;
  }
  n7 = namebr(i);
  write(munit6, "(1x,i3,1x,a6,1x,a6,1x,a6,3i5,i4,5i7)"), i, texvec(n7),
    bus1, bus2, kbus(i), mbus(i), length(i), nr(i), kodebr(i), kodsem(i),
    litype(i), imodel(i), indhst(i);
  window(cmn);
  statement_3329:
  if (n33 != 1) {
    goto statement_3334;
  }
  write(munit6, "(1x,i3,5e15.6)"), i, ci(i), ck(i), cik(i), cki(i), ckkjm(i);
  window(cmn);
  statement_3334:
  i += n27;
  if (i <= n2) {
    goto statement_3323;
  }
  prom80 = blan80;
  goto statement_3306;
  //C     $$$$$$$  KEY WORD NO. 38:  "YFORM"    $$$$  $$$$  $$$$  $$$$  $$$$M35.2780
  statement_3357:
  kansav = kanal;
  kanal = 2;
  goto statement_3394;
  //C     $$$$$$$  KEY WORD NO. 39:  "NOY"      $$$$  $$$$  $$$$  $$$$  $$$$M35.2784
  statement_3381:
  kanal = kansav;
  goto statement_3406;
  //C     $$$$$$$  KEY WORD NO. 40:  "FACTOR"   $$$$  $$$$  $$$$  $$$$  $$$$M35.2787
  statement_3394:
  ialter = 2;
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 41:  "NOF"      $$$$  $$$$  $$$$  $$$$  $$$$M35.2790
  statement_3406:
  if (ialter == 2) {
    ialter = 1;
  }
  goto statement_1240;
  //C     $$$$$$$  SERVICE 7:SWITCH, 25:SOURCE, 26:EDIT, 28:LANGUAGE,       M36.1851
  //C              42:RLC, 43:WIDTH, 44:BUS, 45:SIZE, 46:LIMIT,             M36.1852
  //C              47:IOUT, 48:NODE, 49:NONLIN, 50:SPACE, 51:LUNIT4,        M36.1853
  //C              52:SERIES, 53:LOCK, 54:[Y], 55:[F], 56:NOROLL            M36.1854
  statement_8500:
  spyink(cmn);
  if (nexmod != 0) {
    goto statement_9803;
  }
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 57:  "OPEN"     $$$$  $$$$  $$$$  $$$$  $$$$M36.1857
  statement_3568:
  write(prom80, "('    NEXT UNIT, NAME (I2, A32 ) :')");
  FEM_THROW_UNHANDLED("executable assign: assign3573tonextsn");
  goto statement_9800;
  read(buff77, format_3576), n7, ansi32;
  if (n7 <= 0) {
    goto statement_1240;
  }
  cmn.io.open(n7, ansi32)
    .status("UNKNOWN");
  goto statement_3568;
  //C     $$$$$$$  KEY WORD NO. 58:  "CLOSE"    $$$$  $$$$  $$$$  $$$$  $$$$M36.1866
  statement_3584:
  write(prom80, "('    NEXT UNIT, STATUS (I2, A32) :')");
  FEM_THROW_UNHANDLED("executable assign: assign3591tonextsn");
  goto statement_9800;
  read(buff77, format_3576), n7, ansi32;
  if (n7 <= 0) {
    goto statement_1240;
  }
  if (ansi32(1, 6) == "KEEP  ") {
    goto statement_3596;
  }
  if (ansi32(1, 6) == "DELETE") {
    goto statement_3596;
  }
  cmn.io.close(n7);
  goto statement_3584;
  statement_3596:
  cmn.io.close(n7)
    .status(ansi32);
  goto statement_3584;
  //C     $$$$$$$  KEY WORD NO. 59:  "SM"       $$$$  $$$$  $$$$  $$$$  $$$$M38.3944
  statement_3606:
  if (nchain >= 16 && cmn.nst > 0) {
    goto statement_43606;
  }
  write(munit6,
    "('   \?\? \?\?  No S.M. data present or not yet',' in time-step loop.')");
  window(cmn);
  goto statement_1240;
  statement_43606:
  ksmspy(3) = 1;
  lockbr = 0;
  statement_3608:
  ksmspy(1) = -1;
  ksmspy(2) = 0;
  cmn.maxflg = 1;
  FEM_THROW_UNHANDLED("executable assign: assign3609tonextsn");
  prom80(1, 8) = "        ";
  goto statement_9800;
  if (iprspy < 1) {
    goto statement_83609;
  }
  write(munit6, "(' AT S.N. 3609 OF \"SPYING\".  KSMSPY(2) =',i4)"), ksmspy(2);
  window(cmn);
  statement_83609:
  if (ksmspy(2) == 0) {
    goto statement_3608;
  }
  ksmspy(3) = 0;
  write(prom80, "('  S.M.',i3,'  WANTED (Y OR N) ? :')"), ksmspy(2);
  ksmspy(1) = +1;
  FEM_THROW_UNHANDLED("executable assign: assign3610tonextsn");
  goto statement_9800;
  if (buff77(1, 1) == "N") {
    goto statement_43606;
  }
  ksmspy(1) = +1;
  statement_3611:
  write(prom80,
    "('     SEND S.M. CLASS (ELEC, MECH, ELVA, MEVA,',' ALL, END) :')");
  FEM_THROW_UNHANDLED("executable assign: assign3613tonextsn");
  goto statement_9800;
  n14 = ksmspy(2);
  if (buff77(1, 4) == "END") {
    goto statement_43606;
  }
  if (buff77(1, 4) != "ELEC" && buff77(1, 4) != "ALL ") {
    goto statement_43615;
  }
  k2 = (n14 - 1) * 101;
  write(munit6,
    "('             LD            LAF             LF',"
    "'           LAKD           LFKD')");
  window(cmn);
  xl = elp(k2 + 20);
  d3 = elp(k2 + 1) + xl;
  d4 = elp(k2 + 2);
  d5 = (elp(k2 + 3) + elp(k2 + 62)) / factom;
  d6 = elp(k2 + 4);
  d8 = elp(k2 + 5);
  write(munit6, format_53614), d3, d4, d5, d6, d8;
  window(cmn);
  write(munit6,
    "('            LKD             RF            RKD',"
    "'             LQ            LAG')");
  window(cmn);
  d3 = (elp(k2 + 6) + elp(k2 + 63)) / factom;
  d4 = elp(k2 + 7);
  d5 = elp(k2 + 8);
  d6 = elp(k2 + 9) + xl;
  d8 = elp(k2 + 10);
  write(munit6, format_53614), d3, d4, d5, d6, d8;
  window(cmn);
  write(munit6,
    "('             LG           LAKQ           LGKQ',"
    "'            LKQ             RG')");
  window(cmn);
  d3 = (elp(k2 + 11) + elp(k2 + 64)) / factom;
  d4 = elp(k2 + 12);
  d5 = elp(k2 + 13);
  d6 = (elp(k2 + 14) + elp(k2 + 65)) / factom;
  d8 = elp(k2 + 15);
  write(munit6, format_53614), d3, d4, d5, d6, d8;
  window(cmn);
  write(munit6,
    "('            RKQ             L0             R0',"
    "'         AGLINE             RA')");
  window(cmn);
  d3 = elp(k2 + 16);
  d4 = 1.0f / elp(k2 + 17);
  d5 = elp(k2 + 18);
  d5 = (d4 - d5) / (1.0f + cmn.damrat);
  d4 = (d4 - d5) / factom;
  d8 = elp(k2 + 20);
  write(munit6, format_53614), d3, d4, d5, xl, d8;
  window(cmn);
  write(munit6,
    "('           RAT1         DSAT10         DSAT12',"
    "'         QSAT10         QSAT12')");
  window(cmn);
  k3 = k2 + 21;
  k2 += 25;
  {
    write_loop wloop(munit6, format_53614);
    FEM_DO_SAFE(k1, k3, k2) {
      wloop, elp(k1);
    }
  }
  window(cmn);
  statement_43615:
  if (buff77(1, 4) != "MECH" && buff77(1, 4) != "ALL ") {
    goto statement_13617;
  }
  k2 = (n14 - 1) * 101 + 26;
  k3 = (n14 - 1) * 30 + 12;
  numask = ismdat(k3);
  write(munit6, "('  NUMASK   NLOCG   NLOCE     CNP')");
  window(cmn);
  write(munit6, "(3i8,f8.1)"), numask, ismdat(k3 + 1), ismdat(k3 + 2), elp(k2);
  window(cmn);
  write(munit6,
    "('           HICO            DSM            HSP','            DSR')");
  window(cmn);
  k2 = 0;
  kp = 0;
  FEM_DO_SAFE(k1, 1, n14) {
    k2 += ismdat(kp + 12);
    kp += 30;
  }
  num2 = numask + numask;
  num3 = numask + num2;
  num5 = num3 + num2;
  k2 = (k2 - numask) * 12;
  k2 += num2;
  FEM_DO_SAFE(k1, 1, numask) {
    k2++;
    write(munit6, format_53614), shp(k2 + numask), shp(k2 + num2),
      shp(k2 + num3), shp(k2 + num5);
    window(cmn);
  }
  statement_13617:
  if (buff77(1, 4) != "MEVA" && buff77(1, 4) != "ALL ") {
    goto statement_13618;
  }
  write(munit6, "(' MECHANICAL ANGLES IN UNITS OF RADIANS ')");
  window(cmn);
  k3 = (n14 - 1) * 30 + 12;
  numask = ismdat(k3);
  k2 = 0;
  kp = 0;
  FEM_DO_SAFE(k1, 1, n14) {
    k2 += ismdat(kp + 12);
    kp += 30;
  }
  k2 = (k2 - numask) * 6;
  k3 = k2 + 1;
  k2 += numask;
  {
    write_loop wloop(munit6, format_53614);
    FEM_DO_SAFE(k1, k3, k2) {
      wloop, histq(k1);
    }
  }
  window(cmn);
  k3 = k2 + 1;
  k2 += numask;
  write(munit6, "(' MECHANICAL SPEEDS IN UNITS OF  RADIANS/SEC ')");
  window(cmn);
  {
    write_loop wloop(munit6, format_53614);
    FEM_DO_SAFE(k1, k3, k2) {
      wloop, histq(k1);
    }
  }
  window(cmn);
  statement_13618:
  if (buff77(1, 4) != "ELVA" && buff77(1, 4) != "ALL ") {
    goto statement_3611;
  }
  write(munit6,
    "('             ID             IQ             I0',"
    "'             IF            IKD')");
  window(cmn);
  k2 = (n14 - 1) * 24;
  k3 = k2 + 1;
  k2 += 5;
  {
    write_loop wloop(munit6, format_53614);
    FEM_DO_SAFE(k1, k3, k2) {
      wloop, cu(k1);
    }
  }
  window(cmn);
  write(munit6,
    "('             IG            IKQ             IA',"
    "'             IB             IC')");
  window(cmn);
  k3 = k2 + 1;
  k2 += 2;
  {
    write_loop wloop(munit6, format_53614);
    wloop, cu(k3), cu(k2);
    FEM_DO_SAFE(k1, 1, 3) {
      wloop, smoutv(k1);
    }
  }
  window(cmn);
  write(munit6,
    "('             VD             VQ             V0',"
    "'             VF             VA')");
  window(cmn);
  {
    write_loop wloop(munit6, format_53614);
    FEM_DO_SAFE(k1, 4, 8) {
      wloop, smoutv(k1);
    }
  }
  window(cmn);
  write(munit6,
    "('             VB             VC            TEQ','           TEXC')");
  window(cmn);
  {
    write_loop wloop(munit6, format_53614);
    FEM_DO_SAFE(k1, 9, 12) {
      wloop, smoutv(k1);
    }
  }
  window(cmn);
  goto statement_3611;
  //C     $$$$$$$  KEY WORD NO. 60:  "HONK"     $$$$  $$$$  $$$$  $$$$  $$$$M36.1877
  statement_3623:
  write(prom80, "('   SEND SEVERITY LEVEL OF ALERT (1 TO 10) :')");
  FEM_THROW_UNHANDLED("executable assign: assign3629tonextsn");
  goto statement_9800;
  frein1(cmn, buff77, n24);
  honker(cmn, n24);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 63:  "WAIT"     $$$$  $$$$  $$$$  $$$$  $$$$M37.6379
  statement_3644:
  write(prom80, "('     SEND DESIRED HIBERNATION TIME IN SECONDS :')");
  FEM_THROW_UNHANDLED("executable assign: assign3649tonextsn");
  goto statement_9800;
  frefp1(cmn, buff77, d13);
  tdelay(cmn, d13);
  goto statement_1240;
  //C     $$$$$$$  KEY WORD NO. 12:  "ECHO"     $$$$  $$$$  $$$$  $$$$  $$$$M38.4066
  statement_3673:
  write(prom80, "('    SEND DESIRED OPERATION (BEGIN, FILE, SHOW) :')");
  FEM_THROW_UNHANDLED("executable assign: assign3681tonextsn");
  goto statement_9800;
  if (buff77(1, 6) != "BEGIN ") {
    goto statement_3686;
  }
  cmn.kspsav = limcrd + 1;
  n23 = limcrd - numcrd;
  write(munit6,
    "('         Ok, up to a maximum of',i7,"
    "'   commands can be accumulated, if no more data.')"),
    n23;
  window(cmn);
  goto statement_1240;
  statement_3686:
  if (buff77(1, 5) != "FILE ") {
    goto statement_3702;
  }
  write(6, star), " TO BE COMPLETED LATER.  \?\?\?\?\?\?\?\??";
  goto statement_1240;
  statement_3702:
  if (buff77(1, 5) != "SHOW ") {
    goto statement_1303;
  }
  write(6, star), " TO BE COMPLETED LATER.  \?\?\?\?\?\?";
  goto statement_3673;
  //C     $$$$$$$  KEY WORD NO.  2:  "STOP"     $$$$  $$$$  $$$$  $$$$  $$$$M35.2794
  statement_9000:
  time44(cmn, spytim(1));
  date44(cmn, spdate(1));
  write(munit6, format_3158), t, tmax, deltat, spytim, spdate;
  window(cmn);
  stoptp(cmn);
  statement_9800:
  nexmod = 2;
  statement_9803:
  if (iprspy < 1) {
    goto statement_9811;
  }
  write(munit6,
    "(' EXIT \"SPYING\".  JJROLL, KBREAK, LOCKBR,',' NCHAIN =',4i5,"
    "'   PROM80(1:20) =',a20)"),
    jjroll, kbreak, lockbr, nchain, prom80(1, 20);
  window(cmn);
  statement_9811:
  if (prom80(1, 8) == "        ") {
    goto statement_9833;
  }
  if (kfile5 == 1) {
    goto statement_9833;
  }
  prompt(cmn);
  statement_9833:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void percnt(
  common& cmn,
  str_arr_ref<> vbyte,
  int const& n7) try
{
  vbyte(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  int& itexp = cmn.itexp;
  int& maxarg = cmn.maxarg;
  const auto& texpar = cmn.texpar;
  fem::str<8>& ansi8 = cmn.ansi8;
  fem::str<132>& munit6 = cmn.munit6;
  //
  int k = fem::int0;
  int j = fem::int0;
  int i = fem::int0;
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M35.3916
  //C     UTILITY WHICH SERVES TO REPLACE  "%%%%%%%%"  STRINGS OF DISK      M35.3917
  //C     FILES BY PARAMETERS OF  "@?"  CALL.   COLUMNS 1, ... N7  ARE      M35.3918
  //C     SEARCHED, OF CHARACTER VECTOR  "VBYTE" .                          M35.3919
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.3920
  FEM_DO_SAFE(k, 1, n7) {
    if (vbyte(k) != "%") {
      goto statement_1297;
    }
    FEM_DO_SAFE(j, 1, 7) {
      if (vbyte(k + j) != "%") {
        goto statement_1297;
      }
    }
    //C     WE EXIT  DO 1253  WITH STRING OF 8 "%" BEGINNING IN COLUMN K      M35.3929
    itexp++;
    if (itexp <= maxarg) {
      goto statement_1284;
    }
    write(munit6,
      "(' \?\?\?\?  TROUBLE.  \"@?\"  USAGE ONLY DEFINED',i4,"
      "'   ARGUMENTS, WHILE THE DISK')"),
      maxarg;
    window(cmn);
    write(munit6,
      "('                 FILE HAS MORE  %-STRINGS.',"
      "'   TROUBLE DETECTED IN FOLLOWING:')");
    window(cmn);
    {
      write_loop wloop(munit6, "('              >>>',80a1)");
      FEM_DO_SAFE(i, 1, n7) {
        wloop, vbyte(i);
      }
    }
    window(cmn);
    cmn.kilper = 1;
    goto statement_1313;
    statement_1284:
    ansi8 = texpar(itexp);
    {
      read_loop rloop(ansi8, "(80a1)");
      FEM_DO_SAFE(j, 1, 8) {
        rloop, vbyte(k + j - 1);
      }
    }
    statement_1297:;
  }
  if (cmn.kverfy != 0) {
    goto statement_1313;
  }
  {
    write_loop wloop(munit6, "(' @>>>',80a1)");
    FEM_DO_SAFE(j, 1, n7) {
      wloop, vbyte(j);
    }
  }
  window(cmn);
  statement_1313:;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct emtspy_save
{
  arr<fem::str<1> > filbyt;
  arr<double> fkar1;
  arr<double> fkar2;
  arr<double> forbyt;
  int n18;
  arr<double> pltbuf;

  emtspy_save() :
    filbyt(dimension(1), fem::fill0),
    fkar1(dimension(1), fem::fill0),
    fkar2(dimension(1), fem::fill0),
    forbyt(dimension(600), fem::fill0),
    n18(fem::int0),
    pltbuf(dimension(1), fem::fill0)
  {}
};

void emtspy(
  common& cmn) try
{
  FEM_CMN_SVE(emtspy);
  common_read read(cmn);
  common_write write(cmn);
  double& t = cmn.t;
  int& kwtspy = cmn.kwtspy;
  auto& muntsv = cmn.muntsv;
  int& nchain = cmn.nchain;
  double& tbreak = cmn.tbreak;
  int& jjroll = cmn.jjroll;
  int& kilper = cmn.kilper;
  int& kfile5 = cmn.kfile5;
  int& nbreak = cmn.nbreak;
  int& munit5 = cmn.munit5;
  const auto& ksmspy = cmn.ksmspy;
  int& lockbr = cmn.lockbr;
  int& komadd = cmn.komadd;
  int& iprspy = cmn.iprspy;
  int& kbreak = cmn.kbreak;
  fem::str<80>& buff77 = cmn.buff77;
  const auto& file6 = cmn.file6;
  fem::str<132>& munit6 = cmn.munit6;
  //
  int& n18 = sve.n18;
  if (is_called_first_time) {
    n18 = 0;
  }
  //C     MODULE OF INTERACTIVE EMTP ONLY, WHICH SERVICES "EMTSPY".         M35.1683
  //C     IF NO INTERACTIVE USE, CONVERT TO DUMMY MODULE ("RETURN").        M35.1684
  n18++;
  if (n18 < cmn.maxflg) {
    goto statement_9008;
  }
  n18 = 0;
  if (iprspy < 9) {
    goto statement_5611;
  }
  write(munit6,
    "(' TOP \"EMTSPY\".  KBREAK, KWTSPY, NBREAK, LOCKBR',' JJROLL, NCHAIN =',"
    "6i4,'    T, TBREAK =',2e14.5)"),
    kbreak, kwtspy, nbreak, lockbr, nchain, jjroll, t, tbreak;
  window(cmn);
  statement_5611:
  if (jjroll > 0) {
    goto statement_5632;
  }
  if (kbreak == 1) {
    goto statement_5613;
  }
  if (lockbr == 1) {
    goto statement_5623;
  }
  if (t < tbreak) {
    goto statement_5623;
  }
  if (nchain != nbreak) {
    goto statement_5623;
  }
  //C     OK, NOW WE SERVICE "BREAK" OF SPY (TIME AND PLACE TO DO IT):      M38.3570
  tbreak = 8877.e33f;
  statement_5613:
  lockbr = 1;
  write(munit6,
    "('   // Start \"BREAK\" service in \"EMTSPY\".','   NCHAIN =',i3,"
    "'   T =',e14.5)"),
    nchain, t;
  window(cmn);
  if (kfile5 == 1) {
    goto statement_6258;
  }
  statement_5617:
  write(cmn.prom80, "(' SPY:')");
  prompt(cmn);
  statement_5623:
  if (ksmspy(3) == 1) {
    goto statement_5632;
  }
  flager(cmn);
  if (kwtspy == 1) {
    goto statement_5632;
  }
  if (kfile5 == 1) {
    goto statement_6258;
  }
  goto statement_9000;
  statement_5632:
  kwtspy = 0;
  spying(cmn);
  if (jjroll > 0) {
    goto statement_9000;
  }
  if (lockbr == 1) {
    goto statement_5623;
  }
  goto statement_9000;
  //C     ENTRY POINT FOR PRE-DEFINED SPY COMMANDS ($SPY OR "@"):           M38.3590
  statement_6258:
  if (komadd == 0) {
    goto statement_6260;
  }
  komadd++;
  buff77 = file6(komadd);
  if (buff77(1, 3) == "EOF") {
    goto statement_6278;
  }
  goto statement_6264;
  statement_6260:
  try {
    read(munit5, "(a80)"), buff77;
  }
  catch (fem::read_end const&) {
    goto statement_6274;
  }
  statement_6264:
  if (kfile5 == 1) {
    percnt(cmn, buff77, 80);
  }
  if (kilper != 0) {
    goto statement_6274;
  }
  spying(cmn);
  if (lockbr == 1) {
    goto statement_6258;
  }
  goto statement_9000;
  //C     END-OF-FILE DURING DISK READ, SO SWITCH TO KEYBOARD INPUT:        M38.3599
  statement_6274:
  cmn.io.close(munit5);
  statement_6278:
  munit5 = muntsv(1);
  kfile5 = 0;
  kilper = 0;
  if (muntsv(2) != 2288) {
    goto statement_5617;
  }
  muntsv(2) = 0;
  statement_9000:
  if (iprspy < 1) {
    goto statement_9008;
  }
  write(munit6,
    "(' EXIT \"EMTSPY\".  KBREAK, NCHAIN, LASTOV,',' M4PLOT =',4i6)"),
    kbreak, nchain, cmn.lastov, cmn.m4plot;
  window(cmn);
  statement_9008:;

}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void locatn(
  common& cmn) try
{
  // COMMON cmn
  const auto& texcol = cmn.texcol;
  const auto& texta6 = cmn.texta6;
  const auto& date1= cmn.date1;
  const auto& tclock= cmn.tclock;
  const auto& vstacs= cmn.vstacs;
  const auto& abuff = cmn.abuff;
  const auto& begmax = cmn.begmax;
  const auto& peaknd = cmn.peaknd;
  const auto& voltbc = cmn.voltbc;
  const auto& kprchg = cmn.kprchg;
  const auto& multpr = cmn.multpr;
  const auto& ipntv = cmn.ipntv;
  const auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  const auto& lunsav = cmn.lunsav;
  const auto& iprsov = cmn.iprsov;
  const auto& flstat = cmn.flstat;
  const auto& indtv = cmn.indtv;
  const auto& ktrlsw = cmn.ktrlsw;
  const auto& nexout = cmn.nexout;
  const auto& loopss = cmn.loopss;
  // COMMON c0b001
  const auto& x = static_cast<common_c0b001&>(cmn).x;
  // COMMON c0b002
  const auto& ykm = cmn.ykm;
  // COMMON c0b003
  const auto& km = cmn.km;
  // COMMON c0b004
  const auto& xk = cmn.xk;
  // COMMON c0b005
  const auto& xm = cmn.xm;
  // COMMON c0b006
  const auto& weight = cmn.weight;
  // COMMON c0b007
  const auto& iwtent = cmn.iwtent;
  // COMMON c0b008
  const auto& con1 = cmn.con1;
  // COMMON c0b009
  const auto& iskip = cmn.iskip;
  // COMMON c0b010
  const auto& zinf = cmn.zinf;
  // COMMON c0b011
  const auto& eta = cmn.eta;
  // COMMON c0b012
  const auto& nhist = cmn.nhist;
  // COMMON c0b013
  const auto& stailm = cmn.stailm;
  // COMMON c0b014
  const auto& stailk = cmn.stailk;
  // COMMON c0b015
  const auto& xmax = cmn.xmax;
  // COMMON c0b016
  const auto& koutvp = cmn.koutvp;
  // COMMON c0b017
  const auto& bnrg = cmn.bnrg;
  // COMMON c0b018
  const auto& sconst = cmn.sconst;
  // COMMON c0b019
  const auto& cnvhst = cmn.cnvhst;
  // COMMON c0b020
  const auto& sfd = cmn.sfd;
  // COMMON c0b021
  const auto& qfd = cmn.qfd;
  // COMMON c0b022
  const auto& semaux = cmn.semaux;
  // COMMON c0b023
  const auto& ibsout = cmn.ibsout;
  // COMMON c0b024
  const auto& bvalue = cmn.bvalue;
  // COMMON c0b025
  const auto& sptacs = cmn.sptacs;
  // COMMON c0b026
  const auto& kswtyp = cmn.kswtyp;
  // COMMON c0b027
  const auto& modswt = cmn.modswt;
  // COMMON c0b028
  const auto& kbegsw = cmn.kbegsw;
  // COMMON c0b029
  const auto& lastsw = cmn.lastsw;
  // COMMON c0b030
  const auto& kentnb = cmn.kentnb;
  // COMMON c0b031
  const auto& nbhdsw = cmn.nbhdsw;
  // COMMON c0b032
  const auto& topen = cmn.topen;
  // COMMON c0b033
  const auto& crit = cmn.crit;
  // COMMON c0b034
  const auto& kdepsw = cmn.kdepsw;
  // COMMON c0b035
  const auto& tdns = cmn.tdns;
  // COMMON c0b036
  const auto& isourc = cmn.isourc;
  // COMMON c0b037
  const auto& energy = cmn.energy;
  // COMMON c0b038
  const auto& iardub = cmn.iardub;
  // COMMON c0b039
  const auto& ardube = cmn.ardube;
  // COMMON c0b040
  const auto& nonlad = cmn.nonlad;
  // COMMON c0b041
  const auto& nonle = cmn.nonle;
  // COMMON c0b042
  const auto& vnonl = cmn.vnonl;
  // COMMON c0b043
  const auto& curr = cmn.curr;
  // COMMON c0b044
  const auto& anonl = cmn.anonl;
  // COMMON c0b045
  const auto& vecnl1 = cmn.vecnl1;
  // COMMON c0b046
  const auto& vecnl2 = cmn.vecnl2;
  // COMMON c0b048
  const auto& vzer5 = cmn.vzer5;
  // COMMON c0b049
  const auto& ilast = cmn.ilast;
  // COMMON c0b050
  const auto& nltype = cmn.nltype;
  // COMMON c0b051
  const auto& kupl = cmn.kupl;
  // COMMON c0b052
  const auto& nlsub = cmn.nlsub;
  // COMMON c0b055
  const auto& cursub = cmn.cursub;
  // COMMON c0b056
  const auto& cchar = cmn.cchar;
  // COMMON c0b057
  const auto& vchar = cmn.vchar;
  // COMMON c0b058
  const auto& gslope = cmn.gslope;
  // COMMON c0b060
  const auto& kk = cmn.kk;
  // COMMON c0b061
  const auto& c = cmn.c;
  // COMMON c0b062
  const auto& tr = cmn.tr;
  // COMMON c0b063
  const auto& tx = cmn.tx;
  // COMMON c0b064
  const auto& r = static_cast<common_c0b064&>(cmn).r;
  // COMMON c0b065
  const auto& nr = cmn.nr;
  // COMMON c0b066
  const auto& length = cmn.length;
  // COMMON c0b067
  const auto& cik = cmn.cik;
  // COMMON c0b068
  const auto& ci = cmn.ci;
  // COMMON c0b069
  const auto& ck = cmn.ck;
  // COMMON c0b070
  const auto& ismout = cmn.ismout;
  // COMMON c0b072
  const auto& cu = cmn.cu;
  // COMMON c0b074
  const auto& histq = cmn.histq;
  // COMMON c0b077
  const auto& ibrnch = cmn.ibrnch;
  // COMMON c0b078
  const auto& jbrnch = cmn.jbrnch;
  // COMMON c0b079
  const auto& tstop = cmn.tstop;
  // COMMON c0b080
  const auto& nonlk = cmn.nonlk;
  // COMMON c0b081
  const auto& nonlm = cmn.nonlm;
  // COMMON c0b082
  const auto& spum = cmn.spum;
  // COMMON c0b083
  const auto& kks = cmn.kks;
  // COMMON c0b084
  const auto& kknonl = cmn.kknonl;
  // COMMON c0b085
  const auto& znonl = cmn.znonl;
  // COMMON c0b086
  const auto& znonlb = cmn.znonlb;
  // COMMON c0b087
  const auto& znonlc = cmn.znonlc;
  // COMMON c0b088
  const auto& finit = cmn.finit;
  // COMMON c0b089
  const auto& ksub = cmn.ksub;
  // COMMON c0b090
  const auto& msub = cmn.msub;
  // COMMON c0b091
  const auto& isubeg = cmn.isubeg;
  // COMMON c0b092
  const auto& litype = cmn.litype;
  // COMMON c0b093
  const auto& imodel = cmn.imodel;
  // COMMON c0b094
  const auto& kbus = cmn.kbus;
  // COMMON c0b095
  const auto& mbus = cmn.mbus;
  // COMMON c0b096
  const auto& kodebr = cmn.kodebr;
  // COMMON c0b097
  const auto& cki = cmn.cki;
  // COMMON c0b098
  const auto& ckkjm = cmn.ckkjm;
  // COMMON c0b099
  const auto& indhst = cmn.indhst;
  // COMMON c0b100
  const auto& kodsem = cmn.kodsem;
  // COMMON c0b102
  const auto& iform = cmn.iform;
  // COMMON c0b103
  const auto& node = cmn.node;
  // COMMON c0b104
  const auto& crest = cmn.crest;
  // COMMON c0b105
  const auto& time1 = cmn.time1;
  // COMMON c0b106
  const auto& time2 = cmn.time2;
  // COMMON c0b107
  const auto& tstart = cmn.tstart;
  // COMMON c0b108
  const auto& sfreq = cmn.sfreq;
  // COMMON c0b109
  const auto& kmswit = cmn.kmswit;
  // COMMON c0b110
  const auto& nextsw = cmn.nextsw;
  // COMMON c0b111
  const auto& rmfd = cmn.rmfd;
  // COMMON c0b112
  const auto& cikfd = cmn.cikfd;
  // COMMON c0b113
  const auto& imfd = cmn.imfd;
  // COMMON c0b114
  const auto& tclose = cmn.tclose;
  // COMMON c0b115
  const auto& adelay = cmn.adelay;
  // COMMON c0b116
  const auto& kpos = cmn.kpos;
  // COMMON c0b118
  const auto& e = cmn.e;
  // COMMON c0b119
  const auto& f = static_cast<common_c0b119&>(cmn).f;
  // COMMON c0b120
  const auto& kssfrq = cmn.kssfrq;
  // COMMON c0b121
  const auto& kode = cmn.kode;
  // COMMON c0b122
  const auto& kpsour = cmn.kpsour;
  // COMMON c0b123
  const auto& volti = static_cast<common_c0b123&>(cmn).volti;
  // COMMON c0b124
  const auto& voltk = static_cast<common_c0b124&>(cmn).voltk;
  // COMMON c0b125
  const auto& volt = cmn.volt;
  // COMMON c0b126
  const auto& bus = cmn.bus;
  // COMMON smach
  const auto& z = static_cast<common_smach&>(cmn).z;
  const auto& x1 = cmn.x1;
  // COMMON umcom
  const auto& busum = cmn.busum;
  const auto& ptheta = cmn.ptheta;
  const auto& zthevr = cmn.zthevr;
  const auto& vinp = cmn.vinp;
  const auto& zthevs = cmn.zthevs;
  const auto& umcur = cmn.umcur;
  const auto& con = cmn.con;
  const auto& dumvec = cmn.dumvec;
  const auto& dummat = cmn.dummat;
  const auto& date = static_cast<common_umcom&>(cmn).date;
  const auto& clock = cmn.clock;
  double& pi = static_cast<common_umcom&>(cmn).pi;
  const auto& ndum = cmn.ndum;
  // COMMON c29b01
  const auto& karray = static_cast<common_c29b01&>(cmn).karray;
  // COMMON spycom
  const auto& rampcn = cmn.rampcn;
  const auto& rampsl = cmn.rampsl;
  const auto& kyramp = cmn.kyramp;
  const auto& fendrp = cmn.fendrp;
  const auto& tbegrp = cmn.tbegrp;
  const auto& tendrp = cmn.tendrp;
  const auto& fbegrp = cmn.fbegrp;
  // COMMON spykom
  const auto& indxrp = cmn.indxrp;
  const auto& ivec = cmn.ivec;
  const auto& iascii = cmn.iascii;
  const auto& labels = cmn.labels;
  auto& locate = cmn.locate;
  const auto& nline = cmn.nline;
  const auto& looprp = cmn.looprp;
  const auto& n10rmp = cmn.n10rmp;
  const auto& memrmp = cmn.memrmp;
  const auto& kar1 = cmn.kar1;
  const auto& kar2 = cmn.kar2;
  // COMMON spyf77
  const auto& filext = cmn.filext;
  const auto& symb = cmn.symb;
  const auto& col = cmn.col;
  const auto& symbrp = cmn.symbrp;
  const auto& file6b = cmn.file6b;
  const auto& file6 = cmn.file6;
  const auto& digit = cmn.digit;
  const auto& texpar = cmn.texpar;
  // COMMON ekcom1
  const auto& ekbuf = cmn.ekbuf;
  const auto& ektemp = cmn.ektemp;
  const auto& solrsv = static_cast<common_ekcom1&>(cmn).solrsv;
  const auto& solisv = static_cast<common_ekcom1&>(cmn).solisv;
  const auto& nekcod = cmn.nekcod;
  //
  int kcolcs = sptacs(5);
  int kspvar = sptacs(6);
  int katcs = sptacs(7);
  int kprsup = sptacs(9);
  int kaliu = sptacs(11);
  int kjout = sptacs(12);
  int kiuty = sptacs(13);
  int kud1 = sptacs(14);
  int kawkcs = sptacs(15);
  int kxar = sptacs(16);
  int kxtcs = sptacs(17);
  int klntab = sptacs(18);
  int kksus = sptacs(21);
  int kalksu = sptacs(22);
  int nuk = lstat(51);
  locate(1) = locint(cmn.bus1);
  locate(2) = locint(cmn.bus2);
  locate(3) = locint(cmn.bus3);
  locate(4) = locint(cmn.bus4);
  locate(5) = locint(cmn.bus5);
  locate(6) = locint(cmn.bus6);
  locate(7) = locint(cmn.trash);
  locate(8) = locint(cmn.blank);
  locate(9) = locint(cmn.terra);
  locate(10) = locint(cmn.userid);
  locate(11) = locint(cmn.branch);
  locate(12) = locint(cmn.copy);
  locate(13) = locint(cmn.csepar);
  locate(14) = locint(cmn.chcont);
  locate(15) = locint(texcol);
  locate(16) = locint(texta6);
  locate(17) = locint(date1);
  locate(18) = locint(tclock);
  locate(19) = locint(vstacs);
  locate(20) = locint(abuff);
  locate(21) = locint(cmn.ci1);
  locate(22) = locint(cmn.ck1);
  locate(23) = locint(cmn.deltat);
  locate(24) = locint(cmn.delta2);
  locate(25) = locint(cmn.freqcs);
  locate(26) = locint(cmn.epsiln);
  locate(27) = locint(cmn.xunits);
  locate(28) = locint(cmn.aincr);
  locate(29) = locint(cmn.xmaxmx);
  double znvref = fem::double0;
  locate(30) = locint(znvref);
  locate(31) = locint(cmn.epszno);
  locate(32) = locint(cmn.epwarn);
  locate(33) = locint(cmn.epstop);
  locate(34) = locint(cmn.t);
  double hertz = fem::double0;
  locate(35) = locint(hertz);
  locate(36) = locint(cmn.tolmat);
  locate(37) = locint(cmn.twopi);
  locate(38) = locint(cmn.tmax);
  locate(39) = locint(cmn.omega);
  locate(40) = locint(cmn.copt);
  locate(41) = locint(cmn.xopt);
  locate(42) = locint(cmn.szplt);
  locate(43) = locint(cmn.szbed);
  locate(44) = locint(cmn.sglfir);
  locate(45) = locint(cmn.sigmax);
  locate(46) = locint(cmn.epsuba);
  locate(47) = locint(cmn.epdgel);
  locate(48) = locint(cmn.epomeg);
  locate(49) = locint(cmn.fminfs);
  locate(50) = locint(cmn.delffs);
  locate(51) = locint(cmn.fmaxfs);
  locate(52) = locint(cmn.tenerg);
  locate(53) = locint(begmax);
  locate(54) = locint(cmn.tenm3);
  locate(55) = locint(cmn.tenm6);
  locate(56) = locint(cmn.unity);
  locate(57) = locint(cmn.onehaf);
  locate(58) = locint(peaknd);
  locate(59) = locint(cmn.fltinf);
  locate(60) = locint(cmn.flzero);
  locate(61) = locint(cmn.degmin);
  locate(62) = locint(cmn.degmax);
  locate(63) = locint(cmn.statfr);
  locate(64) = locint(voltbc);
  locate(65) = locint(flstat);
  double dtnext = fem::double0;
  locate(66) = locint(dtnext);
  locate(67) = locint(cmn.angle);
  locate(68) = locint(cmn.pu);
  double seedr = fem::double0;
  locate(69) = locint(seedr);
  locate(70) = locint(cmn.speedl);
  int kstart = fem::int0;
  locate(71) = locint(kstart);
  int knt = fem::int0;
  locate(72) = locint(knt);
  int kbase = fem::int0;
  locate(73) = locint(kbase);
  int ltdelt = fem::int0;
  locate(74) = locint(ltdelt);
  double unused = fem::double0;
  locate(75) = locint(unused);
  int mtape = fem::int0;
  locate(76) = locint(mtape);
  locate(77) = locint(cmn.lunit1);
  locate(78) = locint(cmn.lunit2);
  locate(79) = locint(cmn.lunit3);
  locate(80) = locint(cmn.lunit4);
  locate(81) = locint(cmn.lunit5);
  locate(82) = locint(cmn.lunit6);
  locate(83) = locint(cmn.lunit7);
  locate(84) = locint(cmn.lunit8);
  locate(85) = locint(cmn.lunit9);
  locate(86) = locint(cmn.lunt10);
  locate(87) = locint(cmn.lunt11);
  locate(88) = locint(cmn.lunt12);
  locate(89) = locint(cmn.lunt13);
  locate(90) = locint(cmn.lunt14);
  locate(91) = locint(cmn.lunt15);
  locate(92) = locint(nexout);
  locate(93) = locint(cmn.nright);
  locate(94) = locint(cmn.nfrfld);
  locate(95) = locint(cmn.kolbeg);
  locate(96) = locint(kprchg);
  locate(97) = locint(multpr);
  locate(98) = locint(ipntv);
  locate(99) = locint(indtv);
  locate(100) = locint(lstat);
  locate(101) = locint(nbyte);
  locate(102) = locint(lunsav);
  locate(103) = locint(iprsov);
  locate(104) = locint(cmn.icheck);
  locate(105) = locint(unused);
  int iend = fem::int0;
  locate(106) = locint(iend);
  locate(107) = locint(cmn.iline);
  locate(108) = locint(cmn.inonl);
  int iold = fem::int0;
  locate(109) = locint(iold);
  locate(110) = locint(cmn.iout);
  int iprint = fem::int0;
  locate(111) = locint(iprint);
  locate(112) = locint(cmn.ipunch);
  locate(113) = locint(cmn.iread);
  locate(114) = locint(cmn.kol132);
  locate(115) = locint(cmn.istep);
  locate(116) = locint(unused);
  locate(117) = locint(cmn.itype);
  locate(118) = locint(cmn.it1);
  locate(119) = locint(cmn.it2);
  int iupper = fem::int0;
  locate(120) = locint(iupper);
  locate(121) = locint(cmn.izero);
  locate(122) = locint(cmn.kcount);
  locate(123) = locint(cmn.istead);
  locate(124) = locint(unused);
  locate(125) = locint(cmn.ldata);
  locate(126) = locint(cmn.lbrnch);
  int limtxf = fem::int0;
  locate(127) = locint(limtxf);
  int mdebug = fem::int0;
  locate(128) = locint(mdebug);
  locate(129) = locint(cmn.lexct);
  locate(130) = locint(cmn.lbus);
  locate(131) = locint(cmn.lymat);
  locate(132) = locint(cmn.lswtch);
  locate(133) = locint(cmn.lnonl);
  locate(134) = locint(cmn.lchar);
  locate(135) = locint(cmn.m4plot);
  locate(136) = locint(cmn.lpast);
  int lsmat = fem::int0;
  locate(137) = locint(lsmat);
  locate(138) = locint(cmn.iplot);
  locate(139) = locint(cmn.ncomp);
  locate(140) = locint(cmn.nv);
  locate(141) = locint(cmn.lcomp);
  locate(142) = locint(cmn.numsm);
  locate(143) = locint(cmn.ifdep);
  locate(144) = locint(cmn.ltails);
  locate(145) = locint(cmn.lfdep);
  locate(146) = locint(cmn.lwt);
  locate(147) = locint(cmn.last);
  locate(148) = locint(cmn.npower);
  locate(149) = locint(cmn.maxpe);
  int lpeak = fem::int0;
  locate(150) = locint(lpeak);
  int nout = fem::int0;
  locate(151) = locint(nout);
  locate(152) = locint(cmn.iv);
  int ineof = fem::int0;
  locate(153) = locint(ineof);
  locate(154) = locint(ktrlsw);
  locate(155) = locint(cmn.num99);
  locate(156) = locint(cmn.kpartb);
  locate(157) = locint(cmn.llbuff);
  locate(158) = locint(cmn.kanal);
  locate(159) = locint(cmn.nsmth);
  locate(160) = locint(cmn.ntcsex);
  locate(161) = locint(cmn.nstacs);
  int kloaep = fem::int0;
  locate(162) = locint(kloaep);
  locate(163) = locint(cmn.lastov);
  locate(164) = locint(cmn.ltacst);
  locate(165) = locint(cmn.lhist);
  locate(166) = locint(cmn.ifx);
  int ndelta = fem::int0;
  locate(167) = locint(ndelta);
  int idelta = fem::int0;
  locate(168) = locint(idelta);
  locate(169) = locint(cmn.inecho);
  locate(170) = locint(cmn.noutpr);
  locate(171) = locint(cmn.ktab);
  locate(172) = locint(cmn.jflsos);
  locate(173) = locint(cmn.numdcd);
  locate(174) = locint(cmn.numum);
  locate(175) = locint(cmn.lspcum);
  locate(176) = locint(cmn.nphcas);
  int locz11 = fem::int0;
  locate(177) = locint(locz11);
  int locbr1 = fem::int0;
  locate(178) = locint(locbr1);
  locate(179) = locint(cmn.ialter);
  locate(180) = locint(cmn.ichar);
  locate(181) = locint(cmn.ktref);
  int kph = fem::int0;
  locate(182) = locint(kph);
  int kreqab = fem::int0;
  locate(183) = locint(kreqab);
  int ksat = fem::int0;
  locate(184) = locint(ksat);
  locate(185) = locint(cmn.memsav);
  locate(186) = locint(cmn.lisoff);
  int lspov4 = fem::int0;
  locate(187) = locint(lspov4);
  locate(188) = locint(cmn.kburro);
  locate(189) = locint(cmn.iaverg);
  locate(190) = locint(cmn.lsiz23);
  locate(191) = locint(cmn.lsiz26);
  locate(192) = locint(cmn.numout);
  locate(193) = locint(cmn.moldat);
  locate(194) = locint(cmn.lsiz27);
  locate(195) = locint(cmn.ltlabl);
  locate(196) = locint(cmn.iwt);
  locate(197) = locint(cmn.ifdep2);
  locate(198) = locint(cmn.idoubl);
  locate(199) = locint(cmn.ioutin);
  locate(200) = locint(cmn.ipun);
  locate(201) = locint(cmn.jst);
  locate(202) = locint(cmn.jst1);
  locate(203) = locint(unused);
  locate(204) = locint(cmn.numsub);
  locate(205) = locint(cmn.maxzno);
  int kalplt = fem::int0;
  locate(206) = locint(kalplt);
  int niomax = fem::int0;
  locate(207) = locint(niomax);
  int niamax = fem::int0;
  locate(208) = locint(niamax);
  int ibr1 = fem::int0;
  locate(209) = locint(ibr1);
  locate(210) = locint(cmn.ifsem);
  locate(211) = locint(cmn.lfsem);
  locate(212) = locint(cmn.iadd);
  locate(213) = locint(cmn.lfd);
  int laux = fem::int0;
  locate(214) = locint(laux);
  locate(215) = locint(cmn.iofgnd);
  locate(216) = locint(cmn.iofbnd);
  locate(217) = locint(unused);
  int jseedr = fem::int0;
  locate(218) = locint(jseedr);
  locate(219) = locint(cmn.modout);
  locate(220) = locint(cmn.iftail);
  int ipoint = fem::int0;
  locate(221) = locint(ipoint);
  int lpast2 = fem::int0;
  locate(222) = locint(lpast2);
  locate(223) = locint(cmn.ncurr);
  locate(224) = locint(cmn.ioffd);
  locate(225) = locint(cmn.isplot);
  locate(226) = locint(cmn.isprin);
  locate(227) = locint(cmn.maxout);
  int ipos = fem::int0;
  locate(228) = locint(ipos);
  locate(229) = locint(unused);
  locate(230) = locint(unused);
  locate(231) = locint(cmn.kill);
  locate(232) = locint(cmn.ivolt);
  locate(233) = locint(cmn.nchain);
  locate(234) = locint(cmn.iprsup);
  locate(235) = locint(unused);
  locate(236) = locint(cmn.intinf);
  locate(237) = locint(cmn.kconst);
  locate(238) = locint(cmn.kswtch);
  locate(239) = locint(cmn.it);
  locate(240) = locint(cmn.ntot);
  locate(241) = locint(cmn.ibr);
  int lcom10 = fem::int0;
  locate(242) = locint(lcom10);
  int ltrnst = fem::int0;
  locate(243) = locint(ltrnst);
  locate(244) = locint(cmn.lsyn);
  locate(245) = locint(cmn.kssout);
  locate(246) = locint(loopss);
  int infexp = fem::int0;
  locate(247) = locint(infexp);
  locate(248) = locint(cmn.numref);
  locate(249) = locint(cmn.nword1);
  locate(250) = locint(cmn.nword2);
  locate(251) = locint(cmn.iloaep);
  locate(252) = locint(cmn.lnpin);
  locate(253) = locint(cmn.ntot1);
  locate(254) = locint(cmn.limstp);
  locate(255) = locint(cmn.indstp);
  locate(256) = locint(cmn.nc);
  locate(257) = locint(unused);
  locate(258) = locint(unused);
  locate(259) = locint(cmn.icat);
  locate(260) = locint(cmn.numnvo);
  locate(261) = locint(unused);
  locate(262) = locint(cmn.nenerg);
  int isw = fem::int0;
  locate(263) = locint(isw);
  int itest = fem::int0;
  locate(264) = locint(itest);
  int idist = fem::int0;
  locate(265) = locint(idist);
  locate(266) = locint(x);
  locate(267) = locint(ykm);
  locate(268) = locint(km);
  locate(269) = locint(xk);
  locate(270) = locint(xm);
  locate(271) = locint(weight);
  locate(272) = locint(iwtent);
  locate(273) = locint(con1);
  locate(274) = locint(iskip);
  locate(275) = locint(zinf);
  locate(276) = locint(eta);
  locate(277) = locint(nhist);
  locate(278) = locint(stailm);
  locate(279) = locint(stailk);
  locate(280) = locint(xmax);
  locate(281) = locint(koutvp);
  locate(282) = locint(bnrg);
  locate(283) = locint(sconst);
  locate(284) = locint(cnvhst);
  locate(285) = locint(sfd);
  locate(286) = locint(qfd);
  locate(287) = locint(semaux);
  locate(288) = locint(ibsout);
  locate(289) = locint(bvalue);
  locate(290) = locint(sptacs);
  locate(291) = locint(kswtyp);
  locate(292) = locint(modswt);
  locate(293) = locint(kbegsw);
  locate(294) = locint(lastsw);
  locate(295) = locint(kentnb);
  locate(296) = locint(nbhdsw);
  locate(297) = locint(topen);
  locate(298) = locint(crit);
  locate(299) = locint(kdepsw);
  locate(300) = locint(tdns);
  locate(301) = locint(isourc);
  locate(302) = locint(energy);
  locate(303) = locint(iardub);
  locate(304) = locint(ardube);
  locate(305) = locint(nonlad);
  locate(306) = locint(nonle);
  locate(307) = locint(vnonl);
  locate(308) = locint(curr);
  locate(309) = locint(anonl);
  locate(310) = locint(vecnl1);
  locate(311) = locint(vecnl2);
  double brnonl = fem::double0;
  locate(312) = locint(brnonl);
  locate(313) = locint(vzer5);
  locate(314) = locint(ilast);
  locate(315) = locint(nltype);
  locate(316) = locint(kupl);
  locate(317) = locint(nlsub);
  locate(318) = locint(cursub);
  locate(319) = locint(cchar);
  locate(320) = locint(vchar);
  locate(321) = locint(gslope);
  locate(322) = locint(kk);
  locate(323) = locint(c);
  locate(324) = locint(tr);
  locate(325) = locint(tx);
  locate(326) = locint(r);
  locate(327) = locint(nr);
  locate(328) = locint(length);
  locate(329) = locint(cik);
  locate(330) = locint(ci);
  locate(331) = locint(ck);
  double swname = fem::double0;
  locate(332) = locint(swname);
  locate(333) = locint(ibrnch);
  locate(334) = locint(jbrnch);
  locate(335) = locint(tstop);
  locate(336) = locint(nonlk);
  locate(337) = locint(nonlm);
  locate(338) = locint(spum);
  locate(339) = locint(kks);
  locate(340) = locint(kknonl);
  locate(341) = locint(znonl);
  locate(342) = locint(znonlb);
  locate(343) = locint(znonlc);
  locate(344) = locint(finit);
  locate(345) = locint(ksub);
  locate(346) = locint(msub);
  locate(347) = locint(isubeg);
  locate(348) = locint(litype);
  locate(349) = locint(imodel);
  locate(350) = locint(kbus);
  locate(351) = locint(mbus);
  locate(352) = locint(kodebr);
  locate(353) = locint(cki);
  locate(354) = locint(ckkjm);
  locate(355) = locint(indhst);
  locate(356) = locint(kodsem);
  double brname = fem::double0;
  locate(357) = locint(brname);
  locate(358) = locint(iform);
  locate(359) = locint(node);
  locate(360) = locint(crest);
  locate(361) = locint(time1);
  locate(362) = locint(time2);
  locate(363) = locint(tstart);
  locate(364) = locint(sfreq);
  locate(365) = locint(kmswit);
  locate(366) = locint(nextsw);
  locate(367) = locint(rmfd);
  locate(368) = locint(cikfd);
  locate(369) = locint(imfd);
  locate(370) = locint(tclose);
  locate(371) = locint(adelay);
  locate(372) = locint(kpos);
  locate(373) = locint(e);
  locate(374) = locint(f);
  locate(375) = locint(kssfrq);
  locate(376) = locint(kode);
  locate(377) = locint(kpsour);
  locate(378) = locint(volti);
  locate(379) = locint(voltk);
  locate(380) = locint(volt);
  locate(381) = locint(bus);
  double eld = fem::double0;
  locate(382) = locint(eld);
  double elaf = fem::double0;
  locate(383) = locint(elaf);
  double elf = fem::double0;
  locate(384) = locint(elf);
  double elakd = fem::double0;
  locate(385) = locint(elakd);
  double elfkd = fem::double0;
  locate(386) = locint(elfkd);
  double elkd = fem::double0;
  locate(387) = locint(elkd);
  double elq = fem::double0;
  locate(388) = locint(elq);
  double elag = fem::double0;
  locate(389) = locint(elag);
  double elg = fem::double0;
  locate(390) = locint(elg);
  double elakq = fem::double0;
  locate(391) = locint(elakq);
  double elgkq = fem::double0;
  locate(392) = locint(elgkq);
  double elkq = fem::double0;
  locate(393) = locint(elkq);
  double el0 = fem::double0;
  locate(394) = locint(el0);
  double ra = fem::double0;
  locate(395) = locint(ra);
  double rf = fem::double0;
  locate(396) = locint(rf);
  double rkd = fem::double0;
  locate(397) = locint(rkd);
  double rg = fem::double0;
  locate(398) = locint(rg);
  double rkq = fem::double0;
  locate(399) = locint(rkq);
  double r0 = fem::double0;
  locate(400) = locint(r0);
  double agline = fem::double0;
  locate(401) = locint(agline);
  double rat1 = fem::double0;
  locate(402) = locint(rat1);
  double smoutp = fem::double0;
  locate(403) = locint(smoutp);
  double smoutq = fem::double0;
  locate(404) = locint(smoutq);
  double teg = fem::double0;
  locate(405) = locint(teg);
  double texc = fem::double0;
  locate(406) = locint(texc);
  double cnp = fem::double0;
  locate(407) = locint(cnp);
  double a22 = fem::double0;
  locate(408) = locint(a22);
  double a12 = fem::double0;
  locate(409) = locint(a12);
  double a21 = fem::double0;
  locate(410) = locint(a21);
  double ac = fem::double0;
  locate(411) = locint(ac);
  double ai = fem::double0;
  locate(412) = locint(ai);
  double at = fem::double0;
  locate(413) = locint(at);
  double ah = fem::double0;
  locate(414) = locint(ah);
  double xay = fem::double0;
  locate(415) = locint(xay);
  locate(416) = locint(cu);
  double cv = fem::double0;
  locate(417) = locint(cv);
  double dsat = fem::double0;
  locate(418) = locint(dsat);
  double qsat = fem::double0;
  locate(419) = locint(qsat);
  double acr = fem::double0;
  locate(420) = locint(acr);
  double ce = fem::double0;
  locate(421) = locint(ce);
  double dsr = fem::double0;
  locate(422) = locint(dsr);
  double dsd = fem::double0;
  locate(423) = locint(dsd);
  double hico = fem::double0;
  locate(424) = locint(hico);
  double dsm = fem::double0;
  locate(425) = locint(dsm);
  double hsp = fem::double0;
  locate(426) = locint(hsp);
  double power = fem::double0;
  locate(427) = locint(power);
  double extrs = fem::double0;
  locate(428) = locint(extrs);
  locate(429) = locint(histq);
  double histr = fem::double0;
  locate(430) = locint(histr);
  double yfor = fem::double0;
  locate(431) = locint(yfor);
  double zsk = fem::double0;
  locate(432) = locint(zsk);
  double y = fem::double0;
  locate(433) = locint(y);
  double tork = fem::double0;
  locate(434) = locint(tork);
  double temp = fem::double0;
  locate(435) = locint(temp);
  locate(436) = locint(z);
  locate(437) = locint(x1);
  locate(438) = locint(cmn.sqrt3);
  locate(439) = locint(cmn.asqrt3);
  locate(440) = locint(cmn.sqrt32);
  locate(441) = locint(cmn.thtw);
  locate(442) = locint(cmn.athtw);
  locate(443) = locint(cmn.radeg);
  locate(444) = locint(cmn.omdt);
  locate(445) = locint(cmn.factom);
  locate(446) = locint(cmn.damrat);
  int isat = fem::int0;
  locate(447) = locint(isat);
  int ised = fem::int0;
  locate(448) = locint(ised);
  int iseq = fem::int0;
  locate(449) = locint(iseq);
  int imdual = fem::int0;
  locate(450) = locint(imdual);
  int iconfg = fem::int0;
  locate(451) = locint(iconfg);
  int kmac = fem::int0;
  locate(452) = locint(kmac);
  int kexc = fem::int0;
  locate(453) = locint(kexc);
  int numas = fem::int0;
  locate(454) = locint(numas);
  int nodma = fem::int0;
  locate(455) = locint(nodma);
  int nodmb = fem::int0;
  locate(456) = locint(nodmb);
  int nodmc = fem::int0;
  locate(457) = locint(nodmc);
  int jasmit = fem::int0;
  locate(458) = locint(jasmit);
  int jsmtor = fem::int0;
  locate(459) = locint(jsmtor);
  int jexcit = fem::int0;
  locate(460) = locint(jexcit);
  int isloc = fem::int0;
  locate(461) = locint(isloc);
  int noutsm = fem::int0;
  locate(462) = locint(noutsm);
  locate(463) = locint(ismout);
  locate(464) = locint(cmn.mfirst);
  locate(465) = locint(cmn.limass);
  locate(466) = locint(cmn.nst);
  locate(467) = locint(cmn.itold);
  locate(468) = locint(cmn.ibrold);
  locate(469) = locint(busum);
  locate(470) = locint(ptheta);
  locate(471) = locint(zthevr);
  locate(472) = locint(vinp);
  locate(473) = locint(zthevs);
  locate(474) = locint(umcur);
  locate(475) = locint(con);
  locate(476) = locint(dumvec);
  locate(477) = locint(dummat);
  locate(478) = locint(date);
  locate(479) = locint(clock);
  locate(480) = locint(pi);
  locate(481) = locint(cmn.sroot2);
  locate(482) = locint(cmn.sroot3);
  locate(483) = locint(cmn.omegrf);
  locate(484) = locint(cmn.inpu);
  locate(485) = locint(cmn.numbus);
  locate(486) = locint(cmn.ncltot);
  locate(487) = locint(ndum);
  locate(488) = locint(cmn.initum);
  locate(489) = locint(cmn.iureac);
  locate(490) = locint(cmn.iugpar);
  locate(491) = locint(cmn.iufpar);
  locate(492) = locint(cmn.iuhist);
  locate(493) = locint(cmn.iuumrp);
  locate(494) = locint(cmn.iunod1);
  locate(495) = locint(cmn.iunod2);
  locate(496) = locint(cmn.iujclt);
  locate(497) = locint(cmn.iujclo);
  locate(498) = locint(cmn.iujtyp);
  locate(499) = locint(cmn.iunodo);
  locate(500) = locint(cmn.iujtmt);
  locate(501) = locint(cmn.iuhism);
  locate(502) = locint(cmn.iuomgm);
  locate(503) = locint(cmn.iuomld);
  locate(504) = locint(cmn.iutham);
  locate(505) = locint(cmn.iuredu);
  locate(506) = locint(cmn.iureds);
  locate(507) = locint(cmn.iuflds);
  locate(508) = locint(cmn.iufldr);
  locate(509) = locint(cmn.iurequ);
  locate(510) = locint(cmn.iuflqs);
  locate(511) = locint(cmn.iuflqr);
  locate(512) = locint(cmn.iujcds);
  locate(513) = locint(cmn.iujcqs);
  locate(514) = locint(cmn.iuflxd);
  locate(515) = locint(cmn.iuflxq);
  locate(516) = locint(cmn.iunppa);
  locate(517) = locint(cmn.iurotm);
  locate(518) = locint(cmn.iuncld);
  locate(519) = locint(cmn.iunclq);
  locate(520) = locint(cmn.iujtqo);
  locate(521) = locint(cmn.iujomo);
  locate(522) = locint(cmn.iujtho);
  locate(523) = locint(cmn.iureqs);
  locate(524) = locint(cmn.iuepso);
  locate(525) = locint(cmn.iudcoe);
  locate(526) = locint(cmn.iukcoi);
  locate(527) = locint(cmn.iuvolt);
  locate(528) = locint(cmn.iuangl);
  locate(529) = locint(cmn.iunodf);
  locate(530) = locint(cmn.iunodm);
  locate(531) = locint(cmn.iukumo);
  locate(532) = locint(cmn.iujumo);
  locate(533) = locint(cmn.iuumou);
  locate(534) = locint(cmn.nclfix);
  locate(535) = locint(cmn.numfix);
  locate(536) = locint(cmn.iotfix);
  locate(537) = locint(cmn.ibsfix);
  locate(538) = locint(cmn.ksubum);
  locate(539) = locint(cmn.nsmach);
  locate(540) = locint(cmn.istart);
  locate(541) = locint(karray);
  locate(542) = locint(rampcn);
  locate(543) = locint(rampsl);
  locate(544) = locint(kyramp);
  locate(545) = locint(texpar);
  locate(546) = locint(fendrp);
  locate(547) = locint(cmn.tminrp);
  locate(548) = locint(cmn.tmaxrp);
  locate(549) = locint(tbegrp);
  locate(550) = locint(tendrp);
  locate(551) = locint(fbegrp);
  locate(552) = locint(cmn.tbreak);
  locate(553) = locint(indxrp);
  locate(554) = locint(ivec);
  locate(555) = locint(iascii);
  locate(556) = locint(cmn.numsym);
  locate(557) = locint(cmn.jjroll);
  locate(558) = locint(cmn.itexp);
  locate(559) = locint(labels);
  locate(560) = locint(cmn.maxarg);
  locate(561) = locint(cmn.kilper);
  locate(562) = locint(cmn.kfile5);
  locate(563) = locint(cmn.kverfy);
  locate(564) = locint(cmn.ibegcl);
  locate(565) = locint(cmn.iendcl);
  locate(566) = locint(cmn.lidnt1);
  locate(567) = locint(cmn.lidnt2);
  locate(568) = locint(cmn.linnow);
  locate(569) = locint(cmn.linspn);
  locate(570) = locint(cmn.numcrd);
  locate(571) = locint(cmn.munit5);
  locate(572) = locint(cmn.indbuf);
  locate(573) = locint(cmn.indbeg);
  locate(574) = locint(cmn.mflush);
  locate(575) = locint(cmn.newvec);
  locate(576) = locint(cmn.munit6);
  locate(577) = locint(cmn.lserlc);
  locate(578) = locint(cmn.kserlc);
  locate(579) = locint(cmn.kbrser);
  locate(580) = locint(cmn.lockbr);
  locate(581) = locint(cmn.iprspy);
  locate(582) = locint(cmn.monitr);
  locate(583) = locint(cmn.monits);
  locate(584) = locint(locate);
  locate(585) = locint(nline);
  locate(586) = locint(cmn.kwtspy);
  locate(587) = locint(cmn.kbreak);
  locate(588) = locint(cmn.limbuf);
  locate(589) = locint(cmn.inchlp);
  locate(590) = locint(cmn.ksymbl);
  locate(591) = locint(cmn.kopyit);
  locate(592) = locint(cmn.kslowr);
  locate(593) = locint(cmn.limcrd);
  locate(594) = locint(looprp);
  locate(595) = locint(n10rmp);
  locate(596) = locint(memrmp);
  locate(597) = locint(kar1);
  locate(598) = locint(kar2);
  locate(599) = locint(cmn.numrmp);
  locate(600) = locint(cmn.luntsp);
  locate(601) = locint(cmn.logvar);
  locate(602) = locint(filext);
  locate(603) = locint(symb);
  locate(604) = locint(col);
  locate(605) = locint(cmn.bytfnd);
  locate(606) = locint(cmn.char1);
  locate(607) = locint(symbrp);
  double chard4 = fem::double0;
  locate(608) = locint(chard4);
  locate(609) = locint(cmn.bytbuf);
  locate(610) = locint(cmn.buff77);
  locate(611) = locint(file6b);
  locate(612) = locint(file6);
  locate(613) = locint(cmn.blan80);
  locate(614) = locint(cmn.prom80);
  locate(615) = locint(digit);
  int iac = fem::int0;
  locate(616) = locint(iac);
  int idctcs = fem::int0;
  locate(617) = locint(idctcs);
  int ipl = fem::int0;
  locate(618) = locint(ipl);
  int ipr = fem::int0;
  locate(619) = locint(ipr);
  int ixr = fem::int0;
  locate(620) = locint(ixr);
  int jpl = fem::int0;
  locate(621) = locint(jpl);
  int jpr = fem::int0;
  locate(622) = locint(jpr);
  int kint = fem::int0;
  locate(623) = locint(kint);
  int kout = fem::int0;
  locate(624) = locint(kout);
  int nds = fem::int0;
  locate(625) = locint(nds);
  int nkn = fem::int0;
  locate(626) = locint(nkn);
  int nmax = fem::int0;
  locate(627) = locint(nmax);
  locate(628) = locint(nuk);
  int kwrite = fem::int0;
  locate(629) = locint(kwrite);
  int kpr = fem::int0;
  locate(630) = locint(kpr);
  int kpl = fem::int0;
  locate(631) = locint(kpl);
  int mxtacw = fem::int0;
  locate(632) = locint(mxtacw);
  int iptacw = fem::int0;
  locate(633) = locint(iptacw);
  int nhst = fem::int0;
  locate(634) = locint(nhst);
  int kvin = fem::int0;
  locate(635) = locint(kvin);
  int kvou = fem::int0;
  locate(636) = locint(kvou);
  int kvxx = fem::int0;
  locate(637) = locint(kvxx);
  int icsup = fem::int0;
  locate(638) = locint(icsup);
  int nxic = fem::int0;
  locate(639) = locint(nxic);
  int kksj = fem::int0;
  locate(640) = locint(kksj);
  int kksk = fem::int0;
  locate(641) = locint(kksk);
  int kkfst = fem::int0;
  locate(642) = locint(kkfst);
  int kkni = fem::int0;
  locate(643) = locint(kkni);
  int kkhst = fem::int0;
  locate(644) = locint(kkhst);
  int kifls = fem::int0;
  locate(645) = locint(kifls);
  int kidum = fem::int0;
  locate(646) = locint(kidum);
  int kslim1 = fem::int0;
  locate(647) = locint(kslim1);
  int kslim2 = fem::int0;
  locate(648) = locint(kslim2);
  int kslim3 = fem::int0;
  locate(649) = locint(kslim3);
  int kpac1r = fem::int0;
  locate(650) = locint(kpac1r);
  int kpac1i = fem::int0;
  locate(651) = locint(kpac1i);
  int kpac2r = fem::int0;
  locate(652) = locint(kpac2r);
  int kpac2i = fem::int0;
  locate(653) = locint(kpac2i);
  int kalksx = fem::int0;
  locate(654) = locint(kalksx);
  int kilms1 = fem::int0;
  locate(655) = locint(kilms1);
  int kilms2 = fem::int0;
  locate(656) = locint(kilms2);
  int kdumj = fem::int0;
  locate(657) = locint(kdumj);
  int kdumk = fem::int0;
  locate(658) = locint(kdumk);
  int kkzj = fem::int0;
  locate(659) = locint(kkzj);
  int kkzk = fem::int0;
  locate(660) = locint(kkzk);
  int kiflz = fem::int0;
  locate(661) = locint(kiflz);
  int kgnz = fem::int0;
  locate(662) = locint(kgnz);
  int kzlim1 = fem::int0;
  locate(663) = locint(kzlim1);
  int kzlim2 = fem::int0;
  locate(664) = locint(kzlim2);
  int kalkzx = fem::int0;
  locate(665) = locint(kalkzx);
  int kilmz1 = fem::int0;
  locate(666) = locint(kilmz1);
  int kilmz2 = fem::int0;
  locate(667) = locint(kilmz2);
  locate(668) = locint(kksus);
  locate(669) = locint(kalksu);
  locate(670) = locint(kiuty);
  locate(671) = locint(kud1);
  int kud2 = fem::int0;
  locate(672) = locint(kud2);
  int kud3 = fem::int0;
  locate(673) = locint(kud3);
  int kud4 = fem::int0;
  locate(674) = locint(kud4);
  int kud5 = fem::int0;
  locate(675) = locint(kud5);
  locate(676) = locint(kaliu);
  int ktysup = fem::int0;
  locate(677) = locint(ktysup);
  int kjsup = fem::int0;
  locate(678) = locint(kjsup);
  int kksup = fem::int0;
  locate(679) = locint(kksup);
  locate(680) = locint(kspvar);
  int kopsup = fem::int0;
  locate(681) = locint(kopsup);
  int kfnsup = fem::int0;
  locate(682) = locint(kfnsup);
  int krgsup = fem::int0;
  locate(683) = locint(krgsup);
  locate(684) = locint(kprsup);
  int ktypdv = fem::int0;
  locate(685) = locint(ktypdv);
  int kkdj = fem::int0;
  locate(686) = locint(kkdj);
  int kkdk = fem::int0;
  locate(687) = locint(kkdk);
  int kgndev = fem::int0;
  locate(688) = locint(kgndev);
  int kdev1 = fem::int0;
  locate(689) = locint(kdev1);
  int kdev2 = fem::int0;
  locate(690) = locint(kdev2);
  int kldev1 = fem::int0;
  locate(691) = locint(kldev1);
  int kldev2 = fem::int0;
  locate(692) = locint(kldev2);
  int kkdus = fem::int0;
  locate(693) = locint(kkdus);
  int kalkdu = fem::int0;
  locate(694) = locint(kalkdu);
  int ktbdev = fem::int0;
  locate(695) = locint(ktbdev);
  int kpn = fem::int0;
  locate(696) = locint(kpn);
  int kpd = fem::int0;
  locate(697) = locint(kpd);
  int kxhst = fem::int0;
  locate(698) = locint(kxhst);
  int khscr = fem::int0;
  locate(699) = locint(khscr);
  int khsci = fem::int0;
  locate(700) = locint(khsci);
  int kilim1 = fem::int0;
  locate(701) = locint(kilim1);
  int kilim2 = fem::int0;
  locate(702) = locint(kilim2);
  int krowcs = fem::int0;
  locate(703) = locint(krowcs);
  int krhsde = fem::int0;
  locate(704) = locint(krhsde);
  int kvlim1 = fem::int0;
  locate(705) = locint(kvlim1);
  int kvlim2 = fem::int0;
  locate(706) = locint(kvlim2);
  int kkxic = fem::int0;
  locate(707) = locint(kkxic);
  locate(708) = locint(kawkcs);
  locate(709) = locint(kxar);
  int kxai = fem::int0;
  locate(710) = locint(kxai);
  int kbwkcs = fem::int0;
  locate(711) = locint(kbwkcs);
  locate(712) = locint(kxtcs);
  locate(713) = locint(klntab);
  int klmxic = fem::int0;
  locate(714) = locint(klmxic);
  locate(715) = locint(kcolcs);
  locate(716) = locint(katcs);
  int kbtcs = fem::int0;
  locate(717) = locint(kbtcs);
  locate(718) = locint(kjout);
  int kkout = fem::int0;
  locate(719) = locint(kkout);
  int kxmncs = fem::int0;
  locate(720) = locint(kxmncs);
  int ktxmn = fem::int0;
  locate(721) = locint(ktxmn);
  int kxmxcs = fem::int0;
  locate(722) = locint(kxmxcs);
  int ktxmx = fem::int0;
  locate(723) = locint(ktxmx);
  int klnout = fem::int0;
  locate(724) = locint(klnout);
  locate(725) = locint(ekbuf);
  locate(726) = locint(ektemp);
  locate(727) = locint(cmn.errchk);
  locate(728) = locint(solrsv);
  locate(729) = locint(solisv);
  locate(730) = locint(cmn.nitera);
  locate(731) = locint(cmn.nekreq);
  locate(732) = locint(nekcod);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct initsp_save
{
  arr<fem::str<8> > textay;

  initsp_save() :
    textay(dimension(75), fem::fill0)
  {}
};

void initsp(
  common& cmn) try
{
  FEM_CMN_SVE(initsp);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  int& iprspy = cmn.iprspy;
  int& limbuf = cmn.limbuf;
  auto& memrmp = cmn.memrmp;
  bool& logvar = cmn.logvar;
  auto& filext = cmn.filext;
  auto& digit = cmn.digit;
  auto& spykwd = cmn.spykwd;
  fem::str<32>& ansi32 = cmn.ansi32;
  fem::str<132>& munit6 = cmn.munit6;
  //
  auto& textay = sve.textay;
  if (is_called_first_time) {
    textay(1) = "HEADING ";
    textay(2) = "STOP    ";
    textay(3) = "PLOT    ";
    textay(4) = "HELP    ";
    textay(5) = "EXAMINE ";
    textay(6) = "DEPOSIT ";
    textay(7) = "SWITCH  ";
    textay(8) = "APPEND  ";
    textay(9) = "SAVE    ";
    textay(10) = "RESTORE ";
    textay(11) = "GO      ";
    textay(12) = "ECHO    ";
    textay(13) = "FIND    ";
    textay(14) = "LIST    ";
    textay(15) = "SPY     ";
    textay(16) = "BREAK   ";
    textay(17) = "WHEN    ";
    textay(18) = "COMMENT ";
    textay(19) = "@?      ";
    textay(20) = "ROLL    ";
    textay(21) = "TYPE?   ";
    textay(22) = "VERIFY  ";
    textay(23) = "FILES   ";
    textay(24) = "SLEEP   ";
    textay(25) = "SOURCE  ";
    textay(26) = "EDIT    ";
    textay(27) = "WAKE    ";
    textay(28) = "LANGUAGE";
    textay(29) = "CATALOG ";
    textay(30) = "BEGIN   ";
    textay(31) = "STEP    ";
    textay(32) = "DEBUG   ";
    textay(33) = "DATA    ";
    textay(34) = "RAMP    ";
    textay(35) = "TIME    ";
    textay(36) = "TEK     ";
    textay(37) = "BRANCH  ";
    textay(38) = "YFORM   ";
    textay(39) = "NOY     ";
    textay(40) = "FACTOR  ";
    textay(41) = "NOF     ";
    textay(42) = "RLC     ";
    textay(43) = "WIDTH   ";
    textay(44) = "BUS     ";
    textay(45) = "SIZE    ";
    textay(46) = "LIMIT   ";
    textay(47) = "IOUT    ";
    textay(48) = "NODE    ";
    textay(49) = "NONLIN  ";
    textay(50) = "SPACE   ";
    textay(51) = "LUNIT4  ";
    textay(52) = "SERIES  ";
    textay(53) = "LOCK    ";
    textay(54) = "[Y]     ";
    textay(55) = "[F]     ";
    textay(56) = "NOROLL  ";
    textay(57) = "OPEN    ";
    textay(58) = "CLOSE   ";
    textay(59) = "SM      ";
    textay(60) = "HONK    ";
    textay(61) = "CHOICE  ";
    textay(62) = "TACS    ";
    textay(63) = "WAIT    ";
    textay(64) = "V-I     ";
    textay(65) = "        ";
  }
  int n3 = fem::int0;
  int j = fem::int0;
  double tdroll = fem::double0;
  //C     MODULE OF INTERACTIVE EMTP ONLY, WHICH SERVICES "EMTSPY".         M35.2802
  //C     IF NO INTERACTIVE EMTP USE, THIS MODULE CAN BE DELETED.           M36.3109
  //C     UNIVERSAL INITIALIZATION MODULE FOR "SPYING".   CONSTANTS         M36.3110
  //C     MUST BE SET ONLY ONCE, AT THE BEGINNING OF EXECUTION ONLY.        M36.3111
  //C     NEXT COME ALL POSSIBLE KEY-WORD RESPONSES TO "SPY:" PROMPT:       M36.3113
  n3 = 29;
  dimens(memrmp(1), n3, bus1, bus1);
  limbuf = memrmp(2);
  if (iprspy < 1) {
    goto statement_1144;
  }
  write(munit6, "(' NEAR TOP OF \"INITSP\".  LIMBUF =',i8)"), limbuf;
  window(cmn);
  statement_1144:
  cmn.lockbr = 1;
  cmn.kbreak = 0;
  cmn.indbuf = 0;
  cmn.noback = 0;
  cmn.monitr = 0;
  cmn.monits = 0;
  cmn.inchlp = 0;
  cmn.kslowr = 5;
  cmn.maxflg = 1;
  cmn.tbreak = 8877.e33f;
  cmn.kspsav = 0;
  cmn.numrmp = 0;
  cmn.kbrser = 0;
  cmn.kserlc = 0;
  cmn.lserlc = 0;
  cmn.komadd = 0;
  cmn.blan80 = " ";
  FEM_DO_SAFE(j, 1, 9999) {
    if (textay(j) == "        ") {
      goto statement_1152;
    }
    spykwd(j) = textay(j);
  }
  statement_1152:
  cmn.numkey = j - 1;
  cmn.nexmod = 0;
  cmn.junker = "JUNK    ";
  digit(1) = "1";
  digit(2) = "2";
  digit(3) = "3";
  digit(4) = "4";
  digit(5) = "5";
  digit(6) = "6";
  digit(7) = "7";
  digit(8) = "8";
  digit(9) = "9";
  digit(10) = "0";
  locatn(cmn);
  FEM_DO_SAFE(j, 1, 9) {
    filext(j) = " ";
    write(ansi32, "('INCLSPY',i1,'.DAT',13x)"), j;
    cmn.io.inquire_file(ansi32)
      .exist(logvar);
    if (logvar) {
      filext(j) = "X";
    }
    if (iprspy < 1) {
      goto statement_2795;
    }
    write(munit6,
      "(' NEXT USE OF \"INQUIRE\".  J, ANSI32 =',i5,1x,a32)"), j,
      ansi32;
    window(cmn);
    statement_2795:;
  }
  cmn.kwtspy = 0;
  cmn.jjroll = 0;
  tdroll = 1.0f;
  cmn.kfile5 = 0;
  cmn.lidnt1 = 1;
  cmn.lidnt2 = 1;
  cmn.linspn = 1;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void stopin(
  common& cmn) try
{
  common_read read(cmn);
  common_write write(cmn);
  auto& lstat = cmn.lstat;
  int& istep = cmn.istep;
  fem::str<80>& buff77 = cmn.buff77;
  auto& file6 = cmn.file6;
  fem::str<132>& munit6 = cmn.munit6;
  //
  //C     UNIVERSAL MODULE OF INTERACTIVE EMTP (SPY OF "EMTSPY").           M37. 831
  //C     IF NON-INTERACTIVE VERSION, MODULE CAN BE DESTROYED.  THIS        M37. 832
  //C     MODULE IS CALLED ONLY TO DISPLAY ERRONEOUS FILE6(ISTEP), &        M37. 833
  //C     PROMPT USER TO SEND A CORRECTED COPY.  CALLED BY "DATAIN".        M37. 834
  write(munit6,
    "('   ? ? ?   Trouble with input data.  last card',' number',i5,"
    "'   is in error.')"),
    istep;
  window(cmn);
  write(munit6,
    "('     1234567890123456789012345678901234567890',"
    "'1234567890123456789012345678901234567890')");
  window(cmn);
  write(munit6, "(a80)"), file6(istep);
  window(cmn);
  if (cmn.m4plot == 1) {
    goto statement_1227;
  }
  cmn.kill = 79;
  lstat(19) = 1218;
  goto statement_9000;
  statement_1227:
  write(cmn.prom80, "(' SEND CORRECTED CARD (SPY, STOP) :')");
  prompt(cmn);
  read(cmn.munit5, "(a80)"), buff77;
  if (buff77(1, 4) == "STOP") {
    stoptp(cmn);
  }
  if (buff77(1, 4) != "SPY") {
    goto statement_1244;
  }
  spying(cmn);
  goto statement_9000;
  statement_1244:
  file6(istep) = buff77;
  statement_9000:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct datain_save
{
  fem::str<6> dumnam;
  fem::str<32> filsav;
  int komlev;
  arr<int> lentyp;
  int nchpre;
  int nchsuf;
  int numtyp;
  arr<fem::str<12> > typdat;

  datain_save() :
    dumnam(fem::char0),
    filsav(fem::char0),
    komlev(fem::int0),
    lentyp(dimension(18), fem::fill0),
    nchpre(fem::int0),
    nchsuf(fem::int0),
    numtyp(fem::int0),
    typdat(dimension(18), fem::fill0)
  {}
};

bool data_input(common& cmn) try {
  common_write write(cmn);
  auto& buff77 = cmn.buff77;
  auto& file6 = cmn.file6;
  int numhld = 0;
  int krdoff = 0;
  int kcut = 0;
  int krdcom = 0;

  cmn.iprspy = 0;
  cmn.iprsup = 0;     // DIAGNOSTIC EMTP PRINTOUT (0 OR 99)
  cmn.iprsov(1) = 0;  // EMTP DIAGNOSTIC ONLY THRU 1ST OVERLAY
  cmn.m4plot = 2;
  cmn.numcrd = 1;     // SO FAR, WE HAVE READ ONE INPUT DATA CARD

  arr<fem::str<80> > tank(dimension(1000), fem::fill0);

  std::string sLine;
  for (int j = 1; std::getline(cmn.inp_stream, sLine); ++j) {
    sLine.resize(80, ' ');
    file6(krdoff + j) = sLine;
    if (kcut == 1) {
      goto statement_5486;
    }
    if (file6(krdoff + j)(1, 2) == "C ") {
      krdcom++;
    }
    if (file6(krdoff + j)(1, 19) != "BEGIN NEW DATA CASE" || j - krdcom <= 3) {
      goto statement_1756;
    }
    kcut = 1;
  statement_5486:
    numhld++;
    if (numhld > 1000) {
      write(cmn.lunit6, "(1x,a30)"), " Input data cards overflow !";
      //cmn.log_stream << " Input data cards overflow !\n";
      return false;
    }

    tank(numhld) = file6(krdoff + j);
    //C     IF ALL EMTP DATA (E.G., "KILL CODES" USE) COMES VIA KEY           M37. 240
    //C     BOARD, IT IS ENDED WITH "EOF"; WHEN SOLVED, MORE KEYBOARD.        M37. 241
  statement_1756:
    if (file6(krdoff + j)(1, 4) == "EOF ") {
      return true;
    }
    //C ANOTHER INPUT DATA CARD NOW READ
    if (kcut == 0) {
      cmn.numcrd++;
    }
  }
  return true;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void datain(
  common& cmn) try
{
  FEM_CMN_SVE(datain);
  common_read read(cmn);
  common_write write(cmn);
  auto& date1= cmn.date1;
  auto& tclock= cmn.tclock;
  auto& lunt13 = cmn.lunt13;
  auto& lstat = cmn.lstat;
  auto& iprsov= cmn.iprsov;
  int& istep = cmn.istep;
  int& m4plot = cmn.m4plot;
  int& llbuff = cmn.llbuff;
  int& numdcd = cmn.numdcd;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  int& kverfy = cmn.kverfy;
  int& numcrd = cmn.numcrd;
  int& munit5 = cmn.munit5;
  int& lockbr = cmn.lockbr;
  int& iprspy = cmn.iprspy;
  int& limcrd = cmn.limcrd;
  bool& logvar = cmn.logvar;
  fem::str<1>& char1 = cmn.char1;
  fem::str<80>& buff77 = cmn.buff77;
  auto& file6 = cmn.file6;
  fem::str<80>& blan80 = cmn.blan80;
  fem::str<80>& prom80 = cmn.prom80;
  const auto& digit = cmn.digit;
  auto& ansi8 = cmn.ansi8;
  auto& ansi32 = cmn.ansi32;
  auto& answ80 = cmn.answ80;
  auto& munit6 = cmn.munit6;
  auto& kssfrq = cmn.kssfrq;
  auto& kode = cmn.kode;
  auto& kpsour = cmn.kpsour;
  int& kexact = cmn.kexact;
  int& numrun = cmn.numrun;
  //
  fem::str<6>& dumnam = sve.dumnam;
  fem::str<32>& filsav = sve.filsav;
  int& komlev = sve.komlev;
  auto& lentyp = sve.lentyp;
  int& nchpre = sve.nchpre;
  int& nchsuf = sve.nchsuf;
  int& numtyp = sve.numtyp;
  auto& typdat = sve.typdat;
  if (is_called_first_time) {
    komlev = -1;
    nchpre = 0;
    nchsuf = 0;
    dumnam = "DUM   ";
    typdat(1) = "REQUEST     ";
    lentyp(1) = 7;
    typdat(2) = "FUNCTION    ";
    lentyp(2) = 8;
    typdat(3) = "TACS SOURCE ";
    lentyp(3) = 11;
    typdat(4) = "SUPPLEMENTAL";
    lentyp(4) = 12;
    typdat(5) = "TACS OUTPUT ";
    lentyp(5) = 11;
    typdat(6) = "TACS INITIAL";
    lentyp(6) = 12;
    typdat(7) = "BRANCH      ";
    lentyp(7) = 6;
    typdat(8) = "SWITCH      ";
    lentyp(8) = 6;
    typdat(9) = "SOURCE      ";
    lentyp(9) = 6;
    typdat(10) = "LOAD FLOW   ";
    lentyp(10) = 9;
    typdat(11) = "INITIAL     ";
    lentyp(11) = 7;
    typdat(12) = "OUTPUT      ";
    lentyp(12) = 6;
    typdat(13) = "PLOT        ";
    lentyp(13) = 4;
    typdat(14) = "STATISTICS  ";
    lentyp(14) = 10;
    numtyp = 14;
    filsav = "                                ";
  }
  int j = fem::int0;
  arr<fem::str<80> > tank(dimension(1000), fem::fill0);
  int k = fem::int0;
  int kcut = fem::int0;
  int limarg = fem::int0;
  int n13 = fem::int0;
  int ntacs = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int n16 = fem::int0;
  int n14 = fem::int0;
  int krdoff = fem::int0;
  int krdcom = fem::int0;
  int n22 = fem::int0;
  int n17 = fem::int0;
  int L = fem::int0;
  int m = fem::int0;
  int n5 = fem::int0;
  fem::str<40> prefix = fem::char0;
  fem::str<40> suffix = fem::char0;
  int kntdum = fem::int0;
  int n26 = fem::int0;
  int n7 = fem::int0;
  int n8 = fem::int0;
  int n19 = fem::int0;
  int n12 = fem::int0;
  int n15 = fem::int0;
  arr_1d<35, int> kolinc(fem::fill0);
  int n18 = fem::int0;
  arr_1d<35, fem::str<20> > arginc(fem::fill0);
  arr_1d<200, int> kard(fem::fill0);
  int n1 = fem::int0;
  arr_1d<200, int> kbeg(fem::fill0);
  int n6 = fem::int0;
  arr_1d<200, int> karg(fem::fill0);
  arr_1d<200, int> kend(fem::fill0);
  arr_1d<200, int> ktex(fem::fill0);
  int n20 = fem::int0;
  int n24 = fem::int0;
  int kntmax = fem::int0;
  int kntold = fem::int0;
  int n2 = fem::int0;
  int n4 = fem::int0;
  int n3 = fem::int0;
  int n = fem::int0;
  int ip = fem::int0;
  int n10 = fem::int0;
  int n11 = fem::int0;
  int munit4 = fem::int0;
  int nn1 = fem::int0;
  int nn2 = fem::int0;
  int ll = fem::int0;
  int numarg = fem::int0;
  arr_1d<35, int> modarg(fem::fill0);
  arr_1d<35, int> kkkdum(fem::fill0);
  static const char* format_1329 = "(a80)";
  static const char* format_1737 =
    "('  ----  Illegal file name.  Try again ....')";
  static const char* format_2791 = "(a4,25i3,/(4x,25i3))";
  static const char* format_4223 =
    "(' DONE WITH ARGUMENT.  L, N12, N13, N14, N26 =',8i6)";
  static const char* format_4232 = "(4x,25i3)";
  static const char* format_4237 = "(4x,25i3)";

  //C     UNIVERSAL MODULE OF INTERACTIVE EMTP (SPY OF "EMTSPY").          
  //C     IF NON-INTERACTIVE VERSION, MODULE CAN BE DESTROYED.             
  //C     FIRST EMTP DATA INPUT, AND "SPY" CHOICE, ARE MADE HERE.          
  //C     MODULE IS CALLED ONLY BY INSTALLATION-DEPENDENT "EREXIT".        
  //C DEFAULT COMMENT LEVEL (NONE)
  //C BEGIN WITH NO FILE NAME PREFIX
  //C BEGIN WITH NO FILE NAME SUFFIX
  //C DEFAULT DUMMY ROOT NAME
  //C TOTAL NUMBER OF DATA TYPE NAMES
  //C for LMFS
  //C INIT. NUMRUN for LMFS runs

  static int numhld = fem::int0;

  if (kexact != 88333) {
    numrun = 0;
  }
  if (kexact == 88333 && numrun > 0) {
    goto statement_5266;
  }
  if (numhld ==  - 8899) {
    FEM_STOP(0);
  }
  if (numhld == 0) {
    goto statement_5244;
  }
  FEM_DO_SAFE(j, 1, numhld) {
    if (tank(j)(1, 19) == "BEGIN NEW DATA CASE" && j > 3) {
      goto statement_3389;
    }
    file6(j) = tank(j);
  }
  statement_3389:
  numcrd = j - 1;
  FEM_DO_SAFE(k, j, numhld) {
    tank(k - numcrd) = tank(k);
  }
  numhld = numhld - numcrd;
  if (numhld <= 0) {
    numhld = -8899;
  }
  numdcd = 0;
  goto statement_1774;
  statement_5266:
  kcut = 0;
  //C data input assigned from outside
  if (filsav == "                                ") {
    goto statement_1712;
  }
  //C reuse input for
  cmn.io.open(munit5, filsav)
    .status("OLD");
  //Cgenerating 2nd & 3rd LMF
  statement_1712:
  if (llbuff ==  - 3333) {
    cmn.io.rewind(munit5);
  }
  //C 2ND OR LATER PASS, SKIP
  //C KEYBOARD
  statement_5244:
  //if (llbuff !=  - 3333 && file6(numcrd + 1)(1, 4) != "EOF ") {
  //  goto statement_1708;
  //}
  //C LOCAL FLAG (NO WINDOWS YET OPENED)
  kverfy = -4545;
  //C DIMENSIONED LIMIT ON ARGUMENTS OF "MODULE"
  limarg = 35;
  //C SET POINTER AT ZERO (NO "CIMAGE" CALLS YET)
  numdcd = 0;
  //C I/O CHANNEL FOR "EMTSPY" INPUT (KEYBOARD)
  munit5 = 5;
  //C PRESENT FIXED LIMIT ON FILE6 OF "DEKSPY"
  limcrd = 30000;
  //C INITIALLY ASSUME NO DEBUG PRINTOUT
  n13 = 0;
  //C OLD TACS DATA FORMAT
  ntacs = 0;
  //C FIND CALENDAR DATE AND THE
  date44(cmn, date1(1));
  //C TIME OF DAY FOR DOCUMENTATION
  time44(cmn, tclock(1));
  //C INITIALIZE SPY COMMON (DIGIT NEEDED TO SORT)
  initsp(cmn);
  //C PROMPT USER AT "EMTSPY" KEYBOARD
statement_1311:

#if 0
  write(lunit6,
    "(' EMTP BEGINS.  SEND (SPY, $ATTACH, DEBUG,',"
    "' HELP, MODULE, JUNK, STOP) :')");
  //C READ FIRST CARD OF EMTP DATA
  read(munit5, format_1329), buff77;
  if (buff77(1, 5) == "STOP ") {
    stoptp(cmn);
  }
  if (buff77(1, 5) != "DISK ") {
    goto statement_51329;
  }
  //C SIGNAL TO APOLLO "SYSDEP" FOR DISK LUNIT6
  cmn.maxzno = 4545;
  //C LOOP BACK FOR NON-LUNIT6-DISK EMTP INPUT
  goto statement_1311;
  //C BATCH MODE
  statement_51329:
  if (buff77(1, 7) == "$ATTACH") {
    goto statement_1347;
  }
  if (buff77(1, 5) != "JUNK ") {
    goto statement_1332;
  }
  write(lunit6,
    "('   SEND ROOT WORD TO OVER-RIDE \"JUNK\" FOR',"
    "' SPY AND PLOT WINDOWS :')");
  //C READ NEW WINDOW PAD NAME
  read(munit5, "(a8)"), cmn.junker;
  //C IMPLIED COMMAND NEXT SERVICED
  buff77(1, 8) = "SPY     ";
  //C WINDOWS ALREADY OPEN
  statement_1332:
  if (kverfy == 0) {
    goto statement_41332;
  }
  //C FLAG INDICATING DESIRE TO OPEN WINDOWS
  kverfy = -34543;
  //C OPEN 2 EXTRA WINDOWS FOR SPY AND PLOT
  window(cmn);
  //C ERASE FLAG, NOW THAT BOTH WINDOWS ARE OPEN
  kverfy = 0;
  statement_41332:
  if (buff77(1, 6) == "MODULE") {
    goto statement_2613;
  }
  if (buff77(1, 5) != "HELP ") {
    goto statement_1342;
  }
  write(munit6,
    "('    Greetings, greetings.  Welcome to the',"
    "' wonderful new world of interactive')");
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  write(munit6,
    "('    EMTP execution, observation, and',"
    "' control.  After sending  \"SPY\",  send')");
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  write(munit6,
    "('    \"HELP\",  and then  \"ALL\"  to receive',"
    "' some 500 lines of instruction.  Also,')");
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  write(munit6,
    "('    see Section 9 of the Rule Book dated',"
    "' June, 1984.  Also see  \"Apollo\".')");
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  goto statement_1311;
  statement_1342:
  if (buff77(1, 6) != "DEBUG ") {
    goto statement_1347;
  }

  //C CHANGE DIAGNOSTIC PRINTOUT CONTROL TO "ON"
  n13 = 99;
  //C BACK TO PROMPT FOR INTERACTIVE CHOICE AGAIN
  goto statement_1311;
  //C  DIAGNOSTIC SPY PRINTOUT (0 OR 99)
  statement_1347:
  iprspy = n13;
  //C  DIAGNOSTIC EMTP PRINTOUT (0 OR 99)
  iprsup = n13;
  //C EMTP DIAGNOSTIC ONLY THRU 1ST OVERLAY
  iprsov(1) = n13;
  //C NOT INTERACTIVE
  if (buff77(1, 3) != "SPY") {
    goto statement_1724;
  }
  //C     BEGIN INTERACTIVE CONTROL SEQUENCE, LEADING TO "EMTSPY":          M37. 232
  //C SET FLAG REMEMBERING USE OF SPY
  m4plot = 1;
  //C BUILD VERY 1ST SPY PROMPT
  write(prom80, "(' SPY:')");
  //C WRITE PROM80 WITH CURSOR CONTROL (NO LF)
  prompt(cmn);
  //C NON-INTERACTIVE CASE
  statement_1708:
  if (m4plot != 1) {
    goto statement_2320;
  }
  //C FORCED SPY READ WITHIN "FLAGER"
  lockbr = 1;
  //C B4 ANY EMTP COMPUTATION, START SPY DIALOGUE
  emtspy(cmn);
  //C SPY LOOP UNTIL "GO"
  if (lockbr == 1) {
    goto statement_1708;
  }
  //C JUMP TO $INCLUDE REMOVAL, THEN EXIT MODULE
  goto statement_1774;
  //C     BEGIN NON-INTERACTIVE VARIABLE INITIALIZATION:                    M35. 219
  //C NOT INTERACTIVE, AND USE REAL*4 LUNIT4 PLOTS
statement_1724:

  m4plot = 2;
  //C INITIALLY ASSUME EXTERNALLY-CONNECTED DATA
  lunt13 = 5;
  //C SO FAR, WE HAVE READ ONE INPUT DATA CARD
  numcrd = 1;
  //C 1ST CARD IMAGE PERMANENTLY STORED
  file6(1) = buff77;
  if (buff77(1, 7) != "$ATTACH") {
    goto statement_1753;
  }
  //C       "$ATTACH,FILENAME,5" USAGE REQUIRES EXTRACTION OF NAME:         M35. 225
  //C WE WILL INTERNALLY CONNECT DATA TO UNIT 13
  lunt13 = 13;
  //C COLUMN WHICH BEGINS FILE NAME IS NOT YET KNOWN
  n16 = 0;
  //C SEARCH FOR 2ND COMMA IN THESE COLUMNS
  FEM_DO_SAFE(j, 9, 40) {
    //C IF NONBLANK COLUMN,
    //C AND 1ST, SAVE IT IN N16
    if (buff77(j, j) != " " && n16 == 0) {
      n16 = j;
    }
    //C 2ND COMMA FOUND
    if (buff77(j, j) == ",") {
      goto statement_1746;
    }
  }
  statement_1736:
  write(munit6, format_1737);
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C LOOP BACK TO OPENING PROMPT (REPEAT IT)
  goto statement_1311;
  //C NUMBER OF CHARACTERS IN FILE NAME
  statement_1746:
  n14 = j - n16;
  //C TRANSFER DISK FILE NAME
  ansi32(1, n14) = buff77(n16, j - 1);
  //C BLANK OUT REMAINDER
  ansi32(n14 + 1, 32) = blan80(n14 + 1, 32);
  filsav = ansi32(1, 32);
  if (iprsup >= 1) {
    write(lunit6, "(' EXTRACTED FILE NAME ANSI32(1:32) =',a32)"), ansi32;
  }
  //C ASK IF FILE EXISTS
  cmn.io.inquire_file(ansi32)
    .exist(logvar);
  //C ILLEGAL FILE; REPROMPT
  if (!logvar) {
    goto statement_1736;
  }
  //C SAVE FILE NAME FOR PRIME "EREXIT"
  cmn.spycd2(1, 32) = ansi32;
  cmn.io.open(lunt13, ansi32)
    .status("OLD");
  //C MAKE $ATTACH INTO COMMENT
  file6(1) = "C " + buff77(1, 78);
  kcut = 0;
  statement_1753:
  krdoff = numcrd;
  krdcom = 0;
  //C READ UNTIL AN END-OF-FILE DETECTED

  FEM_DO_SAFE(j, 1, limcrd) {
    try {
      read(lunt13, format_1329), file6(krdoff + j);
    }
    catch (fem::read_end const&) {
      goto statement_1766;
    }

    if (kcut == 1) {
      goto statement_5486;
    }
    if (file6(krdoff + j)(1, 2) == "C ") {
      krdcom++;
    }
    if (file6(krdoff + j)(1, 19) != "BEGIN NEW DATA CASE" || j - krdcom <= 3) {
      goto statement_1756;
    }
    kcut = 1;
    statement_5486:
    numhld++;
    if (numhld > 1000) {
      write(munit6, star), " Input data cards overflow", " tank(1000).   Halt.";
    }
    if (numhld > 1000) {
      stoptp(cmn);
    }
    tank(numhld) = file6(krdoff + j);
    //C     IF ALL EMTP DATA (E.G., "KILL CODES" USE) COMES VIA KEY           M37. 240
    //C     BOARD, IT IS ENDED WITH "EOF"; WHEN SOLVED, MORE KEYBOARD.        M37. 241
    statement_1756:
    if (file6(krdoff + j)(1, 4) == "EOF ") {
      goto statement_1766;
    }
    //C ANOTHER INPUT DATA CARD NOW READ
    if (kcut == 0) {
      numcrd++;
    }
  }
#endif
  iprspy = n13;
  //C  DIAGNOSTIC EMTP PRINTOUT (0 OR 99)
  iprsup = n13;
  //C EMTP DIAGNOSTIC ONLY THRU 1ST OVERLAY
  iprsov(1) = n13;

  m4plot = 2;
  //C SO FAR, WE HAVE READ ONE INPUT DATA CARD
  numcrd = 1;

  if (data_input(cmn))
    goto statement_1766;


  statement_1760:
  write(munit6,
    "(' Input buffer overflow.  Limit =',i6,"
    "'. Reject this data, and reprompt ....')"),
    limcrd;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C IF THIS WAS $ATTACH USAGE, THEN
  //C LOOP BACK TO START ANEW THE DATA INPUT
  if (lunt13 == 13) {
    goto statement_1311;
  }
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  stoptp(cmn);

  statement_1766:
  numcrd++;
  write(munit6,
    "(' Input Reading is done.',' NUMCRD =',i5,' CARDS.')"),
    numcrd;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C IF INTERNALLY-CONNECTED FILE, THEN
  //C DISCONNECT IT
  if (lunt13 != 5) {
    cmn.io.close(lunt13)
      .status("KEEP");
  }
  //C INITIALIZE PASS NUMBER OF $INCLUDE PROCESSING
  statement_1774:
  n22 = 1;
  //C 1ST $INCLUDE MIGHT BE 1ST DATA CARD (DO 1786)
  n13 = 1;
  //C     BEGIN LOOP TO REPLACE NEXT PRESENTLY-VISIBLE $INCLUDE :           M37. 246
  //C SWITCH SET SO DO 1816 LOOP EXECUTED 1ST TIME
  statement_1776:
  n17 = 0;
  //C SEARCH SUSPECT DATA FOR $INCLUDE
  FEM_DO_SAFE(j, n13, numcrd) {
    //C SKIP ALL NON-$
    statement_1777:
    if (file6(j)(1, 1) != "$") {
      goto statement_1786;
    }
    //C TRANSFER TO SCALAR WORKING STORAGE
    buff77 = file6(j);
    //C JUMP AROUND DIAGNOSTIC
    if (iprspy < 3) {
      goto statement_41777;
    }
    write(munit6, "(' J =',i4,'   NEXT $-CARD = ',a80)"), j, buff77;
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    statement_41777:
    if (buff77(1, 8) == "$INCLUDE") {
      goto statement_1787;
    }
    //C ONLY PROCESSES
    //C THESE LIMITED
    //C DOLLAR CARDS
    if (buff77(1, 7) != "$PREFIX" && buff77(1, 7) != "$SUFFIX" && buff77(1,
        6) != "$LEVEL" && buff77(1, 6) != "$DUMMY") {
      goto statement_1786;
    }
    //C BEGIN SEARCHING FOR FILE PRE/SUFFIX IN COL. 8
    k = 8;
    //C IF NOT BLANK AND NOT
    //C COMMA, EXIT
    statement_1778:
    if (buff77(k, k) != " " && buff77(k, k) != ",") {
      goto statement_1779;
    }
    //C NEXT COLUMN TO RIGHT IN SEARCH FOR FILE START
    k++;
    //C  BACK TO CHECK NEW COLUMN K
    if (k < 80) {
      goto statement_1778;
    }
    //C PRETEND PRE/SUFFIX NAME BEGINS IN COLUMN 10
    k = 10;
    //C PRETEND PRE/SUFFIX NAME IS 5 CHARACTERS LONG
    L = 4;
    //C $PRE/SUFFIX
    if (buff77(5, 7) == "FIX") {
      goto statement_31779;
    }
    //C BLANK COMMON COMMUNICATION OF CARD NUMBER
    istep = j;
    //C ALLOW USER TO CORRECT ERRONEOUS CARD J
    stopin(cmn);
    //C ON OUR WAY TO "OVER51"
    if (kill > 0) {
      goto statement_9200;
    }
    //C  RETURN TO RE-PROCESS CORRECTED CARD J
    goto statement_1777;
    statement_1779:
    if (buff77(1, 7) != "$PREFIX" && buff77(1, 7) != "$SUFFIX") {
      goto statement_1783;
    }
    //C ONE COL. PAST END OF NAME
    L = fem::index(buff77(k, buff77.len()), " ");
    //C COL. OF COMMA, IF ANY
    m = fem::index(buff77(k, buff77.len()), ",");
    //C IF THERE IS A TRAILING COMMA, AND
    //C IF THIS PRECEDES THE BLANK, THEN
    //C IT BOUNDS USER-SUPPLIED NAME;  BOUND IS "L"
    if (m != 0 && m < L) {
      L = m;
    }
    //C INDEX FOR FINAL CHARACTER OF PREFIX/SUFFIX
    L = L - 1;
    //C END OF PRE/SUFFIX RELATIVE TO COL. 1
    statement_31779:
    n5 = k - 1 + L;
    if (buff77(1, 7) != "$PREFIX") {
      goto statement_1782;
    }
    //C PERMANENT STORAGE OF NAME PREFIX
    prefix = buff77(k, n5);
    //C LENGTH OF FILE NAME PREFIX NOW STORED
    nchpre = L;
    //C DONE PROCESSING $PREFIX CARD; MAKE COMMENT
    goto statement_1785;
    //C PERMANENT STORAGE OF NAME SUFFIX
    statement_1782:
    suffix = buff77(k, n5);
    //C LENGTH OF FILE NAME SUFFIX NOW STORED
    nchsuf = L;
    //C DONE PROCESSING $SUFFIX CARD; MAKE COMMENT
    goto statement_1785;
    statement_1783:
    if (buff77(1, 6) != "$LEVEL") {
      goto statement_1784;
    }
    //C TRANSFER NUMERICAL PART OF CARD
    prom80 = buff77(k, 80);
    //C DECODE KOMLEV FROM PROM80
    frein1(cmn, prom80, komlev);
    //C DONE PROCESSING $LEVEL CARD;  MAKE COMMENT
    goto statement_1785;
    statement_1784:
    if (buff77(1, 6) != "$DUMMY") {
      goto statement_1786;
    }
    //C STORE NEW 3-CHAR ROOT NAME
    dumnam(1, 3) = buff77(k, k + 2);
    //C TRANSFER DIGITS TO CELL 1
    ansi8(1, 3) = buff77(k + 3, k + 5);
    //C RE-INITIALIZE SERIALIZATION
    read(ansi8, "(3i1)"), kntdum;
    //C 3-DIGIT DECIMAL SERIALIZATION FOR DUMMY
    //C CONVERT TO COMMENT CARD
    statement_1785:
    file6(j) = "C " + buff77(1, 78);
    //C END  DO 1786  CHECK OF DATA CARD J FOR $INCL.
    statement_1786:;
  }
  //C DONE WITH INPUT DATA; NO $INCLUDE REMAIN
  goto statement_2320;
  //C REMEMBER INDEX OF 1ST $INCLUDE, FOR NEXT SEARCH
  statement_1787:
  n13 = j;
  //C BEGIN LOOKING FOR SEPARATOR IN COLUMN 11
  statement_1788:
  n26 = 9;
  statement_1789:
  if (buff77(n26, n26) != " " && buff77(n26, n26) != ",") {
    goto statement_1797;
  }
  //C MOVE ONE COLUMN TO RIGHT IN SEARCH
  n26++;
  if (n26 < 40) {
    goto statement_1789;
  }
  //C BLANK COMMON COMMUNICATION OF CARD NUMBER
  statement_1794:
  istep = j;
  //C ALLOW USER TO CORRECT ERRONEOUS CARD J
  stopin(cmn);
  //C ON OUR WAY TO "OVER51"
  if (kill > 0) {
    goto statement_9200;
  }
  //C  RETURN TO RE-PROCESS CORRECTED CARD J
  goto statement_1776;
  //C STARTING CANDIDATE FOR LAST COL. OF NAME
  statement_1797:
  k = n26 + 1;
  //C IF COMMA OR BLANK, EXIT
  //C WITH FILE NAME
  statement_1801:
  if (buff77(k, k) == "," || buff77(k, k) == " ") {
    goto statement_1804;
  }
  //C NEXT COL. RIGHT IN SEARCH FOR END OF NAME
  k++;
  //C JUMP TO ERROR CORRECTION
  if (k > 60) {
    goto statement_1794;
  }
  //C LOOP BACK TO CONTINUE SEARCH FOR END OF NAME
  goto statement_1801;
  //C IF NON-BLANK PREFIX EXISTS, THEN
  //C PREFIX BEGINS NAME
  statement_1804:
  if (nchpre > 0) {
    answ80(1, nchpre) = prefix(1, nchpre);
  }
  //C LENGTH OF PREFIX + CENTER NAME
  n7 = nchpre + k - n26;
  //C ADD CENTER NAME
  answ80(nchpre + 1, n7) = buff77(n26, k - 1);
  //C LENGTH OF ENTIRE, COMPLETE FILE NAME
  n8 = n7 + nchsuf;
  //C IF NON-BLANK SUFFIX EXISTS, THEN
  //C SUFFIX FINISHES NAME
  if (nchsuf > 0) {
    answ80(n7 + 1, n8) = suffix(1, nchsuf);
  }
  //C BLANK OUT REMAINDER
  answ80(n8 + 1, 80) = blan80(n8 + 1, 80);
  //C 2ND OR LATER PASS, SO SKIP
  if (n17 == 1) {
    goto statement_1819;
  }
  //C 1ST CARD COPIED IS BOTTOM OF DATA CASE
  L = numcrd;
  //C DESTINATION OF THIS FIRST CARD COPIED
  n19 = limcrd;
  //C LOOP OVER ALL DATA BELOW $INCL.
  FEM_DO_SAFE(m, j + 1, numcrd) {
    //C MOVE CARD DOWN AS FAR AS POSSIBLE
    file6(n19) = file6(L);
    //C PRECEDING DATA CARD IS NEXT TO BE COPIED
    L = L - 1;
    //C CORRESPONDING CARD DESTINATION ADDRESS
    n19 = n19 - 1;
  }
  //C REMEMBER 1ST CARD OF COPY STORED BELOW
  n19++;
  statement_1819:
  write(lunit6,
    "(' Pass number = ',i3,',  CARD =',i4,'.   READY TO OPEN $INCLUDE =',a)"),
    n22, j, answ80(1, n8);
  //C FILE EXISTS?
  cmn.io.inquire_file(answ80(1, n8))
    .exist(logvar);
  //C ILLEGAL NAME CORRECTION
  if (!logvar) {
    goto statement_1794;
  }
  //C TEMP STORAGE B4 2-BYTE SHIFT
  prom80 = file6(j);
  //C MAKE INTO A COMMENT CARD
  file6(j) = "C " + prom80(1, 78);
  cmn.io.open(lunt13, answ80(1, n8))
    .status("OLD");
  //C SO FAR, NO ARGUMENTS OF $INCLUDE ARE KNOWN
  n16 = 0;
  //C POINT TO "," OR " " ENDING FILE NAME
  n26 = k + 1;
  //C SEARCH COLS. N26-80 FOR NONBLANK
  statement_4203:
  FEM_DO_SAFE(L, n26, 80) {
    //C IF NOT "," OR BLANK,
    //C ARGUMENT STARTS
    if (buff77(L, L) != "," && buff77(L, L) != " ") {
      goto statement_4208;
    }
    //C END  DO 4205  LOOP;  COL. "L" NOT ARGUMENT
  }
  //C ALL ARGUMENTS FOUND; NOW USE THEM
  goto statement_4226;
  //C ANOTHER (THE N16-TH) ARGUMENT BEGINS
  statement_4208:
  n16++;
  //C IF NUMBER OF ARGUMENTS IS TOO LARGE,
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  if (n16 > 10) {
    stoptp(cmn);
  }
  //C LOCATE BOUNDING COMMA
  n12 = fem::index(buff77(L, buff77.len()), ",");
  //C LOCATE BOUNDING BLANK
  n13 = fem::index(buff77(L, buff77.len()), " ");
  //C ASSUME THERE'S A COMMA, IN THIS COL.
  n14 = n12;
  //C TRAILING COMMA IS PRESENT
  if (n12 > 0) {
    goto statement_4214;
  }
  //C ASSUME THERE'S A BLANK, IN THIS COL.
  n14 = n13;
  //C NO ",", BUT THERE IS " "
  if (n13 > 0) {
    goto statement_4220;
  }
  write(munit6, "(' NO BOUNDING SYMBOL.  STOP AFTER DISPLAY.')");
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  write(munit6, format_4223), L, n12, n13, n14, n26;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  stoptp(cmn);
  //C IF TRAILING BLANK, AND IF BLANK
  //C PRECEDES ",", BLANK BOUNDS
  statement_4214:
  if (n13 > 0 && n13 < n14) {
    n14 = n13;
  }
  //C NUMBER OF COLUMNS MAKING UP THE ARGUMENT
  statement_4220:
  n15 = n14 - 1;
  //C REMEMBER THE WIDTH OF ARGUMENT N16
  kolinc(n16) = n15;
  //C COL. ENDING ARGUMENT, BASED ON COL. 1
  n18 = L - 1 + n15;
  //C BLANK OUT STORAGE B4 ADDING STRING
  arginc(n16) = " ";
  //C REMEMBER ARGUMENT
  arginc(n16)(1, n15) = buff77(L, n18);
  //C COLUMN TO BEGIN SEARCH FOR NEXT ARGUMENT
  n26 = n18 + 1;
  //C JUMP AROUND DIAGNOSTIC
  if (iprspy < 5) {
    goto statement_4224;
  }
  write(munit6, format_4223), L, n12, n13, n14, n26;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C LOOP BACK TO PROCESS NEXT ARGUMENT IF ANY
  statement_4224:
  goto statement_4203;
  //C ASSUME NO ARGUMENTS (THIS IS BOUND)
  statement_4226:
  kard(1) = 999999;
  //C INITIALIZE OFFSET FOR POINTER VECTOR READS BELOW
  n1 = 0;
  //C SKIP ARGUMENT POINTERS
  if (n16 == 0) {
    goto statement_4239;
  }
  //C READ NEXT CARD
  statement_4228:
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(L, 1, 25) {
      rloop, kbeg(L);
    }
  }
  //C SEARCH I3 REPLACEMENT FIELDS FOR BLANK
  FEM_DO_SAFE(L, 1, 25) {
    //C YES, BOUND IS FOUND
    if (kbeg(L) == 0) {
      goto statement_4230;
    }
    //C END  DO 4229  LOOP TO BOUND REPLACEMENTS
  }
  //C 25 MORE PARAMETER USAGES FOUND
  n1 += 25;
  //C STILL ROOM FOR 25 MORE
  if (n1 <= 175) {
    goto statement_4228;
  }
  //C     OVERFLOW.  199 IS MAX NUMBER OF REPLACEMENTS, TEMPORARILY         M37. 370
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  stoptp(cmn);
  //C REWIND $INCLUDE FILE, TO START AGAIN
  statement_4230:
  cmn.io.rewind(lunt13);
  //C NUMBER OF EFFECTIVE ARGUMENT USAGES
  n6 = n1 + L - 1;
  //C CARD NOS. USED
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(k, 1, n6) {
      rloop, kard(k);
    }
  }
  //C ARGUMENTS USED
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(k, 1, n6) {
      rloop, karg(k);
    }
  }
  //C COL. NO. START
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(k, 1, n6) {
      rloop, kbeg(k);
    }
  }
  //C COL. NO. ENDING
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(k, 1, n6) {
      rloop, kend(k);
    }
  }
  //C ALPHANUM. FLAG
  {
    read_loop rloop(cmn, lunt13, format_4232);
    FEM_DO_SAFE(k, 1, n6) {
      rloop, ktex(k);
    }
  }
  //C JUMP AROUND DIAGNOSTIC
  if (iprspy < 1) {
    goto statement_4235;
  }
  write(munit6, "(' DONE READING ARGUMENT USAGE VECTORS.  N4 =',i5)"), n6;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C JUMP AROUND DIAGNOSTIC
  statement_4235:
  if (iprspy < 5) {
    goto statement_4238;
  }
  write(munit6, "(' VECTORS KARD, KARG, KBEG, KEND, KTEXT(1:25) ...')");
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  {
    write_loop wloop(munit6, format_4237);
    FEM_DO_SAFE(k, 1, n5) {
      wloop, kard(k);
    }
  }
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  {
    write_loop wloop(munit6, format_4237);
    FEM_DO_SAFE(k, 1, n5) {
      wloop, karg(k);
    }
  }
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  {
    write_loop wloop(munit6, format_4237);
    FEM_DO_SAFE(k, 1, n5) {
      wloop, kbeg(k);
    }
  }
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  {
    write_loop wloop(munit6, format_4237);
    FEM_DO_SAFE(k, 1, n5) {
      wloop, kend(k);
    }
  }
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  {
    write_loop wloop(munit6, format_4237);
    FEM_DO_SAFE(k, 1, n5) {
      wloop, ktex(k);
    }
  }
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C BOUND (NO MORE ARGUMENT USAGE)
  statement_4238:
  kard(n6 + 1) = 999999;
  //C NO RECORDS READ FROM $INCLUDE FILE SO FAR
  statement_4239:
  n20 = 0;
  //C START BY CONSIDERING 1ST ARGUMENT FIRST
  n24 = 1;
  //C SO FAR, NO "/" CARDS ENCOUNTERED IN INCLUDE FILE
  n5 = 0;
  //C DO-LOOP LIMIT (NEEDED, FOR J CHANGES INSIDE)
  n18 = j + 1;
  //C INITIALIZE MAXIMUM COUNTER FOR DUMMY NAMES
  kntmax = 0;
  //C SAVE SERIALIZE INDEX AT START OF FILE
  kntold = kntdum;
  //C READ $INCLUDE RECORDS UNTIL EOF
  FEM_DO_SAFE(k, n18, limcrd) {
    //C NEXT DATA CARD
    try {
      read(lunt13, format_1329), buff77;
    }
    catch (fem::read_end const&) {
      goto statement_1828;
    }
    //C EFFECTIVE EOF
    if (buff77(1, 4) == "$EOF") {
      goto statement_1828;
    }
    //C YES, 1 OR MORE "/"
    if (buff77(1, 1) == "/") {
      n5 = 1;
    }
    //C ACCEPT NON-COM.
    if (buff77(1, 1) != "C") {
      goto statement_4247;
    }
    //C SEE IF COL. 2 IS ONE OF 10 DIGITS
    FEM_DO_SAFE(L, 1, 10) {
      //C YES, DIGIT
      if (buff77(2, 2) == digit(L)) {
        goto statement_4244;
      }
      //C END  DO 4241  LOOP TO CHECK IF COL. 2 IS DIGIT
    }
    //C NON-DIGITED COMMENT CARD IS ACCEPTED
    goto statement_4247;
    //C DIGIT(10) = 0   IS EXCEPTION
    statement_4244:
    if (L == 10) {
      L = 0;
    }
    //C IGNORE COMMENT CARD
    if (L > komlev) {
      goto statement_4273;
    }
    //C BLANK OUT LEVEL-DIGIT IN COL. 2
    buff77(2, 2) = " ";
    //C ACCEPT THIS DATA CARD; DO NOT DISCARD IT
    statement_4247:
    j++;
    //C TRANSFER BUFFER TO REGULAR STORAGE
    file6(j) = buff77;
    //C COMMENT CARDS CAN HAVE NO
    //C ARGUMENTS, SO BYPASS THE CHECK FOR USAGE
    if (buff77(1, 1) == "C") {
      goto statement_4273;
    }
    //C NO. OF COUNTABLE $INCLUDE CARD JUST READ
    n20++;
    //C JUMP AROUND DIAGNOSTIC
    if (iprspy < 3) {
      goto statement_4249;
    }
    write(munit6,
      "(' READY WITH NEXT CARD.  N20, N24, KARD(N24) =',3i8)"), n20,
      n24, kard(n24);
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    //C NO ARGUMENT USAGE
    statement_4249:
    if (n20 < kard(n24)) {
      goto statement_4273;
    }
    //C BEGINNING COLUMN NUMBER OF REPLACEMENT
    n1 = kbeg(n24);
    //C ENDING    COLUMN NUMBER OF REPLACEMENT
    n2 = kend(n24);
    //C INDEX NUMBER OF ARGUMENT BEING USED
    n4 = karg(n24);
    //C LENGTH OF ARGUMENT BEING SUBSTITUTED
    n3 = kolinc(n4);
    //C LEGAL ARGUMENT REQUEST
    if (n4 <= n16) {
      goto statement_34250;
    }
    write(lunit6,
      "(' ERROR STOP AT S.N. 4250 OF \"DATAIN\".',"
      "'  INSUFFICIENT NUMBER OF $INCLUDE ARGUMENTS.',/,"
      "'             N24, N4, N16 =',3i8)"),
      n24, n4, n16;
    //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
    stoptp(cmn);
    //C USE ARGUMENT OF $INCLUDE
    statement_34250:
    if (n4 > 0) {
      goto statement_4252;
    }
    //C SERIALIZATION FOR DUMMY NAME USAGE
    kntdum = kntold - n4;
    //C NEW LARGER DUMMY
    if (-n4 > kntmax) {
      kntmax = -n4;
    }
    //C CONVERT INTEGER TO CHARACTER
    write(ansi8, "(i3)"), kntdum;
    //C 1ST OF 3 DIGITS
    if (kntdum < 100) {
      ansi8(1, 1) = "0";
    }
    //C 2ND OF 3 DIGITS
    if (kntdum < 10) {
      ansi8(2, 2) = "0";
    }
    //C IF NAME IS NOT 6 CHARACTERS,
    //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
    if (n2 - n1 != 5) {
      stoptp(cmn);
    }
    //C ADD SERIALIZATION TO ROOT NAME
    dumnam(4, 6) = ansi8(1, 3);
    //C TRANSFER DUMMY NAME TO CARD
    file6(j)(n1, n2) = dumnam;
    //C LOOP BACK TO CONSIDER POSSIBLE NEXT ARGUMENT
    goto statement_4249;
    //C IF ARG. LENGTH MISMATCH,
    //C & IF THIS IS TEXT, THEN
    //C JUMP TO CORRECTION CHANCE
    statement_4252:
    if (n2 - n1 != n3 - 1 && ktex(n24) == 1) {
      goto statement_4253;
    }
    //C ARG. IS SHORT ENOUGH
    if (n2 - n1 >= n3 - 1) {
      goto statement_4261;
    }
    statement_4253:
    write(munit6,
      "('   Argument',i4,'   length-mismatch error.','  Used on card',i4,"
      "' .')"),
      n4, n20;
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    write(munit6,
      "('       N24 =',i4,'    KBEG, KEND =',2i4,'    Length from $INCLUDE =',"
      "i4,' .')"),
      n24, n1, n2, n3;
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    write(prom80, "(' SEND CORRECTED ARGUMENT (STOP) :')");
    //C WRITE PROM80 WITH CURSOR CONTROL (NO LF)
    prompt(cmn);
    //C SPY USAGE ALLOWS RECOVERY
    if (m4plot == 1) {
      goto statement_4259;
    }
    //C KILL CODE INDICATING INTERACTIVE HOPELESSNESS
    kill = 79;
    lstat(19) = 4259;
    //C ASSIGN LSTAT(18), THEN NCHAIN=51; THEN EXIT
    goto statement_9200;
    //C READ REVISED ARGUMENT
    statement_4259:
    read(munit5, "(a20)"), arginc(n4);
    //C IF USER SURRENDERS,
    //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
    if (arginc(n4)(1, 5) == "STOP ") {
      stoptp(cmn);
    }
    //C INITIALIZE DESTINATION ADDRESS AT RIGHT EDGE
    statement_4261:
    n = n2;
    //C JUMP AROUND DIAGNOSTIC
    if (iprspy < 4) {
      goto statement_34261;
    }
    write(munit6, "(' ARGUMENT NOW PROCESSED, ARGINC(N4) =',a20)"), arginc(n4);
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    //C PROCESS ALL 20 CHARACTERS OF ARGUMENT
    statement_34261:
    FEM_DO_SAFE(ip, 1, 20) {
      //C PROCESS FROM RIGHT TO LEFT (RIGHT-ADJUST)
      m = 21 - ip;
      //C TRANSFER BYTE TO TEMP SCALAR
      char1 = arginc(n4)(m, m);
      //C SKIP OVER BLANK
      if (char1 == " ") {
        goto statement_4263;
      }
      //C JUMP AROUND DIAGNOSTIC
      if (iprspy < 8) {
        goto statement_54262;
      }
      write(munit6,
        "('  NEXT NON-BLANK DIGIT.  IP, N, DIGIT =',2i6,'   \"',a1,'\"')"),
        ip, m, char1;
      //C OUTPUT OF CHARACTER VARIABLE MUNIT6
      window(cmn);
      //C POUNDS RESERVES BLANK SPACE, SO
      //C IT IS NOW BLANKED AS IT IS USED
      statement_54262:
      if (char1 == "#") {
        char1 = " ";
      }
      //C SPACE ERROR; ALLOW CORRECTION
      if (n < n1) {
        goto statement_4253;
      }
      //C SUBSTITUTE THIS ARGUMENT BYTE
      file6(j)(n, n) = char1;
      //C BACK UP DESTINATION ADDRESS FOR NEXT BYTE
      n = n - 1;
      //C END  DO 4263  LOOP OVER ARGINC(20:1)
      statement_4263:;
    }
    //C IF BLANK SPACE REMAINS ON LEFT,
    //C & IF THIS IS TEXT, THEN
    //C ALLOW USER CORRECTION OF ERRONEOUS STRING
    if (n + 1 > n1 && ktex(n24) == 1) {
      goto statement_4253;
    }
    //C IF DATA FIELD STILL HAS SPACE ON LEFT,
    //C THEN BLANK THIS REMAINDER OUT
    if (n >= n1) {
      file6(j)(n1, n) = " ";
    }
    //C DONE WITH PRESENT REPLACEMENT; ON TO NEXT
    n24++;
    //C LOOP BACK TO CONSIDER THIS NEXT ARGUMENT
    goto statement_4249;
    //C END  DO 4273  LOOP READING ALL FILE CARDS
    statement_4273:;
  }
  //C STOP AFTER MESSAGE ABOUT BUFFER OVERFLOW
  goto statement_1760;
  statement_1828:
  cmn.io.close(lunt13)
    .status("KEEP");
  //C JUMP AROUND DIAGNOSTIC
  if (iprspy < 1) {
    goto statement_1832;
  }
  write(munit6, "(' DONE WITH DISK FILE (CLOSE).  J, N19 =',2i8)"), j, n19;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C UPDATE DUMMY SERIALIZ. REFERENCE
  statement_1832:
  kntold += kntmax;
  //C "/" USAGE, SO SKIP C-END
  if (n5 == 1) {
    goto statement_1833;
  }
  buff77(1, 32) = "C END OF $INCLUDE.  FILE NAME = ";
  //C TRANSFER FILE NAME OF OPEN
  buff77(33, 80) = answ80(1, 48);
  //C COMMENT CARD JUST BUILT NEEDS STORAGE INDEX
  j++;
  //C TRANSFER TO PERMANENT STORAGE
  file6(j) = buff77;
  //C OVERFLOW ERROR STOP
  statement_1833:
  if (j > n19) {
    goto statement_1760;
  }
  //C COPY LOWER CARDS BACK AS K+1,..
  FEM_DO_SAFE(m, n19, limcrd) {
    //C DESTINATION INDEX FOR NEXT DATA CARD COPIED
    j++;
    file6(j) = file6(m);
    if (file6(j)(1, 8) == "$INCLUDE") {
      goto statement_1841;
    }
  }
  //C NEW NUMBER OF CARDS MAKING UP DATA CASE
  numcrd = j;
  //C INCREMENT PASS NUMBER OF $INCLUDE REMOVAL
  n22++;
  //C LOOP BACK TO SEE IF ANY MORE $INCLUDE EXIST
  goto statement_1776;
  //C LOWER INDEX 1 BEYOND $INCLUDE CONSIDERED
  statement_1841:
  n19 = m + 1;
  //C JUMP AROUND DIAGNOSTIC
  if (iprspy < 1) {
    goto statement_1847;
  }
  write(munit6, "(' NEXT $INCLUDE RECOGNIZED IN DO 1835.  M =',i6)"), m;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C LOAD WORKING STORAGE USED AT S.N.1788
  statement_1847:
  buff77 = file6(j);
  //C SIGNAL TO BYPASS DO 1816 CARDS TRANSFER
  n17 = 1;
  //C LOOP BACK TO PROCESS FILE6(J) AS $INCLUDE
  goto statement_1788;
  //C     FOLLOWING CODE PROCESSES ANY $SPY USAGE:                          M36. 181
  statement_2320:
  j = 1;
  n7 = 0;
  //C SO FAR, NO DATA-SORTING REQUESTS ("/") FOUND
  n17 = 0;
  //C DONE WITH $SPY CARDS
  statement_2347:
  if (j > numcrd) {
    goto statement_2415;
  }
  if (file6(j)(1, 8) != "$SPY    ") {
    goto statement_2378;
  }
  n7++;
  //C IF OVER 9 SUCH $SPY USAGES, THEN
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  if (n7 > 9) {
    stoptp(cmn);
  }
  file6(j) = "$SPY, SPYFILE .DAT, 0,";
  file6(j)(14, 14) = digit(n7);
  ansi32 = "SPYFILE .DAT";
  ansi32(8, 8) = digit(n7);
  //C JUMP AROUND DIAGNOSTIC
  if (iprsup < 1) {
    goto statement_2353;
  }
  write(munit6, "(' PREPARE TO OPEN FOR $SPY.  ANSI32 =',a32)"), ansi32;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  statement_2353:
  cmn.io.open(lunt13, ansi32)
    .status("NEW");
  FEM_DO_SAFE(k, j + 1, numcrd) {
    if (file6(k)(1, 7) != "$SPYEND") {
      goto statement_2361;
    }
    cmn.io.close(lunt13);
    n24 = k - j;
    FEM_DO_SAFE(L, k + 1, numcrd) {
      file6(L - n24) = file6(L);
    }
    numcrd = numcrd - n24;
    write(munit6,
      "(' DONE WITH UPWARD SHIFT.  N24, J, NUMCRD =',3i8)"), n24, j,
      numcrd;
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    goto statement_2378;
    statement_2361:
    write(lunt13, format_1329), file6(k);
  }
  //C SORTING NEEDED
  statement_2378:
  if (file6(j)(1, 1) == "/") {
    n17 = 1;
  }
  if (file6(j)(1, 8) != "TACS OLD") {
    goto statement_2410;
  }
  //C FLAG FOR OLD TACS DATA W/O '/' CARDS
  ntacs = 2;
  file6(j)(1, 2) = "C ";
  statement_2410:
  j++;
  goto statement_2347;
  //C NO DATA SORTING ("/")
  statement_2415:
  if (n17 == 0) {
    goto statement_9800;
  }
  //C     BEGIN CODE TO SORT EMTP DATA ACCORDING TO CLASS :                 M37. 530
  //C NO CLASS-1  ("REQUEST")   USAGE FOUND SO FAR
  n1 = 0;
  //C NO CLASS-10 ("LOAD FLOW") USAGE FOUND SO FAR
  n10 = 0;
  //C NO CLASS-11 ("INITIAL")   USAGE FOUND SO FAR
  n11 = 0;
  //C INITIALIZE NUMBER OF DATA CLASS ("/") CARDS FOUND
  n12 = 0;
  if (iprsup >= 9) {
    {
      write_loop wloop(cmn, lunit6,
        "(' ENTIRE INPUT FILE AS WE START SORTING ...',/(i5,a80))");
      FEM_DO_SAFE(j, 1, numcrd) {
        wloop, j, file6(j);
      }
    }
  }
  //C SEARCH EACH DATA CARD FOR "/" USAGE
  FEM_DO_SAFE(j, 1, numcrd) {
    //C SKIP NON-"/" CARD
    statement_2418:
    if (file6(j)(1, 1) != "/") {
      goto statement_2431;
    }
    //C USE NEXT ROW IN TABLE STORING "/" POINTERS
    n12++;
    //C REMEMBER CARD NUMBER AT START OF DATA CLASS
    kssfrq(n12) = j;
    //C SO FAR, NO ENDING CARD NUMBER OF "/" USE
    kpsour(n12) = 0;
    //C NO PREVIOUS "/" TO BOUND
    if (n12 == 1) {
      goto statement_2420;
    }
    //C IF PREVIOUS "/" USAGE IS
    //C UNBOUNDED, THEN REMEMBER LAST CARD
    if (kpsour(n12 - 1) == 0) {
      kpsour(n12 - 1) = j - 1;
    }
    //C CHECK FOR EACH POSSIBLE DATA CLASS NAME
    statement_2420:
    FEM_DO_SAFE(k, 1, numtyp) {
      //C YES, FOUND IT
      if (file6(j)(2, 13) == typdat(k)) {
        goto statement_2428;
      }
      //C END  DO 2421  LOOP TO IDENTIFY NAME AFTER "/"
    }
    if (file6(j)(2, 10) != "TACS DATA") {
      goto statement_2424;
    }
    //C SET 'TACS DATA' TO 'TACS INITIAL' IF
    k = 6;
    //C NEW TACS DATA FORMAT USED.
    ntacs = 1;
    //C  NTACS SET TO 1 IF TACS WITH NEW FORMAT
    goto statement_2428;
    //C IF EXECUTION IS NOT INTERACTIVE,
    //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
    statement_2424:
    if (munit4 != 1) {
      stoptp(cmn);
    }
    //C TELL USER TO SEND CORRECTED NAME
    write(munit6, format_1737);
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    //C READ CORRECTED "/" CARD
    read(munit5, format_1329), file6(j);
    //C LOOK BACK TO RECOGNIZE JUST-READ "/" CARD
    goto statement_2418;
    //C REMEMBER DATA CLASS NUMBER IN SUMMARY TABLE
    statement_2428:
    kode(n12) = k;
    //C REMEMBER USAGE OF "/REQUEST"
    if (k == 1) {
      n1 = 1;
    }
    //C REMEMBER USAGE OF "/LOAD FLOW"
    if (k == 10) {
      n10 = 1;
    }
    //C REMEMBER USAGE OF "/INITIAL"
    if (k == 11) {
      n11 = 1;
    }
    //C IF 1 OR MORE "/" FOUND SO FAR,
    //C & LAST "/" NOT YET ENDED,
    //C AND CARD IS BLANK,
    //C THEN BOUND LAST "/" USAGE
    statement_2431:
    if (n12 >= 1 && kpsour(n12) == 0 && file6(j)(1, 6) == "BLANK ") {
      kpsour(n12) = j - 1;
    }
    //C END  DO 2436  LOOP WHICH SETS UP SUMMARY "/" TABLE
  }
  //C FINAL BOUND
  if (kpsour(n12) == 0) {
    kpsour(n12) = numcrd;
  }
  L = 0;
  //C JUMP AROUND DIAGNOSTIC
  if (iprspy < 2) {
    goto statement_12438;
  }
  write(munit6, "('     ROW  KSSFRQ  KPSOUR    KODE')");
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  FEM_DO_SAFE(j, 1, n12) {
    write(munit6, "(4i8)"), j, kssfrq(j), kpsour(j), kode(j);
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    //C END  DO 2443  LOOP OVER
  }
  //C BEGINNING CONVERSION OF OLD TACS DATA FORMAT
  statement_12438:
  L++;
  if (L > n12) {
    goto statement_2444;
  }
  if (kode(L) <= 1 || kode(L) > 6) {
    goto statement_12438;
  }
  if (ntacs == 1) {
    goto statement_12438;
  }
  //C  1ST CARD OF CLASS L
  nn1 = kssfrq(L) + 1;
  //C  LAST CARD OF CLASS L
  nn2 = kpsour(L);
  if (kode(L) > 2) {
    goto statement_12448;
  }
  FEM_DO_SAFE(ll, nn1, nn2) {
    //C TYPE '99'
    if (file6(ll)(1, 2) != "99") {
      goto statement_12440;
    }
    //C FUNCTION CARDS BECOME '  '
    file6(ll)(1, 2) = "  ";
    statement_12440:;
  }
  goto statement_12438;
  statement_12448:
  if (kode(L) > 3) {
    goto statement_12458;
  }
  //C FOR TACS SOURCES, CONVERT
  FEM_DO_SAFE(ll, nn1, nn2) {
    if (file6(ll)(1, 1) == "$" || file6(ll)(1, 1) == "9" || file6(ll)(1,
        1) == "C") {
      goto statement_12456;
    }
    //C TYPE '01'
    if (file6(ll)(2, 2) != "1") {
      goto statement_12450;
    }
    //C TO '11',  '02' TO '14', '03' TO
    file6(ll)(1, 1) = "1";
    //C '23' AND '04' TO '24'
    goto statement_12456;
    statement_12450:
    if (file6(ll)(2, 2) != "2") {
      goto statement_12452;
    }
    file6(ll)(1, 2) = "14";
    goto statement_12456;
    statement_12452:
    file6(ll)(1, 1) = "2";
    statement_12456:;
  }
  goto statement_12438;
  statement_12458:
  if (kode(L) > 4) {
    goto statement_12468;
  }
  //C NO CHANGE ON SUPPLEMENTAL VARIABLE DATA
  goto statement_12438;
  statement_12468:
  if (kode(L) > 5) {
    goto statement_12478;
  }
  FEM_DO_SAFE(ll, nn1, nn2) {
    if (file6(ll)(1, 1) != " ") {
      goto statement_12470;
    }
    //C SET TYPE '  ' TO '33' FOR TACS
    file6(ll)(1, 2) = "33";
    //C OUTPUT CARDS
    statement_12470:;
  }
  goto statement_12438;
  statement_12478:
  FEM_DO_SAFE(ll, nn1, nn2) {
    if (file6(ll)(1, 1) != " ") {
      goto statement_12480;
    }
    //C SET TYPE '  ' TO '77' FOR TACS
    file6(ll)(1, 2) = "77";
    //C INITIAL CONDITION CARDS
    statement_12480:;
  }
  goto statement_12438;
  //C INITIALIZE ENTRY OF "/" SUMMARY TABLE WE'LL HIT NEXT
  statement_2444:
  n17 = 1;
  //C INITIALIZE CARD NUMBER WHERE THESE BEGIN
  n18 = kssfrq(n17);
  //C INITIALIZE "/" INDEX TO REMOVE POSSIBLE GARBAGE
  n8 = 0;
  //C INITIALIZE DESTINATION ADDRESS (1 B4 1ST)
  n24 = numcrd;
  //C  INITIALIZE CARD NUMBER OF ORIGINAL DATA DONE
  j = 0;
  //if (file6(1)(1, 9) != "C $ATTACH") {
  //  goto statement_2445;
  //}
  ////C INCREMENT DESTINATION ADDRESS PAST THIS
  //n24++;
  ////C TRANSFER CASE-MARKER CARD BELOW
  //file6(n24) = file6(1);
  ////C UPDATE NUMBER OF ORIGINAL DATA CARDS NOW DONE
  //j = 1;
  //statement_2445:
  if (file6(j + 1)(1, 16) != "BEGIN NEW DATA C") {
    goto statement_2446;
  }
  //C INCREMENT DESTINATION ADDRESS PAST THIS
  n24++;
  //C TRANSFER CASE-MARKER CARD BELOW
  file6(n24) = file6(j + 1);
  //C UPDATE NUMBER OF ORIGINAL DATA CARDS NOW DONE
  j++;
  //C NO "/REQUEST" CARDS USED
  statement_2446:
  if (n1 == 0) {
    goto statement_2453;
  }
  //C  INDEX FOR "REQUEST", DATA WHICH WE NOW ADD
  n8 = 1;
  //C JUMP TO THE INSERTION OF THIS CLASS-1 DATA
  goto statement_2472;
  //C NEXT CARD NUMBER OF ORIGINAL DATA CONSIDERED
  statement_2453:
  j++;
  //C DONE WITH ALL DATA
  if (j > numcrd) {
    goto statement_2497;
  }
  //C NOT A "/" CARD, SO BYPASS SUCH
  if (j != n18) {
    goto statement_2456;
  }
  //C ADVANCE CARD POINTER TO LAST CARD IN "/" CLASS
  j = kpsour(n17);
  //C FOLLOWING "/" USAGE IS IN THIS NEXT ROW OF TABLE
  n17++;
  //C CARD NUMBER WHERE NEXT "/" CARDS WILL APPEAR
  n18 = kssfrq(n17);
  //C LOOP BACK TO CONTINUE SEARCH FOR "BLANK" CARD
  goto statement_2453;
  //C NOT AT END OF SOURCE DATA
  statement_2456:
  if (n8 != 9) {
    goto statement_2458;
  }
  //C NO "/LOAD FLOW" REQUESTS
  if (n10 == 0) {
    goto statement_2460;
  }
  //C  INDEX FOR "LOAD FLOW", DATA WHICH WE NOW ADD
  n8 = n10;
  //C JUMP TO THE INSERTION OF THIS CLASS-10 DATA
  goto statement_2472;
  //C "/INITIAL" NOT JUST ADDED
  statement_2458:
  if (n8 != 10) {
    goto statement_2462;
  }
  //C NO "/INITIAL" TO BE ADDED
  statement_2460:
  if (n11 == 0) {
    goto statement_2462;
  }
  //C  INDEX FOR "INITIAL", DATA WHICH WE NOW ADD
  n8 = 11;
  //C JUMP TO THE INSERTION OF THIS CLASS-11 DATA
  goto statement_2472;
  //C NOT END OF CLASS
  statement_2462:
  if (file6(j)(1, 6) != "BLANK ") {
    goto statement_2493;
  }
  //C JUMP AROUND DIAGNOSTIC
  if (iprspy < 2) {
    goto statement_2465;
  }
  write(munit6, "(' BLANK CARD RECOGNIZED.  J =',i6)"), j;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C SEARCH CLASS TABLE TO IDENTIFY DATA TYPE
  statement_2465:
  FEM_DO_SAFE(k, 1, numtyp) {
    //C NUMBER OF CHARACTERS IN K-TH KEY WORD
    n8 = lentyp(k);
    //C SEARCH FOR KEY WORD K
    n14 = fem::index(file6(j), typdat(k)(1, n8));
    //C YES, ONE OF OUR DATA CLASSES FOUN
    if (n14 > 0) {
      if (k == 11) { //w break a loop bug for case0004
        file6(j)(1, 2) = "C ";
        goto statement_2493;
      }
      goto statement_2469;
    }
    //C END  DO 2464  LOOP SEEKING TO IDENTIFY BLANK CARD
  }
  n14 = fem::index(file6(j), "TACS DATA");
  //C ONLY ONE CLASS IF NEW TACS
  if (n14 == 0) {
    goto statement_2493;
  }
  //C DATA FORMAT, SO SET CLASS NO. TO 6 (LAST ONE)
  k = 6;
  //C DATA CLASS WHICH THIS BLANK CARD TERMINATES
  statement_2469:
  n8 = k;
  //C     CONVERT END OF CLASS BLANK CARD IN OLD TACS DATA TO COMMENT CARD  M42.7150
  if (k == 2 || k == 3 || k == 4 || k == 5) {
    file6(j)(1, 2) = "C ";
  }
  //C JUMP AROUND DIAGNOSTIC
  statement_2472:
  if (iprspy < 3) {
    goto statement_2475;
  }
  write(munit6, "(' DATA CLASS NEEDS CONSIDERATION.  N8 =',i6)"), n8;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C SEARCH ROWS OF "/" TABLE FOR CLASS NUMBER N8
  statement_2475:
  FEM_DO_SAFE(k, 1, n12) {
    //C NOT CORRECT CLASS FOR BLANK
    if (kode(k) != n8) {
      goto statement_2484;
    }
    //C BEGINNING ACTIVE DATA CARD OF K-TH "/" USAGE
    n5 = kssfrq(k) + 1;
    //C ENDING DATA CARD OF K-TH "/" USAGE
    n6 = kpsour(k);
    //C OVERFLOW MESSAGE
    if (n24 + n6 - n5 >= limcrd) {
      goto statement_1760;
    }
    //C LOOP OVER EACH ACTIVE CARD OF K-TH "/" USAGE
    FEM_DO_SAFE(L, n5, n6) {
      //C NEXT DESTINATION CARD ADDRESS WE COPY INTO
      n24++;
      //C INSERT "/" CARD IN LOWER WORKING AREA
      file6(n24) = file6(L);
    }
    //C JUMP AROUND DIAGNOSTIC
    if (iprspy < 3) {
      goto statement_2484;
    }
    write(munit6,
      "(' DONE WITH \"/\" COPY BELOW.  N5, N6, N24 =',3i6)"), n5, n6,
      n24;
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    //C END  DO 2484  LOOP OVER ALL ENTRIES "K" IN "/" TABLE
    statement_2484:;
  }
  //C IF JUST DONE WITH "/LOAD FLOW" OR
  //C "/INITIAL", SPECIAL RETURN
  if (n8 == 10 || n8 == 11) {
    goto statement_2456;
  }
  //C "/REQUEST" PRECEDED NOTHING
  if (j <= 2) {
    goto statement_2453;
  }
  //C NEXT DESTINATION CARD ADDRESS WE COPY INTO
  statement_2493:
  n24++;
  //C COPY ORIGINAL CARD J INTO LOW ASSEMBLY
  file6(n24) = file6(j);
  //C OVERFLOW ERROR MESSAGE
  if (n24 >= limcrd) {
    goto statement_1760;
  }
  //C NOT FINISHED; BACK FOR NEXT J
  if (j < numcrd) {
    goto statement_2453;
  }
  //C JUMP AROUND DIAGNOSTIC
  statement_2497:
  if (iprspy < 2) {
    goto statement_2500;
  }
  write(munit6, "(' DONE WITH LOWER ASSEMBLY.  N24 =',i8)"), n24;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C INITIALIZE CARD DESTINATION INDEX FOR UPWARD SHIFT
  statement_2500:
  j = 0;
  //C CONSIDER EACH LOWER-ASSEMBLED CARD K
  FEM_DO_SAFE(k, numcrd + 1, n24) {
    //C FINAL UPPER INDEX, WHERE CARD IN LOWER ROW K GOES
    j++;
    //C SHIFT CARD IMAGE UPWARD TO FINAL POSITION
    file6(j) = file6(k);
    //C JUMP AROUND DIAGNOSTIC
    if (iprspy < 9) {
      goto statement_2505;
    }
    write(munit6, "(' CARD',i3,'.',a80)"), j, file6(j);
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    statement_2505:;
  }
  //C FINAL LENGTH OF EMTP INPUT DATA, AFTER "/" REMOVAL
  numcrd = j;
  //C JUMP AROUND DIAGNOSTIC
  if (iprspy < 1) {
    goto statement_2509;
  }
  write(munit6, "(' DONE WITH ALL \"/\" PROCESSING.  NUMCRD =',i8)"), numcrd;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C ?????  IF INTERACTIVE USE,
  //C  ????????   TEMPORARY DIAGNOSTIC  ??????
  statement_2509:
  if (m4plot == 1) {
    spying(cmn);
  }
  //C EXIT MODULE AFTER POSSIBLE DIAGNOSTIC
  goto statement_9800;
  //C     BEGIN CODE TO PROCESS "MODULE" OF USER.  CONVERT USER DATA        M37. 663
  //C     FROM  "ARG", "DUM", AND "NUM" CHARACTER DECLARATIONS TO           M37. 664
  //C     THE VECTORS KARD/KARG/KBEG/KEND/KTEX AS NEEDED BY $INCLUDE        M37. 665
  //C DIAGNOSTIC SPY PRINTOUT (0 OR 99)
  statement_2613:
  iprspy = n13;
  //C ERASE MEMORY OF ANY PREVIOUS DATA STORAGE
  numcrd = 0;
  //C ALLOW "DATA" USAGE TO READ INPUT FILE
  spying(cmn);
  //C INITIALIZE THE NUMBER OF DECLARATION CARDS RECOGNIZED
  n8 = 0;
  //C INITIALIZE THE NUMBER OF NON-DUMMY ARGUMENTS
  numarg = 0;
  //C INITIALIZE DESTINATION ADDRESS 1 PAST BOTTOM
  n11 = limcrd + 1;
  //C INITIALIZE COUNT OF CARD BEING CONSIDERED NEXT
  n13 = 0;
  //C TEMPORARY INTEGER VARIABLE STORAGE FOR UNITY
  n4 = 1;
  //C INITIALIZE MODE
  copyi(n4, modarg(1), limarg);
  //C JUMP INTO LOOP OVER ALL INPUT CARDS N13
  goto statement_2628;
  //C NEXT DESTINATION ADDRESS (STORE FROM BOTTOM UP)
  statement_2621:
  n11 = n11 - 1;
  //C COPY NON-DECLARATION CARD DOWN BELOW
  file6(n11) = buff77;
  //C NEXT INPUT CARD (NATURAL ORDER) CONSIDERED
  statement_2628:
  n13++;
  //C DONE PROCESSING ALL CARDS
  if (n13 > numcrd) {
    goto statement_2703;
  }
  //C COPY INPUT CARD INTO WORKING STORAGE
  buff77 = file6(n13);
  //C SKIP OVER ANY CARD
  //C NOT "ARG" OR "DUM"
  //C OR "NUM"
  if (buff77(1, 3) != "ARG" && buff77(1, 3) != "DUM" && buff77(1, 3) != "NUM") {
    goto statement_2621;
  }
  k = 4;
  //C ONE MORE DECLARATION PUSHED TO TOP OF VECTOR
  n8++;
  //C STORE DECLARATION AFTER LAST SUCH CARD
  file6(n8) = buff77;
  //C START OF NEXT ARGUMENT IS
  //C NON-"," & NON-" "
  statement_2637:
  if (buff77(k, k) != " " && buff77(k, k) != ",") {
    goto statement_2648;
  }
  //C MOVE ONE BYTE TO RIGHT IN SEARCH FOR NEXT ARGUMENT
  k++;
  //C LOOP BACK TO TRY THIS NEW COLUMN
  if (k <= 80) {
    goto statement_2637;
  }
  //C DONE WITH THIS CARD, SO LOOP BACK TO READ ANOTHER
  goto statement_2628;
  //C INITIALIZE SEARCH FOR RIGHT EDGE OF ARGUMENT
  statement_2648:
  L = k + 1;
  //C BLANK OR COMMA BOUNDS
  //C RIGHT EDGE OF ARGUMENT
  statement_2656:
  if (buff77(L, L) == " " || buff77(L, L) == ",") {
    goto statement_2664;
  }
  //C MOVE ONE BYTE TO RIGHT IN SEARCH FOR RIGHT EDGE
  L++;
  //C LOOP BACK TO TRY THIS NEW COLUMN
  if (L <= 80) {
    goto statement_2656;
  }
  //C RIGHT EDGE OF ARGUMENT IS ONE BYTE TO LEFT OF BOUND
  statement_2664:
  L = L - 1;
  if (buff77(1, 3) != "NUM") {
    goto statement_2687;
  }
  //C SEARCH EXISTING ARGUMENT LIST FOR THIS ONE
  FEM_DO_SAFE(m, 1, numarg) {
    //C NUMBER OF CHARACTERS IN ARGUMENT JUST IDENTIFIED
    n6 = L - k + 1;
    //C WRONG LENGTH; SKIP IT
    if (kolinc(m) != n6) {
      goto statement_2672;
    }
    //C NO MATCH
    if (arginc(m)(1, n6) != buff77(k, L)) {
      goto statement_2672;
    }
    //C INDICATE NUMERIC STORAGE (RIGHT ADJUST)
    modarg(m) = 0;
    //C EXIT LOOP; ON TO NEXT ARGUMENT ON "NUM" CARD
    goto statement_2695;
    //C END  DO 2672  CARD SEARCHING FOR ARGUMENT
    statement_2672:;
  }
  write(munit6,
    "('   \?\??  ILLEGAL \"NUM\" DECLARATION.  UNRECOGNIZED',' NAME = ',a)"),
    buff77(k, L);
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  stoptp(cmn);
  //C INDEX FOR THIS INPUT ARGUMENT STORAGE
  statement_2687:
  numarg++;
  //C NO OVERFLOW YET
  if (numarg <= limarg) {
    goto statement_2692;
  }
  write(munit6,
    "(' OVERFLOW ERROR STOP.  ARGUMENT USAGE IS',"
    "' LIMITED IN NUMBER TO LIMARG =',i5)"),
    limarg;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  stoptp(cmn);
  //C STORE NEWLY-IDENTIFIED ARGUMENT
  statement_2692:
  arginc(numarg) = buff77(k, L);
  //C BYTE LENGTH OF ARGUMENT
  kolinc(numarg) = L - k + 1;
  if (buff77(1, 3) == "DUM") {
    kkkdum(numarg) = 1;
  }
  //C NEXT LEFT EDGE COULD BE 1 BEYOND PRESENT RIGHT EDGE
  statement_2695:
  k = L + 1;
  //C LOOP BACK TO IDENTIFY NEXT ARGUMENT OF BUFF77
  goto statement_2637;
  //C NEXT DESTINATION ADDRESS FOR $EOF WE CREATE
  statement_2703:
  n11 = n11 - 1;
  write(ansi32, "(2a4,2x,2a4)"), date1, tclock;
  file6(n11) = "$EOF   USER-SUPPLIED HEADER CARDS FOLLOW.  ";
  //C ADD ON DATE AND TIME
  file6(n11)(51, 68) = ansi32(1, 18);
  //C LOOP OVER ALL DECLARATION, NOW STORED AT TOP
  FEM_DO_SAFE(j, 1, n8) {
    //C NEXT DESTINATION ADDRESS FOR DECLARATION CARD
    n11 = n11 - 1;
    //C TRANSFER DECLARATION FROM TOP TO BOTTOM
    file6(n11) = file6(j);
  }
  //C JUMP AROUND DIAGNOSTIC
  if (iprspy < 1) {
    goto statement_2721;
  }
  write(munit6,
    "(' DONE PROCESSING DECLARATIONS.  N8, N11,',' LIMCRD =',3i5)"),
    n8, n11, limcrd;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  write(munit6, "('     ROW  KOLINC  KKKDUM  MODARG  ARGINC ....')");
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C PRINT EACH ROW J OF ARGUMENT TABLE
  FEM_DO_SAFE(j, 1, numarg) {
    write(munit6, "(4i8,a20)"), j, kolinc(j), kkkdum(j), modarg(j), arginc(j);
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    //C END  DO 2719  LOOP OVER ALL ROWS "J" OF TABLE
  }
  //C INITIALIZE NUMBER OF ARGUMENT USAGES FOUND SO FAR
  statement_2721:
  n20 = 0;
  //C INITIALIZE LOCATION OF NEXT CARD CONSIDERED
  n16 = limcrd + 1;
  //C SO FAR, NO ACTIVE (NON-COMMENT) CARDS READ
  n13 = 0;
  //C PROCESS ALL NON-DECLATION CARDS
  FEM_DO_SAFE(n17, n11, limcrd) {
    //C REVERSE-INDEXED LOCATION OF NEXT NON-DECL. CARD
    n16 = n16 - 1;
    //C TRANSFER CARD TO SCALAR WORKING STORAGE
    buff77 = file6(n16);
    //C SKIP COMMENT CARDS
    if (buff77(1, 1) == "C") {
      goto statement_2766;
    }
    //C PRESENT CARD HAS THIS ACTIVE CARD NUMBER IN FILE
    n13++;
    //C SKIP SORTING COMMANDS
    if (buff77(1, 1) == "/") {
      goto statement_2766;
    }
    //C EFFECTIVE FILE END
    if (buff77(1, 4) == "$EOF") {
      goto statement_2772;
    }
    //C CHECK PRESENT CARD FOR EACH ARGUMENT
    FEM_DO_SAFE(j, 1, numarg) {
      //C BEGIN SEARCH FOR STRING IN COLUMN 1 OF BUFF77
      L = 1;
      //C NUMBER OF CHARACTERS IN THE J-TH ARGUMENT
      n15 = kolinc(j);
      statement_2724:
      k = fem::index(buff77(L, buff77.len()), arginc(j)(1, n15));
      //C NO MORE J-TH STRING USAGE
      if (k == 0) {
        goto statement_2754;
      }
      //C ANOTHER ARGUMENT USAGE FOUND; ADVANCE STORAGE
      n20++;
      //C NOT OVERFLOW WORKING VECTORS
      if (n20 <= 200) {
        goto statement_2737;
      }
      write(munit6,
        "('  ====   OVERFLOW ERROR STOP AT CARD NUMBER',i6,"
        "'    OVER 200 ARGUMENTS.')"),
        n16;
      //C OUTPUT OF CHARACTER VARIABLE MUNIT6
      window(cmn);
      //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
      stoptp(cmn);
      //C IT IS THE J-TH STRING WHICH IS USED HERE
      statement_2737:
      karg(n20) = j;
      //C IF THIS IS A DUMMY RATHER THAN REAL ONE,
      //C STORE DUMMY ARG NUMBER WITH "-" FLAG
      if (j > numarg) {
        karg(n20) = -(j - numarg);
      }
      //C ACTIVE CARD COUNT OF THIS RECORD
      kard(n20) = n13;
      //C BEGINNING CARD COLUMN NUMBER FOR STRING
      kbeg(n20) = L - 1 + k;
      //C ENDING COLUMN NUMBER
      kend(n20) = kbeg(n20) + n15 - 1;
      //C IF THIS IS A NON-DUMMY ARGUMENT, THEN
      //C STORE RIGHT ADJUST FLAG (0=Y, 1=N)
      if (j <= numarg) {
        ktex(n20) = modarg(j);
      }
      //C SEARCH CONTINUES ONE BYTE BEYOND STRING END
      L = kend(n20) + 1;
      //C JUMP AROUND DIAGNOSTIC
      if (iprspy < 6) {
        goto statement_2749;
      }
      write(munit6,
        "('    ANOTHER STRING FOUND.  N16, J, L, K, N20 =',5i6)"),
        n16, j, L, k, n20;
      //C OUTPUT OF CHARACTER VARIABLE MUNIT6
      window(cmn);
      //C LOOP BACK TO CHECK FOR ANOTHER APPEARANCE TO RIGHT
      statement_2749:
      goto statement_2724;
      //C END  DO 2754  LOOP OVER EACH CANDIDATE STRING J
      statement_2754:;
    }
    //C JUMP AROUND DIAGNOSTIC
    if (iprspy < 2) {
      goto statement_2766;
    }
    write(munit6,
      "(' DONE WITH THIS CARD.  N16, N20 =',2i5,'   BUFF77=',a80)"),
      n16, n20, buff77;
    //C OUTPUT OF CHARACTER VARIABLE MUNIT6
    window(cmn);
    //C END  DO 2766  LOOP OVER CARD NUMBER N16
    statement_2766:;
  }
  //C JUMP AROUND DIAGNOSTIC
  statement_2772:
  if (iprspy < 1) {
    goto statement_2778;
  }
  write(munit6,
    "(' DONE WITH IDENTIFYING ALL ARGUMENTS OF ALL CARDS.','   N20 =',i4)"),
    n20;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C 25I3 CARDS NOT FILLED
  statement_2778:
  if ((n20 / 25) * 25 != n20) {
    goto statement_2783;
  }
  //C     EXTRA ZERO ENTRY MUST BE ADDED, SINCE OTHERWISE CARD IS FULL:     M37. 794
  //C ADD ZERO ENTRY, WHICH GOES ON BLANK EXTRA CARD
  n20++;
  //C ONLY VALUE ACTUALLY USED, OF QUINTUPLET
  kard(n20) = 0;
  //C REMOVE POSSIBLE GARBAGE, TO AVOID OUTPUT MESS
  karg(n20) = 0;
  //C REMOVE POSSIBLE GARBAGE, TO AVOID OUTPUT MESS
  kbeg(n20) = 0;
  //C REMOVE POSSIBLE GARBAGE, TO AVOID OUTPUT MESS
  kend(n20) = 0;
  //C REMOVE POSSIBLE GARBAGE, TO AVOID OUTPUT MESS
  ktex(n20) = 0;
  statement_2783:
  write(prom80, "(' SEND OUTPUT FILE NAME FOR FINAL $INCLUDE FILE :')");
  prompt(cmn);
  read(munit5, format_1329), buff77;
  cmn.io.open(lunt13, buff77)
    .status("NEW");
  cmn.io.rewind(lunt13);
  ansi8(1, 4) = "KARD";
  {
    write_loop wloop(cmn, lunt13, format_2791);
    wloop, ansi8(1, 4);
    FEM_DO_SAFE(j, 1, n20) {
      wloop, kard(j);
    }
  }
  ansi8(1, 4) = "KARG";
  {
    write_loop wloop(cmn, lunt13, format_2791);
    wloop, ansi8(1, 4);
    FEM_DO_SAFE(j, 1, n20) {
      wloop, karg(j);
    }
  }
  ansi8(1, 4) = "KBEG";
  {
    write_loop wloop(cmn, lunt13, format_2791);
    wloop, ansi8(1, 4);
    FEM_DO_SAFE(j, 1, n20) {
      wloop, kbeg(j);
    }
  }
  ansi8(1, 4) = "KEND";
  {
    write_loop wloop(cmn, lunt13, format_2791);
    wloop, ansi8(1, 4);
    FEM_DO_SAFE(j, 1, n20) {
      wloop, kend(j);
    }
  }
  ansi8(1, 4) = "KTEX";
  {
    write_loop wloop(cmn, lunt13, format_2791);
    wloop, ansi8(1, 4);
    FEM_DO_SAFE(j, 1, n20) {
      wloop, ktex(j);
    }
  }
  //C NEXT, DUMP ALL INPUT DATA CARDS
  FEM_DO_SAFE(j, n11, limcrd) {
    write(lunt13, "(a80)"), file6(limcrd + n11 - j);
  }
  cmn.io.close(lunt13);
  //C BACK TO ORIGINAL PROMPT AT START OF EMTP EXECUTION
  goto statement_1311;
  //C HEAD FOR ERROR OVERLAYS, FOR "KILL" MESSAGE
  statement_9200:
  cmn.nchain = 51;
  //C OVERLAY NUMBER PRESENTLY BEING EXECUTED
  lstat(18) = -1;
  statement_9800:
  if (ntacs != 2) {
    goto statement_9002;
  }
  //C BEGIN TO CONVERT TACS DATA WITHOUT '/' CARDS
  k = 1;
  FEM_DO_SAFE(j, 1, numcrd) {
    if (file6(j)(1, 5) != "BLANK" && file6(j)(1, 80) != blan80(1, 80)) {
      goto statement_3005;
    }
    //C COUNTER FOR TACS DATA TYPES
    k++;
    //C DONE WITH ALL 5 DATA TYPES
    if (k >= 6) {
      goto statement_9002;
    }
    //CCONVERT BLANK CARD TO COMMENT CARD
    file6(j)(1, 2) = "C ";
    //C EXCEPT THE LAST ONE TO END TACS DATA
    goto statement_3500;
    statement_3005:
    switch (k) {
      case 1: goto statement_3010;
      case 2: goto statement_3020;
      case 3: goto statement_3500;
      case 4: goto statement_3040;
      case 5: goto statement_3050;
      default: break;
    }
    //CCONVERT TYPE CODE '99' TO
    //C'  ' FOR FUNCTIONS
    statement_3010:
    if (file6(j)(1, 2) == "99") {
      file6(j)(1, 2) = "  ";
    }
    goto statement_3500;
    statement_3020:
    if (file6(j)(1, 1) == "C" || file6(j)(1, 1) == "9" || file6(j)(1,
        1) == "$") {
      goto statement_3500;
    }
    if (file6(j)(2, 2) != "1") {
      goto statement_3022;
    }
    //C TO CONVERT TACS SOURCE CARDS:
    file6(j)(1, 1) = "1";
    //C TYPE ' 1' TO '11', ' 2' TO '14'
    goto statement_3500;
    statement_3022:
    if (file6(j)(2, 2) != "2") {
      goto statement_3024;
    }
    //C ' 3' TO '23', AND ' 4' TO '24'
    file6(j)(1, 2) = "14";
    goto statement_3500;
    statement_3024:
    file6(j)(1, 1) = "2";
    goto statement_3500;
    statement_3040:
    if (file6(j)(1, 1) != " ") {
      goto statement_3500;
    }
    //CCONVERT TYPE '  ' TO '33'
    file6(j)(1, 2) = "33";
    //CFOR TACS OUTPUT VARIABLES
    goto statement_3500;
    statement_3050:
    if (file6(j)(1, 1) != " ") {
      goto statement_3500;
    }
    //CCONVERT TYPE '  ' TO '77'
    file6(j)(1, 2) = "77";
    //CFOR TACS INITIAL CONDITION CARDS
    statement_3500:;
  }
  //C JUMP AROUND DIAGNOSTIC
  statement_9002:
  if (iprsup < 1) {
    goto statement_9007;
  }
  write(munit6,
    "(' EXIT \"DATAIN\".   NUMCRD, LIMCRD, KILL =',3i8)"), numcrd,
    limcrd, kill;
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  statement_9007:;

  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)

}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

#if 0
void erexit(
  common& cmn)
{
  // COMMON cmn
  auto& muntsv = cmn.muntsv;
  //
  //C       VAX-11   INSTALLATION-DEPENDENT EMTP MODULE.   THIS IS          M37. 143
  //C     CALLED BY THE TOP OF "MAIN00", BEFORE ANY EMTP DATA INPUT.        M37. 144
  //C  DUMMY VECTOR FOR CTRL-C HANDLING
  //C NEEDED FOR CTRL-C INITIALIZATION
  //C MAGIC BLOCK FOR VAX/VMS CTRL-C
  //C FOR USE OF "PROMPT" UNTIL FIXED TT?? ADDRESS
  int lunit6 = 6;
  //C ALTERNATE MUNIT5 UNIT NUMBER OF SPY
  muntsv(2) = 49;
  //C SET FLAG CORRESPONDING TO NO CTRL-C USAGE
  cmn.kwtvax = 0;
  //C      CALL ENABLE_CTRL_C ( KWITER, IDUM(1) )  ! INITIALIZE CTRL-C       M38. 115
  //C READ DATA IN, PROCESS $INCLUDE, SPY, ETC.
  datain(cmn);

}
#endif 

void interp()
{
  //C     IF  CHARACTER*51 KUNIT6,  ACTIVE MODULE NEEDED TO FLUSH           M35. 273
  //C     ABUFF AND KUNIT6 AS 132-COLUMN INTERPRETED DATA CARD LINE.        M35. 274
}



double
seedy(
  common& cmn,
  str_arr_cref<> atim)
{
  double return_value = fem::double0;
  atim(dimension(2));
  common_read read(cmn);
  //C                                                                       M23. 121
  //C)    THIS FUNCTION IS DESIGNED TO TAKE THE TIME OF DAY (WALL-CLOCK     M23. 122
  //C)    TIME) IN BCD FORM AS INPUT, AND RETURN THE NUMBER OF SECONDS      M23. 123
  //C)    SINCE MIDNIGHT AS OUTPUT.   THE TIME OF DAY IS ASSUMED TO BE      M23. 124
  //C)    CODED IN WORDS   ATIM(1)   AND   ATIM(2) ,   AS FOUND BY A CALL TOM23. 125
  //C)    SUBROUTINE  'TIME44' .   THE STORAGE HERE IS IN FORMAT   2A4 ,    M23. 126
  //C)    WITH THE FIRST FOUR CHARACTERS OF   'HH.MM.SS'   ASSUMED TO BE    M23. 127
  //C)    IN  ATIM(1) ,  AND THE LAST FOUR IN  ATIM(2) .                    M24. 295
  //C)                                                                      M23. 132
  //C!REAL*8          ATIM
  int ihr = fem::int0;
  int imin10 = fem::int0;
  int imin1 = fem::int0;
  int isec = fem::int0;
  read(atim(1), "(i2,1x,i1,4x,i1,1x,i2)"), ihr, imin10, imin1, isec;
  int imin = imin10 * 10 + imin1;
  double hour = ihr * 3600;
  double amin = imin * 60;
  double sec = isec;
  return_value = sec + amin + hour + 1.0f;
  return return_value;
}



void nextcard(common& cmn) try // entry in sysdep
{
  //common_read read(cmn);
  common_write write(cmn);

  int n7 = cmn.numdcd + 1;
  auto& lunit6 = cmn.lunit6;
  int j = 0;
  //C JUMP AROUND DIAGNOSTIC
  statement_1472:
  if (cmn.iprspy < 5) {
    goto statement_1486;
  }
  write(cmn.munit6, "(' IN \"NEXTCARD\":',i5,1x,a80)"), n7, cmn.file6(n7);
  //C OUTPUT OF CHARACTER VARIABLE MUNIT6
  window(cmn);
  //C AT LEAST 1 CARD REMAINS
  statement_1486:
  if (n7 <= cmn.numcrd) {
    goto statement_1488;
  }
  write(lunit6,
    "('   ****  ****   DATA CRISIS.   LAST',' CARD HAS BEEN READ.   NUMCRD =',"
    "i6,/,'                USE \"DATA\" COMMAND OF',"
    "' SPY TO READ IN NEXT BLOCK OF DATA.')"),
    cmn.numcrd;
  //C SET KILL, THEN EXIT
  if (cmn.m4plot != 1) {
    goto statement_9000;
  }
  //C ALLOW USER TO CHANGE DATA CARD STORAGE
  emtspy(cmn);
  //C LOOP BACK FOR ANOTHER TRY AT READING
  goto statement_1472;
  statement_1488:
  {
    //read_loop rloop(cmn.file6(n7), "(10a8)");
    //FEM_DO_SAFE(j, 1, 10) {
    //  rloop, cmn.abuff(j);
    //}
    cmn.abuff = cmn.file6(n7);
  }
  //C EXIT MODULE WITH NEW CARD IMAGE IN ABUFF
  goto statement_9200;
  //C POSITIVE KILL IS EOF FLAG IN "CIMAGE"
  statement_9000:
  cmn.kill = 7654;
  statement_9200:;

}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}


void mult(
  arr_cref<double> a,
  arr_cref<double> x,
  arr_ref<double> y,
  int const n,
  int const icheck) try
{
  a(dimension(n* (n + 1) / 2));
  x(dimension(n));
  y(dimension(n));
  int ii = fem::int0;
  int k = fem::int0;
  double xx = fem::double0;
  double yy = fem::double0;
  int i = fem::int0;
  //C)    SUBROUTINE  'MULT'  IS USED TO POST-MULTIPLY A SYMMETRIC MATRIX   M15. 333
  //C)    BY A VECTOR.                                                      M15. 334
  //C)    A=MATRIX,X AND Y=VECTORS.IF ICHECK=0   THEN  Y=A*X                M15. 335
  //C)    N=SIZE OF MATRIX.        IF ICHECK=NEG.THEN  Y=A*X-Y              M15. 336
  //C)                             IF ICHECK=POS.THEN  Y=A*X+Y.             M15. 337
  //C)    MATRIX A IS REAL, SYMMETRIC AND STORED AS UPPER TRIANGULAR MATRIX M15. 338
  //C)    IN ONE-DIMENSIONAL ARRAY (1 ELEMENT FOR FIRST COLUMN, 2 FOR SECONDM15. 339
  //C)    COLUMN ETC.). Y MUST NOT BE IDENTICAL WITH X.                     M15. 340
  ii = 0;
  k = 0;
  statement_1:
  k++;
  if (k > n) {
    return;
  }
  xx = x(k);
  yy = y(k);
  if (icheck == 0) {
    yy = 0.f;
  }
  if (icheck < 0) {
    yy = -yy;
  }
  FEM_DO_SAFE(i, 1, k) {
    ii++;
    y(i) += a(ii) * xx;
    yy += a(ii) * x(i);
  }
  y(k) = yy;
  goto statement_1;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void vecrsv(
  common& cmn,
  arr_ref<double> array,
  int const& n13,
  int const& n2) try
{
  array(dimension(n13));
  common_write write(cmn);
  const auto& nbyte = cmn.nbyte;
  int& iprsup = cmn.iprsup;
  int& kntvec = cmn.kntvec;
  auto& kofvec = cmn.kofvec;
  //
  auto& lunit6 = cmn.lunit6;
  int n4 = fem::int0;
  int k = fem::int0;
  //arr_1d<1, double> farray(fem::fill0);
  int n14 = fem::int0;
  //C     MODULE FOR VECTOR DUMPING/RESTORING OF "OVER6", "OVER8", ETC.     M37. 910
  //C     THIS IS UNIVERSAL FOR VIRTUAL COMPUTERS WHICH CHOSE TO            M37. 911
  //C     USE /C29B01/ SPACE FOR THIS, AS WELL AS ALL OF "LABCOM".          M37. 912
  //C     ALSO NEEDED ARE UNCOUNTED HOLLERITH.  PARALLEL TO "VECISV".       M37. 913
  //C!w EQUIVALENCE  ( KARRAY(1),  FARRAY(1) )
  //C     BLOCK /VECCOM/ IS SHARED BY "VECRSV" AND "VECISV".                M34.   7
  //C     KOFVEC(KNTVEC) REMEMBERS INDEX FOR KNTVEC-TH DUMPING.             M37. 914
  ArraySpan farray(reinterpret_cast<double*>(&cmn.karray(1)), cmn.karray.size() / 2);
  if (iprsup >= 1) {
    write(lunit6,
      "(' BEGIN \"VECRSV\".  N13, N2 =',2i8,'     KNTVEC =',i8)"),
      n13, n2, kntvec;
  }
  if (n2 != 0) {
    goto statement_1638;
  }
  if (n13 >= 0) {
    kntvec = n13;
  }
  if (n13 < 0) {
    kntvec += n13;
  }
  if (iprsup >= 2) {
    write(lunit6, "(' INITIALIZATION OF KNTVEC.  N13 =',i10)"), n13;
  }
  goto statement_9000;
  statement_1638:
  if (n2 == 1) {
    goto statement_1671;
  }
  //C     BEGIN CODE TO RESTORE  (ARRAY(K), K=1, N13)  FROM TANK:           M34.  21
  kntvec++;
  n4 = kofvec(kntvec);
  if (iprsup >= 2) {
    write(lunit6, "(' READY TO RESTORE.  KNTVEC, N4 =',2i10)"), kntvec, n4;
  }
  if (n13 <= 0) {
    goto statement_9000;
  }
  FEM_DO_SAFE(k, 1, n13) {
    array(k) = farray(n4);
    n4++;
  }
  goto statement_9000;
  //C     BEGIN CODE TO DUMP  (ARRAY(K), K=1, N13)  INTO TANK:              M34.  31
  statement_1671:
  if (kntvec > 0) {
    goto statement_1674;
  }
  //C RELATIVE LENGTHS  REAL/INTEGER
  n14 = nbyte(3) / nbyte(4);
  //C BEGIN STORAGE
  kofvec(1) = (cmn.ltlabl + 1) / n14 + 51;
  if (iprsup >= 2) {
    write(lunit6, "(' INITIALIZE KOFVEC(1) =',i10)"), kofvec(1);
  }
  statement_1674:
  kntvec++;
  n4 = kofvec(kntvec);
  if (iprsup >= 2) {
    write(lunit6, "(' READY TO DUMP.  KNTVEC, N4 =',2i10)"), kntvec, n4;
  }
  if (n13 <= 0) {
    goto statement_1683;
  }
  FEM_DO_SAFE(k, 1, n13) {
    farray(n4) = array(k);
    n4++;
  }
  //C IF /VECCOM/ STORAGE EXCEEDED,
  //C INSTALLATION-DEPENDENT PROGRAM STOP CARD
  statement_1683:
  if (kntvec >= 20) {
    stoptp(cmn);
  }
  kofvec(kntvec + 1) = n4;
  if (iprsup >= 2) {
    write(lunit6, "(' DEFINE  KOFVEC(KNTVEC+1) =',i10)"), kofvec(kntvec + 1);
  }
  statement_9000:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT \"VECRSV\".  ARRAY(1;2;N13) =',3e15.6)"),
      array(1), array(2), array(n13);
  }
  if (iprsup >= 2) {
    write(lunit6, "(' KOFVEC =',20i6)"), kofvec;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void fltopt(
  common& cmn,
  double const& d8,
  int& n14) try
{
  common_read read(cmn);
  common_write write(cmn);
  int& iprsup = cmn.iprsup;
  fem::str<80>& blan80 = cmn.blan80;
  const auto& digit = cmn.digit;
  fem::str<32>& ansi32 = cmn.ansi32;
  fem::str<35>& spycd2 = cmn.spycd2;
  //
  int n15 = fem::int0;
  double d9 = fem::double0;
  int n5 = fem::int0;
  int n7 = fem::int0;
  int k = fem::int0;
  fem::str<5> ansi5 = fem::char0;
  int n17 = fem::int0;
  int n18 = fem::int0;
  int j = fem::int0;
  int n4 = fem::int0;
  fem::str<1> onebyt = fem::char0;
  int n3 = fem::int0;
  static const char* format_4172 = "(f35.24)";
  static const char* format_4262 = "(i1)";
  //C       This module services         , and is designed to optimally     M42.8177
  //C       encode the floating number  D8  into  ANSI32  of  "DEKSPY".  By M42.8178
  //C       optimal, we mean a showing of the greatest precision within the M42.8179
  //C       minimum space.  On input,  N14  is the maximum column width, butM42.8180
  //C       on output, it signals the beginning column number.  That is, theM42.8181
  //C       character string  ANSI32(N14:32)  is to be displayed.           M42.8182
  if (iprsup >= 1) {
    write(6, star), " TOP \"FLTOPT\".  D8, N14 =", d8, n14;
  }
  n15 = n14;
  if (d8 != 0.0f) {
    goto statement_4118;
  }
  ansi32(30, 32) = "0.0";
  n14 = 30;
  goto statement_4321;
  statement_4118:
  d9 = std::abs(d8);
  if (d8 < 0.0f) {
    n15 = n15 - 1;
  }
  n5 = 0;
  if (d9 < 1.e6f && d9 >= 1.e-3f) {
    goto statement_4169;
  }
  //C       USE OF E-FIELD REQUIRES MASSAGE AND REMOVAL OF EXPONENT FIRST:  M42.8199
  write(spycd2, "(e35.22)"), d9;
  if (iprsup >= 1) {
    write(6, star), " E-FIELD SPYCD2 BEFORE MASSAGE:", spycd2;
  }
  n7 = fem::index(spycd2, "E");
  if (n7 > 0) {
    goto statement_4133;
  }
  ansi32(26, 32) = "GARBAGE";
  n14 = 26;
  goto statement_4321;
  statement_4133:
  ansi32 = spycd2(4, 35);
  k = fem::index(spycd2, "E+");
  if (k == 0) {
    goto statement_4145;
  }
  statement_4138:
  spycd2(4, k + 1) = " " + ansi32(1, k - 3);
  goto statement_4133;
  statement_4145:
  k = fem::index(spycd2, "E0");
  if (k != 0 && k < 34) {
    goto statement_4138;
  }
  k = fem::index(spycd2, "E-0");
  if (k == 0) {
    goto statement_4157;
  }
  spycd2(4, k + 2) = " " + ansi32(1, k - 2);
  goto statement_4133;
  //C     WE REACH S.N.4157 HAVING FULLY SIMPLIFIED E-FIELD EXPONENT:       M42.8221
  statement_4157:
  k = fem::index(spycd2, "E");
  ansi5 = spycd2(k, 35) + blan80(1, k - 31);
  n5 = 36 - k;
  n15 = n15 - n5;
  ansi32 = spycd2(1, k - 1);
  spycd2 = "   " + ansi32;
  read(spycd2, format_4172), d9;
  goto statement_4184;
  //C     USE OF F-FIELD BEGINS WITH ENCODING OF ABSOLUTE VALUE:            M42.8230
  statement_4169:
  write(spycd2, format_4172), d9;
  statement_4184:
  if (iprsup >= 1) {
    write(6, "(' AFTER F35.24 ENCODE, SPYCD2(A35) =',a35)"), spycd2;
  }
  n17 = 0;
  if (d9 < 1.0f) {
    n17 = fem::index(spycd2, ".");
  }
  n18 = 0;
  FEM_DO_SAFE(j, 1, 35) {
    k = 36 - j;
    if (n18 > 0) {
      goto statement_4245;
    }
    if (spycd2(k, k) == "0") {
      goto statement_4252;
    }
    n18 = k;
    if (n17 > 0) {
      goto statement_4256;
    }
    goto statement_4252;
    statement_4245:
    if (spycd2(k, k) != " ") {
      goto statement_4252;
    }
    n17 = k + 1;
    goto statement_4256;
    statement_4252:;
  }
  stoptp(cmn);
  statement_4256:
  n4 = n18 - n17 + 1;
  if (n4 <= n15) {
    goto statement_4288;
  }
  n18 = n17 + n15 - 1;
  //C     HAVING CHOPPED NUMBER, WE MUST CHECK FOR "0000.." OR "9999..":    M42.8254
  onebyt = spycd2(n18 + 1, n18 + 1);
  read(onebyt, format_4262), n3;
  if (n3 >= 5) {
    goto statement_4273;
  }
  //C     ENTER LOOP FOR CASE OF "0000.." (SEARCH LEFT FOR NON-ZERO):       M42.8259
  statement_4264:
  if (spycd2(n18, n18) != "0") {
    goto statement_4256;
  }
  n18 = n18 - 1;
  goto statement_4264;
  //C     ENTER LOOP FOR CASE OF "9999.." (MOVE LEFT, ROUNDING UPWARD):     M42.8263
  statement_4273:
  onebyt = spycd2(n18, n18);
  if (onebyt == ".") {
    goto statement_4286;
  }
  read(onebyt, format_4262), n3;
  n3++;
  spycd2(n18, n18) = digit(n3);
  if (n3 == 10) {
    goto statement_4286;
  }
  n3 = fem::index(spycd2, ".");
  if (n17 > n18) {
    n17 = n18;
  }
  if (n18 < n3) {
    n18 = n3;
  }
  goto statement_4293;
  statement_4286:
  n18 = n18 - 1;
  goto statement_4273;
  statement_4288:
  if (n4 >= n15) {
    goto statement_4293;
  }
  n15 = n4;
  statement_4293:
  if (iprsup >= 1) {
    write(6,
      "(' F-FIELD.  N4, N17, N18, N15, N14 =',5i6,'    ANSI32(N14:32) =',a)"),
      n4, n17, n18, n15, n14, ansi32(n14, 32);
  }
  if (n5 == 0) {
    goto statement_4306;
  }
  if (n18 + n5 > 35) {
    stoptp(cmn);
  }
  n4 = n18 + n5;
  spycd2(n18 + 1, n4) = ansi5(1, n5);
  n18 = n4;
  statement_4306:
  if (d8 >= 0.0f) {
    goto statement_4314;
  }
  n17 = n17 - 1;
  spycd2(n17, n17) = "-";
  statement_4314:
  n17 = n17 - 1;
  spycd2(n17, n17) = " ";
  n14 = 32 - (n18 - n17);
  ansi32(n14, 32) = spycd2(n17, n18);
  statement_4321:
  ansi32(1, n14 - 1) = blan80(1, n14 - 1);
  if (iprsup >= 1) {
    write(6,
      "(' EXIT \"FLTOPT\".  N14 =',i3,'   ANSI32(N14:32) =',a)"),
      n14, ansi32(n14, 32);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void dgelg(
  arr_ref<double> r,
  arr_ref<double> a,
  int const& m,
  int const& n,
  double const& eps,
  int& ier) try
{
  r(dimension(1));
  a(dimension(1));
  double piv = fem::double0;
  int mm = fem::int0;
  int nm = fem::int0;
  int L = fem::int0;
  double tb = fem::double0;
  int i = fem::int0;
  double tol = fem::double0;
  int lst = fem::int0;
  int k = fem::int0;
  double pivi = fem::double0;
  int j = fem::int0;
  int ll = fem::int0;
  int lend = fem::int0;
  int ii = fem::int0;
  int ist = fem::int0;
  //C        PURPOSE                                                        M35. 292
  //C           TO SOLVE A GENERAL SYSTEM OF SIMULTANEOUS LINEAR EQUATIONS. M35. 293
  //C        USAGE                                                          M35. 294
  //C           CALL DGELG(R,A,M,N,EPS,IER)                                 M35. 295
  //C        DESCRIPTION OF PARAMETERS                                      M35. 296
  //C           R      - DOUBLE PRECISION M BY N RIGHT HAND SIDE MATRIX     M35. 297
  //C                    (DESTROYED). ON RETURN R CONTAINS THE SOLUTIONS    M35. 298
  //C                    OF THE EQUATIONS.                                  M35. 299
  //C           A      - DOUBLE PRECISION M BY M COEFFICIENT MATRIX         M35. 300
  //C                    (DESTROYED).                                       M35. 301
  //C           M      - THE NUMBER OF EQUATIONS IN THE SYSTEM.             M35. 302
  //C           N      - THE NUMBER OF RIGHT HAND SIDE VECTORS.             M35. 303
  //C           EPS    - SINGLE PRECISION INPUT CONSTANT WHICH IS USED AS   M35. 304
  //C                    RELATIVE TOLERANCE FOR TEST ON LOSS OF             M35. 305
  //C                    SIGNIFICANCE.                                      M35. 306
  //C           IER    - RESULTING ERROR PARAMETER CODED AS FOLLOWS         M35. 307
  //C                    IER=0  - NO ERROR,                                 M35. 308
  //C                    IER=-1 - NO RESULT BECAUSE OF M LESS THAN 1 OR     M35. 309
  //C                             PIVOT ELEMENT AT ANY ELIMINATION STEP     M35. 310
  //C                             EQUAL TO 0,                               M35. 311
  //C                    IER=K  - WARNING DUE TO POSSIBLE LOSS OF SIGNIFI-  M35. 312
  //C                             CANCE INDICATED AT ELIMINATION STEP K+1,  M35. 313
  //C                             WHERE PIVOT ELEMENT WAS LESS THAN OR      M35. 314
  //C                             EQUAL TO THE INTERNAL TOLERANCE EPS TIMES M35. 315
  //C                             ABSOLUTELY GREATEST ELEMENT OF MATRIX A.  M35. 316
  //C        REMARKS                                                        M35. 317
  //C           INPUT MATRICES R AND A ARE ASSUMED TO BE STORED COLUMNWISE  M35. 318
  //C           IN M*N RESP. M*M SUCCESSIVE STORAGE LOCATIONS. ON RETURN    M35. 319
  //C           SOLUTION MATRIX R IS STORED COLUMNWISE TOO.                 M35. 320
  //C           THE PROCEDURE GIVES RESULTS IF THE NUMBER OF EQUATIONS M IS M35. 321
  //C           GREATER THAN 0 AND PIVOT ELEMENTS AT ALL ELIMINATION STEPS  M35. 322
  //C           ARE DIFFERENT FROM 0. HOWEVER WARNING IER=K - IF GIVEN -    M35. 323
  //C           INDICATES POSSIBLE LOSS OF SIGNIFICANCE. IN CASE OF A WELL  M35. 324
  //C           SCALED MATRIX A AND APPROPRIATE TOLERANCE EPS, IER=K MAY BE M35. 325
  //C           INTERPRETED THAT MATRIX A HAS THE RANK K. NO WARNING IS     M35. 326
  //C           GIVEN IN CASE M=1.                                          M35. 327
  //C        METHOD                                                         M35. 328
  //C           SOLUTION IS DONE BY MEANS OF GAUSS-ELIMINATION WITH         M35. 329
  //C           COMPLETE PIVOTING.                                          M35. 330
  //C     INTRINSIC  ABSZ                                                   M35. 331
  if (m <= 0) {
    goto statement_23;
  }
  //C     SEARCH FOR GREATEST ELEMENT IN MATRIX A                           M35. 333
  ier = 0;
  piv = 0.0f;
  mm = m * m;
  nm = n * m;
  FEM_DO_SAFE(L, 1, mm) {
    tb = std::abs(a(L));
    if (tb <= piv) {
      goto statement_3;
    }
    piv = tb;
    i = L;
    statement_3:;
  }
  tol = eps * piv;
  //C     A(I) IS PIVOT ELEMENT. PIV CONTAINS THE ABSOLUTE VALUE OF A(I).   M35. 345
  //C     START ELIMINATION LOOP                                            M35. 346
  lst = 1;
  FEM_DO_SAFE(k, 1, m) {
    //C     TEST ON SINGULARITY                                               M35. 349
    if (piv <= 0.0f) {
      goto statement_23;
    }
    if (ier != 0) {
      goto statement_7;
    }
    if (piv > tol) {
      goto statement_7;
    }
    ier = k - 1;
    statement_7:
    pivi = 1.0f / a(i);
    j = (i - 1) / m;
    i = i - j * m - k;
    j += 1 - k;
    //C     I+K IS ROW-INDEX, J+K COLUMN-INDEX OF PIVOT ELEMENT               M35. 358
    //C     PIVOT ROW REDUCTION AND ROW INTERCHANGE IN RIGHT HAND SIDE R      M35. 359
    FEM_DOSTEP(L, k, nm, m) {
      ll = L + i;
      tb = pivi * r(ll);
      r(ll) = r(L);
      r(L) = tb;
    }
    //C     IS ELIMINATION TERMINATED                                         M35. 365
    if (k >= m) {
      goto statement_18;
    }
    //C     COLUMN INTERCHANGE IN MATRIX A                                    M35. 367
    lend = lst + m - k;
    if (j <= 0) {
      goto statement_12;
    }
    ii = j * m;
    FEM_DO_SAFE(L, lst, lend) {
      tb = a(L);
      ll = L + ii;
      a(L) = a(ll);
      a(ll) = tb;
    }
    //C     ROW INTERCHANGE AND PIVOT ROW REDUCTION IN MATRIX A               M35. 376
    statement_12:
    FEM_DOSTEP(L, lst, mm, m) {
      ll = L + i;
      tb = pivi * a(ll);
      a(ll) = a(L);
      a(L) = tb;
    }
    //C     SAVE COLUMN INTERCHANGE INFORMATION                               M35. 382
    a(lst) = j;
    //C     ELEMENT REDUCTION AND NEXT PIVOT SEARCH                           M35. 384
    piv = 0.0f;
    lst++;
    j = 0;
    FEM_DO_SAFE(ii, lst, lend) {
      pivi = -a(ii);
      ist = ii + m;
      j++;
      FEM_DOSTEP(L, ist, mm, m) {
        ll = L - j;
        a(L) += pivi * a(ll);
        tb = std::abs(a(L));
        if (tb <= piv) {
          goto statement_15;
        }
        piv = tb;
        i = L;
        statement_15:;
      }
      FEM_DOSTEP(L, k, nm, m) {
        ll = L + j;
        r(ll) += pivi * r(L);
      }
    }
    lst += m;
  }
  //C     END OF ELIMINATION LOOP                                           M35. 404
  //C     BACK SUBSTITUTION AND BACK INTERCHANGE                            M35. 405
  statement_18:
  if (m > 1) {
    goto statement_19;
  }
  if (m == 1) {
    goto statement_22;
  }
  goto statement_23;
  statement_19:
  ist = mm + m;
  lst = m + 1;
  FEM_DO_SAFE(i, 2, m) {
    ii = lst - i;
    ist = ist - lst;
    L = ist - m;
    L = a(L) + 0.5f;
    FEM_DOSTEP(j, ii, nm, m) {
      tb = r(j);
      ll = j;
      FEM_DOSTEP(k, ist, mm, m) {
        ll++;
        tb = tb - a(k) * r(ll);
      }
      k = j + L;
      r(j) = r(k);
      r(k) = tb;
    }
  }
  statement_22:
  return;
  //C     ERROR RETURN                                                      M35. 426
  statement_23:
  ier = -1;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}


void cominv(
  common& cmn,
  arr_cref<double> a,
  arr_ref<double> b,
  int const& m,
  double const& freq) try
{
  a(dimension(1));
  b(dimension(1));
  double& t = cmn.t;
  auto& flstat = cmn.flstat;
  auto& lstat = cmn.lstat;
  //
  double epspv2 = fem::double0;
  int i = fem::int0;
  arr_1d<50, int> ij(fem::fill0);
  int nph2 = fem::int0;
  int n22 = fem::int0;
  int nphpi2 = fem::int0;
  int j = fem::int0;
  int L = fem::int0;
  int n1 = fem::int0;
  double u = fem::double0;
  int n2 = fem::int0;
  int k = fem::int0;
  int n3 = fem::int0;
  double v = fem::double0;
  double d9 = fem::double0;
  int n4 = fem::int0;
  //C   THIS SUBROUTINE PERFORMS INVERSION OF A COMPLEX MATRIX              M31.6537
  epspv2 = 1.0e-16;
  FEM_DO_SAFE(i, 1, m) {
    ij(i) = 0;
  }
  nph2 = m + m;
  n22 = 2 * m * m;
  nphpi2 = nph2 + 2;
  FEM_DO_SAFE(j, 1, n22) {
    b(j) = a(j);
  }
  L = 0;
  statement_130:
  L++;
  if (L > m) {
    return;
  }
  t = 0.f;
  n1 = 1;
  FEM_DO_SAFE(j, 1, m) {
    if (ij(j) > 0) {
      goto statement_140;
    }
    u = b(n1) * b(n1) + b(n1 + 1) * b(n1 + 1);
    if (u <= t) {
      goto statement_140;
    }
    t = u;
    n2 = j;
    k = n1;
    statement_140:
    n1 += nphpi2;
  }
  ij(n2) = 1;
  if (t > epspv2) {
    goto statement_145;
  }
  cmn.kill = 199;
  flstat(15) = freq;
  flstat(13) = t;
  flstat(14) = epspv2;
  lstat(13) = L;
  lstat(14) = m;
  lstat(19) = 145;
  return;
  statement_145:
  u = b(k) / t;
  t = -b(k + 1) / t;
  b(k) = u;
  b(k + 1) = t;
  n3 = (n2 - 1) * nph2 + 1;
  n2 = 2 * n2 - 1;
  FEM_DOSTEP(i, 1, nph2, 2) {
    if (i == n2) {
      goto statement_160;
    }
    n1 = i + (n2 - 1) * m;
    v = u * b(n1) - t * b(n1 + 1);
    d9 = u * b(n1 + 1) + t * b(n1);
    FEM_DOSTEP(j, 1, n22, nph2) {
      if (j == n3) {
        goto statement_150;
      }
      k = i + j;
      n4 = j + n2;
      b(k - 1) = b(k - 1) - b(n4 - 1) * v + b(n4) * d9;
      b(k) = b(k) - b(n4 - 1) * d9 - b(n4) * v;
      statement_150:;
    }
    statement_160:;
  }
  k = n2;
  FEM_DOSTEP(i, 1, nph2, 2) {
    if (i == n2) {
      goto statement_170;
    }
    n4 = n3 + i;
    v = b(n4 - 1) * u - b(n4) * t;
    b(n4) = b(n4 - 1) * t + b(n4) * u;
    b(n4 - 1) = v;
    v = b(k + 1) * t - b(k) * u;
    b(k + 1) = -b(k) * t - b(k + 1) * u;
    b(k) = v;
    statement_170:
    k += nph2;
  }
  goto statement_130;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}


void last14(
  common& cmn) try
{
  common_write write(cmn);
  double& deltat = cmn.deltat;
  double& epsiln = cmn.epsiln;
  double& unity = cmn.unity;
  double& fltinf = cmn.fltinf;
  auto& lstat = cmn.lstat;
  int& icheck = cmn.icheck;
  int& inonl = cmn.inonl;
  int& it1 = cmn.it1;
  int& it2 = cmn.it2;
  int& lymat = cmn.lymat;
  int& num99 = cmn.num99;
  int& kpartb = cmn.kpartb;
  int& lhist = cmn.lhist;
  int& lfd = cmn.lfd;
  int& iprsup = cmn.iprsup;
  int& kconst = cmn.kconst;
  int& ntot = cmn.ntot;
  int& ibr = cmn.ibr;
  const auto& x = static_cast<common_c0b001&>(cmn).x;
  auto& ykm = cmn.ykm;
  auto& km = cmn.km;
  const auto& eta = cmn.eta;
  auto& sconst = cmn.sconst;
  const auto& cnvhst = cmn.cnvhst;
  const auto& qfd = cmn.qfd;
  auto& semaux = cmn.semaux;
  const auto& nonlad = cmn.nonlad;
  const auto& anonl = cmn.anonl;
  const auto& nltype = cmn.nltype;
  const auto& gslope = cmn.gslope;
  const auto& c = cmn.c;
  const auto& tx = cmn.tx;
  const auto& nr = cmn.nr;
  const auto& length = cmn.length;
  const auto& cik = cmn.cik;
  auto& ci = cmn.ci;
  const auto& ck = cmn.ck;
  const auto& nonlk = cmn.nonlk;
  const auto& nonlm = cmn.nonlm;
  auto& kks = cmn.kks;
  const auto& litype = cmn.litype;
  const auto& imodel = cmn.imodel;
  const auto& kbus = cmn.kbus;
  const auto& mbus = cmn.mbus;
  const auto& kodebr = cmn.kodebr;
  const auto& cki = cmn.cki;
  const auto& indhst = cmn.indhst;
  const auto& kodsem = cmn.kodsem;
  const auto& namebr = cmn.namebr;
  const auto& iform = cmn.iform;
  const auto& time1 = cmn.time1;
  const auto& kmswit = cmn.kmswit;
  auto& e = cmn.e;
  auto& f = static_cast<common_c0b119&>(cmn).f;
  auto& kpsour = cmn.kpsour;
  auto& volt = cmn.volt;
  const auto& bus = cmn.bus;
  int& koff20 = cmn.koff20;
  int& koff21 = cmn.koff21;
  int& koff22 = cmn.koff22;
  int& koff23 = cmn.koff23;
  int& koff24 = cmn.koff24;
  int& koff25 = cmn.koff25;
  int& inoff1 = cmn.inoff1;
  int& inoff4 = cmn.inoff4;
  int& nqtw = cmn.nqtw;
  //
  int icucpl = fem::int0;
  int jglnn = fem::int0;
  int isecti = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  int kss = fem::int0;
  int L = fem::int0;
  int k = fem::int0;
  int n1 = fem::int0;
  int i1 = fem::int0;
  int j0 = fem::int0;
  int j = fem::int0;
  int n2 = fem::int0;
  int n3 = fem::int0;
  int n4 = fem::int0;
  double yx = fem::double0;
  int mabs = fem::int0;
  int ioff1 = fem::int0;
  int ioff2 = fem::int0;
  int ioff3 = fem::int0;
  int ioff4 = fem::int0;
  int ioff5 = fem::int0;
  int ioff6 = fem::int0;
  int ioff7 = fem::int0;
  int ioff8 = fem::int0;
  int koff11 = fem::int0;
  int kq = fem::int0;
  int nphs = fem::int0;
  int nphs2 = fem::int0;
  int icb = fem::int0;
  int nq1 = fem::int0;
  int nq0 = fem::int0;
  int nnq1 = fem::int0;
  int iq = fem::int0;
  int nteq = fem::int0;
  double sume = fem::double0;
  double sumd = fem::double0;
  int jkl = fem::int0;
  int icbscn = fem::int0;
  int nticpl = fem::int0;
  int ifd = fem::int0;
  int nk1 = fem::int0;
  int nq2 = fem::int0;
  int nq3 = fem::int0;
  int nnq2 = fem::int0;
  int nnq3 = fem::int0;
  int nq4 = fem::int0;
  int nq5 = fem::int0;
  int nq6 = fem::int0;
  double apidt = fem::double0;
  double cj = fem::double0;
  double hj = fem::double0;
  double dj = fem::double0;
  double fac1 = fem::double0;
  int n5 = fem::int0;
  double dblpr2 = fem::double0;
  double fac3 = fem::double0;
  double fac4 = fem::double0;
  double fac5 = fem::double0;
  double dblpr3 = fem::double0;
  double dblpr4 = fem::double0;
  double dblpr1 = fem::double0;
  double d18 = fem::double0;
  int nn10 = fem::int0;
  int nn11 = fem::int0;
  int nn12 = fem::int0;
  int ihist = fem::int0;
  double sk1r = fem::double0;
  double sk1i = fem::double0;
  double rll = fem::double0;
  double sll = fem::double0;
  double yll = fem::double0;
  double xll = fem::double0;
  int icu = fem::int0;
  int nnn1 = fem::int0;
  int nnk = fem::int0;
  int km1 = fem::int0;
  double dyk = fem::double0;
  int ij = fem::int0;
  int jk = fem::int0;
  double qjk = fem::double0;
  int ik = fem::int0;
  double qik = fem::double0;
  double b = fem::double0;
  int iadrs = fem::int0;
  int ibi = fem::int0;
  int ibrj = fem::int0;
  int ibj = fem::int0;
  int iyeq = fem::int0;
  int kj = fem::int0;
  int n4j = fem::int0;
  double pit2 = fem::double0;
  int n9 = fem::int0;
  double d1 = fem::double0;
  int kbr = fem::int0;
  int n6 = fem::int0;
  double d2 = fem::double0;
  int n7 = fem::int0;
  int m = fem::int0;
  int mp = fem::int0;
  int np = fem::int0;
  int mm = fem::int0;
  int mark = fem::int0;
  int marm = fem::int0;
  int nq = fem::int0;
  int knode = fem::int0;
  int mnode = fem::int0;
  int nn = fem::int0;
  //C!DIMENSION CBLHST(1)
  //C!EQUIVALENCE  ( CNVHST(1),  CBLHST(1) )
  //C!DIMENSION INFDLI(1)
  //C!EQUIVALENCE  ( NAMEBR(1),  INFDLI(1) )
  //C!DIMENSION  WK1(1)
  //C!EQUIVALENCE ( SEMAUX(1), WK1(1) )
  //C     BEGINNING OF FORMATION OF THE REAL ADMITTANCE MATRIX (Y)          M32.4520
  icucpl = 0;
  jglnn = 0;
  isecti = 400;
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' TOP OF \"LAST14\".  KODSEM(1:IBR) FOLLOW  ....',/(1x,20i6))");
      FEM_DO_SAFE(i, 1, ibr) {
        wloop, kodsem(i);
      }
    }
  }
  if (iprsup >= 5) {
    {
      write_loop wloop(cmn, lunit6,
        "('                   INDHST(1:IBR) FOLLOW  ....',/(1x,20i6))");
      FEM_DO_SAFE(i, 1, ibr) {
        wloop, indhst(i);
      }
    }
  }
  kss = lymat + 1;
  cmn.ialter = 1;
  L = 1;
  //C                                       ESTABLISHING L-TH Y-ROW FROM BRA   11730
  statement_600:
  L++;
  move0(f, ntot);
  k = 1;
  statement_620:
  n1 = kbus(k);
  it2 = length(k);
  if (iprsup >= 6) {
    write(lunit6,
      "(/,' AT 607.',"
      "'       L    NTOT       K      N1     IT1     IT2     IBR     KSS',/,"
      "8x,8i8)"),
      L, ntot, k, n1, it1, it2, ibr, kss;
  }
  if (n1 < 0) {
    goto statement_690;
  }
  it2 = fem::iabs(it2);
  if (it2 == 1) {
    goto statement_650;
  }
  it1 = k;
  FEM_DO_SAFE(i, 1, it2) {
    if (kbus(it1) == L) {
      goto statement_700;
    }
    if (mbus(it1) == L) {
      goto statement_710;
    }
    goto statement_630;
    statement_700:
    icheck = 0;
    goto statement_720;
    statement_710:
    icheck = 1;
    statement_720:
    i1 = i - 1;
    n1 = nr(it1);
    //C                                          !>Column of branch IT1 being M44.1482
    FEM_DO_SAFE(j0, 1, it2) {
      j = j0 - 1;
      n2 = k + j;
      if (icheck != 0) {
        goto statement_760;
      }
      n3 = kbus(n2);
      n4 = mbus(n2);
      statement_730:
      if (j <= i1) {
        goto statement_770;
      }
      n2 = nr(n2) + i1;
      statement_740:
      yx = tx(n2);
      if (kodebr(k) > 0) {
        yx = x(n2);
      }
      f(n3) += yx + c(n2) / 2.0f;
      f(n4) = f(n4) - yx;
      if (iprsup >= 9) {
        write(lunit6,
          "(' COUPLED ELEM ADDS TO (Y).  N3, N4, N2,',"
          "' KODEBR(K), YX, C(N2), F(N3), F(N4) =',4i10,/,1x,4e25.15)"),
          n3, n4, n2, kodebr(k), yx, c(n2), f(n3), f(n4);
      }
      goto statement_750;
      statement_760:
      n3 = mbus(n2);
      n4 = kbus(n2);
      goto statement_730;
      statement_770:
      n2 = n1 + j;
      goto statement_740;
      statement_750:;
    }
    statement_630:
    it1++;
  }
  statement_640:
  k += it2;
  if (iprsup >= 6) {
    write(lunit6, "(/,' AT 643.   K, IT2, IBR, KODSEM(K) =',4i8)"),
      k, it2, ibr, kodsem(k);
  }
  if (k <= ibr) {
    goto statement_620;
  }
  goto statement_780;
  statement_650:
  mabs = fem::iabs(mbus(k));
  if (n1 == L) {
    goto statement_660;
  }
  if (mabs == L) {
    goto statement_670;
  }
  goto statement_640;
  statement_660:
  n4 = mabs;
  goto statement_680;
  statement_670:
  n4 = n1;
  statement_680:
  n3 = nr(k);
  n2 = fem::iabs(n3);
  if (iprsup >= 3) {
    write(6, star), " Series R-L-C. N3, N2, X(N2), F(L), F(N4) =",
      n3, n2, x(n2), f(L), f(n4);
  }
  yx = x(n2);
  if (n3 > 0) {
    yx = 1.0f / yx;
  }
  f(L) += yx;
  f(n4) = f(n4) - yx;
  if (n3 >= 0) {
    f(L) += c(n2) / 2.0f;
  }
  if (iprsup >= 3) {
    write(6, star), " After R-L-C.   F(L), F(N4) =", f(L), f(n4);
  }
  goto statement_640;
  statement_690:
  if (imodel(k) !=  - 3) {
    goto statement_3681;
  }
  //C                                            For testing new logic whichM44.1486
  statement_3681:
  if (imodel(k) !=  - 4) {
    goto statement_3688;
  }
  ioff1 = 0;
  ioff2 = ioff1 + isecti;
  ioff3 = ioff2 + isecti;
  ioff4 = ioff3 + isecti;
  ioff5 = ioff4 + isecti;
  ioff6 = ioff5 + isecti;
  ioff7 = ioff6 + isecti;
  ioff8 = ioff7 + isecti;
  if (ioff8 <= lymat) {
    goto statement_5337;
  }
  write(lunit6,
    "(' IN OVER14, NEW MARTI LINE SOLUTION LOGIC OVERFLOWED STO',"
    "'RAGE LIST NO. 5: LYMAT =',i5,' NEEDED SPACE HERE IOFF8=',i5,'.',/,"
    "' EXECUTION IS ABORTED, AND REDIMENSION WITH LARGER VALUEOF LIST NO. 5 IS"
    " REQUIRED.')"),
    lymat, ioff8;
  FEM_STOP(0);
  //C
  statement_5337:
  cmn.lcbl = 0;
  cmn.lmode = 0;
  koff21 = koff20 + cmn.nqtt;
  koff22 = koff21 + cmn.lbrnch;
  koff23 = koff22 + nqtw;
  koff24 = koff23 + nqtw;
  koff25 = koff24 + 288;
  koff11 = koff25 + 288;
  //C
  if (koff11 < lhist) {
    goto statement_5339;
  }
  write(lunit6,
    "(' IN OVER14, NEW MARTI LINE SOLUTION LOGIC OVERFLOWED STO',"
    "'RAGE LIST NO. 22: LHIST =',i5,' NEEDED SPACE HERE KOFF11=',i5,'.',/,"
    "' EXECUTION IS ABORTED, AND REDIMENSION WITH LARGER VALUEOF LIST NO. 22 I"
    "S REQUIRED.')"),
    lhist, koff11;
  statement_5339:
  kq = k;
  if (L > 2) {
    goto statement_9743;
  }
  //C                                                                       M44.1539
  //C        Evaluate integration constants of Q                            M44.1540
  //C                                                                       M44.1541
  kq = k;
  nphs = fem::abs(length(kq));
  nphs2 = nphs * nphs;
  icb = namebr(inoff1 + kq);
  nq1 = namebr(cmn.inoff2 + kq);
  nq0 = namebr(inoff1 + kq);
  nnq1 = namebr(cmn.inoff3 + kq);
  FEM_DO_SAFE(iq, 1, nphs2) {
    nteq = semaux(koff20 + icb);
    sume = 0.e0;
    sumd = sconst(nq1);
    if (iprsup > 0) {
      write(6,
        "('  I  NTEQ  NNQ1  NNQ2  NNQ3   NQ4   NQ5   NQ6',"
        "'        QK0(I)    Cj(ntermq)    Dj(ntermq)',"
        "'    Ej(ntermq)      SUMdj(I)      SUMej(I)')");
    }
    jkl = 0;
    icbscn = lhist + icb;
    nticpl = cnvhst(icbscn);
    icucpl += nticpl;
    icucpl = icucpl * 3;
    nk1 = lhist + ifd + icucpl - nticpl * 3;
    FEM_DO_SAFE(i, 1, nteq) {
      nq2 = nq1 + i;
      nq3 = nq2 + nteq;
      nnq2 = nnq1 + i;
      nnq3 = nnq2 + nteq;
      nq4 = nnq3 + nteq;
      nq5 = nnq1 + 3 * nteq + 1;
      nq6 = nq5 + 1;
      if (sconst(nq2) >= 1.e+13f) {
        goto statement_1001;
      }
      apidt = sconst(nq3) * deltat;
      cj = fem::dexp(-apidt);
      hj = (1.e0 - cj) / apidt;
      apidt = sconst(nq2) / sconst(nq3);
      dj = apidt * (1.e0 - hj);
      sconst(nq4) = -apidt * (cj - hj);
      sconst(nnq2) = cj;
      sconst(nnq3) = dj;
      sume += sconst(nq4);
      sconst(nq6) = sume;
      sumd += dj;
      sconst(nq5) = sumd;
      goto statement_1002;
      statement_1001:
      jkl++;
      if (jkl == 2) {
        goto statement_1004;
      }
      fac1 = sconst(nq3) * deltat / 1.e15f;
      sconst(n5) = expz(-fac1);
      dblpr2 = sconst(n5);
      fac3 = sconst(nq3 + 1) * deltat / 1.e15f;
      fac4 = sconst(nq3 + 1) / 1.e15f;
      fac5 = sconst(nq3) / 1.e15f;
      dcosz(fac3, dblpr3);
      dsinz(fac3, dblpr4);
      dblpr1 = dblpr2 * dblpr3;
      dblpr2 = dblpr2 * dblpr4;
      d18 = fac4 * fac4 + fac5 * fac5;
      nn10 = nk1 + 1;
      nn11 = nn10 + 1;
      nn12 = nn11 + 1;
      nk1 += 3;
      if (nk1 >= ihist + lfd / 2) {
        write(lunit6,
          "(' Second part of CNVHST NK1= ',i4,' larger than IHIST ',i4,"
          "' + LFD/2 ',i4)"),
          nk1, ihist, lfd;
      }
      if (nk1 >= ihist + lfd / 2) {
        FEM_STOP(0);
      }
      sk1r = sconst(nq2) / 1.e+15f;
      sk1i = sconst(nq2 + 1) / 1.e+15f;
      rll = ((unity - dblpr1) * fac5 + dblpr2 * fac4);
      sll = (dblpr2 * fac5 - (unity - dblpr1) * fac4);
      yll = sk1r * rll - sk1i * sll;
      xll = sk1r * dblpr1 + sk1i * dblpr2;
      sconst(nnq2) = 2 * dblpr1;
      sconst(nnq3) = 2 * sk1r - yll / (deltat * d18);
      sconst(nq4) = -2 * (xll - yll / (deltat * d18));
      sumd += sconst(nnq3);
      sconst(nq5) = sumd;
      sume += sconst(nq4);
      sconst(nq6) = sume;
      statement_1002:
      if (iprsup > 0) {
        write(6,
          "(1x,i2,3x,i3,2x,i4,2x,i4,2x,i4,2x,i4,2x,i4,2x,i4,6e14.5)"),
          i, nteq, nnq1, nnq2, nnq3, nq4, nq5, nq6, sconst(nq1),
          sconst(nnq2), sconst(nnq3), sconst(nq4), sconst(nq5),
          sconst(nq6);
      }
      if (jkl == 1) {
        goto statement_100;
      }
      statement_1004:
      jkl = 0;
      statement_100:;
    }
    nnq1 = nq6;
    nq1 = nq3 + 1;
    icb++;
    //C     Q0(NQ0) = SCONST(NQ5)                                            !M44.1588
    semaux(koff22 + nq0) = sconst(nq5);
    nq0++;
  }
  //C                                                                       M44.1592
  //C        Evaluate equivalent admittance                                 M44.1593
  //C                                                                       M44.1594
  icb = namebr(inoff1 + k);
  icu = namebr(inoff4 + kq);
  //C      CALL QYQTR( NPHS, WK1(KOFF21+KQ),                                M44.1597
  //C     1            WK1(KOFF22+ICB), WK1(KOFF23+ICU) )                   M44.1598
  //C        This subroutine evaluates the matrix product Y = Q * D * Qt    M44.1599
  //C        where D is a diagonal matrix and Y will be symmetrical         M44.1600
  //C        All matrices are real.                                         M44.1601
  nnn1 = nphs * (nphs + 1) / 2;
  FEM_DO_SAFE(i, 1, nnn1) {
    //C      Y(I)=0.D0                                                        M44.1604
    semaux(koff23 + icu - 1 + i) = 0.0f;
  }
  if (iprsup > 0) {
    write(6,
      "('  NNK   KM1    J   I   IJ   IK',"
      "'       DYK-Y05           QJK           QIK',"
      "'             B   YEQ(KOFF23)')");
  }
  FEM_DO_SAFE(nnk, 1, nphs) {
    km1 = (nnk - 1) * nphs;
    //C      DYK = DY(NNK)                                                    M44.1609
    dyk = semaux(koff21 + kq - 1 + nnk);
    ij = 0;
    FEM_DO_SAFE(j, 1, nphs) {
      jk = km1 + j;
      //C      QJK = Q(JK)                                                      M44.1614
      qjk = semaux(koff22 + icb - 1 + jk);
      FEM_DO_SAFE(i, 1, j) {
        ij++;
        ik = km1 + i;
        //C      QIK = Q(IK)                                                      M44.1619
        qik = semaux(koff22 + icb - 1 + ik);
        b = qik * qjk;
        //C      Y(IJ) = Y(IJ) + DYK * B                                          M44.1622
        semaux(koff23 + icu - 1 + ij) += dyk * b;
        if (iprsup > 0) {
          write(6, "(1x,i4,2x,i4,2x,i4,2x,i4,1x,i4,2x,i4,5e14.5)"),
            nnk, km1, j, i, ij, ik, dyk, qjk, qik, b, semaux(koff23 +
            icu - 1 + ij);
        }
      }
    }
  }
  statement_9743:
  if (iprsup > 0) {
    write(6, star), " K, IT2, L, N1, MBUS(K), IBR =", k, it2, L, n1,
      mbus(k), ibr;
  }
  if (it2 < 0) {
    goto statement_682;
  }
  it2 = 1;
  if (-n1 != L && fem::iabs(mbus(k)) != L) {
    goto statement_640;
  }
  f(L) += semaux(koff21 + icb);
  goto statement_640;
  statement_682:
  it2 = -it2;
  it1 = k - 1;
  j0 = k;
  iadrs = namebr(inoff4 + kq) - 1;
  FEM_DO_SAFE(ibi, 1, it2) {
    it1++;
    if (-kbus(it1) == L) {
      goto statement_684;
    }
    if (fem::iabs(mbus(it1)) == L) {
      goto statement_685;
    }
    goto statement_683;
    statement_684:
    j0 = 0;
    statement_685:
    ibrj = k;
    FEM_DO_SAFE(ibj, 1, it2) {
      if (j0 == 0) {
        n1 = -kbus(ibrj);
      }
      if (j0 != 0) {
        n1 = fem::iabs(mbus(ibrj));
      }
      if (ibi < ibj) {
        iyeq = iadrs + ibi + (ibj - 1) * ibj / 2;
      }
      if (ibi >= ibj) {
        iyeq = iadrs + ibj + (ibi - 1) * ibi / 2;
      }
      f(n1) += semaux(koff23 + iyeq);
      ibrj++;
    }
    statement_683:;
  }
  it1++;
  goto statement_640;
  //C                                                                       M44.1674
  statement_3688:
  yx = std::abs(ci(k));
  //C      IF (KODSEM(K) .NE. 0  .AND. IMODEL(K) .NE. -2) GO TO 6920        M31.3052
  if (kodsem(k) != 0 && imodel(k) >= 0) {
    goto statement_6920;
  }
  it2 = -it2;
  if (it2 < 0) {
    it2 = 1;
  }
  n2 = k + it2 - 1;
  FEM_DO_SAFE(i, k, n2) {
    if (ck(i) >= 0.0f) {
      goto statement_21690;
    }
    j = cik(i);
    ci(i) = ci(i) / eta(j);
    statement_21690:;
  }
  it1 = k;
  j0 = k;
  FEM_DO_SAFE(i, 1, it2) {
    if ((-kbus(it1)) == L) {
      goto statement_694;
    }
    if (mbus(it1) == L) {
      goto statement_695;
    }
    goto statement_693;
    statement_694:
    j0 = 0;
    statement_695:
    n2 = k;
    FEM_DO_SAFE(n4, 1, it2) {
      if (j0 == 0) {
        goto statement_696;
      }
      n1 = mbus(n2);
      goto statement_697;
      statement_696:
      n1 = -kbus(n2);
      statement_697:
      yx = 0.0f;
      kj = k;
      ij = litype(k) - 1;
      n4j = ij + n4;
      ij += i;
      FEM_DO_SAFE(j, 1, it2) {
        yx += qfd(ij) * std::abs(ci(kj)) * qfd(n4j);
        if (iprsup >= 3) {
          write(lunit6,
            "(' AT  2696 ',10x,"
            "'       J     IT2      KJ        CI(KJ)       N4J       QFD(N4J) "
            "     IJ        QFD(IJ)             YX',/,20x,3i8,e15.6,i8,e15.6,"
            "i8,2e15.6)"),
            j, it2, kj, ci(kj), n4j, qfd(n4j), ij, qfd(ij), yx;
        }
        ij += it2;
        n4j += it2;
        kj++;
      }
      pit2 = it2;
      yx = yx * pit2;
      f(n1) += yx;
      if (iprsup >= 3) {
        write(lunit6,
          "('      N1      N2      N3      N4             YX            F(N1)'"
          ",/,4i8,e15.6,2x,e15.6)"),
          n1, n2, n3, n4, yx, f(n1);
      }
      n2++;
    }
    if (iprsup >= 3) {
      write(lunit6,
        "(' CI1, L, AND F(L) AT 2697 ARE',5x,e15.6,i8,e15.6)"),
        cmn.ci1, L, f(L);
    }
    statement_693:
    it1++;
  }
  //C     TO RECOVER THE ARRAY CI                                           M29.1966
  n2 = k + it2 - 1;
  FEM_DO_SAFE(i, k, n2) {
    if (ck(i) >= 0.0f) {
      goto statement_31690;
    }
    j = cik(i);
    ci(i) = ci(i) * eta(j);
    statement_31690:;
  }
  goto statement_640;
  statement_6920:
  it2 = fem::iabs(kodebr(k));
  n1 = cik(k);
  FEM_DO_SAFE(i, 1, it2) {
    if (n1 > 0) {
      move0(volt, it2);
    }
    n9 = k + i - 1;
    if (-kbus(n9) != L) {
      goto statement_13010;
    }
    n3 = 1;
    d1 = 1.0f;
    goto statement_13020;
    statement_13010:
    if (fem::iabs(mbus(n9)) != L) {
      goto statement_13200;
    }
    n3 = -1;
    d1 = 1.0f;
    if (kodsem(k) < 0) {
      d1 = -1.0f;
    }
    statement_13020:
    kbr = k;
    statement_13030:
    n4 = std::abs(cki(kbr)) - 1.0f;
    n5 = n4 / it2 + 1;
    n4 = n4 - (n5 - 1) * it2 + 1;
    if (n1 < 0 && n4 != i) {
      goto statement_13140;
    }
    //C      IF (KODSEM(KBR) .GT. 0 .AND. IMODEL(KBR) .NE. -2)                M31.3071
    if (kodsem(k) != 0 && imodel(k) >= 0) {
      goto statement_13040;
    }
    n6 = -kodsem(kbr) + 2;
    d2 = sconst(n6 - 2) + sconst(n6 - 1);
    goto statement_13050;
    statement_13040:
    n6 = kodsem(kbr);
    d2 = sconst(n6);
    n7 = ci(kbr);
    n6 = n6 - n7 - n7 + 1;
    if (n7 > 0) {
      n6 += 7 * n7;
    }
    statement_13050:
    n7 = ck(kbr);
    switch (fem::if_arithmetic(n7)) {
      case -1: goto statement_13060;
      case  0: goto statement_13110;
      default: goto statement_13070;
    }
    statement_13060:
    d2 += sconst(n6 + 1);
    goto statement_13110;
    statement_13070:
    n7 = n6 + 4 * (n7 - 1);
    FEM_DOSTEP(j, n6, n7, 4) {
      switch (fem::if_arithmetic(sconst(j))) {
        case -1: goto statement_13100;
        case  0: goto statement_13090;
        default: goto statement_13080;
      }
      statement_13080:
      d2 += sconst(j + 2);
      statement_13090:
      d2 += sconst(j + 2);
      statement_13100:;
    }
    statement_13110:
    if (iprsup >= 6) {
      write(lunit6,
        "(' AT 13110.      K       L       I      N9      N3      N4      N5  "
        "    N6      N7                D2 ',/,10x,9i8,5x,e15.7)"),
        k, L, i, n9, n3, n4, n5, n6, n7, d2;
    }
    if (n1 < 0) {
      goto statement_13120;
    }
    //C  VOLT(.) IS THE I TH ROW OF (QFD) * (Y-MODAL)                         M23.3448
    n6 = (n4 - 1) * it2 + i + n1 - 1;
    volt(n5) += qfd(n6) * d1 * d2;
    goto statement_13140;
    statement_13120:
    n6 = k + n5 - 1;
    //C  ADD(SUBTRACT) I TH ROW OF Y-PHASE TO(FROM) THE L-TH ROW OF (Y-TOTAL) M23.3453
    if (n3 > 0) {
      goto statement_13130;
    }
    n6 = fem::iabs(mbus(n6));
    goto statement_13140;
    statement_13130:
    n6 = -kbus(n6);
    e(n6) += d1 * d2;
    statement_13140:
    kbr++;
    if (cki(kbr - 1) > 0.0f) {
      goto statement_13030;
    }
    if (n1 < 0) {
      goto statement_13190;
    }
    n4 = k + it2 - 1;
    FEM_DO_SAFE(kbr, k, n4) {
      if (n3 > 0) {
        goto statement_13150;
      }
      n5 = fem::iabs(mbus(kbr));
      goto statement_13160;
      statement_13150:
      n5 = -kbus(kbr);
      statement_13160:
      n6 = n1 + kbr - k;
      d1 = 0.0f;
      FEM_DO_SAFE(j, 1, it2) {
        d1 += volt(j) * qfd(n6);
        n6 += it2;
      }
      if (iprsup > 5) {
        write(lunit6,
          "(' AT 13170.  N3 = ',i5,5x,'N5 = ',i5,5x,'KBR = ',i5,5x,'F(N5) = ',"
          "e15.7,5x,'D1 = ',e15.7)"),
          n3, n5, kbr, f(n5), d1;
      }
      f(n5) += d1;
    }
    statement_13190:
    if (n3 > 0) {
      goto statement_13010;
    }
    statement_13200:;
  }
  it2 = 1;
  statement_13210:
  if (cki(k) < 0.0f) {
    goto statement_640;
  }
  k++;
  goto statement_13210;
  statement_780:
  if (num99 <= 0) {
    goto statement_2801;
  }
  FEM_DO_SAFE(i, 1, inonl) {
    if (nltype(i) > 0) {
      goto statement_2793;
    }
    if (nltype(i) ==  - 98 || nltype(i) ==  - 96) {
      goto statement_2781;
    }
    if (anonl(i) >= 0.0f) {
      goto statement_2793;
    }
    statement_2781:
    k = nonlk(i);
    m = fem::iabs(nonlm(i));
    if (k != L) {
      goto statement_2784;
    }
    n4 = m;
    goto statement_2786;
    statement_2784:
    if (m != L) {
      goto statement_2793;
    }
    n4 = k;
    statement_2786:
    if (nltype(i) !=  - 96) {
      goto statement_2787;
    }
    n3 = nonlad(i) + 1;
    yx = gslope(n3);
    f(L) += yx;
    f(n4) = f(n4) - yx;
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' TYPE-96 G ADDED TO ROW OF Y.  ',5i10,/,3e25.15)"), i,
        k, m, L, n4, yx, f(L), f(n4);
    }
    goto statement_2793;
    statement_2787:
    n3 = nonlad(i);
    yx = gslope(n3);
    f(L) += yx;
    f(n4) = f(n4) - yx;
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' TYPE-98 G ADDED TO ROW OF (Y).',5i10,/,3e25.15)"), i,
        k, m, L, n4, yx, f(L), f(n4);
    }
    statement_2793:;
  }
  statement_2801:
  kks(L) = kss;
  if (f(L) != 0.0f) {
    goto statement_4308;
  }
  if (kconst <= 1) {
    goto statement_2813;
  }
  FEM_DO_SAFE(i, 2, kconst) {
    if (iform(i) != 18) {
      goto statement_2808;
    }
    n6 = time1(i);
    if (n6 == L) {
      goto statement_4308;
    }
    statement_2808:;
  }
  //C     CONNECT HIGH RESISTANCE TO GROUND FOR NONZERO DIAGONAL:           M32.4549
  statement_2813:
  f(L) = epsiln;
  write(lunit6,
    "(' NODE  \"',a6,'\"  HAS NO CONNECTED',"
    "' LINEAR BRANCHES.   ADD (TO GROUND) G =',e13.4,/,1x)"),
    bus(L), epsiln;
  statement_4308:
  if (num99 <= 0) {
    goto statement_73620;
  }
  FEM_DO_SAFE(i, 1, inonl) {
    if (nltype(i) > 0) {
      goto statement_73610;
    }
    k = nonlk(i);
    m = fem::iabs(nonlm(i));
    if (k != L) {
      goto statement_73600;
    }
    if (f(m) == 0.0f) {
      f(m) = 1.0f / fltinf;
    }
    goto statement_73610;
    statement_73600:
    if (m != L) {
      goto statement_73610;
    }
    if (f(k) == 0.0f) {
      f(k) = 1.0f / fltinf;
    }
    statement_73610:;
  }
  statement_73620:
  if (iprsup >= 4) {
    {
      write_loop wloop(cmn, lunit6,
        "(' NODE  \"',a6,'\"  ROW OF (Y) ....',/(1x,5e25.15))");
      wloop, bus(L);
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, f(i);
      }
    }
  }
  FEM_DO_SAFE(i, 2, ntot) {
    if (f(i) == 0.0f) {
      goto statement_885;
    }
    kss = kss - 1;
    km(kss) = i;
    ykm(kss) = f(i);
    statement_885:;
  }
  km(kss) = -km(kss);
  if (iprsup > 0) {
    write(lunit6,
      "(' END OF STORAGE OF ROW OF (Y), AT 73647.',5i10)"), L, kks(L),
      kss, inonl, num99;
  }
  if (kss > ntot) {
    goto statement_894;
  }
  write(lunit6,
    "(' BEFORE ANY FACTORING,  (Y) STORAGE',"
    "' HAS ALMOST OVERFLOWED LIST 5 STORAGE.',"
    "'   ONLY NTOT CELLS LEFT AT ROW  L =',i4)"),
    L;
  cmn.kill = 1;
  lstat(16) = 5;
  lstat(14) = L;
  lstat(13) = 1;
  lstat(19) = 894;
  goto statement_9900;
  statement_894:
  if (L < kpartb) {
    goto statement_600;
  }
  kks(1) = kss;
  move0(kpsour, ntot);
  L = 1;
  mp = 1000;
  statement_202:
  if (mp > ntot) {
    goto statement_1000;
  }
  mp += 1000;
  goto statement_202;
  statement_1000:
  L++;
  m = L + mp;
  j = kks(L);
  statement_2000:
  j = j - 1;
  i = fem::iabs(km(j));
  k = kpsour(i);
  if (k != 0 && k < m) {
    m = k;
  }
  if (km(j) > 0) {
    goto statement_2000;
  }
  j = kks(L);
  statement_3000:
  j = j - 1;
  i = fem::iabs(km(j));
  if (i > kpartb) {
    goto statement_5000;
  }
  if (kpsour(i) == 0) {
    kpsour(i) = m;
  }
  if (kpsour(i) == m) {
    goto statement_5000;
  }
  np = kpsour(i);
  FEM_DO_SAFE(mm, 2, kpartb) {
    if (kpsour(mm) == np) {
      kpsour(mm) = m;
    }
  }
  statement_5000:
  if (km(j) > 0) {
    goto statement_3000;
  }
  if (L < kpartb) {
    goto statement_1000;
  }
  FEM_DO_SAFE(np, 1, inonl) {
    if (nltype(np) < 0) {
      goto statement_6868;
    }
    mark = kpsour(nonlk(np));
    if (mark == 0) {
      goto statement_6868;
    }
    marm = kpsour(fem::iabs(nonlm(np)));
    if (marm == 0 || marm == mark) {
      goto statement_6868;
    }
    FEM_DO_SAFE(nq, 2, ntot) {
      if (kpsour(nq) == marm) {
        kpsour(nq) = mark;
      }
    }
    statement_6868:;
  }
  FEM_DO_SAFE(mm, 1, cmn.kswtch) {
    knode = kpsour(kmswit(mm));
    mnode = kpsour(kmswit(mm + cmn.lswtch));
    if (knode == mnode) {
      goto statement_5800;
    }
    if (knode == 0 || mnode == 0) {
      goto statement_5800;
    }
    FEM_DO_SAFE(nn, 2, ntot) {
      if (kpsour(nn) == mnode) {
        kpsour(nn) = knode;
      }
    }
    statement_5800:;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' KPARTB, NTOT =',2i10,/,' KPSOUR CELLS FOLOW........ ',/(1x,"
        "20i6))");
      wloop, kpartb, ntot;
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, kpsour(i);
      }
    }
  }
  lstat(27) = kss;
  if (iprsup <= 2) {
    goto statement_9900;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' ( KKS(I), I=1, KPARTB ) FOLLOW ....',/(1x,20i6))");
    FEM_DO_SAFE(i, 1, kpartb) {
      wloop, kks(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,2(5x,'I',7x,'KM(I)',19x,'YKM(I)',6x),/(i6,i12,e25.16,2i12,e25.16))");
    FEM_DO_SAFE(i, kss, lymat) {
      wloop, i, km(i), ykm(i);
    }
  }
  statement_9900:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT  \"LAST14\".')");
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

//C      SUBROUTINE QYQTR(NPHS,DY,Q,Y)                                     VAX.2322
//C      include 'zdef1.inc'
//CC      INSERT DECK  LABCOM                                              VAX.2323
//C      DIMENSION DY(1)   ,Q(1)    ,Y(1)                                  VAX.2324
//CC                                                                       VAX.2325
//C      N1=NPHS*(NPHS+1)/2                                                VAX.2326
//C      DO 100 I=1,N1                                                     VAX.2327
//C      Y(I)=0.D0                                                         VAX.2328
//C100   CONTINUE                                                          VAX.2329
//CC                                                                       VAX.2330
//C      DO 101 K=1,NPHS                                                   VAX.2331
//C      KM1=(K-1)*NPHS                                                    VAX.2332
//C      DYK=DY(K)                                                         VAX.2333
//C      IJ=0                                                              VAX.2334
//C      DO 102 J=1,NPHS                                                   VAX.2335
//C      JK=KM1+J                                                          VAX.2336
//C      QJK=Q(JK)                                                         VAX.2337
//C      DO 103 I=1,J                                                      VAX.2338
//C      IJ=IJ+1                                                           VAX.2339
//C      IK=KM1+I                                                          VAX.2340
//C      QIK=Q(IK)                                                         VAX.2341
//C      B=QIK*QJK                                                         VAX.2342
//C      Y(IJ)=Y(IJ)+DYK*B                                                 VAX.2343
//C103   CONTINUE                                                          VAX.2344
//C102   CONTINUE                                                          VAX.2345
//C101   CONTINUE                                                          VAX.2346
//C      RETURN                                                            VAX.2347
//C      END                                                               VAX.2348

void identifier_switch(
  common& cmn) try
{
  common_write write(cmn);
  auto& lstat = cmn.lstat;
  int& lswtch = cmn.lswtch;
  auto& ktrlsw = cmn.ktrlsw;
  int& kpartb = cmn.kpartb;
  int& iprsup = cmn.iprsup;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  const auto& modswt = cmn.modswt;
  auto& kbegsw = cmn.kbegsw;
  auto& lastsw = cmn.lastsw;
  const auto& kentnb = cmn.kentnb;
  const auto& nbhdsw = cmn.nbhdsw;
  const auto& kmswit = cmn.kmswit;
  auto& nextsw = cmn.nextsw;
  auto& kode = cmn.kode;
  const auto& bus = cmn.bus;
  //
  int n20 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int j = fem::int0;
  int i = fem::int0;
  int n18 = fem::int0;
  int ll = fem::int0;
  int n13 = fem::int0;
  int n3 = fem::int0;
  int k = fem::int0;
  int ndx1 = fem::int0;
  int m = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int jj = fem::int0;
  int mm = fem::int0;
  int n9 = fem::int0;
  int ndx2 = fem::int0;
  int n17 = fem::int0;
  int n14 = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  int n19 = fem::int0;
  int n15 = fem::int0;
  int n16 = fem::int0;
  int n4 = fem::int0;
  int n8 = fem::int0;
  int mo = fem::int0;
  int m1 = fem::int0;
  int l1 = fem::int0;
  int m2 = fem::int0;
  int l2 = fem::int0;
  int m7 = fem::int0;
  int m3 = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  int k1 = fem::int0;
  int k2 = fem::int0;
  int m4 = fem::int0;
  int m5 = fem::int0;
  int m6 = fem::int0;
  int nmin = fem::int0;
  int n5 = fem::int0;
  int n12 = fem::int0;
  int nmax = fem::int0;
  int nless = fem::int0;
  int nover = fem::int0;
  int m9 = fem::int0;
  int l3 = fem::int0;
  int l4 = fem::int0;
  int l5 = fem::int0;
  int nn = fem::int0;
  int kk2 = fem::int0;
  int ll2 = fem::int0;
  int numb = fem::int0;
  int k7 = fem::int0;
  int k3 = fem::int0;
  int k4 = fem::int0;
  static const char* format_3451 =
    "(' (NEXTSW(I), I=1, KSWTCH)  FOLLOWS ....',/(1x,20i5))";
  static const char* format_3452 =
    "(' (LASTSW(I), I=1, KSWTCH)  FOLLOWS ....',/(1x,20i5))";
  static const char* format_3453 =
    "(' (KBEGSW(I), I=1, KSWTCH)  FOLLOWS ....',/(1x,20i5))";
  static const char* format_3454 =
    "(' (KODE(I), I=1, NTOT)  FOLLOWS  ....',/(1x,20i5))";
  //C!EQUIVALENCE ( KTRLSW(1), N20 )
  //C     OVERLAY-16 MODULE CALLED BY "SUBTS1" IF AND ONLY IF ONE OR MORE   M32.5263
  //C     SWITCHES HAS JUST CHANGED STATUS (IF KTRLSW(1) .GT. 0).   THE     M32.5264
  //C     PURPOSE IS TO UPDATE NEXTSW VECTOR THAT GIVES ORDER OF SWITCH     M32.5265
  //C     CURRENT CALCULATION.   GENERAL SOPHISTICATED LOGIC USES THE       M32.5266
  //C     FOLLOWING STORAGE:                                                M32.5267
  //C       MODSWT(LL) = J  MEANS THAT THE LL-TH SWITCHING OPERATION OF     M32.5268
  //C                    THIS TIME STEP INVOLVES SWITCH NUMBER J.   IF      M32.5269
  //C                    CONTENT (J) IS POSITIVE,  A NOW-OPEN SWITCH IS     M32.5270
  //C                    TO BE CLOSED;  IF CONTENT IS NEGATIVE (-J), THEN   M32.5271
  //C                    THE NOW-CLOSED SWITCH J IS TO BE OPENED.           M32.5272
  //C       NEXTSW(J) = K  MEANS THAT CURRENT IS TO BE CALCULATED IN SWITCH M32.5273
  //C                   NUMBER K AFTER THAT OF SWITCH NUMBER J.  ADDED MINUSM32.5274
  //C                   SIGN INDICATES KCL AT 2ND NODE RATHER THAN 1ST ONE. M32.5275
  //C                   POINTER IS CIRCULAR (NEVER-ENDING).                 M32.5276
  //C       LASTSW(K) = J  IS THE BACKWARD MAP (LIKE NEXTSW ABOVE,  ONLY IN M32.5277
  //C                   REVERSE ORDER.   IT, TOO, IS CIRCULAR.   ADDED MINUSM32.5278
  //C                   SIGN MARKS LAST SWITCH OF SWITCH GROUP.             M32.5279
  //C       KENTNB(I) = N  MEANS THAT SWITCHES (OPEN OR CLOSED) ADJACENT TO M32.5280
  //C                   SWITCH I CAN BE FOUND IN NBHDSW(N) ONWARD.  THE LASTM32.5281
  //C                   ADJACENT ONE IS IN CELL  KENTNB(I+1)-1 .            M32.5282
  //C       NBHDSW(J) --- STORAGE FOR ALL SWITCHES ADJACENT TO ANY OTHER    M32.5283
  //C                     SWITCHES.   KENTNB  LOCATES DESIRED ENTRIES.   IF M32.5284
  //C                     NO SWITCH IS ADJACENT,  THERE SHALL BE NO SUCH    M32.5285
  //C                     STORAGE (ENTRY POINT EXCEEDS TERMINAL POINT).     M32.5286
  //C       KBEGSW(J) = 0  MEANS THAT SWITCH J BEGINS A SWITCH GROUP.   IF  M32.5287
  //C                   CLOSED BUT NOT 1ST OF GROUP, THEN NONZERO STORED.   M32.5288
  //C       KODE(K)  =  M   MEANS THAT SWITCH NODES K AND M ARE SHORTED     M32.5289
  //C                   TOGETHER AS PART OF A SWITCH GROUP,  AND THAT WITHINM32.5290
  //C                   THE SWITCH GROUP,  M  IS THE NEXT HIGHER NODE AFTER M32.5291
  //C                   BUT POINTER CHAIN IS CIRCULAR,  SO THE EXCEPTION IS M32.5292
  //C                   THAT THE HIGHEST NODE POINTS TO THE LOWEST.         M32.5293
  //C       KTRLSW(6) --- FIXED COMMUNICATION VECTOR OF /BLANK/.   CELLS    M32.5294
  //C                     HAVE THE FOLLOWING MEANING:                       M32.5295
  //C                   (1) = NUMBER OF SWITCH CHANGES THIS TIME-STEP;      M32.5296
  //C                   (2) = CURRENT NUMBER OF CLOSED SWITCHES;            M32.5297
  //C                   (3) = CURRENT NUMBER OF TRIANGULARIZATIONS OF (Y);  M32.5298
  //C                   (4) = SWITCH NUMBER OF 1ST SWITCH OF 1ST GROUP;     M32.5299
  //C                   (5) = TOTAL NUMBER SWITCH STATUS CHANGES OF SOLUTIONM32.5300
  //C                   (6) = 0 OR 1 DEPENDING UPON WHETHER THE             M32.5301
  //C                         COMPLICATED OR SIMPLE LOGIC IN "SWITCH" IS    M32.5302
  //C                         TO BE USED.   SEE "SIMPLE SWITCH LOGIC" OF    M32.5303
  //C                         EMTP RULE BOOK (TO GET VALUE OF UNITY).       M32.5304
  //C     FOR CASES WITH FEW SWITCHES,  THIS IS A CASE OF OVERKILL,  AND    M32.5305
  //C     A USER WHO IS SHORT OF MEMORY MIGHT WANT TO ELIMINATE MOST OF     M32.5306
  //C     THIS SUBROUTINE.  SUCH IS POSSIBLE (SEE ABOVE S.N. 3459).         M32.5307
  n20 = ktrlsw(1);
  if (iprsup >= 1) {
    write(lunit6, "(' TOP OF \"SWITCH\".  KTRLSW VECTOR =',10i7)"), ktrlsw;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(' (MODSWT(J), J=1, KTRLSW(1)) FOLLOW ...',/(1x,20i6))");
      FEM_DO_SAFE(j, 1, n20) {
        wloop, modswt(j);
      }
    }
  }
  if (iprsup < 3) {
    goto statement_3459;
  }
  {
    write_loop wloop(cmn, lunit6, format_3451);
    FEM_DO_SAFE(i, 1, kswtch) {
      wloop, nextsw(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3452);
    FEM_DO_SAFE(i, 1, kswtch) {
      wloop, lastsw(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3453);
    FEM_DO_SAFE(i, 1, kswtch) {
      wloop, kbegsw(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3454);
    FEM_DO_SAFE(i, 1, ntot) {
      wloop, kode(i);
    }
  }
  //C     CHOICE OF ALTERNATE SWITCH LOGIC IS NOW TO BE MADE.               M32.5327
  //C     IMMEDIATELY FOLLOWING IS SIMPLE LOGIC (MUCH SHORTER CODE),        M32.5328
  //C     WHICH IS FINE FOR CASES WITH FEW SWITCHES.   THOSE SHORT          M32.5329
  //C     OF MEMORY COULD DELETE ALL BUT THIS (DELETE BETWEEN               M32.5330
  //C     BOUNDING COMMENT CARDS WITH "%%%%%%").    IF THIS IS              M32.5331
  //C     DONE,  THEN ALSO DELETE FOLLOWING "IF"-STATEMENT:                 M32.5332
  statement_3459:
  ktrlsw(5) += ktrlsw(1);
  if (iprsup >= 1) {
    write(lunit6,
      "(' TOP OF \"SWITCH\".  ISTEP, KTRLSW(1:6) =',10i6)"),
      cmn.istep, ktrlsw;
  }
  if (ktrlsw(6) == 0) {
    goto statement_3605;
  }
  //C     BEGIN SIMPLE, BRUTE-FORCE SWITCH LOGIC OF "SIMPLE SWITCH LOGIC"   M32.5338
  //C     SPECIAL-REQUEST CARD (SEE EMTP RULE BOOK):                        M32.5339
  move0(kbegsw, kswtch);
  move0(kode, ntot);
  j = ktrlsw(4);
  if (j <= 0) {
    goto statement_3478;
  }
  //C     ENTER LOOP AROUND NEXTSW, AS WE NOTE CLOSED SWITCHES USING KBEGSW:M32.5344
  statement_3473:
  kbegsw(j) = 1;
  j = fem::iabs(nextsw(j));
  if (j != ktrlsw(4)) {
    goto statement_3473;
  }
  statement_3478:
  move0(nextsw, kswtch);
  n18 = ktrlsw(2);
  FEM_DO_SAFE(ll, 1, n20) {
    j = modswt(ll);
    if (j > 0) {
      goto statement_3482;
    }
    j = -j;
    kbegsw(j) = 0;
    n18 = n18 - 1;
    goto statement_3485;
    statement_3482:
    kbegsw(j) = 1;
    n18++;
    statement_3485:;
  }
  ktrlsw(2) = n18;
  if (n18 > 0) {
    goto statement_3487;
  }
  ktrlsw(4) = 0;
  move0(nextsw, kswtch);
  goto statement_4457;
  statement_3487:
  n13 = 0;
  n3 = 0;
  //C     ENTER LOOP  DO 3580  OVER ALL SWITCHES,  IN WHICH EACH IN TURN    M32.5367
  //C     IS TESTED TO SEE IF IT CAN BE USED FOR NEXT SWITCH-CURRENT        M32.5368
  //C     CALCULATION.   WE EXECUTE THIS LOOP UNTIL N13 = N18 (UNTIL ALL    M32.5369
  //C     CLOSED SWITCHES HAVE BEEN PROPERLY ORDERED IN NEXTSW:             M32.5370
  statement_3488:
  FEM_DO_SAFE(i, 1, kswtch) {
    if (kbegsw(i) == 0) {
      goto statement_3580;
    }
    if (nextsw(i) != 0) {
      goto statement_3580;
    }
    k = kmswit(i);
    ndx1 = lswtch + i;
    m = kmswit(ndx1);
    n1 = kentnb(i);
    n2 = kentnb(i + 1) - 1;
    jj = 0;
    mm = 0;
    n9 = 0;
    if (k != 1 && k <= kpartb) {
      goto statement_3491;
    }
    //C     KNOWN-VOLTAGE NODE K MUST BE DROPPED FROM CONSIDERATION:          M32.5385
    jj = 1;
    n9++;
    statement_3491:
    if (m != 1 && m <= kpartb) {
      goto statement_3493;
    }
    //C     KNOWN-VOLTAGE NODE M MUST BE DROPPED FROM CONSIDERATION:          M32.5391
    mm = 1;
    n9++;
    statement_3493:
    if (n1 > n2) {
      goto statement_3506;
    }
    FEM_DO_SAFE(ll, n1, n2) {
      j = nbhdsw(ll);
      if (kbegsw(j) == 0) {
        goto statement_3503;
      }
      if (nextsw(j) != 0) {
        goto statement_3503;
      }
      ndx2 = lswtch + j;
      if (jj > 0) {
        goto statement_3497;
      }
      if (k != kmswit(j) && k != kmswit(ndx2)) {
        goto statement_3497;
      }
      jj = 1;
      goto statement_3501;
      statement_3497:
      if (mm > 0) {
        goto statement_3503;
      }
      if (m != kmswit(j) && m != kmswit(ndx2)) {
        goto statement_3503;
      }
      mm = 1;
      statement_3501:
      n9++;
      if (n9 == 2) {
        goto statement_3580;
      }
      statement_3503:;
    }
    //C     WE DROP OUT OF ABOVE  DO 3503  LOOP ONLY IF ONE SIDE OF SWITCH #I M32.5414
    //C     CAN BE USED FOR KCL CALCULATION OF SWITCH CURRENT:                M32.5415
    statement_3506:
    if (n13 > 0) {
      nextsw(n17) = i * nextsw(n17);
    }
    n17 = i;
    if (jj > 0) {
      goto statement_3511;
    }
    nextsw(i) = 1;
    goto statement_3518;
    statement_3511:
    nextsw(i) = -1;
    statement_3518:
    n13++;
    if (n13 == 1) {
      n14 = i;
    }
    if (kode(k) != 0) {
      goto statement_3528;
    }
    if (kode(m) != 0) {
      goto statement_3528;
    }
    //C     SWITCH NOW CLOSING IS CONNECTED TO NO OTHER CLOSED SWITCHES, SO   M32.5427
    //C     EACH END POINTS TO THE OTHER (TRIVIAL KODE CHANGE):               M32.5428
    kode(k) = m;
    kode(m) = k;
    goto statement_3563;
    statement_3528:
    n6 = k;
    if (kode(k) == 0) {
      n6 = m;
    }
    n7 = k;
    if (n7 == n6) {
      n7 = m;
    }
    n19 = n7;
    //C     N6 WAS JUST ONE NODE OF CIRCULAR CHAIN;  MOVE TILL HIGHEST NODE:  M32.5437
    statement_3532:
    if (kode(n6) < n6) {
      goto statement_3536;
    }
    n6 = kode(n6);
    goto statement_3532;
    statement_3536:
    n15 = kode(n7);
    if (n7 <= n6 && n7 >= kode(n6)) {
      goto statement_3541;
    }
    //C     INSERT NODE N7 AS NEW MAX OR NEW MIN:                             M32.5445
    n16 = kode(n6);
    kode(n6) = n7;
    kode(n7) = n16;
    if (n7 > n6) {
      n6 = n7;
    }
    goto statement_3556;
    //C     NON-EXTREMA INSERTION.  1ST FIND INSERTION POINT:                 M32.5451
    statement_3541:
    n9 = kode(n6);
    statement_3544:
    if (n7 < kode(n9)) {
      goto statement_3548;
    }
    n9 = kode(n9);
    goto statement_3544;
    //C     NOW WE INSERT N7 AFTER N9 BUT BEFORE KODE(N9):                    M32.5456
    statement_3548:
    n16 = kode(n9);
    kode(n9) = n7;
    kode(n7) = n16;
    //C     WE REACH 3556 BELOW AFTER NODE N7 HAS BEEN INSERTED IN KODE:      M32.5460
    statement_3556:
    if (n15 == 0) {
      goto statement_3563;
    }
    if (n15 == n19) {
      goto statement_3563;
    }
    //C     N7-END WAS A CHAIN (NOT ISOLATED NODE), AND WE'RE NOT YET DONE:   M32.5463
    n7 = n15;
    goto statement_3536;
    //C     WE REACH 3563 WITH KODE CORRECTLY MODIFIED TO REFLECT ADDED SWITCHM32.5466
    statement_3563:
    if (iprsup >= 3) {
      write(lunit6, "(' COMPLETE PROCESSING OF SWITCH',i5)"), i;
    }
    statement_3580:;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(' DONE ANOTHER PASS OF ALL SWITCHES.  N13, N17 =',2i5)"),
      n13, n17;
  }
  if (n13 > n3) {
    goto statement_3591;
  }
  write(lunit6, "(' TEMPORARY ERROR STOP IN \"SWITCH\" AT S.N. 3587.')");
  stoptp(cmn);
  statement_3591:
  n3 = n13;
  if (n13 < n18) {
    goto statement_3488;
  }
  ktrlsw(4) = n14;
  //C     WE ARE DONE,  HAVING ORDERED ALL N18 OF THE CLOSED SWITCHES.      M32.5482
  //C     NOW ONLY THE CIRCULAR END OF NEXTSW MUST BE PATCHED ON:           M32.5483
  nextsw(n17) = nextsw(n17) * n14;
  goto statement_4457;
  //C     %%%%%%%%%%%%%%%%%%%  BEGIN DELETABLE SOPHISTICATED LOGIC  %%%%%%%%M32.5486
  //C     %%%%% NOTE: "LASTSW" OF DECK "LABCOM" CAN BE DELETED, TOO,        M32.5487
  //C     %%%%%       ALONG WITH THIS BLOCK OF SOPHISTICATED CODE.          M32.5488
  //C     BEGIN BY OPENING ALL SWITCHES SO ORDERED (NEGATIVE MODSWT):       M32.5489
  statement_3605:
  FEM_DO_SAFE(ll, 1, n20) {
    if (modswt(ll) > 0) {
      goto statement_4100;
    }
    n17 = -modswt(ll);
    k = kmswit(n17);
    ndx1 = lswtch + n17;
    m = kmswit(ndx1);
    n3 = fem::iabs(lastsw(n17));
    n4 = fem::iabs(nextsw(n17));
    //C     FIRST TEST WHETHER SWITCH N17 CONSTITUTES A GROUP ALL BY ITSELF:  M32.5499
    if (lastsw(n17) > 0 || kbegsw(n17) != 0) {
      goto statement_3621;
    }
    //C     BEGIN SIMPLIFIED LOGIC FOR ISOLATED SWITCH N17 WHICH NOW OPENS:   M32.5503
    kode(k) = 0;
    kode(m) = 0;
    goto statement_3664;
    //C     BEGIN LOGIC FOR GROUP OF 2 OR MORE SWITCHES.   IMPORTANT SPECIAL  M32.5507
    //C     CASE HERE INVOLVES TEST FOR WHETHER SWITCH N17 IS AT THE END OF   M32.5508
    //C     A RADIAL.   LOOK FOR SUCH FINGER-SWITCHES FIRST:                  M32.5509
    statement_3621:
    n1 = kentnb(n17);
    n2 = kentnb(n17 + 1) - 1;
    jj = 0;
    mm = 0;
    n9 = 0;
    FEM_DO_SAFE(i, n1, n2) {
      n7 = nbhdsw(i);
      if (nextsw(n7) == 0) {
        goto statement_3641;
      }
      ndx2 = lswtch + n7;
      if (jj > 0) {
        goto statement_3627;
      }
      if (k != kmswit(n7) && k != kmswit(ndx2)) {
        goto statement_3627;
      }
      jj = 1;
      n9++;
      goto statement_3635;
      statement_3627:
      if (mm > 0) {
        goto statement_3641;
      }
      if (m != kmswit(n7) && m != kmswit(ndx2)) {
        goto statement_3641;
      }
      mm = 1;
      n9++;
      statement_3635:
      if (n9 == 2) {
        goto statement_3750;
      }
      statement_3641:;
    }
    //C     WE FALL OUT BOTTOM OF  DO 3641  ONLY IF SWITCH N17 IS AT END OF   M32.5535
    //C     RADIAL.   THIS IS FINGER-SWITCH, WITH SIMPLE LOGIC.    BEGIN      M32.5536
    //C     BY FINDING NODE N16 WHICH IS OUT AT END OF RADIAL:                M32.5537
    n16 = k;
    if (jj > 0) {
      n16 = m;
    }
    //C     NEXT EXTRACT NODE N16 (ISOLATED END OF FINGER-SWITCH) FROM KODE:  M32.5540
    n8 = n16;
    statement_3652:
    n9 = kode(n8);
    if (n9 == n16) {
      goto statement_3658;
    }
    n8 = n9;
    goto statement_3652;
    statement_3658:
    kode(n8) = kode(n16);
    kode(n16) = 0;
    //C     REPAIR OF "-" FLAG ON LASTSW THAT MARKS END OF GROUP, IF NEEDED:  M32.5548
    statement_3664:
    if (lastsw(n17) < 0) {
      lastsw(n3) = -fem::iabs(lastsw(n3));
    }
    //C     NEXT REPAIR ZERO KBEGSW THAT MARKS BEGINNING OF GROUP, IF NEEDED: M32.5551
    if (kbegsw(n17) == 0) {
      kbegsw(n4) = 0;
    }
    //C     NEXT ESTABLISH NEW FORWARD LINKAGE NEXTSW AROUND NOW-OPEN N17:    M32.5554
    n15 = nextsw(n3);
    nextsw(n3) = n4;
    if (n15 < 0) {
      nextsw(n3) = -n4;
    }
    //C     NEXT ESTABLISH NEW BACKWARD LINKAGE LASTSW AROUND NOW-OPEN N17:   M32.5559
    n15 = lastsw(n4);
    lastsw(n4) = n3;
    if (n15 < 0) {
      lastsw(n4) = -n3;
    }
    if (ktrlsw(4) == n17) {
      ktrlsw(4) = n4;
    }
    if (ktrlsw(4) == n17) {
      ktrlsw(4) = 0;
    }
    goto statement_4095;
    //C     BEGIN LOGIC FOR GROUP-SPLITTING (SWITCH N17 NOT AT END OF RADIAL):M32.5567
    statement_3750:
    mo = kode(k);
    if (mo == 0) {
      goto statement_3744;
    }
    kode(k) = 0;
    k = mo;
    goto statement_3750;
    statement_3744:
    m1 = fem::iabs(lastsw(n17));
    statement_3746:
    if (kbegsw(m1) == 0) {
      goto statement_3754;
    }
    kbegsw(m1) = 2;
    m1 = lastsw(m1);
    goto statement_3746;
    statement_3754:
    kbegsw(m1) = 2;
    l1 = lastsw(m1);
    m2 = n17;
    statement_3756:
    kbegsw(m2) = 2;
    if (lastsw(m2) < 0) {
      goto statement_3758;
    }
    m2 = fem::iabs(nextsw(m2));
    goto statement_3756;
    statement_3758:
    l2 = fem::iabs(nextsw(m2));
    m7 = 1;
    m3 = m2;
    statement_3760:
    if (m3 != n17) {
      goto statement_3764;
    }
    m3 = fem::iabs(lastsw(m3));
    statement_3764:
    kbegsw(m3) = 0;
    j1 = kmswit(m3);
    j2 = kmswit(m3 + lswtch);
    n1 = kentnb(m3);
    n2 = kentnb(m3 + 1) - 1;
    FEM_DO_SAFE(i, n1, n2) {
      n7 = nbhdsw(i);
      if (nextsw(n7) == 0) {
        goto statement_3774;
      }
      if (kbegsw(n7) == 2) {
        goto statement_3774;
      }
      k1 = kmswit(n7);
      k2 = kmswit(n7 + lswtch);
      jj = j1;
      if (j1 == k1 || j1 == k2) {
        jj = j2;
      }
      mm = j1;
      if (mm == jj) {
        mm = j2;
      }
      goto statement_3788;
      statement_3774:;
    }
    //C     PROCESSING SWITCHES WHICH ARE NO PROCESSED SWITCH CONNECTED       M32.5607
    kode(j1) = j2;
    kode(j2) = j1;
    if (m7 != 1) {
      goto statement_3776;
    }
    //C     THIS IS IST PROCESSING SWITCH AND THE LAST SWITCH OF GROUP 1      M32.5611
    if (nextsw(m3) < 0) {
      m7 = -1;
    }
    nextsw(m3) = m3 * m7;
    m4 = lastsw(m3);
    lastsw(m3) = -m3;
    m3 = fem::iabs(m4);
    m7 = 0;
    goto statement_3760;
    statement_3776:
    n7 = 6666;
    //C     NOW WE BREAK PROCESSED SWITCH CHAIN AND PUT M3 IN THE CHAIN       M32.5620
    m4 = m2;
    statement_3778:
    if (kbegsw(m4) == 0) {
      goto statement_3780;
    }
    m4 = fem::iabs(lastsw(m4));
    goto statement_3778;
    statement_3780:
    if (n7 != 6666) {
      kbegsw(m4) = 1;
    }
    m5 = nextsw(m3);
    nextsw(m3) = m4;
    if (m5 < 0) {
      nextsw(m3) = -m4;
    }
    m5 = lastsw(m4);
    lastsw(m4) = m3;
    if (m5 < 0) {
      lastsw(m4) = -m3;
    }
    m5 = fem::iabs(m5);
    m4 = nextsw(m5);
    nextsw(m5) = m3;
    if (m4 < 0) {
      nextsw(m5) = -m3;
    }
    m6 = lastsw(m3);
    lastsw(m3) = m5;
    if (n7 == 6666) {
      lastsw(m3) = -m5;
    }
    if (m3 == m1) {
      goto statement_3795;
    }
    m3 = m6;
    goto statement_3760;
    //C     M3 CONNECTS TO N7 AND BECOMES THE FIRST SWITCH IN N7 SWITCH GROUP M32.5642
    statement_3788:
    m4 = n7;
    statement_3784:
    nmin = kode(mm);
    if (nmin < mm) {
      goto statement_3790;
    }
    mm = nmin;
    goto statement_3784;
    //C     M3 IS JUST AT THE END OF A RADIAL.  PUT NODE JJ IN THE KODE CHAIN M32.5648
    statement_3790:
    if (jj < mm && jj > nmin) {
      goto statement_3792;
    }
    //C     IN THE "KODE" CHAIN,  NODE JJ IS LARGER THAN MM OR LESS THAN NMIN M32.5650
    kode(mm) = jj;
    kode(jj) = nmin;
    goto statement_3778;
    statement_3792:
    mm = kode(nmin);
    if (mm > jj) {
      goto statement_3794;
    }
    nmin = mm;
    goto statement_3792;
    statement_3794:
    kode(nmin) = jj;
    kode(jj) = mm;
    goto statement_3778;
    statement_3795:
    if (l2 == m1) {
      goto statement_4095;
    }
    //C     WE FOUND OTHER SWITCH GROUP. BREAK JUST PROCESSING SWITCH VETTORS M32.5662
    //C     AND FORM THE WHOLE SWICH VECTORS.   M1 IS STILL 1ST OF THE GROUP. M32.5663
    m2 = lastsw(m1);
    lastsw(m1) = l1;
    if (m2 < 0) {
      lastsw(m1) = -l1;
    }
    m2 = fem::iabs(m2);
    m1 = nextsw(m2);
    nextsw(m2) = l2;
    if (m1 < 0) {
      nextsw(m2) = -l2;
    }
    m1 = lastsw(l2);
    lastsw(l2) = m2;
    if (m1 < 0) {
      lastsw(l2) = -m2;
    }
    statement_4095:
    nextsw(n17) = 0;
    lastsw(n17) = 0;
    kbegsw(n17) = 1;
    ktrlsw(2) = ktrlsw(2) - 1;
    if (iprsup >= 2) {
      write(lunit6,
        "(' DONE WITH ANOTHER OPENING.  LL, N17, K, M =',10i5)"), ll,
        n17, k, m;
    }
    statement_4100:;
  }
  //C     NEXT CLOSE ALL SWITCHES SO ORDERED (POSITIVE MODSWT):             M32.5682
  FEM_DO_SAFE(ll, 1, n20) {
    if (modswt(ll) < 0) {
      goto statement_4450;
    }
    n17 = modswt(ll);
    k = kmswit(n17);
    ndx1 = lswtch + n17;
    m = kmswit(ndx1);
    n1 = kentnb(n17);
    n2 = kentnb(n17 + 1) - 1;
    mm = 0;
    n4 = 0;
    if (n2 < n1) {
      goto statement_4120;
    }
    FEM_DO_SAFE(i, n1, n2) {
      n7 = nbhdsw(i);
      if (nextsw(n7) == 0) {
        goto statement_4118;
      }
      ndx2 = lswtch + n7;
      if (n4 > 0) {
        goto statement_4113;
      }
      jj = n7;
      n5 = k;
      if (k == kmswit(jj)) {
        n5 = m;
      }
      if (k == kmswit(ndx2)) {
        n5 = m;
      }
      n4 = k;
      if (n4 == n5) {
        n4 = m;
      }
      goto statement_4118;
      statement_4113:
      if (kmswit(n7) != n5 && kmswit(ndx2) != n5) {
        goto statement_4118;
      }
      //C     WE HAVE FOUND GROUP 2 SWITCH (CONNECTED TO NODE N5):              M32.5708
      mm = n7;
      goto statement_4126;
      statement_4118:;
    }
    if (n4 > 0) {
      goto statement_4300;
    }
    //C     NO CONNECTED SWITCHES WHICH ARE CLOSED IS EASY SPECIAL CASE:      M32.5713
    statement_4120:
    kode(k) = m;
    kode(m) = k;
    m1 = ktrlsw(4);
    ktrlsw(4) = n17;
    kbegsw(n17) = 0;
    if (m1 != 0) {
      goto statement_4122;
    }
    nextsw(n17) = n17;
    if (k > kpartb || k == 1) {
      nextsw(n17) = -n17;
    }
    lastsw(n17) = -n17;
    goto statement_4130;
    //C     READY TO CHECK FOR ILLEGAL SWITCH LOOP, AND ALSO VOLTAGE SOURCE:  M32.5724
    statement_4126:
    n6 = 0;
    n2 = n4;
    //C     ENTER LOOP OVER NODES IN GROUP 1, TO CHECK FOR LOOPS AND SOURCES: M32.5727
    statement_4135:
    n2 = kode(n2);
    if (n2 == 1) {
      n6 = 1;
    }
    if (n2 > kpartb) {
      n6 = 1;
    }
    if (n2 != n5) {
      goto statement_4147;
    }
    cmn.kill = 64;
    lstat(19) = 4147;
    cmn.bus1 = bus(n2);
    goto statement_4457;
    statement_4147:
    if (n2 != n4) {
      goto statement_4135;
    }
    //C     OK, SO NO SWITCH LOOPS.  BUT WE MIGHT HAVE TO SWAP GROUPS 1 AND   M32.5739
    //C     2 --- REQUIRED IF GROUP 1 HAD A VOLTAGE SOURCE:                   M32.5740
    if (n6 == 0) {
      goto statement_4300;
    }
    //C     FIRST, SWAP KNOWN SWITCHES IN GROUPS (JJ AND MM):                 M32.5742
    n12 = mm;
    mm = jj;
    jj = n12;
    //C     NEXT, SWAP NODES N4 AND N5 (GROUP 1 AND GROUP 2 CONNECTIONS):     M32.5746
    n12 = n5;
    n5 = n4;
    n4 = n12;
    statement_4300:
    nmax = n4;
    n3 = n5;
    statement_4302:
    nmin = kode(nmax);
    if (nmin < nmax) {
      goto statement_4304;
    }
    nmax = nmin;
    goto statement_4302;
    statement_4304:
    m5 = kode(n3);
    if (n3 < nmin) {
      goto statement_4310;
    }
    if (n3 > nmax) {
      goto statement_4310;
    }
    nless = nmin;
    statement_4306:
    nover = kode(nless);
    if (nover > n3) {
      goto statement_4308;
    }
    nless = nover;
    goto statement_4306;
    statement_4308:
    kode(nless) = n3;
    kode(n3) = nover;
    goto statement_4312;
    statement_4310:
    kode(nmax) = n3;
    kode(n3) = nmin;
    statement_4312:
    if (m5 == 0) {
      goto statement_4314;
    }
    if (m5 == n5) {
      goto statement_4314;
    }
    if (n3 < nmin) {
      nmin = n3;
    }
    if (n3 > nmax) {
      nmax = n3;
    }
    n3 = m5;
    goto statement_4304;
    statement_4314:
    m1 = jj;
    statement_4316:
    if (kbegsw(m1) == 0) {
      goto statement_4318;
    }
    m1 = fem::iabs(lastsw(m1));
    goto statement_4316;
    statement_4318:
    if (mm != 0) {
      goto statement_532;
    }
    if (n5 > kpartb || n5 == 1) {
      goto statement_532;
    }
    //C     N17 CAN BE 1ST SWITCH OF THE GROUP NOW, SO IT IS EASY TO PROCESS  M32.5781
    kbegsw(n17) = 0;
    kbegsw(m1) = 1;
    if (ktrlsw(4) == m1) {
      ktrlsw(4) = n17;
    }
    statement_4122:
    m3 = lastsw(m1);
    m2 = fem::iabs(m3);
    nextsw(n17) = m1;
    if (n4 == 0) {
      goto statement_4124;
    }
    if (n5 == m) {
      nextsw(n17) = -m1;
    }
    lastsw(n17) = m2;
    goto statement_4128;
    statement_4124:
    if (k > kpartb || k == 1) {
      nextsw(n17) = -m1;
    }
    lastsw(n17) = -m2;
    statement_4128:
    lastsw(m1) = n17;
    if (m3 < 0) {
      lastsw(m1) = -n17;
    }
    if (nextsw(m2) < 0) {
      n17 = -n17;
    }
    nextsw(m2) = n17;
    goto statement_4130;
    //C     NOW ENTER GENERAL LOGIC TO PROCESS GROUP OF TWO OR MORE SWITCHES  M32.5799
    statement_532:
    kbegsw(n17) = 1;
    n3 = m1;
    statement_4322:
    n8 = n3;
    if (nextsw(n3) < 0) {
      n8 = lswtch + n3;
    }
    if (kmswit(n8) == n4) {
      goto statement_4360;
    }
    if (lastsw(n3) < 0) {
      goto statement_4324;
    }
    n3 = fem::iabs(nextsw(n3));
    goto statement_4322;
    //C     ALL JJ SWITCHES OF JJ GROUP ARE PROCESSED .   NOW PROCESSING N17  M32.5808
    statement_4324:
    lastsw(n3) = -lastsw(n3);
    m3 = nextsw(n3);
    m2 = fem::iabs(m3);
    nextsw(n3) = n17;
    if (m3 < 0) {
      nextsw(n3) = -n17;
    }
    //C     N17 IS IN THE END OF A RADIAL.   WE BEGIN TO PROCESS SWITCH N17.  M32.5814
    statement_4399:
    if (mm != 0) {
      goto statement_4330;
    }
    lastsw(n17) = -n3;
    if (m1 == m9 && m1 == m2) {
      m2 = ktrlsw(4);
    }
    statement_4325:
    nextsw(n17) = m2;
    if (n4 == m) {
      nextsw(n17) = -m2;
    }
    if (lastsw(m2) < 0) {
      n17 = -n17;
    }
    lastsw(m2) = n17;
    goto statement_4130;
    //C     NOW PROCESSING SWITCH N17  WHICH CONNECTED  ANOTHER SWITCH GROUP  M32.5823
    statement_4330:
    lastsw(n17) = n3;
    l1 = mm;
    statement_4332:
    if (kbegsw(l1) == 0) {
      goto statement_4334;
    }
    l1 = fem::iabs(lastsw(l1));
    goto statement_4332;
    statement_4334:
    kbegsw(l1) = 1;
    if (ktrlsw(4) == l1) {
      ktrlsw(4) = m1;
    }
    if (m2 == l1) {
      goto statement_4325;
    }
    //C     A LITTLE TROUBLE.  FIRST EXTRACT 2ND GROUP FROM SWITCH CHAIN AND  M32.5832
    //C     THEN CONNECT THE THREE SWITCH GROUPS CAREFULLY.                   M32.5833
    l2 = mm;
    statement_4336:
    if (lastsw(l2) < 0) {
      goto statement_4338;
    }
    l2 = fem::iabs(nextsw(l2));
    goto statement_4336;
    statement_4338:
    l3 = fem::iabs(lastsw(l1));
    l4 = fem::iabs(nextsw(l2));
    l5 = l4;
    if (nextsw(l3) < 0) {
      l5 = -l5;
    }
    nextsw(l3) = l5;
    if (lastsw(l4) < 0) {
      l3 = -l3;
    }
    lastsw(l4) = l3;
    nextsw(n17) = l1;
    if (n4 == m) {
      nextsw(n17) = -l1;
    }
    if (lastsw(l1) < 0) {
      n17 = -n17;
    }
    lastsw(l1) = n17;
    l5 = m2;
    if (nextsw(l2) < 0) {
      l5 = -l5;
    }
    nextsw(l2) = l5;
    if (lastsw(m2) < 0) {
      l2 = -l2;
    }
    lastsw(m2) = l2;
    goto statement_4130;
    statement_4360:
    if (lastsw(n3) > 0) {
      goto statement_4364;
    }
    nextsw(n3) = -nextsw(n3);
    goto statement_4324;
    //C     PROCESS SWITCHES WHICH NEED CHANGING "NEXTSW" ORDER IN THE GROUP  M32.5858
    statement_4364:
    nextsw(n17) = 1;
    m3 = n3;
    m9 = m3;
    nn = 0;
    statement_4368:
    kbegsw(n3) = 2;
    nn++;
    if (lastsw(n3) < 0) {
      goto statement_4370;
    }
    n3 = fem::iabs(nextsw(n3));
    goto statement_4368;
    statement_4370:
    m2 = fem::iabs(nextsw(n3));
    nextsw(n3) = m3;
    kbegsw(n17) = 2;
    m4 = lastsw(m3);
    kk2 = 0;
    ll2 = 1;
    if (nextsw(m4) < 0) {
      ll2 = -1;
    }
    if (m1 == m3 && m1 == m2) {
      m4 = 0;
    }
    n3 = fem::iabs(nextsw(m3));
    statement_4374:
    k1 = kmswit(n3);
    k2 = kmswit(lswtch + n3);
    n1 = kentnb(n3);
    n2 = kentnb(n3 + 1) - 1;
    j1 = 0;
    j2 = 0;
    numb = 0;
    FEM_DO_SAFE(i, n1, n2) {
      k7 = nbhdsw(i);
      if (nextsw(k7) == 0) {
        goto statement_4380;
      }
      if (kbegsw(k7) != 2) {
        goto statement_4380;
      }
      k3 = kmswit(k7);
      k4 = kmswit(lswtch + k7);
      if (j1 == 1) {
        goto statement_4372;
      }
      if (k1 != k3 && k1 != k4) {
        goto statement_4372;
      }
      j1 = 1;
      numb++;
      goto statement_4376;
      statement_4372:
      if (j2 == 1) {
        goto statement_4380;
      }
      if (k2 != k3 && k2 != k4) {
        goto statement_4380;
      }
      j2 = 1;
      numb++;
      statement_4376:
      if (numb != 2) {
        goto statement_4380;
      }
      m3 = n3;
      goto statement_4384;
      statement_4380:;
    }
    kk2++;
    if (m4 != 0) {
      goto statement_4382;
    }
    ktrlsw(4) = n3;
    lastsw(n3) = 0;
    kbegsw(n3) = 0;
    goto statement_4383;
    statement_4382:
    kbegsw(n3) = 1;
    if (m9 == m1 && kk2 == 1) {
      kbegsw(n3) = 0;
    }
    lastsw(n3) = m4;
    nextsw(m4) = n3 * ll2;
    ll2 = 1;
    statement_4383:
    if (j1 == 1) {
      ll2 = -1;
    }
    if (kk2 == nn) {
      goto statement_4388;
    }
    m4 = n3;
    nextsw(m3) = nextsw(n3);
    statement_4384:
    n3 = fem::iabs(nextsw(n3));
    goto statement_4374;
    statement_4388:
    nextsw(n3) = n17 * ll2;
    kbegsw(n17) = 1;
    goto statement_4399;
    statement_4130:
    ktrlsw(2)++;
    if (iprsup >= 2) {
      write(lunit6,
        "(' DONE WITH ANOTHER CLOSURE.  LL, N17, K, M =',10i5)"), ll,
        n17, k, m;
    }
    statement_4450:;
  }
  //C     %%%%%%%%%%%%%%%%%%%  END   DELETABLE SOPHISTICATED LOGIC  %%%%%%%%M32.5928
  statement_4457:
  if (iprsup < 2) {
    goto statement_4465;
  }
  {
    write_loop wloop(cmn, lunit6, format_3451);
    FEM_DO_SAFE(i, 1, kswtch) {
      wloop, nextsw(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3452);
    FEM_DO_SAFE(i, 1, kswtch) {
      wloop, lastsw(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3453);
    FEM_DO_SAFE(i, 1, kswtch) {
      wloop, kbegsw(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3454);
    FEM_DO_SAFE(i, 1, ntot) {
      wloop, kode(i);
    }
  }
  statement_4465:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT \"SWITCH\".')");
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}


void matmul(
  arr_ref<double, 2> aum,
  arr_cref<double, 2> bum) try
{
  aum(dimension(3, 3));
  bum(dimension(3, 3));
  //C     MATRIX ALGEBRA MODULE USED BY UNIVERSAL MACHINE (U.M.)            M32. 291
  int n5 = 3;
  int n1 = fem::int0;
  int n2 = fem::int0;
  arr_2d<3, 3, double> cum(fem::fill0);
  int n3 = fem::int0;
  FEM_DO_SAFE(n1, 1, n5) {
    FEM_DO_SAFE(n2, 1, n5) {
      cum(n1, n2) = aum(n1, 1) * bum(1, n2);
      FEM_DO_SAFE(n3, 2, n5) {
        cum(n1, n2) += aum(n1, n3) * bum(n3, n2);
      }
    }
  }
  FEM_DO_SAFE(n1, 1, n5) {
    FEM_DO_SAFE(n2, 1, n5) {
      aum(n1, n2) = cum(n1, n2);
    }
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void matvec(
  arr_cref<double, 2> aum,
  arr_ref<double> yum) try
{
  aum(dimension(3, 3));
  yum(dimension(15));
  //C     MATRIX ALGEBRA MODULE USED BY UNIVERSAL MACHINE (U.M.)            M32. 307
  int n1 = 3;
  int n2 = fem::int0;
  arr_1d<3, double> x(fem::fill0);
  FEM_DO_SAFE(n2, 1, n1) {
    x(n2) = 0.0f;
  }
  int n3 = fem::int0;
  FEM_DO_SAFE(n2, 1, n1) {
    FEM_DO_SAFE(n3, 1, n1) {
      x(n2) += aum(n2, n3) * yum(n3);
    }
  }
  FEM_DO_SAFE(n2, 1, n1) {
    yum(n2) = x(n2);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}


struct plotng_save
{
  arr<int> kdig;
  int klank;
  int kom;
  arr<int> ktsin;
  arr<int> kut;

  plotng_save() :
    kdig(dimension(10), fem::fill0),
    klank(fem::int0),
    kom(fem::int0),
    ktsin(dimension(4), fem::fill0),
    kut(dimension(131), fem::fill0)
  {}
};

void plotng(
  common& cmn,
  int const& kkrv,
  int const& kklm) try
{
  FEM_CMN_SVE(plotng);
  common_read read(cmn);
  common_write write(cmn);
  double& tolmat = cmn.tolmat;
  auto& lunt12 = cmn.lunt12;
  int& iprsup = cmn.iprsup;
  //
  //arr_ref<int> kdig(sve.kdig, dimension(10));
  //int& klank = sve.klank;
  //int& kom = sve.kom;
  //arr_ref<int> ktsin(sve.ktsin, dimension(4));
  //arr_ref<int> kut(sve.kut, dimension(131));

  arr_1d<131, fem::str<1> > kut(fem::fill0);
  arr_1d<4, fem::str<1> > ktsin(fem::fill0);
  fem::str<1> kom = "";
  fem::str<1> klank = "";
  arr_1d<10, fem::str<1> > kdig(fem::fill0);

  if (is_called_first_time) {
    kut(1) = " ";
    ktsin(1) = "A";
    ktsin(2) = "B";
    ktsin(3) = "C";
    ktsin(4) = "D";
    kom = "*";
    klank = " ";
    kdig(1) = "1";
    kdig(2) = "2";
    kdig(3) = "3";
    kdig(4) = "4";
    kdig(5) = "5";
    kdig(6) = "6";
    kdig(7) = "7";
    kdig(8) = "8";
    kdig(9) = "9";
    kdig(10) = "0";
  }
  auto& lunit6 = cmn.lunit6;
  int krv = fem::int0;
  int klm = fem::int0;
  int j = fem::int0;
  int n4 = fem::int0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  int n1 = fem::int0;
  int n7 = fem::int0;
  int n8 = fem::int0;
  int n14 = fem::int0;
  //C     UNIVERSAL MODULE CALLED ONLY BY "INNR29" OF OVERLAY 29.           M35.8735
  //C     SOME LOGIC IS SIMILAR TO "LINPLT" OF OVERLAY 31.                  M35.8736
  //C     BURROUGHS: PRESERVE LOCAL VARIABLE BETWEEN MODULE CALLS:          M35.8738
  if (iprsup >= 1) {
    write(lunit6, "(' TOP OF \"PLOTNG\".  KKRV, KKLM =',2i8)"), kkrv, kklm;
  }
  krv = kkrv;
  klm = kklm;
  if (klm ==  - 5678) {
    goto statement_350;
  }
  if (klm > 131) {
    goto statement_5831;
  }
  if (klm ==  - 4321) {
    goto statement_4832;
  }
  if (klm >= 0) {
    goto statement_3652;
  }
  write(lunit6, "(1x,131a1)"), kut;
  statement_350:
  FEM_DO_SAFE(j, 1, 131) {
    kut(j) = klank;
  }
  kut(5) = kdig(1);
  goto statement_9000;
  //C     BEGIN CODE TO ADD CURVE "KRV" TO COLUMN "KLM" OF KUT(131)         M35.8759
  statement_3652:
  if (krv != 2) {
    goto statement_3664;
  }
  if (kut(47) == klank) {
    kut(47) = kdig(1);
  }
  statement_3664:
  if (krv != 3) {
    goto statement_3671;
  }
  if (kut(89) == klank) {
    kut(89) = kdig(1);
  }
  statement_3671:
  if (kut(klm) == klank) {
    goto statement_3688;
  }
  if (kut(klm) == kdig(1)) {
    goto statement_3688;
  }
  kut(klm) = kom;
  goto statement_9000;
  statement_3688:
  kut(klm) = ktsin(krv);
  goto statement_9000;
  //C     BEGIN CODE TO ENCODE MEAN CLOSING TIME STORED IN TOLMAT:          M35.8770
  statement_4832:
  n4 = 6;
  if (krv == 2) {
    n4 = 48;
  }
  if (krv == 3) {
    n4 = 90;
  }
  n5 = n4 + 11;
  if (iprsup >= 1) {
    write(lunit6, "(' LUNT12 WRITE.  N4, TOLMAT =',i8,e15.3)"), n4, tolmat;
  }
  cmn.io.rewind(lunt12);
  write(lunt12, "(e12.3)"), tolmat;
  cmn.io.rewind(lunt12);
  {
    read_loop rloop(cmn, lunt12, "(12a1)");
    FEM_DO_SAFE(j, n4, n5) {
      rloop, kut(j);
    }
  }
  goto statement_9000;
  //C     BEGIN CODE TO ENCODE 3-DIGIT KLM ON RIGHT EDGE OF KUT:            M35.8784
  statement_5831:
  if (krv == 1) {
    klm = klm - 5;
  }
  if (krv == 2) {
    klm = klm - 47;
  }
  if (krv == 3) {
    klm = klm - 89;
  }
  if (klm < 1000) {
    goto statement_5856;
  }
  write(lunit6,
    "(' TOO LARGE KLM IN \"PLOTNG\".  STOP.','   KRV, KLM =',2i8,8x,"
    "'KUT(1:131) ...',/,1x,131a1)"),
    krv, klm;
  statement_5856:
  n6 = klm / 100;
  n1 = klm - 100 * n6;
  n7 = n1 / 10;
  n8 = n1 - 10 * n7;
  if (n7 == 0) {
    n7 = 10;
  }
  if (n8 == 0) {
    n8 = 10;
  }
  n14 = 120;
  if (krv == 2) {
    n14 = 124;
  }
  if (krv == 3) {
    n14 = 128;
  }
  kut(n14) = kdig(n6);
  kut(n14 + 1) = kdig(n7);
  kut(n14 + 2) = kdig(n8);
  if (iprsup >= 1) {
    write(lunit6,
      "(' ENCODE KLM.   KRV, KLM, N14, N6, N7, N8 =',6i6,8x,'KUT(1:131) ....',"
      "/,1x,131a1)"),
      krv, klm, n14, n6, n7, n8, kut;
  }
  statement_9000:
  if (iprsup >= 3) {
    write(lunit6,
      "(' EXIT \"PLOTNG\",  KRV, KLM =',2i6,8x,'KUT(1:131) FOLLOWS .....',/,"
      "1x,131a1)"),
      krv, klm, kut;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct innr29_save
{
  arr<int> normal;
  arr<fem::str<8> > texnam;
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;
  fem::str<8> text8;

  innr29_save() :
    normal(dimension(25), fem::fill0),
    texnam(dimension(10), fem::fill0),
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0),
    text8(fem::char0)
  {}
};

void innr29(
  common& cmn,
  arr_ref<double> array,
  arr_ref<int> ibsout,
  arr_ref<int> kount,
  arr_ref<int> kpoint,
  arr_ref<int> nsum,
  str_arr_ref<> bus,
  arr_ref<int> kmswit,
  arr_ref<int> kdepsw,
  arr_ref<int> ibrnch,
  arr_ref<int> jbrnch,
  arr_ref<double> akey,
  arr_ref<double> tstat,
  arr_ref<double> tclose,
  arr_ref<double> topen) try
{
  FEM_CMN_SVE(innr29);
  array(dimension(1));
  ibsout(dimension(1));
  kount(dimension(1));
  kpoint(dimension(1));
  nsum(dimension(1));
  bus(dimension(1));
  kmswit(dimension(1));
  kdepsw(dimension(1));
  ibrnch(dimension(1));
  jbrnch(dimension(1));
  akey(dimension(1));
  tstat(dimension(1));
  tclose(dimension(1));
  topen(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& bus6 = cmn.bus6;
  fem::str<8>& blank = cmn.blank;
  const auto& texta6 = cmn.texta6;
  auto& date1= cmn.date1;
  auto& tclock= cmn.tclock;
  const auto& abuff = cmn.abuff;
  double& aincr = cmn.aincr;
  double& t = cmn.t;
  double& tolmat = cmn.tolmat;
  double& fltinf = cmn.fltinf;
  double& pu = cmn.pu;
  auto& moncar = cmn.moncar;
  auto& lunit3 = cmn.lunit3;
  auto& lunit9 = cmn.lunit9;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  int& lswtch = cmn.lswtch;
  int& nv = cmn.nv;
  int& maxbus = cmn.maxbus;
  int& lastov = cmn.lastov;
  int& numout = cmn.numout;
  int& ivolt = cmn.ivolt;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  int& nc = cmn.nc;
  int& numnvo = cmn.numnvo;
  int& nenerg = cmn.nenerg;
  double& xmean1 = cmn.xmean1;
  double& xvar1 = cmn.xvar1;
  double& stdev1 = cmn.stdev1;
  double& vmax = cmn.vmax;
  int& liminc = cmn.liminc;
  int& key = cmn.key;
  //
  arr_ref<int> normal(sve.normal, dimension(25));
  str_arr_ref<1> texnam(sve.texnam, dimension(10));
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text8 = sve.text8;
  if (is_called_first_time) {
    text1 = "MISC. ";
    text2 = "STATIS";
    sve.text3 = "TICS D";
    sve.text4 = "ATA   ";
    sve.text5 = "BEGIN ";
    sve.text6 = "NEW DA";
    sve.text7 = "BNDC  ";
    text8 = " CONT.";
    texnam(1) = "VOLTAG";
    texnam(2) = "E     ";
    texnam(3) = "CURREN";
    texnam(4) = "T     ";
    texnam(5) = " POWER";
    texnam(6) = "      ";
    texnam(7) = "ENERGY";
    texnam(8) = "      ";
    texnam(9) = " NODE ";
    texnam(10) = "BRANCH";
    normal(1) = 0;
    normal(2) = 0;
    normal(3) = 0;
    normal(4) = 0;
    normal(5) = 1;
    normal(6) = 2;
    normal(7) = 4;
    normal(8) = 8;
    normal(9) = 12;
    normal(10) = 18;
    normal(11) = 24;
    normal(12) = 28;
    normal(13) = 30;
    normal(14) = 28;
    normal(15) = 24;
    normal(16) = 18;
    normal(17) = 12;
    normal(18) = 8;
    normal(19) = 4;
    normal(20) = 2;
    normal(21) = 1;
    normal(22) = 0;
    normal(23) = 0;
    normal(24) = 0;
    normal(25) = 0;
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int ioutcs = fem::int0;
  int knt = fem::int0;
  int kbase = fem::int0;
  int isw = fem::int0;
  int idist = fem::int0;
  int itest = fem::int0;
  int kloaep = fem::int0;
  int llm1 = fem::int0;
  int jdummy = fem::int0;
  int in1 = fem::int0;
  int in5 = fem::int0;
  int in10 = fem::int0;
  int in15 = fem::int0;
  int in20 = fem::int0;
  int in25 = fem::int0;
  int in30 = fem::int0;
  int ll264 = fem::int0;
  int icnovf = fem::int0;
  int npnerg = fem::int0;
  double total = fem::double0;
  int icont = fem::int0;
  int n22 = fem::int0;
  int n9 = fem::int0;
  double dd1 = fem::double0;
  int infexp = fem::int0;
  int kntout = fem::int0;
  int k9 = fem::int0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  int n16 = fem::int0;
  int nsmout = fem::int0;
  int n18 = fem::int0;
  int numbco = fem::int0;
  int j2 = fem::int0;
  int i = fem::int0;
  int m13 = fem::int0;
  int nstat = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int i0 = fem::int0;
  int j = fem::int0;
  int n2end = fem::int0;
  double basev = fem::double0;
  int n13 = fem::int0;
  arr<int> itemp(dimension(264), fem::fill0);
  int n11 = fem::int0;
  int n8 = fem::int0;
  double c8 = fem::double0;
  arr<fem::str<8> > aupper(dimension(264), fem::fill0);
  int k = fem::int0;
  int ibropt = fem::int0;
  double d11 = fem::double0;
  double d1 = fem::double0;
  double vmaxsv = fem::double0;
  double vminsv = fem::double0;
  int iall = fem::int0;
  double totmax = fem::double0;
  int kend = fem::int0;
  int mpr = fem::int0;
  int kfl = fem::int0;
  int n17 = fem::int0;
  int numsrt = fem::int0;
  int n33 = fem::int0;
  int k1 = fem::int0;
  int k2 = fem::int0;
  int n3 = fem::int0;
  double ainsav = fem::double0;
  double vmin = fem::double0;
  int i1 = fem::int0;
  double sxi = fem::double0;
  double sxisq = fem::double0;
  int n88 = fem::int0;
  int l6 = fem::int0;
  int l7 = fem::int0;
  int kj = fem::int0;
  double xi = fem::double0;
  double xisq = fem::double0;
  double dex = fem::double0;
  int index = fem::int0;
  double term2 = fem::double0;
  double term1 = fem::double0;
  double sxifi = fem::double0;
  double sx2fi = fem::double0;
  int is = fem::int0;
  double txmax = fem::double0;
  double xint = fem::double0;
  int maxint = fem::int0;
  int m = fem::int0;
  int mm = fem::int0;
  double r = fem::double0;
  double xxi = fem::double0;
  double fi = fem::double0;
  double xifi = fem::double0;
  double x2fi = fem::double0;
  double percen = fem::double0;
  int m1 = fem::int0;
  double xi1 = fem::double0;
  double r1 = fem::double0;
  int kont1 = fem::int0;
  int nsum1 = fem::int0;
  double prcen1 = fem::double0;
  int mend = fem::int0;
  double xmean = fem::double0;
  double xvar = fem::double0;
  double stddev = fem::double0;
  int nsw = fem::int0;
  int nssw = fem::int0;
  int n = fem::int0;
  double vartot = fem::double0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  double bias = fem::double0;
  int m5 = fem::int0;
  int m6 = fem::int0;
  double ranoff = fem::double0;
  int n7 = fem::int0;
  double sqrt3 = fem::double0;
  arr_1d<25, int> kount1(fem::fill0);
  arr_1d<25, int> kount2(fem::fill0);
  arr_1d<25, int> kount3(fem::fill0);
  double sdt = fem::double0;
  double deltsc = fem::double0;
  double fclosc = fem::double0;
  double deltsu = fem::double0;
  double fclosu = fem::double0;
  int i2 = fem::int0;
  int i3 = fem::int0;
  int k3 = fem::int0;
  int k4 = fem::int0;
  int k5 = fem::int0;
  int k6 = fem::int0;
  int L = fem::int0;
  double twdep = fem::double0;
  int nn3 = fem::int0;
  int l1 = fem::int0;
  int n4 = fem::int0;
  int nn4 = fem::int0;
  int l2 = fem::int0;
  int nn5 = fem::int0;
  int l3 = fem::int0;
  int kurve1 = fem::int0;
  int kurve2 = fem::int0;
  int kurve3 = fem::int0;
  int kurve4 = fem::int0;
  int line = fem::int0;
  int kolum1 = fem::int0;
  int kolum2 = fem::int0;
  int kolum3 = fem::int0;
  int kolnum = fem::int0;
  int nm1 = fem::int0;
  int mm1 = fem::int0;
  double temp = fem::double0;
  int jn = fem::int0;
  int jn1 = fem::int0;
  double abc = fem::double0;
  double b = fem::double0;
  double c = fem::double0;
  double dn = fem::double0;
  double fs = fem::double0;
  int il = fem::int0;
  int jb = fem::int0;
  int ja = fem::int0;
  double z = fem::double0;
  double az = fem::double0;
  double d = fem::double0;
  double y = fem::double0;
  double ei = fem::double0;
  double es = fem::double0;
  double prob = fem::double0;
  double c1 = fem::double0;
  double c2 = fem::double0;
  double c4 = fem::double0;
  static const char* format_3 =
    "(/,' NOTICE ----- OVERVOLTAGE TABULATION FOR THIS VOLTAGE VARIABLE CAN NO"
    "T CONTINUE, DUE TO INSUFFICIENT WORKING',/,14x,"
    "'SPACE.   STATISTICS MISCELLANEOUS DATA PARAMETER  ''XMAXMX''  HAS BEEN E"
    "XCEEDED BY THE PEAK PER UNIT',/,14x,"
    "'OVERVOLTAGE (ACTUALLY, EXCEEDED BY  5.0  TIMES OR MORE).')";
  static const char* format_434 = "(5x,e12.4,' SWITCH CLOSINGS/COL')";
  static const char* format_4615 =
    "('+STATISTICAL OUTPUT OF ',a6,1x,a6,a1,e13.4)";
  static const char* format_5020 = "(1x,i9,f20.5,e20.6,2i15,f20.3)";
  static const char* format_534 = "(5x,2(e12.4,' SWITCH CLOSINGS/COL',10x))";
  static const char* format_634 = "(5x,3(e12.4,' SWITCH CLOSINGS/COL',10x))";
  static const char* format_6434 =
    "(' ----------------------------------------------------------------------"
    "-------------------------------------------------------------')";
  static const char* format_661 =
    "(/,' AT 661 OF SUBR29,N3, ARRAY(N3), L1 AND KOUNT1(L1) ARE',10x,i10,"
    "e15.6,2i10)";
  static const char* format_817 =
    "(' ONE OR MORE NONEXISTENT NODE NAMES IN BRANCH',' OUTPUT  \"',a6,"
    "'\"  TO  \"',a6,'\" .   THIS REQUEST IGNORED.')";
  static const char* format_825 = "(e12.4)";
  static const char* format_835 = "(e12.4,30x,e12.4)";
  static const char* format_845 = "(e12.4,2(30x,e12.4))";
  //C!EQUIVALENCE  (MONCAR(1),    KNT),   (MONCAR(2),  KBASE)
  //C!EQUIVALENCE                         (MONCAR(4),    ISW)
  //C!EQUIVALENCE  (MONCAR(5),  IDIST),   (MONCAR(6),  ITEST)
  //C!EQUIVALENCE  (MONCAR(9), KLOAEP)
  ioutcs = lstat(59);
  ioutcs = lstat(59);
  knt = moncar(1);
  kbase = moncar(2);
  isw = moncar(4);
  idist = moncar(5);
  itest = moncar(6);
  kloaep = moncar(9);
  if (iprsup >= 1) {
    write(lunit6,
      "(' TOP OF \"INNR29\".  ISW, LASTOV, LUNIT9 =',3i8)"), isw,
      lastov, lunit9;
  }
  llm1 = -1;
  jdummy = 999;
  in1 = 1;
  in5 = 5;
  in10 = 10;
  in15 = 15;
  in20 = 20;
  in25 = 25;
  in30 = 30;
  ll264 = 264;
  icnovf = 0;
  npnerg = fem::iabs(nenerg);
  total = npnerg;
  icont = 0;
  n22 = 0;
  n9 = nv + 1;
  dd1 = alog1z(fltinf);
  infexp = dd1 + 0.5f;
  if (isw == 4444) {
    goto statement_399;
  }
  kntout = 0;
  k9 = 0;
  cmn.io.rewind(lunit9);
  if (knt == 1) {
    goto statement_7;
  }
  read(lunit9, fem::unformatted), ntot, nenerg;
  goto statement_9;
  statement_7:
  read(lunit9, fem::unformatted), ntot;
  statement_9:
  if (cmn.jflsos > 0) {
    read(lunit9, fem::unformatted), pu;
  }
  //C     READ (LUNIT9)  DATE1, TCLOCK, IVOLT, N6, NDX1, NDX2, N16,         M42.7804
  //C    1        NSMOUT, IOUTCS, NUMOUT, N18, NUMNVO, NUMBCO, NC, KSWTCH   M42.7805
  //C     READ (LUNIT9)  (BUS(I), I=1, NTOT),                               M42.7807
  //C    1               (BUS(I), I=J1, J2),                                M42.7808
  //C    2      ( BUS(I),I=J3,J4), (BUS(I), I=J5,J6 )                       M42.7809
  //C     write (*,*) ' INNR29.  Ready for LUNIT9 READ.  J2 =', J2          M42.7810
  read(lunit9, fem::unformatted), date1, tclock, ivolt, maxbus, ndx1,
    ndx2, n16, nsmout, ioutcs, numout, n18, numnvo, numbco, nc,
    kswtch;
  if (iprsup >= 3) {
    write(lunit6, star), " INNR29.  NTOT, MAXBUS, N16 =", ntot, maxbus, n16;
  }
  j2 = ntot + maxbus + n16;
  {
    read_loop rloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(i, 1, j2) {
      rloop, bus(i);
    }
  }
  if (iprsup >= 1) {
    write(lunit6, "(' INTEGERS READ FROM LUNIT9',5x,12i8)"), nc,
      nsmout, ioutcs, ivolt, ndx1, ndx2, n16, numout, n18, numnvo,
      numbco, nc;
  }
  if (ivolt != 1) {
    goto statement_4103;
  }
  {
    read_loop rloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(i, 2, ntot) {
      rloop, m13;
    }
  }
  goto statement_4104;
  statement_4103:
  if (numnvo > 0) {
    {
      read_loop rloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(i, 1, numnvo) {
        rloop, ibsout(i);
      }
    }
  }
  statement_4104:
  if (nc > 0) {
    {
      read_loop rloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(i, 1, nc) {
        rloop, ibrnch(i);
      }
      FEM_DO_SAFE(i, 1, nc) {
        rloop, jbrnch(i);
      }
    }
  }
  nstat = lstat(32);
  n1 = 1;
  n2 = nstat;
  i0 = 0;
  statement_35:
  i0++;
  if (i0 > npnerg) {
    goto statement_4108;
  }
  {
    read_loop rloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(j, n1, n2) {
      rloop, array(j);
    }
  }
  if (iprsup >= 6) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' READ  ARRAY(I) ,   BETWEEN LIMITS',2i5,/(1x,10e13.4))");
      wloop, n1, n2;
      FEM_DO_SAFE(j, n1, n2) {
        wloop, array(j);
      }
    }
  }
  n2end = n2;
  n1 += nstat;
  n2 += nstat;
  goto statement_35;
  statement_4108:
  basev = pu;
  n13 = 0;
  goto statement_1600;
  statement_6543:
  if (cmn.m4plot == 1) {
    emtspy(cmn);
  }
  icont = 0;
  n22 = 0;
  //C     READ INPUT CARD USING CIMAGE                                      M32.6834
  statement_16543:
  cimage(cmn);
  //C     NEXT CHECK FOR TRUNCATED STATISTICS MISC. DATA CARD:              M32.6849
  statement_1600:
  move0(itemp, ll264);
  read(abuff, "(40x,4a6)"), bus1, bus2, bus3, bus4;
  if (bus1 != text1) {
    goto statement_2620;
  }
  if (bus2 != text2) {
    goto statement_2620;
  }
  kbase = 29;
  moncar(2) = kbase;
  goto statement_9200;
  statement_2620:
  n13++;
  icont++;
  //CCCC  N11 = (ICONT-1) * 11 + 1                                          VAX.2990
  n11 = n22 + 1;
  if (n11 <= ll264) {
    goto statement_2630;
  }
  icont = 24;
  icnovf = 1;
  goto statement_4727;
  //C2630 N22 = ICONT * 11                                                  VAX.2994
  statement_2630:
  n22 += 11;
  if (kolbeg > 0) {
    goto statement_4723;
  }
  {
    read_loop rloop(abuff(1), "(i2,e12.3,11a6)");
    rloop, n8, c8;
    FEM_DO_SAFE(k, n11, n22) {
      rloop, aupper(k);
    }
  }
  if (icont > 1) {
    goto statement_4725;
  }
  ibropt = n8;
  basev = c8;
  goto statement_4725;
  statement_4723:
  nfrfld = 1;
  kolbeg = 1;
  freone(cmn, d11);
  ibropt = d11;
  freone(cmn, basev);
  nright = -1;
  nfrfld = 11;
  freone(cmn, d1);
  nright = 0;
  FEM_DO_SAFE(k, n11, n22) {
    aupper(k) = texta6(k);
  }
  statement_4725:
  if (aupper(n22) != text8) {
    goto statement_4727;
  }
  n22 = n22 - 1;
  write(kunit6, "('+  CONTINUED DICE REQUEST.  SEE LAST CARD: ')");
  goto statement_16543;
  statement_4727:
  vmaxsv = 0.0f;
  vminsv = fltinf;
  iall = 0;
  totmax = 0.0f;
  if (ibropt < 0) {
    goto statement_7612;
  }
  if (ibropt != 1) {
    goto statement_1725;
  }
  cmn.kill = 91;
  lstat(19) = 1725;
  goto statement_9200;
  statement_1725:
  kend = n22;
  statement_7611:
  ivolt = 0;
  mpr = 0;
  kfl = 0;
  goto statement_1615;
  statement_7612:
  kend = n22;
  goto statement_7611;
  statement_1615:
  if (ibropt == 0 || ibropt ==  - 1) {
    goto statement_7615;
  }
  if (basev == 0) {
    basev = 1.0f;
  }
  if (ibropt ==  - 2) {
    n16 = 3;
  }
  if (ibropt ==  - 3) {
    n16 = 5;
  }
  if (ibropt ==  - 4) {
    n16 = 7;
  }
  write(kunit6, format_4615), texnam(10), texnam(n16), texnam(n16 + 1);
  goto statement_2800;
  statement_7615:
  if (basev == 0.0f) {
    goto statement_7616;
  }
  if (basev == pu) {
    goto statement_7640;
  }
  n16 = 1;
  if (ibropt >= 0) {
    n17 = 9;
  }
  if (ibropt < 0) {
    n17 = 10;
  }
  write(kunit6, format_4615), texnam(n17), texnam(n16), texnam(n16 + 1);
  goto statement_2800;
  statement_7616:
  basev = pu;
  mpr = 1;
  FEM_DO_SAFE(k, 1, kend) {
    if (aupper(k) == blank) {
      goto statement_7625;
    }
    kfl = 1;
    goto statement_7630;
    statement_7625:;
  }
  statement_7630:
  if (kfl == 0) {
    goto statement_7635;
  }
  n16 = 1;
  if (ibropt >= 0) {
    n17 = 9;
  }
  if (ibropt < 0) {
    n17 = 10;
  }
  write(kunit6, format_4615), texnam(n17), texnam(n16), texnam(n16 + 1), basev;
  goto statement_7615;
  statement_7635:
  write(kunit6, "('+BLANK CARD TERMINATING STATISTICS OUTPUT CARDS.')");
  interp();
  kbase = 28;
  moncar(2) = kbase;
  if (n13 == 1) {
    goto statement_2800;
  }
  goto statement_180;
  statement_7640:
  if (mpr == 1) {
    goto statement_2800;
  }
  n17 = 9;
  if (ibropt < 0) {
    n17 = 10;
  }
  n16 = 1;
  write(kunit6, format_4615), texnam(n17), texnam(n16), texnam(n16 + 1);
  statement_2800:
  numsrt = 0;
  if (icnovf == 0) {
    goto statement_801;
  }
  write(lunit6,
    "(' OVERFLOW MAXIMUM LIMIT OF 24 CONT. CARDS, CURRENT REQUEST CARD IS IGNO"
    "RED. ')");
  icnovf = 0;
  statement_801:
  if (ibropt != 0) {
    n33 = kend / 2;
  }
  i = 0;
  FEM_DO_SAFE(k, 1, n22) {
    if (kbase != 28) {
      goto statement_290;
    }
    k9 = k * nstat;
    ibropt = 0;
    statement_210:
    kntout++;
    if (kntout > nstat) {
      goto statement_15071;
    }
    if (ibropt ==  - 1) {
      goto statement_230;
    }
    if (ivolt != 1) {
      goto statement_220;
    }
    if (kntout == 1) {
      goto statement_210;
    }
    if (kntout > ntot) {
      goto statement_15071;
    }
    bus1 = bus(kntout);
    goto statement_40;
    statement_220:
    if (kntout > numnvo) {
      goto statement_15071;
    }
    n1 = ibsout(kntout);
    bus1 = bus(n1);
    goto statement_40;
    statement_230:
    i++;
    n1 = ibrnch(i);
    n2 = jbrnch(i);
    bus1 = bus(n1);
    bus2 = bus(n2);
    goto statement_40;
    statement_290:
    if (ibropt == 0) {
      goto statement_7645;
    }
    if (k > n33) {
      goto statement_6543;
    }
    //CC    K1 = K * 2 + ( ICONT - 2 )                                        VAX.3002
    k1 = 2 * k - 1;
    k2 = k1 + 1;
    bus1 = aupper(k1);
    bus2 = aupper(k2);
    if (bus1 == blank && bus2 == blank) {
      goto statement_5070;
    }
    n1 = 0;
    n2 = 0;
    FEM_DO_SAFE(j, 1, j2) {
      if (n1 == 0 && bus(j) == bus1) {
        n1 = j;
      }
      if (n2 == 0 && bus(j) == bus2) {
        n2 = j;
      }
    }
    n3 = n1 * n2;
    if (n3 > 1) {
      goto statement_7835;
    }
    if (n3 == 0) {
      write(lunit6, format_817), bus1, bus2;
    }
    goto statement_5070;
    statement_7835:
    if (ibropt ==  - 2 || ibropt ==  - 4) {
      goto statement_1845;
    }
    FEM_DO_SAFE(i, 1, nv) {
      if (ibrnch(i) != n1 || jbrnch(i) != n2) {
        goto statement_1835;
      }
      goto statement_1855;
      statement_1835:;
    }
    goto statement_1852;
    statement_1845:
    FEM_DO_SAFE(i, n9, nc) {
      if (ibrnch(i) != n1 || jbrnch(i) != n2) {
        goto statement_1850;
      }
      goto statement_1855;
      statement_1850:;
    }
    statement_1852:
    write(lunit6, format_817), bus1, bus2;
    goto statement_5070;
    statement_1855:
    kntout = numnvo + i;
    goto statement_40;
    statement_7645:
    bus1 = aupper(k);
    if (bus1 == blank) {
      goto statement_5070;
    }
    FEM_DO_SAFE(i, 2, ntot) {
      if (bus1 == bus(i)) {
        goto statement_7660;
      }
    }
    write(lunit6,
      "(5x,'REQUEST FOR VOLTAGE OUTPUT OF NONEXISTENT NODE ''',a6,"
      "''' WILL BE IGNORED.')"),
      bus1;
    goto statement_5070;
    statement_7660:
    FEM_DO_SAFE(j, 1, numnvo) {
      if (ibsout(j) == i) {
        kntout = j;
      }
    }
    statement_40:
    vmax = std::abs(array(kntout));
    numsrt++;
    itemp(k) = kntout;
    ainsav = aincr;
    if (aincr < 0.f) {
      vmin = std::abs(array(kntout));
    }
    n2end = kntout + (npnerg - 1) * nstat;
    FEM_DOSTEP(j, kntout, n2end, nstat) {
      array(j) = std::abs(array(j));
      if (array(j) > vmax) {
        vmax = array(j);
      }
      if (aincr >= 0.f) {
        goto statement_45;
      }
      if (array(j) < vmin) {
        vmin = array(j);
      }
      statement_45:;
    }
    if (vmaxsv < vmax) {
      vmaxsv = vmax;
    }
    if (vminsv > vmin) {
      vminsv = vmin;
    }
    statement_145:
    if (aincr >= 0.f) {
      goto statement_46;
    }
    ainsav = vmax / vmin / (liminc - 1);
    basev = vmin;
    statement_46:
    move0(kount, liminc);
    move0(nsum, liminc);
    i1 = 0;
    sxi = 0.0f;
    sxisq = 0.0f;
    n88 = kntout;
    statement_59:
    i1++;
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' AT 5714.','      I1  NPNERG        ',12x,'BASEV',/,9x,2i8,"
        "e15.6)"),
        i1, npnerg, basev;
    }
    if (i1 > npnerg) {
      goto statement_3860;
    }
    if (iall == 0) {
      goto statement_5724;
    }
    totmax = 0.0f;
    if (k9 == 0) {
      goto statement_5730;
    }
    if (ibropt ==  - 1) {
      goto statement_5722;
    }
    FEM_DO_SAFE(l6, 1, numnvo) {
      n1 = l6 + (i1 - 1) * nstat;
      if (totmax < array(n1)) {
        totmax = array(n1);
      }
    }
    goto statement_5744;
    statement_5722:
    FEM_DO_SAFE(l7, numnvo + 1, nstat) {
      n1 = l7 + (i1 - 1) * nstat;
      if (totmax < array(n1)) {
        totmax = array(n1);
      }
    }
    goto statement_5744;
    statement_5730:
    FEM_DO_SAFE(kj, 1, n22) {
      i = itemp(kj);
      if (i == 0) {
        goto statement_5734;
      }
      n1 = i + (i1 - 1) * nstat;
      if (totmax < array(n1)) {
        totmax = array(n1);
      }
      statement_5734:;
    }
    goto statement_5744;
    statement_5724:
    totmax = array(n88);
    n88 += nstat;
    statement_5744:
    totmax = totmax / basev;
    xi = totmax;
    xisq = xi * xi;
    sxi += xi;
    sxisq += xisq;
    if (ainsav <= 0.0f) {
      goto statement_6543;
    }
    dex = totmax / ainsav + 1.0f;
    index = dex;
    if (index <= liminc) {
      goto statement_6020;
    }
    write(lunit6, format_3);
    goto statement_46901;
    statement_6020:
    kount(index)++;
    goto statement_59;
    statement_3860:
    interp();
    write(lunit6, "(/,/,/,1x)");
    write(lunit6, format_6434);
    if (iall == 0) {
      goto statement_6464;
    }
    write(lunit6, "(1x,13('SUMMARY   '))");
    write(lunit6, format_6434);
    if (ibropt != 0) {
      goto statement_6439;
    }
    write(lunit6,
      "(' A DISTRIBUTION OF PEAK OVERVOLTAGES AMONG ALL OUTPUT NODES ON THE LA"
      "ST CARD HAVING THE SAME BASE VOLTAGE FOLLOWS.   THIS',/,"
      "' STATISTICAL DISTRIBUTION IS FOR THE MAXIMUM OF THE PEAKS AT ALL OF TH"
      "ESE OUTPUT NODES HAVING BASE VOLTAGE =',e14.5)"),
      basev;
    if (k9 != 0) {
      ibropt = -1;
    }
    goto statement_68;
    statement_6439:
    write(lunit6,
      "(' A DISTRIBUTION OF PEAK VALUES AMONG ALL OUTPUT BRANCHES ON THE LAST "
      "CARD HAVING THE SAME BASE VALUE FOLLOWS.   THIS')");
    if (ibropt ==  - 1) {
      n16 = 1;
    }
    if (ibropt ==  - 2) {
      n16 = 3;
    }
    if (ibropt ==  - 3) {
      n16 = 5;
    }
    if (ibropt ==  - 4) {
      n16 = 7;
    }
    write(lunit6,
      "(' STATISTICAL DISTRIBUTION IS FOR THE MAXIMUM',"
      "' OF THE PEAKS AT ALL OF THESE OUTPUT',' BRANCHES HAVING BASE ',a6,a1,"
      "' =',e14.5)"),
      texnam(n16), texnam(n16 + 1), basev;
    goto statement_68;
    statement_6464:
    if (ibropt != 0) {
      goto statement_2167;
    }
    write(lunit6,
      "(' STATISTICAL DISTRIBUTION OF PEAK VOLTAGE AT NODE  ''',a6,''' .',5x,"
      "'BASE VOLTAGE FOR PER-UNIT PRINTOUT =',e14.5)"),
      bus1, basev;
    goto statement_68;
    statement_2167:
    if (ibropt ==  - 1) {
      n16 = 1;
    }
    if (ibropt ==  - 2) {
      n16 = 3;
    }
    if (ibropt ==  - 3) {
      n16 = 5;
    }
    if (ibropt ==  - 4) {
      n16 = 7;
    }
    write(lunit6,
      "(' STATISTICAL DISTRIBUTION OF PEAK ',a6,a1,' AT BRANCH  \"',a6,"
      "'\"  TO  \"',a6,'\".    BASE ',a6,a1,' FOR PER-UNIT OUTPUT =',e14.5)"),
      texnam(n16), texnam(n16 + 1), bus1, bus2, texnam(n16), texnam(n16 + 1),
      basev;
    statement_68:
    key = 0;
    if (iprsup >= 1) {
      write(lunit6, "(/,' AT 69   ',6e17.5)"), sxi, total, sxisq,
        basev, vmax, ainsav;
    }
    term2 = sxi * sxi;
    term1 = total * sxisq;
    xmean1 = sxi / total;
    if (total == 1.0f) {
      goto statement_100;
    }
    xvar1 = (term1 - term2) / ((total) * (total - 1.0f));
    if (xvar1 < 0.0f) {
      xvar1 = 0.0f;
    }
    goto statement_102;
    statement_100:
    key = 1;
    xvar1 = 0.0f;
    statement_102:
    stdev1 = sqrtz(xvar1);
    sxifi = 0.0f;
    sx2fi = 0.0f;
    is = 0;
    txmax = vmax / basev;
    xint = txmax / ainsav + 1.0f;
    maxint = xint;
    if (aincr < 0.0f) {
      goto statement_5010;
    }
    if (maxint <= liminc) {
      goto statement_5010;
    }
    write(lunit6, format_3);
    goto statement_46901;
    statement_5010:
    if (ibropt ==  - 1) {
      n16 = 1;
    }
    if (ibropt ==  - 2) {
      n16 = 3;
    }
    if (ibropt ==  - 3) {
      n16 = 5;
    }
    if (ibropt ==  - 4) {
      n16 = 7;
    }
    write(lunit6,
      "(2x,'INTERVAL',13x,a6,a1,10x,a6,a1,' IN',6x,'FREQUENCY',5x,"
      "'CUMULATIVE',12x,'PER CENT')"),
      texnam(n16), texnam(n16 + 1), texnam(n16), texnam(n16 + 1);
    write(lunit6,
      "(4x,'NUMBER',9x,'IN PER UNIT',6x,'PHYSICAL UNITS',6x,'(DENSITY)',6x,"
      "'FREQUENCY',5x,'.GE. CURRENT VALUE')");
    FEM_DO_SAFE(m, 1, maxint) {
      mm = m - 1;
      if (m == 1) {
        mm = 1;
      }
      nsum(m) = nsum(mm) + kount(m);
      r = ainsav * (m - 1);
      xxi = r;
      fi = kount(m);
      xifi = xxi * fi;
      x2fi = xxi * xxi * fi;
      sxifi += xifi;
      sx2fi += x2fi;
      if (iprsup >= 1) {
        write(lunit6, "(/,' AT 5013',3e17.5)"), sxifi, total, sx2fi;
      }
      r = r * basev;
      percen = ((npnerg - nsum(m)) / total) * 100;
      if (nsum(m) > 0) {
        goto statement_5011;
      }
      is = 1;
      m1 = m;
      xi1 = xxi;
      r1 = r;
      kont1 = kount(m);
      nsum1 = nsum(m);
      prcen1 = percen;
      goto statement_5050;
      statement_5011:
      if (is > 0) {
        write(lunit6, format_5020), m1, xi1, r1, kont1, nsum1, prcen1;
      }
      is = 0;
      if (nsum(m) == npnerg) {
        goto statement_5015;
      }
      write(lunit6, format_5020), m, xxi, r, kount(m), nsum(m), percen;
      goto statement_5050;
      statement_5015:
      mend = m;
      goto statement_5055;
      statement_5050:;
    }
    statement_5055:
    write(lunit6, format_5020), mend, xxi, r, kount(mend), nsum(mend), percen;
    if (iprsup >= 1) {
      write(lunit6, "(/,' AT 5014',3e17.5)"), sxifi, total, sx2fi;
    }
    xmean = sxifi / total;
    if (key != 0) {
      goto statement_5066;
    }
    xvar = ((total * sx2fi) - (sxifi * sxifi)) / (total * (total - 1.0f));
    if (xvar < 0.0f) {
      xvar = 0.0f;
    }
    stddev = sqrtz(xvar);
    write(lunit6,
      "(/,' DISTRIBUTION PARAMETERS FOR THE ABOVE DATA.   GROUPED DATA   UNGRO"
      "UPED DATA',/,38x,'MEAN = ',3x,f10.7,6x,f10.7,/,34x,'VARIANCE = ',3x,"
      "f10.7,6x,f10.7,/,29x,'STD DEVIATION = ',3x,f10.7,6x,f10.7)"),
      xmean, xmean1, xvar, xvar1, stddev, stdev1;
    goto statement_46901;
    statement_5066:
    write(lunit6,
      "(/,' THE NUMBER OF ENERGIZATIONS FOR THIS STATISTICS RUN IS 1.  VARIANC"
      "E AND STANDARD DEVIATION CANNOT BE COMPUTED.')");
    statement_46901:
    move0(kount, liminc);
    move0(nsum, liminc);
    if (k9 == 0) {
      goto statement_15070;
    }
    if (iall == 0) {
      goto statement_210;
    }
    iall = 0;
    if (kntout >= nstat) {
      goto statement_1840;
    }
    goto statement_210;
    statement_15070:
    if (iall == 1) {
      goto statement_1840;
    }
    statement_5070:
    if (k == n22 && ibropt == 0) {
      goto statement_5071;
    }
    if (k == n33 && ibropt < 0) {
      goto statement_5071;
    }
    goto statement_840;
    statement_15071:
    if (ibropt ==  - 1) {
      goto statement_5071;
    }
    kntout = kntout - 1;
    if (numsrt != 1) {
      goto statement_15073;
    }
    numsrt = 0;
    goto statement_210;
    statement_15073:
    numsrt = 0;
    goto statement_15072;
    statement_5071:
    if (numsrt == 1) {
      goto statement_1840;
    }
    statement_15072:
    iall = 1;
    vmax = vmaxsv;
    vmin = vminsv;
    goto statement_145;
    statement_840:;
  }
  statement_1840:
  write(lunit6, "(/,1x)");
  if (kbase != 28) {
    goto statement_6543;
  }
  statement_180:
  if (nenerg < 0) {
    goto statement_9200;
  }
  statement_399:
  write(lunit6, "(/,/,/,49x,' SAMPLE CURVE SYMBOLS---A,B,C')");
  write(lunit6, "(49x,' THEORETICAL CURVE SYMBOL---D')");
  write(lunit6, "(49x,' COMMON CURVE SYMBOL--------*')");
  nsw = 0;
  nssw = 0;
  cmn.io.rewind(lunit3);
  if (iprsup >= 1) {
    write(6, "(' ISW, KSWTCH, LSWTCH, NOT =',4i6)"), isw, kswtch, lswtch, ntot;
  }
  if (isw == 4444) {
    {
      read_loop rloop(cmn, lunit3, fem::unformatted);
      FEM_DO_SAFE(i, 1, ntot) {
        rloop, bus(i);
      }
    }
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(' SWITCH VECTORS READ FROM  ''LUNIT3'' .',/,"
      "'     ROW   BUS1     BUS2',11x,'AKEY',10x,'TSTAT',13x,'DT',2x,"
      "'KDEPSW')");
  }
  FEM_DO_SAFE(i, 1, kswtch) {
    j = lswtch + i;
    read(lunit3, fem::unformatted), kmswit(i), kmswit(j), akey(i),
      tstat(i), topen(j), kdepsw(i);
    if (iprsup >= 1) {
      write(lunit6, "(1x,3i8,3e15.6,i8)"), i, kmswit(i), kmswit(j),
        akey(i), tstat(i), topen(j), kdepsw(i);
    }
  }
  read(lunit3, fem::unformatted), kloaep;
  statement_410:
  nsw++;
  if (nsw > kswtch) {
    goto statement_415;
  }
  if (std::abs(akey(nsw)) != 44444.f) {
    goto statement_410;
  }
  nssw++;
  if (kloaep == 0) {
    goto statement_412;
  }
  if (kdepsw(nsw) == 0) {
    goto statement_411;
  }
  tclose(nssw) = tstat(nsw) + tstat(kloaep);
  n = kdepsw(nsw);
  vartot = fem::pow2(topen(nsw + lswtch)) + fem::pow2(topen(n + lswtch));
  statement_1411:
  if (kdepsw(n) == 0) {
    goto statement_414;
  }
  tclose(nssw) += tstat(n);
  n = kdepsw(n);
  vartot += fem::pow2(topen(n + lswtch));
  goto statement_1411;
  statement_411:
  tclose(nssw) = tstat(kloaep);
  goto statement_414;
  statement_412:
  if (kdepsw(nsw) == 0) {
    goto statement_413;
  }
  n = kdepsw(nsw);
  tclose(nssw) = tstat(nsw) + tstat(n);
  vartot = fem::pow2(topen(nsw + lswtch)) + fem::pow2(topen(n + lswtch));
  statement_1412:
  if (kdepsw(n) == 0) {
    goto statement_414;
  }
  n = kdepsw(n);
  tclose(nssw) += tstat(n);
  vartot += fem::pow2(topen(n + lswtch));
  goto statement_1412;
  statement_413:
  tclose(nssw) = tstat(nsw);
  statement_414:
  topen(nssw + lswtch) = topen(nsw + lswtch);
  if (kdepsw(nsw) != 0) {
    topen(nssw + lswtch) = sqrtz(vartot);
  }
  kmswit(nssw) = kmswit(nsw);
  kmswit(nssw + lswtch) = kmswit(nsw + lswtch);
  kpoint(nssw) = nsw;
  goto statement_410;
  statement_415:
  FEM_DO_SAFE(i, 1, nssw) {
    tstat(i) = tclose(i);
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, "(' TSTAT AT 1710'(1x,6e15.6))");
      FEM_DO_SAFE(j, 1, nssw) {
        wloop, tstat(j);
      }
    }
  }
  n1 = 0;
  n9 = nenerg * kswtch;
  FEM_DO_SAFE(i, 1, nenerg) {
    n5 = n1 + 1;
    n6 = n1 + kswtch;
    {
      read_loop rloop(cmn, lunit3, fem::unformatted);
      rloop, bias;
      FEM_DO_SAFE(i1, n5, n6) {
        rloop, array(i1);
      }
    }
    m5 = n9 + n5;
    m6 = n9 + n6;
    {
      read_loop rloop(cmn, lunit3, fem::unformatted);
      rloop, bias;
      FEM_DO_SAFE(i1, m5, m6) {
        rloop, array(i1);
      }
    }
    ranoff = bias;
    if (itest == 1) {
      ranoff = 0.0f;
    }
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, lunit6,
          "(/,' READ LOGICAL 3.  KSWTCH  NENERG      N1',11x,'BIAS',/,16x,3i8,"
          "e15.5,/(1x,8e16.6))");
        wloop, kswtch, nenerg, n1, bias;
        FEM_DO_SAFE(i1, n5, n6) {
          wloop, array(i1);
        }
        FEM_DO_SAFE(i1, m5, m6) {
          wloop, array(i1);
        }
      }
    }
    FEM_DO_SAFE(j, 1, nssw) {
      k = kpoint(j);
      if (itest == 0 || itest == 1) {
        goto statement_2417;
      }
      if (itest > 2) {
        goto statement_1417;
      }
      if (akey(k) ==  + 44444.f) {
        goto statement_2410;
      }
      ranoff = 0.0f;
      goto statement_2417;
      statement_2410:
      ranoff = bias;
      goto statement_2417;
      statement_1417:
      if (akey(k) ==  - 44444.f) {
        goto statement_2410;
      }
      ranoff = 0.0f;
      statement_2417:
      n7 = n1 + k;
      if (akey(k) ==  - 44444.f) {
        n7 = n1 + k + n9;
      }
      n8 = n1 + j;
      array(n8) = array(n7) - ranoff;
    }
    n1 += nssw;
  }
  sqrt3 = 3.0f;
  sqrt3 = sqrtz(sqrt3);
  i = 1;
  statement_419:
  move0(kount1, in25);
  move0(kount2, in25);
  move0(kount3, in25);
  sdt = std::abs(topen(i + lswtch));
  deltsc = sdt / 3.0f;
  fclosc = nenerg * .13242f / 30;
  deltsu = sqrt3 * sdt / 12.0f;
  fclosu = nenerg / 720.0f;
  i2 = i + 1;
  i3 = i + 2;
  if (i2 > nssw) {
    goto statement_430;
  }
  if (topen(i2 + lswtch) != topen(i + lswtch)) {
    goto statement_430;
  }
  if (i3 > nssw) {
    goto statement_530;
  }
  if (topen(i3 + lswtch) != topen(i + lswtch)) {
    goto statement_530;
  }
  goto statement_630;
  statement_430:
  k1 = kmswit(i);
  k2 = kmswit(i + lswtch);
  bus1 = bus(k1);
  bus2 = bus(k2);
  write(lunit6, "(/,/,/,6x,' SWITCH ''',a6,'''  TO  ''',a6,'''')"), bus1, bus2;
  if (idist > 0) {
    goto statement_436;
  }
  if (topen(i + lswtch) < 0.0f) {
    goto statement_436;
  }
  write(lunit6, format_434), fclosc;
  goto statement_440;
  statement_436:
  write(lunit6, format_434), fclosu;
  statement_440:
  write(lunit6, "(17x,' COLUMNS')");
  write(lunit6, "(10x,i1,5(3x,i2))"), in5, in10, in15, in20, in25, in30;
  write(lunit6, "(5x,'+----+----+----+----+----+----+')");
  goto statement_660;
  statement_530:
  k1 = kmswit(i);
  k2 = kmswit(i + lswtch);
  k3 = kmswit(i2);
  k4 = kmswit(i2 + lswtch);
  bus1 = bus(k1);
  bus2 = bus(k2);
  bus3 = bus(k3);
  bus4 = bus(k4);
  write(lunit6,
    "(/,/,/,6x,2(' SWITCH ''',a6,'''  TO  ''',a6,'''',12x))"), bus1,
    bus2, bus3, bus4;
  if (idist > 0) {
    goto statement_536;
  }
  if (topen(i + lswtch) < 0.0f) {
    goto statement_536;
  }
  write(lunit6, format_534), fclosc, fclosc;
  goto statement_540;
  statement_536:
  write(lunit6, format_534), fclosu, fclosu;
  statement_540:
  write(lunit6, "(17x,' COLUMNS',36x,' COLUMNS')");
  write(lunit6, "(10x,i1,5(3x,i2),16x,i1,5(3x,i2))"), in5, in10,
    in15, in20, in25, in30, in5, in10, in15, in20, in25, in30;
  write(lunit6, "(5x,2('+----+----+----+----+----+----+',11x))");
  goto statement_660;
  statement_630:
  k1 = kmswit(i);
  k2 = kmswit(i + lswtch);
  k3 = kmswit(i2);
  k4 = kmswit(i2 + lswtch);
  k5 = kmswit(i3);
  k6 = kmswit(i3 + lswtch);
  bus1 = bus(k1);
  bus2 = bus(k2);
  bus3 = bus(k3);
  bus4 = bus(k4);
  bus5 = bus(k5);
  bus6 = bus(k6);
  write(lunit6,
    "(/,/,/,6x,' SWITCH ''',a6,'''  TO  ''',a6,'''',2(12x,' SWITCH ''',a6,"
    "'''  TO  ''',a6,''''))"),
    bus1, bus2, bus3, bus4, bus5, bus6;
  if (idist > 0) {
    goto statement_636;
  }
  if (topen(i + lswtch) < 0.0f) {
    goto statement_636;
  }
  write(lunit6, format_634), fclosc, fclosc, fclosc;
  goto statement_640;
  statement_636:
  write(lunit6, format_634), fclosu, fclosu, fclosu;
  statement_640:
  write(lunit6, "(17x,' COLUMNS',2(36x,' COLUMNS'))");
  write(lunit6, "(10x,i1,5(3x,i2),2(16x,i1,5(3x,i2)))"), in5, in10,
    in15, in20, in25, in30, in5, in10, in15, in20, in25, in30, in5,
    in10, in15, in20, in25, in30;
  write(lunit6, "(5x,3('+----+----+----+----+----+----+',11x))");
  statement_660:
  FEM_DO_SAFE(n, 1, nenerg) {
    L = (n - 1) * nssw;
    n3 = i + L;
    twdep = array(n3) - tstat(i);
    if (kdepsw(i) == 0) {
      goto statement_1660;
    }
    m = kdepsw(i);
    nn3 = m + L;
    twdep = twdep - array(nn3) + tstat(m);
    statement_1660:
    if (idist > 0) {
      goto statement_662;
    }
    if (topen(i + lswtch) < 0.0f) {
      goto statement_662;
    }
    l1 = 13 + (twdep + deltsc / 2.f) / deltsc;
    kount1(l1)++;
    if (iprsup >= 1) {
      write(lunit6, format_661), n3, array(n3), l1, kount1(l1);
    }
    goto statement_665;
    statement_662:
    l1 = 13 + (twdep + deltsu / 2.f) / deltsu;
    kount1(l1)++;
    if (iprsup >= 1) {
      write(lunit6, format_661), n3, array(n3), l1, kount1(l1);
    }
    statement_665:;
  }
  if (i2 > nssw) {
    goto statement_700;
  }
  if (topen(i2 + lswtch) != topen(i + lswtch)) {
    goto statement_700;
  }
  FEM_DO_SAFE(n, 1, nenerg) {
    L = (n - 1) * nssw;
    n4 = i2 + L;
    twdep = array(n4) - tstat(i2);
    if (kdepsw(i2) == 0) {
      goto statement_1666;
    }
    m = kdepsw(i2);
    nn4 = m + L;
    twdep = twdep - array(nn4) + tstat(m);
    statement_1666:
    if (idist > 0) {
      goto statement_668;
    }
    if (topen(i2 + lswtch) < 0.0f) {
      goto statement_668;
    }
    l2 = 13 + (twdep + deltsc / 2.f) / deltsc;
    kount2(l2)++;
    goto statement_669;
    statement_668:
    l2 = 13 + (twdep + deltsu / 2.f) / deltsu;
    kount2(l2)++;
    statement_669:
    if (iprsup >= 1) {
      write(lunit6,
        "(' AT 1669 OF SUBR29,N4, ARRAY(N4), L2 AND KOUNT2(L2) ARE',10x,i10,"
        "e15.6,2i10)"),
        n4, array(n4), l2, kount2(l2);
    }
  }
  if (iprsup >= 1) {
    write(lunit6, "(' I, I2, I3 AND DT ARE',10x,3i5,3e15.6)"), i, i2,
      i3, topen(i + lswtch), topen(i2 + lswtch), topen(i3 + lswtch);
  }
  if (i3 > nssw) {
    goto statement_700;
  }
  if (topen(i3 + lswtch) != topen(i + lswtch)) {
    goto statement_700;
  }
  FEM_DO_SAFE(n, 1, nenerg) {
    L = (n - 1) * nssw;
    n5 = i3 + L;
    twdep = array(n5) - tstat(i3);
    if (kdepsw(i3) == 0) {
      goto statement_1671;
    }
    m = kdepsw(i3);
    nn5 = m + L;
    twdep = twdep - array(nn5) + tstat(m);
    statement_1671:
    if (idist > 0) {
      goto statement_672;
    }
    if (topen(i3 + lswtch) < 0.0f) {
      goto statement_672;
    }
    l3 = 13 + (twdep + deltsc / 2.f) / deltsc;
    kount3(l3)++;
    goto statement_673;
    statement_672:
    l3 = 13 + (twdep + deltsu / 2.f) / deltsu;
    kount3(l3)++;
    statement_673:
    if (iprsup >= 1) {
      write(lunit6,
        "(' AT 674 OF SUBR29, N5, ARRAY(N5), L3 AND KOUNT3(L3) ARE',10x,i10,"
        "e15.6,2i10)"),
        n5, array(n5), l3, kount3(l3);
    }
  }
  statement_700:
  kurve1 = 1;
  kurve2 = 2;
  kurve3 = 3;
  kurve4 = 4;
  n13 = -5678;
  plotng(cmn, llm1, n13);
  FEM_DO_SAFE(line, 1, 25) {
    kolum1 = 0;
    kolum2 = 0;
    kolum3 = 0;
    if (idist > 0) {
      goto statement_753;
    }
    if (topen(i + lswtch) < 0.0f) {
      goto statement_753;
    }
    kolum1 = 5 + kount1(line) / fclosc + 0.5f;
    kolnum = 5 + normal(line);
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' AT 751, LINE, KOUNT1 AND NORMAL ARE',10x,3i10)"), line,
        kount1(line), normal(line);
    }
    goto statement_770;
    statement_753:
    kolum1 = 5 + kount1(line) / fclosu + 0.5f;
    if (iprsup >= 1) {
      write(lunit6, "(' LINE AND KOUNT1',10x,2i10)"), line, kount1(line);
    }
    kolnum = 35;
    goto statement_770;
    statement_754:
    if (idist > 0) {
      goto statement_758;
    }
    if (topen(i + lswtch) < 0.0f) {
      goto statement_758;
    }
    kolum2 = 47 + kount2(line) / fclosc + 0.5f;
    kolnum = 47 + normal(line);
    goto statement_772;
    statement_758:
    kolum2 = 47 + kount2(line) / fclosu + 0.5f;
    if (iprsup >= 1) {
      write(lunit6, "(' LINE AND KOUNT2',10x,2i10)"), line, kount2(line);
    }
    kolnum = 77;
    goto statement_772;
    statement_759:
    if (idist > 0) {
      goto statement_763;
    }
    if (topen(i + lswtch) < 0.0f) {
      goto statement_763;
    }
    kolum3 = 89 + kount3(line) / fclosc + 0.5f;
    kolnum = 89 + normal(line);
    goto statement_774;
    statement_763:
    kolum3 = 89 + kount3(line) / fclosu + 0.5f;
    if (iprsup >= 1) {
      write(lunit6, "(' LINE AND KOUNT3',10x,2i10)"), line, kount3(line);
    }
    kolnum = 119;
    goto statement_774;
    statement_770:
    plotng(cmn, kurve4, kolnum);
    plotng(cmn, kurve1, kolum1);
    if (topen(i2 + lswtch) != topen(i + lswtch)) {
      goto statement_779;
    }
    goto statement_754;
    statement_772:
    plotng(cmn, kurve4, kolnum);
    plotng(cmn, kurve2, kolum2);
    if (topen(i3 + lswtch) != topen(i + lswtch)) {
      goto statement_779;
    }
    goto statement_759;
    statement_774:
    plotng(cmn, kurve4, kolnum);
    plotng(cmn, kurve3, kolum3);
    statement_779:
    if (line != 13) {
      goto statement_705;
    }
    tolmat = tstat(i);
    n13 = -4321;
    plotng(cmn, kurve1, n13);
    if (i2 > nssw) {
      goto statement_705;
    }
    if (topen(i2 + lswtch) != topen(i + lswtch)) {
      goto statement_705;
    }
    tolmat = tstat(i2);
    plotng(cmn, kurve2, n13);
    if (i3 > nssw) {
      goto statement_705;
    }
    if (topen(i3 + lswtch) != topen(i + lswtch)) {
      goto statement_705;
    }
    tolmat = tstat(i3);
    plotng(cmn, kurve3, n13);
    statement_705:
    plotng(cmn, jdummy, llm1);
  }
  if (i2 > nssw) {
    goto statement_799;
  }
  if (topen(i2 + lswtch) != topen(i + lswtch)) {
    goto statement_799;
  }
  if (i3 > nssw) {
    goto statement_809;
  }
  if (topen(i3 + lswtch) != topen(i + lswtch)) {
    goto statement_809;
  }
  goto statement_813;
  statement_799:
  write(lunit6, "(3x,' TIME')");
  if (idist > 0) {
    goto statement_821;
  }
  if (topen(i + lswtch) < 0.0f) {
    goto statement_821;
  }
  write(lunit6, format_825), deltsc;
  goto statement_826;
  statement_821:
  write(lunit6, format_825), deltsu;
  statement_826:
  write(lunit6, "(2x,' SEC/LINE')");
  goto statement_991;
  statement_809:
  write(lunit6, "(3x,' TIME',37x,' TIME')");
  if (idist > 0) {
    goto statement_831;
  }
  if (topen(i + lswtch) < 0.0f) {
    goto statement_831;
  }
  write(lunit6, format_835), deltsc, deltsc;
  goto statement_836;
  statement_831:
  write(lunit6, format_835), deltsu, deltsu;
  statement_836:
  write(lunit6, "(2x,' SEC/LINE',34x,' SEC/LINE')");
  goto statement_992;
  statement_813:
  write(lunit6, "(3x,' TIME',2(37x,' TIME'))");
  if (idist > 0) {
    goto statement_841;
  }
  if (topen(i + lswtch) < 0.0f) {
    goto statement_841;
  }
  write(lunit6, format_845), deltsc, deltsc, deltsc;
  goto statement_848;
  statement_841:
  write(lunit6, format_845), deltsu, deltsu, deltsu;
  statement_848:
  write(lunit6, "(2x,' SEC/LINE',2(34x,' SEC/LINE'))");
  i += 3;
  goto statement_1000;
  statement_991:
  i++;
  goto statement_1000;
  statement_992:
  i += 2;
  statement_1000:
  if (i <= nssw) {
    goto statement_419;
  }
  nm1 = nenerg - 1;
  FEM_DO_SAFE(i, 1, nssw) {
    if (nm1 <= 0) {
      goto statement_1905;
    }
    FEM_DO_SAFE(j, 1, nm1) {
      m = j * nssw + i;
      mm1 = m - nssw;
      if (array(m) >= array(mm1)) {
        goto statement_905;
      }
      temp = array(m);
      FEM_DO_SAFE(jn, 1, j) {
        jn1 = jn * nssw;
        L = m - jn1;
        n6 = L + nssw;
        if (temp >= array(L)) {
          goto statement_904;
        }
        array(n6) = array(L);
      }
      array(i) = temp;
      goto statement_905;
      statement_904:
      array(n6) = temp;
      statement_905:;
    }
    statement_1905:
    if (idist == 0) {
      goto statement_900;
    }
    statement_901:
    abc = std::abs(topen(i + lswtch)) * sqrt3;
    b = tstat(i) - abc;
    c = tstat(i) + abc;
    goto statement_902;
    statement_900:
    if (topen(i + lswtch) < 0.0f) {
      goto statement_901;
    }
    statement_902:
    dn = 0.0f;
    fs = 0.0f;
    il = 1;
    statement_906:
    if (il <= nm1) {
      goto statement_1906;
    }
    jb = i;
    goto statement_908;
    statement_1906:
    FEM_DO_SAFE(k, il, nm1) {
      j = k;
      jb = j * nssw + i;
      ja = jb - nssw;
      if (array(ja) != array(jb)) {
        goto statement_909;
      }
    }
    statement_908:
    j = nenerg;
    ja = jb;
    statement_909:
    il = j + 1;
    fi = fs;
    fs = j;
    fs = fs / total;
    if (idist > 0) {
      goto statement_917;
    }
    if (topen(i + lswtch) < 0.0f) {
      goto statement_917;
    }
    if (topen(i + lswtch) > 0.0f) {
      goto statement_912;
    }
    goto statement_929;
    statement_912:
    z = (array(ja) - tstat(i)) / topen(i + lswtch);
    az = std::abs(z);
    t = 1.0f / (1.0f + .2316419f * az);
    d = .3989423f * expz(-z * z / 2.0f);
    y = 1.0f - d * t * ((((1.330274f * t - 1.821256f) * t +
      1.781478f) * t - .3565638f) * t + .3193815f);
    if (z >= 0.0f) {
      goto statement_927;
    }
    y = 1.0f - y;
    goto statement_927;
    statement_917:
    if (array(ja) > b) {
      goto statement_923;
    }
    y = 0.0f;
    goto statement_927;
    statement_923:
    if (array(ja) <= c) {
      goto statement_925;
    }
    y = 1.0f;
    goto statement_927;
    statement_925:
    y = (array(ja) - b) / (2 * abc);
    statement_927:
    ei = std::abs(y - fi);
    es = std::abs(y - fs);
    if (dn < es) {
      dn = es;
    }
    switch (fem::if_arithmetic(il - nenerg)) {
      case -1: goto statement_906;
      case  0: goto statement_908;
      default: goto statement_928;
    }
    statement_928:
    z = dn * sqrtz(total);
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' AT 1927, AZ, Y, ES, DN AND Z ARE',10x,5e15.6)"), az, y,
        es, dn, z;
    }
    if (z > 0.27f) {
      goto statement_2;
    }
    prob = 0.0f;
    goto statement_950;
    statement_2:
    if (z >= 1.0f) {
      goto statement_6;
    }
    c1 = expz(-1.233701f / fem::pow2(z));
    n1 = alog1z(c1) * 32.f;
    if (-n1 < infexp) {
      goto statement_1928;
    }
    c8 = 0.0f;
    goto statement_5;
    statement_1928:
    c2 = c1 * c1;
    c4 = c2 * c2;
    c8 = c4 * c4;
    statement_5:
    prob = (2.506628f / z) * c1 * (1.0f + c8 * (1.0f + c8 * c8));
    goto statement_950;
    statement_6:
    if (z < 3.1f) {
      goto statement_8;
    }
    prob = 1.0f;
    goto statement_950;
    statement_8:
    c1 = expz(-2.0f * z * z);
    c2 = c1 * c1;
    c4 = c2 * c2;
    c8 = c4 * c4;
    prob = 1.0f - 2.0f * (c1 - c4 + c8 * (c1 - c8));
    statement_950:
    prob = 1.0f - prob;
    write(lunit6, "(75x,' KOLMOGOROV-SMIRNOV TEST RESULT',10x,e15.6)"), prob;
    statement_929:;
  }
  statement_9200:
  if (isw == 4444) {
    kbase = 28;
  }
  if (isw == 4444) {
    moncar(2) = kbase;
  }
  lstat(18) = 29;
  lastov = nchain;
  nchain = 51;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct fltdat_save
{
  fem::str<8> chara;
  fem::str<8> charb;
  fem::str<8> charc;
  fem::str<8> charq;
  int kblank; 
  int kfill;  
  int korig;  

  fltdat_save() :
    chara(fem::char0),
    charb(fem::char0),
    charc(fem::char0),
    charq(fem::char0),
    kblank(fem::int0),
    kfill(fem::int0),
    korig(fem::int0)
  {}
};

void fltdat(
  common& cmn,
  arr_ref<double, 2> array,
  arr_ref<double, 2> arrsav,
  arr_ref<double> soln,
  arr_ref<double> rhs,
  arr_ref<double, 2> ymat,
  arr_ref<int, 2> kspars,
  int const& maxsq,
  int const& nmax2,
  int const& nmax,
  int const& lspars) try
{
  FEM_CMN_SVE(fltdat);
  array(dimension(maxsq, maxsq));
  arrsav(dimension(maxsq, maxsq));
  soln(dimension(maxsq));
  rhs(dimension(maxsq));
  ymat(dimension(nmax, nmax2));
  kspars(dimension(lspars, lspars));
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& blank = cmn.blank;
  const auto& abuff = cmn.abuff;
  double& epsiln = cmn.epsiln;
  double& fltinf = cmn.fltinf;
  auto& lunit1 = cmn.lunit1;
  auto& lunit7 = cmn.lunit7;
  auto& lstat = cmn.lstat;
  const auto& iprsov = cmn.iprsov;
  int& ipunch = cmn.ipunch;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& ntot = cmn.ntot;
  //
  fem::str<8>& chara = sve.chara;
  fem::str<8>& charb = sve.charb;
  fem::str<8>& charc = sve.charc;
  fem::str<8>& charq = sve.charq;
  auto& kblank = sve.kblank;
  auto& kfill = sve.kfill;
  auto& korig = sve.korig;
#if 0
  if (is_called_first_time) {
    korig = "X";
    kfill = "F";
    kblank = " ";
    chara = "A     ";
    charb = "B     ";
    charc = "C     ";
    charq = "?     ";
  }
  int ll35 = fem::int0;
  double drive = fem::double0;
  int limit = fem::int0;
  int loop = fem::int0;
  arr_1d<35, int> negate(fem::fill0);
  int n13 = fem::int0;
  int nitmax = fem::int0;
  double percen = fem::double0;
  int ipncom = fem::int0;
  auto& lunit6 = cmn.lunit6;
  double scale = fem::double0;
  int k = fem::int0;
  int m = fem::int0;
  double d6 = fem::double0;
  int ntot2 = fem::int0;
  int ntotsq = fem::int0;
  int ntotp1 = fem::int0;
  int ntotm1 = fem::int0;
  int maxcol = fem::int0;
  int j = fem::int0;
  int n12 = fem::int0;
  int L = fem::int0;
  arr_1d<35, fem::str<8> > texta(fem::fill0);
  arr_1d<35, fem::str<8> > textb(fem::fill0);
  arr_1d<35, double> rthev(fem::fill0);
  arr_1d<35, double> xthev(fem::fill0);
  arr_1d<6, fem::str<8> > text1(fem::fill0);
  arr_1d<6, fem::str<8> > text2(fem::fill0);
  int n4 = fem::int0;
  arr_1d<35, int> ichara(fem::fill0);
  arr_1d<35, int> icharb(fem::fill0);
  arr_1d<35, double> admit(fem::fill0);
  int n7 = fem::int0;
  int kk = fem::int0;
  int n8 = fem::int0;
  int i = fem::int0;
  int niter = fem::int0;
  double d13 = fem::double0;
  int n2 = fem::int0;
  int n6 = fem::int0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  int n18 = fem::int0;
  double d2 = fem::double0;
  arr_1d<35, double> output(fem::fill0);
  double d7 = fem::double0;
  arr_1d<35, double> rzero(fem::fill0);
  arr_1d<35, double> xzero(fem::fill0);
  int n5 = fem::int0;
  arr_1d<1, fem::str<8> > text9(fem::fill0);
  arr_1d<14, fem::str<8> > text80(fem::fill0);
  static const char* format_5443 = "(1x,10e13.5)";
  static const char* format_5744 =
    "(i2,',',2(a6,','),6x,',,,',e23.14,',',e23.14,',,,,,,')";
  static const char* format_5745 =
    "(i3,',',2(a6,','),6x,',,,',e23.14,',',e23.14,',,,,,,')";
  static const char* format_5753 =
    "(/,' SPARSITY PATTERN OF TRIANGULARIZED JACOBIAN',' FOLLOWS  .....',/,6x,"
    "'1234567890',"
    "'123456789012345678901234567890123456789012345678901234567890')";
  static const char* format_5755 = "(i3,' : ',120a1)";
  static const char* format_5770 = "(13a6,a3)";
  //C     FOLLOWING DIMENSIONED VECTOR WITH "35" REALLY SHOULD BE           M32.7165
  //C     VARIABLY-DIMENSIONED TO "IOFBND" USER-REQUESTED SIZE.  BUT        M32.7166
  //C     IT IS EASIER TO LEAVE THEM FIXED, BIGGER THAN EVER NEEDED:        M32.7167
  ll35 = 35;
  drive = 1.0f;
  limit = fem::pow2(maxsq);
  statement_5270:
  loop = 1;
  move0(negate, ll35);
  //C     ENTER LOOP OVER SEQUENCE NETWORKS (ZERO FIRST, THEN POSITIVE):    M32.7184
  statement_5286:
  n13 = 2 * maxsq;
  move0(ymat(1, 1), n13);
  iprsup = iprsov(nchain);
  //C     READ INPUT CARD USING CIMAGE.                                     M32.7188
  cimage(cmn);
  read(abuff, "(2i8,2e8.0,2i8,4x,4a1)"), nitmax, n13, epsiln, percen,
    ipunch, ipncom, bus1, bus2, bus3, bus4;
  if (nitmax > 0 || epsiln > 0.0f) {
    goto statement_5311;
  }
  write(lunit6, "('+BLANK CARD TERMINATES \"FDU\" SUBCASES.')");
  goto statement_9900;
  statement_5311:
  write(lunit6, "('+MISC.',2i5,2e12.3,i4,1x,4a1)"), nitmax, n13,
    epsiln, percen, ipncom, bus1, bus2, bus3, bus4;
  if (iprsup <= 0) {
    iprsup = n13;
  }
  if (iprsup <= 0) {
    iprsup = 1;
  }
  if (bus1 != blank) {
    chara = bus1;
  }
  if (bus2 != blank) {
    charb = bus2;
  }
  if (bus3 != blank) {
    charc = bus3;
  }
  if (bus4 != blank) {
    charq = bus4;
  }
  scale = percen;
  ntot = 0;
  //C     ENTER LOOP WITH TOP AT 5321 WHERE ANOTHER BRANCH CARD IS READ:    M32.7211
  //C     READ INPUT CARD USING CIMAGE.                                     M32.7212
  statement_5321:
  cimage(cmn);
  read(abuff, "(2i8,e8.0)"), k, m, d6;
  if (k <= 0 || m <= 0 || d6 <= 0) {
    goto statement_5347;
  }
  if (k > ntot) {
    ntot = k;
  }
  if (m > ntot) {
    ntot = m;
  }
  if (ntot <= nmax) {
    goto statement_5335;
  }
  write(lunit6,
    "(/,'  @@@@@@@  OVERFLOW ERROR STOP.  GENERATOR OR',"
    "' NODE NUMBER IS TOO LARGE.   NTOT =',i5)"),
    ntot;
  kill = 1;
  lstat(19) = 5331;
  lstat(16) = 23;
  goto statement_9900;
  statement_5335:
  write(lunit6, "('+BRANCH CARD.  NODES =',2i4,'   X =',e13.4)"), k, m, d6;
  d6 = 1.0f / d6;
  ymat(k, m) = -d6;
  ymat(m, k) = -d6;
  ymat(k, k) += d6;
  ymat(m, m) += d6;
  goto statement_5321;
  statement_5347:
  write(lunit6, "('+BLANK CARD TERMINATING LINE CARDS.')");
  ntot2 = 2 * ntot;
  if (iprsup >= 2) {
    write(lunit6, "(' ADMITTANCE MATRIX FOLLOWS.   NTOT =',i3)"), ntot;
  }
  ntotsq = ntot * ntot;
  ntotp1 = ntot + 1;
  ntotm1 = ntot - 1;
  maxcol = 2 * ntot - 1;
  FEM_DO_SAFE(j, 1, ntot) {
    n12 = ntot + j;
    ymat(j, n12) = 1.0f;
    //C     READ INPUT CARD USING CIMAGE.                                     M32.7250
    cimage(cmn);
    read(abuff, "(i2,2a6,2e10.0,i6)"), L, texta(L), textb(L), rthev(L),
      xthev(L), n13;
    read(abuff, "(2x,12a1)"), text1, text2;
    write(lunit6, "('+THEVENIN.',i6,2e13.4,i6)"), L, rthev(L), xthev(L), n13;
    if (negate(L) == 0) {
      negate(L) = n13;
    }
    n4 = 0;
    FEM_DO_SAFE(m, 1, 6) {
      if (text1(m) != charq) {
        goto statement_5361;
      }
      ichara(L) = m;
      n4++;
      statement_5361:
      if (text2(m) != charq) {
        goto statement_5363;
      }
      icharb(L) = m;
      n4++;
      statement_5363:;
    }
    if (n4 >= 2) {
      goto statement_5368;
    }
    ichara(L) = 6;
    icharb(L) = 6;
    FEM_DO_SAFE(k, 2, 6) {
      if (text1(k) == blank && text1(k - 1) == chara) {
        ichara(L) = k - 1;
      }
      if (text2(k) == blank && text2(k - 1) == chara) {
        icharb(L) = k - 1;
      }
    }
    statement_5368:
    admit(L) = 1.0f / xthev(L);
    if (iprsup >= 2) {
      {
        write_loop wloop(cmn, lunit6,
          "(' ROW',i2,'.   X/R =',f11.3,'   XTHEV =',f11.3,'   Y(',i2,"
          "',1:NTOT) =',3e13.5,/,1x,10e13.5)");
        wloop, L, rthev(L), xthev(L), L;
        FEM_DO_SAFE(L, 1, ntot) {
          wloop, ymat(L, L);
        }
      }
    }
  }
  //C     NEXT ASSEMBLE CONSTANT PART OF JACOBIAN IN ARRSAV ARRAY.  THIS    M32.7284
  //C     IS TOP OF LOOP OVER ADMITTANCE LEVEL (FOR SEQUENTIAL ADJUSTMENT   M32.7285
  //C     OF [Y] TO MINIMIZE SHOCK TO NEWTON SOLUTION):                     M32.7286
  statement_5379:
  n7 = 0;
  move0(arrsav(1, 1), limit);
  FEM_DO_SAFE(kk, 1, ntot) {
    n8 = n7;
    FEM_DO_SAFE(i, 1, ntot) {
      n7++;
      if (scale > percen) {
        goto statement_5385;
      }
      soln(n7) = 0.0f;
      if (i == kk) {
        soln(n7) = admit(kk);
      }
      statement_5385:
      n4 = (i - 1) * ntot + i;
      //C     ARRSAV(N7,N4) = -GEN(I)          ! dF(I)/dYS(I) = -VS(I)          M32.7298
      if (lspars == 1) {
        goto statement_5395;
      }
      FEM_DO_SAFE(L, 1, ntotsq) {
        kspars(n7, L) = kblank;
      }
      kspars(n7, n4) = korig;
      statement_5395:
      if (i == kk) {
        arrsav(n7, n7) += drive;
      }
      FEM_DO_SAFE(j, 1, ntot) {
        if (j == kk) {
          goto statement_5402;
        }
        arrsav(n7, n8 + j) = scale * ymat(i, j);
        if (lspars != 1) {
          kspars(n7, n8 + j) = korig;
        }
        statement_5402:;
      }
    }
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(' INITIAL GUESS SOLN(1:NTOTSQ) =',6e15.6,/,1x,8e15.6)");
      FEM_DO_SAFE(j, 1, ntotsq) {
        wloop, soln(j);
      }
    }
  }
  if (iprsup >= 2) {
    write(lunit6, "(/,' PARTIAL CONSTANT JACOBIAN FOLLOWS.')");
  }
  FEM_DO_SAFE(i, 1, ntotsq) {
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6, format_5443);
        FEM_DO_SAFE(j, 1, ntotsq) {
          wloop, arrsav(i, j);
        }
      }
    }
  }
  if (iprsup <= 1) {
    goto statement_5458;
  }
  if (lspars == 1) {
    goto statement_5458;
  }
  write(lunit6, format_5753);
  FEM_DO_SAFE(k, 1, ntotsq) {
    {
      write_loop wloop(cmn, lunit6, format_5755);
      wloop, k;
      FEM_DO_SAFE(L, 1, ntotsq) {
        wloop, kspars(k, L);
      }
    }
  }
  statement_5458:
  niter = 0;
  write(lunit6, format_5443);
  goto statement_5723;
  //C     TOP OF LOOP FOR NEXT NEWTON ITERATION:                            M32.7334
  statement_5481:
  mover(arrsav(1, 1), array(1, 1), limit);
  n7 = 0;
  //C     INSIDE DO 5506, RHS(I) IS FUNCTION F(I);  NEWTON "-" ADDED AT 5529M32.7337
  FEM_DO_SAFE(kk, 1, ntot) {
    n8 = n7;
    FEM_DO_SAFE(i, 1, ntot) {
      n7++;
      n4 = (i - 1) * ntot + i;
      if (i == kk) {
        rhs(n7) = (soln(n7) - admit(i)) * drive;
      }
      if (i != kk) {
        rhs(n7) = soln(n4) * soln(n7);
      }
      //C     ENTER LOOP TO EVALUATE SUM OVER J OF Y(I,J)*V(J) FOR J .NE. I:    M32.7347
      d13 = ymat(i, kk) * drive;
      n2 = n8;
      FEM_DO_SAFE(j, 1, ntot) {
        n2++;
        if (j == kk) {
          goto statement_5492;
        }
        d13 += ymat(i, j) * soln(n2);
        statement_5492:;
      }
      if (iprsup >= 6) {
        write(lunit6,
          "(' BELOW 5492.  KK, I, N4, N7, N2 =',5i5,/,"
          "'              SCALE, RHS(N7), D13 =',3e15.5)"),
          kk, i, n4, n7, n2, scale, rhs(n7), d13;
      }
      rhs(n7) += scale * d13;
      if (i == kk) {
        goto statement_5502;
      }
      array(n7, n7) += soln(n4);
      array(n7, n4) += soln(n7);
      if (iprsup <= 1) {
        goto statement_5502;
      }
      if (lspars == 1) {
        goto statement_5502;
      }
      kspars(n7, n7) = korig;
      kspars(n7, n4) = korig;
      statement_5502:;
    }
  }
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' FINAL JACOBIAN AFTER VARIABLE PART HAS BEEN',"
      "' ADDED.  RHS = FUNCTION EVALUATION (ALSO DONE).')");
  }
  FEM_DO_SAFE(i, 1, ntotsq) {
    if (iprsup >= 4) {
      {
        write_loop wloop(cmn, lunit6,
          "(i3,'. RHS =',e15.6,'   Y(I,1:NTOTSQ) =',6e15.6,/,1x,8e15.6)");
        wloop, i, rhs(i);
        FEM_DO_SAFE(j, 1, ntotsq) {
          wloop, array(i, j);
        }
      }
    }
    rhs(i) = -rhs(i);
  }
  if (iprsup <= 1) {
    goto statement_5538;
  }
  if (lspars == 1) {
    goto statement_5538;
  }
  write(lunit6, format_5753);
  FEM_DO_SAFE(k, 1, ntotsq) {
    {
      write_loop wloop(cmn, lunit6, format_5755);
      wloop, k;
      FEM_DO_SAFE(L, 1, ntotsq) {
        wloop, kspars(k, L);
      }
    }
  }
  statement_5538:
  FEM_DO_SAFE(i, 1, ntotsq) {
    if (i == 1) {
      goto statement_5563;
    }
    n6 = i - 1;
    FEM_DO_SAFE(j, 1, n6) {
      if (array(i, j) == 0.0f) {
        goto statement_5561;
      }
      if (lspars == 1) {
        goto statement_5541;
      }
      if (kspars(i, j) == kblank) {
        kspars(i, j) = kfill;
      }
      statement_5541:
      d3 = array(i, j);
      array(i, j) = 0.0f;
      n8 = j + 1;
      FEM_DO_SAFE(L, n8, ntotsq) {
        array(i, L) = array(i, L) - d3 * array(j, L);
      }
      rhs(i) = rhs(i) - d3 * rhs(j);
      if (iprsup >= 5) {
        {
          write_loop wloop(cmn, lunit6,
            "(' ZERO (',i2,',',i2,'). RHS(I) =',e15.6,'   A(I,1:N9) =',5e15.6,"
            "/,1x,8e15.6)");
          wloop, i, j, rhs(i);
          FEM_DO_SAFE(L, 1, ntotsq) {
            wloop, array(i, L);
          }
        }
      }
      statement_5561:;
    }
    statement_5563:
    if (iprsup >= 4) {
      write(lunit6,
        "(' DIAGONAL READY TO BE RECIPROCATED,  A(',i2,',',i2,') =',e15.6)"),
        i, i, array(i, i);
    }
    d4 = 1.0f / array(i, i);
    array(i, i) = 1.0f;
    if (i == ntotsq) {
      goto statement_5574;
    }
    n8 = i + 1;
    FEM_DO_SAFE(L, n8, ntotsq) {
      if (array(i, L) == 0.0f) {
        goto statement_5572;
      }
      array(i, L) = d4 * array(i, L);
      if (lspars == 1) {
        goto statement_5572;
      }
      if (kspars(i, L) == kblank) {
        kspars(i, L) = kfill;
      }
      statement_5572:;
    }
    statement_5574:
    rhs(i) = d4 * rhs(i);
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6,
          "(' FINAL ROW',i3,'.  RHS =',e15.6,'   A(I,1:NTOTSQ) =',5e15.6,/,1x,"
          "8e15.6)");
        wloop, i, rhs(i);
        FEM_DO_SAFE(j, 1, ntotsq) {
          wloop, array(i, j);
        }
      }
    }
  }
  if (iprsup >= 2) {
    write(lunit6, "(' DONE WITH DOWNWARD, BEGIN BACKSUBSTITUTION.')");
  }
  i = ntotsq;
  statement_5614:
  i = i - 1;
  n8 = i + 1;
  FEM_DO_SAFE(j, n8, ntotsq) {
    if (array(i, j) == 0.0f) {
      goto statement_5627;
    }
    rhs(i) = rhs(i) - array(i, j) * rhs(j);
    statement_5627:;
  }
  if (i > 1) {
    goto statement_5614;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(' COMPLETE CORRECTION VECTOR:',6e15.6,/,1x,8e15.6)");
      FEM_DO_SAFE(j, 1, ntotsq) {
        wloop, rhs(j);
      }
    }
  }
  d4 = 0.0f;
  FEM_DO_SAFE(j, 1, ntotsq) {
    if (std::abs(rhs(j)) > d4) {
      d4 = std::abs(rhs(j));
    }
    soln(j) += rhs(j);
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(' LARGEST CORRECTION AT NEWTON ITERATION  NITER =',i3,'  IS  D4 =',"
      "e15.6)"),
      niter, d4;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(' CORRECTED SOLUTION ESTIMATE:',6e15.6,/,1x,8e15.6)");
      FEM_DO_SAFE(i, 1, ntotsq) {
        wloop, soln(i);
      }
    }
  }
  if (d4 < epsiln) {
    goto statement_5729;
  }
  statement_5723:
  niter++;
  if (niter <= nitmax) {
    goto statement_5481;
  }
  write(lunit6,
    "(/,' ***********  NONCONVERGENCE ERROR.  ITERATION',"
    "' LIMIT HAS BEEN REACHED.   NITMAX =',i3,/,'   PEAK CORRECTION (ABS) =',"
    "e15.6,'   FOR ADMITTANCE LEVEL \"SCALE\" =',f6.3)"),
    nitmax, d4, scale;
  goto statement_5778;
  statement_5729:
  if (std::abs(scale - 1.0f) > epsiln) {
    goto statement_5782;
  }
  //C     PROBLEM IS SOLVED;  ONLY CONVERSION FROM "Y" TO "X" REMAINS:      M32.7461
  write(lunit6,
    "(/,' FINAL GENERATOR EQUIVALENT IMPEDANCES, PLUS',"
    "' CONFIRMATION OF ORIGINAL GENERATOR PARAMETERS.',/,"
    "' RESISTANCE IS IGNORED DURING THE INTERNAL',"
    "' COMPUTATION, AND ADDED AS FIXED % ONLY AT END.',/,"
    "' X-FAULT IS SHORT CIRCUIT REACTANCE COMPUTED',"
    "' AFTER REMOVAL OF USER-FLAGGED GENERATORS.',/,3x,'GEN',10x,'X-NEW',10x,"
    "'R-NEW',8x,'X-FAULT',9x,'X-THEV',7x,'X/R-THEV')");
  n18 = 0;
  cmn.io.rewind(lunit1);
  //C     NEXT WE ADD Y-GEN TO [Y], TO CALCULATE SHORT CIRCUIT CURRENT:     M32.7473
  FEM_DO_SAFE(j, 1, ntot) {
    if (negate(j) != 0) {
      goto statement_5734;
    }
    n8 = (j - 1) * ntot + j;
    ymat(j, j) += soln(n8);
    statement_5734:;
  }
  //C     NEXT WE INVERT TOTAL [Y], TO GIVE S.S. CURRENTS AS DIAGONALS:     M32.7479
  FEM_DO_SAFE(k, 1, ntot) {
    d3 = 1.0f / ymat(k, k);
    n6 = k + 1;
    FEM_DO_SAFE(L, n6, ntot2) {
      ymat(k, L) = ymat(k, L) * d3;
    }
    FEM_DO_SAFE(m, 1, ntot) {
      if (m == k) {
        goto statement_6748;
      }
      d2 = ymat(m, k);
      FEM_DO_SAFE(L, n6, ntot2) {
        ymat(m, L) = ymat(m, L) - d2 * ymat(k, L);
      }
      statement_6748:;
    }
  }
  //C     DONE WITH YMAT INVERSION;  OUTPUT GENERATOR GOODIES:              M32.7492
  FEM_DO_SAFE(j, 1, ntot) {
    n8 = (j - 1) * ntot + j;
    output(j) = fltinf;
    if (soln(n8) != 0.0f) {
      output(j) = 1.0f / soln(n8);
    }
    d7 = output(j) / rthev(j);
    n2 = ntot + j;
    write(lunit6, "(1x,i5,4e15.6,f15.3)"), j, output(j), d7, ymat(j,
      n2), xthev(j), rthev(j);
    if (negate(j) == 1) {
      output(j) = fltinf;
    }
    d7 = output(j) / rthev(j);
    if (loop == 2) {
      goto statement_5740;
    }
    rzero(j) = d7;
    xzero(j) = output(j);
    goto statement_5746;
    //C     WITH BOTH Z-GROUND AND Z-SKY MODES NOW KNOWN, PUNCH BRANCH CARDS: M32.7510
    statement_5740:
    if (negate(j) != 0) {
      goto statement_5746;
    }
    n6 = 51;
    n4 = ichara(j);
    n5 = icharb(j);
    text9(1) = chara;
    packa1(text9(1), texta(j), n4);
    packa1(text9(1), textb(j), n5);
    if (ipncom == 0) {
      goto statement_5743;
    }
    write(lunit7, "('C')");
    write(lunit1, "(' C')");
    n18++;
    statement_5743:
    if (ipunch == 0) {
      write(lunit7, format_5744), n6, texta(j), textb(j), rzero(j), xzero(j);
    }
    write(lunit1, format_5745), n6, texta(j), textb(j), rzero(j), xzero(j);
    n18++;
    n4 = ichara(j);
    n5 = icharb(j);
    text9(1) = charb;
    packa1(text9(1), texta(j), n4);
    packa1(text9(1), textb(j), n5);
    n6 = 52;
    if (ipunch == 0) {
      write(lunit7, format_5744), n6, texta(j), textb(j), d7, output(j);
    }
    write(lunit1, format_5745), n6, texta(j), textb(j), d7, output(j);
    n18++;
    text9(1) = charc;
    packa1(text9(1), texta(j), n4);
    packa1(text9(1), textb(j), n5);
    n6 = 53;
    if (ipunch == 0) {
      write(lunit7, "(i2,',',2(a6,','),6x,',,,,,,,,,,')"), n6, texta(j),
        textb(j);
    }
    write(lunit1, "(i3,',',2(a6,','),6x,',,,,,,,,,,')"), n6, texta(j), textb(j);
    n18++;
    statement_5746:;
  }
  if (iprsup <= 1) {
    goto statement_5764;
  }
  if (lspars == 1) {
    goto statement_5764;
  }
  write(lunit6, format_5753);
  FEM_DO_SAFE(k, 1, ntotsq) {
    {
      write_loop wloop(cmn, lunit6, format_5755);
      wloop, k;
      FEM_DO_SAFE(L, 1, ntotsq) {
        wloop, kspars(k, L);
      }
    }
  }
  statement_5764:
  loop++;
  write(lunit6, format_5443);
  if (loop <= 2) {
    goto statement_5286;
  }
  if (ipunch != 0) {
    goto statement_5778;
  }
  write(lunit6,
    "(' 80-COLUMN CARD IMAGES OF COUPLED R-L BRANCHES',"
    "' THAT MAY BE PUNCHED ON LUNIT7 (IF IPUNCH = 0).',/,"
    "' 1234567890123456789012345678901234567890',"
    "'1234567890123456789012345678901234567890',/,"
    "' ----------------------------------------',"
    "'----------------------------------------')");
  cmn.io.rewind(lunit1);
  FEM_DO_SAFE(j, 1, n18) {
    read(lunit1, format_5770), text80;
    write(lunit6, format_5770), text80;
  }
  statement_5778:
  goto statement_5270;
  statement_5782:
  scale += percen;
  if (scale > 1.0f) {
    scale = 1.0f;
  }
  goto statement_5379;
  statement_9900:
  if (iprsov(nchain) >= 1) {
    write(lunit6, "(' EXIT \"FLTDAT\".  KILL =',i5)"), kill;
  }

#endif
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct statrs_save
{
  fem::str<1> c1;

  statrs_save() :
    c1(fem::char0)
  {}
};

void statrs(
  common& cmn) try
{
  FEM_CMN_SVE(statrs);
  common_write write(cmn);
  auto& lunit1 = cmn.lunit1;
  const auto& lstat = cmn.lstat;
  int& iprsup = cmn.iprsup;
  //
  fem::str<1>& c1 = sve.c1;
  if (is_called_first_time) {
    c1 = " ";
  }
  auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  fem::str<20> filn20 = fem::char0;
  int j = fem::int0;
  //C     INSTALLATION-DEPENDENT MODULE OF OVERLAY 29,  CALLED ONLY         M31.3700
  //C     FOR  "TABULATE ENERGIZATION RESULTS"  USAGE.                      M31.3701
  //C!, FILNAM(20)
  //C!EQUIVALENCE (FILN20, FILNAM(1) )
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' TOP OF \"STATRS\" .   LSTAT(13:16) =',4i5)");
      FEM_DO_SAFE(i, 13, 16) {
        wloop, lstat(i);
      }
    }
  }
  {
    write_loop wloop(filn20, "('ST',i1,'LOG',3i1,'.DAT ')");
    FEM_DO_SAFE(i, 13, 16) {
      wloop, lstat(i);
    }
  }
  FEM_DO_SAFE(j, 15, 20) {
    filn20(j, j) = c1;
  }
  cmn.io.close(lunit1);
  if (lstat(13) == 0) {
    goto statement_9000;
  }
  if (iprsup >= 1) {
    write(lunit6, "(' IN \"STATRS\", B4 OPEN OF UNIT LUNIT1 .',20a1)"), filn20;
  }
  cmn.io.open(lunit1, filn20)
    .form("UNFORMATTED")
    .status("OLD");
  write(lunit6,
    "(20x,'----  SUCCESSFUL  OPEN   OF  LUNIT',i1,'  DATA',"
    "' ON DISK.   PERMANENT FILE NAME = ',20a1,' .')"),
    lstat(13), filn20;
  statement_9000:;

}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct guts29_save
{
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;

  guts29_save() :
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0)
  {}
};

void guts29(
  common& cmn,
  str_arr_ref<> bus,
  arr_ref<int> kmswit,
  arr_ref<int> kdepsw,
  arr_ref<int> ibrnch,
  arr_ref<int> jbrnch,
  arr_ref<double> akey,
  arr_ref<double> tstat,
  arr_ref<double> tclose,
  arr_ref<double> topen) try
{
  FEM_CMN_SVE(guts29);
  bus(dimension(1));
  kmswit(dimension(1));
  kdepsw(dimension(1));
  ibrnch(dimension(1));
  jbrnch(dimension(1));
  akey(dimension(1));
  tstat(dimension(1));
  tclose(dimension(1));
  topen(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& blank = cmn.blank;
  auto& texta6 = cmn.texta6;
  auto& date1= cmn.date1;
  auto& tclock= cmn.tclock;
  const auto& abuff = cmn.abuff;
  double& aincr = cmn.aincr;
  double& xmaxmx = cmn.xmaxmx;
  auto& voltbc = cmn.voltbc;
  auto& moncar = cmn.moncar;
  auto& lunit1 = cmn.lunit1;
  auto& lunit3 = cmn.lunit3;
  auto& lunit9 = cmn.lunit9;
  auto& ipntv = cmn.ipntv;
  auto& indtv = cmn.indtv;
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  int& istep = cmn.istep;
  int& lastov = cmn.lastov;
  int& numout = cmn.numout;
  auto& nexout = cmn.nexout;
  int& iofbnd = cmn.iofbnd;
  int& kill = cmn.kill;
  int& ivolt = cmn.ivolt;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  const auto& loopss = cmn.loopss;
  int& nc = cmn.nc;
  int& numnvo = cmn.numnvo;
  int& nenerg = cmn.nenerg;
  auto& karray = static_cast<common_c29b01&>(cmn).karray;
  int& liminc = cmn.liminc;
  int& iofarr = cmn.iofarr;
  int& maxo29 = cmn.maxo29;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  fem::str<8>& text7 = sve.text7;
  if (is_called_first_time) {
    text1 = "MISC. ";
    text2 = "STATIS";
    text3 = "TICS D";
    text5 = "BEGIN ";
    text6 = "NEW DA";
    text7 = "BNDC  ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int ioutcs = fem::int0;
  int knt = fem::int0;
  int kbase = fem::int0;
  int idist = fem::int0;
  int itest = fem::int0;
  int kloaep = fem::int0;
  int n18 = fem::int0;
  double d18 = fem::double0;
  int n3 = fem::int0;
  double d7 = fem::double0;
  int n2 = fem::int0;
  int n7 = fem::int0;
  int iofray = fem::int0;
  int iofsav = fem::int0;
  int iofsol = fem::int0;
  int iofrhs = fem::int0;
  int iofmat = fem::int0;
  int iofksp = fem::int0;
  int n8 = fem::int0;
  int lspars = fem::int0;
  int n4 = fem::int0;
  arr_1d<1, double> array(fem::fill0);
  int nstat = fem::int0;
  int n6 = fem::int0;
  arr_1d<20, int> lltemp(fem::fill0);
  int i = fem::int0;
  arr_1d<50, int> mmtemp(fem::fill0);
  int m = fem::int0;
  int n13 = fem::int0;
  int n5 = fem::int0;
  int neni = fem::int0;
  int npni = fem::int0;
  int npnerg = fem::int0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  int n16 = fem::int0;
  int nsmout = fem::int0;
  int numbco = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  int j3 = fem::int0;
  int j4 = fem::int0;
  int j5 = fem::int0;
  int j6 = fem::int0;
  int m13 = fem::int0;
  int jj = fem::int0;
  int j = fem::int0;
  double ranoff = fem::double0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  int ntemp = fem::int0;
  int narray = fem::int0;
  int iofibs = fem::int0;
  int iofkou = fem::int0;
  int iofpnt = fem::int0;
  int iofnsu = fem::int0;
  static const char* format_6249 = "('+FILE NAMES.',9i4)";
  //C!EQUIVALENCE ( ARRAY(1), KARRAY(1) )
  //C!EQUIVALENCE  (MONCAR(1),    KNT),   (MONCAR(2),  KBASE)
  //C!EQUIVALENCE  (MONCAR(5),  IDIST),   (MONCAR(6),  ITEST)
  //C!EQUIVALENCE  (MONCAR(9), KLOAEP)
  ioutcs = lstat(59);
  knt = moncar(1);
  kbase = moncar(2);
  idist = moncar(5);
  itest = moncar(6);
  kloaep = moncar(9);
  if (iprsup >= 1) {
    write(lunit6,
      "(' TOP OF \"GUTS29\".  IOFBND, KBURRO, ISTEP =',3i8)"),
      iofbnd, cmn.kburro, istep;
  }
  n18 = maxo29 * nbyte(4) / nbyte(3) - iofarr;
  if (istep !=  - 6633) {
    goto statement_5627;
  }
  //C     BEGIN "FAULT DATA USAGE" (FROM "REQUES" OF OVERLAY 1):            M32.6603
  //C     NEXT SOLVE FOR MAXIMUM DIMENSION X:  2(X)**2 + 4(X) - N18 = 0     M32.6604
  d18 = 1 + n18 / 2;
  n3 = sqrtz(d18) - 1.0f;
  d7 = n3;
  n2 = sqrtz(d7);
  if (iofbnd <= 0) {
    iofbnd = n2;
  }
  if (iofbnd <= n2) {
    goto statement_4839;
  }
  write(6,
    "(' INSUFFICIENT WORKING SPACE FROM \"VARDIM\"',"
    "' DIMENSIONING TO HONOR USER-REQUESTED',"
    "' MAXIMUM NUMBER OF BUSSES EQUAL TO',i5,' .',/,"
    "' USER CAN RERUN WITH REDUCED MAXIMUM EQUAL TO',i5,' .')"),
    iofbnd, n2;
  stoptp(cmn);
  statement_4839:
  n3 = fem::pow2(iofbnd);
  n7 = fem::pow2(n3);
  write(lunit6, "('+',40x,'MAX =',i3)"), iofbnd;
  iofray = 1;
  iofsav = iofray + n7;
  iofsol = iofsav + n7;
  iofrhs = iofsol + n3;
  iofmat = iofrhs + n3;
  iofksp = iofmat + 2 * n3;
  iofksp = iofksp * nbyte(4) / nbyte(3) + 1;
  n8 = iofksp + n7;
  lspars = 1;
  if (n8 < loopss(2)) {
    lspars = n3;
  }
  n4 = 2 * iofbnd;
  if (iprsup >= 1) {
    write(lunit6,
      "(' IOFSAV, IOFSOL, IOFRHS, IOFMAT, IOFKSP =',5i6,/,"
      "' ARRAY DIMENSIONS N3, N4, N2, LSPARS =',4i6)"),
      iofsav, iofsol, iofrhs, iofmat, iofksp, n3, n4, iofbnd, lspars;
  }
  fltdat(cmn, array(iofray), array(iofsav), array(iofsol), array(iofrhs),
    array(iofmat), karray(iofksp), n3, n4, iofbnd, lspars);
  goto statement_9800;
  //C     END "FAULT DATA USAGE" SERVICING;  BEGIN MONTE CARLO:             M32.6643
  //C     REMOVE POSSIBLE MINUS SIGN FROM  'XMAXMX'  (INDICATING            M28.6617
  //C     USER-REQUEST FOR BUILT-IN RANDOM NUMBERS OF  "SANDNM" ).          M28.6618
  statement_5627:
  xmaxmx = std::abs(xmaxmx);
  //C     RESET 'AINCR' IF BIAS OF  55  IS PRESENT (INDICATING              M27.2653
  //C     STATISTICS JUST FOR MINIMA?).                                     M27.2654
  if (aincr >= 55.0f) {
    aincr = aincr - 55.0f;
  }
  if (aincr == 0.0f) {
    aincr = .05f;
  }
  knt = 0;
  moncar(1) = knt;
  nstat = lstat(32);
  if (lastov > 1) {
    goto statement_6309;
  }
  knt = 1;
  moncar(1) = knt;
  nenerg = 0;
  n6 = 0;
  n7 = 0;
  n8 = 0;
  //C     READ INPUT CARD USING CIMAGE.                                     M23.5361
  statement_6227:
  cimage(cmn);
  if (cmn.kolbeg > 0) {
    goto statement_6263;
  }
  {
    read_loop rloop(abuff(1), "(10i8)");
    FEM_DO_SAFE(i, 1, 10) {
      rloop, lltemp(i);
    }
  }
  FEM_DO_SAFE(i, 1, 10) {
    if (lltemp(i) == 0) {
      goto statement_6239;
    }
    if (lltemp(i) != 9999) {
      goto statement_6236;
    }
    n8 = 9999;
    goto statement_6243;
    statement_6236:
    n7++;
    if (n7 > 50) {
      goto statement_6270;
    }
    mmtemp(n7) = lltemp(i);
    statement_6239:;
  }
  statement_6243:
  {
    write_loop wloop(cmn, kunit6, format_6249);
    FEM_DO_SAFE(i, 1, 9) {
      wloop, lltemp(i);
    }
  }
  if (n8 == 9999) {
    goto statement_6294;
  }
  goto statement_6227;
  statement_6263:
  cmn.nfrfld = 1;
  statement_6269:
  freone(cmn, d7);
  if (d7 == 9999.f) {
    goto statement_6282;
  }
  if (d7 == 0.0f) {
    goto statement_6273;
  }
  n7++;
  if (n7 <= 50) {
    goto statement_6272;
  }
  statement_6270:
  write(lunit6,
    "(' TEMPORARY ERROR STOP IN \"GUTS29\".',"
    "'   OVERFLOW  MMTEMP(50).   STOP.')");
  stoptp(cmn);
  statement_6272:
  mmtemp(n7) = d7;
  statement_6273:
  goto statement_6269;
  statement_6282:
  FEM_DO_SAFE(i, 1, 9) {
    lltemp(i) = mmtemp(i);
  }
  {
    write_loop wloop(cmn, kunit6, format_6249);
    FEM_DO_SAFE(i, 1, 9) {
      wloop, lltemp(i);
    }
  }
  statement_6294:
  FEM_DO_SAFE(m, 1, n7) {
    n13 = mmtemp(m);
    n2 = n13 / 100;
    n5 = n13 - 100 * n2;
    n3 = n5 / 10;
    n4 = n5 - 10 * n3;
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' IN  ''GUTS29'' ,  READY TO ATTACH.',"
        "'       M      N7     N13      N2      N3',"
        "'      N4  LUNIT3  LUNIT6  LUNIT9',/,33x,9i8)"),
        m, n7, n13, n2, n3, n4, lunit3, lunit6, lunit9;
    }
    lstat(14) = n2;
    lstat(15) = n3;
    lstat(16) = n4;
    lstat(13) = 9;
    statrs(cmn);
    read(lunit1, fem::unformatted), ntot, neni;
    read(lunit1, fem::unformatted), cmn.pu;
    npni = iabsz(neni);
    nenerg += neni;
    npnerg = iabsz(nenerg);
    if (iprsup >= 3) {
      write(lunit6,
        "(/,' AFTER 2-INTEGER READ FROM LUNIT1.','    NTOT    NENI',/,34x,"
        "2i8)"),
        ntot, neni;
    }
    nexout(m) = ntot;
    if (m != 1) {
      goto statement_260;
    }
    write(lunit9, fem::unformatted), ntot;
    statement_260:
    read(lunit1, fem::unformatted), date1, tclock, ivolt, n6, ndx1,
      ndx2, n16, nsmout, ioutcs, numout, n18, numnvo, numbco, nc,
      kswtch;
    cmn.nv = nc - numbco;
    if (m != 1) {
      goto statement_270;
    }
    write(lunit9, fem::unformatted), date1, tclock, ivolt, n6, ndx1,
      ndx2, n16, nsmout, ioutcs, numout, n18, numnvo, numbco, nc,
      kswtch;
    statement_270:
    j1 = ntot + 1;
    j2 = ntot + n6;
    j3 = j2 + ndx1;
    j4 = j2 + ndx2;
    j5 = j4 + 1;
    j6 = j4 + n16;
    {
      read_loop rloop(cmn, lunit1, fem::unformatted);
      FEM_DO_SAFE(i, 1, ntot) {
        rloop, bus(i);
      }
      FEM_DO_SAFE(i, j1, j2) {
        rloop, bus(i);
      }
      FEM_DO_SAFE(i, j3, j4) {
        rloop, bus(i);
      }
      FEM_DO_SAFE(i, j5, j6) {
        rloop, bus(i);
      }
    }
    if (m != 1) {
      goto statement_275;
    }
    {
      write_loop wloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(i, 1, ntot) {
        wloop, bus(i);
      }
      FEM_DO_SAFE(i, j1, j2) {
        wloop, bus(i);
      }
      FEM_DO_SAFE(i, j3, j4) {
        wloop, bus(i);
      }
      FEM_DO_SAFE(i, j5, j6) {
        wloop, bus(i);
      }
    }
    statement_275:
    if (iprsup >= 1) {
      write(lunit6, "(' INTEGERS WRITTEN ON LUNIT9',5x,12i8)"), nc,
        nsmout, ioutcs, ivolt, ndx1, ndx2, n16, numout, n18, numnvo,
        numbco, nc;
    }
    texta6(m) = bus(ntot);
    if (ivolt != 1) {
      goto statement_4103;
    }
    {
      read_loop rloop(cmn, lunit1, fem::unformatted);
      FEM_DO_SAFE(i, 2, ntot) {
        rloop, m13;
      }
    }
    if (m != 1) {
      goto statement_4104;
    }
    {
      write_loop wloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(i, 2, ntot) {
        wloop, i;
      }
    }
    goto statement_4104;
    statement_4103:
    if (numnvo > 0) {
      {
        read_loop rloop(cmn, lunit1, fem::unformatted);
        FEM_DO_SAFE(i, 1, numnvo) {
          rloop, karray(i);
        }
      }
    }
    if (m != 1) {
      goto statement_4104;
    }
    if (numnvo > 0) {
      {
        write_loop wloop(cmn, lunit9, fem::unformatted);
        FEM_DO_SAFE(i, 1, numnvo) {
          wloop, karray(i);
        }
      }
    }
    statement_4104:
    if (nc > 0) {
      {
        read_loop rloop(cmn, lunit1, fem::unformatted);
        FEM_DO_SAFE(i, 1, nc) {
          rloop, ibrnch(i);
        }
        FEM_DO_SAFE(i, 1, nc) {
          rloop, jbrnch(i);
        }
      }
    }
    if (m != 1) {
      goto statement_285;
    }
    if (nc > 0) {
      {
        write_loop wloop(cmn, lunit9, fem::unformatted);
        FEM_DO_SAFE(i, 1, nc) {
          wloop, ibrnch(i);
        }
        FEM_DO_SAFE(i, 1, nc) {
          wloop, jbrnch(i);
        }
      }
    }
    statement_285:
    nstat = nc + numnvo;
    if (m == 1) {
      lstat(32) = nstat;
    }
    ipntv(m) = nstat;
    indtv(m) = kswtch;
    if (m == 1) {
      goto statement_310;
    }
    n2 = m - 1;
    if (nexout(m) != nexout(n2)) {
      goto statement_9200;
    }
    if (texta6(m) != texta6(n2)) {
      goto statement_9200;
    }
    if (ipntv(m) != ipntv(n2)) {
      goto statement_9200;
    }
    if (indtv(m) != indtv(n2)) {
      goto statement_9200;
    }
    statement_310:
    FEM_DO_SAFE(jj, 1, npni) {
      {
        read_loop rloop(cmn, lunit1, fem::unformatted);
        FEM_DO_SAFE(j, 1, nstat) {
          rloop, voltbc(j);
        }
      }
      if (iprsup >= 3) {
        {
          write_loop wloop(cmn, lunit6,
            "('  VOLTBC  FROM LUNIT1.',/(1x,8e15.6))");
          FEM_DO_SAFE(j, 1, nstat) {
            wloop, voltbc(j);
          }
        }
      }
      {
        write_loop wloop(cmn, lunit9, fem::unformatted);
        FEM_DO_SAFE(j, 1, nstat) {
          wloop, voltbc(j);
        }
      }
    }
    lstat(13) = 3;
    statrs(cmn);
    FEM_DO_SAFE(i, 1, kswtch) {
      j = cmn.lswtch + i;
      read(lunit1, fem::unformatted), kmswit(i), kmswit(j), akey(i),
        tstat(i), topen(j), kdepsw(i);
      if (m != 1) {
        goto statement_340;
      }
      write(lunit3, fem::unformatted), kmswit(i), kmswit(j), akey(i),
        tstat(i), topen(j), kdepsw(i);
      statement_340:;
    }
    read(lunit1, fem::unformatted), kloaep;
    if (m != 1) {
      goto statement_410;
    }
    write(lunit3, fem::unformatted), kloaep;
    statement_410:
    FEM_DO_SAFE(jj, 1, npni) {
      {
        read_loop rloop(cmn, lunit1, fem::unformatted);
        rloop, ranoff;
        FEM_DO_SAFE(i, 1, kswtch) {
          rloop, tclose(i);
        }
      }
      {
        write_loop wloop(cmn, lunit3, fem::unformatted);
        wloop, ranoff;
        FEM_DO_SAFE(i, 1, kswtch) {
          wloop, tclose(i);
        }
      }
      {
        read_loop rloop(cmn, lunit1, fem::unformatted);
        rloop, ranoff;
        FEM_DO_SAFE(i, 1, kswtch) {
          rloop, topen(i);
        }
      }
      {
        write_loop wloop(cmn, lunit3, fem::unformatted);
        wloop, ranoff;
        FEM_DO_SAFE(i, 1, kswtch) {
          wloop, topen(i);
        }
      }
    }
  }
  lstat(13) = 0;
  statrs(cmn);
  statement_6309:
  if (kbase == 29) {
    goto statement_1621;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M32.6716
  statement_6315:
  cimage(cmn);
  statement_6319:
  //C     CHECK FOR TRUNCATED STATISTICS MISC. DATA CARD:                   M32.6719
  read(abuff, "(40x,4a6)"), bus1, bus2, bus3, bus4;
  if (bus1 != text1) {
    goto statement_6369;
  }
  if (bus2 != text2) {
    goto statement_6369;
  }
  if (bus3 != text3) {
    goto statement_6369;
  }
  kbase = 29;
  moncar(2) = kbase;
  statement_1621:
  read(abuff, "(24x,2e8.0)"), d1, d2;
  if (d1 != 0.0f) {
    aincr = d1;
  }
  if (d2 != 0.0f) {
    xmaxmx = d2;
  }
  write(kunit6, "('+STATISTICS DATA.',2i7,2f9.4)"), itest, idist, aincr, xmaxmx;
  goto statement_6315;
  //C     CHECK FOR "BEGIN NEW DATA CASE" OR "BNDC" CARD:                   M32.6732
  statement_6369:
  read(abuff, "(13a6)"), bus1, bus2, bus3, bus4;
  if (bus1 == text5 && bus2 == text6) {
    goto statement_16379;
  }
  if (bus1 == text7 && bus2 == blank) {
    goto statement_16379;
  }
  if (bus1 == blank && bus2 == blank && kbase == 28) {
    goto statement_16379;
  }
  goto statement_6379;
  statement_16379:
  write(kunit6, "('+NEW-CASE MARKER CARD BOUNDS THIS-CASE DATA.')");
  goto statement_9900;
  statement_6379:
  ntemp = nstat;
  if (nstat < kswtch) {
    ntemp = kswtch;
  }
  narray = fem::iabs(nenerg) * (ntemp + 1) * 2;
  if (aincr >= 0.0f) {
    goto statement_6389;
  }
  liminc = std::abs(aincr);
  goto statement_6399;
  statement_6389:
  xmaxmx = 5.0f * xmaxmx;
  liminc = xmaxmx / aincr + 1.0f;
  statement_6399:
  iofibs = (iofarr + narray) * nbyte(3) / nbyte(4);
  iofkou = iofibs + numnvo + nc + nc;
  iofpnt = iofkou + liminc;
  iofnsu = iofpnt + liminc;
  n2 = iofnsu + liminc - 1;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' BEFORE CALL INNR29.','  MAXO29   NSTAT  KSWTCH  NENERG',"
      "'  NUMNVO      NC  LIMINC      N2',9x,'XMAXMX',10x,'AINCR',/,20x,8i8,"
      "2e15.6)"),
      maxo29, nstat, kswtch, nenerg, numnvo, nc, liminc, n2, xmaxmx,
      aincr;
  }
  if (n2 <= maxo29) {
    goto statement_20;
  }
  kill = 88;
  lstat(15) = n2;
  lstat(16) = maxo29;
  lstat(13) = fem::iabs(nenerg) + 3;
  lstat(14) = liminc;
  lstat(19) = 20;
  goto statement_9800;
  statement_20:
  innr29(cmn, array(iofarr), karray(iofibs), karray(iofkou), karray(iofpnt),
    karray(iofnsu), bus(1), kmswit(1), kdepsw(1), ibrnch(1), jbrnch(1),
    akey(1), tstat(1), tclose(1), topen(1));
  if (kbase == 29) {
    goto statement_6319;
  }
  if (kbase == 28) {
    goto statement_6315;
  }
  statement_9200:
  kill = 206;
  bus1 = texta6(m);
  bus2 = texta6(n2);
  lstat(11) = nexout(n2);
  lstat(12) = ipntv(n2);
  lstat(13) = indtv(n2);
  lstat(14) = nstat;
  lstat(19) = 300;
  statement_9800:
  lstat(18) = nchain;
  lastov = nchain;
  nchain = 51;
  statement_9900:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT \"GUTS29\".  KILL, NCHAIN, N18 =',3i6)"),
      kill, nchain, n18;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void subr29(
  common& cmn) try
{
  common_write write(cmn);
  fem::str<8>& trash = cmn.trash;
  const auto& nbyte = cmn.nbyte;
  int& lbus = cmn.lbus;
  int& lswtch = cmn.lswtch;
  int& lsiz12 = cmn.lsiz12;
  int& iprsup = cmn.iprsup;
  auto& karray = static_cast<common_c29b01&>(cmn).karray;
  int& iofarr = cmn.iofarr;
  int& nvar = cmn.nvar;
  int& maxo29 = cmn.maxo29;
  //
  auto& lunit6 = cmn.lunit6;
  int j = fem::int0;
  int iofbus = fem::int0;
  int iofkms = fem::int0;
  int iofkde = fem::int0;
  int iofibr = fem::int0;
  int iofjbr = fem::int0;
  int iofake = fem::int0;
  int ioftst = fem::int0;
  int ioftcl = fem::int0;
  int ioftop = fem::int0;
  int n9 = fem::int0;
  arr_1d<1, fem::str<8> > text(fem::fill0);
  arr_1d<1, double> array(fem::fill0);
  //C!w EQUIVALENCE  ( KARRAY(1), TEXT(1), ARRAY(1) )
  if (iprsup >= 1) {
    write(lunit6,
      "(' AT TOP OF \"SUBR29\".  LSWTCH, LSIZ12, LBUS =',3i8)"),
      lswtch, lsiz12, lbus;
  }
  nvar = lswtch;
  if (lsiz12 > lswtch) {
    nvar = lsiz12;
  }
  dimens(karray(1), cmn.nchain, trash, trash);
  FEM_DOSTEP(j, 1, 9999, 2) {
    if (karray(j) != 0) {
      goto statement_2364;
    }
    maxo29 = karray(j + 1);
    goto statement_2368;
    statement_2364:;
  }
  stoptp(cmn);
  statement_2368:
  iofbus = 1;
  iofkms = (iofbus + 2 * lbus) * nbyte(1) / nbyte(4);
  iofkde = iofkms + 2 * lswtch;
  iofibr = iofkde + lswtch;
  iofjbr = iofibr + lsiz12;
  iofake = (iofjbr + lsiz12) * nbyte(4) / nbyte(3) + 1;
  ioftst = iofake + lswtch;
  ioftcl = ioftst + lswtch;
  ioftop = ioftcl + lswtch;
  iofarr = ioftop + 2 * lswtch;
  n9 = iofarr * nbyte(3) / nbyte(4);
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(' AFTER OFFSET COMPUTATION.  NVAR, NBYTE(1:4) =',5i5,5x,'MAXO29 =',"
        "i8,/,'   IOFBUS  IOFKMS  IOFKDE  IOFIBR  IOFJBR',"
        "'  IOFAKE  IOFTST  IOFTCL  IOFTOP  IOFARR',/,1x,10i8)");
      wloop, nvar;
      FEM_DO_SAFE(j, 1, 4) {
        wloop, nbyte(j);
      }
      wloop, maxo29, iofbus, iofkms, iofkde, iofibr, iofjbr, iofake,
        ioftst, ioftcl, ioftop, iofarr, n9;
    }
  }
  if (n9 < maxo29) {
    goto statement_3462;
  }
  write(lunit6,
    "(/,' TEMPORARY ERROR STOP IN \"SUBR29\" OF OVERLAY 29.',"
    "'   WORKING STORAGE OF /C29B01/ (\"VARDIM\" OUTPUT)',"
    "' MUST EQUAL AT LEAST',i7,'   WORDS',/,"
    "' TO SOLVE THE PROBLEM, ALTHOUGH USER-DIMENSIONING',' ONLY PROVIDED FOR',"
    "i7,'   WORDS (BOTH',' INTEGER FIGURES).   REDIMENSION THE EMTP.')"),
    n9, maxo29;
  stoptp(cmn);
  statement_3462:
  guts29(cmn, text(iofbus), karray(iofkms), karray(iofkde), karray(iofibr),
    karray(iofjbr), array(iofake), array(ioftst), array(ioftcl), array(
    ioftop));
  if (iprsup >= 1) {
    write(lunit6, "(' AT EXIT OF \"SUBR29\".  IOFARR, KILL =',2i8)"),
      iofarr, cmn.kill;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void over29(
  common& cmn) try
{
  //C! IMPLICIT double precision (A-H, O-Z)
  //C! IMPLICIT INTEGER (I-N)
  //C!COMMON  / C29B01 /   KARRAY( 1992869 )
  //C!COMMON  / SPAC01 /   TP    (   30000 )
  //C!COMMON  / SPAC02 /   NORDER(    3002 )
  //C!COMMON  / SPAC03 /   INDEX (    3002 )
  //C!COMMON  / SPAC04 /   DIAG  (    3002 )
  //C!COMMON  / SPAC05 /   DIAB  (    3002 )
  //C!COMMON  / SPAC06 /   SOLR  (    3002 )
  //C!COMMON  / SPAC07 /   SOLI  (    3002 )
  //C!COMMON  / SPAC08 /   ICH1  (    3002 )
  //C!COMMON  / SPAC09 /   BND   (     300 )
  //C!COMMON  / SPAC10 /   ILOC  (   30000 )
  //C!COMMON  / SPAC11 /   GND   (   30000 )
  subr29(cmn);
  //C      COMMON  /SPAC02/   NORDER(1)
  //C      COMMON  /SPAC03/   INDEX (1)
  //C      COMMON  /SPAC04/   DIAG  (1)
  //C      DIMENSION                               ICH2(1)                   M25.  37
  //C      EQUIVALENCE                (   DIAG(1), ICH2(1)  )                M25.  37
  //C      COMMON  /SPAC05/   DIAB  (1)
  //C      DIMENSION                               LOC(1)                    M22. 483
  //C      EQUIVALENCE                (   DIAB(1), LOC(1)  )                 M22. 483
  //C      COMMON  /SPAC06/   SOLR  (1)
  //C      DIMENSION                                KOWNT(1)                 M32. 102
  //C      EQUIVALENCE                (   SOLR(1),  KOWNT(1)  )              M32. 102
  //C      COMMON  /SPAC07/   SOLI  (1)
  //C      COMMON  /SPAC08/   ICH1  (1)
  //C      COMMON  /SPAC01/   BND   (1)
  //C      DIMENSION                              KORDER(1)                  M28. 110
  //C      EQUIVALENCE                (   BND(1), KORDER(1)  )                M28. 11
  //C      COMMON  /SPAC10/   ILOC  (1)
  //C      COMMON  /SPAC11/   GND   (1)
  //C      DIMENSION                              KOLUM(1),                  M28. 112
  //C     1 FRANDN(1), IRANDN(1)                                             M23.  25
  //C      EQUIVALENCE                (   GND(1), KOLUM(1),                  M28. 112
  //C     1 FRANDN(1), IRANDN(1)  )                                          M23.  25
  //C
  //C!w
  //C
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void copya(
  str_cref text1,
  str_arr_ref<> text2,
  int const& kk) try
{
  text2(dimension(kk));
  //C     ROUTINE WHICH COPIES THE SAME ALPHANUMERIC WORD  'TEXT1'  INTO    M23.  31
  //C     A CONTIGUOUS REGION OF MEMORY ----  'KK'  WORDS IN LENGTH,        M23.  32
  //C     BEGINNING WITH WORD  TEXT2(1) .                                   M23.  33
  int i = fem::int0;
  FEM_DO_SAFE(i, 1, kk) {
    text2(i) = text1;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

#if 0
void
packch(
  str_arr_cref<> from, 
  str_arr_ref<> to,   
  int const& k4or6,
  int const& nchbeg,
  int const& nword)
{
  from(dimension(nword));
  to(dimension(nword));

  //C)                                                                      M23.  41
  //C)    THIS MODULE PERFORMS THE SYSTEM-DEPENDENT FUNCTION OF PACKING BCD M23.  42
  //C)    CHARACTERS FROM  A4  OR  A6  WORDS TOGETHER SO AS TO FORM A       M23.  43
  //C)    CONTIGUOUS STRING OF CHARACTERS WITHOUT EXTRA BLANK FILL.   FOR   M23.  44
  //C)    EXAMPLE, CDC HAS A 60-BIT WORD WHICH STORES 10 BCD CHARACTERS (6  M23.  45
  //C)    BITS TO A CHARACTER).   WITH PLOT ALPHANUMERIC TEXT READ UNDER  A6M23.  46
  //C)    FORMAT CONTROL, THE RIGHT-MOST FOUR CHARACTERS OF SUCH WORDS WILL M23.  47
  //C)    BE BLANK-FILLED BY THE SYSTEM.   IBM'S EIGHT CHARACTERS IN AN     M23.  48
  //C)    EIGHT-BYTE WORD POSE AN ANALOGOUS PROBLEM.   SINCE THE  CALCOMP   M23.  49
  //C)    PLOTTING SUBROUTINE CALLS WHICH APPEAR IN                         M23.  50
  //C)    THE CALLING MODULE REQUIRE CONTIGUOUS CHARACTER STRINGS, OUTPUT   M23.  51
  //C)    TEXT MUST BE COMPRESSED SO AS TO REMOVE THE WORD-LENGTH-DEPENDENT M23.  52
  //C)    BLANK FILL.   THE PRESENT SUBROUTINE IS CALLED BY THE PLOTTING    M23.  53
  //C)    CODE TO PERFORM THIS FUNCTION.   MEANING OF THE SUBROUTINE        M23.  54
  //C     ARGUMENTS IS AS FOLLOWS ......                                    M23.  55
  //C      NWORD ----- THE NUMBER OF WORDS WHICH ARE TO HAVE THEIR BCD      M23.  56
  //C                  CHARACTERS EXTRACTED, AND PACKED INTO  A CHARACTER   M23.  57
  //C                  STRING.   THIS IS A POSITIVE INTEGER.                M23.  58
  //C      FROM(1)  ----- THE FIRST OF  'NWORD'  WORDS  WHOSE BCD CONTENTS  M23.  59
  //C                     ARE TO BE PACKED.                                 M23.  60
  //C      K4OR6  ----- EQUAL TO EITHER  4  OR  6 ,  WHICHEVER IS THE NUMBERM23.  61
  //C                   OF CHARACTERS OF BCD INFORMATION WHICH IS STORED IN M23.  62
  //C                   THE WORDS   (FROM(I), I=1, NWORD) .                 M23.  63
  //C      TO(1)  ----- THE ACTIVE BCD CHARACTERS OF   (FROM(I), I=1, NWORD)M23.  64
  //C                   ARE TO BE PACKED AS A CONTIGUOUS STRING OF          M23.  65
  //C                   CHARACTERS BEGINNING WITH CHARACTER POSITION        M23.  66
  //C                   'NCHBEG'  OF WORD  TO(1) .                          M23.  67
  //C      NCHBEG  -----  THE CHARACTER POSITION OF WORD  TO(1)  WHERE THE  M23.  68
  //C                     CONTIGUOUS STRING OF BCD CHARACTERS IS TO BEGIN.  M23.  69
  //C                     NORMALLY  'NCHBEG'  IS BETWEEN  1  AND  10 ,      M23.  70
  //C                     ALTHOUGH LARGER POSITIVE VALUES ARE ALLOWED.      M23.  71
  //C                     FOR EXAMPLE, A VALUE OF  27  MEANS THAT THE CDC   M23.  72
  //C                     CHARACTER INSERTION BEGINS IN POSITION  7  OF     M23.  73
  //C                     WORD  TO(3) .                                     M23.  74
  //C!LOGICAL*1        FROM(NWORD), TO(NWORD)

  int ichar = nchbeg;
  int iword = fem::int0;
  int kchar = fem::int0;
  int jchar = fem::int0;
  FEM_DO_SAFE(iword, 1, nword) {
    FEM_DO_SAFE(kchar, 1, k4or6) {
      jchar = (iword - 1) * 8 + kchar;
      to(ichar) = from(jchar);
      ichar++;
    }
  }
}
#endif

void packch(
  str_cref from,
  ArraySpan<fem::str<8>> to,
  int const& k4or6,
  int const& nchbeg,
  int const& nword) try
{
  int ichar = nchbeg;
  int iword = fem::int0;
  int kchar = fem::int0;
  int jchar = fem::int0;
  FEM_DO_SAFE(iword, 1, nword) {
    FEM_DO_SAFE(kchar, 1, k4or6) {
      jchar = (iword - 1) * 8 + kchar;
      //to(ichar) = from(jchar);
      int irow = (ichar - 1) / 8;
      to(irow + 1)(ichar - irow * 8) = from(jchar);
      ichar++;
    }
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

//C
//C!w dummy routines
void plot(
  float const& /* x */,
  float const& /* y */,
  int const& /* i */)
{
}

void factor(
  float const& /* x */)
{
}

void newpen(
  int const& /* i */)
{
}

//C!      subroutine symbol(x,y,z,w,v,i,q,j)
//C!       return
//C!      end
//C!      subroutine axis(x,y,z,w,d,g,h,q,a)
//C!       return
//C!      end
void symbol(
  double const& /* x */,
  double const& /* y */,
  double const& /* z */,
  double const& /* w */,
  double const& /* v */,
  int const& /* i */)
{
}

//C!      subroutine axis(x,y,z,w,d,g,h,q)
//C!       return
//C!      end
void number(
  float const& /* x */,
  float const& /* y */,
  float const& /* z */,
  float const& /* w */,
  float const& /* d */,
  int const& /* i */)
{
}

void scale(
  float const& /* x */,
  float const& /* y */,
  int const& /* i */,
  int const& /* j */,
  float const& /* g */)
{
}

void line(
  float const& /* x */,
  float const& /* y */,
  int const& /* i */,
  int const& /* j */,
  int const& /* k */,
  int const& /* L */)
{
}

void series(
  common& cmn,
  int& nfour,
  int& kpl,
  int const& jplt,
  int const& maxevk) try
{
  common_write write(cmn);
  double& onehaf = cmn.onehaf;
  auto& karray = static_cast<common_c29b01&>(cmn).karray;
  //
  arr_1d<2, double> evdoub(fem::fill0);
  int n2 = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  auto& lunit6 = cmn.lunit6;
  int n4 = fem::int0;
  int n1 = fem::int0;
  int ioffa = fem::int0;
  int ioffb = fem::int0;
  int j = fem::int0;
  double pi = fem::double0;
  double an = fem::double0;
  int m = fem::int0;
  double d12 = fem::double0;
  double d7 = fem::double0;
  double c1 = fem::double0;
  double s1 = fem::double0;
  double cp = fem::double0;
  double sp = fem::double0;
  int ndx1 = fem::int0;
  int ndx2 = fem::int0;
  int L = fem::int0;
  double gk2 = fem::double0;
  double gk1 = fem::double0;
  int k = fem::int0;
  double gk = fem::double0;
  double tp = fem::double0;
  double bp = fem::double0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  double d4 = fem::double0;
  //C!EQUIVALENCE ( EVDOUB(1), KARRAY(1) )
  evdoub(1) = karray(1);
  evdoub(2) = karray(2);
  if (nfour > 0) {
    goto statement_3184;
  }
  nfour = -nfour;
  n2 = kpl;
  d1 = evdoub(kpl) - evdoub(1);
  statement_3163:
  n2 = n2 - 1;
  d2 = evdoub(n2) - evdoub(1);
  if (d1 * d2 > 0.0f) {
    goto statement_3175;
  }
  if (std::abs(d1) > std::abs(d2)) {
    n2 = n2 - 1;
  }
  write(lunit6,
    "(/,' BACK UP FINAL TIME FROM POINT NUMBER',i5,'   TO POINT NUMBER',i5,"
    "' ,   SO THAT SIGNAL WILL BE NEARLY PERIODIC.',/,"
    "' THE FOLLOWING UNUSED POINT, WHICH HAS VALUE',"
    "' CLOSEST TO POINT NUMBER 1, EQUALS',e15.6)"),
    kpl, n2, evdoub(n2 + 1);
  kpl = n2;
  goto statement_3184;
  statement_3175:
  d1 = d2;
  goto statement_3163;
  statement_3184:
  n4 = kpl / 2 + 2;
  n1 = kpl + 2 * n4;
  if (n1 <= maxevk) {
    goto statement_3209;
  }
  write(lunit6,
    "(/,' SORRY, NO FOURIER SERIES IS POSSIBLE',"
    "' DUE TO LACK OF EMTP TABLE SPACE.',i8,"
    "'   FLOATING-POINT CELLS ARE NEEDED,',/,' WHILE ONLY',i8,"
    "'   ARE AVAILABLE.   ON TO NEXT REQUEST.')"),
    n1, maxevk;
  goto statement_9000;
  statement_3209:
  ioffa = kpl;
  ioffb = kpl + n4;
  if (kpl >= 2) {
    goto statement_3216;
  }
  write(lunit6,
    "(/,' SORRY, NO FOURIER SERIES IS POSSIBLE',"
    "' DUE TO LACK OF DATA.   THE NUMBER OF',' DATA POINTS FOUND IS ONLY',i5,"
    "'  .',/,' TWO OR MORE ARE NEEDED.',' ON TO THE NEXT REQUEST.')"),
    kpl;
  goto statement_9000;
  statement_3216:
  if (jplt == 1) {
    goto statement_3226;
  }
  write(lunit6,
    "(/,' SORRY, NO FOURIER SERIES IS POSSIBLE',' DUE TO THE NAMING OF',i4,"
    "'   VARIABLES.   ONLY ONE IS ALLOWED.','  ON TO NEXT REQUEST.')"),
    jplt;
  goto statement_9000;
  statement_3226:
  write(lunit6,
    "(/,' BEGIN FOURIER SERIES CALCULATION',' USING',i6,"
    "'   EQUIDISTANT POINTS.   BEGINNING',' TWO POINTS =',/,2e20.10,9x,"
    "'ENDING TWO POINTS =',2e20.10)"),
    kpl, evdoub(1), evdoub(2), evdoub(kpl - 1), evdoub(kpl);
  if (cmn.iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' LIST OF ALL DATA POINTS FOLLOWS ....',/(1x,10e13.4))");
      FEM_DO_SAFE(j, 1, kpl) {
        wloop, evdoub(j);
      }
    }
  }
  pi = cmn.twopi * onehaf;
  an = kpl;
  an = an * onehaf;
  j = an + 1.6f;
  m = an + 1.0f;
  if (nfour > m) {
    nfour = m;
  }
  d12 = 1.0f / an;
  d7 = pi * d12;
  c1 = cosz(d7);
  s1 = sinz(d7);
  cp = 1.0f;
  sp = 0.0f;
  ndx1 = ioffa;
  ndx2 = ioffb;
  FEM_DO_SAFE(L, 1, m) {
    gk2 = 0.0f;
    gk1 = 0.0f;
    k = kpl;
    statement_4020:
    gk = evdoub(k) + cp * gk1 * 2.0f - gk2;
    gk2 = gk1;
    gk1 = gk;
    k = k - 1;
    if (k > 1) {
      goto statement_4020;
    }
    tp = (evdoub(1) + gk1 * cp - gk2) * d12;
    bp = sp * gk1 * d12;
    if (L == 1) {
      goto statement_4030;
    }
    if (L != j) {
      goto statement_4040;
    }
    bp = 0.0f;
    statement_4030:
    tp = tp * onehaf;
    statement_4040:
    ndx1++;
    ndx2++;
    evdoub(ndx1) = tp;
    evdoub(ndx2) = bp;
    karray(ndx1) = tp;
    karray(ndx2) = bp;
    tp = c1 * cp - s1 * sp;
    sp = c1 * sp + s1 * cp;
    cp = tp;
  }
  write(lunit6,
    "(/,' COEFFICIENTS OF RESULTANT FOURIER SERIES,',"
    "' WITH  \"COMPLEX AMPLITUDE\"  BEING THE SQUARE ROOT',/,"
    "' OF THE SUM OF THE SQUARES OF THE TWO',"
    "' PRECEDING ENTRIES.   THE FINAL COLUMN APPLIES',' TO THIS AMPLITUDE.',/,"
    "2x,'HARMONIC',14x,'COSINE',16x,'SINE',13x,'COMPLEX',9x,'FRACTION OF',/,"
    "4x,'NUMBER',9x,'COEFFICIENT',9x,'COEFFICIENT',11x,'AMPLITUDE',9x,"
    "'FUNDAMENTAL')");
  ndx1 = ioffa;
  ndx2 = ioffb;
  d7 = fem::pow2(evdoub(ndx1 + 2)) + fem::pow2(evdoub(ndx2 + 2));
  d7 = sqrtz(d7);
  FEM_DO_SAFE(k, 1, nfour) {
    L = k - 1;
    ndx1++;
    ndx2++;
    d5 = fem::pow2(evdoub(ndx1)) + fem::pow2(evdoub(ndx2));
    d6 = sqrtz(d5);
    d4 = d6 / d7;
    write(lunit6, "(1x,i9,3e20.10,f20.8)"), L, evdoub(ndx1), evdoub(ndx2),
      d6, d4;
  }
  write(lunit6, "(/,/,1x)");
  statement_9000:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
plots(
  int const& /* i */,
  int const& /* j */,
  int const& /* k */)
{
}

void
begplt(
  common& cmn)
{
  // COMMON cmn
  const auto& iprsov = cmn.iprsov;
  //
  if (iprsov(38) == 0) {
    plots(0, 0, 0);
  }

}

void
endplt(
  int const& /* kalcom */)
{
  //C     THIS SYSTEM-DEPENDENT MODULE IS ALWAYS CALLED ONCE AS CONTROL     M22.5714
  //C     LEAVES  'SUBR31'  DURING A NORMAL EXIT (NO ERROR STOP).           M22.5715
  //C     ARGUMENT  "KALCOM"  IS ZERO IF THE DATA CASE DID NO               M28.7012
  //C     CALCOMP PLOTTING, OR UNITY IF THERE WERE ONE OR MORE              M28.7013
  //C     SUCH PLOTS.   FOR MOST COMPUTERS, THE CALCOMP BUFFER              M28.7014
  //C     IS NOT CLOSED HERE, BUT RATHER IN  "FINTP" .                      M28.7015
}

void
fintp(
  common& cmn)
{
  // COMMON cmn
  const auto& iprsov = cmn.iprsov;
  //
  if (iprsov(38) > 0) {
    plot(0.0f, 0.0f, 999);
  }
  if (cmn.ivolt == 7777) {
    cmn.io.close(20)
      .status("DELETE");
  }

}

struct axis_save
{
  double hgt1;
  double hgt2;
  double hgt3;
  fem::str<8> text1;
  double tic;
  double ticd2;

  axis_save() :
    hgt1(fem::double0),
    hgt2(fem::double0),
    hgt3(fem::double0),
    text1(fem::char0),
    tic(fem::double0),
    ticd2(fem::double0)
  {}
};

void
axis(
  common& cmn,
  double const& xx,
  double const& yy,
  str_cref title,
  int const& numch,
  double const& size,
  double const& ang,
  double const& begin,
  double const& scale)
{
#if 0
  FEM_CMN_SVE(axis);
  common_write write(cmn);
  double& hgt1 = sve.hgt1;
  double& hgt2 = sve.hgt2;
  double& hgt3 = sve.hgt3;
  fem::str<8>& text1 = sve.text1;
  double& tic = sve.tic;
  double& ticd2 = sve.ticd2;
  if (is_called_first_time) {
    tic = .075f;
    ticd2 = .03f;
    hgt1 = 0.2f;
    hgt2 = .15f;
    hgt3 = .12f;
    text1 = "( 10**";
  }
  double d1 = fem::double0;
  double d2 = fem::double0;
  int ndig = fem::int0;
  double d3 = fem::double0;
  double scal1 = fem::double0;
  double beg1 = fem::double0;
  int length = fem::int0;
  double axmid = fem::double0;
  int nchabs = fem::int0;
  double xmax = fem::double0;
  int n3 = fem::int0;
  double d4 = fem::double0;
  auto& lunit6 = cmn.lunit6;
  //C     MODULE  'AXIS'  WAS WRITTEN BY W. SCOTT MEYER OF BPA IN JUNE OF   M14.2637
  //C     1976, ESPECIALLY FOR BPA EMTP USAGE ONLY.   ANYONE HAVING THE REALM14.2638
  //C     CALCOMP MODULE OF THE SAME NAME SHOULD DISCARD THIS PRESENT       M14.2639
  //C     APPROXIMATE EQUIVALENT.   UNFORTUNATELY, BPA DOES NOT FALL INTO   M14.2640
  //C     THIS CLASS (OUR SYSTEM PROGRAMMERS THOUGHT THEY WERE BEING CLEVER M14.2641
  //C     BY ADDING TWO MORE ARGUMENTS TO THE MODULE WHICH IS AVAILABLE IN  M14.2642
  //C     OUR SYSTEM LIBRARY).                                              M14.2643
  d1 = fem::abs(begin);
  d2 = fem::abs(begin + size * scale);
  if (d2 > d1) {
    d1 = d2;
  }
  if (d1 <= 0.0f) {
    goto statement_9000;
  }
  ndig = 0;
  statement_2313:
  if (d1 <= 1.000001f) {
    goto statement_2321;
  }
  ndig = ndig - 1;
  d1 = d1 * 0.1f;
  goto statement_2313;
  statement_2321:
  if (d1 >= .0999999f) {
    goto statement_2336;
  }
  ndig++;
  d1 = d1 * 10.f;
  goto statement_2321;
  statement_2336:
  if (ang > 0.0f) {
    goto statement_2345;
  }
  if (ndig >= 2) {
    goto statement_2345;
  }
  if (ndig <  - 3) {
    goto statement_2345;
  }
  ndig = 0;
  statement_2345:
  d3 = fem::pow(10.f, ndig);
  scal1 = scale * d3;
  beg1 = begin * d3;
  length = size + .000001f;
  axmid = size * 0.5f - 2.0f;
  d3 = -ndig;
  nchabs = fem::iabs(numch);
  if (ang > 0.0f) {
    goto statement_2506;
  }
  plot(xx, yy, 3);
  xmax = xx + size;
  plot(xmax, yy, 2);
  d2 = beg1 + length * scal1;
  statement_2427:
  d1 = xx + length;
  plot(d1, yy + tic, 3);
  plot(d1, yy - tic, 2);
  number(d1 - 0.2f, yy - 0.3f, hgt2, d2, ang, 2);
  length = length - 1;
  d2 = d2 - scal1;
  if (length > 0) {
    goto statement_2427;
  }
  d1 = yy - 0.6f;
  d2 = xx + axmid;
  symbol(d2, d1, hgt1, title, ang, nchabs);
  if (ndig == 0) {
    goto statement_2438;
  }
  d2 += 5.0f;
  symbol(d2, d1, hgt1, text1, ang, 6);
  d2 += 1.2f;
  number(d2, d1 + .07f, hgt1, d3, ang, -1);
  d2 += 0.4f;
  symbol(d2, d1, hgt1, ")", ang, 1);
  statement_2438:
  goto statement_2569;
  statement_2506:
  plot(xx, yy + size, 3);
  plot(xx, yy, 2);
  d1 = yy;
  d2 = beg1;
  n3 = 0;
  statement_2554:
  plot(xx + tic, d1, 3);
  plot(xx - ticd2, d1, 2);
  if (cmn.iprsup >= 1) {
    write(6,
      "(' BEFORE Y-AXIS CALL TO  ''NUMBER''  IN  ''AXIS'' .',13x,'XX',13x,"
      "'D1',11x,'HGT3',13x,'D2',12x,'ANG',/,46x,4e15.6)"),
      xx, d1, hgt3, d2, ang;
  }
  number(xx - 0.1f, d1 - 0.2f, hgt3, d2, ang, 3);
  d2 += scal1;
  d1 += 1.0f;
  n3++;
  if (n3 <= length) {
    goto statement_2554;
  }
  d1 = yy + axmid;
  d4 = xx - 0.3f;
  symbol(d4, d1, hgt1, title, ang, nchabs);
  if (ndig == 0) {
    goto statement_2569;
  }
  d1 += 4.0f;
  symbol(d4, d1, hgt1, text1, ang, 6);
  d1 += 1.2f;
  number(d4 - .07f, d1, hgt1, d3, ang, -1);
  d1 += 0.4f;
  symbol(d4, d1, hgt1, ")", ang, 1);
  statement_2569:
  return;
  statement_9000:
  write(lunit6,
    "(/,/,"
    "' ERROR STOP WITHIN BPA CDC MODULE  ''AXIS''  OF OVERLAY 31.     GO SEE P"
    "ROGRAM MAINTENANCE AT ONCE.')");
  stoptp(cmn);

#endif
}

void grid(
  double const& d1,
  double const& d2,
  double const& d3,
  double const& d4,
  int const& n1,
  int const& n2) try
{
  int ll2 = fem::int0;
  int ll3 = fem::int0;
  double d8 = fem::double0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  int i = fem::int0;
  int j = fem::int0;
  //C     THIS MODULE HAS BEEN WRITTEN FOR USE ONLY ON THE BPA CDC-6500     M19.2252
  //C     COMPUTER INSTALLATION, WHICH DOES NOT HAVE LEGITIMATE CALCOMP.    M19.2253
  //C     IT SIMULATES THE CALCOMP MODULE OF THE SAME NAME.   ANYONE WHO    M19.2254
  //C     HAS REAL CALCOMP PLOTTING SOFTWARE WITH THESE SUBROUTINES SHOULD  M19.2255
  //C     DESTROY THIS MODULE.        W. SCOTT MEYER, APRIL 1977.           M19.2256
  ll2 = 2;
  ll3 = 3;
  d8 = n2 * d4 + d2;
  d5 = d1;
  d6 = d2;
  i = 0;
  statement_1878:
  i++;
  if (i > n1) {
    goto statement_1972;
  }
  d5 += d3;
  plot(d5, d6, ll3);
  if (d6 > d2) {
    goto statement_1912;
  }
  d6 = d8;
  goto statement_1941;
  statement_1912:
  d6 = d2;
  statement_1941:
  plot(d5, d6, ll2);
  goto statement_1878;
  statement_1972:
  d6 = d2;
  d5 = d1;
  d8 = d1 + n1 * d3;
  j = -1;
  statement_1988:
  j++;
  if (j > n2) {
    goto statement_2029;
  }
  plot(d5, d6, ll3);
  if (d5 > d1) {
    goto statement_2005;
  }
  d5 = d8;
  goto statement_2013;
  statement_2005:
  d5 = d1;
  statement_2013:
  plot(d5, d6, ll2);
  d6 += d4;
  goto statement_1988;
  statement_2029:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct linplt_save
{
  int k;
  fem::str<4> klank;
  fem::str<4> kline;
  fem::str<4> kom;
  arr<fem::str<4>> ktsin;
  arr<fem::str<4>> kut;
  fem::str<4> kxline;
  arr<int> max5;
  arr<int> min5;

  linplt_save() :
    k(fem::int0),
    klank(fem::int0),
    kline(fem::int0),
    kom(fem::int0),
    ktsin(dimension(4), fem::fill0),
    kut(dimension(131), fem::fill0),
    kxline(fem::fill0),
    max5(dimension(4), fem::fill0),
    min5(dimension(4), fem::fill0)
  {}
};

void linplt(
  common& cmn,
  int const& krv,
  int const& klm) try
{
  FEM_CMN_SVE(linplt);
  common_write write(cmn);
  auto& k = sve.k;
  auto& klank = sve.klank;
  auto& kline = sve.kline;
  auto& kom = sve.kom;
  auto& ktsin = sve.ktsin;
  auto& kut = sve.kut;
  auto& kxline = sve.kxline;
  auto& max5 = sve.max5;
  auto& min5 = sve.min5;

  if (is_called_first_time) {
    ktsin(1) = "A";
    ktsin(2) = "B";
    ktsin(3) = "C";
    ktsin(4) = "D";
    kom = "*";
    kline = "1";
    klank = " ";
    kxline = "-";
    kut(1) = " ";
    min5(1) = 0;
    max5(1) = 0;
    k = 0;
  }
  int jgo = fem::int0;
  int j = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int jmin = fem::int0;
  int jmax = fem::int0;
  int i = fem::int0;
  static const char* format_230 = "(1x,131a1)";
  static const char* format_250 = "('+',131a1)";
  //C                                                                       M10. 276
  //C****** THIS IS THE STANDARD VERSION OF LINPLT ******                   M10. 277
  //C                                                                       M10. 278
  //C)       LINPLT IS THE LINE PRINTER PLOT SUBROUTINE.  IT FILLS AND      M15.1454
  //C)    PRINTS AN OUTPUT ARRAY,  KUT , WITH THE NECESSARY SYMBOLS FROM THEM15.1455
  //C)    ARRAY KTSIN.  THE POSITION AND TYPE OF SYMBOL IS DETERMINED IN THEM15.1456
  //C)    CALLING SUBROUTINE,  =SUBR31= .                                   M15.1457
  //C        BEFORE PRINTING, FOR EACH CURVE,  LINPLT  FILLS THE COLUMNS BE-M10. 283
  //C     TWEEN THE MINIMUM AND MAXIMUM POINTS WITH THE CORRESPONDING SYM-  M10. 284
  //C     BOL.  IF A DIFFERENT CURVE SYMBOL IS ENCOUNTERED, THE COMMON      M10. 285
  //C     SYMBOL  *  IS INSERTED.  THIS PROCEDURE INSURES THAT =SPIKES= WILLM10. 286
  //C     APPEAR AS A LINE OF SYMBOLS.   ARRAYS  =MAX=  AND  =MIN=  ARE USEDM10. 287
  //C     FOR THIS PURPOSE.   BUT X-Y PRINTER PLOT BYPASSES THIS,           M28.7016
  //C     VIA  KRV = 77  SPECIAL FLAG.                                      M28.7017
  //C        IMMEDIATELY AFTER PRINTING, THE ARRAY IS BLANKED, TO BE READY  M10. 289
  //C     FOR THE NEXT LINE OF DATA POINTS, BEFORE RETURNING.               M10. 290
  //C        THE NORMAL RANGE OF VALUES FOR THE CALLING ARGUMENTS ARE --    M10. 291
  //C             KRV  1 TO 4   ( INCLUSIVE )                               M10. 292
  //C             KLM  1 TO 131 ( INCLUSIVE )                               M10. 293
  //C     WHEN CALLED WITH THESE VALUES,  LINPLT  WILL PLACE THE =KRV= CURVEM10. 294
  //C     SYMBOL IN THE =KLM= COLUMN OF THE OUTPUT ARRAY, UNLESS THAT COLUMNM10. 295
  //C     ALREADY CONTAINS A DIFFERENT KRV SYMBOL, IN WHICH CASE THE COMMON M10. 296
  //C     SYMBOL IS USED.                                                   M10. 297
  //C        THE SPECIAL VALUES OF KRV AND KLM ARE --                       M10. 298
  //C          KRV = -1   PLACE THE TIME AXIS LINE SYMBOL, 1, IN THE KLM    M10. 299
  //C                     COLUMN OF THE ARRAY.  THIS SYMBOL IS ERASED BY ANYM10. 300
  //C                     SUBSEQUENT CURVE SYMBOL.                          M10. 301
  //C          KRV = 0    THE FIRST CALL TO LINPLT USES THIS AND A DUMMY    M10. 302
  //C                     ARGUMENT FOR KLM TO INITIALIZE LINPLT.  THE ORDI- M10. 303
  //C                     NATE AXIS AND TIC MARKS ARE PRINTED.  THE FIRST   M10. 304
  //C                     OUTPUT LINE OF DATA WILL OVERWRITE THE AXIS.      M10. 305
  //C          KLM = -1   THIS AND A DUMMY ARGUMENT FOR KRV CAUSES THE OUT- M10. 306
  //C                     PUT ARRAY TO BE PRINTED.                          M10. 307
  //C          KRV = 99   PLACES THE INTERSECTION SYMBOL  "*"               M28.7018
  //C                     (VARIABLE KOM) IN COLUMN  KLM.                    M28.7019
  //C          KRV = 77   BYPASSES THE VERTICAL FILL BETWEEN MIN            M28.7020
  //C                     AND MAX, JUST BEFORE PRINTING.                    M28.7021
  //C                                                                       M10. 308
  //C
  //C     BURROUGHS: PRESERVE LOCAL VARIABLE BETWEEN MODULE CALLS:          M32.7606
  //C     BURROUGHS: PRESERVE LOCAL VARIABLE BETWEEN MODULE CALLS:          M35.8873
  if (krv == 99) {
    goto statement_407;
  }
  jgo = 4;
  if (krv ==  - 1) {
    jgo = 1;
  }
  if (krv == 0) {
    jgo = 2;
  }
  if (klm ==  - 1) {
    jgo = 3;
  }
  switch (jgo) {
    case 1: goto statement_100;
    case 2: goto statement_200;
    case 3: goto statement_300;
    case 4: goto statement_400;
    default: break;
  }
  statement_100:
  kut(klm) = kline;
  goto statement_999;
  statement_200:
  k = 1;
  FEM_DO_SAFE(j, 1, 131) {
    kut(j) = klank;
  }
  FEM_DOSTEP(j, 1, 131, 10) {
    kut(j) = kline;
  }
  write(lunit6, format_230), kut;
  FEM_DO_SAFE(j, 1, 131) {
    kut(j) = kxline;
  }
  write(lunit6, format_250), kut;
  goto statement_350;
  statement_300:
  if (krv == 77) {
    goto statement_334;
  }
  FEM_DO_SAFE(j, 1, 4) {
    jmin = min5(j);
    if (jmin == 132) {
      goto statement_330;
    }
    jmax = max5(j);
    if (jmin == jmax) {
      goto statement_330;
    }
    FEM_DO_SAFE(i, jmin, jmax) {
      if (kut(i) == ktsin(j)) {
        goto statement_320;
      }
      if (kut(i) == klank) {
        goto statement_310;
      }
      if (kut(i) == kline) {
        goto statement_310;
      }
      kut(i) = kom;
      goto statement_320;
      statement_310:
      kut(i) = ktsin(j);
      statement_320:;
    }
    statement_330:;
  }
  statement_334:
  if (k == 0) {
    goto statement_340;
  }
  k = 0;
  write(lunit6, format_250), kut;
  goto statement_350;
  statement_340:
  write(lunit6, format_230), kut;
  statement_350:
  FEM_DO_SAFE(j, 1, 4) {
    max5(j) = 1;
    min5(j) = 132;
  }
  FEM_DO_SAFE(j, 1, 131) {
    kut(j) = klank;
  }
  goto statement_999;
  statement_400:
  if (klm > max5(krv)) {
    max5(krv) = klm;
  }
  if (klm < min5(krv)) {
    min5(krv) = klm;
  }
  if (kut(klm) == ktsin(krv)) {
    goto statement_999;
  }
  if (kut(klm) == klank) {
    goto statement_410;
  }
  if (kut(klm) == kline) {
    goto statement_410;
  }
  statement_407:
  kut(klm) = kom;
  goto statement_999;
  statement_410:
  kut(klm) = ktsin(krv);
  statement_999:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void advanz(
  int& jhmsp)
{
  //C)    THE REAL (I.E., NON-DUMMY) SUBROUTINE ADVANZ IS USED WITH BPA'S   M15.1467
  //C)    EAI FLATBED PLOTTER, TO ROLL  'JHMSP'  INCHES OF NEW PAPER ONTO   M15.1468
  //C)    THE PLOTTING TABLE, MAKING ROOM FOR THE UPCOMING PLOT TO BE       M15.1469
  //C)    DRAWN.   BUT WITH REGULAR CALCOMP DRUM PLOTTING (WHERE THERE IS   M15.1470
  //C)    NO TABLE, AS SUCH), THE PRESENT REPLACEMENT MODULE SHOULD BE USED,M15.1471
  //C)    WHICH HAS TWO EFFECTS.   FIRST, THE ROLLING OF THE PAPER IS       M15.1472
  //C)    BYPASSED, OF COURSE.   ALSO, BY SETTING  'JHMSP'  TO ZERO, THE    M15.1473
  //C)    ASSOCIATED PLOT ORIGIN-CHANGING IS EFFECTIVELY DISABLED.          M15.1474
  jhmsp = 0;
}

void prnthd(
  int const& /* n1 */)
{
  //C)    THE REAL (I.E., NON-DUMMY) SUBROUTINE PRNTHD IS USED WITH BPA'S   M15.1475
  //C)    EAI FLATBED PLOTTER.   IT IS ASSOCIATED WITH THE PRINTHEAD FEATUREM15.1476
  //C)    OF THE EAI PLOTTER, WHERE ALPHANUMERIC CHARACTERS MAY BE TYPED    M15.1477
  //C)    RATHER THAN DRAWN WITH THE PEN, IN ORDER TO SPEED UP THE PLOTTING M15.1478
  //C)    OPERATION.   SUBROUTINE PRNTHD IS CALLED WITH DIFFERENT VALUES    M15.1479
  //C)    FOR THE ARGUMENT  'N1'  IN ORDER TO CHANGE MODES ON THIS          M15.1480
  //C)    PRINTHEAD USAGE, AS FOLLOWS ......                                M15.1481
  //C)           0  -----  DRAWN CHARACTERS, USING THE PEN.                 M15.1482
  //C)           1  -----  HORIZONTALLY-TYPED LETTERING                     M15.1483
  //C)           2  -----  VERTICALLY-TYPED LETTERING                       M15.1484
  //C)    FOR REGULAR CALCOMP DRUM PLOTTING WHERE ALL CHARACTERS MUST BE    M15.1485
  //C)    DRAWN WITH THE PEN, LEAVE IN THIS DUMMY SUBROUTINE AS IT IS       M15.1486
  //C)    WRITTEN HERE.   CALLING IT WILL DO NOTHING, OF COURSE.            M15.1487
}

struct subr31_save
{
  int kscale;
  int ll0;
  int ll1;
  int ll10;
  int ll16;
  int ll18;
  int ll2;
  int ll24;
  int ll3;
  int ll6;
  int ll78;
  int llmin1;
  int llmin3;
  fem::str<8> text1;
  fem::str<8> text10;
  fem::str<8> text11;
  fem::str<8> text12;
  fem::str<8> text13;
  arr<fem::str<8> > text14;
  fem::str<8> text15;
  arr<fem::str<8> > text16;
  fem::str<8> text18;
  fem::str<8> text19;
  fem::str<8> text2;
  fem::str<8> text20;
  fem::str<8> text22;
  fem::str<8> text23;
  fem::str<8> text24;
  fem::str<8> text25;
  fem::str<8> text26;
  fem::str<8> text27;
  fem::str<8> text28;
  fem::str<8> text29;
  fem::str<8> text3;
  fem::str<8> text30;
  fem::str<8> text31;
  fem::str<8> text32;
  fem::str<8> text33;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;
  fem::str<8> text8;
  fem::str<8> text9;
  arr<fem::str<8> > textax;

  subr31_save() :
    kscale(fem::int0),
    ll0(fem::int0),
    ll1(fem::int0),
    ll10(fem::int0),
    ll16(fem::int0),
    ll18(fem::int0),
    ll2(fem::int0),
    ll24(fem::int0),
    ll3(fem::int0),
    ll6(fem::int0),
    ll78(fem::int0),
    llmin1(fem::int0),
    llmin3(fem::int0),
    text1(fem::char0),
    text10(fem::char0),
    text11(fem::char0),
    text12(fem::char0),
    text13(fem::char0),
    text14(dimension(2), fem::fill0),
    text15(fem::char0),
    text16(dimension(2), fem::fill0),
    text18(fem::char0),
    text19(fem::char0),
    text2(fem::char0),
    text20(fem::char0),
    text22(fem::char0),
    text23(fem::char0),
    text24(fem::char0),
    text25(fem::char0),
    text26(fem::char0),
    text27(fem::char0),
    text28(fem::char0),
    text29(fem::char0),
    text3(fem::char0),
    text30(fem::char0),
    text31(fem::char0),
    text32(fem::char0),
    text33(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0),
    text8(fem::char0),
    text9(fem::char0),
    textax(dimension(32), fem::fill0)
  {}
};

// over31 -> subr31 for ploting on creen - no need

void subr31(
  common& cmn)
{
  cmn.nchain = 51;  //
#if 0
  FEM_CMN_SVE(subr31);
  common_read read(cmn);
  common_write write(cmn);
  auto& bus1 = cmn.bus1;
  auto& bus2 = cmn.bus2;
  auto& bus3 = cmn.bus3;
  auto& bus4 = cmn.bus4;
  auto& bus5 = cmn.bus5;
  auto& bus6 = cmn.bus6;
  auto& trash = cmn.trash;
  auto& blank = cmn.blank;
  const auto& texta6 = cmn.texta6;
  auto& date1= cmn.date1;
  auto& tclock= cmn.tclock;
  const auto& abuff = cmn.abuff;
  double& tmax = cmn.tmax;
  double& szplt = cmn.szplt;
  double& szbed = cmn.szbed;
  double& flzero = cmn.flzero;
  double& degmax = cmn.degmax;
  double& statfr = cmn.statfr;
  auto& voltbc = cmn.voltbc;
  //auto& moncar = cmn.moncar;
  int& lunit4 = cmn.lunit4;
  int& lunt13 = cmn.lunt13;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  auto& iprsov= cmn.iprsov;
  int& iout = cmn.iout;
  int& iplot = cmn.iplot;
  int& nsmth = cmn.nsmth;
  int& lastov = cmn.lastov;
  int& isprin = cmn.isprin;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& lnpin = cmn.lnpin;
  int& nc = cmn.nc;
  int& numnvo = cmn.numnvo;
  //arr_ref<int> karray(static_cast<common_c29b01&>(cmn).karray,
  //  dimension(1992869));
  int& kalcom = cmn.kalcom;
  //
  int& kscale = sve.kscale;
  int& ll0 = sve.ll0;
  int& ll1 = sve.ll1;
  int& ll16 = sve.ll16;
  int& ll2 = sve.ll2;
  int& ll24 = sve.ll24;
  int& ll3 = sve.ll3;
  int& ll6 = sve.ll6;
  int& llmin1 = sve.llmin1;
  int& llmin3 = sve.llmin3;
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text10 = sve.text10;
  fem::str<8>& text11 = sve.text11;
  fem::str<8>& text12 = sve.text12;
  fem::str<8>& text13 = sve.text13;
  str_arr_ref<1> text14(sve.text14, dimension(2));
  fem::str<8>& text15 = sve.text15;
  str_arr_ref<1> text16(sve.text16, dimension(2));
  fem::str<8>& text18 = sve.text18;
  fem::str<8>& text19 = sve.text19;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text20 = sve.text20;
  fem::str<8>& text22 = sve.text22;
  fem::str<8>& text23 = sve.text23;
  fem::str<8>& text24 = sve.text24;
  fem::str<8>& text25 = sve.text25;
  fem::str<8>& text26 = sve.text26;
  fem::str<8>& text27 = sve.text27;
  fem::str<8>& text28 = sve.text28;
  fem::str<8>& text29 = sve.text29;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text30 = sve.text30;
  fem::str<8>& text31 = sve.text31;
  fem::str<8>& text32 = sve.text32;
  fem::str<8>& text33 = sve.text33;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  fem::str<8>& text7 = sve.text7;
  fem::str<8>& text8 = sve.text8;
  fem::str<8>& text9 = sve.text9;
  str_arr_ref<1> textax(sve.textax, dimension(32));
  if (is_called_first_time) {
    text1 = "PRINT ";
    text2 = "HEAD O";
    text3 = "N     ";
    text4 = "FF    ";
    text5 = "SMOOTH";
    text6 = "BRANCH";
    text7 = "HEIGHT";
    text8 = "MARGIN";
    text9 = "CALCOM";
    text10 = "P PLOT";
    text11 = "PRINTE";
    text12 = "R PLOT";
    text13 = "P PRIN";
    text14(1) = "PLOT T";
    text14(2) = "YPE   ";
    text15 = "PAGE  ";
    text16(1) = "NODE N";
    text16(2) = "AMES  ";
    text18 = "PEN CH";
    text19 = "OICE  ";
    text20 = "A1    ";
    text22 = "PLOT L";
    text23 = "INE LI";
    text24 = "MIT   ";
    text25 = "SUPERI";
    text26 = "MPOSE ";
    text27 = "SCALE ";
    text28 = "X-Y PL";
    text29 = "OT    ";
    text30 = "FOURIE";
    text31 = "R ON  ";
    text32 = "R OFF ";
    text33 = "BOUNDS";
    textax(1) = "DEGREE";
    textax(2) = "S BASE";
    textax(3) = "D ON 6";
    textax(4) = "0 HZ  ";
    textax(5) = "CYCLES";
    textax(6) = " BASED";
    textax(7) = " ON 60";
    textax(8) = " HZ   ";
    textax(9) = "SECOND";
    textax(10) = "S     ";
    textax(11) = "      ";
    textax(12) = "      ";
    textax(13) = "MILLIS";
    textax(14) = "ECONDS";
    textax(15) = "      ";
    textax(16) = "      ";
    textax(17) = "MICROS";
    textax(18) = "ECONDS";
    textax(19) = "      ";
    textax(20) = "      ";
    textax(21) = "FREQUE";
    textax(22) = "NCY IN";
    textax(23) = " HERTZ";
    textax(24) = "      ";
    textax(25) = "LOG10 ";
    textax(26) = "FREQUE";
    textax(27) = "NCY IN";
    textax(28) = " HERTZ";
    textax(29) = "SPACE ";
    textax(30) = "FOR   ";
    textax(31) = "X-Y   ";
    textax(32) = "PLOT  ";
    kscale = 0;
    llmin3 = -3;
    llmin1 = -1;
    ll0 = 0;
    ll1 = 1;
    ll2 = 2;
    ll3 = 3;
    ll6 = 6;
    sve.ll10 = 10;
    ll16 = 16;
    sve.ll18 = 18;
    ll24 = 24;
    sve.ll78 = 78;
  }
  auto& lunit6 = cmn.lunit6;
  //auto& kunit6 = lunit6;
  arr_1d<1, fem::str<8> > blanka(fem::fill0);
  //fem::str<8> blanka(fem::fill0);
  int long1 = fem::int0;
  arr_1d<150, double> xin(fem::fill0);
  //double tstep = fem::double0;
  //arr_1d<6, fem::str<8> > busvec(fem::fill0);
  //int kbase = fem::int0;
  arr_1d<20, int> lltemp(fem::fill0);
  int i = fem::int0;
  int maxev = fem::int0;
  double c1e12 = fem::double0;
  double zero = fem::double0;
  double one = fem::double0;
  double hgt1 = fem::double0;
  double hgt2 = fem::double0;
  double fourth = fem::double0;
  double half = fem::double0;
  double fl1p5 = fem::double0;
  double fltwo = fem::double0;
  double fl2p5 = fem::double0;
  double fl3 = fem::double0;
  double fl3p5 = fem::double0;
  double fl10 = fem::double0;
  double fl90 = fem::double0;
  int mmmin1 = fem::int0;
  int mm0 = fem::int0;
  int mm1 = fem::int0;
  int mm2 = fem::int0;
  int mm3 = fem::int0;
  int mm4 = fem::int0;
  int mm6 = fem::int0;
  int mm7 = fem::int0;
  int mm8 = fem::int0;
  int mm9 = fem::int0;
  int mm11 = fem::int0;
  int mm13 = fem::int0;
  arr_1d<9, double> xyplot(fem::fill0);
  double tolrce = fem::double0;
  double vs = fem::double0;
  double vhs = fem::double0;
  double vh = fem::double0;
  double taxmax = fem::double0;
  double vploff = fem::double0;
  int mrgn = fem::int0;
  int kbound = fem::int0;
  int mpage = fem::int0;
  int kpgrid = fem::int0;
  arr_1d<5, int> mulplt(fem::fill0);
  int linlim = fem::int0;
  int limbin = fem::int0;
  int jdumy = fem::int0;
  int j = fem::int0;
  arr_1d<4, int> kpen(fem::fill0);
  int kprhd = fem::int0;
  int nfour = fem::int0;
  int long2 = fem::int0;
  int long3 = fem::int0;
  arr_1d<13, fem::str<8> > cstxt(fem::fill0);
  arr_1d<13, fem::str<8> > sext(fem::fill0);
  //arr<fem::str<8> > sext(dimension(13), fem::fill0);
  vectorEx<fem::str<8> > pltle(52, "");
  double countp = fem::double0;
  int ialf = fem::int0;
  int itp = fem::int0;
  arr_1d<13, fem::str<8> > aupper(fem::fill0);
  arr_1d<4, int> isww(fem::fill0);
  double d4 = fem::double0;
  double d4fact = fem::double0;
  int maxevk = fem::int0;
  int n8 = fem::int0;
  arr_1d<52, fem::str<8> > alpha(fem::fill0);
  int j1 = fem::int0;
  int k = fem::int0;
  arr_1d<8, fem::str<8> > slot(fem::fill0);
  int jslot = fem::int0;
  int icp = fem::int0;
  int ihs = fem::int0;
  double hpi = fem::double0;
  double hmin = fem::double0;
  double hmax = fem::double0;
  double vmin = fem::double0;
  double vmax = fem::double0;
  double flong1 = fem::double0;
  int ncrv = fem::int0;
  double d1 = fem::double0;
  double vsnew = fem::double0;
  arr_1d<3, fem::str<8> > headl(fem::fill0);
  arr_1d<3, fem::str<8> > vertl(fem::fill0);
  double d23 = fem::double0;
  double hpil = fem::double0;
  int kikoy = fem::int0;
  double vmaxr = fem::double0;
  double vminr = fem::double0;
  double tmult = fem::double0;
  int mhoriz = fem::int0;
  arr_1d<4, fem::str<8> > horzl(fem::fill0);
  double ha = fem::double0;
  arr_1d<150, int> intd8(fem::fill0);
  int numnam = fem::int0;
  int numbco = fem::int0;
  int jcnt = fem::int0;
  arr_1d<1, fem::str<8> > buslst(fem::fill0);
  int iofibr = fem::int0;
  int iofjbr = fem::int0;
  int iofbus = fem::int0;
  int n4 = fem::int0;
  //arr_1d<1, int> ibsout(fem::fill0);
  int n1 = fem::int0;
  int n2 = fem::int0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  arr_1d<150, int> intd9(fem::fill0);
  int n11 = fem::int0;
  int n12 = fem::int0;
  //arr_1d<1, int> ibrnch(fem::fill0);
  //arr_1d<1, int> jbrnch(fem::fill0);
  arr_1d<3, fem::str<8> > daytim(fem::fill0);
  int numbvo = fem::int0;
  int jplt = fem::int0;
  int L = fem::int0;
  arr_1d<4, int> mplot(fem::fill0);
  int lplt = fem::int0;
  int jbegbc = fem::int0;
  int ib = fem::int0;
  int il = fem::int0;
  int n7 = fem::int0;
  int n3 = fem::int0;
  int jplt2 = fem::int0;
  int kpl = fem::int0;
  int kplt = fem::int0;
  int iovfl = fem::int0;
  int iend = fem::int0;
  double evmx = fem::double0;
  double vmaxl = fem::double0;
  double vminl = fem::double0;
  arr_1d<4, int> iswx(fem::fill0);
  arr_1d<4, double> evh(fem::fill0);
  arr_1d<4, double> evdh(fem::fill0);
  int n9 = fem::int0;
  int ndx1 = fem::int0;
  arr_1d<2, double> ev(fem::fill0);
  double tsing = fem::double0;
  arr_1d<150, double> bxsing(fem::fill0);
  //arr_1d<1, double> bx(fem::fill0);
  int jk = fem::int0;
  double evp = fem::double0;
  double evdp = fem::double0;
  arr_1d<4, int> itimes(fem::fill0);
  int ip1 = fem::int0;
  double stp = fem::double0;
  int jstp = fem::int0;
  double a = fem::double0;
  double evmxf = fem::double0;
  int jsl = fem::int0;
  int jchar = fem::int0;
  double dx = fem::double0;
  double dy = fem::double0;
  double dxl = fem::double0;
  double dxl2 = fem::double0;
  double dyl = fem::double0;
  int jpts = fem::int0;
  int lnflg = fem::int0;
  int ipl1 = fem::int0;
  int ipl2 = fem::int0;
  int jovfl = fem::int0;
  int lnck = fem::int0;
  double d2 = fem::double0;
  double expnt = fem::double0;
  double d3 = fem::double0;
  arr_1d<14, double> vrtnum(fem::fill0);
  int lcnt = fem::int0;
  double hpt = fem::double0;
  int jcol = fem::int0;
  int mdpt = fem::int0;
  int n10 = fem::int0;
  int m = fem::int0;
  int jalf = fem::int0;
  double d7 = fem::double0;
  double d6 = fem::double0;
  double d5 = fem::double0;
  arr_1d<2, fem::str<8> > arch10(fem::fill0);
  double ricp = fem::double0;
  double vhs1 = fem::double0;
  arr_1d<8, double> xyshor(fem::fill0);
  int j2 = fem::int0;
  double dlen = fem::double0;
  double dstrt = fem::double0;
  int jend = fem::int0;
  int kend = fem::int0;
  arr_1d<4, int> jpntr(fem::fill0);
  double hlo = fem::double0;
  double hhi = fem::double0;
  int kold = fem::int0;
  int klm = fem::int0;
  int ktrm = fem::int0;
  double hhpt = fem::double0;
  arr_1d<4, int> kpltq(fem::fill0);
  int ibase = fem::int0;
  int istore = fem::int0;
  int indx = fem::int0;
  double vold = fem::double0;
  double evbasx = fem::double0;
  double evbasy = fem::double0;
  int ipontr = fem::int0;
  double hvec = fem::double0;
  double vvec = fem::double0;
  double denom = fem::double0;
  double hdif = fem::double0;
  double vnew = fem::double0;
  double vdif = fem::double0;
  double term = fem::double0;
  double enumr = fem::double0;
  double disqr = fem::double0;
  double vchnge = fem::double0;
  double d9 = fem::double0;
  int ipl = fem::int0;
  double d8 = fem::double0;
  double hms = fem::double0;
  int jhmsp = fem::int0;
  int jhms = fem::int0;
  static const char* format_1182 = "('+** PLOT CARD.',2x,3e11.3)";
  static const char* format_1224 =
    "(5x,'NOTE ----- A TIME SCALE OF ',e13.4,"
    "' WAS READ FROM COLUMNS 5-7 OF THE PRECEDING PLOT-REQUEST CARD.',/,5x,"
    "'TOGETHER WITH THE REQUESTED MINIMUM OF ',e13.4,"
    "' UNITS (READ FROM COLUMNS 8-11) AND THE REQUESTED',/,5x,'MAXIMUM OF ',"
    "e13.4,' UNITS (READ FROM COLUMNS 12-15), THIS IMPLIES A PLOT OF LENGTH ',"
    "e13.4)";
  static const char* format_1621 =
    "(5x,'THE USER IS REMINDED THAT CORRECT SPELLING AND THE CONSISTENT POSITI"
    "ONING OF ALL BLANKS WITHIN THE DATA',/,5x,"
    "'FIELDS OF WIDTH 6 FOR ALL BUS NAMES IS REQUIRED.')";
  static const char* format_310 =
    "(' ****THE NUMBER OF LINES PRINTED FOR THIS PLOT REQUEST NOW EXCEEDS THE "
    "TOTAL NUMBER OF DATA POINTS.')";
  static const char* format_3105 = "('+',1x,f8.6)";
  static const char* format_3121 = "('+',2x,e9.3)";
  static const char* format_5979 = "(' EV READ FROM LOGICAL 9',i10)";
  static const char* format_7381 = "(24x,3i8)";
  static const char* format_7641 = "(10e8.0)";
  //C     FLAG-1.   BEGIN CLASS-1  /BLANK/  VARIABLES                       M10.   1
  //C     FLAG-2.   BEGIN CLASS-2  /BLANK/  VARIABLES                       M10.   3
  //C               (FLOATING-POINT NUMERIC USAGE ONLY, WITH SCALARS        M10.   4
  //C                PRECEDING ARRAYS).                                     M10.   5
  //C     FLAG-3.   BEGIN CLASS-3  /BLANK/  VARIABLES                       M10.   7
  //C               (INTEGER-NUMERIC USAGE ONLY, WITH ARRAYS                M10.   8
  //C                PRECEDING SCALARS).                                    M10.   9
  //C
  //C     DECLARATION2   INTD8, INTD9, MAXEV, KARRAY, LLTEMP                M22.5511
  //C     DECLARATION2   LONG1, LONG2, LONG3, JHMSP                         M28.6630
  //C     DECLARATION2   MMMIN1, MM0, MM1, MM2, MM3, MM4, MM6               M29.2673
  //C     DECLARATION2   MM7, MM8, MM9, MM11, MM13                          M28.6632
  //C!w EQUIVALENCE  ( TSTEP, XIN(1) ),     ( BX(1), XIN(2) )
  //C!w      EQUIVALENCE  ( KARRAY(1), EV(1), BUSLST(1),                    M22.5514
  //C!w     1    IBSOUT(1), IBRNCH(1), JBRNCH(1)  )                          M28.6635
  //C!EQUIVALENCE  ( BUSVEC(1), BUS1 )
  //C!EQUIVALENCE   ( MONCAR(2), KBASE )
  auto& kunit6 = lunit6;
  blanka(1) = blank;
  long1 = nchain;
  auto& tstep = xin(1);
  auto& kbase = cmn.moncar(2);
  auto& ibsout = cmn.karray;
  auto& ibrnch = cmn.karray;
  auto& jbrnch = cmn.karray;
  ArraySpan EV(reinterpret_cast<double*>(&cmn.karray(1)), cmn.karray.size() / 2);
  auto& BUSLST = EV;

  if (cmn.kburro == 1) {
    long1 = 29;
  }
  dimens(lltemp(1), long1, trash, trash);
  FEM_DOSTEP(i, 1, 9999, 2) {
    if (lltemp(i) != 0) {
      goto statement_5654;
    }
    maxev = lltemp(i + 1) * nbyte(6) / nbyte(5);
    goto statement_5655;
    statement_5654:;
  }
  stoptp(cmn);
  statement_5655:
  maxev = maxev - 8;
  c1e12 = 1.e36f;
  //C     THE FOLLOWING VARIABLES ARE USED AS FLOATING-POINT ARGUMENTS OF   M09.  90
  //C     CALCOMP SUBROUTINE CALLS.   THEY ARE JUST CONSTANTS, WHICH ARE    M09.  91
  //C     DEFINED USING EQUAL SIGNS SO EITHER SINGLE OR DOUBLE PRECISION    M09.  92
  //C     IS POSSIBLE WITHOUT PROGRAM CHANGES.                              M09.  93
  zero = 0.0f;
  one = 1.0f;
  hgt1 = 0.12f;
  hgt2 = 0.2f;
  fourth = .25f;
  half = 0.5f;
  fl1p5 = 1.5f;
  fltwo = 2.0f;
  fl2p5 = 2.5f;
  fl3 = 3.0f;
  fl3p5 = 3.5f;
  fl10 = 10.0f;
  fl90 = 90.f;
  //C     OTHER CALCOMP ARGUMENTS ARE LISTED HERE JUST FOR CONVENIENCE .... M09. 107
  //C     COUNTP, DLEN, DSTRT, DY, HPI, RICP, SZBED, SZPLT, VMIN, VHS, VHS1 M09. 108
  //C     THE FOLLOWING ARE LONG INTEGERS (MAY BE DOUBLE LENGTH),           M28.6663
  //C     USED AS ARGUMENTS OF NON-CALCOMP SUBROUTINE CALLS.  "MM"          M28.6664
  mmmin1 = -1;
  mm0 = 0;
  mm1 = 1;
  mm2 = 2;
  mm3 = 3;
  mm4 = 4;
  mm6 = 6;
  mm7 = 7;
  mm8 = 8;
  mm9 = 9;
  mm11 = 11;
  mm13 = 13;
  xyplot(1) = 0.0f;
  tolrce = .0001f;
  vs = 1.0f;
  vhs = 8.0f;
  vh = 10.0f;
  taxmax = 0.0f;
  vploff = 0.0f;
  mrgn = 2;
  kbound = 0;
  iout = 1;
  mpage = 0;
  kpgrid = 0;
  mulplt(1) = 0;
  linlim = 100;
  //C     DIMENSION OF BUFFER INTEGER ARRAYS   'INTD8'  AND  'INTD9' .      M20.4903
  limbin = 150;
  jdumy = 999;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' BEGIN  ''SUBR31'' .  LLBUFF    KILL   LNPIN   NSMTH',10x,'SZBED',"
      "10x,'SZPLT',5x,'DATE1',4x,'TCLOCK',/,18x,4i8,2e15.5,2(2x,2a4))"),
      cmn.llbuff, kill, lnpin, nsmth, szbed, szplt, date1, tclock;
  }
  FEM_DO_SAFE(j, 1, 4) {
    kpen(j) = 1;
  }
  kprhd = 1;
  nfour = 0;
  kalcom = 0;
  if (kill == 9999) {
    goto statement_2740;
  }
  long1 = 6;
  long2 = 1;
  long3 = 1;
  FEM_DO_SAFE(i, 1, 13) {
    cstxt(i) = blank;
    packch(blanka(1), ArraySpan(sext.begin(), sext.size()), long1, long2, long3);
    long2 += 6;
  }
  FEM_DO_SAFE(j, 1, 52) {
    pltle(j) = blank;
  }
  countp = 0.0f;
  if (iprsup >= 1) {
    write(lunit6, "(/,' VECTOR  ''SEXT''  AS  13A6 .',13a6,/,1x,13a6)"), sext;
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.2684
  statement_1000:
  cmn.io.rewind(lunit4);
  if (iout >= 2) {
    write(lunit6, "(/,/,/,1x)");
  }
  tstep = 0.0f;
  xin(1) = tstep;
  ialf = 0;
  //C     READ INPUT CARD USING CIMAGE                                      M09. 162
  statement_1050:
  cimage(cmn);
  read(abuff, "(i2,13a6)"), itp, aupper;
  if (iplot < 0) {
    goto statement_1070;
  }
  if (lunit4 <= 0) {
    goto statement_1070;
  }
  if (aupper(1) != text15) {
    goto statement_10452;
  }
  mpage = 1;
  goto statement_1050;
  statement_10452:
  if (aupper(1) != text9) {
    goto statement_1052;
  }
  if (aupper(2) != text10) {
    goto statement_1054;
  }
  iout = 1;
  write(kunit6, "('+REQUEST FOR CALCOMP PLOT.')");
  goto statement_1050;
  statement_1052:
  if (aupper(1) != text11) {
    goto statement_1061;
  }
  if (aupper(2) != text12) {
    goto statement_1061;
  }
  iout = 2;
  write(kunit6, "('+REQUEST FOR LINE PRINTER PLOT.')");
  goto statement_1050;
  statement_1054:
  if (aupper(2) != text13) {
    goto statement_1061;
  }
  iout = 3;
  write(kunit6, "('+REQUEST FOR CALCOMP AND LINE PRINTER PLOTS.')");
  goto statement_1050;
  statement_1061:
  if (aupper(1) != text1) {
    goto statement_1067;
  }
  if (aupper(2) != text2) {
    goto statement_1067;
  }
  if (aupper(3) != text3) {
    goto statement_1064;
  }
  kprhd = 1;
  write(kunit6, "('+REQUEST FOR TYPING OF PLOT CHARACTERS.')");
  goto statement_1050;
  statement_1064:
  if (aupper(3) != text4) {
    goto statement_1067;
  }
  kprhd = 0;
  write(kunit6, "('+REQUEST FOR DRAWING OF PLOT CHARACTERS.')");
  goto statement_1050;
  statement_1067:
  if (aupper(1) != text33) {
    goto statement_5843;
  }
  kbound = 1;
  write(kunit6, "('+SCALE Y AXIS SO NO CURVE EXCEEDS LIMITS.')");
  goto statement_1050;
  statement_5843:
  if (aupper(1) != text18) {
    goto statement_1079;
  }
  if (aupper(2) != text19) {
    goto statement_1079;
  }
  read(abuff, "(16x,5i8)"), kpgrid, isww;
  write(kunit6, "('+GRID & PEN CHOICES.',5i5)"), kpgrid, isww;
  FEM_DO_SAFE(i, 1, 4) {
    if (isww(i) > 0) {
      kpen(i) = isww(i);
    }
  }
  goto statement_1050;
  statement_1079:
  if (aupper(1) != text22) {
    goto statement_7392;
  }
  if (aupper(2) != text23) {
    goto statement_7392;
  }
  if (aupper(3) != text24) {
    goto statement_7392;
  }
  read(abuff, format_7381), linlim;
  write(kunit6, "('+LINE LIMIT FOR SPARSE PRINTER PLOTS =',i8)"), linlim;
  goto statement_1050;
  statement_7392:
  if (aupper(1) != text25) {
    goto statement_7406;
  }
  if (aupper(2) != text26) {
    goto statement_7406;
  }
  read(abuff, format_7381), mulplt(1), mulplt(4), mulplt(5);
  if (mulplt(1) <= 0) {
    mulplt(1) = 1;
  }
  write(kunit6, "('+GRAPH SUPERPOSITION.',3i8)"), mulplt(1), mulplt(4),
    mulplt(5);
  mulplt(2) = 0;
  mulplt(3) = 0;
  goto statement_1050;
  statement_7406:
  if (aupper(1) != text27) {
    goto statement_7627;
  }
  read(abuff, "(24x,e8.0)"), d4;
  write(kunit6, "('+SCALING FACTOR FOR PLOTS.',f10.5)"), d4;
  d4 = 1.0f / d4;
  if (kalcom != 1) {
    goto statement_7622;
  }
  factor(d4);
  goto statement_1050;
  statement_7622:
  kscale = 1;
  d4fact = d4;
  goto statement_1050;
  statement_7627:
  if (aupper(1) != text28) {
    goto statement_7661;
  }
  if (aupper(2) != text29) {
    goto statement_7661;
  }
  write(kunit6, "('+PLOT ONE EMTP VARIABLE AGAINST ANOTHER.')");
  textax(29) = aupper(3);
  textax(30) = aupper(4);
  textax(31) = aupper(5);
  textax(32) = aupper(6);
  //C     READ INPUT CARD USING CIMAGE                                      M23.5574
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_7644;
  }
  {
    read_loop rloop(abuff(1), format_7641);
    FEM_DO_SAFE(i, 1, 3) {
      rloop, xyplot(i);
    }
  }
  goto statement_7648;
  statement_7644:
  nfrfld = 3;
  frefld(cmn, xyplot(1));
  statement_7648:
  if (xyplot(1) <= 0.0f) {
    xyplot(1) = 8.0f;
  }
  if (xyplot(1) == 9999.f) {
    xyplot(1) = 0.0f;
  }
  {
    write_loop wloop(cmn, kunit6, "('+X-AXIS.',3e13.4)");
    FEM_DO_SAFE(i, 1, 3) {
      wloop, xyplot(i);
    }
  }
  //C     READ INPUT CARD USING CIMAGE                                      M23.5585
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_7651;
  }
  {
    read_loop rloop(abuff(1), format_7641);
    FEM_DO_SAFE(i, 4, 9) {
      rloop, xyplot(i);
    }
  }
  goto statement_7653;
  statement_7651:
  nfrfld = 6;
  frefld(cmn, xyplot(4));
  statement_7653:
  if (xyplot(4) <= 0.0f) {
    xyplot(4) = 8.0f;
  }
  if (xyplot(7) <= 0.0f) {
    xyplot(7) = 10.0f;
  }
  if (xyplot(9) <= 0.0f) {
    xyplot(9) = 10.0f;
  }
  {
    write_loop wloop(cmn, kunit6, "('+Y-AXIS.',3e13.4)");
    FEM_DO_SAFE(i, 4, 6) {
      wloop, xyplot(i);
    }
  }
  goto statement_1050;
  statement_7661:
  if (aupper(1) != text30) {
    goto statement_7679;
  }
  if (aupper(2) != text31) {
    goto statement_7671;
  }
  read(abuff, format_7381), nfour;
  if (nfour <= 1) {
    nfour = 30;
  }
  write(kunit6, "('+FOURIER SERIES STARTED.  NFOUR =',i8)"), nfour;
  maxevk = maxevk * nbyte(5) / nbyte(3);
  goto statement_1050;
  statement_7671:
  if (aupper(2) != text32) {
    goto statement_7679;
  }
  nfour = 0;
  write(kunit6, "('+FOURIER SERIES ENDED.  BACK TO PLOTS.')");
  maxevk = maxevk * nbyte(3) / nbyte(5);
  goto statement_1050;
  statement_7679:
  if (itp == 0) {
    goto statement_1070;
  }
  if (itp == 1) {
    goto statement_1160;
  }
  if (itp == 2) {
    goto statement_1550;
  }
  lstat(16) = itp;
  kill = 76;
  lstat(19) = 1070;
  goto statement_9200;
  statement_1070:
  FEM_DO_SAFE(i, 1, 13) {
    if (aupper(i) != blank) {
      goto statement_1106;
    }
  }
  write(kunit6, "('+BLANK CARD TERMINATING PLOT SPEC. CARDS.')");
  interp();
  if (taxmax == 0.0f) {
    goto statement_2720;
  }
  if (kalcom == 0) {
    goto statement_2720;
  }
  n8 = -6666;
  goto statement_2656;
  statement_1106:
  if (iplot >= 0 && lunit4 > 0) {
    goto statement_1120;
  }
  write(kunit6, "('+PLOT CARD IGNORED IN QUEST FOR START OF NEW CASE')");
  goto statement_1050;
  statement_1120:
  if (ialf < 52) {
    goto statement_1126;
  }
  write(kunit6, "('+OVERFLOW SUBTITLE CARD DISCARDED.')");
  goto statement_1050;
  statement_1126:
  ialf += 13;
  //packch(aupper(1), alpha(ialf - 12), mm6, mm1, mm13);
  packch(aupper(1), ArraySpan(&alpha(ialf - 12), alpha.size() - (ialf - 12 - 1)), mm6, mm1, mm13);
  j1 = ialf - 12;
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' AT 1126 PACKED SUBTITLE TEXT.',/,1x,13a10)");
      FEM_DO_SAFE(j, j1, ialf) {
        wloop, alpha(j);
      }
    }
  }
  k = 0;
  FEM_DO_SAFE(j, j1, ialf) {
    k++;
    pltle(j) = aupper(k);
  }
  write(kunit6, "('+PLOT SUBTITLE CARD.')");
  goto statement_1050;
  statement_1550:
  packch(aupper(1), ArraySpan(&sext(1), sext.size()), mm6, mm1, mm13);
  if (iprsup >= 1) {
    write(lunit6, "(' AT 1550 PACKED CASE TITLE TEXT.',/,1x,13a10)"), sext;
  }
  FEM_DO_SAFE(j, 1, 13) {
    cstxt(j) = aupper(j);
  }
  write(kunit6, "('+PLOT CASE-TITLE TEXT.')");
  goto statement_1050;
  statement_1160:
  copya(blank, slot(1), mm8);
  jslot = 3;
  if (kolbeg > 0) {
    goto statement_7402;
  }
  {
    read_loop rloop(abuff(1), "(i2,2i1,e3.0,2e4.0,e5.0,e4.0,4a6,2(2a6,a4))");
    rloop, itp, icp, ihs, hpi, hmin, hmax, vmin, vmax;
    FEM_DO_SAFE(j, 1, 4) {
      rloop, slot(j);
    }
    rloop, bus1, bus2, bus3, bus4, bus5, bus6;
  }
  goto statement_7405;
  statement_7402:
  nfrfld = 1;
  freone(cmn, flong1);
  itp = flong1;
  freone(cmn, flong1);
  icp = flong1;
  freone(cmn, flong1);
  ihs = flong1;
  nfrfld = 5;
  frefld(cmn, voltbc(1));
  hpi = voltbc(1);
  hmin = voltbc(2);
  hmax = voltbc(3);
  vmin = voltbc(4);
  vmax = voltbc(5);
  nfrfld = 4;
  nright = -1;
  freone(cmn, flong1);
  if (kill > 0) {
    goto statement_9200;
  }
  nright = 0;
  FEM_DO_SAFE(j, 1, 4) {
    slot(j) = texta6(j);
  }
  //C     TEMPORARILY BLANK OUT THE TITLES IN FREE-FORMAT CASE              M22.5571
  bus1 = blank;
  bus2 = blank;
  bus3 = blank;
  bus4 = blank;
  bus5 = blank;
  bus6 = blank;
  statement_7405:
  if (isprin != 43) {
    goto statement_7408;
  }
  if (degmax == 0.0f) {
    goto statement_7408;
  }
  ihs = 4;
  icp = 4;
  hpi = tmax / hmin;
  hmin = 0.0f;
  hmax = tmax;
  if (slot(1) == text20) {
    goto statement_7408;
  }
  vmin = cmn.degmin;
  vmax = degmax;
  statement_7408:
  hmin = hmin * (1.0f - flzero);
  hmax = hmax * (1.0f + flzero);
  if (xyplot(1) == 0.0f) {
    goto statement_7413;
  }
  hpi = (hmax - hmin) * 0.1f;
  statement_7413:
  ncrv = icp;
  if (slot(1) != text8) {
    goto statement_83;
  }
  write(kunit6, "('+GRAPH SEPARATION CARD.   ''KSEP'' =',i3)"), ihs;
  if (ihs >= 2) {
    goto statement_82;
  }
  write(lunit6,
    "(' THE SPECIFIED GRAPH SEPARATION OF ',i2,"
    "' INCHES IS CONSIDERED TOO SMALL AND IS RESET TO ',i1,' INCHES.')"),
    ihs, mrgn;
  ihs = mrgn;
  statement_82:
  mrgn = ihs;
  goto statement_1050;
  statement_83:
  if (slot(1) != text7) {
    goto statement_1185;
  }
  write(kunit6, "('+GRAPH SIZE ADJUSTMENT CARD.',2e11.3)"), hmin, hmax;
  d1 = hmin + hmax + vploff;
  if (d1 <= szplt) {
    goto statement_11182;
  }
  write(lunit6,
    "(5x,'NOTE ---- THE REQUESTED BOTTOM MARGIN OF ',e9.3,"
    "' AND GRAPH HEIGHT OF ',e9.3,' REQUIRES A TOTAL ',/,5x,"
    "'PAPER HEIGHT OF ',e9.3,"
    "'.  THIS IS GREATER THAN THE HEIGHT SPECIFIED IN =CALL PAPRSZ=, WHICH IS "
    "',e9.3,/,5x,"
    "'THE REQUESTED VALUES WILL BE IGNORED AND THE LAST SPECIFIED (OR DEFAULT "
    "IF NO HEIGHT VALUES WERE EVER GIVEN) ',/,5x,'WILL BE USED.')"),
    hmin, hmax, d1, szplt;
  if (taxmax > 0.0f) {
    write(lunit6,
      "(5x,'ACTUALLY, THE JUST-QUOTED PAPER HEIGHT IS THE PAPER HEIGHT MINUS T"
      "HE OFFSET HEIGHT OF',e13.4,'   FOR',/,5x,"
      "'THE ONE OR MORE GRAPHS WHICH HAVE ALREADY BEEN DRAWN VERTICALLY BELOW "
      "THE UPCOMING PLOT.   THE USER SHOULD NOT',/,5x,"
      "'INCREASE VERTICAL DIMENSIONS UNLESS HE IS AT THE BOTTOM OF THE PAPER, "
      "OR UNLESS HE IS SURE THAT HE HAS SUFFICIENT',/,5x,"
      "'VERTICAL SPACE LEFT ON THE PAPER FOR AT LEAST ONE MORE PLOT.   THE SIZ"
      "E ADJUSTMENT REMAINS CANCELLED.')"),
      vploff;
  }
  goto statement_1050;
  statement_11182:
  vsnew = hmin - vs;
  if (kalcom == 1) {
    plot(zero, vsnew, llmin3);
  }
  vs = hmin;
  vhs = hmax;
  vh = vhs + vs + 1.0f;
  goto statement_1050;
  statement_1185:
  if (slot(1) != text6) {
    goto statement_1188;
  }
  jslot = 7;
  write(kunit6, format_1182), hpi, hmin, hmax;
  interp();
  //C     READ INPUT CARD USING CIMAGE                                      M09. 271
  cimage(cmn);
  read(abuff, "(2x,i1,21x,8a6)"), ncrv, slot;
  if (ncrv == 0) {
    ncrv = 4;
  }
  write(kunit6, "('+CONTINUATION TO READ BRANCH NODE-PAIR NAMES.')");
  interp();
  goto statement_1195;
  statement_1188:
  if (slot(1) != text5) {
    goto statement_1195;
  }
  tolrce = vmin * vmin;
  write(kunit6, "('+REDEFINITION OF SMOOTHING TOLERANCE.',2x,e10.2)"), vmin;
  d1 = 0.1f;
  if (vmin > d1) {
    write(lunit6,
      "(' ****WARNING****  REQUESTED SMOOTHING TOLERANCE OF ',e11.3,"
      "' MAY CAUSE INACCURATE PLOT.')"),
      vmin;
  }
  goto statement_1050;
  statement_1195:
  if (icp == 8) {
    goto statement_7412;
  }
  if (icp == 9) {
    goto statement_7412;
  }
  if (icp > 0 && icp <= 4) {
    goto statement_7412;
  }
  write(lunit6,
    "(' ILLEGAL PLOT-VARIABLE TYPE CODE  \"ICP\" =',i3,"
    "' .   THIS PLOT REQUEST IS CANCELLED.')"),
    icp;
  goto statement_1000;
  statement_7412:
  //packch(bus1, headl(1), mm6, mm1, mm2);
  //packch(bus3, headl(1), mm4, mm13, mm1);
  //packch(bus4, vertl(1), mm6, mm1, mm3);
  packch(bus1, ArraySpan(&headl(1), headl.size()), mm6, mm1, mm2);
  packch(bus3, ArraySpan(&headl(1), headl.size()), mm4, mm13, mm1);
  packch(bus4, ArraySpan(&vertl(1), headl.size()), mm6, mm1, mm3);

  if (iprsup >= 1) {
    write(lunit6,
      "(' AT 1195 PACKED PLOT TITLE TEXT.',3a10,/,"
      "' AT 1195 PACKED VERT AXIS LABEL.',3a10)"),
      headl, vertl;
  }
  if (jslot != 3) {
    goto statement_4589;
  }
  write(kunit6, format_1182), hpi, hmin, hmax;
  interp();
  statement_4589:
  if (hpi != 0.0f) {
    goto statement_1192;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M09. 298
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_8212;
  }
  read(abuff, "(5e16.0)"), hpi, hmin, hmax, vmin, vmax;
  goto statement_8215;
  statement_8212:
  nfrfld = 5;
  frefld(cmn, voltbc(1));
  hpi = voltbc(1);
  hmin = voltbc(2);
  hmax = voltbc(3);
  vmin = voltbc(4);
  vmax = voltbc(5);
  if (kill > 0) {
    goto statement_9200;
  }
  statement_8215:
  write(kunit6, "('+RE-READ OF FLOATING-POINT FIELDS FOR ACCURACY.')");
  interp();
  statement_1192:
  if (nfour == 0) {
    goto statement_21192;
  }
  d23 = hpi - 7.6f;
  if (d23 >  - .001f && d23 < 0.001f) {
    nfour = -nfour;
  }
  goto statement_21220;
  statement_21192:
  if (hpi <= 0.0f) {
    goto statement_1193;
  }
  if (hmax <= 0.0f) {
    goto statement_1193;
  }
  if (hmax > hmin) {
    goto statement_1197;
  }
  statement_1193:
  write(lunit6,
    "(5x,'PLOT CARD ERROR.   TIME-AXIS SPECIFICATION IS ILLEGAL.   THIS PLOT R"
    "EQUEST IS BEING SKIPPED.',/,20x,3e15.5)"),
    hpi, hmin, hmax;
  goto statement_1000;
  statement_1197:
  d1 = (hmax - hmin) / hpi;
  hpil = hpi;
  if (iout == 2) {
    goto statement_1227;
  }
  if (d1 <= szbed) {
    goto statement_1227;
  }
  write(lunit6, format_1224), hpi, hmin, hmax, d1;
  write(lunit6,
    "('+',106x,', WHICH EXCEEDS',/,5x,"
    "'THE CURRENTLY IMPOSED FLAT-BED LIMIT OF ',e13.4,"
    "' INCHES.  THE SCALE ON THE TIME AXIS WILL BE CHANGED BY THE EMTP SO',/,"
    "5x,'THAT THE SPECIFIED RANGE COVERS EXACTLY 12 INCHES OF PAPER.   IF THE "
    "USER HAS QUESTIONS, CALL PROGRAM MAINTENANCE.')"),
    szbed;
  hpi = (hmax - hmin) / 12.f;
  statement_1227:
  if (iout == 1) {
    goto statement_1229;
  }
  if (d1 >= 3.0f) {
    goto statement_1229;
  }
  write(lunit6, format_1224), hpi, hmin, hmax, d1;
  hmax = 3.0f * hpi + hmin;
  write(lunit6,
    "('+',106x,', WHICH IS CONSIDERED',/,5x,"
    "'TOO SHORT FOR THE REQUESTED LINEPRINTER PLOT.  THE REQUESTED MAXIMUM WIL"
    "L BE RESET BY THE T. P. TO ',e13.6,/,5x,"
    "'TO GIVE A PLOT LENGTH OF 3 INCHES.')"),
    hmax;
  statement_1229:
  countp += 1.0f;
  kikoy = 0;
  if ((iout == 2) && (vmin != 0.0f || vmax != 0.0f)) {
    kikoy = 99;
  }
  if (vmin != 0.0f || vmax != 0.0f) {
    goto statement_1220;
  }
  vmin = -c1e12;
  vmax = c1e12;
  statement_1220:
  vmaxr = vmin + (vmax - vmin) * (vh - vs) / vhs;
  vminr = vmin - (vmax - vmin) * vs / vhs;
  statement_21220:
  if (ihs >= 1 && ihs <= 7) {
    goto statement_1230;
  }
  write(lunit6,
    "(5x,'THE NUMBER SPECIFYING THE UNITS ON THE HORIZONTAL SCALE, PUNCHED IN "
    "COLUMN 4 OF THE PLOT REQUEST CARD, MUST BE  ',/,5x,"
    "'BETWEEN 1 AND 7 (INCLUSIVE).  THE NUMBER READ FROM THE LAST SUCH CARD WA"
    "S',i2,'.',/,5x,'THIS PLOT REQUEST IS CANCELLED.')"),
    ihs;
  goto statement_1000;
  statement_1230:
  switch (ihs) {
    case 1: goto statement_1240;
    case 2: goto statement_1260;
    case 3: goto statement_1280;
    case 4: goto statement_1300;
    case 5: goto statement_1320;
    case 6: goto statement_1280;
    case 7: goto statement_1280;
    default: break;
  }
  statement_1240:
  tmult = 360.f * statfr;
  goto statement_1340;
  statement_1260:
  tmult = statfr;
  goto statement_1340;
  statement_1280:
  tmult = 1.f;
  goto statement_1340;
  statement_1300:
  tmult = 1000.f;
  goto statement_1340;
  statement_1320:
  tmult = 1000000.f;
  statement_1340:
  hmin = hmin / tmult;
  hmax = hmax / tmult;
  mhoriz = -22;
  if (xyplot(1) > 0.0f) {
    ihs = 8;
  }
  j = 4 * (ihs - 1) + 1;
  packch(textax(j), ArraySpan(&horzl(1), horzl.size()),mm6, mm1, mm4);
  if (iprsup >= 1) {
    write(lunit6, "(' AT 1341 PACKED TIME AXIS LABEL.',3a10)"), horzl;
  }
  if (vmin >= 0.0f) {
    goto statement_1460;
  }
  if (vmax <= 0.0f) {
    goto statement_1480;
  }
  ha = -vmin * vhs / (vmax - vmin);
  goto statement_1500;
  statement_1460:
  ha = 0.0f;
  goto statement_1500;
  statement_1480:
  ha = vhs;
  statement_1500:
  {
    read_loop rloop(cmn, lunit4, fem::unformatted);
    rloop, date1, tclock;
    FEM_DO_SAFE(j, 1, 4) {
      rloop, intd8(j);
    }
  }
  numnam = intd8(1);
  numnvo = intd8(2);
  numbco = intd8(3);
  nc = intd8(4);
  jcnt = numnam + numnvo + 2 * nc;
  jcnt = jcnt * nbyte(1) / nbyte(4);
  if (maxev >= jcnt) {
    goto statement_1520;
  }
  lstat(14) = maxev;
  lstat(15) = jcnt;
  lstat(19) = 1500;
  kill = 96;
  goto statement_9200;
  statement_1520:
  if (mulplt(1) > 0) {
    goto statement_1523;
  }
  mulplt(2) = 0;
  mulplt(3) = 0;
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.2696
  statement_1523:
  cmn.io.rewind(lunit4);
  {
    read_loop rloop(cmn, lunit4, fem::unformatted);
    rloop, date1, tclock;
    FEM_DO_SAFE(j, 1, 4) {
      rloop, intd8(j);
    }
    FEM_DO_SAFE(j, 1, numnam) {
      rloop, buslst(j);
    }
  }
  if (numnvo > limbin) {
    goto statement_34231;
  }
  if (nc <= limbin) {
    goto statement_44231;
  }
  statement_34231:
  write(lunit6,
    "(/,' OVERFLOW ERROR STOP IN  ''SUBR31'' .','  LIMBIN  NUMNVO      NC',/,"
    "35x,3i8)"),
    limbin, numnvo, nc;
  stoptp(cmn);
  statement_44231:
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' FIRST THIRD OF PLOT-FILE HEADER INFO READ FROM LOGICAL 4 IN SUBR"
        "31.',7x,'DATE1(2)',6x,'TCLOCK(2)','  NUMNAM  NUMBCO      NC',/,68x,"
        "7x,2a4,7x,2a4,3i8,/(' (BUSLST(J), J=1, NUMNAM)',1x,10a7))");
      wloop, date1, tclock, numnam, numbco, nc;
      FEM_DO_SAFE(j, 1, numnam) {
        wloop, buslst(j);
      }
    }
  }
  iofibr = numnvo;
  iofjbr = numnvo + nc;
  iofbus = numnvo + 2 * nc;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' OFFSETS.','  IOFIBR  IOFJBR  IOFBUS',/,9x,3i8)"), iofibr,
      iofjbr, iofbus;
  }
  j = numnam;
  statement_4224:
  n4 = j + iofbus;
  buslst(n4) = buslst(j);
  j = j - 1;
  if (j > 0) {
    goto statement_4224;
  }
  if (numnvo > 0) {
    {
      read_loop rloop(cmn, lunit4, fem::unformatted);
      FEM_DO_SAFE(j, 1, numnvo) {
        rloop, intd8(j);
      }
    }
  }
  FEM_DO_SAFE(j, 1, numnvo) {
    ibsout(j) = intd8(j);
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' NUMNVO=',i4,10x,'(IBSOUT(J), J=1, NUMNVO)  FOLLOW ....',/(1x,"
        "20i6))");
      wloop, numnvo;
      FEM_DO_SAFE(j, 1, numnvo) {
        wloop, ibsout(j);
      }
    }
  }
  n1 = numnvo + 1;
  n2 = numnvo + nc;
  n5 = n1 + nc;
  n6 = n2 + nc;
  if (nc == 0) {
    goto statement_54224;
  }
  {
    read_loop rloop(cmn, lunit4, fem::unformatted);
    FEM_DO_SAFE(j, 1, nc) {
      rloop, intd8(j);
    }
    FEM_DO_SAFE(j, 1, nc) {
      rloop, intd9(j);
    }
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (INTD8(J), J=1, NC), (INTD9(J), J=1, NC)',/(1x,20i6))");
      FEM_DO_SAFE(j, 1, nc) {
        wloop, intd8(j);
      }
      FEM_DO_SAFE(j, 1, nc) {
        wloop, intd9(j);
      }
    }
  }
  n11 = n1;
  n12 = n5;
  FEM_DO_SAFE(j, 1, nc) {
    ibrnch(n11) = intd8(j);
    jbrnch(n12) = intd9(j);
    n11++;
    n12++;
  }
  if (iprsup < 1) {
    goto statement_54224;
  }
  write(lunit6,
    "(' N1=',i10,'N2=',i10,/,"
    "' IBRNCH(J) AND JBRNCH(J+NC), J=N1, N2 AT 4222....')"),
    n1, n2;
  FEM_DO_SAFE(j, n1, n2) {
    n6 = j + nc;
    write(lunit6, "(1x,2i10)"), ibrnch(j), jbrnch(n6);
  }
  statement_54224:
  //packch(date1(1), daytim(1), mm4, mm1, mm2);
  //packch(blanka(1), daytim(1), mm4, mm9, mm1);
  //packch(tclock(1), daytim(1), mm4, mm11, mm2);
  packch(date1(1),  ArraySpan(&daytim(1), daytim.size()), mm4, mm1, mm2);
  packch(blanka(1), ArraySpan(&daytim(1), daytim.size()), mm4, mm9, mm1);
  packch(tclock(1), ArraySpan(&daytim(1), daytim.size()), mm4, mm11, mm2);

  if (iprsup >= 1) {
    write(lunit6, "(' AT 4223 PACKED DAYTIM.',8a10)"), daytim;
  }
  numbvo = nc - numbco;
  i = 0;
  jplt = 0;
  if (icp > 7) {
    goto statement_1660;
  }
  statement_1560:
  i++;
  if (i != 5) {
    goto statement_1580;
  }
  if (jplt == 0) {
    goto statement_1900;
  }
  goto statement_1880;
  statement_1580:
  if (slot(i) == blank) {
    goto statement_1560;
  }
  k = 0;
  statement_1600:
  k++;
  if (k <= numnvo) {
    goto statement_1640;
  }
  write(lunit6,
    "(5x,'BUS NAME =',a6,"
    "'= OF THE USER=S LAST-READ PLOT CARD IS NOT THE NAME OF A BUS HAVING NODE"
    " VOLTAGE',/,5x,"
    "'OUTPUT.   HENCE THIS FIELD WILL BE IGNORED BY THE EMTP (TREATED AS IF IT"
    " HAD BEEN BLANK).')"),
    slot(i);
  write(lunit6, format_1621);
  statement_1627:
  slot(i) = blank;
  goto statement_1560;
  statement_1640:
  L = ibsout(k) + iofbus;
  if (slot(i) != buslst(L)) {
    goto statement_1600;
  }
  jplt++;
  mplot(jplt) = k;
  slot(jplt) = buslst(L);
  if (jplt < i) {
    goto statement_1627;
  }
  goto statement_1560;
  statement_1660:
  FEM_DOSTEP(j, 1, jslot, 2) {
    if (slot(j) == blank && slot(j + 1) == blank) {
      goto statement_1680;
    }
    slot(jplt + 1) = slot(j);
    slot(jplt + 2) = slot(j + 1);
    jplt += 2;
    statement_1680:;
  }
  if (jplt == 0) {
    goto statement_1900;
  }
  lplt = 0;
  jbegbc = numbvo + 1;
  FEM_DOSTEP(i, 1, jplt, 2) {
    if (icp == 9) {
      goto statement_1720;
    }
    ib = 1;
    il = jbegbc;
    n1 = numnvo + 1;
    goto statement_1740;
    statement_1720:
    ib = jbegbc;
    il = nc + 1;
    n1 = numnvo + jbegbc;
    statement_1740:
    if (ib < il) {
      goto statement_1780;
    }
    write(lunit6,
      "(5x,'THE USER=S LAST-READ PLOT CARD REQUESTS A PLOT FOR A BRANCH-VARIAB"
      "LE WHICH IS IDENTIFIED BY TERMINAL',/,5x,'NAMES =',a6,'= AND =',a6,"
      "'=.   BUT THE EMTP CANNOT FIND THIS REQUESTED VARIABLE IN THE LIST OF O"
      "UTPUT',/,5x,"
      "'VARIABLES, SO THIS PARTICULAR PLOT REQUEST MUST BE IGNORED.')"),
      slot(i), slot(i + 1);
    write(lunit6, format_1621);
    write(lunit6,
      "(5x,'ALSO, THE USER SHOULD BE REMINDED THAT BRANCH-OUTPUT REQUESTS ARE "
      "MADE USING COLUMN-80 PUNCHES ON THE',/,5x,"
      "'BRANCH CARDS IN QUESTION.   THE USER SHOULD DOUBLE-CHECK THAT HE REALL"
      "Y HAS REQUESTED THE OUTPUT VARIABLE WHICH',/,5x,"
      "'HE IS TRYING TO PLOT (AND WHICH GOT HIM IN TROUBLE).   ONE COMMON ERRO"
      "R IS TO REQUEST ONLY BRANCH-CURRENT OUTPUT',/,5x,"
      "'(A 1-PUNCH IN COLUMN 80) AND THEN TRY TO PLOT BRANCH VOLTAGE ---- OR V"
      "ICE VERSA.   FINALLY, THE USER SHOULD CHECK',/,5x,"
      "'THAT BRANCH OUTPUT IS EVEN POSSIBLE FOR THE COMPONENT IN QUESTION, SIN"
      "CE COLUMN-80 PUNCHES MAY BE IGNORED IF THE')");
    write(lunit6,
      "(5x,'COMPONENT IN QUESTION DOES NOT PROVIDE FOR SUCH OUTPUT.   ANY BRAN"
      "CH-OUTPUT REQUEST FOR A MULTI-PHASE',/,5x,"
      "'DISTRIBUTED LINE FALLS INTO THIS CLASS, IT WILL BE NOTED.')");
    slot(i) = blank;
    slot(i + 1) = blank;
    goto statement_1860;
    statement_1780:
    n7 = ib + iofibr;
    n8 = ib + iofjbr;
    n2 = ibrnch(n7) + iofbus;
    n3 = jbrnch(n8) + iofbus;
    if (iprsup >= 1) {
      write(lunit6, "(' AT 1780',2i10,5x,2a8)"), n2, n3, buslst(n2), buslst(n3);
    }
    if (slot(i) != buslst(n2)) {
      goto statement_1800;
    }
    if (slot(i + 1) != buslst(n3)) {
      goto statement_1820;
    }
    //C               NODE PAIR FOUND - SIGN CORRECT                          M09. 490
    mplot(lplt + 1) = n1;
    goto statement_1840;
    statement_1800:
    if (slot(i + 1) != buslst(n2)) {
      goto statement_1820;
    }
    if (slot(i) != buslst(n3)) {
      goto statement_1820;
    }
    //C               NODE PAIR FOUND - SIGN NEGATIVE                         M09. 495
    mplot(lplt + 1) = -n1;
    goto statement_1840;
    statement_1820:
    ib++;
    n1++;
    goto statement_1740;
    statement_1840:
    lplt++;
    statement_1860:;
  }
  jplt = lplt;
  if (jplt == 0) {
    goto statement_1900;
  }
  jslot++;
  statement_1880:
  if (iprsup == 0) {
    goto statement_1929;
  }
  {
    write_loop wloop(cmn, lunit6, "(/,' AT 1883 OF OV31.',i10,/(1x,a6))");
    wloop, jplt;
    FEM_DO_SAFE(i, 1, jslot) {
      wloop, slot(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(4i10)");
    FEM_DO_SAFE(i, 1, 4) {
      wloop, mplot(i);
    }
  }
  goto statement_1929;
  statement_1900:
  write(lunit6,
    "(5x,'NO VALID PLOT-VARIABLE NAME OR NAMES WAS PUNCHED ON THE USER=S LAST-"
    "READ PLOT CARD.   HENCE THE EMTP WILL',/,5x,"
    "'IGNORE THIS PLOT CARD COMPLETELY, AND GO ON TO READ THE NEXT ONE (FUN AN"
    "D GAMES CONTINUE).')");
  goto statement_1000;
  statement_1929:
  k = numnvo + nc;
  jplt2 = jplt * 2;
  maxevk = (maxev / jplt2) * jplt2 - (4 * jplt);
  maxevk = maxevk * nbyte(4) / nbyte(5);
  j = jplt2 + 4 * jplt;
  if (maxevk >= j) {
    goto statement_1935;
  }
  write(lunit6,
    "(5x,' *** THE PLOTTING ARRAY EV HAS BEEN DIMENSIONED SUCH THAT THE WORKIN"
    "G SIZE IS',i10,'.  THIS IS LESS THAN',i10,/,5x,"
    "'WHICH IS THE SIZE REQUIRED FOR THIS PLOT.  THIS REQUEST IS CANCELLED. ')"
    ""),
    maxevk, j;
  goto statement_1000;
  statement_1935:
  kpl = 0;
  kplt = 0;
  iovfl = 0;
  iend = 0;
  evmx = 0.0f;
  vmaxl = 0.0f;
  vminl = 0.0f;
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.2698
  cmn.io.rewind(lunt13);
  FEM_DO_SAFE(j, 1, jplt) {
    iswx(j) = 0;
    evh(j) = 0.0f;
    evdh(j) = 0.0f;
  }
  n9 = 0;
  if (xyplot(1) != 0 || nfour != 0) {
    n9 = 1;
  }
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' BEFORE READ OF PLOT POINTS.','       K    JPLT      N9  MAXEVK',/,"
      "28x,4i8,/,' ''MPLOT''  VECTOR FOLLOWS.',16i5)"),
      k, jplt, n9, maxevk, mplot;
  }
  ndx1 = 2 * linlim;
  move0(ev, ndx1);
  statement_2115:
  if (cmn.m4plot == 0) {
    goto statement_2102;
  }
  {
    read_loop rloop(cmn, lunit4, fem::unformatted);
    rloop, tsing;
    FEM_DO_SAFE(j, 1, k) {
      rloop, bxsing(j);
    }
  }
  tstep = tsing;
  xin(1) = tstep;
  FEM_DO_SAFE(j, 1, k) {
    xin(j+1) = bxsing(j); // equivalence bx(1), xin(2)
  }
  goto statement_2105;
  statement_2102:
  {
    read_loop rloop(cmn, lunit4, fem::unformatted);
    rloop, tstep;
    FEM_DO_SAFE(j, 1, k) {
      rloop, xin(j+1);
    }
  }
  xin(1) = tstep;
  statement_2105:
  if (tstep ==  - 9999.f || tstep > hmax) {
    goto statement_2200;
  }
  if (tstep < hmin) {
    goto statement_2115;
  }
  FEM_DO_SAFE(j, 1, jplt) {
    j1 = mplot(j);
    if (j1 >= 0) {
      goto statement_2120;
    }
    j1 = -j1;
    xin(j1+1) = -xin(j1+1);
    statement_2120:
    if (n9 == 0) {
      goto statement_2127;
    }
    kplt++;
    kpl++;
    if (nfour != 0) {
      goto statement_2123;
    }
    ev(kpl) = xin(j1+1);
    goto statement_2140;
    statement_2123:
    cmn.karray(kpl) = xin(j1+1);
    goto statement_2140;
    statement_2127:
    kpl += 2;
    ev(kpl - 1) = tstep;
    ev(kpl) = xin(j1+1);
    kplt += 2;
    statement_2140:;
  }
  if (kpl >= maxevk) {
    goto statement_2150;
  }
  goto statement_2115;
  statement_2150:
  iovfl = 1;
  goto statement_2210;
  statement_2200:
  iend = 1;
  if (lastov == 1) {
    tmax = ev(kpl - 1);
  }
  if (kplt != 0) {
    goto statement_2210;
  }
  write(lunit6,
    "(' NO PLOT POINTS FOUND BETWEEN THE REQUESTED TIME LIMITS  ',e12.3,"
    "' TO ',e12.3,' .   THIS PLOT REQUEST CANCELLED.')"),
    hmin, hmax;
  goto statement_1000;
  statement_2210:
  if (iprsup == 0) {
    goto statement_2215;
  }
  jk = kplt / jplt2;
  write(lunit6,
    "(/,' AT 2211, AFTER READING FROM 4, THE NUMBER OF POINTS PER CURVE ARE',"
    "i10)"),
    jk;
  if (iprsup < 3) {
    goto statement_2215;
  }
  j1 = 8;
  if (iprsup > 39) {
    j1 = kpl;
  }
  {
    write_loop wloop(cmn, lunit6, "(/,' EV(J) PLOT POINTS.',/(1x,10e13.4))");
    FEM_DO_SAFE(j, 1, j1) {
      wloop, ev(j);
    }
  }
  statement_2215:
  if (xyplot(1) > 0.0f) {
    goto statement_2540;
  }
  if (nfour == 0) {
    goto statement_7682;
  }
  //C     CALCULATE FOURIER SERIES IN MODULE  "SERIES" .                    M28.6764
  series(cmn, nfour, kpl, jplt, maxevk);
  goto statement_1000;
  statement_7682:
  FEM_DO_SAFE(j, 1, jplt) {
    j1 = j * 2;
    FEM_DOSTEP(i, j1, kpl, jplt2) {
      evp = ev(i);
      if (iswx(j) == 1) {
        goto statement_2240;
      }
      evdp = evp - evh(j);
      if (evdp * evdh(j) >= 0.0f) {
        goto statement_2250;
      }
      if (isww(j) == 1) {
        goto statement_2255;
      }
      itimes(j)++;
      if (itimes(j) <= nsmth) {
        goto statement_2260;
      }
      iswx(j) = 1;
      write(lunit6,
        "(5x,'WHILE SCANNING THE DATA POINTS FOR CURVES OF THE LAST-READ PLOT "
        "CARD, A NEED FOR SMOOTHING OF CURVE NUMBER',/,5x,i2,' BEYOND TIME ',"
        "e12.4,' SECONDS HAS BEEN DETERMINED.   AT THIS POINT, ',i3,"
        "' SUCCESSIVE, UNINTERRUPTED,',/,5x,"
        "'ALTERNATING RELATIVE MAXIMA AND RELATIVE MINIMA HAVE BEEN OBSERVED. "
        "  THIS IS TAKEN AS A SIGN OF A SPURIOUS',/,5x,"
        "'MATHEMATICAL OSCILLATION, SOMETHING WHICH SHOULD NOT EXIST PHYSICALL"
        "Y (AT LEAST NOT FOR AN INTELLIGENT USER',/,5x,"
        "'WHO HAS PICKED THE TIME-STEP SIZE =DELTAT= AND THE OUTPUT FREQUENCY "
        "\"IPLOT\" PROPERLY).   AT THIS POINT, THE')"),
        j, ev(i - 1), nsmth;
      write(lunit6,
        "(5x,'OMNISCIENT AND OMNIPOTENT EMTP (OTHERWISE AFFECTIONATELY REFERRE"
        "D TO AS =BIG BROTHER= BY THOSE USERS',/,5x,"
        "'WHO ARE ACCUSTOMED TO HIS MODUS OPERANDI) HAS DECIDED TO SMOOTH THIS"
        " CURVE FOR ALL LATER TIME.   THIS SMOOTHING',/,5x,"
        "'INVOLVES SIMPLY THE AVERAGING OF SUCCESSIVE ORDINATES IN THE OUTPUT "
        "FILE OF PLOT-VARIABLE POINTS FOR THIS CURVE,',/,5x,"
        "'BEFORE PLOTTING BEYOND THIS POINT IN TIME.')");
      statement_2240:
      ip1 = i + jplt2;
      if (ip1 <= kpl) {
        goto statement_2241;
      }
      ip1 = i - jplt2;
      ev(i) = ev(ip1);
      goto statement_2242;
      statement_2241:
      ev(i) = (ev(ip1) + evp) / 2.0f;
      statement_2242:
      evp = ev(i);
      goto statement_2260;
      statement_2250:
      isww(j) = 1;
      goto statement_2260;
      statement_2255:
      itimes(j) = 1;
      isww(j) = 0;
      statement_2260:
      evdh(j) = evdp;
      evh(j) = evp;
      d1 = fem::abs(evp);
      if (d1 > evmx) {
        evmx = d1;
      }
      if (evp < vminr) {
        goto statement_2280;
      }
      if (evp > vmaxr) {
        goto statement_2300;
      }
      goto statement_2310;
      statement_2280:
      ev(i) = vminr;
      goto statement_2310;
      statement_2300:
      ev(i) = vmaxr;
      statement_2310:
      if (iout == 1) {
        goto statement_2320;
      }
      if (ev(i) > vmaxl) {
        vmaxl = ev(i);
      }
      if (ev(i) < vminl) {
        vminl = ev(i);
      }
      statement_2320:;
    }
  }
  if (iovfl == 0) {
    goto statement_2350;
  }
  {
    write_loop wloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(j, 1, kpl) {
      wloop, ev(j);
    }
  }
  if (iend == 1) {
    goto statement_2350;
  }
  kpl = 0;
  goto statement_2115;
  statement_2350:
  stp = 1.0f + (hpi / tmult) / (ev(jplt2 + 1) - ev(1));
  if (iout == 1) {
    goto statement_2346;
  }
  if (vmaxl != 0.0f) {
    goto statement_2346;
  }
  if (vminl != 0.0f) {
    goto statement_2346;
  }
  write(lunit6,
    "(/,' ABORT THIS PLOT REQUEST, BECAUSE ALL VARIABLES ARE IDENTICALLY ZERO "
    "OVER THE REQUESTED TIME SPAN.')");
  goto statement_1000;
  statement_2346:
  jstp = stp;
  if (iprsup >= 1) {
    write(lunit6, "(/,' PLOT PARAMETERS AT 2342.',2i10,5e15.5)"),
      jplt, kplt, vmax, vmin, evmx, vminr, vmaxr;
  }
  if (vmax != c1e12 || vmin != (-c1e12)) {
    goto statement_2540;
  }
  if (kikoy == 99) {
    goto statement_2540;
  }
  if (evmx == 0.0f) {
    evmx = 1.0f;
  }
  a = 8.0f;
  evmxf = evmx;
  if (kbound == 1) {
    goto statement_2360;
  }
  evmxf = evmx * 4.0f;
  evmxf = evmxf / 5.0f;
  statement_2360:
  d1 = evmxf - a;
  if (d1 == 0.0f) {
    goto statement_2400;
  }
  if (d1 > 0.0f) {
    goto statement_2380;
  }
  a = a / 10.f;
  goto statement_2360;
  statement_2380:
  a = a * 10.f;
  d1 = evmxf - a;
  if (d1 == 0.0f) {
    goto statement_2400;
  }
  if (d1 > 0.0f) {
    goto statement_2380;
  }
  d1 = evmxf - a / 2.0f;
  if (d1 == 0.0f) {
    goto statement_2440;
  }
  if (d1 < 0.0f) {
    goto statement_2420;
  }
  statement_2400:
  vmax = a;
  goto statement_2520;
  statement_2420:
  d1 = evmxf - a / 4.0f;
  if (d1 < 0.0f) {
    goto statement_2460;
  }
  if (d1 == 0.0f) {
    goto statement_2480;
  }
  statement_2440:
  vmax = a / 2.0f;
  goto statement_2520;
  statement_2460:
  if (evmxf - a / 8.0f <= 0.0f) {
    goto statement_2500;
  }
  statement_2480:
  vmax = a / 4.0f;
  goto statement_2520;
  statement_2500:
  vmax = a / 8.0f;
  statement_2520:
  vmin = -vmax;
  statement_2540:
  FEM_DO_SAFE(j, 1, 13) {
    aupper(j) = blank;
  }
  long1 = 1;
  jsl = jplt;
  if (icp >= 8) {
    jsl = jplt2;
  }
  FEM_DO_SAFE(i, 1, jsl) {
    if (slot(i) == blank) {
      slot(i) = cmn.terra;
    }
    //packch(slot(i), aupper(1), mm6, long1, mm1);
    packch(slot(i), ArraySpan(&aupper(1), aupper.size()), mm6, long1, mm1);
    long1 += 6;
    //packch(blanka(1), aupper(1), mm4, long1, mm1);
    packch(blanka(1), ArraySpan(&aupper(1), aupper.size()), mm4, long1, mm1);
    long1 += 2;
  }
  jchar = long1;
  if (iprsup >= 1) {
    write(lunit6, "(' AT 2569 PACKED NODE NAMES.',8a10)"), aupper;
  }
  if (iprsup >= 1) {
    write(lunit6, "(' TOLERANCE=',e12.6)"), tolrce;
  }
  if (xyplot(1) == 0.0f) {
    goto statement_2570;
  }
  //C     IF ( IOUT  .EQ.  1 )   GO TO 12581  VB REMOVAL (JUNE 82)          M32.7598
  vminl = xyplot(5);
  vmaxl = xyplot(6);
  jplt2 = 1;
  statement_2570:
  dx = hpi / tmult;
  dy = (vmax - vmin) / vhs;
  d1 = lnpin;
  dxl = (hpil / tmult) / d1;
  dxl2 = dxl / 2.0f;
  dyl = (vmaxl - vminl) / 130.f;
  if (kikoy == 99) {
    dyl = (vmax - vmin) / 130.f;
  }
  if (iprsup >= 1) {
    write(lunit6, "(' AT 2580',4e15.6)"), dxl, vmaxl, vminl, dyl;
  }
  jpts = kplt / jplt2;
  if (jpts < linlim) {
    jpts = linlim;
  }
  lnflg = 0;
  ipl1 = 1;
  statement_2580:
  ipl2 = ipl1 + ncrv - 1;
  if (ipl2 > jplt) {
    ipl2 = jplt;
  }
  kpl = kplt;
  jovfl = iovfl;
  lnck = 0;
  if (iprsup >= 1) {
    write(lunit6, "(' AT 2580, IPL1,2',2i10)"), ipl1, ipl2;
  }
  if (iout == 1) {
    goto statement_12581;
  }
  if (lnflg == 1) {
    goto statement_3260;
  }
  if (mpage == 1) {
    write(lunit6, "('1')");
  }
  if (mpage == 0) {
    write(lunit6, "(/,/,/,/,1x)");
  }
  if (bus1 != blank) {
    goto statement_3190;
  }
  if (bus2 != blank) {
    goto statement_3190;
  }
  if (bus3 != blank) {
    goto statement_3190;
  }
  goto statement_3205;
  statement_3190:
  write(lunit6, "(58x,2a6,a4,/,/,1x)"), bus1, bus2, bus3;
  statement_3205:
  FEM_DO_SAFE(j, 1, 13) {
    if (cstxt(j) != blank) {
      goto statement_3207;
    }
  }
  goto statement_3209;
  statement_3207:
  write(lunit6, "(27x,13a6,/,1x)"), cstxt;
  statement_3209:
  if (ialf == 0) {
    goto statement_3212;
  }
  FEM_DOSTEP(j, 1, ialf, 13) {
    j1 = j + 12;
    {
      write_loop wloop(cmn, lunit6, "(27x,13a6)");
      FEM_DO_SAFE(k, j, j1) {
        wloop, pltle(k);
      }
    }
    FEM_DO_SAFE(k, j, j1) {
      pltle(k) = blank;
    }
  }
  statement_3212:
  j = countp;
  write(lunit6,
    "(/,1x,2a4,2x,2a4,6x,i2,/,' PLOT TYPE',5x,i1,/,' NODE NAMES',5x,8(a6,3x),"
    "/,1x)"),
    date1, tclock, j, icp, slot;
  k = 4 * (ihs - 1) + 1;
  j1 = k + 3;
  {
    write_loop wloop(cmn, lunit6, "(1x,4a6,/,1x)");
    FEM_DO_SAFE(j, k, j1) {
      wloop, textax(j);
    }
  }
  d1 = fem::abs(vmaxl);
  d2 = fem::abs(vminl);
  if (kikoy == 99) {
    d1 = fem::abs(vmax);
  }
  if (kikoy == 99) {
    d2 = fem::abs(vmin);
  }
  if (d1 < d2) {
    d1 = d2;
  }
  k = 0;
  if (d1 < 1.0f) {
    goto statement_3232;
  }
  statement_3231:
  if (d1 < 10.0f) {
    goto statement_3235;
  }
  k++;
  d1 = d1 / 10.0f;
  goto statement_3231;
  statement_3232:
  if (d1 * cmn.fltinf < 1.0f) {
    goto statement_3235;
  }
  statement_43232:
  if (d1 >= 1.0f) {
    goto statement_3235;
  }
  k = k - 1;
  d1 = d1 * 10.0f;
  goto statement_43232;
  statement_3235:
  if (k != 0) {
    goto statement_3237;
  }
  write(lunit6, "(51x,2a6,a4)"), bus4, bus5, bus6;
  expnt = 1.0f;
  goto statement_3240;
  statement_3237:
  write(lunit6, "(51x,2a6,a4,'  (  X 10**(',i3,')  )')"), bus4, bus5, bus6, k;
  k = -k;
  expnt = fem::pow(10.0f, k);
  statement_3240:
  d3 = vminl;
  if (kikoy == 99) {
    d3 = vmin;
  }
  FEM_DO_SAFE(j, 1, 14) {
    vrtnum(j) = d3 * expnt;
    d3 += (dyl * 10.0f);
  }
  write(lunit6, "(f7.3,f8.3,f9.3,10f10.3,f8.3)"), vrtnum;
  long1 = jdumy;
  linplt(cmn, mm0, long1);
  if (xyplot(1) != 0.0f) {
    goto statement_2581;
  }
  lcnt = -1;
  hpt = hmin;
  jcol = 0;
  mdpt = 0;
  if ((vminl > 0.0f && kikoy != 99) || (vmin > 0.0f && kikoy == 99)) {
    goto statement_3260;
  }
  if ((vmaxl < 0.0f && kikoy != 99) || (vmax < 0.0f && kikoy == 99)) {
    goto statement_3260;
  }
  d3 = -vminl / dyl + 1.5f;
  if (kikoy == 99) {
    d3 = -vmin / dyl + 1.5f;
  }
  mdpt = d3;
  statement_3260:
  if (iout == 2) {
    goto statement_5975;
  }
  goto statement_12581;
  //C     BEGIN X-Y PRINTER PLOT CODE  &&&&&&&&&&&&&&&&&&&&&&&&&&&          M28.6784
  statement_2581:
  n1 = xyplot(1) * lnpin;
  n2 = xyplot(4) * xyplot(9);
  n3 = n1 * n2;
  n4 = maxevk - n3;
  n11 = kpl * nbyte(5) / nbyte(4);
  if (n4 > n11) {
    goto statement_2739;
  }
  write(lunit6,
    "(5x,' X-Y PRINTER PLOT CANCELLED DUE TO',' INSUFFICIENT WORKING SPACE.',"
    "4i8)"),
    n11, maxevk, n3, kpl;
  goto statement_2819;
  statement_2739:
  n5 = n11 + 1;
  n6 = n5 + n3;
  FEM_DO_SAFE(j, n5, n6) {
    cmn.karray(j) = 0;
  }
  d1 = n1 / (xyplot(3) - xyplot(2));
  d2 = n2 / (xyplot(6) - xyplot(5));
  n10 = -xyplot(5) * d2 + 0.5f;
  if (n10 > 131) {
    n10 = 0;
  }
  if (n10 < 0) {
    n10 = 0;
  }
  n5 = 1;
  n9 = jplt / 2;
  FEM_DO_SAFE(i, 1, maxevk) {
    FEM_DO_SAFE(j, 1, n9) {
      k = (ev(n5) - xyplot(2)) * d1 + 0.5f;
      if (k > n1) {
        k = n1;
      }
      if (k <= 0) {
        k = 1;
      }
      L = (ev(n5 + 1) - xyplot(5)) * d2 + 0.5f;
      if (L > n2) {
        L = n2;
      }
      if (L <= 0) {
        L = 1;
      }
      n8 = n11 + (k - 1) * n2 + L;
      if (cmn.karray(n8) > 0) {
        goto statement_2756;
      }
      cmn.karray(n8) = j;
      goto statement_2763;
      statement_2756:
      if (cmn.karray(n8) != j) {
        cmn.karray(n8) = 99;
      }
      statement_2763:
      n5 += 2;
      if (n5 > kpl) {
        goto statement_2781;
      }
    }
  }
  stoptp(cmn);
  statement_2781:
  n8 = n11;
  n7 = lnpin;
  n9 = 77;
  d3 = xyplot(2);
  d4 = (xyplot(3) - xyplot(2)) / xyplot(1);
  linplt(cmn, ll0, ll1);
  FEM_DO_SAFE(k, 1, n1) {
    if (n10 > 0) {
      linplt(cmn, llmin1, n10);
    }
    n7 = n7 - 1;
    FEM_DO_SAFE(j, 1, n2) {
      n8++;
      m = cmn.karray(n8);
      if (m == 0) {
        goto statement_2807;
      }
      linplt(cmn, m, j);
      statement_2807:;
    }
    linplt(cmn, n9, llmin1);
    if (n7 > 0) {
      goto statement_2816;
    }
    d3 += d4;
    write(kunit6, "('+',e12.3)"), d3;
    n7 = lnpin;
    statement_2816:;
  }
  statement_2819:
  d1 = 1.0f / d1;
  d2 = 1.0f / d2;
  write(lunit6,
    "(' JUST-COMPLETED X-Y PLOT: DX/LINE =',e14.6,5x,'DY/COLUMN =',e14.6)"),
    d1, d2;
  //C     X-Y PRINTER PLOT ENDS HERE.   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& M28.6854
  if (iout == 2) {
    goto statement_1000;
  }
  statement_12581:
  if (kalcom == 1) {
    goto statement_2582;
  }
  kalcom = 1;
  begplt(cmn);
  if (kscale == 1) {
    factor(d4fact);
  }
  plot(one, vs, llmin3);
  statement_2582:
  iprsov(38)++;
  if (mulplt(2) > 0) {
    goto statement_5975;
  }
  jalf = 1;
  newpen(ll1);
  prnthd(kprhd);
  d7 = vhs;
  if (kpgrid > 0) {
    d7 += 0.1f;
  }
  //C!CALL SYMBOL ( HALF, D7, HGT1, SEXT(1), ZERO, LL78 )
  //C!CALL SYMBOL ( FL2P5, VHS+HALF, HGT2, HEADL(1), ZERO, LL16 )
  if (mulplt(1) == 0) {
    goto statement_2593;
  }
  //C!CALL SYMBOL ( HALF, FOURTH, HGT1, DAYTIM(1), ZERO, LL18 )
  //C!CALL SYMBOL ( HALF, FL3P5,  HGT1, USERID,    ZERO, LL6  )
  if (mulplt(4) == 0) {
    goto statement_5962;
  }
  plot(zero, vhs, ll3);
  plot(zero, zero, ll2);
  d4 = -.08f;
  d6 = .08f;
  d5 = -.0001f;
  statement_2589:
  plot(d4, d5, ll3);
  plot(d6, d5, ll2);
  d5 += 1.0f;
  if (d5 <= vhs) {
    goto statement_2589;
  }
  goto statement_5963;
  //C!CALL SYMBOL ( HALF, HALF, HGT1, DAYTIM(1), ZERO, LL18 )
  statement_2593:
  number(fl3, half, hgt1, countp, zero, llmin1);
  //packch(text14(1), arch10(1), mm6, mm1, mm2);
  packch(text14(1), ArraySpan(&arch10(1), arch10.size()), mm6, mm1, mm2);
  //C!CALL SYMBOL (HALF, FOURTH, HGT1, ARCH10(1) , ZERO, LL10 )
  ricp = icp;
  number(fltwo, fourth, hgt1, ricp, zero, llmin1);
  //packch(text16(1), arch10(1), mm6, mm1, mm2);
  packch(text16(1), ArraySpan(&arch10(1), arch10.size()), mm6, mm1, mm2);
  //C!CALL SYMBOL ( HALF, ZERO, HGT1, ARCH10(1), ZERO, LL10 )
  //C!CALL SYMBOL ( FLTWO, ZERO, HGT1, AUPPER(1), ZERO, JCHAR )
  statement_5962:
  vhs1 = d7 - half;
  statement_2600:
  if (jalf > ialf) {
    goto statement_2620;
  }
  //C!CALL SYMBOL ( FL1P5, VHS1, HGT1, ALPHA(JALF), ZERO, LL78 )
  vhs1 = vhs1 - half;
  jalf += 13;
  goto statement_2600;
  statement_2620:
  if (xyplot(1) == 0.0f) {
    goto statement_3496;
  }
  n7 = kpl / 2;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' BEFORE CALL TO  ''SCALE''  FOR  X-Y  PLOT.','     KPL    JPLT',"
      "11x,'X(1)',11x,'Y(1)',/,41x,2i8,2e15.6)"),
      kpl, jplt, ev(1), ev(2);
  }
  if (iprsup >= 1) {
    write(lunit6, "(/,' VECTOR  ''XYPLOT''  FOLLOWS ...',/,1x,8e15.5)"), xyplot;
  }
  //C     NOW TRANSFER TO SINGLE-PRECISION VECTOR FOR CALCOMP               M28.6862
  //C     CALLS.   XYPLOT  INTERFACED WITH  "FREFLD", RECALL.               M28.6863
  FEM_DO_SAFE(i, 1, 8) {
    xyshor(i) = xyplot(i);
  }
  if (xyplot(2) == xyplot(3)) {
    goto statement_3419;
  }
  ev(kpl + 1) = xyplot(2);
  ev(kpl + 3) = (xyplot(3) - xyplot(2)) / xyplot(1);
  goto statement_3422;
  statement_3419:
  scale(ev(1), xyshor(1), n7, ll2, xyshor(7));
  statement_3422:
  if (xyplot(5) == xyplot(6)) {
    goto statement_3426;
  }
  ev(kpl + 2) = xyplot(5);
  ev(kpl + 4) = (xyplot(6) - xyplot(5)) / xyplot(4);
  goto statement_3429;
  statement_3426:
  scale(ev(2), xyshor(4), n7, ll2, xyshor(7));
  statement_3429:
  d4 = ev(kpl + 3);
  d5 = ev(kpl + 4);
  if (iprsup >= 2) {
    write(lunit6,
      "(/,' SCALING PARAMETERS.',9x,'X-BIAS',9x,'Y-BIAS',10x,'DX/IN',10x,"
      "'DY/IN',11x,'X(1)',11x,'Y(1)',/,20x,6e15.6)"),
      ev(kpl + 1), ev(kpl + 2), d4, d5, ev(1), ev(2);
  }
  FEM_DOSTEP(i, 1, jplt, 2) {
    n5 = kpl + i;
    ev(n5) = ev(kpl + 1);
    ev(n5 + 1) = ev(kpl + 2);
    n5 += jplt;
    ev(n5) = d4;
    ev(n5 + 1) = d5;
  }
  n5++;
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' (EV(I), I=KPL, N5)  ....',/(1x,10e13.4))");
      FEM_DO_SAFE(i, kpl, n5) {
        wloop, ev(i);
      }
    }
  }
  axis(cmn, zero, zero, horzl(1), ll24, xyshor(1), zero, ev(kpl + 1), d4);
  axis(cmn, zero, zero, vertl(1), ll16, xyshor(4), fl90, ev(kpl + 2), d5);
  if (kpgrid == 0) {
    goto statement_3442;
  }
  j1 = xyplot(1);
  j2 = xyplot(4);
  newpen(kpgrid);
  grid(zero, zero, one, one, j1, j2);
  statement_3442:
  j = 0;
  if (xyplot(8) > 0.0f) {
    j = n7 / xyplot(8);
  }
  n5 = kpl / jplt;
  n12 = 0;
  FEM_DOSTEP(i, 1, jplt, 2) {
    n12++;
    newpen(kpen(n12));
    if (iprsup >= 2) {
      write(lunit6,
        "(/,' READY TO CALL  ''LINE''  AGAIN.',"
        "'       I       J    JPLT      N5',/,30x,4i8)"),
        i, j, jplt, n5;
    }
    line(ev(i), ev(i + 1), n5, jplt, j, i);
  }
  taxmax = xyplot(1) + 1.0f;
  xyplot(1) = 0.0f;
  ipl2 = jplt;
  goto statement_2656;
  statement_3496:
  if (kprhd == 0) {
    goto statement_2624;
  }
  prnthd(ll2);
  statement_2624:
  axis(cmn, zero, zero, vertl(1), ll16, vhs, fl90, vmin, dy);
  statement_5963:
  if (kprhd > 0) {
    prnthd(ll1);
  }
  if (ipl1 != 1) {
    goto statement_5970;
  }
  dlen = (hmax - hmin) * tmult / hpi;
  if (dlen < 9.0f) {
    dlen = 9.0f;
  }
  dstrt = hmin * tmult;
  statement_5970:
  if (mulplt(1) == 0) {
    goto statement_7435;
  }
  if (mulplt(5) == 0) {
    goto statement_7435;
  }
  plot(zero, ha, ll3);
  plot(dlen, ha, ll2);
  d4 = ha - .08f;
  d6 = ha + .08f;
  d5 = .9999f;
  statement_7433:
  plot(d5, d4, ll3);
  plot(d5, d6, ll2);
  d5 += 1.0f;
  if (d5 <= dlen) {
    goto statement_7433;
  }
  goto statement_7438;
  statement_7435:
  axis(cmn, zero, ha, horzl(1), mhoriz, dlen, zero, dstrt, hpi);
  statement_7438:
  if (dlen > taxmax) {
    taxmax = dlen;
  }
  if (kpgrid == 0) {
    goto statement_5975;
  }
  j1 = dlen + flzero;
  j2 = vhs + flzero;
  newpen(kpgrid);
  grid(zero, zero, one, one, j1, j2);
  statement_5975:
  iend = kplt;
  //C     &&&&&&&&&&&&&&&&&   REMOVE  CALL MOVER0  &&&&&&&&&&&&&            M28.6870
  if (iovfl == 0) {
    goto statement_5980;
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.2707
  cmn.io.rewind(lunt13);
  iend = maxevk;
  {
    read_loop rloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(j, 1, iend) {
      rloop, ev(j);
    }
  }
  if (iprsup >= 1) {
    write(lunit6, format_5979), iend;
  }
  statement_5980:
  if (iout == 1) {
    goto statement_5981;
  }
  if (lnflg == 1) {
    goto statement_3115;
  }
  jend = 0;
  kend = iend - jplt2;
  FEM_DO_SAFE(i, ipl1, ipl2) {
    jpntr(i) = 2 * i - 1;
  }
  hlo = hpt - dxl2;
  hhi = hpt + dxl2;
  statement_3010:
  if (iprsup >= 5) {
    write(lunit6,
      "(13x,'HLO',12x,'HPT',12x,'HHI',11x,'TMAX',/,1x,4e15.6)"), hlo,
      hpt, hhi, tmax;
  }
  FEM_DO_SAFE(i, ipl1, ipl2) {
    kold = 0;
    statement_3020:
    j = jpntr(i);
    evp = ev(j);
    if (evp < hlo) {
      goto statement_3100;
    }
    if (evp >= hhi) {
      goto statement_3100;
    }
    klm = (ev(j + 1) - vminl) / dyl + 1.5f;
    if (kikoy == 99) {
      klm = (ev(j + 1) - vmin) / dyl + 1.5f;
    }
    if (1 > klm) {
      klm = 1;
    }
    if (131 < klm) {
      klm = 131;
    }
    if (klm == kold) {
      goto statement_3040;
    }
    if (klm <= 9) {
      jcol = 1;
    }
    long1 = i;
    long2 = klm;
    linplt(cmn, long1, long2);
    kold = klm;
    if (iprsup >= 5) {
      write(lunit6, "(' AT 3040',i10,2e15.6,2i10)"), j, ev(j), ev(j + 1),
        i, klm;
    }
    statement_3040:
    jpntr(i) += jplt2;
    d4 = tmax - evp;
    if (d4 > 0.0f) {
      goto statement_3020;
    }
    jend = 1;
    statement_3100:;
  }
  if (iprsup >= 6) {
    write(lunit6,
      "(1x,'    LNCK    JPTS    LCNT   LNPIN    JCOL',"
      "'   JOVFL    JEND    MDPT    IPL1    IPL2  LLMIN1',/,1x,11i8)"),
      lnck, jpts, lcnt, lnpin, jcol, jovfl, jend, mdpt, ipl1, ipl2,
      llmin1;
  }
  if (jend == 1) {
    goto statement_3103;
  }
  FEM_DO_SAFE(j, ipl1, ipl2) {
    ktrm = (j * 2 - 1) + kend;
    if (jpntr(j) > ktrm) {
      goto statement_3101;
    }
    goto statement_3102;
    statement_3101:;
  }
  jend = 1;
  statement_3103:
  if (jovfl != 0) {
    goto statement_3115;
  }
  statement_3102:
  lcnt++;
  long1 = jdumy;
  linplt(cmn, long1, mmmin1);
  lnck++;
  if (lnck > jpts) {
    goto statement_3111;
  }
  if (lcnt != lnpin) {
    goto statement_3110;
  }
  if (jcol != 0) {
    goto statement_3109;
  }
  hhpt = hpt * tmult;
  if (hhpt >= 0.9999f) {
    goto statement_3106;
  }
  write(kunit6, format_3105), hhpt;
  goto statement_3109;
  statement_3106:
  d4 = hhpt * .001f;
  if (d4 >= 0.9999f) {
    goto statement_3108;
  }
  write(kunit6, "('+',2x,f7.3)"), hhpt;
  goto statement_3109;
  statement_3108:
  d4 = hhpt * 1.e-6f;
  if (d4 >= 1.0f) {
    goto statement_3119;
  }
  write(kunit6, "('+',2x,f7.0)"), hhpt;
  goto statement_3109;
  statement_3119:
  write(kunit6, format_3121), hhpt;
  statement_3109:
  lcnt = 0;
  statement_3110:
  if (jend == 1) {
    goto statement_3115;
  }
  if (mdpt == 0) {
    goto statement_31;
  }
  if (mdpt > 9) {
    goto statement_30;
  }
  j1 = lcnt + 1;
  if (j1 == lnpin) {
    goto statement_31;
  }
  statement_30:
  long1 = mdpt;
  linplt(cmn, mmmin1, long1);
  statement_31:
  jcol = 0;
  hlo = hhi;
  hpt = hlo + dxl2;
  hhi = hlo + dxl;
  goto statement_3010;
  statement_3111:
  if (iout == 2) {
    goto statement_3112;
  }
  lnflg = 1;
  write(lunit6, format_310);
  write(lunit6,
    "(' ****SINCE CALCOMP PLOT WAS ALSO SPECIFIED, ONLY PRINTER PLOT IS CANCEL"
    "LED FOR THIS REQUEST.')");
  goto statement_3115;
  statement_3112:
  write(lunit6, format_310);
  write(lunit6,
    "(' ****SINCE ONLY PRINTER PLOT WAS SPECIFIED, THIS PLOT REQUEST IS CANCEL"
    "LED.')");
  goto statement_1000;
  statement_3115:
  if (iout == 2) {
    goto statement_2645;
  }
  statement_5981:
  FEM_DO_SAFE(i, ipl1, ipl2) {
    j = 2 * i - 1;
    if (tolrce > flzero) {
      goto statement_5991;
    }
    kpltq(i) = iend / jplt2;
    j1 = j + iend;
    goto statement_6145;
    statement_5991:
    kpltq(i) = 0;
    ibase = j;
    istore = j;
    indx = j + 1 + jplt2;
    vold = ev(indx);
    statement_6000:
    evbasx = ev(ibase);
    evbasy = ev(ibase + 1);
    ev(istore) = evbasx;
    ev(istore + 1) = evbasy;
    kpltq(i)++;
    istore += jplt2;
    ipontr = ibase + jplt2;
    hvec = (ev(ipontr) - evbasx) / dx;
    vvec = (ev(ipontr + 1) - evbasy) / dy;
    denom = hvec * hvec + vvec * vvec;
    statement_6020:
    ipontr += jplt2;
    if (iovfl == 0) {
      goto statement_6025;
    }
    if (ipontr > iend) {
      goto statement_6140;
    }
    goto statement_6030;
    statement_6025:
    if (ipontr > kplt) {
      goto statement_6140;
    }
    statement_6030:
    hdif = (ev(ipontr) - evbasx) / dx;
    vnew = ev(ipontr + 1);
    vdif = (vnew - evbasy) / dy;
    term = hdif * hdif + vdif * vdif;
    enumr = hvec * hdif + vvec * vdif;
    disqr = term - enumr * enumr / denom;
    if (ipontr <= 10000 && i == 1 && iprsup >= 5) {
      write(lunit6, "(/,' AT 16030 ',3i10,6e15.5,/(1x,8e15.5))"), i,
        istore, ipontr, ev(ipontr), evbasx, dx, vnew, evbasy, dy,
        denom, enumr, disqr, hdif, vdif, hvec, vvec, term;
    }
    if (disqr > tolrce) {
      goto statement_6040;
    }
    vchnge = vnew - vold;
    vold = vnew;
    if (vvec * vchnge >  - flzero) {
      goto statement_6020;
    }
    statement_6040:
    vold = vnew;
    ibase = ipontr - jplt2;
    goto statement_6000;
    statement_6140:
    ipontr = ipontr - jplt2;
    ev(istore) = ev(ipontr);
    ev(istore + 1) = ev(ipontr + 1);
    kpltq(i)++;
    j1 = istore + jplt2;
    statement_6145:
    ev(j1) = hmin;
    ev(j1 + 1) = vmin;
    j1 += jplt2;
    ev(j1) = dx;
    ev(j1 + 1) = dy;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' AT 2630,AFTER SMOOTHING, THE NUMBER OF POINTS PER CURVE ARE',/,"
        "10x,4i10)");
      FEM_DO_SAFE(i, ipl1, ipl2) {
        wloop, kpltq(i);
      }
    }
  }
  d6 = vhs - fourth * (1.0f + mulplt(3));
  d9 = d6 + hgt1 / 2.0f;
  n5 = ipl1 + mulplt(3) - 1;
  FEM_DO_SAFE(ipl, ipl1, ipl2) {
    j1 = 2 * ipl - 1;
    newpen(kpen(ipl));
    n5++;
    line(ev(j1), ev(j1 + 1), kpltq(ipl), jplt2, jstp, n5);
    if (iovfl == 0) {
      goto statement_2641;
    }
    if (jovfl > 0) {
      goto statement_2642;
    }
    statement_2641:
    if (mulplt(1) > 0) {
      goto statement_7452;
    }
    d7 = dlen - 1.2f;
    d8 = ipl;
    number(d7, vhs1, hgt1, d8, zero, llmin1);
    d7 = dlen - 1.0f;
    plot(d7, vhs1, ll3);
    plot(dlen, vhs1, ll2);
    d7 = dlen - 0.5f;
    d8 = vhs1 + 0.1f;
    symbol(d7, d8, hgt1, ipl, zero, llmin1);
    vhs1 = vhs1 - half;
    goto statement_2642;
    statement_7452:
    d7 = dlen + 0.5f;
    if (iprsup >= 1) {
      write(lunit6,
        "(/,' LEGEND.     IPL     ICP',/,8x,6i8,3e20.6,/(1x,20a6))"),
        ipl, icp, mulplt, taxmax, vhs, d6, slot;
    }
    d8 = n5;
    number(d7, d6, hgt1, d8, zero, llmin1);
    d7 += .35f;
    //w symbol(d7, d9, hgt1, n5, zero, llmin1);
    d7 += .35f;
    n6 = ipl;
    if (icp >= 8) {
      n6 = 2 * ipl - 1;
    }
    //w symbol(d7, d6, hgt1, slot(n6), zero, ll6);
    if (mulplt(3) == 0) {
      taxmax += 2.0f;
    }
    mulplt(3)++;
    if (icp < 8) {
      goto statement_7468;
    }
    d7 += 0.8f;
    n6++;
    //w symbol(d7, d6, hgt1, slot(n6), zero, ll6);
    statement_7468:
    d6 = d6 - .25f;
    d9 = d9 - .25f;
    statement_2642:;
  }
  statement_2645:
  if (iovfl == 0) {
    goto statement_2650;
  }
  kpl = kpl - iend;
  if (kpl == 0) {
    goto statement_2650;
  }
  iend = kpl;
  if (iend > maxevk) {
    iend = maxevk;
  }
  {
    read_loop rloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(j, 1, iend) {
      rloop, ev(j);
    }
  }
  if (iprsup >= 1) {
    write(lunit6, format_5979), iend;
  }
  j1 = kpl - iend;
  if (j1 == 0) {
    jovfl = 0;
  }
  goto statement_5980;
  statement_2650:
  if (iout == 1) {
    goto statement_2653;
  }
  if (lcnt == 0) {
    goto statement_2651;
  }
  if (jcol == 1) {
    goto statement_2651;
  }
  if (lnflg == 1) {
    goto statement_2651;
  }
  hhpt = hpt * tmult;
  if (hhpt >= 1.0f) {
    goto statement_2648;
  }
  write(kunit6, format_3105), hhpt;
  goto statement_2651;
  statement_2648:
  write(kunit6, format_3121), hhpt;
  statement_2651:
  long1 = 1;
  long2 = 75;
  linplt(cmn, long1, long2);
  write(lunit6, "(/,' END OF GRAPH.',/,1x)");
  if (iout == 2) {
    goto statement_2680;
  }
  statement_2653:
  d7 = vh + 1.0f;
  mulplt(2)++;
  if (mulplt(2) < mulplt(1)) {
    goto statement_1000;
  }
  mulplt(1) = 0;
  d8 = vploff + d7;
  d9 = d8 + vh - .001f;
  if (d9 <= szplt) {
    goto statement_2657;
  }
  statement_2656:
  plot(zero, -vploff, llmin3);
  goto statement_2659;
  statement_2657:
  vploff = d8;
  plot(zero, d7, llmin3);
  goto statement_2680;
  statement_2659:
  hms = (taxmax + mrgn) * 1.001f;
  taxmax = 0.0f;
  vploff = 0.0f;
  jhmsp = hms;
  hms = jhmsp;
  jhms = jhmsp;
  statement_2646:
  if (jhmsp > 60) {
    jhmsp = 60;
  }
  advanz(jhmsp);
  if (jhmsp == 0) {
    goto statement_2647;
  }
  jhms = jhms - 60;
  if (jhms <= 0) {
    goto statement_2680;
  }
  jhmsp = jhms;
  goto statement_2646;
  statement_2647:
  plot(hms, zero, llmin3);
  statement_2680:
  if (n8 ==  - 6666) {
    goto statement_2720;
  }
  if (ipl2 == jplt) {
    goto statement_1000;
  }
  ipl1 = ipl2 + 1;
  goto statement_2580;
  statement_2720:
  if (kalcom == 1) {
    plot(zero, -vs, llmin3);
  }
  long1 = kalcom;
  endplt(long1);
  if (isprin != 43) {
    goto statement_7416;
  }
  lastov = nchain;
  nchain = 43;
  goto statement_9999;
  statement_7416:
  lastov = nchain;
  if (kbase != 1) {
    goto statement_2724;
  }
  kbase = 2;
  nchain = 12;
  goto statement_9999;
  statement_2724:
  nchain = 51;
  goto statement_9999;
  statement_2740:
  fintp(cmn);
  stoptp(cmn);
  statement_9200:
  lstat(18) = 31;
  lastov = nchain;
  nchain = 51;
  statement_9999:;

#endif
}

void over31(
  common& cmn)
{
  //C!INCLUDE  'DECK29.inc'
  subr31(cmn);
}

double
yfun39(
  common& cmn,
  double const& x)
{
  double return_value = fem::double0;
  int& ndata = cmn.ndata;
  const auto& xdat = cmn.xdat;
  const auto& ydat = cmn.ydat;
  //
  double ai = fem::double0;
  int i1 = fem::int0;
  double y = fem::double0;
  if (x <= xdat(1)) {
    goto statement_120;
  }
  if (x >= xdat(ndata)) {
    goto statement_100;
  }
  ai = cmn.aptdec * (x - xdat(1)) + 1.e0;
  i1 = ai;
  y = (x - xdat(i1)) * (ydat(i1 + 1) - ydat(i1)) / (xdat(i1 + 1) - xdat(i1));
  return_value = y + ydat(i1);
  goto statement_110;
  statement_120:
  return_value = ydat(1);
  goto statement_110;
  statement_100:
  return_value = ydat(ndata);
  statement_110:
  return return_value;
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}

void split(
  common& cmn,
  double const& xbeg,
  double const& xend,
  double const& ycutpu,
  double& xcut) try
{
  double& refa = cmn.refa;
  double& refb = cmn.refb;
  const auto& xdat = cmn.xdat;
  //
  double dxspli = fem::double0;
  double xfirst = fem::double0;
  double xlast = fem::double0;
  double ycut = fem::double0;
  double x = fem::double0;
  double x1 = fem::double0;
  double d1 = fem::double0;
  dxspli = .1e0;
  xfirst = xdat(1);
  xlast = xdat(cmn.ndata);
  ycut = refa + ycutpu * (refb - refa);
  //C AVOID OVERSHOT
  if (std::abs(xbeg - xend) < 0.1f) {
    dxspli = .01e0;
  }
  if (xbeg > xend) {
    goto statement_130;
  }
  if (refa < refb) {
    goto statement_110;
  }
  statement_90:
  x = xbeg - dxspli;
  statement_100:
  x1 = x;
  x += dxspli;
  if (x > xlast) {
    x = xlast;
  }
  if (yfun39(cmn, x) <= ycut) {
    goto statement_170;
  }
  if (x == xlast) {
    goto statement_110;
  }
  goto statement_100;
  statement_110:
  x = xbeg - dxspli;
  statement_120:
  x1 = x;
  x += dxspli;
  if (x > xlast) {
    x = xlast;
  }
  if (yfun39(cmn, x) >= ycut) {
    goto statement_170;
  }
  if (x == xlast) {
    goto statement_90;
  }
  goto statement_120;
  statement_130:
  if (refa > refb) {
    goto statement_150;
  }
  statement_135:
  x = xbeg + dxspli;
  statement_140:
  x1 = x;
  x = x - dxspli;
  if (x < xfirst) {
    x = xfirst;
  }
  if (yfun39(cmn, x) >= ycut) {
    goto statement_170;
  }
  if (x == xfirst) {
    goto statement_150;
  }
  goto statement_140;
  statement_150:
  x = xbeg + dxspli;
  statement_160:
  x1 = x;
  x = x - dxspli;
  if (x < xfirst) {
    x = xfirst;
  }
  if (yfun39(cmn, x) <= ycut) {
    goto statement_170;
  }
  if (x == xfirst) {
    goto statement_135;
  }
  goto statement_160;
  statement_170:
  if (x1 < xfirst) {
    x1 = xfirst;
  }
  d1 = yfun39(cmn, x1);
  xcut = x1 + (x - x1) * (ycut - d1) / (yfun39(cmn, x) - d1);
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void locsl(
  common& cmn,
  double const& xbeg,
  double const& xend,
  double const& alpha,
  double& xmid,
  double& xcorna,
  double& xcornb,
  double& erymax) try
{
  common_write write(cmn);
  const auto& xknee = cmn.xknee;
  double& onehav = cmn.onehav;
  double& refa = cmn.refa;
  double& refb = cmn.refb;
  int& idebug = cmn.idebug;
  int& lout = cmn.lout;
  int& izone = cmn.izone;
  //
  double d78 = fem::double0;
  double d1 = fem::double0;
  double refd2 = fem::double0;
  double refdpc = fem::double0;
  double d2 = fem::double0;
  int jn = fem::int0;
  double xdelta = fem::double0;
  double dxedma = fem::double0;
  int iter = fem::int0;
  double xcorar = fem::double0;
  double xcorbr = fem::double0;
  double erropt = fem::double0;
  int idefac = fem::int0;
  int lsign = fem::int0;
  int n = fem::int0;
  int j = fem::int0;
  double error = fem::double0;
  double x = fem::double0;
  double yapprx = fem::double0;
  int idefop = fem::int0;
  double xl1 = fem::double0;
  double xl2 = fem::double0;
  double x1 = fem::double0;
  double x2 = fem::double0;
  double agamma = fem::double0;
  double d13 = fem::double0;
  double errory = fem::double0;
  d78 = xend - xbeg;
  if (std::abs(d78) >= 0.01f) {
    goto statement_50;
  }
  //C REALLY SMALL RANGE
  if (d78 > 0.0f) {
    xmid = xbeg + d78 / 2;
  }
  //C CONSIDERATION,  THL
  if (d78 < 0.0f) {
    xmid = xend - d78 / 2;
  }
  //C  9/14/89
  goto statement_80;
  statement_50:
  split(cmn, xbeg, xend, onehav, xmid);
  statement_80:
  d1 = std::abs(xend - xmid);
  if (d1 <= 0.001e0) {
    return;
  }
  if (idebug < 4) {
    goto statement_2100;
  }
  refd2 = std::abs((refa - refb) * onehav);
  refdpc = 100.e0 * (fem::pow(10.e0, refd2) - 1.e0);
  write(lout,
    "(1x,'REFA=',e11.4,3x,'REFB=',e11.4,3x,'REFDPC=',e11.4,'%')"),
    refa, refb, refdpc;
  //C   PLACE SEGMENT INITIALLY AT MID POINT                                M32.8826
  statement_2100:
  d2 = (refb - refa) / 2.f / alpha;
  xcorna = xmid - d2;
  xcornb = xmid + d2;
  jn = std::abs(alpha);
  d1 = xend - xbeg;
  xdelta = d1 / (20 * jn);
  dxedma = d1 / (50 * jn);
  //C                                                                       M32.8833
  FEM_DO_SAFE(iter, 1, 2) {
    xcorar = xcorna;
    xcorbr = xcornb;
    xcorna = xcorna - xdelta;
    xcornb = xcornb - xdelta;
    erropt = 1.e12;
    idefac = -1;
    lsign = 1;
    //C    In 248 loop, N=1 is for R-shift, N=2 is for L-shift
    FEM_DO_SAFE(n, 1, 2) {
      if (n == 1) {
        goto statement_98;
      }
      idefac = 0;
      lsign = -1;
      statement_98:
      FEM_DO_SAFE(j, 1, 5) {
        idefac += lsign;
        xcorna += xdelta * lsign;
        xcornb += xdelta * lsign;
        //C   CHECK ALLOCATION ERROR                                              M32.8846
        error = 0.f;
        x = xbeg - xdelta;
        statement_100:
        x += xdelta;
        if (x > xend) {
          goto statement_140;
        }
        if (x <= xcorna) {
          goto statement_110;
        }
        if (x > xcornb) {
          goto statement_120;
        }
        yapprx = refa + (x - xcorna) * alpha;
        goto statement_130;
        statement_110:
        yapprx = refa;
        goto statement_130;
        statement_120:
        yapprx = refb;
        statement_130:
        error += fem::pow2((yapprx - yfun39(cmn, x)));
        goto statement_100;
        statement_140:
        if (idebug < 4) {
          goto statement_8069;
        }
        if (n == 1) {
          write(lout, "(1x,'SHIFT R',i5,4e12.4)"), idefac, xcorna,
            xcornb, error, erropt;
        }
        if (n == 2) {
          write(lout, "(1x,'SHIFT L',i5,4e12.4)"), idefac, xcorna,
            xcornb, error, erropt;
        }
        //C Avoid infinite loop, change
        statement_8069:
        if (error >= erropt) {
          goto statement_150;
        }
        //C .GT. to .GE.,  THL, 9/12/89
        erropt = error;
        idefop = idefac;
        //C  THL
        statement_150:
        if (error >= 2.f / iter * erropt) {
          goto statement_170;
        }
      }
      statement_170:
      if (n == 2) {
        goto statement_250;
      }
      //C   RESTORE ORIGINAL POSITION BEFORE SHIFTING TO THE LEFT               M32.8868
      xcorna = xcorar;
      xcornb = xcorbr;
    }
    //C   SHIFT ACCORDING TO OPTIMUM VALUE                                    M32.8899
    statement_250:
    xcorna = xcorar + idefop * xdelta;
    xcornb = xcorbr + idefop * xdelta;
    xdelta = xdelta / 4.f;
  }
  //C  OBTAIN MAXIMUM DEVIATION                                             M32.8904
  erymax = 0.f;
  xl1 = xknee(izone);
  xl2 = xknee(izone + 1);
  x = xcorna - dxedma;
  statement_270:
  x += dxedma;
  if (x > xcornb) {
    goto statement_310;
  }
  x1 = x - dxedma;
  x2 = x + dxedma;
  if (x1 < xl1) {
    x1 = x;
  }
  if (x2 > xl2) {
    x2 = x;
  }
  if (x1 != x2) {
    goto statement_280;
  }
  agamma = 0.f;
  goto statement_290;
  statement_280:
  agamma = (yfun39(cmn, x2) - yfun39(cmn, x1)) / (x2 - x1);
  statement_290:
  yapprx = refa + (x - xcorna) * alpha;
  d13 = 1.0f + fem::pow2(agamma);
  errory = std::abs((yapprx - yfun39(cmn, x)) / sqrtz(d13));
  if (errory < erymax) {
    goto statement_300;
  }
  erymax = errory;
  statement_300:
  goto statement_270;
  statement_310:;
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void refh(
  common& cmn) try
{
  const auto& indxv = cmn.indxv;
  const auto& azepo = cmn.azepo;
  double& hreflg = cmn.hreflg;
  double& onehav = cmn.onehav;
  int& iftype = cmn.iftype;
  int& ntotra = cmn.ntotra;
  const auto& xdat = cmn.xdat;
  //
  double xref = fem::double0;
  int i2 = fem::int0;
  double href = fem::double0;
  int irange = fem::int0;
  int id = fem::int0;
  double alpha = fem::double0;
  int jn = fem::int0;
  int indexp = fem::int0;
  int indexz = fem::int0;
  int j = fem::int0;
  double fpole = fem::double0;
  double fzero = fem::double0;
  xref = xdat(1);
  i2 = ntotra;
  if (iftype == 2) {
    i2 = ntotra - 1;
  }
  href = 1.e0;
  if (i2 == 0) {
    goto statement_180;
  }
  FEM_DO_SAFE(irange, 1, i2) {
    id = indxv(irange);
    alpha = azepo(id + 2);
    if (alpha > 0.f) {
      goto statement_110;
    }
    jn = -alpha + onehav;
    indexp = id + 2;
    indexz = indexp + jn;
    goto statement_120;
    statement_110:
    jn = alpha + onehav;
    indexz = id + 2;
    indexp = indexz + jn;
    statement_120:
    FEM_DO_SAFE(j, 1, jn) {
      fpole = azepo(indexp + j);
      fzero = azepo(indexz + j);
      href = href * fpole / fzero;
    }
  }
  statement_180:
  hreflg = alog1z(href);
  if (iftype == 1) {
    goto statement_170;
  }
  id = indxv(ntotra);
  alpha = azepo(id + 2);
  jn = -alpha + onehav;
  indexp = id + 2;
  FEM_DO_SAFE(j, 1, jn) {
    fpole = azepo(indexp + j);
    hreflg += alog1z(fpole);
  }
  statement_170:
  hreflg += yfun39(cmn, xref);
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void ratp(
  common& cmn,
  double const& freq,
  double& amaglg) try
{
  const auto& indxv = cmn.indxv;
  const auto& azepo = cmn.azepo;
  double& onehav = cmn.onehav;
  int& iftype = cmn.iftype;
  int& ntotra = cmn.ntotra;
  //
  int i2 = fem::int0;
  double freq2 = fem::double0;
  double amagp = fem::double0;
  int irange = fem::int0;
  int id = fem::int0;
  double alpha = fem::double0;
  int jn = fem::int0;
  int indexp = fem::int0;
  int indexz = fem::int0;
  int j = fem::int0;
  double fpole = fem::double0;
  double fzero = fem::double0;
  i2 = ntotra;
  if (iftype == 2) {
    i2 = ntotra - 1;
  }
  freq2 = fem::pow2(freq);
  amagp = 1.e0;
  if (i2 == 0) {
    goto statement_180;
  }
  FEM_DO_SAFE(irange, 1, i2) {
    id = indxv(irange) + 2;
    alpha = azepo(id);
    if (alpha > 0.f) {
      goto statement_110;
    }
    jn = -alpha + onehav;
    indexp = id;
    indexz = indexp + jn;
    goto statement_120;
    statement_110:
    jn = alpha + onehav;
    indexz = id;
    indexp = indexz + jn;
    statement_120:
    FEM_DO_SAFE(j, 1, jn) {
      fpole = azepo(indexp + j);
      fzero = azepo(indexz + j);
      amagp = amagp * (fem::pow2(fzero) + freq2) / (fem::pow2(fpole) + freq2);
    }
  }
  statement_180:
  amaglg = alog1z(amagp);
  if (iftype == 1) {
    goto statement_170;
  }
  id = indxv(ntotra) + 2;
  alpha = azepo(id);
  jn = -alpha + onehav;
  FEM_DO_SAFE(j, 1, jn) {
    fpole = azepo(id + j);
    amaglg = amaglg - alog1z(fem::pow2(fpole) + freq2);
  }
  statement_170:
  amaglg = cmn.hreflg + amaglg / 2.e0;
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void adjpk(
  common& cmn) try
{
  common_write write(cmn);
  const auto& indxv = cmn.indxv;
  auto& azepo = cmn.azepo;
  double& onehav = cmn.onehav;
  double& oneqtr = cmn.oneqtr;
  double& refb = cmn.refb;
  int& idebug = cmn.idebug;
  int& lout = cmn.lout;
  int& ntotra = cmn.ntotra;
  const auto& xdat = cmn.xdat;
  //
  int mdimpz = fem::int0;
  int ntotr1 = fem::int0;
  int irange = fem::int0;
  int index1 = fem::int0;
  int index2 = fem::int0;
  double alph1 = fem::double0;
  double alph2 = fem::double0;
  double xl1 = fem::double0;
  double xr1 = fem::double0;
  int id = fem::int0;
  double xpeak = fem::double0;
  double xbeg = fem::double0;
  double xend = fem::double0;
  int jn1 = fem::int0;
  int jn2 = fem::int0;
  int id1 = fem::int0;
  int id2 = fem::int0;
  double flim1 = fem::double0;
  double flim2 = fem::double0;
  double djn1 = fem::double0;
  double djn2 = fem::double0;
  double erropt = fem::double0;
  int isub = fem::int0;
  double dsub2 = fem::double0;
  double dxepk = fem::double0;
  double tolerr = fem::double0;
  double dfx = fem::double0;
  double dfpk1 = fem::double0;
  double dfpk2 = fem::double0;
  double dfpk11 = fem::double0;
  double dfpk22 = fem::double0;
  int j = fem::int0;
  arr_1d<50, double> fpz1(fem::fill0);
  arr_1d<50, double> fpz2(fem::fill0);
  int idefac = fem::int0;
  int jsh = fem::int0;
  double fcorn1 = fem::double0;
  double fcorn2 = fem::double0;
  double error = fem::double0;
  double x = fem::double0;
  double f = fem::double0;
  double amaglg = fem::double0;
  double yapprx = fem::double0;
  int idefop = fem::int0;
  double df11 = fem::double0;
  double df22 = fem::double0;
  //C  CHANGE THIS LIMIT IF DIMENSION IS CHANGED                            M32.8931
  //C   ORDER OF SLOPE IN SEGMENT (CONSECUTIVE POLES OR ZEROES)             M32.8932
  mdimpz = 50;
  if (ntotra == 1) {
    goto statement_340;
  }
  ntotr1 = ntotra - 1;
  FEM_DO_SAFE(irange, 1, ntotr1) {
    index1 = indxv(irange);
    index2 = indxv(irange + 1);
    alph1 = azepo(index1 + 2);
    alph2 = azepo(index2 + 2);
    if (alph1 * alph2 > 0.f) {
      goto statement_330;
    }
    xl1 = azepo(index1 + 1);
    if (irange < ntotr1) {
      goto statement_100;
    }
    xr1 = xdat(cmn.ndata);
    goto statement_110;
    statement_100:
    id = indxv(irange + 2);
    xr1 = azepo(id + 1);
    statement_110:
    xpeak = azepo(index2 + 1);
    cmn.refa = yfun39(cmn, xpeak);
    refb = yfun39(cmn, xl1);
    split(cmn, xpeak, xl1, oneqtr, xbeg);
    refb = yfun39(cmn, xr1);
    split(cmn, xpeak, xr1, oneqtr, xend);
    jn1 = std::abs(alph1) + onehav;
    jn2 = std::abs(alph2) + onehav;
    if (jn1 > mdimpz || jn2 > mdimpz) {
      goto statement_2100;
    }
    id1 = index1 + 2 + jn1;
    id2 = index2 + 2;
    flim1 = azepo(id1);
    flim2 = azepo(id2 + jn2 + 1);
    if (idebug >= 3) {
      write(lout, "(/,1x,10x,'ADJUSTMENT OF PEAK:',e12.4)"), xpeak;
    }
    djn1 = 1.e0 / jn1;
    djn2 = 1.e0 / jn2;
    //C  THL
    erropt = 1.e12f;
    FEM_DO_SAFE(isub, 1, 3) {
      dsub2 = 1.e0 / (fem::pow2(isub));
      dxepk = .3e0 * dsub2;
      tolerr = fem::pow(1.01e0, dsub2);
      dfx = fem::pow(10.e0, (.02e0 * dsub2 / isub));
      dfpk1 = fem::pow(dfx, djn1);
      dfpk2 = fem::pow(dfx, djn2);
      dfpk11 = 1.e0 / dfpk1;
      dfpk22 = 1.e0 / dfpk2;
      //C   STORE ORIGINAL VALUES IN TEMPORARY VECTORS                          M32.8967
      FEM_DO_SAFE(j, 1, jn1) {
        fpz1(j) = azepo(id1 + j);
        azepo(id1 + j) = azepo(id1 + j) * dfpk11;
      }
      FEM_DO_SAFE(j, 1, jn2) {
        fpz2(j) = azepo(id2 + j);
        azepo(id2 + j) = azepo(id2 + j) * dfpk2;
      }
      //C   SHIFT INWARDS                                                       M32.8976
      //C      ERROPT = 1.E12    !  THL
      idefac = -1;
      FEM_DO_SAFE(jsh, 1, 50) {
        idefac++;
        fcorn1 = azepo(id1 + jn1) * dfpk1;
        fcorn2 = azepo(id2 + 1) * dfpk22;
        if (fcorn1 > fcorn2) {
          goto statement_200;
        }
        FEM_DO_SAFE(j, 1, jn1) {
          azepo(id1 + j) = azepo(id1 + j) * dfpk1;
        }
        FEM_DO_SAFE(j, 1, jn2) {
          azepo(id2 + j) = azepo(id2 + j) * dfpk22;
        }
        refh(cmn);
        //C   CHECK ERROR                                                         M32.8989
        error = 0.f;
        x = xbeg - dxepk;
        statement_160:
        x += dxepk;
        if (x > xend) {
          goto statement_170;
        }
        f = fem::pow(10.e0, x);
        ratp(cmn, f, amaglg);
        yapprx = amaglg;
        error += fem::pow2((yapprx - yfun39(cmn, x)));
        goto statement_160;
        statement_170:
        if (idebug >= 4) {
          write(lout, "(1x,'SHIFT IN ',i5,4e12.4)"), idefac, fcorn1,
            fcorn2, error, erropt;
        }
        //C THL
        if (error >= erropt) {
          goto statement_180;
        }
        erropt = error;
        idefop = idefac;
        //C THL
        statement_180:
        if (error >= tolerr * erropt) {
          goto statement_200;
        }
      }
      //C   RESTORE ORIGINAL VALUES BEFORE SHIFTING IN THE OPPOSITE DIRECTION   M32.9007
      statement_200:
      FEM_DO_SAFE(j, 1, jn1) {
        azepo(id1 + j) = fpz1(j);
      }
      FEM_DO_SAFE(j, 1, jn2) {
        azepo(id2 + j) = fpz2(j);
      }
      //C   SHIFT OUTWARDS                                                      M32.9012
      idefac = 0;
      FEM_DO_SAFE(jsh, 1, 50) {
        idefac = idefac - 1;
        fcorn1 = azepo(id1 + 1) * dfpk11;
        fcorn2 = azepo(id2 + jn2) * dfpk2;
        if (fcorn1 < flim1) {
          goto statement_290;
        }
        if (fcorn2 > flim2) {
          goto statement_290;
        }
        FEM_DO_SAFE(j, 1, jn1) {
          azepo(id1 + j) = azepo(id1 + j) * dfpk11;
        }
        FEM_DO_SAFE(j, 1, jn2) {
          azepo(id2 + j) = azepo(id2 + j) * dfpk2;
        }
        refh(cmn);
        //C   CHECK ERROR                                                         M32.9025
        error = 0.f;
        x = xbeg - dxepk;
        statement_250:
        x += dxepk;
        if (x > xend) {
          goto statement_260;
        }
        f = fem::pow(10.e0, x);
        ratp(cmn, f, amaglg);
        yapprx = amaglg;
        error += fem::pow2((yapprx - yfun39(cmn, x)));
        goto statement_250;
        statement_260:
        if (idebug >= 4) {
          write(lout, "(1x,'SHIFT OUT',i5,4e12.4)"), idefac, fcorn1,
            fcorn2, error, erropt;
        }
        //C THL
        if (error >= erropt) {
          goto statement_270;
        }
        erropt = error;
        idefop = idefac;
        //C THL
        statement_270:
        if (error >= tolerr * erropt) {
          goto statement_290;
        }
      }
      //C   SHIFT ACCORDING TO OPTIMUM VALUE                                    M32.9043
      statement_290:
      df11 = fem::pow(dfpk1, idefop);
      FEM_DO_SAFE(j, 1, jn1) {
        azepo(id1 + j) = fpz1(j) * df11;
      }
      df22 = fem::pow(dfpk22, idefop);
      FEM_DO_SAFE(j, 1, jn2) {
        azepo(id2 + j) = fpz2(j) * df22;
      }
    }
    statement_330:;
  }
  statement_340:
  return;
  //C               TERMINATING CONDITIONS                                  M32.9051
  statement_2100:
  write(lout,
    "(/,/,1x,'%%% DIMENSION OF FPZ1 OR FPZ2 (',i2,"
    "') EXCEEDED. EXECUTION TERMINATED %%%')"),
    mdimpz;
  stoptp(cmn);
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
shira(
  common& cmn,
  double const& xbeg,
  double const& xend,
  double const& fbeg,
  double const& fend,
  int const& /* iter */,
  int const& index,
  int const& irange) try
{
  common_write write(cmn);
  auto& azepo = cmn.azepo;
  int& idebug = cmn.idebug;
  int& lout = cmn.lout;
  //
  int mdifpz = fem::int0;
  int iflgrh = fem::int0;
  double alpha = fem::double0;
  int jn = fem::int0;
  int j2n = fem::int0;
  int id = fem::int0;
  double d13 = fem::double0;
  double erropt = fem::double0;
  int isub = fem::int0;
  double dxecr = fem::double0;
  double tolerr = fem::double0;
  double dfx = fem::double0;
  double fdelta = fem::double0;
  double fdelt1 = fem::double0;
  int j = fem::int0;
  arr_1d<50, double> fpz(fem::fill0);
  int idefac = fem::int0;
  int idefop = fem::int0;
  int jsh = fem::int0;
  double fcorn2 = fem::double0;
  double error = fem::double0;
  double x = fem::double0;
  double f = fem::double0;
  double amaglg = fem::double0;
  double yapprx = fem::double0;
  double fcorn1 = fem::double0;
  double fdelt2 = fem::double0;
  //C  CHANGE THIS LIMIT IF DIMENSION IS CHANGED                            M32.9315
  //C   ORDER OF SLOPE IN SEGMENT * 2                                       M32.9316
  mdifpz = 100;
  iflgrh = 0;
  if (cmn.izone == cmn.nzone && irange == cmn.nrange && cmn.iftype == 2) {
    iflgrh = 1;
  }
  alpha = azepo(index + 2);
  jn = std::abs(alpha) + cmn.onehav;
  j2n = 2 * jn;
  if (j2n > mdifpz) {
    goto statement_2100;
  }
  id = index + 2;
  if (idebug >= 3) {
    write(lout,
      "(/,1x,5x,'CORNERS ADJUSTMENT OF RANGE',i3,' :',2x,'X1=',e10.4,3x,'X2=',"
      "e10.4)"),
      irange, xbeg, xend;
  }
  d13 = 1.e0 / jn;
  d13 = sqrtz(d13);
  //C  THL
  erropt = 1.e12;
  FEM_DO_SAFE(isub, 1, 3) {
    dxecr = .5e0 / isub;
    tolerr = fem::pow(1.01e0, (1.f / fem::pow2(isub)));
    dfx = fem::pow(10.e0, (dxecr * .1e0));
    fdelta = fem::pow(dfx, d13);
    fdelt1 = 1.e0 / fdelta;
    //C   PRESERVE ORIGINAL POSITIONS AND PREPARE FOR SHIFTING                M32.9336
    FEM_DO_SAFE(j, 1, j2n) {
      fpz(j) = azepo(id + j);
      azepo(id + j) = azepo(id + j) * fdelt1;
    }
    //C   SHIFT TO THE RIGHT                                                  M32.9341
    //C      ERROPT = 1.D12       ! I THINK THIS SHOULD BE MOVED OUTSIDE LOOP
    idefac = -1;
    idefop = 0;
    FEM_DO_SAFE(jsh, 1, 50) {
      fcorn2 = azepo(id + j2n) * fdelta;
      if (fcorn2 > fend) {
        goto statement_160;
      }
      idefac++;
      FEM_DO_SAFE(j, 1, j2n) {
        azepo(id + j) = azepo(id + j) * fdelta;
      }
      //C   CHECK ERROR                                                         M32.9351
      if (iflgrh == 1) {
        refh(cmn);
      }
      error = 0.f;
      x = xbeg - dxecr;
      statement_120:
      x += dxecr;
      if (x > xend) {
        goto statement_130;
      }
      f = fem::pow(10.e0, x);
      ratp(cmn, f, amaglg);
      yapprx = amaglg;
      error += fem::pow2((yapprx - yfun39(cmn, x)));
      goto statement_120;
      statement_130:
      if (idebug >= 4) {
        write(lout, "(1x,'SHIFT R',i5,4e12.4)"), idefac, fcorn2,
          fend, error, erropt;
      }
      //C THL
      if (error >= erropt) {
        goto statement_140;
      }
      erropt = error;
      idefop = idefac;
      //C THL
      statement_140:
      if (error >= tolerr * erropt) {
        goto statement_160;
      }
    }
    //C   RESTORE ORIGINAL VALUES BEFORE SHIFTING TO THE LEFT                 M32.9370
    statement_160:
    FEM_DO_SAFE(j, 1, j2n) {
      azepo(id + j) = fpz(j);
    }
    //C   SHIFT TO THE LEFT                                                   M32.9373
    idefac = 0;
    FEM_DO_SAFE(jsh, 1, 50) {
      fcorn1 = azepo(id + 1) * fdelt1;
      if (fcorn1 < fbeg) {
        goto statement_230;
      }
      idefac = idefac - 1;
      FEM_DO_SAFE(j, 1, j2n) {
        azepo(id + j) = azepo(id + j) * fdelt1;
      }
      //C   CHECK ERROR                                                         M32.9381
      if (iflgrh == 1) {
        refh(cmn);
      }
      error = 0.f;
      x = xbeg - dxecr;
      statement_190:
      x += dxecr;
      if (x > xend) {
        goto statement_200;
      }
      f = fem::pow(10.e0, x);
      ratp(cmn, f, amaglg);
      yapprx = amaglg;
      error += fem::pow2((yapprx - yfun39(cmn, x)));
      goto statement_190;
      statement_200:
      if (idebug >= 4) {
        write(lout, "(1x,'SHIFT L',i5,4e12.4)"), idefac, fcorn1,
          fbeg, error, erropt;
      }
      //C  THL
      if (error >= erropt) {
        goto statement_210;
      }
      erropt = error;
      idefop = idefac;
      //C  THL
      statement_210:
      if (error >= tolerr * erropt) {
        goto statement_230;
      }
    }
    //C   SHIFT ACCORDING TO OPTIMUM VALUE                                    M32.9400
    statement_230:
    fdelt2 = fem::pow(fdelta, idefop);
    FEM_DO_SAFE(j, 1, j2n) {
      azepo(id + j) = fpz(j) * fdelt2;
    }
  }
  if (iflgrh == 1) {
    refh(cmn);
  }
  return;
  //C             TERMINATING CONDITIONS                                    M32.9406
  statement_2100:
  write(lout,
    "(/,/,1x,'%%% DIMENSION OF FPZ (',i2,"
    "') EXCEEDED. EXECUTION TERMINATED %%%')"),
    mdifpz;
  stoptp(cmn);
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
inran(
  common& cmn,
  int const& irange,
  int& indx0,
  int& indxr1,
  int& indxr2,
  int& indxr3,
  int& indxl1,
  int& indxl2) try
{
  // COMMON com39
  const auto& indxv = cmn.indxv;
  int& ntotra = cmn.ntotra;
  //
  int id = irange;
  indx0 = indxv(id);
  id++;
  if (id > ntotra) {
    id = ntotra;
  }
  indxr1 = indxv(id);
  id++;
  if (id > ntotra) {
    id = ntotra;
  }
  indxr2 = indxv(id);
  id++;
  if (id > ntotra) {
    id = ntotra;
  }
  indxr3 = indxv(id);
  id = irange - 1;
  if (id < 1) {
    id = 1;
  }
  indxl1 = indxv(id);
  id = id - 1;
  if (id < 1) {
    id = 1;
  }
  indxl2 = indxv(id);
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
adjcr(
  common& cmn) try
{
  common_write write(cmn);
  const auto& azepo = cmn.azepo;
  const auto& noprao = cmn.noprao;
  int& idebug = cmn.idebug;
  int& lout = cmn.lout;
  int& nzone = cmn.nzone;
  int& izone = cmn.izone;
  int& nrange = cmn.nrange;
  const auto& xdat = cmn.xdat;
  //
  double xlast = fem::double0;
  double xfirst = fem::double0;
  int nzone1 = fem::int0;
  int iter = fem::int0;
  int irangt = fem::int0;
  int nrang1 = fem::int0;
  int irange = fem::int0;
  int indx0 = fem::int0;
  int indxr1 = fem::int0;
  int indxr2 = fem::int0;
  int indxr3 = fem::int0;
  int indxl1 = fem::int0;
  int indxl2 = fem::int0;
  double xbeg = fem::double0;
  double xbegf = fem::double0;
  double fbeg = fem::double0;
  double xend = fem::double0;
  double xendf = fem::double0;
  double fend = fem::double0;
  auto& lunit6 = cmn.lunit6;
  int index = fem::int0;
  double alpha = fem::double0;
  int jn = fem::int0;
  int i1 = fem::int0;
  int i2 = fem::int0;
  int i = fem::int0;
  refh(cmn);
  xlast = xdat(cmn.ndata);
  xfirst = xdat(1);
  nzone1 = nzone - 1;
  FEM_DO_SAFE(iter, 1, 3) {
    if (idebug >= 3) {
      write(lout, "(/,/,5x,'*** SHIFTING ITERATION NO.',i2,3x,'***')"), iter;
    }
    irangt = 0;
    //C             SHIFTING OF ZONES
    FEM_DO_SAFE(izone, 1, nzone) {
      nrange = noprao(izone);
      nrang1 = nrange - 1;
      if (idebug >= 3) {
        write(lout,
          "(/,1x,'*** CORNERS ADJUSTMENT OF ZONE',i3,';',2x,'THERE ARE',i3,2x,"
          "' RANGES ***')"),
          izone, nrange;
      }
      FEM_DO_SAFE(irange, 1, nrange) {
        irangt++;
        inran(cmn, irangt, indx0, indxr1, indxr2, indxr3, indxl1, indxl2);
        if (nzone == 1) {
          goto statement_180;
        }
        if (nrange == 1) {
          goto statement_280;
        }
        if (nrange == 2) {
          goto statement_290;
        }
        if (nrange == 3) {
          goto statement_300;
        }
        if (irange == 1) {
          goto statement_240;
        }
        if (irange == 2) {
          goto statement_250;
        }
        if (irange == nrang1) {
          goto statement_260;
        }
        if (irange == nrange) {
          goto statement_270;
        }
        //C   INTERMEDIATE RANGES                                                 M32.9175
        statement_100:
        xbeg = azepo(indxl2 + 1);
        xbegf = azepo(indxl1 + 1);
        fbeg = fem::pow(10.f, xbegf);
        xend = azepo(indxr3 + 1);
        xendf = azepo(indxr2 + 1);
        fend = fem::pow(10.f, xendf);
        goto statement_320;
        //C             SPECIAL CASE: ONE ZONE ONLY                               M32.9137
        statement_180:
        if (nrange <= 2) {
          goto statement_190;
        }
        if (nrange == 3) {
          goto statement_200;
        }
        if (irange == 1) {
          goto statement_240;
        }
        if (irange == 2) {
          goto statement_250;
        }
        if (irange >= nrang1) {
          goto statement_210;
        }
        goto statement_100;
        statement_190:
        xbeg = xfirst;
        fbeg = fem::pow(10.f, (xbeg - 1.f));
        xend = xlast;
        fend = fem::pow(10.f, (xend + 1.f));
        goto statement_320;
        statement_200:
        if (irange == 1) {
          goto statement_240;
        }
        if (irange == 2) {
          goto statement_190;
        }
        statement_210:
        xbeg = azepo(indxl2 + 1);
        xbegf = azepo(indxl1 + 1);
        fbeg = fem::pow(10.f, xbegf);
        xend = xlast;
        fend = fem::pow(10.f, (xend + 1.f));
        goto statement_320;
        //C   FIRST RANGE                                                         M32.9183
        statement_240:
        xbeg = azepo(indxl1 + 1);
        xbegf = azepo(indx0 + 1);
        fbeg = fem::pow(10.f, xbegf);
        if (izone == 1) {
          fbeg = fbeg / 10.f;
        }
        if (izone == nzone && nrange == 2) {
          goto statement_245;
        }
        xend = azepo(indxr3 + 1);
        fend = azepo(indxr1 + 3);
        if (izone != 1) {
          goto statement_320;
        }
        xendf = azepo(indxr2 + 1);
        fend = fem::pow(10.f, xendf);
        goto statement_320;
        statement_245:
        xend = xlast;
        fend = azepo(indxr1 + 3);
        goto statement_320;
        //C   SECOND RANGE                                                        M32.9190
        statement_250:
        xbeg = azepo(indxl2 + 1);
        fbeg = azepo(indx0);
        if (izone == 1) {
          fbeg = fbeg / 10.f;
        }
        xend = azepo(indxr3 + 1);
        xendf = azepo(indxr2 + 1);
        fend = fem::pow(10.f, xendf);
        goto statement_320;
        //C   ONE-TO-LAST RANGE                                                   M32.9197
        statement_260:
        xbeg = azepo(indxl2 + 1);
        xbegf = azepo(indxl1 + 1);
        fbeg = fem::pow(10.f, xbegf);
        if (izone == nzone) {
          goto statement_285;
        }
        xend = azepo(indxr3 + 1);
        fend = azepo(indxr1 + 3);
        goto statement_320;
        statement_285:
        xend = xlast;
        fend = fem::pow(10.f, (xend + 1.f));
        goto statement_320;
        //C   LAST RANGE                                                          M32.9204
        statement_270:
        xbeg = azepo(indxl2 + 1);
        fbeg = azepo(indx0);
        if (izone == nzone) {
          goto statement_285;
        }
        xend = azepo(indxr2 + 1);
        xendf = azepo(indxr1 + 1);
        fend = fem::pow(10.f, xendf);
        goto statement_320;
        //C   SPECIAL CASES                                                       M32.9211
        //C   ONE-RANGE ZONE                                                      M32.9212
        statement_280:
        xbeg = azepo(indxl1 + 1);
        xbegf = azepo(indx0 + 1);
        fbeg = fem::pow(10.f, xbegf);
        if (izone == 1) {
          fbeg = fbeg / 10.f;
        }
        if (izone == nzone) {
          goto statement_285;
        }
        xend = azepo(indxr2 + 1);
        xendf = azepo(indxr1 + 1);
        fend = fem::pow(10.f, xendf);
        goto statement_320;
        //C   TWO-RANGE ZONE                                                      M32.9220
        statement_290:
        if (irange == 1) {
          goto statement_240;
        }
        if (irange == 2) {
          goto statement_270;
        }
        //C   THREE-RANGE ZONE                                                    M32.9223
        statement_300:
        if (irange == 1) {
          goto statement_240;
        }
        if (irange == 2) {
          goto statement_310;
        }
        if (irange == 3) {
          goto statement_270;
        }
        //C   SECOND RANGE (3-R CASE)                                             M32.9227
        statement_310:
        xbeg = azepo(indxl2 + 1);
        fbeg = azepo(indx0);
        if (izone == 1) {
          fbeg = fbeg / 10.f;
        }
        xend = azepo(indxr3 + 1);
        fend = azepo(indxr1 + 3);
        statement_320:
        shira(cmn, xbeg, xend, fbeg, fend, iter, indx0, irange);
      }
    }
    if (idebug < 4) {
      goto statement_460;
    }
    //C  THL
    write(lunit6,
      "(/,/,' after do 340 loop in ADJCR',/,1x,4x,'XBEGR',3x,'ALPHA',10x,"
      "'POLES AND ZEROES AFTER ADJUSTMENT (HZ)',/)");
    index = 0;
    FEM_DO_SAFE(irange, 1, cmn.ntotra) {
      alpha = azepo(index + 2);
      jn = std::abs(alpha) + cmn.onehav;
      i1 = index + 1;
      i2 = i1 + 1 + 2 * jn;
      {
        write_loop wloop(cmn, lunit6,
          "(1x,e12.4,f4.0,6e11.4,/,17x,6e11.4,/,17x,6e11.4)");
        FEM_DO_SAFE(i, i1, i2) {
          wloop, azepo(i);
        }
      }
      index = i2;
    }
    statement_460:;
  }
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

double
aph(
  common& cmn,
  double const& x) try
{
  double return_value = fem::double0;
  int& ndata = cmn.ndata;
  const auto& xdat = cmn.xdat;
  const auto& aphdat = cmn.aphdat;
  //
  double ai = fem::double0;
  int i1 = fem::int0;
  if (x <= xdat(1)) {
    goto statement_120;
  }
  if (x >= xdat(ndata)) {
    goto statement_100;
  }
  ai = cmn.aptdec * (x - xdat(1)) + 1.e0;
  i1 = ai;
  return_value = (x - xdat(i1)) * (aphdat(i1 + 1) - aphdat(i1)) / (
    xdat(i1 + 1) - xdat(i1)) + aphdat(i1);
  goto statement_110;
  statement_120:
  return_value = aphdat(1);
  goto statement_110;
  statement_100:
  return_value = aphdat(ndata);
  statement_110:
  return return_value;
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct ftplot_save
{
  fem::str<8> blank;
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;

  ftplot_save() :
    blank(fem::char0),
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0)
  {}
};

void
ftplot(
  common& cmn,
  int const& icurve,
  int const& imode,
  int const& nfitmx) try
{
  FEM_CMN_SVE(ftplot);
  common_write write(cmn);
  const auto& fczr = cmn.fczr;
  const auto& fcpr = cmn.fcpr;
  int& iftype = cmn.iftype;
  int& lout = cmn.lout;
  int& ndata = cmn.ndata;
  int& nzeror = cmn.nzeror;
  const auto& xdat = cmn.xdat;
  const auto& ydat = cmn.ydat;
  //
  fem::str<8>& blank = sve.blank;
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  if (is_called_first_time) {
    text1 = "0";
    text2 = "I";
    text3 = "*";
    blank = " ";
  }
  int j = fem::int0;
  arr_1d<92, fem::str<8> > pl(fem::fill0);
  double ymin = fem::double0;
  double ymax = fem::double0;
  int i = fem::int0;
  double d1 = fem::double0;
  double amin = fem::double0;
  double amax = fem::double0;
  double dfamp = fem::double0;
  double x = fem::double0;
  double freq = fem::double0;
  double freq2 = fem::double0;
  double amagp = fem::double0;
  double amaglg = fem::double0;
  int j1 = fem::int0;
  double ax = fem::double0;
  int intd1 = fem::int0;
  int intd2 = fem::int0;
  FEM_DO_SAFE(j, 1, 92) {
    pl(j) = blank;
  }
  if (icurve == 2 && nfitmx == 0) {
    goto statement_120;
  }
  ymin = 1.e20;
  ymax = -1.e20;
  FEM_DO_SAFE(i, 1, ndata) {
    d1 = ydat(i);
    if (d1 > ymin) {
      goto statement_110;
    }
    ymin = d1;
    statement_110:
    if (d1 < ymax) {
      goto statement_100;
    }
    ymax = d1;
    statement_100:;
  }
  amin = .90e0 * fem::pow(10.e0, ymin);
  amax = 1.1e0 * fem::pow(10.e0, ymax);
  dfamp = amax - amin;
  //C  Ti fitting
  if (nfitmx > 0) {
    goto statement_112;
  }
  write(lout,
    "(/,/,' PRINTER PLOT OF  YC  FITTING FOR MODE',i3,/,"
    "' PLOT OF YCMAG VS. YCEQMAG IN MHOS ',/,' PLOT SYMBOLS:   0 = YCMAG',"
    "'    I = YCEQMAG','    * = INTERSECTION POINT.')"),
    imode;
  write(lout,
    "(/,3x,'YCMAG',6x,'YCEQMAG',15x,e10.4,74x,e10.4,/,28x,'FREQ',/,35x,'.1',"
    "10('........1'))"),
    amin, amax;
  goto statement_130;
  statement_112:
  write(lout,
    "(/,/,' PRINTER PLOT OF  Ti  FITTING FOR ELEMENT',2i2,/,"
    "' PLOT OF TiMAG VS. TiEQMAG ',/,' PLOT SYMBOLS:   0 = TiMAG',"
    "'    I = TiEQMAG','    * = INTERSECTION POINT.')"),
    icurve, imode;
  write(lout,
    "(/,3x,'TiMAG',6x,'TiEQMAG',15x,e10.4,74x,e10.4,/,28x,'FREQ',/,35x,'.1',"
    "10('........1'))"),
    amin, amax;
  goto statement_130;
  statement_120:
  if (iftype == 1) {
    goto statement_122;
  }
  amin = 0.f;
  amax = 1.e0;
  dfamp = 1.e0;
  goto statement_124;
  statement_122:
  amin = 0.f;
  amax = 1.5e0;
  dfamp = 1.5e0;
  statement_124:
  write(lout,
    "(/,/,' PRINTER PLOT OF  A1  FITTING FOR MODE',i3,/,"
    "' PLOT OF A1MAG VS. A1EQMAG IN P.U. ',/,' PLOT SYMBOLS:   0 = A1MAG',"
    "'    I = A1EQMAG','    * = INTERSECTION POINT.')"),
    imode;
  write(lout,
    "(/,3x,'A1MAG',6x,'A1EQMAG',15x,e10.4,74x,e10.4,/,28x,'FREQ',/,35x,'.1',"
    "10('........1'))"),
    amin, amax;
  statement_130:
  x = xdat(1) - .2e0;
  statement_810:
  x += .2e0;
  if (x > xdat(ndata)) {
    goto statement_850;
  }
  freq = fem::pow(10.e0, x);
  freq2 = fem::pow2(freq);
  amagp = 1.e0;
  if (nzeror == 0) {
    goto statement_825;
  }
  FEM_DO_SAFE(j, 1, nzeror) {
    amagp = amagp * (fem::pow2(fczr(j)) + freq2) / (fem::pow2(fcpr(j)) + freq2);
  }
  statement_825:
  amaglg = alog1z(amagp);
  if (iftype == 1) {
    goto statement_840;
  }
  j1 = nzeror + 1;
  FEM_DO_SAFE(j, j1, cmn.npoler) {
    amaglg = amaglg - alog1z(fem::pow2(fcpr(j)) + freq2);
  }
  statement_840:
  amaglg = cmn.hrflgr + amaglg / 2.e0;
  ax = fem::pow(10.e0, yfun39(cmn, x));
  amagp = fem::pow(10.e0, amaglg);
  intd1 = (ax - amin) * 90.e0 / dfamp + 1.5e0;
  intd2 = (amagp - amin) * 90.e0 / dfamp + 1.5e0;
  if (intd1 < 1 || intd1 > 91) {
    intd1 = 92;
  }
  if (intd2 < 1 || intd2 > 91) {
    intd2 = 92;
  }
  pl(intd1) = text1;
  pl(intd2) = text2;
  if (intd1 == intd2) {
    pl(intd1) = text3;
  }
  {
    write_loop wloop(cmn, lout, "(1x,e10.4,2x,e10.4,2x,e10.4,1x,91a1)");
    wloop, ax, amagp, freq;
    FEM_DO_SAFE(i, 1, 91) {
      wloop, pl(i);
    }
  }
  pl(intd1) = blank;
  pl(intd2) = blank;
  goto statement_810;
  statement_850:;
  //C     BEGIN WITH FUNCTIONS OF  MMODES=18  LIMIT ON MODES:               M32.  17
  //C     NEXT COME FUNCTIONS OF  MPOLES=100  LIMIT ON POLES:               M32.  20
  //C     NEXT  MXCHKR=2*SUM(2**I), I=0,1,..N  WITH 2**N .GE. MPOLES        M32.  25
  //C     NEXT COME FUNCTIONS OF  MXKNEE=100  LIMIT ON UPS AND DOWNS:       M32.  27
  //C     NEXT COME SCALARS, WITH REALS BEFORE INTEGERS (A LA IBM):         M32.  29
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
defblk(
  str_arr_ref<> abuff) try
{
  abuff(dimension(1));
  //C     ALMOST-UNIVERSAL MODULE FOR BLANKING OUT "ABUFF" CARD             M32.9762
  //C     IMAGE OF "DEFAULT" DATA CARD OF "MARTI SETUP".   THE ONE          M32.9763
  //C     AND ONLY CALL IS BY MODULE "MISC39" OF OVERLAY 39.   IT           M32.9764
  //C     IS NOT UNIVERSAL ONLY FOR THOSE COMPUTERS (E.G., APOLLO)          M32.9765
  //C     WHICH HAVE  "CHARACTER ABUFF*80"  DECLARATION.                    M32.9766
  abuff(1) = abuff(5);
  abuff(2) = abuff(5);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct misc39_save
{
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;

  misc39_save() :
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0)
  {}
};

void
misc39(
  common& cmn) try
{
  FEM_CMN_SVE(misc39);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus3 = cmn.bus3;
  auto& abuff = cmn.abuff;
  auto& indtv = cmn.indtv;
  int& ipunch = cmn.ipunch;
  int& iprsup = cmn.iprsup;
  auto& modskp = cmn.modskp;
  double& gmode = cmn.gmode;
  double& amina1 = cmn.amina1;
  double& epstol = cmn.epstol;
  int& idebug = cmn.idebug;
  int& modify = cmn.modify;
  int& nexmis = cmn.nexmis;
  int& normax = cmn.normax;
  int& ifwta = cmn.ifwta;
  int& koutpr = cmn.koutpr;
  int& inelim = cmn.inelim;
  int& ifplot = cmn.ifplot;
  int& ifdat = cmn.ifdat;
  int& iecode = cmn.iecode;
  int& metrik = cmn.metrik;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  if (is_called_first_time) {
    text1 = "DATA  ";
    text2 = "SELECT";
    text3 = "DEFAUL";
    text4 = "T     ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int kdeflt = fem::int0;
  arr_1d<9, int> itemp(fem::fill0);
  int j = fem::int0;
  int k = fem::int0;
  int n3 = fem::int0;
  double d1 = fem::double0;
  double d13 = fem::double0;
  static const char* format_2247 = "(2a6)";
  //C     THIS MODULE IS CALLED BY "SUBR39"  OF                             M32.9666
  //C     OVERLAY 39 WHEN NEW MISCELLANEOUS DATA CARDS ARE REQUIRED         M32.9667
  //C     (POSSIBLY ONCE FOR EACH MODE,  IN THE MOST EXTREME CASE).         M32.9668
  //C!EQUIVALENCE ( KDEFLT, INDTV(1) )
  kdeflt = indtv(1);
  if (iprsup >= 6) {
    write(lunit6, "(' TOP OF \"MISC39\".   MODIFY =',i4)"), modify;
  }
  if (modify == 0) {
    goto statement_2268;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M32.9679
  statement_2245:
  if (kdeflt != 1) {
    cimage(cmn);
  }
  read(abuff, format_2247), bus1, bus3;
  if (bus1 != text1) {
    goto statement_4063;
  }
  statement_2268:
  read(abuff, format_2247), bus1, bus3;
  if (bus1 != text3) {
    goto statement_2274;
  }
  if (bus3 != text4) {
    goto statement_2274;
  }
  write(kunit6, "('+REQUEST FOR DEFAULT FITTING (= 3 BLANK CARDS).')");
  interp();
  kdeflt = 1;
  indtv(1) = kdeflt;
  //C     ERASE "DEFAULT" FROM "ABUFF" (INSTALLATION-DEPENDENT):            M32.9693
  defblk(abuff);
  statement_2274:
  if (bus1 != text2) {
    goto statement_2286;
  }
  cmn.modesk = 1;
  read(abuff, "(8x,9i8)"), itemp;
  FEM_DO_SAFE(j, 1, 9) {
    if (itemp(j) == 0) {
      goto statement_2283;
    }
    k = 1;
    if (itemp(j) < 0) {
      k = 2;
    }
    n3 = iabsz(itemp(j));
    modskp(k, n3) = 1;
    statement_2283:;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M32.9706
  cimage(cmn);
  goto statement_2268;
  statement_2286:
  read(abuff, "(66x,a6)"), cmn.bus2;
  //C     BEGIN CODE TO READ OVERALL PROGRAM MISCELLANEOUS PARAM.:          M32.9712
  read(abuff, "(8x,3i8,e8.0)"), idebug, ipunch, koutpr, gmode;
  if (gmode <= 0.0f && metrik == 0) {
    gmode = .48e-7;
  }
  if (gmode <= 0.0f && metrik == 1) {
    gmode = .30e-7;
  }
  if (koutpr == 0) {
    koutpr = 2;
  }
  if (koutpr < 0) {
    koutpr = 0;
  }
  if (kdeflt == 0) {
    write(kunit6, "('+PARAM. ',e8.1,3i8)"), gmode, ipunch, idebug, koutpr;
  }
  if (modify != 0) {
    goto statement_2245;
  }
  goto statement_9900;
  statement_4063:
  if (modify == 2) {
    goto statement_4387;
  }
  //C     BEGIN CODE FOR MISCELLANEOUS PARAM. OF  ZC  FITTING               M32.9725
  read(abuff, "(i8,e8.0,6i8)"), nexmis, epstol, normax, iecode,
    ifwta, ifplot, ifdat, inelim;
  if (nexmis == 0) {
    nexmis = -1;
  }
  if (epstol == 0) {
    epstol = .3e0;
  }
  d1 = epstol;
  d13 = 1.0f + epstol / 100.f;
  epstol = fem::pow2(alog1z(d13));
  if (normax <= 0) {
    normax = 30;
  }
  if (kdeflt == 0) {
    write(kunit6, "('+Yc FIT.',i3,e8.1,6i3)"), nexmis, d1, normax,
      iecode, ifwta, ifplot, ifdat, inelim;
  }
  interp();
  goto statement_9900;
  //C     BEGIN CODE FOR MISCELLANEOUS PARAM. OF A1 FITTING                 M32.9740
  statement_4387:
  read(abuff, "(i8,e8.0,6i8,e8.0)"), nexmis, epstol, normax,
    iecode, ifwta, ifplot, ifdat, inelim, amina1;
  if (epstol == 0) {
    epstol = .3e0;
  }
  d1 = epstol;
  d13 = 1.0f + epstol / 100.f;
  epstol = fem::pow2(alog1z(d13));
  if (normax <= 0) {
    normax = 30;
  }
  if (amina1 == 0.f) {
    amina1 = .05e0;
  }
  if (kdeflt == 0) {
    write(kunit6, "('+A1 FIT.',i3,e8.1,6i3,e8.1)"), nexmis, d1,
      normax, iecode, ifwta, ifplot, ifdat, inelim, amina1;
  }
  interp();
  statement_9900:
  if (iprsup >= 6) {
    write(lunit6, "(' EXIT \"MISC39\".')");
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct subr39_save
{
  fem::str<8> text1;
  fem::str<8> text10;
  fem::str<8> text11;
  fem::str<8> text12;
  fem::str<8> text13;
  fem::str<8> text14;
  fem::str<8> text15;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;
  fem::str<8> text8;
  fem::str<8> text9;

  subr39_save() :
    text1(fem::char0),
    text10(fem::char0),
    text11(fem::char0),
    text12(fem::char0),
    text13(fem::char0),
    text14(fem::char0),
    text15(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0),
    text8(fem::char0),
    text9(fem::char0)
  {}
};

void
subr39(
  common& cmn) try
{
  FEM_CMN_SVE(subr39);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& trash = cmn.trash;
  fem::str<8>& blank = cmn.blank;
  auto& texta6 = cmn.texta6;
  const auto& date1= cmn.date1;
  auto& tclock= cmn.tclock;
  auto& vstacs= cmn.vstacs;
  const auto& abuff = cmn.abuff;
  double& ck1 = cmn.ck1;
  double& twopi = cmn.twopi;
  double& sglfir = cmn.sglfir;
  double& tenm3 = cmn.tenm3;
  double& unity = cmn.unity;
  double& onehaf = cmn.onehaf;
  auto& voltbc = cmn.voltbc;
  auto& lunit1 = cmn.lunit1;
  auto& lunit2 = cmn.lunit2;
  auto& lunit7 = cmn.lunit7;
  auto& lunit9 = cmn.lunit9;
  int& nright = cmn.nright;
  int& kolbeg = cmn.kolbeg;
  auto& indtv = cmn.indtv;
  auto& lstat = cmn.lstat;
  int& ipunch = cmn.ipunch;
  int& lastov = cmn.lastov;
  int& ktab = cmn.ktab;
  int& ialter = cmn.ialter;
  int& iofgnd = cmn.iofgnd;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  auto& tir = cmn.tir;
  auto& tii = cmn.tii;
  auto& tdum = cmn.tdum;
  auto& modskp = cmn.modskp;
  auto& alinvc = cmn.alinvc;
  auto& akfrac = cmn.akfrac;
  auto& alphaf = cmn.alphaf;
  auto& fczr = cmn.fczr;
  auto& fcpr = cmn.fcpr;
  auto& fcz = cmn.fcz;
  auto& fcp = cmn.fcp;
  auto& indxv = cmn.indxv;
  auto& xauxd = cmn.xauxd;
  auto& zoprau = cmn.zoprau;
  auto& zoprao = cmn.zoprao;
  auto& azepo = cmn.azepo;
  auto& xchkra = cmn.xchkra;
  auto& xknee = cmn.xknee;
  auto& noprao = cmn.noprao;
  double& hreflg = cmn.hreflg;
  double& aptdec = cmn.aptdec;
  double& onehav = cmn.onehav;
  double& hrflgr = cmn.hrflgr;
  double& epstol = cmn.epstol;
  double& refa = cmn.refa;
  double& refb = cmn.refb;
  int& idebug = cmn.idebug;
  int& iftype = cmn.iftype;
  int& ndata = cmn.ndata;
  int& ntotra = cmn.ntotra;
  int& nzone = cmn.nzone;
  int& izone = cmn.izone;
  int& modify = cmn.modify;
  int& nexmis = cmn.nexmis;
  int& normax = cmn.normax;
  int& ifwta = cmn.ifwta;
  int& koutpr = cmn.koutpr;
  int& inelim = cmn.inelim;
  int& ifplot = cmn.ifplot;
  int& ifdat = cmn.ifdat;
  int& iecode = cmn.iecode;
  int& nzeror = cmn.nzeror;
  int& npoler = cmn.npoler;
  int& modesk = cmn.modesk;
  int& metrik = cmn.metrik;
  auto& xdat = cmn.xdat;
  auto& ydat = cmn.ydat;
  auto& aphdat = cmn.aphdat;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text10 = sve.text10;
  fem::str<8>& text11 = sve.text11;
  fem::str<8>& text13 = sve.text13;
  fem::str<8>& text14 = sve.text14;
  fem::str<8>& text15 = sve.text15;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  fem::str<8>& text7 = sve.text7;
  fem::str<8>& text8 = sve.text8;
  fem::str<8>& text9 = sve.text9;
  if (is_called_first_time) {
    text1 = "LINE  ";
    text2 = "CONSTA";
    text3 = "NTS   ";
    text4 = "CABLE ";
    text5 = "LC    ";
    text6 = "CC    ";
    text7 = "OLD   ";
    text8 = "DATA  ";
    text9 = "NEW   ";
    text10 = "RHO   ";
    text11 = "BRANCH";
    sve.text12 = "COMMON";
    text13 = "CARDS ";
    text14 = "PRINTE";
    text15 = "R PLOT";
  }
  int kdeflt = fem::int0;
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int ifqdpt = fem::int0;
  double pai = fem::double0;
  double tendeg = fem::double0;
  int mmodes = fem::int0;
  int mxknee = fem::int0;
  int mpoles = fem::int0;
  int mxchkr = fem::int0;
  int mzopra = fem::int0;
  int lunt35 = fem::int0;
  int llm1 = fem::int0;
  int ll4 = fem::int0;
  int jdatcs = fem::int0;
  arr_1d<20, int> lltemp(fem::fill0);
  int n3 = fem::int0;
  int i = fem::int0;
  int mdapts = fem::int0;
  int n13 = fem::int0;
  int ialdum = fem::int0;
  int m = fem::int0;
  int n4 = fem::int0;
  double d1 = fem::double0;
  int n1 = fem::int0;
  double dist = fem::double0;
  arr_1d<14, fem::str<8> > texta(fem::fill0);
  int k = fem::int0;
  int imodal = fem::int0;
  double d9 = fem::double0;
  double d11 = fem::double0;
  int mspedb = fem::int0;
  int itrnsf = fem::int0;
  int j = fem::int0;
  int ij = fem::int0;
  int kp = fem::int0;
  int ip = fem::int0;
  int jp = fem::int0;
  int nmode = fem::int0;
  int nfitmx = fem::int0;
  double convun = fem::double0;
  int npoint = fem::int0;
  double d13 = fem::double0;
  double deminp = fem::double0;
  double clear = fem::double0;
  int kount = fem::int0;
  int n5 = fem::int0;
  int n12 = fem::int0;
  double d1lim = fem::double0;
  double d2lim = fem::double0;
  int imode = fem::int0;
  int id1 = fem::int0;
  int ipoint = fem::int0;
  double twopif = fem::double0;
  double ycharm = fem::double0;
  double ychara = fem::double0;
  double alpha = fem::double0;
  double beta = fem::double0;
  int index = fem::int0;
  arr<double> alintp(dimension(4100), fem::fill0);
  int L = fem::int0;
  int ncurve = fem::int0;
  arr_1d<11, int> minust(fem::fill0);
  int icurve = fem::int0;
  int numone = fem::int0;
  int numzro = fem::int0;
  double epstzc = fem::double0;
  int normzc = fem::int0;
  int iecozc = fem::int0;
  int ifwtzc = fem::int0;
  int ifplzc = fem::int0;
  int ifdazc = fem::int0;
  int inelzc = fem::int0;
  double epsta1 = fem::double0;
  int norma1 = fem::int0;
  int iecoa1 = fem::int0;
  int ifwta1 = fem::int0;
  int ifpla1 = fem::int0;
  int ifdaa1 = fem::int0;
  int inela1 = fem::int0;
  double f0 = fem::double0;
  double fdat = fem::double0;
  double adat = fem::double0;
  double phdat = fem::double0;
  double d3 = fem::double0;
  double asave = fem::double0;
  double d4 = fem::double0;
  double d5 = fem::double0;
  int n9 = fem::int0;
  double travhf = fem::double0;
  int iknee = fem::int0;
  double ylevl0 = fem::double0;
  double x1levl = fem::double0;
  int iscape = fem::int0;
  double x2levl = fem::double0;
  double xlevl = fem::double0;
  double dxcomp = fem::double0;
  int nechk1 = fem::int0;
  double xbegr = fem::double0;
  double xendr = fem::double0;
  double ycut = fem::double0;
  double ycutpu = fem::double0;
  double xbegtl = fem::double0;
  double xendtl = fem::double0;
  int i1 = fem::int0;
  int i2 = fem::int0;
  int nechk2 = fem::int0;
  int iterlp = fem::int0;
  int incrtl = fem::int0;
  double erropt = fem::double0;
  int ichkp = fem::int0;
  int npole = fem::int0;
  double tolfac = fem::double0;
  double tolmin = fem::double0;
  double xbegz = fem::double0;
  double xendz = fem::double0;
  double signz = fem::double0;
  int ioprau = fem::int0;
  int ichkra = fem::int0;
  int nchkra = fem::int0;
  int id = fem::int0;
  double xcla = fem::double0;
  double xclb = fem::double0;
  double xlim1 = fem::double0;
  double xlim2 = fem::double0;
  double abeta = fem::double0;
  int nalph1 = fem::int0;
  double xmidr = fem::double0;
  double xcorna = fem::double0;
  double xcornb = fem::double0;
  double erymax = fem::double0;
  double tolera = fem::double0;
  double d2 = fem::double0;
  int id2 = fem::int0;
  int iflag = fem::int0;
  double xd1 = fem::double0;
  double xd2 = fem::double0;
  int npoles = fem::int0;
  int irange = fem::int0;
  int jn = fem::int0;
  int lrange = fem::int0;
  double plocpn = fem::double0;
  int j2 = fem::int0;
  double alocpn = fem::double0;
  int j2n = fem::int0;
  int ncorn = fem::int0;
  int nzero = fem::int0;
  double error1 = fem::double0;
  double error2 = fem::double0;
  double x = fem::double0;
  double freq = fem::double0;
  double freq2 = fem::double0;
  double amagp = fem::double0;
  double amaglg = fem::double0;
  int j1 = fem::int0;
  double epser1 = fem::double0;
  double epser2 = fem::double0;
  double epserr = fem::double0;
  double dx = fem::double0;
  double x1 = fem::double0;
  double x2 = fem::double0;
  double sumtau = fem::double0;
  int n = fem::int0;
  double php = fem::double0;
  double tau = fem::double0;
  double taur = fem::double0;
  double ax = fem::double0;
  double d8 = fem::double0;
  double d6 = fem::double0;
  double d7 = fem::double0;
  int ifrac = fem::int0;
  double s = fem::double0;
  double resilg = fem::double0;
  double sign = fem::double0;
  double resid = fem::double0;
  double hrefr = fem::double0;
  int n23 = fem::int0;
  int n8 = fem::int0;
  int n2 = fem::int0;
  int npols1 = fem::int0;
  arr_1d<100, double> akfrs1(fem::fill0);
  arr_1d<100, double> alphs1(fem::fill0);
  int npols2 = fem::int0;
  arr_1d<100, double> akfrs2(fem::fill0);
  arr_1d<100, double> alphs2(fem::fill0);
  arr_1d<14, fem::str<8> > textp(fem::fill0);
  static const char* format_1542 = "(13a6,a2)";
  static const char* format_4023 = "(6e12.0)";
  static const char* format_4029 = "(5e16.0)";
  static const char* format_7034 = "(1x,4d11.4)";
  static const char* format_7079 =
    "(1x,e12.4,f4.0,6e11.4,/,17x,6e11.4,/,17x,6e11.4)";
  static const char* format_7083 =
    "(/,/,1x,4x,'XBEGR',3x,'ALPHA',10x,"
    "'POLES AND ZEROES AFTER ADJUSTMENT (HZ)',/)";
  static const char* format_7622 = "(24x,e8.0)";
  static const char* format_8781 =
    "('-',i1,2a6,12x,f6.0,4x,'1.',14x,'-4',3x,'1')";
  static const char* format_8782 =
    "(1x,'-',i1,2a6,12x,f6.0,4x,'1.',14x,'-4',3x,'1',"
    "'                        ')";
  static const char* format_8790 = "('-',i1,2a6,12x,f6.0,4x,'1.',14x,'-4',2i2)";
  static const char* format_8791 =
    "(1x,'-',i1,2a6,12x,f6.0,4x,'1.',14x,'-4',2i2,'                        ')";
  static const char* format_8798 = "(i8,e32.20)";
  static const char* format_8799 =
    "(1x,i8,e32.20,'                                          ')";
  static const char* format_8803 = "(3e26.18)";
  static const char* format_8804 = "(1x,3e26.18,'    ')";
  static const char* format_9436 = "(' ROW',i3,'.',9e13.5)";
  //C!EQUIVALENCE ( KDEFLT, INDTV(1) )
  kdeflt = indtv(1);
  if (iprsup >= 1) {
    write(lunit6, "(' TOP OF \"SUBR39\".  LASTOV =',i6)"), lastov;
  }
  if (lastov == 1) {
    goto statement_5657;
  }
  onehav = onehaf;
  cmn.oneqtr = 0.25e0;
  ifqdpt = 1;
  pai = twopi / 2.f;
  tendeg = pai / 18.f;
  //C ==== CHANGE THESE LIMITS IF DIMENSIONS IN LABL39 ARE CHANGED:         M32.7642
  //C   NUMBER OF MODES:                                                    M32.7643
  mmodes = 18;
  //C   CURVE ZONES = PEAKS+VALLEYS+1 :                                     M32.7646
  //C   XKNEE(MXKNEE),NOPRAO(MXKNEE)                                        M32.7647
  //C     THL + Edwin + WSM, 1 Aug 1986.  Change "LABL39" arrays 20 to 100: M43.2900
  mxknee = 100;
  //C   ORDER OF THE APPROXIMATION = NO. OF POLES :                         M32.7649
  //C   XAUXD(2*MPOLES),FCZ(MPOLES),FCP(MPOLES),                            M32.7650
  //C   FCZR(MPOLES),FCPR(MPOLES),INDXV(MPOLES),                            M32.7651
  //C   AKFRAC(MPOLES),ALPHAF(MPOLES)                                       M32.7652
  mpoles = 100;
  //C   DIMENSION OF XCHKRA = 2*SUM(2**I), I=0,N ; N SUCH THAT 2**N.GE.MPOLEM32.7654
  //C   XCHKRA(MXCHKR)                                                      M32.7655
  mxchkr = 255;
  //C   DIMENSION OF ZOPRAU, ZOPRAO, AZEPO = 4*MPOLES  :                    M32.7657
  //C   ZOPRAU(MZOPRA),ZOPRAO(MZOPRA),AZEPO(MZOPRA)                         M32.7658
  mzopra = 400;
  //C ====  END OF DIMENSION-LIMIT ASSIGNMENTS ("LABL39" STORAGE)           M32.7660
  lunt35 = 35;
  llm1 = -1;
  ll4 = 4;
  jdatcs = 0;
  dimens(lltemp(1), nchain, trash, trash);
  if (iprsup >= 1) {
    write(6, "(/,1x,'LLTEMP(1:2) =',2i8)"), lltemp(1), lltemp(2);
  }
  n3 = 0;
  FEM_DOSTEP(i, 1, 9999, 2) {
    if (n3 >= 1) {
      goto statement_1550;
    }
    if (lltemp(i) != 71) {
      goto statement_5654;
    }
    mdapts = lltemp(i + 1);
    n3++;
    statement_5654:;
  }
  stoptp(cmn);
  statement_1550:
  n13 = 0;
  kdeflt = 0;
  indtv(1) = kdeflt;
  if (lastov != 1) {
    goto statement_4040;
  }
  statement_5657:
  ialdum = 0;
  ialter = 1;
  FEM_DO_SAFE(i, 1, 24) {
    vstacs(i) = blank;
  }
  sglfir = 0.2e0;
  m = 1;
  //C     READ INPUT CARD USING CIMAGE                                      M32.7675
  statement_4040:
  cimage(cmn);
  nright = -2;
  n4 = kolbeg;
  kolbeg = 1;
  freone(cmn, d1);
  if (kill > 0) {
    goto statement_9200;
  }
  nright = 0;
  if (texta6(1) != text11) {
    goto statement_7618;
  }
  //C     OPTIONAL "BRANCH" CARD GIVING PAIRS OF NODE NAMES                 M32.7697
  n1 = m + 11;
  {
    read_loop rloop(abuff(1), "(8x,12a6)");
    FEM_DO_SAFE(i, m, n1) {
      rloop, vstacs(i);
    }
  }
  if (iprsup >= 6) {
    {
      write_loop wloop(cmn, lunit6, "(' VSTACS NAMES:',12a6)");
      wloop, m;
      FEM_DO_SAFE(i, m, n1) {
        wloop, vstacs(i);
      }
    }
  }
  m += 12;
  write(kunit6, "('+BUS NAMES FOR EACH PHASE.')");
  goto statement_4040;
  statement_7618:
  if (texta6(1) != text7) {
    goto statement_4042;
  }
  if (texta6(2) != text8) {
    goto statement_4042;
  }
  ialdum = 3;
  ialter = 3;
  if (kolbeg > 0) {
    goto statement_7623;
  }
  read(abuff, format_7622), dist;
  goto statement_7624;
  statement_7623:
  cmn.nfrfld = 1;
  freone(cmn, dist);
  statement_7624:
  if (metrik == 0 && n13 != 8765) {
    dist = dist * 1.60935f;
  }
  write(kunit6, "('+SAME LINE, BUT WITH NEW LENGTH =',f9.2,'  KM.')"), dist;
  goto statement_4040;
  statement_4042:
  if (texta6(1) != text9) {
    goto statement_4043;
  }
  if (texta6(2) != text10) {
    goto statement_4043;
  }
  //C     TEMPORARY NEW RHO AREA - TO BE COMPLETED LATER, SOMEDAY           M32.7726
  statement_4043:
  if (texta6(1) != text14) {
    goto statement_8819;
  }
  if (texta6(2) != text15) {
    goto statement_8819;
  }
  read(abuff, format_7622), sglfir;
  write(kunit6, "('+NEW LOG-F/LINE OF PRINTER PLOT.  SGLFIR =',f8.4)"), sglfir;
  statement_8819:
  {
    read_loop rloop(abuff(1), "(13a6,a2)");
    FEM_DO_SAFE(k, 1, 14) {
      rloop, texta(k);
    }
  }
  FEM_DO_SAFE(k, 1, 14) {
    if (texta(k) != blank) {
      goto statement_4044;
    }
  }
  write(kunit6, "('+BLANK CARD ENDING MARTI SETUP')");
  interp();
  goto statement_9200;
  //C     CHECK FOR KEY WORD  'LINE CONSTANTS'  (OR  'LC' ).                M32.7741
  statement_4044:
  if (texta6(1) == text5) {
    goto statement_1706;
  }
  if (texta6(1) != text1) {
    goto statement_4049;
  }
  if (texta6(2) != text2) {
    goto statement_4049;
  }
  if (texta6(3) != text3) {
    goto statement_4049;
  }
  statement_1706:
  if (iprsup >= 1) {
    write(lunit6, "(' TRANSFER TO  ''LINE CONSTANTS'' .')");
  }
  lastov = nchain;
  nchain = 44;
  goto statement_9999;
  //C     CHECK FOR KEY WORD  'CABLE CONSTANTS'  (OR  'CC' ).               M32.7751
  statement_4049:
  if (texta6(1) == text6) {
    goto statement_1716;
  }
  if (texta6(1) != text4) {
    goto statement_4055;
  }
  if (texta6(2) != text2) {
    goto statement_4055;
  }
  if (texta6(3) != text3) {
    goto statement_4055;
  }
  statement_1716:
  write(kunit6, "('+TRANSFER TO  ''CABLE CONSTANTS'' .')");
  lastov = nchain;
  nchain = 47;
  goto statement_9999;
  statement_4055:
  if (texta6(1) != text8) {
    goto statement_4057;
  }
  if (texta6(2) != text13) {
    goto statement_4057;
  }
  //C     READ DATA CARD USING CIMAGE                                       M35.8898
  cimage(cmn);
  read(abuff, "(3i8,e8.0)"), ktab, imodal, metrik, d9;
  ck1 = d9;
  if (metrik == 0) {
    ck1 = ck1 * .62135896e0;
  }
  //CCC      write (*,*) ' subr39.  Ready to to rewind lunit9 =',           M43.2901
  //CCC     1                                          lunit9               M43.2902
  cmn.io.rewind(lunit9);
  //C     WRITE FIVE DUMMY ZEROS                                            M43.2903
  d11 = 0.f;
  write(lunit9, fem::unformatted), d11, d11, d11, d11, d11;
  cmn.io.rewind(lunit9);
  write(lunit9, fem::unformatted), imodal, metrik, d9, mspedb, itrnsf;
  //C     READ DATA CARD USING CIMAGE                                       M35.8910
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_4029);
    FEM_DO_SAFE(i, 1, 3) {
      rloop, voltbc(i);
    }
  }
  //C     READ IN THE CURRENT TRANSFORMATION MATRIX   *  *  *  *  *  *  *   M35.8914
  if (imodal == 0) {
    goto statement_4033;
  }
  FEM_DO_SAFE(j, 1, ktab) {
    FEM_DOSTEP(i, 1, ktab, 6) {
      ij = i + 5;
      if (ij > ktab) {
        ij = ktab;
      }
      //C     READ DATA CARD USING CIMAGE   *   *   *   *   *   *   *   *   *   M35.8920
      cimage(cmn);
      {
        read_loop rloop(abuff(1), format_4023);
        FEM_DO_SAFE(kp, i, ij) {
          rloop, tir(j, kp);
        }
      }
    }
    FEM_DOSTEP(i, 1, ktab, 6) {
      ij = i + 5;
      if (ij > ktab) {
        ij = ktab;
      }
      //C     READ DATA CARD USING CIMAGE   *   *   *   *   *   *   *   *   *   M35.8928
      cimage(cmn);
      {
        read_loop rloop(abuff(1), format_4023);
        FEM_DO_SAFE(kp, i, ij) {
          rloop, tii(j, kp);
        }
      }
    }
    //CCC      write (*,*) ' subr39.  tir, tii on  lunit9.'                   M43.2906
    {
      write_loop wloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(kp, 1, ktab) {
        wloop, tir(j, kp), tii(j, kp);
      }
    }
  }
  //C     READ MODAL G, B, R, X    *   *   *   *   *   *   *   *   *   *   *M35.8934
  //C     READ DATA CARD USING CIMAGE                                       M35.8935
  statement_4033:
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_4029);
    FEM_DO_SAFE(i, 1, 5) {
      rloop, alinvc(i);
    }
  }
  if (alinvc(ll4) <= 0.f) {
    goto statement_4034;
  }
  //CCC      write (*,*) ' subr39.  alinvc on lunit9.'                      M43.2907
  {
    write_loop wloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(i, 1, 5) {
      wloop, alinvc(i);
    }
  }
  goto statement_4033;
  statement_4034:
  cmn.io.rewind(lunit9);
  //C     ADVANCE THE CARD READER TO CONFORM TO MISC39'S REQUIREMENTS       M35.8942
  cimage(cmn);
  jdatcs = 2;
  //C     END KEY-WORD SECTION, PREPARE FOR MISC. DATA CARD:                M32.7761
  statement_4057:
  FEM_DO_SAFE(i, 1, 2) {
    FEM_DO_SAFE(j, 1, 9) {
      modskp(i, j) = 0;
    }
  }
  modesk = 0;
  cmn.io.rewind(lunit9);
  //CCC      write (*,*) ' subr39.  ready to read imodal, etc. from 9.'     M43.2908
  read(lunit9, fem::unformatted), imodal, metrik, d9, mspedb, itrnsf;
  modify = 0;
  //C   ==  READ MISCELLANEOUS DATA CARD BY CALL TO  "MISC39" :    ==       M32.7769
  misc39(cmn);
  //CCC      write (*,*) ' subr39.  Imodal, MODESK, IALDUM, IALTER, KTAB =',M43.2910
  //CCC     1                       Imodal, MODESK, IALDUM, IALTER, KTAB    M43.2911
  if (modesk == 1) {
    goto statement_4065;
  }
  FEM_DO_SAFE(i, 1, 2) {
    FEM_DO_SAFE(j, 1, 9) {
      modskp(i, j) = 1;
    }
  }
  statement_4065:
  if (ialdum != 3) {
    dist = d9;
  }
  //C     AGAIN, THE USAGE OF 'IALTER' IS RESTORED HERE                     M32.7778
  if (ialter != 3) {
    dist = d9;
  }
  if (imodal == 0 || itrnsf == 1) {
    goto statement_8215;
  }
  FEM_DO_SAFE(ip, 1, ktab) {
    {
      read_loop rloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(jp, 1, ktab) {
        rloop, tir(ip, jp), tii(ip, jp);
      }
    }
    if (iprsup < 9) {
      goto statement_8203;
    }
    {
      write_loop wloop(cmn, lunit6, format_9436);
      wloop, ip;
      FEM_DO_SAFE(jp, 1, ktab) {
        wloop, tir(ip, jp);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_9436);
      wloop, ip;
      FEM_DO_SAFE(jp, 1, ktab) {
        wloop, tii(ip, jp);
      }
    }
    statement_8203:;
  }
  //C                                                                       M32.7788
  //C   === MISCELLANEOUS INITIALIZATIONS ===                               M32.7789
  statement_8215:
  cmn.lout = lunit6;
  nmode = ktab;
  nfitmx = 0;
  if (nmode > mmodes) {
    goto statement_2170;
  }
  convun = 1.e0;
  if (metrik == 0) {
    convun = 1.60935e0;
  }
  modify = 1;
  nexmis = 1;
  aptdec = voltbc(6);
  npoint = voltbc(4);
  if (npoint > mdapts) {
    goto statement_2100;
  }
  //C   == FIXED PARAMETERS ==                                              M32.7802
  //C    SEPARATION BETWEEN CONSECUTIVE POLES OR ZEROES (.1%)               M32.7803
  d13 = 1.0f + tenm3;
  deminp = alog1z(d13);
  //C    INITIAL SEPARATION FROM HORIZONTAL LEVEL (1.%)                     M32.7807
  clear = tenm3 * 10.f;
  //C   == PREPARE IMAGES OF PUNCH FILE ==                                  M32.7810
  kount = 0;
  cmn.io.rewind(lunit1);
  if (ipunch == 0) {
    write(lunit7,
      "('C    PUNCHED CARD OUTPUT OF \"JMARTI SETUP\"',' WHICH BEGAN AT',2x,"
      "2a4,2x,2a4)"),
      tclock, date1;
  }
  if (ipunch != 0) {
    goto statement_8789;
  }
  if (imodal == 1) {
    write(lunit7, "('C   ***** UNTRANSPOSED JMARTI LINE SEGMENT ******    ')");
  }
  if (imodal == 0 && mspedb == 0) {
    write(lunit7, "('C   *****  TRANSPOSED JMARTI LINE SEGMENT  ******    ')");
  }
  if (imodal == 0 && mspedb == 1) {
    write(lunit7,
      "('C   ***** SPECIAL DOUBLE CIRCUIT TRANSPOSED JMARTI LINE SEGMENT *****"
      "*     ')");
  }
  statement_8789:
  cmn.io.rewind(lunit2);
  n5 = 0;
  if (jdatcs > 0) {
    goto statement_8777;
  }
  FEM_DO_SAFE(n12, 1, 9999) {
    {
      read_loop rloop(cmn, lunit2, "(13a6,a2)");
      FEM_DO_SAFE(i, 1, 14) {
        rloop, texta6(i);
      }
    }
    if (ipunch == 0) {
      {
        write_loop wloop(cmn, lunit7, "('C ',13a6)");
        FEM_DO_SAFE(i, 1, 13) {
          wloop, texta6(i);
        }
      }
    }
    if (idebug == 0) {
      goto statement_8100;
    }
    {
      write_loop wloop(cmn, lunit1, "(' C ',13a6,a2)");
      FEM_DO_SAFE(i, 1, 14) {
        wloop, texta6(i);
      }
    }
    kount++;
    statement_8100:
    if (texta6(1) == blank && texta6(2) == blank) {
      n5++;
    }
    if (n5 >= 2) {
      goto statement_8777;
    }
  }
  //C                                                                       M32.7833
  //C             MODES FITTING LOOP                                        M32.7834
  //C                                                                       M32.7835
  statement_8777:
  d13 = 1.005e0;
  d1lim = alog1z(d13);
  d13 = 1.0025e0;
  d2lim = alog1z(d13);
  FEM_DO_SAFE(imode, 1, nmode) {
    cmn.io.rewind(lunit9);
    //C  ??? DUMMY READ TO SKIP HEADER ???                                    M43.2920
    read(lunit9, fem::unformatted), id1, id1, d1, id1, id1;
    if (imodal == 0 || itrnsf == 1) {
      goto statement_3205;
    }
    FEM_DO_SAFE(ip, 1, ktab) {
      {
        read_loop rloop(cmn, lunit9, fem::unformatted);
        FEM_DO_SAFE(jp, 1, ktab) {
          rloop, tdum(ip, jp), tdum(ip, jp);
        }
      }
    }
    statement_3205:
    if (itrnsf == 1) {
      {
        read_loop rloop(cmn, lunit9, fem::unformatted);
        FEM_DO_SAFE(i, 1, ktab) {
          rloop, lltemp(i);
        }
      }
    }
    //C  ??? END OF DUMMY READ ???                                            M43.2927
    FEM_DO_SAFE(ipoint, 1, npoint) {
      FEM_DO_SAFE(i, 1, nmode) {
        read(lunit9, fem::unformatted), twopif, ycharm, ychara, alpha, beta;
        if (itrnsf != 1) {
          goto statement_3213;
        }
        {
          read_loop rloop(cmn, lunit9, fem::unformatted);
          FEM_DO_SAFE(j, 1, nmode) {
            rloop, tir(j, i), tii(j, i);
          }
        }
        statement_3213:
        if (imode != i) {
          goto statement_3215;
        }
        if (nfitmx == 1) {
          goto statement_8210;
        }
        index = (ipoint - 1) * 5;
        alintp(index + 1) = twopif;
        alintp(index + 2) = ycharm;
        alintp(index + 3) = ychara;
        alintp(index + 4) = alpha;
        alintp(index + 5) = beta;
        if (iprsup <= 1) {
          goto statement_3215;
        }
        write(lunit6, star),
          " %% in subr39, omega, ychar(mag,ang),alpha,beta", alintp(index + 1),
          alintp(index + 2), alintp(index + 3), alintp(index + 4),
          alintp(index + 5);
        goto statement_3215;
        statement_8210:
        index = (2 * nmode + 1) * (ipoint - 1);
        alintp(index + 1) = twopif;
        FEM_DO_SAFE(j, 1, nmode) {
          L = 2 * (j - 1) + 1;
          alintp(index + L + 1) = tir(j, i);
          alintp(index + L + 2) = tii(j, i);
        }
        if (iprsup >= 1) {
          {
            write_loop wloop(cmn, lunit6, star);
            wloop, " Ti for column ", imode, "are ";
            FEM_DO_SAFE(j, 1, nmode) {
              wloop, tir(j, i), tii(j, i);
            }
          }
        }
        statement_3215:;
      }
    }
    //C             YC & A1 & Ti FUNCTIONS                                    M43.2956
    ncurve = 2;
    if (nfitmx == 1) {
      ncurve = nmode;
    }
    FEM_DO_SAFE(i, 1, ncurve) {
      minust(i) = 0;
    }
    FEM_DO_SAFE(icurve, 1, ncurve) {
      time44(cmn, tclock(1));
      write(lunit6,
        "(' Begin modal fit at  ',2a4,'.     IMODE, NCURVE =',2i5)"),
        tclock, imode, ncurve;
      numone = 0;
      numzro = 0;
      iftype = icurve;
      if (nfitmx == 1) {
        iftype = 1;
      }
      //C                                                                       M32.7842
      //C             READ PARAMETERS                                           M32.7843
      //C                                                                       M32.7844
      if (icurve == 2 && nfitmx == 0) {
        goto statement_3150;
      }
      if (imode != nexmis) {
        goto statement_3152;
      }
      misc39(cmn);
      epstzc = epstol;
      normzc = normax;
      iecozc = iecode;
      ifwtzc = ifwta;
      ifplzc = ifplot;
      ifdazc = ifdat;
      inelzc = inelim;
      statement_3152:
      if (modskp(1, imode) == 0) {
        goto statement_3200;
      }
      if (nfitmx == 0) {
        goto statement_3156;
      }
      write(lunit6,
        "(/,/,' @@@ BEGIN Ti FITTING FOR ELEMENT:',2i2,3x,'@@@')"),
        icurve, imode;
      if (lltemp(imode) != icurve) {
        goto statement_3160;
      }
      write(lunit6, star), " This Tij = (1.,0.)  ";
      goto statement_8792;
      statement_3156:
      write(lunit6,
        "(/,/,1x,'@@@ BEGIN  Yc  FITTING FOR MODE',i3,3x,'@@@',1x)"),
        imode;
      goto statement_3160;
      statement_3150:
      if (imode != 1) {
        goto statement_3170;
      }
      if (nexmis ==  - 1) {
        goto statement_3170;
      }
      write(lunit6,
        "(/,/,1x,'*** ERROR STOP. USER HAS NOT REQUESTED ',"
        "'THE READING OF MISCELLANEOUS DATA FOR ',"
        "'MODE 1 OF A1 FITTING. NEXMIS =',i5)"),
        nexmis;
      stoptp(cmn);
      statement_3170:
      if (imode !=  - nexmis) {
        goto statement_3180;
      }
      //C     THIS MODE OF A1 HAS NEW MISCELLANEOUS DATA:                       M32.7867
      modify = 2;
      misc39(cmn);
      epsta1 = epstol;
      norma1 = normax;
      iecoa1 = iecode;
      ifwta1 = ifwta;
      ifpla1 = ifplot;
      ifdaa1 = ifdat;
      inela1 = inelim;
      statement_3180:
      if (modskp(2, imode) == 0) {
        goto statement_3200;
      }
      write(lunit6,
        "(/,/,1x,'@@@ BEGIN  A1  FITTING FOR MODE',i3,3x,'@@@',1x)"),
        imode;
      statement_3160:
      if (icurve == 2 && nfitmx == 0) {
        goto statement_3162;
      }
      epstol = epstzc;
      normax = normzc;
      iecode = iecozc;
      ifwta = ifwtzc;
      ifplot = ifplzc;
      ifdat = ifdazc;
      inelim = inelzc;
      goto statement_3164;
      statement_3162:
      epstol = epsta1;
      normax = norma1;
      iecode = iecoa1;
      ifwta = ifwta1;
      ifplot = ifpla1;
      ifdat = ifdaa1;
      inelim = inela1;
      statement_3164:
      if (normax <= mpoles) {
        goto statement_3165;
      }
      write(lunit6,
        "(/,/,1x,'%%% SPECIFIED MAXIMUM ORDER (',i3,"
        "') EXCEEDS DIMENSIONS LIMIT (',i3,').',/,1x,"
        "'MAXIMUM ORDER WILL BE SET EQUAL TO THIS LIMIT %%%',1x)"),
        normax, mpoles;
      normax = mpoles;
      //C                                                                       M32.7902
      //C             READ DATA POINTS                                          M32.7903
      //C                                                                       M32.7904
      statement_3165:
      if (ifdat == 0) {
        goto statement_3210;
      }
      write(lunit6, "(/,/,1x,30x,'###  D A T A  F U N C T I O N  ###')");
      if (icurve >= 2 || nfitmx == 1) {
        goto statement_3167;
      }
      write(lunit6,
        "(/,/,1x,' UNITS: FREQ IN HZ; Yc IN MHOS, PHYc IN DEGREES')");
      write(lunit6, "(/,1x,4x,'FREQ',8x,'Yc',8x,'PHYc',7x,'FREQ')");
      goto statement_3210;
      statement_3166:
      write(lunit6,
        "(/,/,1x,'UNITS: FREQ IN HZ; Ti UNITLESS, PHTi IN DEGREES')");
      write(lunit6, "(/,1x,4x,'FREQ',8x,'Ti',8x,'PHTi',7x,'FREQ')");
      goto statement_3210;
      statement_3167:
      if (nfitmx == 1) {
        goto statement_3166;
      }
      write(lunit6,
        "(/,/,1x,"
        "' UNITS: FREQ IN HZ; VELOCITY IN KM/SEC, TRAVELING TIME INMILLISEC, A"
        "1 IN PER UNIT, PHA1 IN DEGREES')");
      write(lunit6,
        "(/,5x,'FREQ',4x,'VELOCITY',3x,'TRAV.TIME',5x,'A1',8x,'PHA1',7x,"
        "'FREQ')");
      statement_3210:
      FEM_DO_SAFE(ipoint, 1, npoint) {
        if (ipoint == 1) {
          f0 = alintp(1);
        }
        index = (ipoint - 1) * 5;
        if (nfitmx == 1) {
          index = (2 * nmode + 1) * (ipoint - 1);
        }
        fdat = alintp(index + 1);
        if (icurve >= 2 || nfitmx == 1) {
          goto statement_3110;
        }
        adat = alintp(index + 2);
        //C  === VALUE OF G DIRECTLY IN THE MODAL DOMAIN ===                      M32.7949
        //C     IF (GDAT.EQ.0.) GDAT = GMODE/CONVUN                               M43.2997
        phdat = alintp(index + 3);
        //C  === EVALUATE LINE FUNCTIONS ===                                      M32.7952
        if (icurve >= 2 || nfitmx == 1) {
          goto statement_3110;
        }
        if (ifdat == 0) {
          goto statement_3120;
        }
        d3 = phdat * 360.f / twopi;
        write(lunit6, format_7034), fdat, adat, d3, fdat;
        goto statement_3120;
        statement_3104:
        L = index + 2 * (icurve - 1) + 2;
        adat = alintp(L);
        if (ipoint == 1) {
          asave = adat * tenm3;
        }
        if (adat < asave) {
          goto statement_3130;
        }
        phdat = alintp(L + 1);
        if (ifdat == 0) {
          goto statement_3103;
        }
        d3 = phdat * 360.f / twopi;
        write(lunit6, format_7034), fdat, adat, d3, fdat;
        statement_3103:
        if (std::abs(adat - 1.f) < cmn.epsiln) {
          numone++;
        }
        //C     IF ( (180. - ABSZ( PHDAT*360./TWOPI )) .GT. 10. )  GO TO 3120     M43.3012
        if (minust(icurve) == 1) {
          goto statement_3105;
        }
        if ((pai - std::abs(phdat)) > tendeg) {
          goto statement_3106;
        }
        if (ipoint > 1) {
          goto statement_3106;
        }
        minust(icurve) = 1;
        statement_3105:
        phdat += pai;
        statement_3106:
        if (adat < tenm3) {
          numzro++;
        }
        goto statement_3120;
        //C  ### EVALUATION OF THE PROPAGATION FUNCTION A1 ###                    M32.7965
        statement_3110:
        if (nfitmx == 1) {
          goto statement_3104;
        }
        alpha = alintp(index + 4);
        beta = alintp(index + 5);
        if (iprsup >= 1) {
          write(lunit6, star), " alpha, beta =", alpha, beta;
        }
        adat = expz(-alpha * dist);
        if (adat > 1.5e0) {
          goto statement_3132;
        }
        if (adat < cmn.amina1) {
          goto statement_3130;
        }
        phdat = -beta * dist;
        if (ifdat == 0) {
          goto statement_3120;
        }
        d3 = fdat / beta;
        d4 = (dist / d3) * 1.e3;
        d5 = phdat * 360.e0 / twopi;
        write(lunit6, "(1x,6d11.4)"), fdat, d3, d4, adat, d5, fdat;
        statement_3120:
        d11 = fdat / twopi;
        xdat(ipoint) = alog1z(d11);
        ydat(ipoint) = alog1z(adat);
        aphdat(ipoint) = phdat;
      }
      n9 = .75f * npoint;
      if (numone < n9) {
        goto statement_3128;
      }
      write(lunit6, star), " This is a near-one Tij element. ";
      goto statement_8792;
      statement_3128:
      if (numzro >= n9) {
        goto statement_8793;
      }
      //C                                                                       M32.7988
      ndata = npoint;
      goto statement_3140;
      statement_3130:
      ndata = ipoint - 1;
      goto statement_3140;
      statement_3132:
      write(lunit6,
        "(/,/,1x,25x,"
        "'\?\?\?\?\?\?\?\?\?\?  A T T E N T I O N  \?\?\?\?\?\?\?\?\?\?',/,1x,"
        "'THE MAGNITUDE OF THE LINE PROPAGATION FUNCTION (A1',') FOR MODE',i3,"
        "3x,'ATTAINS VALUES LARGER THAN 1.',/,1x,"
        "'THIS CONDITION IS PROBABLY CAUSED BY THE LIMITATIO',"
        "'NS OF USING A CONSTANT COMPLEX TRANSFORMATION MATR','IX',/,1x,"
        "'TO DIAGONALIZE THE LINE MATRICES AT ALL FREQUENCIE',"
        "'S. NEVERTHELESS, THE FUNCTION WILL BE FIT UP TO A ',/,1x,"
        "'MAGNITUDE VALUE OF 1.5.')"),
        imode;
      write(lunit6,
        "(1x,'HOWEVER, MORE REALISTIC RESULTS COULD PROBABLY BE ',"
        "'OBTAINED BY USING ONLY THE REAL PART OF THE TRANSF','ORMATION',/,1x,"
        "'MATRIX (OPTION -2 IN FREQUENCY LOOP CARD IN LINE C',"
        "'ONSTANTS DATA).')");
      ndata = ipoint - 1;
      //C   == TRAVELLING TIME OF HIGHEST FREQ. POINT ==                        M32.8012
      statement_3140:
      if (icurve == 2 && nfitmx == 0) {
        travhf = dist * beta / fdat;
      }
      //C                                                                       M32.8015
      //C             DEFINE CURVE ZONES                                        M32.8016
      //C                                                                       M32.8017
      iknee = 1;
      xknee(1) = xdat(1);
      ylevl0 = ydat(1);
      i = 1;
      statement_120:
      i++;
      if (i > ndata) {
        goto statement_230;
      }
      if (ydat(i) < (ylevl0 - d1lim)) {
        goto statement_130;
      }
      if (ydat(i) > (ylevl0 + d1lim)) {
        goto statement_180;
      }
      goto statement_120;
      //C  LOOK FOR VALLEY                                                      M32.8032
      statement_130:
      ylevl0 = ydat(i);
      x1levl = xdat(i);
      statement_140:
      i++;
      if (i > ndata) {
        goto statement_230;
      }
      if (ydat(i) < (ylevl0 - d1lim)) {
        goto statement_130;
      }
      if (ydat(i) > (ylevl0 + d1lim)) {
        goto statement_150;
      }
      goto statement_140;
      statement_150:
      iscape = i;
      statement_160:
      i = i - 1;
      if (ydat(i) <= (ylevl0 + d2lim)) {
        goto statement_170;
      }
      goto statement_160;
      statement_170:
      x2levl = xdat(i);
      iknee++;
      if (iknee > mxknee) {
        goto statement_2110;
      }
      xlevl = (x1levl + x2levl) * onehaf;
      xknee(iknee) = xlevl;
      //C  LOOK FOR PEAK                                                        M32.8049
      i = iscape;
      statement_180:
      ylevl0 = ydat(i);
      x1levl = xdat(i);
      statement_190:
      i++;
      if (i > ndata) {
        goto statement_230;
      }
      if (ydat(i) > (ylevl0 + d1lim)) {
        goto statement_180;
      }
      if (ydat(i) < (ylevl0 - d1lim)) {
        goto statement_200;
      }
      goto statement_190;
      statement_200:
      iscape = i;
      statement_210:
      i = i - 1;
      if (ydat(i) >= (ylevl0 - d2lim)) {
        goto statement_220;
      }
      goto statement_210;
      statement_220:
      x2levl = xdat(i);
      iknee++;
      if (iknee > mxknee) {
        goto statement_2110;
      }
      xlevl = (x1levl + x2levl) * onehaf;
      xknee(iknee) = xlevl;
      i = iscape;
      goto statement_130;
      statement_230:
      iknee++;
      if (iknee > mxknee) {
        goto statement_2110;
      }
      xknee(iknee) = xdat(ndata);
      if (idebug == 0) {
        goto statement_250;
      }
      write(lunit6, "(/,1x,13x,'--- CURVE ZONES ---',1x)");
      FEM_DO_SAFE(i, 1, iknee) {
        write(lunit6, "(/,10x,i10,f10.3)"), i, xknee(i);
      }
      statement_250:
      nzone = iknee - 1;
      //C   == PARAMETERS FOR LEAST SQUARES ERROR CHECKING ==                   M32.8080
      dxcomp = .05e0;
      nechk1 = ndata / (aptdec * dxcomp) + onehav;
      xbegr = xdat(1);
      xendr = xknee(2);
      d1 = ydat(1);
      refb = yfun39(cmn, xendr);
      d3 = .001e0;
      d4 = refb - d1;
      d5 = fem::pow(10.e0, d4);
      ycut = d1 + alog1z(unity + d3 * (d5 - unity));
      ycutpu = (ycut - d1) / (refb - d1);
      refa = yfun39(cmn, xbegr);
      split(cmn, xbegr, xendr, ycutpu, xbegtl);
      xbegr = xdat(ndata);
      xendr = xknee(iknee - 1);
      d1 = ydat(ndata);
      refb = yfun39(cmn, xendr);
      if (icurve == 2 && nfitmx == 0) {
        d3 = .25e0;
      }
      d4 = refb - d1;
      d5 = fem::pow(10.e0, d4);
      ycut = d1 + alog1z(unity + d3 * (d5 - unity));
      ycutpu = (ycut - d1) / (refb - d1);
      refa = yfun39(cmn, xbegr);
      split(cmn, xbegr, xendr, ycutpu, xendtl);
      i1 = aptdec * (xbegtl - xdat(1)) + 1.e0;
      i2 = aptdec * (xendtl - xdat(1)) + 2.e0;
      nechk2 = (i2 - i1 + 1) / (aptdec * dxcomp) + onehav;
      //C                                                                       M32.8106
      //C             MAIN LOOP FOR ALL-SEGMENTS ALLOCATION                     M32.8107
      //C                                                                       M32.8108
      iterlp = 0;
      incrtl = 0;
      erropt = 1.e12;
      ichkp = 0;
      npole = 0;
      if (normax > 10) {
        goto statement_252;
      }
      tolfac = 3.0e0;
      tolmin = .70e0;
      goto statement_260;
      statement_252:
      tolfac = 2.0e0;
      tolmin = .20e0;
      statement_260:
      iterlp++;
      if (idebug >= 1) {
        write(lunit6,
          "(/,/,2x,'###  A L L O C A T I O N  L O O P  NO.',i3,4x,'###',1x)"),
          iterlp;
      }
      statement_265:
      ntotra = 0;
      FEM_DO_SAFE(izone, 1, nzone) {
        xbegz = xknee(izone);
        xendz = xknee(izone + 1);
        if (yfun39(cmn, xbegz) > yfun39(cmn, xendz)) {
          goto statement_270;
        }
        //C   POSITIVE SLOPE ZONE                                                 M32.8129
        signz = 1.f;
        goto statement_280;
        //C   NEGATIVE SLOPE ZONE                                                 M32.8132
        statement_270:
        signz = -1.f;
        //C   ALLOCATE SLOPES IN ZONE                                             M32.8134
        statement_280:
        ioprau = 0;
        ichkra = 1;
        nchkra = 1;
        xchkra(1) = xbegz;
        xchkra(2) = xendz;
        //C                                                                       M32.8140
        statement_290:
        id = 2 * ichkra;
        xbegr = xchkra(id - 1);
        xendr = xchkra(id);
        refa = yfun39(cmn, xbegr);
        refb = yfun39(cmn, xendr);
        xcla = 0.f;
        xclb = 0.f;
        xlim1 = xbegr;
        xlim2 = xendr;
        if (xbegr == xbegz) {
          split(cmn, xbegr, xendr, clear, xcla);
        }
        if (xendr != xendz) {
          goto statement_310;
        }
        refa = yfun39(cmn, xendr);
        refb = yfun39(cmn, xbegr);
        split(cmn, xendr, xbegr, clear, xclb);
        d1 = refa;
        refa = refb;
        refb = d1;
        statement_310:
        if (xcla != 0.f) {
          xlim1 = xcla;
        }
        if (xclb != 0.f) {
          xlim2 = xclb;
        }
        if (idebug >= 3) {
          write(lunit6,
            "(/,/,1x,'REGION:',3x,'XBEG=',e11.4,3x,'XEND=',e11.4,/)"),
            xbegr, xendr;
        }
        //CCC      write (*,*) ' after #130 XLIM2, XLIM1  ', XLIM2 , XLIM1        M43.3059
        abeta = (refb - refa) / (xlim2 - xlim1);
        nalph1 = abeta;
        alpha = nalph1 + signz;
        locsl(cmn, xbegr, xendr, alpha, xmidr, xcorna, xcornb, erymax);
        //CCC      write(*,*) 'IZONE, ICHKRA, XMIDR, XENDR after call LOCSL  ',   M43.3061
        //CCC     1 IZONE, ICHKRA, XMIDR, XENDR                                   M43.3062
        if (std::abs(xmidr - xendr) > 0.001e0) {
          goto statement_313;
        }
        if (xendr == xendz) {
          goto statement_440;
        }
        ichkra++;
        goto statement_290;
        statement_313:
        tolera = 14.5938964e0 + 3.26036143e0 * alogz(std::abs(abeta));
        if (tolera < tolmin) {
          tolera = tolmin;
        }
        tolera = tolfac * tolera;
        d13 = 1.0f + tolera / 100.f;
        tolera = alog1z(d13);
        if (idebug < 3) {
          goto statement_315;
        }
        d1 = 100.f * (fem::pow(10.f, erymax) - 1.f);
        d2 = 100.f * (fem::pow(10.f, tolera) - 1.f);
        write(lunit6,
          "(/,1x,'XMIDR=',e11.4,3x,'XCORNA=',e11.4,3x,'XCORNB=',e11.4,/,1x,"
          "'ABETA =',f7.2,4x,'ALPHA =',f7.2,/,1x,'ERYMAX=',f7.2,'%',3x,"
          "'TOLERA=',f7.2,'%',1x)"),
          xmidr, xcorna, xcornb, abeta, alpha, d1, d2;
        statement_315:
        if (erymax < tolera) {
          goto statement_330;
        }
        //C   DIVIDE REGION INTO TWO SUBREGIONS                                   M32.8175
        id = 2 * (nchkra + 1);
        nchkra += 2;
        if (2 * nchkra <= mxchkr) {
          goto statement_320;
        }
        if (iterlp == 1) {
          goto statement_2120;
        }
        goto statement_790;
        statement_320:
        xchkra(id - 1) = xbegr;
        xchkra(id) = xmidr;
        xchkra(id + 1) = xmidr;
        xchkra(id + 2) = xendr;
        ichkra++;
        goto statement_290;
        //C   STORE PARAMETERS, DO NOT SUBDIVIDE                                  M32.8187
        statement_330:
        ioprau++;
        if (4 * ioprau <= mzopra) {
          goto statement_340;
        }
        if (iterlp == 1) {
          goto statement_2130;
        }
        goto statement_790;
        statement_340:
        id = 4 * ioprau;
        zoprau(id - 3) = xbegr;
        zoprau(id - 2) = xcorna;
        zoprau(id - 1) = xcornb;
        zoprau(id) = alpha;
        if (ichkra == nchkra) {
          goto statement_350;
        }
        ichkra++;
        goto statement_290;
        //C                                                                       M32.8200
        statement_350:
        if (idebug < 3) {
          goto statement_360;
        }
        write(lunit6, "(/,/,16x,'--- RANGES CHECKED ---',/)");
        FEM_DO_SAFE(i, 1, nchkra) {
          id = 2 * i;
          write(lunit6, "(15x,2e11.4)"), xchkra(id - 1), xchkra(id);
        }
        write(lunit6, "(/,5x,'----- RANGES IN ZONE VECTOR. UNORDERED -----')");
        write(lunit6, "(/,10x,'XBEGR',6x,'XCORNA',6x,'XCORNB',4x,'ALPHA')");
        FEM_DO_SAFE(i, 1, ioprau) {
          id = 4 * i;
          write(lunit6, "(5x,3e12.4,f6.0)"), zoprau(id - 3), zoprau(id - 2),
            zoprau(id - 1), zoprau(id);
        }
        //C             SORT RANGES OF IDENTIFIED REGIONS                         M32.8219
        statement_360:
        noprao(izone) = ioprau;
        if (ioprau == 1) {
          goto statement_420;
        }
        //C   FILL IN AUXILIARY BUFFER                                            M32.8222
        FEM_DO_SAFE(i, 1, ioprau) {
          id1 = 2 * i - 1;
          id2 = 4 * i - 3;
          xauxd(id1) = zoprau(id2);
          xauxd(id1 + 1) = i;
        }
        //C   SORT AUXILIARY BUFFER                                               M32.8229
        k = ioprau;
        iflag = k;
        statement_380:
        if (iflag <= 0) {
          goto statement_400;
        }
        k = iflag - 1;
        iflag = 0;
        FEM_DO_SAFE(j, 1, k) {
          id = 2 * j - 1;
          if (xauxd(id) <= xauxd(id + 2)) {
            goto statement_390;
          }
          xd1 = xauxd(id);
          xd2 = xauxd(id + 1);
          xauxd(id) = xauxd(id + 2);
          xauxd(id + 1) = xauxd(id + 3);
          xauxd(id + 2) = xd1;
          xauxd(id + 3) = xd2;
          iflag = j;
          statement_390:;
        }
        goto statement_380;
        //C             FILL-IN ORDERED VECTOR WITH ALL-RANGES INFORMATION        M32.8247
        statement_400:
        n1 = ntotra;
        ntotra += ioprau;
        if (4 * ntotra <= mzopra) {
          goto statement_405;
        }
        if (iterlp == 1) {
          goto statement_2140;
        }
        goto statement_790;
        statement_405:
        FEM_DO_SAFE(i, 1, ioprau) {
          id1 = 4 * (n1 + i) - 3;
          id = xauxd(2 * i) + onehav;
          id2 = 4 * id - 3;
          zoprao(id1) = zoprau(id2);
          zoprao(id1 + 1) = zoprau(id2 + 1);
          zoprao(id1 + 2) = zoprau(id2 + 2);
          zoprao(id1 + 3) = zoprau(id2 + 3);
        }
        goto statement_440;
        statement_420:
        n1 = ntotra;
        ntotra += ioprau;
        if (4 * ntotra <= mzopra) {
          goto statement_425;
        }
        if (iterlp == 1) {
          goto statement_2140;
        }
        goto statement_790;
        statement_425:
        id1 = 4 * (n1 + 1) - 3;
        zoprao(id1) = zoprau(1);
        zoprao(id1 + 1) = zoprau(2);
        zoprao(id1 + 2) = zoprau(3);
        zoprao(id1 + 3) = zoprau(4);
        statement_440:;
      }
      //C                                                                       M32.8274
      if (idebug < 2) {
        goto statement_450;
      }
      write(lunit6, "(/,6x,'-----  ALL-RANGES VECTOR. ORDERED  -----')");
      write(lunit6, "(/,10x,'XBEGR',6x,'XCORNA',6x,'XCORNB',4x,'ALPHA')");
      FEM_DO_SAFE(i, 1, ntotra) {
        id = 4 * i;
        write(lunit6, "(1x,4x,3e12.4,f6.0)"), zoprao(id - 3), zoprao(id - 2),
          zoprao(id - 1), zoprao(id);
      }
      //C  CHECK NUMBER OF POLES                                                M32.8286
      statement_450:
      npoles = 0;
      FEM_DO_SAFE(irange, 1, ntotra) {
        alpha = zoprao(4 * irange);
        jn = std::abs(alpha) + onehav;
        npoles += jn;
      }
      //C   == ORDER INCREMENT OR DECREMENT CHECK ==                            M32.8293
      if (npoles <= mpoles) {
        goto statement_465;
      }
      if (iterlp > 1) {
        goto statement_790;
      }
      goto statement_475;
      statement_465:
      if (npoles <= normax) {
        goto statement_470;
      }
      if (iterlp > 1) {
        goto statement_795;
      }
      goto statement_475;
      statement_470:
      d1 = npole;
      d2 = npoles;
      if (npole == 0) {
        goto statement_485;
      }
      if (d2 / d1 < 1.3e0) {
        goto statement_480;
      }
      if (ichkp == 1) {
        goto statement_485;
      }
      tolfac = 1.1e0 * tolfac;
      ichkp = 1;
      goto statement_265;
      statement_475:
      tolfac = 2.5e0 * tolfac;
      incrtl++;
      if (incrtl > 10) {
        goto statement_2160;
      }
      goto statement_265;
      statement_480:
      if (npoles > npole) {
        goto statement_485;
      }
      if (ichkp == 1) {
        goto statement_482;
      }
      tolfac = .8e0 * tolfac;
      goto statement_265;
      statement_482:
      tolfac = tolfac / 1.1e0;
      goto statement_265;
      statement_485:
      ichkp = 0;
      //C                                                                       M32.8319
      lrange = 0;
      FEM_DO_SAFE(irange, 1, ntotra) {
        alpha = zoprao(4 * irange);
        if (alpha > 0.f) {
          goto statement_490;
        }
        jn = -alpha + onehav;
        if (jn == 1) {
          goto statement_540;
        }
        goto statement_500;
        statement_490:
        jn = alpha + onehav;
        if (jn == 1) {
          goto statement_540;
        }
        //C   ASSIGN ZEROES FOR +ALPHA OR POLES FOR -ALPHA                        M32.8329
        statement_500:
        plocpn = 0.f;
        j2 = jn - 1;
        FEM_DO_SAFE(j, 1, j2) {
          plocpn += j;
        }
        alocpn = zoprao(4 * irange - 2) + deminp * plocpn / jn;
        lrange += (2 * jn + 2);
        azepo(lrange - 2 * jn - 1) = zoprao(4 * irange - 3);
        azepo(lrange - 2 * jn) = alpha;
        azepo(lrange - jn) = alocpn;
        FEM_DO_SAFE(j, 1, j2) {
          azepo(lrange - jn - j) = alocpn - j * deminp;
        }
        //C   ASSIGN POLES FOR +ALPHA OR ZEROES FOR -ALPHA                        M32.8343
        alocpn = zoprao(4 * irange - 1) - deminp * plocpn / jn;
        azepo(lrange - jn + 1) = alocpn;
        FEM_DO_SAFE(j, 1, j2) {
          azepo(lrange - jn + 1 + j) = alocpn + j * deminp;
        }
        goto statement_550;
        statement_540:
        lrange += 4;
        azepo(lrange - 3) = zoprao(4 * irange - 3);
        azepo(lrange - 2) = alpha;
        azepo(lrange - 1) = zoprao(4 * irange - 2);
        azepo(lrange) = zoprao(4 * irange - 1);
        statement_550:;
      }
      if (idebug < 2) {
        goto statement_570;
      }
      //C   OUTPUT AZEPO VECTOR                                                 M32.8357
      write(lunit6,
        "(/,/,1x,4x,'XBEGR',3x,'ALPHA',10x,"
        "'POLES AND ZEROES BEFORE ADJUSTMENT (LOG F)',/)");
      index = 0;
      FEM_DO_SAFE(irange, 1, ntotra) {
        alpha = azepo(index + 2);
        jn = std::abs(alpha) + onehav;
        i1 = index + 1;
        i2 = i1 + 1 + 2 * jn;
        {
          write_loop wloop(cmn, lunit6, format_7079);
          FEM_DO_SAFE(i, i1, i2) {
            wloop, azepo(i);
          }
        }
        index = i2;
      }
      //C   STORE INDEXES IN VECTOR                                             M32.8371
      statement_570:
      indxv(1) = 0;
      FEM_DO_SAFE(i, 2, ntotra) {
        index = indxv(i - 1);
        alpha = azepo(index + 2);
        jn = std::abs(alpha) + onehav;
        indxv(i) = index + 2 + 2 * jn;
      }
      //C  == CHECK FOR TYPE OF CURVE 2 ==                                      M32.8379
      id = indxv(ntotra);
      alpha = azepo(id + 2);
      if (icurve == 2 && alpha > 0.f && nfitmx == 0) {
        iftype = 1;
      }
      //C  CONVERT CORNERS TO FREQUENCY VALUES                                  M32.8383
      FEM_DO_SAFE(irange, 1, ntotra) {
        index = indxv(irange);
        id = index + 2;
        alpha = azepo(id);
        jn = std::abs(alpha) + onehav;
        j2n = 2 * jn;
        d13 = 10.f;
        FEM_DO_SAFE(j, 1, j2n) {
          azepo(id + j) = fem::pow(d13, azepo(id + j));
        }
        if (idebug < 4) {
          goto statement_600;
        }
        write(lunit6, star), " poles and zeroes in Hz b4 do 610 loop.";
        //C THL
        {
          write_loop wloop(cmn, lunit6, "((1x,10e11.4))");
          FEM_DO_SAFE(i, id + 1, id + j2n) {
            wloop, azepo(i);
          }
        }
        statement_600:;
      }
      //C                                                                       M32.8394
      //C             CORNERS ADJUSTMENTS                                       M32.8395
      //C                                                                       M32.8396
      FEM_DO_SAFE(j, 1, 3) {
        if (idebug >= 3) {
          write(lunit6,
            "(/,/,10x,'*** CORNERS ADJUSTMENT LOOP NO.',i2,3x,'***')"),
            j;
        }
        adjpk(cmn);
        adjcr(cmn);
        //CTHL
        if (idebug < 4) {
          goto statement_610;
        }
        //C THL
        write(lunit6, star), " AFTER CALL ADJCR, J=,", j;
        write(lunit6, format_7083);
        index = 0;
        FEM_DO_SAFE(irange, 1, ntotra) {
          alpha = azepo(index + 2);
          jn = std::abs(alpha) + onehav;
          i1 = index + 1;
          i2 = i1 + 1 + 2 * jn;
          {
            write_loop wloop(cmn, lunit6, format_7079);
            FEM_DO_SAFE(i, i1, i2) {
              wloop, azepo(i);
            }
          }
          index = i2;
          //C  THL
        }
        statement_610:;
      }
      if (idebug < 3) {
        goto statement_630;
      }
      //C             OUTPUT POLES & ZEROES AFTER ADJUSTMENTS                   M32.8405
      write(lunit6, format_7083);
      index = 0;
      FEM_DO_SAFE(irange, 1, ntotra) {
        alpha = azepo(index + 2);
        jn = std::abs(alpha) + onehav;
        i1 = index + 1;
        i2 = i1 + 1 + 2 * jn;
        {
          write_loop wloop(cmn, lunit6, format_7079);
          FEM_DO_SAFE(i, i1, i2) {
            wloop, azepo(i);
          }
        }
        index = i2;
      }
      //C  ==  STORE ZEROES AND POLES ON SEPARATE VECTORS ==                    M32.8418
      statement_630:
      ncorn = 0;
      FEM_DO_SAFE(irange, 1, ntotra) {
        id = indxv(irange) + 2;
        alpha = azepo(id);
        jn = std::abs(alpha) + onehav;
        if (alpha > 0.f) {
          goto statement_660;
        }
        FEM_DO_SAFE(j, 1, jn) {
          fcp(ncorn + j) = azepo(id + j);
        }
        FEM_DO_SAFE(j, 1, jn) {
          fcz(ncorn + j) = azepo(id + jn + j);
        }
        goto statement_690;
        statement_660:
        FEM_DO_SAFE(j, 1, jn) {
          fcz(ncorn + j) = azepo(id + j);
        }
        FEM_DO_SAFE(j, 1, jn) {
          fcp(ncorn + j) = azepo(id + jn + j);
        }
        statement_690:
        ncorn += jn;
      }
      npole = ncorn;
      nzero = ncorn;
      if (iftype == 2) {
        nzero = nzero - jn;
      }
      //C                                                                       M32.8439
      //C              CHECK LEAST-SQUARES DEVIATION                            M32.8440
      //C                                                                       M32.8441
      error1 = 0.f;
      error2 = 0.f;
      x = xdat(1) - dxcomp;
      statement_710:
      x += dxcomp;
      if (x > xdat(ndata)) {
        goto statement_750;
      }
      freq = fem::pow(10.e0, x);
      freq2 = fem::pow2(freq);
      amagp = 1.e0;
      if (nzero == 0) {
        goto statement_725;
      }
      FEM_DO_SAFE(j, 1, nzero) {
        amagp = amagp * (fem::pow2(fcz(j)) + freq2) / (fem::pow2(fcp(
          j)) + freq2);
      }
      statement_725:
      amaglg = alog1z(amagp);
      if (iftype == 1) {
        goto statement_740;
      }
      j1 = nzero + 1;
      FEM_DO_SAFE(j, j1, npole) {
        amaglg = amaglg - alog1z(fem::pow2(fcp(j)) + freq2);
      }
      statement_740:
      amaglg = hreflg + amaglg / 2.e0;
      d1 = amaglg - yfun39(cmn, x);
      if (x > 1.60e0 && x < 1.956e0) {
        d1 = 3.e0 * d1;
      }
      error1 += fem::pow2(d1);
      if (x < xbegtl || x > xendtl) {
        goto statement_710;
      }
      error2 += fem::pow2(d1);
      goto statement_710;
      statement_750:
      epser1 = error1 / nechk1;
      epser2 = error2 / nechk2;
      epserr = epser2;
      if (idebug == 0) {
        goto statement_756;
      }
      d1 = 100.e0 * (fem::pow(10.e0, sqrtz(epser1)) - 1.e0);
      d2 = 100.e0 * (fem::pow(10.e0, sqrtz(epser2)) - 1.e0);
      write(lunit6,
        "(/,/,1x,'*** LSQ AVE ERROR =',e12.4,1x,'%',7x,'LSQ CHECK ERROR =',"
        "e12.4,1x,'%',2x,'***',/,1x,'***',6x,'NO. OF POLES =',i3,20x,"
        "'NO. OF ZEROES =',i3,9x,'***',1x)"),
        d1, d2, npole, nzero;
      if (iecode == 1) {
        goto statement_754;
      }
      d1 = 100.e0 * (fem::pow(10.e0, sqrtz(epstol)) - 1.e0);
      write(lunit6,
        "(/,1x,'--- ERROR CRITERION: LSQ CHECK ERROR LESS THAN',f5.2,1x,"
        "'%  ---',1x)"),
        d1;
      goto statement_756;
      statement_754:
      write(lunit6,
        "(/,1x,'--- ERROR CRITERION: MINIMUM LSQ CHECK ERROR ',"
        "'WITHIN GIVEN MAXIMUM ORDER (',i3,2x,'POLES ) ---')"),
        normax;
      statement_756:
      if (epserr >= erropt) {
        goto statement_780;
      }
      //C  STORE OPTIMUM VALUES                                                 M32.8486
      FEM_DO_SAFE(j, 1, npole) {
        fcpr(j) = fcp(j);
      }
      FEM_DO_SAFE(j, 1, nzero) {
        fczr(j) = fcz(j);
      }
      hrflgr = hreflg;
      npoler = npole;
      nzeror = nzero;
      erropt = epserr;
      statement_780:
      if (epserr < epstol && iecode == 0) {
        goto statement_800;
      }
      if (epserr >= 5.e0 * erropt && inelim == 0) {
        goto statement_797;
      }
      tolfac = .8e0 * tolfac;
      goto statement_260;
      statement_790:
      if (idebug >= 1) {
        write(lunit6,
          "(/,/,1x,'--- FURTHER ORDER INCREASE WAS NOT ',"
          "'POSSIBLE BECAUSE, OF VECTORS DIMENSIONS ---',1x)");
      }
      goto statement_800;
      statement_795:
      if (idebug >= 1) {
        write(lunit6,
          "(/,/,1x,'--- NO. OF POLES IN THIS LOOP (',i3,"
          "') IS LARGER THAN SPECIFIED LIMIT (',i3,') ---',1x)"),
          npoles, normax;
      }
      goto statement_800;
      statement_797:
      if (idebug >= 1) {
        write(lunit6,
          "(/,/,1x,'--- NO FURTHER ORDER INCREASE WAS ALLOWED BECAUSE ERROR',"
          "/,1x,'IN THIS LOOP WAS 5 TIMES LARGER THAN PREVIOUS MINIMUM.',/,1x,"
          "'IF FURTHER ORDER INCREASE IS DESIRED MAKE \"INELIM = 1\" ',/,1x,"
          "'IN PARAMETERS LIST ---',1x)");
      }
      statement_800:
      if (erropt > epstol && idebug >= 1) {
        write(lunit6,
          "(/,/,1x,'--- MAXIMUM TOLERANCE CRITERION COULD NOT ','BE MET ---')");
      }
      //C                                                                       M32.8520
      //C             TIME DELAY FOR PROPAGATION FUNCTION                       M32.8521
      //C                                                                       M32.8522
      if (icurve == 1 || nfitmx == 1) {
        goto statement_805;
      }
      dx = .1e0;
      x = xdat(1) - dx;
      statement_900:
      x += dx;
      if (x > xdat(ndata)) {
        goto statement_910;
      }
      if (aph(cmn, x) <  - .08727e0) {
        goto statement_920;
      }
      goto statement_900;
      statement_920:
      x1 = x;
      x2 = xdat(ndata);
      sumtau = 0.f;
      n = 0;
      x = x1 - dx;
      statement_930:
      x += dx;
      if (x > x2) {
        goto statement_940;
      }
      n++;
      freq = fem::pow(10.e0, x);
      php = 0.f;
      FEM_DO_SAFE(j, 1, nzeror) {
        php += std::atan2(freq, fczr(j)) - std::atan2(freq, fcpr(j));
      }
      if (iftype == 1) {
        goto statement_935;
      }
      j1 = nzeror + 1;
      FEM_DO_SAFE(j, j1, npoler) {
        php = php - std::atan2(freq, fcpr(j));
      }
      statement_935:
      tau = (php - aph(cmn, x)) / freq;
      sumtau += tau;
      goto statement_930;
      statement_940:
      taur = sumtau / (n * twopi);
      goto statement_950;
      statement_910:
      write(lunit6,
        "(/,/,1x,"
        "'*** SPECIFIED FREQUENCY RANGE DOES NOT CONTAIN ENOUGH CURVE ',/,"
        "' DYNAMICS FOR AN ACCURATE PHASE DISPLACEMENT EVALUATION. ',/,"
        "' TAU WILL BE TAKEN AS THE TRAVELLING TIME AT THE HIGHEST ',/,"
        "' GIVEN FREQUENCY ***')");
      taur = travhf;
      statement_950:
      if (idebug == 0) {
        goto statement_807;
      }
      d1 = 1.e3 * taur;
      d2 = fem::pow(10.e0, xdat(ndata));
      d3 = 1.e3 * travhf;
      write(lunit6,
        "(/,/,1x,'PHASE DISPLACEMENT TAU =',e12.4,3x,'MSEC',/,1x,"
        "'TRAVELLING TIME AT',e12.4,2x,'HZ',3x,'IS',e12.4,3x,'MSEC')"),
        d1, d2, d3;
      //C   == ADD EXTRA POLE TO A1 FUNCTION WITH TYPE 1 FIT ==                 M32.8566
      statement_807:
      if (iftype == 2) {
        goto statement_805;
      }
      npoler++;
      if (npoler > mpoles) {
        goto statement_2150;
      }
      d1 = xdat(ndata) + 5.e0;
      fcpr(npoler) = fem::pow(10.e0, d1);
      statement_805:
      if (ifwta == 0) {
        goto statement_850;
      }
      //C                                                                       M32.8573
      //C             COMPARISON TABLE                                          M32.8574
      //C                                                                       M32.8575
      d1 = fem::pow(10.e0, hrflgr);
      write(lunit6,
        "(/,1x,'CURVE TYPE =',i2,4x,'REFERENCE LEVEL =',e11.4)"),
        iftype, d1;
      write(lunit6, "(/,1x,'NO. POLES =',i3,4x,'NO. ZEROES =',i3)"),
        npoler, nzeror;
      if (icurve == 2 || nfitmx == 1) {
        goto statement_812;
      }
      write(lunit6,
        "(/,/,' TABLE OF Yc VS. YcEQ FOR MODE',i3,/,"
        "' UNITS: FREQ. IN HZ, MAGNITUDE IN OHMS, PHASE IN DEG., DELMAG IN %, "
        "DELPH IN DEG.',/,/,5x,'FREQ',6x,'YcMAG',5x,'YcEQMAG',5x,'DELMAG',6x,"
        "'YcPH',6x,'YcEQPH',5x,'DELPH',7x,'FREQ')"),
        imode;
      goto statement_814;
      statement_812:
      if (nfitmx == 1) {
        goto statement_813;
      }
      write(lunit6,
        "(/,1x,'TABLE OF  \"A1\"  VS.  \"A1EQ\"  FOR MODE',i3,/,1x,"
        "'UNITS: FREQUENCY IN HERTZ,  MAGNITUDE ',"
        "'IN PER UNIT,  PHASE IN DEGREES,  DELMAG ',"
        "'IN %,  DELPH IN DEGREES.',/,1x,"
        "'P1PH = A1EQPH+OMEGA*TAU; TAU IN MSEC; DELTAU IN % .',/,/,5x,'FREQ',"
        "6x,'A1MAG',5x,'A1EQMAG',5x,'DELMAG',6x,'A1PH',6x,'A1EQPH',5x,'DELPH',"
        "7x,'P1PH',7x,'TAU',7x,'DELTAU',6x,'FREQ')"),
        imode;
      goto statement_814;
      statement_813:
      write(lunit6,
        "(/,/,' TABLE OF Ti VS. TiEQ FOR ELEMENT ',2i2,/,"
        "' UNITS: FREQ. IN HZ, MAGNITUDE UNITLESS, PHASE IN DEG., DELMAG   IN "
        "%, DELPH IN DEG.',/,/,5x,'FREQ',6x,'TiMAG',5x,'TiEQMAG',5x,'DELMAG',"
        "6x,'TiPH',6x,'TiEQPH',5x,'DELPH',7x,'FREQ')"),
        icurve, imode;
      statement_814:
      dxcomp = .1e0;
      x = xdat(1) - dxcomp;
      statement_810:
      x += dxcomp;
      if (x > xdat(ndata)) {
        goto statement_850;
      }
      freq = fem::pow(10.e0, x);
      freq2 = fem::pow2(freq);
      amagp = 1.e0;
      php = 0.f;
      if (nzeror == 0) {
        goto statement_825;
      }
      FEM_DO_SAFE(j, 1, nzeror) {
        amagp = amagp * (fem::pow2(fczr(j)) + freq2) / (fem::pow2(
          fcpr(j)) + freq2);
        php += std::atan2(freq, fczr(j)) - std::atan2(freq, fcpr(j));
      }
      statement_825:
      amaglg = alog1z(amagp);
      if (iftype == 1) {
        goto statement_840;
      }
      j1 = nzeror + 1;
      FEM_DO_SAFE(j, j1, npoler) {
        amaglg = amaglg - alog1z(fem::pow2(fcpr(j)) + freq2);
        php = php - std::atan2(freq, fcpr(j));
      }
      statement_840:
      amaglg = hrflgr + amaglg / 2.e0;
      amagp = fem::pow(10.e0, amaglg);
      ax = fem::pow(10.e0, yfun39(cmn, x));
      d1 = (amagp / ax - 1.e0) * 100.e0;
      d2 = aph(cmn, x);
      d3 = d2 * 360.e0 / twopi;
      d4 = php * 360.e0 / twopi;
      d5 = std::abs(d4 - d3);
      if (icurve == 2 && nfitmx == 0) {
        goto statement_842;
      }
      write(lunit6, "(1x,8e11.4)"), freq, ax, amagp, d1, d3, d4, d5, freq;
      goto statement_810;
      statement_842:
      tau = (php - d2) / (twopi * freq);
      d8 = tau * 1.e3;
      d9 = (tau / taur - 1.e0) * 100.e0;
      d6 = d4 - 360.e0 * freq * taur;
      d7 = std::abs(d6 - d3);
      write(lunit6, "(1x,11e11.4)"), freq, ax, amagp, d1, d3, d6, d7,
        d4, d8, d9, freq;
      goto statement_810;
      //C                                                                       M32.8637
      statement_850:
      if (ifplot == 1) {
        ftplot(cmn, icurve, imode, nfitmx);
      }
      //C                                                                       M32.8640
      //C             PARTIAL FRACTION EXPANSION                                M32.8641
      //C                                                                       M32.8642
      FEM_DO_SAFE(ifrac, 1, npoler) {
        s = -fcpr(ifrac);
        resilg = hrflgr;
        sign = 1.e0;
        if (nzeror == 0) {
          goto statement_875;
        }
        FEM_DO_SAFE(j, 1, nzeror) {
          if (j == ifrac) {
            goto statement_865;
          }
          d1 = s + fczr(j);
          d2 = s + fcpr(j);
          d3 = std::abs(d1);
          d4 = std::abs(d2);
          sign = sign * (d1 / d3) * (d2 / d4);
          resilg += alog1z(d3) - alog1z(d4);
          goto statement_860;
          statement_865:
          d1 = s + fczr(j);
          d3 = std::abs(d1);
          sign = sign * (d1 / d3);
          resilg += alog1z(d3);
          statement_860:;
        }
        if (iftype == 1) {
          goto statement_870;
        }
        statement_875:
        j1 = nzeror + 1;
        FEM_DO_SAFE(j, j1, npoler) {
          if (j == ifrac) {
            goto statement_880;
          }
          d2 = s + fcpr(j);
          d4 = std::abs(d2);
          sign = sign * (d2 / d4);
          resilg = resilg - alog1z(d4);
          statement_880:;
        }
        statement_870:
        resid = (fem::pow(10.e0, resilg)) * sign;
        akfrac(ifrac) = twopi * resid;
        if (minust(icurve) == 1) {
          akfrac(ifrac) = -akfrac(ifrac);
        }
        alphaf(ifrac) = twopi * fcpr(ifrac);
      }
      //C                                                                       M32.8675
      //C     IF (ICURVE.EQ.1) HREFR = 10.D0**HRFLGR                            M43.3084
      if (icurve == 1 || nfitmx == 1) {
        hrefr = fem::pow(10.e0, hrflgr);
      }
      //C   == PUNCH PARAMETERS ==                                              M32.8678
      n23 = npoler;
      if (iofgnd == 1) {
        n23 = (npoler + 2) / 3 * 3;
      }
      if (icurve == 2 && nfitmx == 0) {
        goto statement_8779;
      }
      if (nfitmx == 1) {
        goto statement_8794;
      }
      d6 = koutpr;
      n8 = 2 * imode;
      if (imodal > 0 || mspedb == 1) {
        goto statement_8787;
      }
      if (ipunch == 0) {
        write(lunit7, format_8781), imode, vstacs(n8 - 1), vstacs(n8), d6;
      }
      if (idebug == 0) {
        goto statement_8794;
      }
      write(lunit1, format_8782), imode, vstacs(n8 - 1), vstacs(n8), d6;
      kount++;
      goto statement_8794;
      statement_8787:
      if (itrnsf == 1) {
        ifqdpt = 0;
      }
      if (ipunch == 0) {
        write(lunit7, format_8790), imode, vstacs(n8 - 1), vstacs(n8),
          d6, nmode, ifqdpt;
      }
      if (idebug == 0) {
        goto statement_8794;
      }
      write(lunit1, format_8791), imode, vstacs(n8 - 1), vstacs(n8),
        d6, nmode, ifqdpt;
      kount++;
      goto statement_8794;
      statement_8793:
      write(lunit6, star), " This is a near-zero Tij element.";
      npoler = 1;
      hrefr = 0.f;
      akfrac(1) = 0.0f;
      alphaf(1) = 1.0f;
      n23 = 1;
      if (iofgnd == 1) {
        n23 = 3;
      }
      goto statement_8794;
      statement_8792:
      npoler = 1;
      hrefr = 1.f;
      akfrac(1) = 0.0f;
      alphaf(1) = 1.0f;
      numone = 0;
      n23 = 1;
      if (iofgnd == 1) {
        n23 = 3;
      }
      statement_8794:
      if (minust(icurve) == 1) {
        hrefr = -hrefr;
      }
      if (ipunch == 0) {
        write(lunit7, format_8798), npoler, hrefr;
      }
      if (idebug == 0) {
        goto statement_8788;
      }
      write(lunit1, format_8799), npoler, hrefr;
      kount++;
      goto statement_8788;
      statement_8779:
      if (ipunch == 0) {
        write(lunit7, format_8798), npoler, taur;
      }
      if (idebug == 0) {
        goto statement_8788;
      }
      write(lunit1, format_8799), npoler, taur;
      kount++;
      statement_8788:
      if (ipunch == 0) {
        {
          write_loop wloop(cmn, lunit7, format_8803);
          FEM_DO_SAFE(kp, 1, npoler) {
            wloop, akfrac(kp);
          }
        }
      }
      if (idebug == 0) {
        goto statement_8806;
      }
      {
        write_loop wloop(cmn, lunit1, format_8804);
        FEM_DO_SAFE(kp, 1, n23) {
          wloop, akfrac(kp);
        }
      }
      statement_8806:
      if (ipunch == 0) {
        {
          write_loop wloop(cmn, lunit7, format_8803);
          FEM_DO_SAFE(kp, 1, npoler) {
            wloop, alphaf(kp);
          }
        }
      }
      if (idebug == 0) {
        goto statement_8810;
      }
      {
        write_loop wloop(cmn, lunit1, format_8804);
        FEM_DO_SAFE(kp, 1, n23) {
          wloop, alphaf(kp);
        }
      }
      d1 = npoler / 3.e0;
      n2 = npoler / 3;
      kount += 2 * n2;
      if (d1 > n2) {
        kount += 2;
      }
      statement_8810:
      if (imode < 2) {
        goto statement_3200;
      }
      if (iprsup >= 1) {
        write(lunit6, star), " imode , imodal, and mspedb at 8810 =",
          imode, imodal, mspedb;
      }
      if (imodal > 0) {
        goto statement_3200;
      }
      if (mspedb == 1 && imode == 2) {
        goto statement_3200;
      }
      if (iprsup >= 1) {
        write(lunit6, star), " icurve =", icurve;
      }
      if (icurve == 2 && nfitmx == 0) {
        goto statement_8815;
      }
      npols1 = npoler;
      if (iprsup >= 1) {
        write(lunit6, star), " Storing  Zc info.";
      }
      FEM_DO_SAFE(kp, 1, npoler) {
        akfrs1(kp) = akfrac(kp);
        alphs1(kp) = alphaf(kp);
      }
      goto statement_3200;
      statement_8815:
      npols2 = npoler;
      if (iprsup >= 1) {
        write(lunit6, star), " Storing A1 info.";
      }
      FEM_DO_SAFE(kp, 1, npoler) {
        akfrs2(kp) = akfrac(kp);
        alphs2(kp) = alphaf(kp);
      }
      goto statement_6000;
      //C                                                                       M32.8727
      statement_3200:;
    }
    //C                                                                       M32.8729
  }
  if (itrnsf != 1) {
    goto statement_8820;
  }
  if (nfitmx != 0) {
    goto statement_8841;
  }
  nfitmx = 1;
  goto statement_8777;
  statement_6000:
  FEM_DO_SAFE(imode, 3, nmode) {
    FEM_DO_SAFE(icurve, 1, 2) {
      if (iprsup >= 1) {
        write(lunit6, star), " restoring the stored info at 6300.";
      }
      if (mspedb == 1 && imode == 3) {
        goto statement_6300;
      }
      if (icurve == 1) {
        npoler = npols1;
      }
      if (icurve == 2) {
        npoler = npols2;
      }
      n23 = npoler;
      if (iofgnd == 1) {
        n23 = (npoler + 2) / 3 * 3;
      }
      if (icurve == 2) {
        goto statement_6779;
      }
      d6 = koutpr;
      n8 = 2 * imode;
      if (mspedb > 0) {
        goto statement_6787;
      }
      if (ipunch == 0) {
        write(lunit7, format_8781), imode, vstacs(n8 - 1), vstacs(n8), d6;
      }
      if (idebug == 0) {
        goto statement_6794;
      }
      write(lunit1, format_8782), imode, vstacs(n8 - 1), vstacs(n8), d6;
      kount++;
      goto statement_6794;
      statement_6787:
      if (ipunch == 0) {
        write(lunit7, format_8790), imode, vstacs(n8 - 1), vstacs(n8),
          d6, nmode, ifqdpt;
      }
      if (idebug == 0) {
        goto statement_6794;
      }
      write(lunit1, format_8791), imode, vstacs(n8 - 1), vstacs(n8),
        d6, nmode, ifqdpt;
      kount++;
      statement_6794:
      if (ipunch == 0) {
        write(lunit7, format_8798), npoler, hrefr;
      }
      if (idebug == 0) {
        goto statement_6788;
      }
      write(lunit1, format_8799), npoler, hrefr;
      kount++;
      goto statement_6788;
      statement_6779:
      if (ipunch == 0) {
        write(lunit7, format_8798), npoler, taur;
      }
      if (idebug == 0) {
        goto statement_6788;
      }
      write(lunit1, format_8799), npoler, taur;
      kount++;
      statement_6788:
      if (icurve == 2) {
        goto statement_6800;
      }
      if (ipunch == 0) {
        {
          write_loop wloop(cmn, lunit7, format_8803);
          FEM_DO_SAFE(kp, 1, npoler) {
            wloop, akfrs1(kp);
          }
        }
      }
      if (idebug == 0) {
        goto statement_6806;
      }
      {
        write_loop wloop(cmn, lunit1, format_8804);
        FEM_DO_SAFE(kp, 1, n23) {
          wloop, akfrs1(kp);
        }
      }
      statement_6806:
      if (ipunch == 0) {
        {
          write_loop wloop(cmn, lunit7, format_8803);
          FEM_DO_SAFE(kp, 1, npoler) {
            wloop, alphs1(kp);
          }
        }
      }
      if (idebug == 0) {
        goto statement_6280;
      }
      {
        write_loop wloop(cmn, lunit1, format_8804);
        FEM_DO_SAFE(kp, 1, n23) {
          wloop, alphs1(kp);
        }
      }
      goto statement_6810;
      statement_6800:
      if (ipunch == 0) {
        {
          write_loop wloop(cmn, lunit7, format_8803);
          FEM_DO_SAFE(kp, 1, npoler) {
            wloop, akfrs2(kp);
          }
        }
      }
      if (idebug == 0) {
        goto statement_6807;
      }
      {
        write_loop wloop(cmn, lunit1, format_8804);
        FEM_DO_SAFE(kp, 1, n23) {
          wloop, akfrs2(kp);
        }
      }
      statement_6807:
      if (ipunch == 0) {
        {
          write_loop wloop(cmn, lunit7, format_8803);
          FEM_DO_SAFE(kp, 1, npoler) {
            wloop, alphs2(kp);
          }
        }
      }
      if (idebug == 0) {
        goto statement_6280;
      }
      {
        write_loop wloop(cmn, lunit1, format_8804);
        FEM_DO_SAFE(kp, 1, n23) {
          wloop, alphs2(kp);
        }
      }
      statement_6810:
      d1 = npoler / 3.e0;
      n2 = npoler / 3;
      kount += 2 * n2;
      if (d1 > n2) {
        kount += 2;
      }
      statement_6280:;
    }
    statement_6300:;
  }
  //C                                                                       M32.8731
  //C   == PUNCH TRANSFORMATION MATRIX ==                                   M32.8732
  statement_8820:
  if (imodal == 0 && mspedb == 0) {
    goto statement_8841;
  }
  if (imodal > 0) {
    goto statement_8822;
  }
  d1 = 2.0f;
  d2 = 6.0f;
  d3 = 1.0f / sqrtz(d1);
  d4 = 1.0f / sqrtz(d2);
  n1 = 1;
  FEM_DO_SAFE(i, 1, 6) {
    FEM_DO_SAFE(j, 1, 6) {
      if (i > 1) {
        goto statement_8021;
      }
      tir(j, i) = d4;
      goto statement_8023;
      statement_8021:
      if (i > 2) {
        goto statement_8025;
      }
      if (j > 3) {
        goto statement_8027;
      }
      tir(j, i) = d4;
      goto statement_8023;
      statement_8027:
      tir(j, i) = -d4;
      goto statement_8023;
      statement_8025:
      if (i > 3) {
        goto statement_8029;
      }
      if (j > 2) {
        goto statement_8031;
      }
      if (j == 1) {
        tir(j, i) = d3;
      }
      if (j == 2) {
        tir(j, i) = -d3;
      }
      goto statement_8023;
      statement_8031:
      tir(j, i) = 0.f;
      goto statement_8023;
      statement_8029:
      if (i > 4) {
        goto statement_8033;
      }
      if (j > 3) {
        goto statement_8035;
      }
      if (j > 2) {
        goto statement_8037;
      }
      tir(j, i) = d4;
      goto statement_8023;
      statement_8037:
      tir(j, i) = -d1 * d4;
      goto statement_8023;
      statement_8035:
      tir(j, i) = 0.f;
      goto statement_8023;
      statement_8033:
      if (i > 5) {
        goto statement_8039;
      }
      if (j >= 4 && j <= 5) {
        goto statement_8041;
      }
      goto statement_8031;
      statement_8041:
      if (j == 4) {
        tir(j, i) = d3;
      }
      if (j == 5) {
        tir(j, i) = -d3;
      }
      goto statement_8023;
      statement_8039:
      if (j > 3) {
        goto statement_8043;
      }
      goto statement_8031;
      statement_8043:
      if (j > 5) {
        goto statement_8045;
      }
      tir(j, i) = d4;
      goto statement_8023;
      statement_8045:
      tir(j, i) = -d1 * d4;
      statement_8023:
      tii(j, i) = 0.0f;
    }
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' TIR and TII for this special transposed double circuit  are',/(1x,"
        "8e15.7))");
      FEM_DO_SAFE(j, 1, 6) {
        FEM_DO_SAFE(i, 1, 6) {
          wloop, tir(j, i);
        }
      }
      FEM_DO_SAFE(j, 1, 6) {
        FEM_DO_SAFE(i, 1, 6) {
          wloop, tii(j, i);
        }
      }
    }
  }
  statement_8822:
  npoler = 1;
  akfrac(1) = 0.0f;
  alphaf(1) = 1.0f;
  n23 = 1;
  if (iofgnd == 1) {
    n23 = (npoler + 2) / 3 * 3;
  }
  FEM_DO_SAFE(imode, 1, nmode) {
    FEM_DO_SAFE(j, 1, nmode) {
      hrefr = tir(j, imode);
      if (ipunch == 0) {
        write(lunit7, format_8798), npoler, hrefr;
      }
      if (idebug == 0) {
        goto statement_8836;
      }
      write(lunit1, format_8799), npoler, hrefr;
      kount++;
      statement_8836:
      if (ipunch == 0) {
        write(lunit7, format_8803), akfrac(1);
      }
      if (idebug == 0) {
        goto statement_8838;
      }
      write(lunit1, format_8804), akfrac(1);
      statement_8838:
      if (ipunch == 0) {
        write(lunit7, format_8803), alphaf(1);
      }
      if (idebug == 0) {
        goto statement_8834;
      }
      write(lunit1, format_8804), alphaf(1);
      kount += 2;
      statement_8834:;
    }
  }
  //C                                                                       M32.8749
  statement_8841:
  if (idebug >= 1) {
    write(lunit6,
      "(/,' PUNCHED OUTPUT (ON LUNIT7) BEGINS WITH',"
      "' COMMENT CARDS DOCUMENTING THE',' TRANSMISSION CIRCUIT GEOMETRY.',/,"
      "' THE FOLLOWING IS A RECORD OF THE',"
      "' PUNCHING,  INCLUDING THE FINAL TWO',"
      "' COLUMNS WHICH DO NOT FIT ON CARD.',/,1x,82('='),/,"
      "' 001234567890123456789012345678901234567890',"
      "'1234567890123456789012345678901234567890',/,1x,82('='))");
  }
  //C   == RECOVER INFORMATION FROM LUNIT1, PRINT ON LUNIT6 ==              M32.8762
  cmn.io.rewind(lunit1);
  if (kount == 0) {
    goto statement_1550;
  }
  FEM_DO_SAFE(j, 1, kount) {
    {
      read_loop rloop(cmn, lunit1, format_1542);
      FEM_DO_SAFE(i, 1, 14) {
        rloop, textp(i);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_1542);
      FEM_DO_SAFE(i, 1, 14) {
        wloop, textp(i);
      }
    }
  }
  goto statement_1550;
  statement_9200:
  lstat(18) = nchain;
  lastov = nchain;
  nchain = 51;
  statement_9999:
  if (iprsup >= 6) {
    write(lunit6, "(' EXIT \"SUBR39\".   NCHAIN, KILL =',2i6)"), nchain, kill;
  }
  return;
  //C                                                                       M32.8777
  //C             TERMINATING CONDITIONS                                    M32.8778
  //C                                                                       M32.8779
  statement_2170:
  write(lunit6,
    "(/,/,1x,'%%% NUMBER OF MODES (',i2,') EXCEEDS LIMIT (',i2,"
    "'). EXECUTION TERMINATED %%%')"),
    nmode, mmodes;
  stoptp(cmn);
  statement_2100:
  write(lunit6,
    "(/,/,1x,'%%% DIMENSION OF DATA VECTORS (',i3,"
    "') EXCEEDED. EXECUTION TERMINATED %%%')"),
    mdapts;
  stoptp(cmn);
  statement_2110:
  write(lunit6,
    "(/,/,1x,'%%% DIMENSION OF XKNEE (',i2,"
    "') EXCEEDED. EXECUTION TERMINATED %%%')"),
    mxknee;
  stoptp(cmn);
  statement_2120:
  write(lunit6,
    "(/,/,1x,'%%% DIMENSION OF XCHKRA (',i3,"
    "') EXCEEDED. EXECUTION TERMINATED %%%')"),
    mxchkr;
  stoptp(cmn);
  statement_2130:
  write(lunit6,
    "(/,/,1x,'%%% DIMENSION OF ZOPRAU (',i3,"
    "') EXCEEDED. EXECUTION TERMINATED %%%')"),
    mzopra;
  stoptp(cmn);
  statement_2140:
  write(lunit6,
    "(/,/,1x,'%%% DIMENSION OF ZOPRAO (',i3,"
    "') EXCEEDED. EXECUTION TERMINATED %%%')"),
    mzopra;
  stoptp(cmn);
  statement_2160:
  write(lunit6,
    "(/,/,1x,'%%% THE ALGORITHM CANNOT FIT THIS CURVE',"
    "' WITHIN THE MAXIMUM ORDER SPECIFIED (',i3,').',/,1x,"
    "'=== INCREASE THIS LIMIT ===.',/,1x,"
    "'NO APPROXIMATION WAS GENERATED %%%')"),
    normax;
  stoptp(cmn);
  statement_2150:
  write(lunit6,
    "(/,/,1x,'%%% DIMENSION OF CORNER VECTORS (',i2,"
    "') EXCEEDED. EXECUTION TERMINATED %%%')"),
    mpoles;
  stoptp(cmn);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
over39(
  common& cmn)
{
  //C! COMMON  / C39B01 /   XDAT  (   10000 )
  //C! COMMON  / C39B02 /   YDAT  (   10000 )
  //C! COMMON  / C39B03 /   APHDAT(   10000 )
  subr39(cmn);
}

void
punpie(
  common& cmn,
  int const& kcirct) try
{
  common_write write(cmn);
  // COMMON cmn
  auto& lunit7 = cmn.lunit7;
  int& iprsup = cmn.iprsup;
  // COMMON com44
  const auto& brname = cmn.brname;
  // COMMON c44b02
  const auto& p = cmn.p;
  // COMMON c44b03
  const auto& z = static_cast<common_c44b03&>(cmn).z;
  // COMMON c44b17
  auto& yd = cmn.yd;
  //
  if (iprsup >= 1) {
    write(6, star), " Top \"PUNPIE\".";
  }
  write(lunit7, "('$VINTAGE, 1')");
  int j = 1;
  int i = fem::int0;
  int k = fem::int0;
  int kk = fem::int0;
  FEM_DO_SAFE(i, 1, kcirct) {
    k = i + j - 1;
    FEM_DO_SAFE(kk, j, k) {
      yd(kk) = yd(kk) / cmn.tenm6;
      if (kk == j) {
        write(lunit7, "(i2,2a6,12x,3e16.5)"), i, brname(2 * i - 1),
          brname(2 * i), p(kk), z(kk), yd(kk);
      }
      if (kk != j) {
        write(lunit7, "(26x,3e16.5)"), p(kk), z(kk), yd(kk);
      }
    }
    j = k + 1;
  }
  write(lunit7, "('$VINTAGE, 0')");
  if (iprsup >= 1) {
    write(6, star), " Exit \"PUNPIE\".";
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
cbal(
  int const& /* nm */,
  int const& n,
  arr_ref<double, 2> ar,
  arr_ref<double, 2> ai,
  int& low,
  int& igh,
  arr_ref<double> scale,
  int const& ndim)  try
{
  ar(dimension(ndim, ndim));
  ai(dimension(ndim, ndim));
  scale(dimension(20));
  double radix = fem::double0;
  double b2 = fem::double0;
  int k = fem::int0;
  int L = fem::int0;
  int m = fem::int0;
  int j = fem::int0;
  int i = fem::int0;
  double f = fem::double0;
  int iexc = fem::int0;
  int jj = fem::int0;
  int noconv = fem::int0;
  double c = fem::double0;
  double r = fem::double0;
  double g = fem::double0;
  double s = fem::double0;
  double c1 = fem::double0;
  //C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE           M29.4493
  //C     CBALANCE, WHICH IS A COMPLEX VERSION OF BALANCE,                  M29.4494
  //C     NUM. MATH. 13, 293-304(1969) BY PARLETT AND REINSCH.              M29.4495
  //C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 315-326(1971).   M29.4496
  //C                                                                       M29.4497
  //C     THIS SUBROUTINE BALANCES A COMPLEX MATRIX AND ISOLATES            M29.4498
  //C     EIGENVALUES WHENEVER POSSIBLE.                                    M29.4499
  //C                                                                       M29.4500
  //C     ON INPUT:                                                         M29.4501
  //C                                                                       M29.4502
  //C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL         M29.4503
  //C          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM          M29.4504
  //C          DIMENSION STATEMENT;                                         M29.4505
  //C                                                                       M29.4506
  //C        N IS THE ORDER OF THE MATRIX;                                  M29.4507
  //C                                                                       M29.4508
  //C        AR AND AI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.4509
  //C          RESPECTIVELY, OF THE COMPLEX MATRIX TO BE BALANCED.          M29.4510
  //C                                                                       M29.4511
  //C     ON OUTPUT:                                                        M29.4512
  //C                                                                       M29.4513
  //C        AR AND AI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.4514
  //C          RESPECTIVELY, OF THE BALANCED MATRIX;                        M29.4515
  //C                                                                       M29.4516
  //C        LOW AND IGH ARE TWO INTEGERS SUCH THAT AR(I,J) AND AI(I,J)     M29.4517
  //C          ARE EQUAL TO ZERO IF                                         M29.4518
  //C           (1) I IS GREATER THAN J AND                                 M29.4519
  //C           (2) J=1,...,LOW-1 OR I=IGH+1,...,N;                         M29.4520
  //C                                                                       M29.4521
  //C        SCALE CONTAINS INFORMATION DETERMINING THE                     M29.4522
  //C           PERMUTATIONS AND SCALING FACTORS USED.                      M29.4523
  //C                                                                       M29.4524
  //C     SUPPOSE THAT THE PRINCIPAL SUBMATRIX IN ROWS LOW THROUGH IGH      M29.4525
  //C     HAS BEEN BALANCED, THAT P(J) DENOTES THE INDEX INTERCHANGED       M29.4526
  //C     WITH J DURING THE PERMUTATION STEP, AND THAT THE ELEMENTS         M29.4527
  //C     OF THE DIAGONAL MATRIX USED ARE DENOTED BY D(I,J).  THEN          M29.4528
  //C        SCALE(J) = P(J),    FOR J = 1,...,LOW-1                        M29.4529
  //C                 = D(J,J)       J = LOW,...,IGH                        M29.4530
  //C                 = P(J)         J = IGH+1,...,N.                       M29.4531
  //C     THE ORDER IN WHICH THE INTERCHANGES ARE MADE IS N TO IGH+1,       M29.4532
  //C     THEN 1 TO LOW-1.                                                  M29.4533
  //C                                                                       M29.4534
  //C     NOTE THAT 1 IS RETURNED FOR IGH IF IGH IS ZERO FORMALLY.          M29.4535
  //C                                                                       M29.4536
  //C     THE ALGOL PROCEDURE EXC CONTAINED IN CBALANCE APPEARS IN          M29.4537
  //C     CBAL  IN LINE.  (NOTE THAT THE ALGOL ROLES OF IDENTIFIERS         M29.4538
  //C     K,L HAVE BEEN REVERSED.)                                          M29.4539
  //C                                                                       M29.4540
  //C     ARITHMETIC IS REAL THROUGHOUT.                                    M29.4541
  //C                                                                       M29.4542
  //C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,        M29.4543
  //C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY         M29.4544
  //C                                                                       M29.4545
  //C     ------------------------------------------------------------------M29.4546
  //C                                                                       M29.4547
  //C     :::::::::: RADIX IS A MACHINE DEPENDENT PARAMETER SPECIFYING      M29.4548
  //C                THE BASE OF THE MACHINE FLOATING POINT REPRESENTATION. M29.4549
  //C                RADIX = 16.0D0 FOR LONG FORM ARITHMETIC                M29.4550
  //C                ON S360 ::::::::::                                     M29.4551
  //C     DATA RADIX/Z4210000000000000/                                     M29.4552
  //C                                                                       M29.4553
  //C     &&&&&&&&&&&&&&&   TEMPORARY PATCH FOR F4V VAX COMPILER:           M29.4554
  radix = 16.0e0;
  //C     DATA STATEMENT JUST ABOVE IS DISABLED (ERROR FOR F4V). &&&        M29.4556
  //C     &&&&&&&&&&&&&&&&&&&&&&&&&&&&  END TEMPORARY PATCH.  23 JAN        M29.4557
  b2 = radix * radix;
  k = 1;
  L = n;
  goto statement_100;
  //C     :::::::::: IN-LINE PROCEDURE FOR ROW AND                          M29.4562
  //C                COLUMN EXCHANGE ::::::::::                             M29.4563
  statement_20:
  scale(m) = j;
  if (j == m) {
    goto statement_50;
  }
  FEM_DO_SAFE(i, 1, L) {
    f = ar(i, j);
    ar(i, j) = ar(i, m);
    ar(i, m) = f;
    f = ai(i, j);
    ai(i, j) = ai(i, m);
    ai(i, m) = f;
  }
  FEM_DO_SAFE(i, k, n) {
    f = ar(j, i);
    ar(j, i) = ar(m, i);
    ar(m, i) = f;
    f = ai(j, i);
    ai(j, i) = ai(m, i);
    ai(m, i) = f;
  }
  statement_50:
  switch (iexc) {
    case 1: goto statement_80;
    case 2: goto statement_130;
    default: break;
  }
  //C     :::::::::: SEARCH FOR ROWS ISOLATING AN EIGENVALUE                M29.4583
  //C                AND PUSH THEM DOWN ::::::::::                          M29.4584
  statement_80:
  if (L == 1) {
    goto statement_280;
  }
  L = L - 1;
  //C     :::::::::: FOR J=L STEP -1 UNTIL 1 DO -- ::::::::::               M29.4587
  statement_100:
  FEM_DO_SAFE(jj, 1, L) {
    j = L + 1 - jj;
    FEM_DO_SAFE(i, 1, L) {
      if (i == j) {
        goto statement_110;
      }
      if (ar(j, i) != 0.0f || ai(j, i) != 0.0f) {
        goto statement_120;
      }
      statement_110:;
    }
    m = L;
    iexc = 1;
    goto statement_20;
    statement_120:;
  }
  goto statement_140;
  //C     :::::::::: SEARCH FOR COLUMNS ISOLATING AN EIGENVALUE             M29.4599
  //C                AND PUSH THEM LEFT ::::::::::                          M29.4600
  statement_130:
  k++;
  statement_140:
  FEM_DO_SAFE(j, k, L) {
    FEM_DO_SAFE(i, k, L) {
      if (i == j) {
        goto statement_150;
      }
      if (ar(i, j) != 0.0f || ai(i, j) != 0.0f) {
        goto statement_170;
      }
      statement_150:;
    }
    m = k;
    iexc = 2;
    goto statement_20;
    statement_170:;
  }
  //C     :::::::::: NOW BALANCE THE SUBMATRIX IN ROWS K TO L ::::::::::    M29.4611
  FEM_DO_SAFE(i, k, L) {
    scale(i) = 1.0f;
  }
  //C     :::::::::: ITERATIVE LOOP FOR NORM REDUCTION ::::::::::           M29.4614
  statement_190:
  noconv = 0;
  FEM_DO_SAFE(i, k, L) {
    c = 0.0f;
    r = 0.0f;
    FEM_DO_SAFE(j, k, L) {
      if (j == i) {
        goto statement_200;
      }
      c += std::abs(ar(j, i)) + std::abs(ai(j, i));
      r += std::abs(ar(i, j)) + std::abs(ai(i, j));
      statement_200:;
    }
    //C     :::::::::: GUARD AGAINST ZERO C OR R DUE TO UNDERFLOW ::::::::::  M29.4624
    if (c == 0.0f || r == 0.0f) {
      goto statement_270;
    }
    g = r / radix;
    f = 1.0f;
    s = c + r;
    statement_210:
    if (c >= g) {
      goto statement_220;
    }
    f = f * radix;
    c = c * b2;
    goto statement_210;
    statement_220:
    g = r * radix;
    statement_230:
    if (c < g) {
      goto statement_240;
    }
    f = f / radix;
    c = c / b2;
    goto statement_230;
    //C     :::::::::: NOW BALANCE ::::::::::                                 M29.4638
    statement_240:
    c1 = 0.95f;
    if ((c + r) / f >= c1 * s) {
      goto statement_270;
    }
    g = 1.0f / f;
    scale(i) = scale(i) * f;
    noconv = 1;
    FEM_DO_SAFE(j, k, n) {
      ar(i, j) = ar(i, j) * g;
      ai(i, j) = ai(i, j) * g;
    }
    FEM_DO_SAFE(j, 1, L) {
      ar(j, i) = ar(j, i) * f;
      ai(j, i) = ai(j, i) * f;
    }
    statement_270:;
  }
  if (noconv == 1) {
    goto statement_190;
  }
  statement_280:
  low = k;
  igh = L;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
cbabk2(
  int const& /* nm */,
  int const& n,
  int const& low,
  int const& igh,
  arr_cref<double> scale,
  int const& m,
  arr_ref<double, 2> zr,
  arr_ref<double, 2> zi,
  int const& ndim) try
{
  scale(dimension(20));
  zr(dimension(ndim, ndim));
  zi(dimension(ndim, ndim));
  int i = fem::int0;
  double s = fem::double0;
  int j = fem::int0;
  int ii = fem::int0;
  int k = fem::int0;
  //C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE           M29.4660
  //C     CBABK2, WHICH IS A COMPLEX VERSION OF BALBAK,                     M29.4661
  //C     NUM. MATH. 13, 293-304(1969) BY PARLETT AND REINSCH.              M29.4662
  //C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 315-326(1971).   M29.4663
  //C                                                                       M29.4664
  //C     THIS SUBROUTINE FORMS THE EIGENVECTORS OF A COMPLEX GENERAL       M29.4665
  //C     MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING            M29.4666
  //C     BALANCED MATRIX DETERMINED BY  CBAL.                              M29.4667
  //C                                                                       M29.4668
  //C     ON INPUT:                                                         M29.4669
  //C                                                                       M29.4670
  //C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL         M29.4671
  //C          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM          M29.4672
  //C          DIMENSION STATEMENT;                                         M29.4673
  //C                                                                       M29.4674
  //C        N IS THE ORDER OF THE MATRIX;                                  M29.4675
  //C                                                                       M29.4676
  //C        LOW AND IGH ARE INTEGERS DETERMINED BY  CBAL;                  M29.4677
  //C                                                                       M29.4678
  //C        SCALE CONTAINS INFORMATION DETERMINING THE PERMUTATIONS        M29.4679
  //C          AND SCALING FACTORS USED BY  CBAL;                           M29.4680
  //C                                                                       M29.4681
  //C        M IS THE NUMBER OF EIGENVECTORS TO BE BACK TRANSFORMED;        M29.4682
  //C                                                                       M29.4683
  //C        ZR AND ZI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.4684
  //C          RESPECTIVELY, OF THE EIGENVECTORS TO BE                      M29.4685
  //C          BACK TRANSFORMED IN THEIR FIRST M COLUMNS.                   M29.4686
  //C                                                                       M29.4687
  //C     ON OUTPUT:                                                        M29.4688
  //C                                                                       M29.4689
  //C        ZR AND ZI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.4690
  //C          RESPECTIVELY, OF THE TRANSFORMED EIGENVECTORS                M29.4691
  //C          IN THEIR FIRST M COLUMNS.                                    M29.4692
  //C                                                                       M29.4693
  //C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,        M29.4694
  //C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY         M29.4695
  //C                                                                       M29.4696
  //C     ------------------------------------------------------------------M29.4697
  //C                                                                       M29.4698
  if (m == 0) {
    goto statement_200;
  }
  if (igh == low) {
    goto statement_120;
  }
  FEM_DO_SAFE(i, low, igh) {
    s = scale(i);
    //C     :::::::::: LEFT HAND EIGENVECTORS ARE BACK TRANSFORMED            M29.4703
    //C                IF THE FOREGOING STATEMENT IS REPLACED BY              M29.4704
    //C                S=1.0/SCALE(I). ::::::::::                             M29.4705
    FEM_DO_SAFE(j, 1, m) {
      zr(i, j) = zr(i, j) * s;
      zi(i, j) = zi(i, j) * s;
    }
  }
  //C     :::::::::: FOR I=LOW-1 STEP -1 UNTIL 1,                           M29.4711
  //C                IGH+1 STEP 1 UNTIL N DO -- ::::::::::                  M29.4712
  statement_120:
  FEM_DO_SAFE(ii, 1, n) {
    i = ii;
    if (i >= low && i <= igh) {
      goto statement_140;
    }
    if (i < low) {
      i = low - ii;
    }
    k = scale(i);
    if (k == i) {
      goto statement_140;
    }
    FEM_DO_SAFE(j, 1, m) {
      s = zr(i, j);
      zr(i, j) = zr(k, j);
      zr(k, j) = s;
      s = zi(i, j);
      zi(i, j) = zi(k, j);
      zi(k, j) = s;
    }
    statement_140:;
  }
  statement_200:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
comhes(
  common& cmn,
  int const& /* nm */,
  int const& n,
  int const& low,
  int const& igh,
  arr_ref<double, 2> ar,
  arr_ref<double, 2> ai,
  arr_ref<int> identifier_int,
  int const& lunit6,
  int const& iprsup,
  int const& ndim,
  arr_ref<int> iord) try
{
  ar(dimension(ndim, ndim));
  ai(dimension(ndim, ndim));
  // int(dimension(20));
  iord(dimension(20));
  common_write write(cmn);
  double epscmh = fem::double0;
  int i = fem::int0;
  int la = fem::int0;
  int kp1 = fem::int0;
  double d13 = fem::double0;
  int m = fem::int0;
  int mm1 = fem::int0;
  double xr = fem::double0;
  double xi = fem::double0;
  int j = fem::int0;
  int it = fem::int0;
  double yr = fem::double0;
  double yi = fem::double0;
  int mp1 = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  //C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE COMHES,   M29.4734
  //C     NUM. MATH. 12, 349-368(1968) BY MARTIN AND WILKINSON.             M29.4735
  //C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 339-358(1971).   M29.4736
  //C                                                                       M29.4737
  //C     GIVEN A COMPLEX GENERAL MATRIX, THIS SUBROUTINE                   M29.4738
  //C     REDUCES A SUBMATRIX SITUATED IN ROWS AND COLUMNS                  M29.4739
  //C     LOW THROUGH IGH TO UPPER HESSENBERG FORM BY                       M29.4740
  //C     STABILIZED ELEMENTARY SIMILARITY TRANSFORMATIONS.                 M29.4741
  //C                                                                       M29.4742
  //C     ON INPUT:                                                         M29.4743
  //C                                                                       M29.4744
  //C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL         M29.4745
  //C          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM          M29.4746
  //C          DIMENSION STATEMENT;                                         M29.4747
  //C                                                                       M29.4748
  //C        N IS THE ORDER OF THE MATRIX;                                  M29.4749
  //C                                                                       M29.4750
  //C        LOW AND IGH ARE INTEGERS DETERMINED BY THE BALANCING           M29.4751
  //C          SUBROUTINE  CBAL.  IF  CBAL  HAS NOT BEEN USED,              M29.4752
  //C          SET LOW=1, IGH=N;                                            M29.4753
  //C                                                                       M29.4754
  //C        AR AND AI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.4755
  //C          RESPECTIVELY, OF THE COMPLEX INPUT MATRIX.                   M29.4756
  //C                                                                       M29.4757
  //C     ON OUTPUT:                                                        M29.4758
  //C                                                                       M29.4759
  //C        AR AND AI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.4760
  //C          RESPECTIVELY, OF THE HESSENBERG MATRIX.  THE                 M29.4761
  //C          MULTIPLIERS WHICH WERE USED IN THE REDUCTION                 M29.4762
  //C          ARE STORED IN THE REMAINING TRIANGLES UNDER THE              M29.4763
  //C          HESSENBERG MATRIX;                                           M29.4764
  //C                                                                       M29.4765
  //C        INT CONTAINS INFORMATION ON THE ROWS AND COLUMNS               M29.4766
  //C          INTERCHANGED IN THE REDUCTION.                               M29.4767
  //C          ONLY ELEMENTS LOW THROUGH IGH ARE USED.                      M29.4768
  //C                                                                       M29.4769
  //C     ARITHMETIC IS REAL EXCEPT FOR THE REPLACEMENT OF THE ALGOL        M29.4770
  //C     PROCEDURE CDIV BY COMPLEX DIVISION USING SUBROUTINE CMPLXZ.       M29.4771
  //C                                                                       M29.4772
  //C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,        M29.4773
  //C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY         M29.4774
  //C                                                                       M29.4775
  //C     ------------------------------------------------------------------M29.4776
  //C                                                                       M29.4777
  //CCCC      FLZERO = 1.D-12       !REPLACED BY EPSCMH }                   M44.2307
  epscmh = 1.e-15f;
  FEM_DO_SAFE(i, 1, 20) {
    iord(i) = i;
  }
  la = igh - 1;
  kp1 = low + 1;
  if (iprsup >= 3) {
    write(lunit6,
      "(' AT THE TOP OF COMHES, IGH, LOW, LA AND KP1 ARE',4i10)"),
      igh, low, la, kp1;
  }
  d13 = epscmh;
  if (la < kp1) {
    goto statement_200;
  }
  FEM_DO_SAFE(m, kp1, la) {
    mm1 = m - 1;
    xr = 0.0f;
    xi = 0.0f;
    i = m;
    FEM_DO_SAFE(j, m, igh) {
      //CCCC            IF (ABSZ(AR(J,MM1)) + ABSZ(AI(J,MM1))                   M29.4790
      //CCCC     1         .LE. ABSZ(XR) + ABSZ(XI)) GO TO 100                  M29.4791
      if ((fem::pow2(ar(j, mm1))) + (fem::pow2(ai(j, mm1))) <= (xr *
          xr) + (xi * xi)) {
        goto statement_100;
      }
      xr = ar(j, mm1);
      xi = ai(j, mm1);
      i = j;
      statement_100:;
    }
    identifier_int(m) = i;
    if (i == m) {
      goto statement_130;
    }
    //C     :::::::::: INTERCHANGE ROWS AND COLUMNS OF AR AND AI ::::::::::   M29.4798
    it = iord(i);
    iord(i) = iord(m);
    iord(m) = it;
    FEM_DO_SAFE(j, mm1, n) {
      yr = ar(i, j);
      ar(i, j) = ar(m, j);
      ar(m, j) = yr;
      yi = ai(i, j);
      ai(i, j) = ai(m, j);
      ai(m, j) = yi;
    }
    FEM_DO_SAFE(j, 1, igh) {
      yr = ar(j, i);
      ar(j, i) = ar(j, m);
      ar(j, m) = yr;
      yi = ai(j, i);
      ai(j, i) = ai(j, m);
      ai(j, m) = yi;
    }
    //C     :::::::::: END INTERCHANGE ::::::::::                             M29.4815
    //C  130    IF (XR .LT. D13 .AND. XI .LT. D13)  GO TO 180                 M44.2318
    //CC  130    IF (ABSZ(XR) .LT. D13 .AND. ABSZ(XI) .LT. D13)  GO TO 180    M44.2319
    statement_130:
    if (xr == 0.0f && xi == 0.0f) {
      goto statement_180;
    }
    mp1 = m + 1;
    FEM_DO_SAFE(i, mp1, igh) {
      yr = ar(i, mm1);
      yi = ai(i, mm1);
      //C      IF (YR .LT. D13 .AND. YI .LT. D13) GO TO 160                     M44.2321
      //CC    IF (ABSZ(YR) .LT. D13 .AND. ABSZ(YI) .LT. D13) GO TO 160          M44.2322
      if (yr == 0.0f && yi == 0.0f) {
        goto statement_160;
      }
      d1 = xr * xr + xi * xi;
      d2 = (xr * yr + yi * xi) / d1;
      d3 = (xr * yi - xi * yr) / d1;
      yr = d2;
      yi = d3;
      ar(i, mm1) = yr;
      ai(i, mm1) = yi;
      FEM_DO_SAFE(j, m, n) {
        ar(i, j) = ar(i, j) - yr * ar(m, j) + yi * ai(m, j);
        ai(i, j) = ai(i, j) - yr * ai(m, j) - yi * ar(m, j);
      }
      FEM_DO_SAFE(j, 1, igh) {
        ar(j, m) += yr * ar(j, i) - yi * ai(j, i);
        ai(j, m) += yr * ai(j, i) + yi * ar(j, i);
      }
      statement_160:;
    }
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6,
          "(' M, IGH AND INT(M) AT 170 ARE',3i10,/,"
          "' (AR(J,M),AI(J,M),J=1,IGH), ARE',/(1x,8e15.6))");
        wloop, m, igh, identifier_int(m);
        FEM_DO_SAFE(j, 1, igh) {
          wloop, ar(j, m), ai(j, m);
        }
      }
    }
    statement_180:;
  }
  statement_200:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
comlr(
  common& cmn,
  int const& /* nm */,
  int const& n,
  int const& low,
  int const& igh,
  arr_ref<double, 2> hr,
  arr_ref<double, 2> hi,
  arr_ref<double> wr,
  arr_ref<double> wi,
  int& ierr,
  int const& ndim) try
{
  hr(dimension(ndim, ndim));
  hi(dimension(ndim, ndim));
  wr(dimension(ndim));
  wi(dimension(ndim));
  double& onehaf = cmn.onehaf;
  //
  double epmach = fem::double0;
  int i = fem::int0;
  int ien = fem::int0;
  double tr = fem::double0;
  double ti = fem::double0;
  int its = fem::int0;
  int ienm1 = fem::int0;
  int ll = fem::int0;
  int L = fem::int0;
  double sr = fem::double0;
  double si = fem::double0;
  double xr = fem::double0;
  double xi = fem::double0;
  double yr = fem::double0;
  double yi = fem::double0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  double zzr = fem::double0;
  double zzi = fem::double0;
  int mm = fem::int0;
  int m = fem::int0;
  int mp1 = fem::int0;
  int im1 = fem::int0;
  int j = fem::int0;
  //C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE COMLR,    M29.4848
  //C     NUM. MATH. 12, 369-376(1968) BY MARTIN AND WILKINSON.             M29.4849
  //C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 396-403(1971).   M29.4850
  //C                                                                       M29.4851
  //C     THIS SUBROUTINE FINDS THE EIGENVALUES OF A COMPLEX                M29.4852
  //C     UPPER HESSENBERG MATRIX BY THE MODIFIED LR METHOD.                M29.4853
  //C                                                                       M29.4854
  //C     ON INPUT:                                                         M29.4855
  //C                                                                       M29.4856
  //C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL         M29.4857
  //C          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM          M29.4858
  //C          DIMENSION STATEMENT;                                         M29.4859
  //C                                                                       M29.4860
  //C        N IS THE ORDER OF THE MATRIX;                                  M29.4861
  //C                                                                       M29.4862
  //C        LOW AND IGH ARE INTEGERS DETERMINED BY THE BALANCING           M29.4863
  //C          SUBROUTINE  CBAL.  IF  CBAL  HAS NOT BEEN USED,              M29.4864
  //C          SET LOW=1, IGH=N;                                            M29.4865
  //C                                                                       M29.4866
  //C        HR AND HI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.4867
  //C          RESPECTIVELY, OF THE COMPLEX UPPER HESSENBERG MATRIX.        M29.4868
  //C          THEIR LOWER TRIANGLES BELOW THE SUBDIAGONAL CONTAIN THE      M29.4869
  //C          MULTIPLIERS WHICH WERE USED IN THE REDUCTION BY  COMHES,     M29.4870
  //C          IF PERFORMED.                                                M29.4871
  //C                                                                       M29.4872
  //C     ON OUTPUT:                                                        M29.4873
  //C                                                                       M29.4874
  //C        THE UPPER HESSENBERG PORTIONS OF HR AND HI HAVE BEEN           M29.4875
  //C          DESTROYED.  THEREFORE, THEY MUST BE SAVED BEFORE             M29.4876
  //C          CALLING  COMLR  IF SUBSEQUENT CALCULATION OF                 M29.4877
  //C          EIGENVECTORS IS TO BE PERFORMED;                             M29.4878
  //C                                                                       M29.4879
  //C        WR AND WI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.4880
  //C          RESPECTIVELY, OF THE EIGENVALUES.  IF AN ERROR               M29.4881
  //C          EXIT IS MADE, THE EIGENVALUES SHOULD BE CORRECT              M29.4882
  //C          FOR INDICES IERR+1,...,N;                                    M29.4883
  //C                                                                       M29.4884
  //C        IERR IS SET TO                                                 M29.4885
  //C          ZERO       FOR NORMAL RETURN,                                M29.4886
  //C          J          IF THE J-TH EIGENVALUE HAS NOT BEEN               M29.4887
  //C                     DETERMINED AFTER 30 ITERATIONS.                   M29.4888
  //C                                                                       M29.4889
  //C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,        M29.4894
  //C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY         M29.4895
  //C                                                                       M29.4896
  //C     ------------------------------------------------------------------M29.4897
  //C                                                                       M29.4898
  //C     :::::::::: EPMACH IS A MACHINE DEPENDENT PARAMETER SPECIFYING     M29.4899
  //C                THE RELATIVE PRECISION OF FLOATING POINT ARITHMETIC.   M29.4900
  //C                EPMACH = 16.0D0**(-13) FOR LONG FORM ARITHMETIC        M29.4901
  //C                ON S360 ::::::::::                                     M29.4902
  //C     DATA EPMACH/Z3410000000000000/                                    M29.4903
  //C     EPMACH WILL BE SET TO EQUAL TO THE SYSTEM DEPENDENT FLOATING      M29.4904
  //C     POINT ZERO VARIABLE  "FLZERO"                                     M29.4905
  epmach = cmn.flzero;
  ierr = 0;
  //C     :::::::::: STORE ROOTS ISOLATED BY CBAL ::::::::::                M29.4908
  FEM_DO_SAFE(i, 1, n) {
    if (i >= low && i <= igh) {
      goto statement_200;
    }
    wr(i) = hr(i, i);
    wi(i) = hi(i, i);
    statement_200:;
  }
  ien = igh;
  tr = 0.0f;
  ti = 0.0f;
  //C     :::::::::: SEARCH FOR NEXT EIGENVALUE ::::::::::                  M29.4917
  statement_220:
  if (ien < low) {
    goto statement_1001;
  }
  its = 0;
  ienm1 = ien - 1;
  //C     :::::::::: LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT             M29.4921
  //C                FOR L=IEN STEP -1 UNTIL LOW D0 -- ::::::::::           M29.4922
  statement_240:
  FEM_DO_SAFE(ll, low, ien) {
    L = ien + low - ll;
    if (L == low) {
      goto statement_300;
    }
    if (std::abs(hr(L, L - 1)) + std::abs(hi(L, L - 1)) <= epmach * (std::abs(hr(L - 1,
        L - 1)) + std::abs(hi(L - 1, L - 1)) + std::abs(hr(L, L)) + std::abs(hi(L,
        L)))) {
      goto statement_300;
    }
  }
  //C     :::::::::: FORM SHIFT ::::::::::                                  M29.4930
  statement_300:
  if (L == ien) {
    goto statement_660;
  }
  if (its == 30) {
    goto statement_1000;
  }
  if (its == 10 || its == 20) {
    goto statement_320;
  }
  sr = hr(ien, ien);
  si = hi(ien, ien);
  xr = hr(ienm1, ien) * hr(ien, ienm1) - hi(ienm1, ien) * hi(ien, ienm1);
  xi = hr(ienm1, ien) * hi(ien, ienm1) + hi(ienm1, ien) * hr(ien, ienm1);
  if (xr == 0.0f && xi == 0.0f) {
    goto statement_340;
  }
  yr = (hr(ienm1, ienm1) - sr) * onehaf;
  yi = (hi(ienm1, ienm1) - si) * onehaf;
  d1 = fem::pow2(yr) - fem::pow2(yi) + xr;
  d2 = 2.0f * yr * yi + xi;
  d3 = sqrtz(fem::pow2(d1) + fem::pow2(d2));
  d3 = sqrtz(d3);
  d4 = onehaf * std::atan2(d2, d1);
  zzr = d3 * cosz(d4);
  zzi = d3 * sinz(d4);
  if (yr * zzr + yi * zzi >= 0.0f) {
    goto statement_310;
  }
  zzr = -zzr;
  zzi = -zzi;
  statement_310:
  d1 = fem::pow2((yr + zzr)) + fem::pow2((yi + zzi));
  d2 = (xr * (yr + zzr) + xi * (yi + zzi)) / d1;
  d3 = (xi * (yr + zzr) - xr * (yi + zzi)) / d1;
  sr = sr - d2;
  si = si - d3;
  goto statement_340;
  //C     :::::::::: FORM EXCEPTIONAL SHIFT ::::::::::                      M29.4951
  statement_320:
  sr = std::abs(hr(ien, ienm1)) + std::abs(hr(ienm1, ien - 2));
  si = std::abs(hi(ien, ienm1)) + std::abs(hi(ienm1, ien - 2));
  statement_340:
  FEM_DO_SAFE(i, low, ien) {
    hr(i, i) = hr(i, i) - sr;
    hi(i, i) = hi(i, i) - si;
  }
  tr += sr;
  ti += si;
  its++;
  //C     :::::::::: LOOK FOR TWO CONSECUTIVE SMALL                         M29.4961
  //C                SUB-DIAGONAL ELEMENTS ::::::::::                       M29.4962
  xr = std::abs(hr(ienm1, ienm1)) + std::abs(hi(ienm1, ienm1));
  yr = std::abs(hr(ien, ienm1)) + std::abs(hi(ien, ienm1));
  zzr = std::abs(hr(ien, ien)) + std::abs(hi(ien, ien));
  //C     :::::::::: FOR M=IEN-1 STEP -1 UNTIL L DO -- ::::::::::           M29.4966
  FEM_DO_SAFE(mm, L, ienm1) {
    m = ienm1 + L - mm;
    if (m == L) {
      goto statement_420;
    }
    yi = yr;
    yr = std::abs(hr(m, m - 1)) + std::abs(hi(m, m - 1));
    xi = zzr;
    zzr = xr;
    xr = std::abs(hr(m - 1, m - 1)) + std::abs(hi(m - 1, m - 1));
    if (yr <= epmach * zzr / yi * (zzr + xr + xi)) {
      goto statement_420;
    }
  }
  //C     :::::::::: TRIANGULAR DECOMPOSITION H=L*R ::::::::::              M29.4977
  statement_420:
  mp1 = m + 1;
  FEM_DO_SAFE(i, mp1, ien) {
    im1 = i - 1;
    xr = hr(im1, im1);
    xi = hi(im1, im1);
    yr = hr(i, im1);
    yi = hi(i, im1);
    if (std::abs(xr) + std::abs(xi) >= std::abs(yr) + std::abs(yi)) {
      goto statement_460;
    }
    //C     :::::::::: INTERCHANGE ROWS OF HR AND HI ::::::::::               M29.4986
    FEM_DO_SAFE(j, im1, ien) {
      zzr = hr(im1, j);
      hr(im1, j) = hr(i, j);
      hr(i, j) = zzr;
      zzi = hi(im1, j);
      hi(im1, j) = hi(i, j);
      hi(i, j) = zzi;
    }
    d1 = fem::pow2(yr) + fem::pow2(yi);
    d2 = (xr * yr + xi * yi) / d1;
    d3 = (yr * xi - xr * yi) / d1;
    wr(i) = 1.0f;
    goto statement_480;
    statement_460:
    d1 = fem::pow2(xr) + fem::pow2(xi);
    d2 = (yr * xr + yi * xi) / d1;
    d3 = (xr * yi - yr * xi) / d1;
    wr(i) = -1.0f;
    statement_480:
    zzr = d2;
    zzi = d3;
    hr(i, im1) = zzr;
    hi(i, im1) = zzi;
    FEM_DO_SAFE(j, i, ien) {
      hr(i, j) = hr(i, j) - zzr * hr(im1, j) + zzi * hi(im1, j);
      hi(i, j) = hi(i, j) - zzr * hi(im1, j) - zzi * hr(im1, j);
    }
  }
  //C     :::::::::: COMPOSITION R*L=H ::::::::::                           M29.5009
  FEM_DO_SAFE(j, mp1, ien) {
    xr = hr(j, j - 1);
    xi = hi(j, j - 1);
    hr(j, j - 1) = 0.0f;
    hi(j, j - 1) = 0.0f;
    //C     :::::::::: INTERCHANGE COLUMNS OF HR AND HI,                      M29.5015
    //C                IF NECESSARY ::::::::::                                M29.5016
    if (wr(j) <= 0.0f) {
      goto statement_580;
    }
    FEM_DO_SAFE(i, L, j) {
      zzr = hr(i, j - 1);
      hr(i, j - 1) = hr(i, j);
      hr(i, j) = zzr;
      zzi = hi(i, j - 1);
      hi(i, j - 1) = hi(i, j);
      hi(i, j) = zzi;
    }
    statement_580:
    FEM_DO_SAFE(i, L, j) {
      hr(i, j - 1) += xr * hr(i, j) - xi * hi(i, j);
      hi(i, j - 1) += xr * hi(i, j) + xi * hr(i, j);
    }
  }
  goto statement_240;
  //C     :::::::::: A ROOT FOUND ::::::::::                                M29.5032
  statement_660:
  wr(ien) = hr(ien, ien) + tr;
  wi(ien) = hi(ien, ien) + ti;
  ien = ienm1;
  goto statement_220;
  //C     :::::::::: SET ERROR -- NO CONVERGENCE TO AN                      M29.5037
  //C                EIGENVALUE AFTER 30 ITERATIONS ::::::::::              M29.5038
  statement_1000:
  ierr = ien;
  statement_1001:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
comlr2(
  common& cmn,
  int const& /* nm */,
  int const& n,
  int const& low,
  int const& igh,
  arr_cref<int> identifier_int,
  arr_ref<double, 2> hr,
  arr_ref<double, 2> hi,
  arr_ref<double, 2> zi,
  arr_ref<double, 2> zr,
  arr_ref<double> wr,
  arr_ref<double> wi,
  int& ierr,
  int const& ndim,
  arr_ref<int> iord) try
{
  // int(dimension(20));
  hr(dimension(ndim, ndim));
  hi(dimension(ndim, ndim));
  zi(dimension(ndim, ndim));
  zr(dimension(ndim, ndim));
  wr(dimension(ndim));
  wi(dimension(ndim));
  iord(dimension(20));
  common_write write(cmn);
  double& t = cmn.t;
  double& onehaf = cmn.onehaf;
  int& iprsup = cmn.iprsup;
  //
  double epmach = fem::double0;
  int itsmax = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  int iend = fem::int0;
  int ii = fem::int0;
  int ip1 = fem::int0;
  int k = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int ien = fem::int0;
  double tr = fem::double0;
  double ti = fem::double0;
  int its = fem::int0;
  int ienm1 = fem::int0;
  int ll = fem::int0;
  int L = fem::int0;
  double sr = fem::double0;
  double si = fem::double0;
  double xr = fem::double0;
  double xi = fem::double0;
  double yr = fem::double0;
  double yi = fem::double0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  double zzr = fem::double0;
  double zzi = fem::double0;
  int mm = fem::int0;
  int m = fem::int0;
  int mp1 = fem::int0;
  int im1 = fem::int0;
  int ittemp = fem::int0;
  int id = fem::int0;
  arr_1d<20, double> umr(fem::fill0);
  arr_1d<20, double> umi(fem::fill0);
  double fnorm = fem::double0;
  int nn = fem::int0;
  int jj = fem::int0;
  arr_1d<20, int> lseq(fem::fill0);
  arr_1d<20, double> vtr(fem::fill0);
  arr_1d<20, double> vti(fem::fill0);
  arr<double, 2> ppr(dimension(20, 20), fem::fill0);
  arr<double, 2> ppi(dimension(20, 20), fem::fill0);
  arr_1d<20, double> eim(fem::fill0);
  //C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE COMLR2,   M29.5049
  //C     NUM. MATH. 16, 181-204(1970) BY PETERS AND WILKINSON.             M29.5050
  //C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 372-395(1971).   M29.5051
  //C                                                                       M29.5052
  //C     THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS            M29.5053
  //C     OF A COMPLEX UPPER HESSENBERG MATRIX BY THE MODIFIED LR           M29.5054
  //C     METHOD.  THE EIGENVECTORS OF A COMPLEX GENERAL MATRIX             M29.5055
  //C     CAN ALSO BE FOUND IF  COMHES  HAS BEEN USED TO REDUCE             M29.5056
  //C     THIS GENERAL MATRIX TO HESSENBERG FORM.                           M29.5057
  //C                                                                       M29.5058
  //C     ON INPUT:                                                         M29.5059
  //C                                                                       M29.5060
  //C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL         M29.5061
  //C          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM          M29.5062
  //C          DIMENSION STATEMENT;                                         M29.5063
  //C                                                                       M29.5064
  //C        N IS THE ORDER OF THE MATRIX;                                  M29.5065
  //C                                                                       M29.5066
  //C        LOW AND IGH ARE INTEGERS DETERMINED BY THE BALANCING           M29.5067
  //C          SUBROUTINE  CBAL.  IF  CBAL  HAS NOT BEEN USED,              M29.5068
  //C          SET LOW=1, IGH=N;                                            M29.5069
  //C                                                                       M29.5070
  //C        INT CONTAINS INFORMATION ON THE ROWS AND COLUMNS INTERCHANGED  M29.5071
  //C          IN THE REDUCTION BY  COMHES, IF PERFORMED.  ONLY ELEMENTS    M29.5072
  //C          LOW THROUGH IGH ARE USED.  IF THE EIGENVECTORS OF THE HESSEN-M29.5073
  //C          BERG MATRIX ARE DESIRED, SET INT(J)=J FOR THESE ELEMENTS;    M29.5074
  //C                                                                       M29.5075
  //C        HR AND HI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.5076
  //C          RESPECTIVELY, OF THE COMPLEX UPPER HESSENBERG MATRIX.        M29.5077
  //C          THEIR LOWER TRIANGLES BELOW THE SUBDIAGONAL CONTAIN THE      M29.5078
  //C          MULTIPLIERS WHICH WERE USED IN THE REDUCTION BY  COMHES,     M29.5079
  //C          IF PERFORMED.  IF THE EIGENVECTORS OF THE HESSENBERG         M29.5080
  //C          MATRIX ARE DESIRED, THESE ELEMENTS MUST BE SET TO ZERO.      M29.5081
  //C                                                                       M29.5082
  //C     ON OUTPUT:                                                        M29.5083
  //C                                                                       M29.5084
  //C        THE UPPER HESSENBERG PORTIONS OF HR AND HI HAVE BEEN           M29.5085
  //C          DESTROYED, BUT THE LOCATION HR(1,1) CONTAINS THE FNORM       M29.5086
  //C          OF THE TRIANGULARIZED MATRIX;                                M29.5087
  //C                                                                       M29.5088
  //C        WR AND WI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.5089
  //C          RESPECTIVELY, OF THE EIGENVALUES.  IF AN ERROR               M29.5090
  //C          EXIT IS MADE, THE EIGENVALUES SHOULD BE CORRECT              M29.5091
  //C          FOR INDICES IERR+1,...,N;                                    M29.5092
  //C                                                                       M29.5093
  //C        ZR AND ZI CONTAIN THE REAL AND IMAGINARY PARTS,                M29.5094
  //C          RESPECTIVELY, OF THE EIGENVECTORS.  THE EIGENVECTORS         M29.5095
  //C          ARE UNNORMALIZED.  IF AN ERROR EXIT IS MADE, NONE OF         M29.5096
  //C          THE EIGENVECTORS HAS BEEN FOUND;                             M29.5097
  //C                                                                       M29.5098
  //C        IERR IS SET TO                                                 M29.5099
  //C          ZERO       FOR NORMAL RETURN,                                M29.5100
  //C          J          IF THE J-TH EIGENVALUE HAS NOT BEEN               M29.5101
  //C                     DETERMINED AFTER 30 ITERATIONS.                   M29.5102
  //C                                                                       M29.5103
  //C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,        M29.5108
  //C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY         M29.5109
  //C                                                                       M29.5110
  //C     ------------------------------------------------------------------M29.5111
  //C                                                                       M29.5112
  //C     :::::::::: EPMACH IS A MACHINE DEPENDENT PARAMETER SPECIFYING     M29.5113
  //C                THE RELATIVE PRECISION OF FLOATING POINT ARITHMETIC.   M29.5114
  //C                EPMACH = 16.0D0**(-13) FOR LONG FORM ARITHMETIC        M29.5115
  //C                ON S360 ::::::::::                                     M29.5116
  //C     DATA EPMACH/Z3410000000000000/                                    M29.5117
  //C     LIKE IN SUBROUTINE COMLR, EPMACH IS SET TO BE FLZERO              M29.5118
  //CCCC      EPMACH = 1.0E-50      ! NOW IN CHOICE.DAT }                   M43.3951
  epmach = 1.e-32f;
  itsmax = 300;
  ierr = 0;
  //C     :::::::::: INITIALIZE EIGENVECTOR MATRIX ::::::::::               M29.5121
  FEM_DO_SAFE(i, 1, n) {
    FEM_DO_SAFE(j, 1, n) {
      zr(i, j) = 0.0f;
      zi(i, j) = 0.0f;
      if (i == j) {
        zr(i, j) = 1.0f;
      }
    }
  }
  //C     :::::::::: FORM THE MATRIX OF ACCUMULATED TRANSFORMATIONS         M29.5128
  //C                FROM THE INFORMATION LEFT BY COMHES ::::::::::         M29.5129
  iend = igh - low - 1;
  if (iend <= 0) {
    goto statement_180;
  }
  //C     :::::::::: FOR I=IGH-1 STEP -1 UNTIL LOW+1 DO -- ::::::::::       M29.5132
  FEM_DO_SAFE(ii, 1, iend) {
    i = igh - ii;
    ip1 = i + 1;
    FEM_DO_SAFE(k, ip1, igh) {
      zr(k, i) = hr(k, i - 1);
      zi(k, i) = hi(k, i - 1);
    }
    j = identifier_int(i);
    if (i == j) {
      goto statement_160;
    }
    FEM_DO_SAFE(k, i, igh) {
      zr(i, k) = zr(j, k);
      zi(i, k) = zi(j, k);
      zr(j, k) = 0.0f;
      zi(j, k) = 0.0f;
    }
    zr(j, i) = 1.0f;
    statement_160:;
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(' AFTER DO 160 LOOP IN COMLR2, ((ZR(I,J),ZI(I,J),J=1,IGH),I=1,IGH) A"
        "RE',/(1x,8e15.6))");
      FEM_DO_SAFE(i, 1, igh) {
        FEM_DO_SAFE(j, 1, igh) {
          wloop, zr(i, j), zi(i, j);
        }
      }
    }
  }
  //C     :::::::::: STORE ROOTS ISOLATED BY CBAL ::::::::::                M29.5154
  statement_180:
  FEM_DO_SAFE(i, 1, n) {
    if (i >= low && i <= igh) {
      goto statement_200;
    }
    wr(i) = hr(i, i);
    wi(i) = hi(i, i);
    statement_200:;
  }
  ien = igh;
  tr = 0.0f;
  ti = 0.0f;
  //C     :::::::::: SEARCH FOR NEXT EIGENVALUE ::::::::::                  M29.5163
  statement_220:
  if (ien < low) {
    goto statement_680;
  }
  its = 0;
  ienm1 = ien - 1;
  //C     :::::::::: LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT             M29.5167
  //C                FOR L=IEN STEP -1 UNTIL LOW DO -- ::::::::::           M29.5168
  statement_240:
  FEM_DO_SAFE(ll, low, ien) {
    L = ien + low - ll;
    if (L == low) {
      goto statement_300;
    }
    if (std::abs(hr(L, L - 1)) + std::abs(hi(L, L - 1)) <= epmach * (std::abs(hr(L - 1,
        L - 1)) + std::abs(hi(L - 1, L - 1)) + std::abs(hr(L, L)) + std::abs(hi(L,
        L)))) {
      goto statement_300;
    }
  }
  //C     :::::::::: FORM SHIFT ::::::::::                                  M29.5176
  statement_300:
  if (L == ien) {
    goto statement_660;
  }
  if (its == itsmax) {
    goto statement_1000;
  }
  //CCCC      IF ((ITS/10)*10 .EQ. ITS ) GO TO 320                          M43.3955
  //CCCCC     IF (ITS .EQ. 10 .OR. ITS .EQ. 20) GO TO 320                   M29.5179
  sr = hr(ien, ien);
  si = hi(ien, ien);
  xr = hr(ienm1, ien) * hr(ien, ienm1) - hi(ienm1, ien) * hi(ien, ienm1);
  xi = hr(ienm1, ien) * hi(ien, ienm1) + hi(ienm1, ien) * hr(ien, ienm1);
  if (iprsup >= 3) {
    write(lunit6, "(' SR, SI, XR AND XI AT 305 ARE',4e15.6)"), sr, si, xr, xi;
  }
  if (xr == 0.0f && xi == 0.0f) {
    goto statement_340;
  }
  yr = (hr(ienm1, ienm1) - sr) * onehaf;
  yi = (hi(ienm1, ienm1) - si) * onehaf;
  d1 = fem::pow2(yr) - fem::pow2(yi) + xr;
  d2 = 2.0f * yr * yi + xi;
  d3 = sqrtz(fem::pow2(d1) + fem::pow2(d2));
  d3 = sqrtz(d3);
  d4 = onehaf * std::atan2(d2, d1);
  zzr = d3 * cosz(d4);
  zzi = d3 * sinz(d4);
  if (yr * zzr + yi * zzi >= 0.0f) {
    goto statement_310;
  }
  zzr = -zzr;
  zzi = -zzi;
  statement_310:
  d1 = fem::pow2((yr + zzr)) + fem::pow2((yi + zzi));
  d2 = (xr * (yr + zzr) + xi * (yi + zzi)) / d1;
  d3 = (xi * (yr + zzr) - xr * (yi + zzi)) / d1;
  if (iprsup >= 3) {
    write(lunit6,
      "(' YR, YI, ZZR, ZZI AND D2,D3 AT 315 ARE',6e15.6)"), yr, yi,
      zzr, zzi, d2, d3;
  }
  sr = sr - d2;
  si = si - d3;
  goto statement_340;
  //C     :::::::::: FORM EXCEPTIONAL SHIFT ::::::::::                      M29.5203
  //CCCC  320 SR = ABSZ(HR(IEN,IENM1)) + ABSZ(HR(IENM1,IEN-2))              M29.5204
  //CCCC      SI = ABSZ(HI(IEN,IENM1)) + ABSZ(HI(IENM1,IEN-2))              M29.5205
  statement_340:
  FEM_DO_SAFE(i, low, ien) {
    hr(i, i) = hr(i, i) - sr;
    hi(i, i) = hi(i, i) - si;
    if (iprsup >= 3) {
      write(lunit6,
        "(' I, SR, SI, HR(I,I), AND HI(I,I) AT 350 ARE',/,10x,i8,4e15.6)"),
        i, sr, si, hr(i, i), hi(i, i);
    }
  }
  tr += sr;
  ti += si;
  its++;
  //C     :::::::::: LOOK FOR TWO CONSECUTIVE SMALL                         M29.5217
  //C                SUB-DIAGONAL ELEMENTS ::::::::::                       M29.5218
  xr = std::abs(hr(ienm1, ienm1)) + std::abs(hi(ienm1, ienm1));
  yr = std::abs(hr(ien, ienm1)) + std::abs(hi(ien, ienm1));
  zzr = std::abs(hr(ien, ien)) + std::abs(hi(ien, ien));
  if (iprsup >= 3) {
    write(lunit6, "(' XR, YR, AND ZZR AT 370 ARE',3e15.6)"), xr, yr, zzr;
  }
  //C     :::::::::: FOR M=IEN-1 STEP -1 UNTIL L DO -- ::::::::::           M29.5225
  FEM_DO_SAFE(mm, L, ienm1) {
    m = ienm1 + L - mm;
    if (m == L) {
      goto statement_420;
    }
    yi = yr;
    yr = std::abs(hr(m, m - 1)) + std::abs(hi(m, m - 1));
    xi = zzr;
    zzr = xr;
    xr = std::abs(hr(m - 1, m - 1)) + std::abs(hi(m - 1, m - 1));
    if (iprsup >= 3) {
      write(lunit6,
        "(' AT 375, MM, YR, ZZR, YI, XR, XI AND EPMACH ARE',/,10x,i8,6e15.6)"),
        mm, yr, zzr, yi, xr, xi, epmach;
    }
    if (yr <= epmach * zzr / yi * (zzr + xr + xi)) {
      goto statement_420;
    }
  }
  //C     :::::::::: TRIANGULAR DECOMPOSITION H=L*R ::::::::::              M29.5240
  statement_420:
  mp1 = m + 1;
  FEM_DO_SAFE(i, mp1, ien) {
    im1 = i - 1;
    xr = hr(im1, im1);
    xi = hi(im1, im1);
    yr = hr(i, im1);
    yi = hi(i, im1);
    if (std::abs(xr) + std::abs(xi) >= std::abs(yr) + std::abs(yi)) {
      goto statement_460;
    }
    //C     :::::::::: INTERCHANGE ROWS OF HR AND HI ::::::::::               M29.5249
    FEM_DO_SAFE(j, im1, n) {
      zzr = hr(im1, j);
      hr(im1, j) = hr(i, j);
      hr(i, j) = zzr;
      zzi = hi(im1, j);
      hi(im1, j) = hi(i, j);
      hi(i, j) = zzi;
    }
    //C     IT=IORD(I)                                                        M43.3956
    ittemp = iord(i);
    iord(i) = iord(im1);
    //C     IORD(IM1) = IT                                                    M43.3958
    iord(im1) = ittemp;
    d1 = fem::pow2(yr) + fem::pow2(yi);
    d2 = (xr * yr + xi * yi) / d1;
    d3 = (yr * xi - xr * yi) / d1;
    wr(i) = 1.0f;
    goto statement_480;
    statement_460:
    d1 = fem::pow2(xr) + fem::pow2(xi);
    d2 = (yr * xr + yi * xi) / d1;
    d3 = (xr * yi - yr * xi) / d1;
    wr(i) = -1.0f;
    statement_480:
    zzr = d2;
    zzi = d3;
    hr(i, im1) = zzr;
    hi(i, im1) = zzi;
    FEM_DO_SAFE(j, i, n) {
      hr(i, j) = hr(i, j) - zzr * hr(im1, j) + zzi * hi(im1, j);
      hi(i, j) = hi(i, j) - zzr * hi(im1, j) - zzi * hr(im1, j);
    }
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6,
          "(' AT 510, (HR(I,J), HI(I,J), J=1,N) FOR I =',i8,', AND N = ',i8,"
          "2x,'ARE',/(1x,8e15.6))");
        wloop, i, n;
        FEM_DO_SAFE(j, 1, n) {
          wloop, hr(i, j), hi(i, j);
        }
      }
    }
  }
  //C     :::::::::: COMPOSITION R*L=H ::::::::::                           M29.5276
  FEM_DO_SAFE(j, mp1, ien) {
    xr = hr(j, j - 1);
    xi = hi(j, j - 1);
    hr(j, j - 1) = 0.0f;
    hi(j, j - 1) = 0.0f;
    //C     :::::::::: INTERCHANGE COLUMNS OF HR, HI, ZR, AND ZI,             M29.5282
    //C                IF NECESSARY ::::::::::                                M29.5283
    if (wr(j) <= 0.0f) {
      goto statement_580;
    }
    FEM_DO_SAFE(i, 1, j) {
      zzr = hr(i, j - 1);
      hr(i, j - 1) = hr(i, j);
      hr(i, j) = zzr;
      zzi = hi(i, j - 1);
      hi(i, j - 1) = hi(i, j);
      hi(i, j) = zzi;
    }
    FEM_DO_SAFE(i, low, igh) {
      zzr = zr(i, j - 1);
      zr(i, j - 1) = zr(i, j);
      zr(i, j) = zzr;
      zzi = zi(i, j - 1);
      zi(i, j - 1) = zi(i, j);
      zi(i, j) = zzi;
    }
    statement_580:
    FEM_DO_SAFE(i, 1, j) {
      hr(i, j - 1) += xr * hr(i, j) - xi * hi(i, j);
      hi(i, j - 1) += xr * hi(i, j) + xi * hr(i, j);
    }
    //C     :::::::::: ACCUMULATE TRANSFORMATIONS ::::::::::                  M29.5305
    FEM_DO_SAFE(i, low, igh) {
      zr(i, j - 1) += xr * zr(i, j) - xi * zi(i, j);
      zi(i, j - 1) += xr * zi(i, j) + xi * zr(i, j);
    }
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6,
          "(' J, LOW AND IGH AT 630 ARE',3i8,"
          "' (HR(I,J),HI(I,J),I=1,J) AND (ZR(I,J),ZI(I,J),I=LOW,IGH) ARE',"
          "/(1x,8e15.6))");
        wloop, j, low, igh;
        FEM_DO_SAFE(i, 1, j) {
          wloop, hr(i, j), hi(i, j);
        }
        FEM_DO_SAFE(i, low, igh) {
          wloop, zr(i, j), zi(i, j);
        }
      }
    }
  }
  goto statement_240;
  //C     :::::::::: A ROOT FOUND ::::::::::                                M29.5317
  statement_660:
  hr(ien, ien) += tr;
  wr(ien) = hr(ien, ien);
  hi(ien, ien) += ti;
  wi(ien) = hi(ien, ien);
  ien = ienm1;
  if (iprsup >= 3) {
    write(lunit6,
      "('     IEN    HR(IEN,IEN)    HI(IEN,IEN)       WR(IEN)        WI(IEN)',"
      "/,i8,4e15.6)"),
      ien, hr(ien, ien), hi(ien, ien), wr(ien), wi(ien);
  }
  goto statement_220;
  statement_680:
  FEM_DO_SAFE(id, low, igh) {
    j = iord(id);
    umr(j) = wr(id);
    umi(j) = wi(id);
  }
  //C     :::::::::: ALL ROOTS FOUND.  BACKSUBSTITUTE TO FIND               M29.5328
  //C                VECTORS OF UPPER TRIANGULAR FORM ::::::::::            M29.5329
  fnorm = 0.0f;
  FEM_DO_SAFE(i, 1, n) {
    FEM_DO_SAFE(j, i, n) {
      fnorm += std::abs(hr(i, j)) + std::abs(hi(i, j));
    }
  }
  hr(1, 1) = fnorm;
  if (n == 1 || fnorm == 0.0f) {
    goto statement_1001;
  }
  //C     :::::::::: FOR IEN=N STEP -1 UNTIL 2 DO -- ::::::::::             M29.5337
  FEM_DO_SAFE(nn, 2, n) {
    ien = n + 2 - nn;
    xr = wr(ien);
    xi = wi(ien);
    ienm1 = ien - 1;
    //C     :::::::::: FOR I=IEN-1 STEP -1 UNTIL 1 DO -- ::::::::::           M29.5343
    FEM_DO_SAFE(ii, 1, ienm1) {
      i = ien - ii;
      zzr = hr(i, ien);
      zzi = hi(i, ien);
      if (i == ienm1) {
        goto statement_760;
      }
      ip1 = i + 1;
      FEM_DO_SAFE(j, ip1, ienm1) {
        zzr += hr(i, j) * hr(j, ien) - hi(i, j) * hi(j, ien);
        zzi += hr(i, j) * hi(j, ien) + hi(i, j) * hr(j, ien);
      }
      statement_760:
      yr = xr - wr(i);
      yi = xi - wi(i);
      if (yr == 0.0f && yi == 0.0f) {
        yr = epmach * fnorm;
      }
      d1 = fem::pow2(yr) + fem::pow2(yi);
      d2 = (zzr * yr + zzi * yi) / d1;
      d3 = (yr * zzi - yi * zzr) / d1;
      hr(i, ien) = d2;
      hi(i, ien) = d3;
      if (iprsup >= 3) {
        write(lunit6,
          "(' NN, N, IEN, II, I, IENM1, ZZR, ZZI, YR, YI, D2, D3, HR(I,IEN) AN"
          "D HI(I,IEN) AT 770 ARE',/,1x,6i5,8e12.5)"),
          nn, n, ien, ii, i, ienm1, zzr, zzi, yr, yi, d2, d3, hr(i,
          ien), hi(i, ien);
      }
    }
  }
  //C     :::::::::: END BACKSUBSTITUTION ::::::::::                        M29.5367
  ienm1 = n - 1;
  //C     :::::::::: VECTORS OF ISOLATED ROOTS ::::::::::                   M29.5369
  FEM_DO_SAFE(i, 1, ienm1) {
    if (i >= low && i <= igh) {
      goto statement_840;
    }
    ip1 = i + 1;
    FEM_DO_SAFE(j, ip1, n) {
      zr(i, j) = hr(i, j);
      zi(i, j) = hi(i, j);
    }
    statement_840:;
  }
  //C     :::::::::: MULTIPLY BY TRANSFORMATION MATRIX TO GIVE              M29.5378
  //C                VECTORS OF ORIGINAL FULL MATRIX.                       M29.5379
  //C                FOR J=N STEP -1 UNTIL LOW+1 DO -- ::::::::::           M29.5380
  FEM_DO_SAFE(jj, low, ienm1) {
    j = n + low - jj;
    //C        M = MIN0Z(J-1,IGH)                                             M36.3634
    m = j - 1;
    if (m > igh) {
      m = igh;
    }
    FEM_DO_SAFE(i, low, igh) {
      zzr = zr(i, j);
      zzi = zi(i, j);
      FEM_DO_SAFE(k, low, m) {
        zzr += zr(i, k) * hr(k, j) - zi(i, k) * hi(k, j);
        zzi += zr(i, k) * hi(k, j) + zi(i, k) * hr(k, j);
      }
      zr(i, j) = zzr;
      zi(i, j) = zzi;
      if (iprsup >= 3) {
        write(lunit6,
          "(' AT THE END OF DO 880 LOOP, JJ, J,  M, ZR(I,J) AND ZI(I,J) ARE',"
          "5x,3i8,2e15.6)"),
          jj, j, m, zr(i, j), zi(i, j);
      }
    }
  }
  goto statement_1001;
  //C     :::::::::: SET ERROR -- NO CONVERGENCE TO AN                      M29.5399
  //C                EIGENVALUE AFTER 30 ITERATIONS ::::::::::              M29.5400
  statement_1000:
  ierr = ien;
  statement_1001:
  //CCCC      DO 1002 I=LOW, IGH                                            M43.3967
  //CCCC      WR(I) = UMR(I)                                                M43.3968
  //CCCC      WI(I) = UMI(I)                                                M43.3969
  //CC     ** SORTING THE EIGENVALUES WITH MAGNITUDE **                     M43.3971
  //CC        ALSO REORDERING THE EIGENVECTOR                               M43.3972
  FEM_DO_SAFE(i, 1, 20) {
    lseq(i) = i;
  }
  FEM_DO_SAFE(i, 1, n) {
    vtr(i) = wr(i);
    vti(i) = wi(i);
    FEM_DO_SAFE(j, 1, n) {
      ppr(i, j) = zr(i, j);
      ppi(i, j) = zi(i, j);
    }
  }
  FEM_DO_SAFE(i, 1, n) {
    eim(i) = wr(i) * wr(i) + wi(i) * wi(i);
  }
  FEM_DO_SAFE(j, 1, n) {
    L = n - j;
    FEM_DO_SAFE(i, 1, L) {
      if (eim(i) >= eim(i + 1)) {
        goto statement_1007;
      }
      t = eim(i);
      eim(i) = eim(i + 1);
      eim(i + 1) = t;
      t = lseq(i);
      lseq(i) = lseq(i + 1);
      lseq(i + 1) = t;
      statement_1007:;
    }
  }
  FEM_DO_SAFE(i, 1, n) {
    wr(i) = vtr(lseq(i));
    wi(i) = vti(lseq(i));
    FEM_DO_SAFE(j, 1, n) {
      zr(i, j) = ppr(i, lseq(j));
      zi(i, j) = ppi(i, lseq(j));
    }
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
dceign(
  common& cmn,
  arr_ref<double, 2> ar,
  arr_ref<double, 2> ai,
  arr_ref<double, 2> vi,
  arr_ref<double, 2> vr,
  arr_ref<double> er,
  arr_ref<double> ei,
  int const& n,
  int const& nm,
  int& ierr,
  int const& nv,
  int const& nb,
  int const& lunit6,
  int const& iprsup,
  int const& ndim) try
{
  ar(dimension(ndim, ndim));
  ai(dimension(ndim, ndim));
  vi(dimension(ndim, ndim));
  vr(dimension(ndim, ndim));
  er(dimension(ndim));
  ei(dimension(ndim));
  common_write write(cmn);
  int i = fem::int0;
  int j = fem::int0;
  int low = fem::int0;
  int nupp = fem::int0;
  arr_1d<20, double> scale(fem::fill0);
  arr_1d<20, int> identifier_int(fem::fill0);
  arr_1d<20, int> iord(fem::fill0);
  if (iprsup >= 1) {
    write(6, star), " Top of DCEIGN.  Input matrix AR ....";
  }
  FEM_DO_SAFE(i, 1, n) {
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, 6, star);
        FEM_DO_SAFE(j, 1, n) {
          wloop, ar(i, j);
        }
      }
    }
  }
  if (iprsup >= 1) {
    write(6, star), "                 Input matrix AI ....";
  }
  FEM_DO_SAFE(i, 1, n) {
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, 6, star);
        FEM_DO_SAFE(j, 1, n) {
          wloop, ai(i, j);
        }
      }
    }
  }
  if (n > nm) {
    goto statement_90;
  }
  low = 1;
  nupp = n;
  if (nb == 0) {
    goto statement_1;
  }
  //C  DO BALANCING                                                         M29.4447
  cbal(nm, n, ar, ai, low, nupp, scale, ndim);
  //C  DO TRANSFORMATION TO UPPER HESSENBERG FORM                           M29.4449
  statement_1:
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(' BEFORE CALL COMHES, NM, N, LOW, NUPP, NB, NV ARE',6i5,/,"
        "' ((AR(I,J),AI(I,J),J=1,NM),I=1,NM) ARE',/(1x,8e15.6))");
      wloop, nm, n, low, nupp, nb, nv;
      FEM_DO_SAFE(i, 1, nm) {
        FEM_DO_SAFE(j, 1, nm) {
          wloop, ar(i, j), ai(i, j);
        }
      }
    }
  }
  comhes(cmn, nm, n, low, nupp, ar, ai, identifier_int, lunit6,
    iprsup, ndim, iord);
  if (nv == 0) {
    goto statement_12;
  }
  //C  CALCULATE VALUES AND VECTORS                                         M29.4458
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(' AFTER CALL COMHES, AR(I,J) AND AI(I,J) ARE',/(1x,8e15.6))");
      FEM_DO_SAFE(i, 1, nm) {
        FEM_DO_SAFE(j, 1, nm) {
          wloop, ar(i, j), ai(i, j);
        }
      }
    }
  }
  comlr2(cmn, nm, n, low, nupp, identifier_int, ar, ai, vi, vr, er,
    ei, ierr, ndim, iord);
  if (iprsup < 3) {
    goto statement_410;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(' AFTER CALL COMLR2 IN DCEIGN, THE EIGENVALUES ARE',/(1x,8e15.6),/)");
    FEM_DO_SAFE(i, 1, nm) {
      wloop, er(i), ei(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(' AND EIGENVECTORS ARE',/(1x,8e15.6))");
    FEM_DO_SAFE(i, 1, nm) {
      FEM_DO_SAFE(j, 1, nm) {
        wloop, vr(i, j), vi(i, j);
      }
    }
  }
  statement_410:
  if (ierr != 0) {
    goto statement_5;
  }
  //C  TRANSFORM VECTORS TO VECTORS OF ORIGINAL MATRIX                      M29.4470
  if (nb == 0) {
    return;
  }
  cbabk2(nm, n, low, nupp, scale, n, vi, vr, ndim);
  return;
  //C  CALCULATE VALUES ONLY                                                M29.4474
  statement_12:
  comlr(cmn, nm, n, low, nupp, ar, ai, er, ei, ierr, ndim);
  if (ierr != 0) {
    goto statement_5;
  }
  return;
  //C  OUTPUT ERROR MESSAGES                                                M29.4479
  statement_5:
  write(lunit6,
    "(' ***WARNING-DCEIGN:  EIGENVALUE',i4,' DID NOT CONVERGE.')"),
    ierr;
  return;
  statement_90:
  ierr = -1;
  write(lunit6,
    "(' **ERROR-DCEIGN:  ORDER OF MATRIX GREATER THAN FIRST',"
    "' DIMENSION OF MATRIX',/,18x,'ORDER=',i5,' FIRST DIMENSION=',i5)"),
    n, nm;
  write(6, star), "output matrix AR ";
  FEM_DO_SAFE(i, 1, n) {
    {
      write_loop wloop(cmn, 6, star);
      FEM_DO_SAFE(j, 1, n) {
        wloop, ar(i, j);
      }
    }
  }
  write(6, star), "output matrix AI ";
  FEM_DO_SAFE(i, 1, n) {
    {
      write_loop wloop(cmn, 6, star);
      FEM_DO_SAFE(j, 1, n) {
        wloop, ai(i, j);
      }
    }
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
redu44(
  common& cmn,
  arr_ref<double> a,
  arr_ref<double> b,
  int const& n,
  int const& m) try
{
  a(dimension(1));
  b(dimension(1));
  common_write write(cmn);
  double& epsiln = cmn.epsiln;
  double& unity = cmn.unity;
  auto& flstat = cmn.flstat;
  auto& lstat = cmn.lstat;
  //
  int j = fem::int0;
  double w = fem::double0;
  int ij = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int k = fem::int0;
  double h1 = fem::double0;
  int ik = fem::int0;
  int i1 = fem::int0;
  int i = fem::int0;
  double h2 = fem::double0;
  int i2 = fem::int0;
  int L = fem::int0;
  //C)    ELIMINATION OF VARIABLES M+1,...N IN SYMMETRIC MATRIX A. A IS     M15.1653
  //C)    STORED AS TRIANGLE (1 ELEMENT FOR 1.COLUMN,2 FOR 2.COLUMN ETC.).  M15.1654
  //C)    RESULT IS REDUCED MATRIX IN COLUMNS 1,...M IN CASE OF REDUCTION   M15.1655
  //C)    (M UNEQUAL 0) OR NEGATIVE INVERSE MATRIX IN COLUMNS 1,...N IN CASEM15.1656
  //C)    OF INVERSION (M=0).                                               M15.1657
  j = n + 1;
  w = unity;
  if (m > 0) {
    w = -w;
  }
  ij = n * j / 2;
  if (cmn.iprsup >= 4) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' AT START OF  ''REDU44'' .','       N       M      IJ',/,24x,3i8,"
        "/,' (A(K), K=1, IJ)  FOLLOW ....',/(1x,8e16.7))");
      wloop, n, m, ij;
      FEM_DO_SAFE(k, 1, ij) {
        wloop, a(k);
      }
    }
  }
  statement_3:
  j = j - 1;
  if (j == m) {
    return;
  }
  h1 = a(ij);
  if (std::abs(h1) > epsiln) {
    goto statement_6421;
  }
  cmn.kill = 86;
  lstat(19) = 6421;
  lstat(18) = 51;
  lstat(13) = n;
  lstat(14) = m;
  lstat(15) = j;
  flstat(15) = epsiln;
  flstat(16) = h1;
  return;
  statement_6421:
  h1 = -unity / h1;
  b(j) = h1;
  ij = ij - j;
  k = 0;
  ik = 0;
  //C                                   BEGIN K-LOOP                        M14.4212
  statement_4:
  ik += k;
  i1 = ik + 1;
  k++;
  if (k > n) {
    goto statement_3;
  }
  if (k < j) {
    goto statement_9;
  }
  if (w < 0.f) {
    goto statement_3;
  }
  if (k == j) {
    goto statement_7;
  }
  i = ik + j;
  statement_5:
  h2 = a(i);
  b(k) = h2 * h1;
  //C                                   BEGIN I-LOOP                        M14.4223
  i2 = ik + k;
  L = 0;
  FEM_DO_SAFE(i, i1, i2) {
    L++;
    a(i) += b(L) * h2;
  }
  if (k < j) {
    goto statement_4;
  }
  i = ik + j;
  a(i) = b(k);
  goto statement_4;
  //C                                   END I-LOOP                          M14.4233
  statement_7:
  i = ij;
  FEM_DO_SAFE(L, 1, j) {
    i++;
    a(i) = b(L);
  }
  goto statement_4;
  //C                                   END K-LOOP                          M14.4239
  statement_9:
  i = ij + k;
  goto statement_5;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct unwind_save
{
  arr<double> bom;
  int kunf;

  unwind_save() :
    bom(dimension(180), fem::fill0),
    kunf(fem::int0)
  {}
};

void
unwind(
  common& cmn,
  arr_ref<double> ping,
  int const& kthl,
  int& mrr,
  int const& nrp,
  int const& ntol,
  arr_ref<int> iseq) try
{
  FEM_CMN_SVE(unwind);
  ping(dimension(200));
  iseq(dimension(15));
  common_write write(cmn);
  double& t = cmn.t;
  int& iprsup = cmn.iprsup;
  //
  arr_ref<double> bom(sve.bom, dimension(180));
  int& kunf = sve.kunf;
  if (is_called_first_time) {
    fem::data((values, 180*datum(0.0e0))), bom;
    kunf = 0;
  }
  int ny = fem::int0;
  int i = fem::int0;
  arr_1d<15, int> iold(fem::fill0);
  arr_1d<3, double> vfreq(fem::fill0);
  int kpt = fem::int0;
  int li = fem::int0;
  arr_1d<200, double> tping(fem::fill0);
  int L = fem::int0;
  int im = fem::int0;
  arr_1d<60, double> sb(fem::fill0);
  int ic = fem::int0;
  int iq = fem::int0;
  int ip = fem::int0;
  int j = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double aj = fem::double0;
  double ai = fem::double0;
  double smj1 = fem::double0;
  double smi1 = fem::double0;
  double smj2 = fem::double0;
  double smi2 = fem::double0;
  arr_1d<4, double> tt(fem::fill0);
  int jb = fem::int0;
  int jbeg = fem::int0;
  double saj = fem::double0;
  int ib = fem::int0;
  double sai = fem::double0;
  int ku = fem::int0;
  int mu = fem::int0;
  arr_1d<15, int> kuid(fem::fill0);
  int kk = fem::int0;
  arr_1d<15, int> kuse(fem::fill0);
  arr_1d<15, int> iseqt(fem::fill0);
  double chf = fem::double0;
  arr_1d<15, int> iseqa(fem::fill0);
  //CCCCC %INCLUDE  '//A/TSU/TPPLOTKOM.INS.FTN'                             VAX.4433
  //C      WRITE(*,*) ' CHANGE ORDER ? 1 (for YES) or 2 (for NO)'           VAX.4441
  //C      READ(*,*) NY                                                     VAX.4442
  if (iprsup >= 1) {
    write(6, star), " Beginning of unwind.   KTHL, MRR, NRP, NTOL =",
      kthl, mrr, nrp, ntol;
  }
  ny = 2;
  //C      IF(NY .EQ. 2) GO TO 3800                                         VAX.4447
  //C      DO 3802 I=1,15                                                   VAX.4448
  //C      ISEQA(I)=I                                                       VAX.4449
  //C      ISEQT(I)=I                                                       VAX.4450
  //C 3802 CONTINUE                                                         VAX.4451
  //C      WRITE(*,*) ' FREQ ?'                                             VAX.4452
  //C      READ(*,*) CHF                                                    VAX.4453
  //C      WRITE(*,*) ' NEW ORDER ?'                                        VAX.4454
  //C      READ(*,3801) (ISEQA(K), K=1,15)                                  VAX.4455
  //C 3801 FORMAT( 15I3 )                                                   VAX.4456
  //C 3800 CONTINUE                                                         VAX.4457
  if ((ntol > 1) || (nrp == 0)) {
    goto statement_1050;
  }
  FEM_DO_SAFE(i, 1, 15) {
    iseq(i) = i;
    iold(i) = i;
  }
  FEM_DO_SAFE(i, 1, 180) {
    bom(i) = 0.0f;
  }
  statement_1050:
  if (iseq(1) != 0) {
    goto statement_10;
  }
  FEM_DO_SAFE(i, 1, 15) {
    iseq(i) = i;
  }
  //CC      WRITE(*,*)                                                      VAX.4471
  //CC     1 ' IDENTICAL EIGENVALUES ? 1 (for  YES) or 2 (for NO)'          VAX.4472
  //CC      READ(*,*) LWH                                                   VAX.4473
  //CC      IF (LWH .EQ. 2) GO TO 10                                        VAX.4474
  //CC      KUNF=1                                                          VAX.4475
  //CC      WRITE(*,*) ' MODE ?'                                            VAX.4476
  //CC      READ(*,4801) (KUID(K), K=1,15)                                  VAX.4477
  //CC 4801 FORMAT( 15I3 )                                                  VAX.4478
  statement_10:
  FEM_DO_SAFE(i, 1, 3) {
    vfreq(i) = 0.f;
  }
  //CC    ****  READ DATA FROM 'PING' VECTOR  ****                          VAX.4483
  kpt = kthl - 1;
  li = kpt / 4;
  vfreq(3) = vfreq(2);
  vfreq(2) = vfreq(1);
  vfreq(1) = ping(1);
  FEM_DO_SAFE(i, 1, kpt + 1) {
    tping(i) = ping(i);
  }
  FEM_DO_SAFE(L, 1, li) {
    FEM_DO_SAFE(im, 1, 4) {
      ping(4 * L - im + 2) = tping(4 * iseq(L) - im + 2);
    }
    iold(L) = iseq(L);
  }
  FEM_DO_SAFE(i, 1, kpt) {
    bom(i + 2 * kpt) = bom(i + kpt);
    bom(i + kpt) = bom(i);
    bom(i) = ping(i + 1);
  }
  if (ntol < 2) {
    return;
  }
  //CC     **** BEGIN TO SMOOTH ****                                        VAX.4504
  //CC  ** INITIALIZATION **                                                VAX.4505
  //CCCCC      DO 88 L=1, 15                                                VAX.4506
  //CCCCC      ISEQ(L) = L                                                  VAX.4507
  //CCCCC   88 CONTINUE                                                     VAX.4508
  FEM_DO_SAFE(i, 1, kpt) {
    //CCCCC      SB(I)=BOM(I)                                                 VAX.4510
    sb(i) = tping(i + 1);
  }
  ic = 0;
  iq = 0;
  if (iprsup >= 1) {
    write(6, star), "  *****  LI, kpt =", li, kpt;
  }
  statement_99:
  if (ic > li * (li - 1)) {
    goto statement_12;
  }
  if (iq == 1) {
    goto statement_12;
  }
  iq = 1;
  FEM_DO_SAFE(L, 1, li) {
    FEM_DO_SAFE(im, 1, 4) {
      bom(4 * L - im + 1) = sb(4 * iseq(L) - im + 1);
    }
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, 6, star);
      wloop, " Beginning  BOM(1:4*LI) =";
      FEM_DO_SAFE(ip, 1, 4 * li) {
        wloop, bom(ip);
      }
    }
  }
  //C   * PROCESS THE DATA BETWEEN FREQ, FREQ-1 & FREQ-2 *                  VAX.4526
  FEM_DOSTEP(j, 2, kpt - 2, 4) {
    FEM_DOSTEP(i, j + 4, kpt - 2, 4) {
      //C   * TEST THE CROSSING OF ANG *                                        VAX.4529
      d1 = bom(j + kpt) - bom(i + kpt);
      d2 = bom(j) - bom(i);
      if (d1 * d2 <= 0.f) {
        goto statement_801;
      }
      d1 = bom(j - 1 + kpt) - bom(i - 1 + kpt);
      d2 = bom(j - 1) - bom(i - 1);
      if (d1 * d2 <= 0.f) {
        goto statement_801;
      }
      goto statement_102;
      //C   * TEST THE SLOPE CHANGE OF ANG , IF SWITCHING *                     VAX.4537
      statement_801:
      aj = 0.f;
      ai = 0.f;
      if ((bom(j + kpt) - bom(j + 2 * kpt)) == 0.f) {
        aj = 1.0e-12f;
      }
      if ((bom(i + kpt) - bom(i + 2 * kpt)) == 0.f) {
        ai = 1.0e-12f;
      }
      smj1 = (bom(j) - bom(j + kpt)) / ((bom(j + kpt) - bom(j + 2 * kpt)) + aj);
      smi1 = (bom(i) - bom(i + kpt)) / ((bom(i + kpt) - bom(i + 2 * kpt)) + ai);
      smj2 = (bom(i) - bom(j + kpt)) / ((bom(j + kpt) - bom(j + 2 * kpt)) + aj);
      smi2 = (bom(j) - bom(i + kpt)) / ((bom(i + kpt) - bom(i + 2 * kpt)) + ai);
      if (iprsup >= 1) {
        write(6, star), " SMJ1, SMJ2, SMI1, SMI2 =", smj1, smj2, smi1, smi2;
      }
      if ((fem::abs(smj1 - 1) < fem::abs(smj2 - 1)) && (fem::abs(
          smi1 - 1) < fem::abs(smi2 - 1))) {
        goto statement_102;
      }
      //C   * TEST THE SLOPE CHANGE OF MAG , IF SWITCHING *                     VAX.4551
      //C     789012345678901234567890123456789012345678901234567890123456789012VAX.4552
      aj = 0.f;
      ai = 0.f;
      if ((bom(j - 1 + kpt) - bom(j - 1 + 2 * kpt)) == 0.f) {
        aj = 1.0e-12f;
      }
      if ((bom(i - 1 + kpt) - bom(i - 1 + 2 * kpt)) == 0.f) {
        ai = 1.0e-12f;
      }
      smj1 = (bom(j - 1) - bom(j - 1 + kpt)) / ((bom(j - 1 + kpt) -
        bom(j - 1 + 2 * kpt)) + aj);
      smi1 = (bom(i - 1) - bom(i - 1 + kpt)) / ((bom(i - 1 + kpt) -
        bom(i - 1 + 2 * kpt)) + ai);
      smj2 = (bom(i - 1) - bom(j - 1 + kpt)) / ((bom(j - 1 + kpt) -
        bom(j - 1 + 2 * kpt)) + aj);
      smi2 = (bom(j - 1) - bom(i - 1 + kpt)) / ((bom(i - 1 + kpt) -
        bom(i - 1 + 2 * kpt)) + ai);
      if ((fem::abs(smj1 - 1) < fem::abs(smj2 - 1)) && (fem::abs(
          smi1 - 1) < fem::abs(smi2 - 1))) {
        goto statement_102;
      }
      //C   * SWITCHING *                                                       VAX.4567
      iq = 0;
      t = iseq((j + 2) / 4);
      iseq((j + 2) / 4) = iseq((i + 2) / 4);
      iseq((i + 2) / 4) = t;
      FEM_DO_SAFE(im, 1, 4) {
        tt(im) = bom(j + im - 2);
        bom(j + im - 2) = bom(i + im - 2);
        bom(i + im - 2) = tt(im);
      }
      statement_102:;
    }
  }
  ic++;
  goto statement_99;
  statement_12:
  //CC  **  BEGIN THE SECOND LOOP FOR VEL AND DB  **                        VAX.4582
  //C   * TEST THE SLOPE CHANGE OF VEL *                                    VAX.4583
  ic = 0;
  iq = 0;
  statement_899:
  if (ic > li * (li - 1)) {
    goto statement_812;
  }
  if (iq == 1) {
    goto statement_812;
  }
  iq = 1;
  FEM_DO_SAFE(L, 1, li) {
    FEM_DO_SAFE(im, 1, 4) {
      bom(4 * L - im + 1) = sb(4 * iseq(L) - im + 1);
    }
  }
  //C   * TEST THE SLOPE CHANGE OF VEL *                                    VAX.4594
  FEM_DO_SAFE(jb, 1, li) {
    jbeg = jb * 4 - 1;
    aj = 0.f;
    if ((bom(jbeg + kpt) - bom(jbeg + 2 * kpt)) == 0.f) {
      aj = 1.0e-12f;
    }
    saj = (bom(jbeg) - bom(jbeg + kpt)) / ((bom(jbeg + kpt) - bom(
      jbeg + 2 * kpt)) + aj);
    if (fem::abs(saj - 1) > 0.5f) {
      goto statement_8001;
    }
  }
  goto statement_812;
  statement_8001:
  FEM_DOSTEP(j, jbeg, kpt - 1, 4) {
    FEM_DOSTEP(i, j + 4, kpt - 1, 4) {
      //C   * TEST THE CROSSING OF VEL OR DB *                                  VAX.4606
      jb = (j + 1) / 4;
      ib = (i + 1) / 4;
      d1 = bom(j + kpt) - bom(i + kpt);
      d2 = bom(j) - bom(i);
      if (d1 * d2 <= 0.f) {
        goto statement_8801;
      }
      d1 = bom(j + 1 + kpt) - bom(i + 1 + kpt);
      d2 = bom(j + 1) - bom(i + 1);
      if (d1 * d2 <= 0.f) {
        goto statement_8801;
      }
      goto statement_8102;
      //C      GO TO 8122                                                       VAX.4616
      statement_8801:
      aj = 0.f;
      ai = 0.f;
      if ((bom(j + kpt) - bom(j + 2 * kpt)) == 0.f) {
        aj = 1.0e-12f;
      }
      if ((bom(i + kpt) - bom(i + 2 * kpt)) == 0.f) {
        ai = 1.0e-12f;
      }
      smj1 = (bom(j) - bom(j + kpt)) / ((bom(j + kpt) - bom(j + 2 * kpt)) + aj);
      smi1 = (bom(i) - bom(i + kpt)) / ((bom(i + kpt) - bom(i + 2 * kpt)) + ai);
      smj2 = (bom(i) - bom(j + kpt)) / ((bom(j + kpt) - bom(j + 2 * kpt)) + aj);
      smi2 = (bom(j) - bom(i + kpt)) / ((bom(i + kpt) - bom(i + 2 * kpt)) + ai);
      if ((fem::abs(smj1 - 1) < fem::abs(smj2 - 1)) && (fem::abs(
          smi1 - 1) < fem::abs(smi2 - 1))) {
        goto statement_8102;
      }
      //C     1 (ABS( SMI1 -1 ) .LT. ABS( SMI2 -1 ))) GO TO 8132                VAX.4628
      //C   * TEST THE SLOPE CHANGE OF DB, IF SWITCH *                          VAX.4629
      aj = 0.f;
      ai = 0.f;
      if ((bom(j + 1 + kpt) - bom(j + 1 + 2 * kpt)) == 0.f) {
        aj = 1.0e-12f;
      }
      if ((bom(i + 1 + kpt) - bom(i + 1 + 2 * kpt)) == 0.f) {
        ai = 1.0e-12f;
      }
      saj = (bom(i + 1) - bom(j + 1 + kpt)) / ((bom(j + 1 + kpt) -
        bom(j + 1 + 2 * kpt)) + aj);
      sai = (bom(j + 1) - bom(i + 1 + kpt)) / ((bom(i + 1 + kpt) -
        bom(i + 1 + 2 * kpt)) + ai);
      if ((fem::abs(saj - 1) > 1.0f) && (fem::abs(sai - 1) > 1.0f)) {
        goto statement_8102;
      }
      //C     1 GO TO 8142                                                      VAX.4640
      //C     789012345678901234567890123456789012345678901234567890123456789012VAX.4641
      //C   * SWITCHING *                                                       VAX.4642
      iq = 0;
      t = iseq(jb);
      iseq(jb) = iseq(ib);
      iseq(ib) = t;
      FEM_DO_SAFE(im, 1, 4) {
        tt(im) = bom(j + im - 3);
        bom(j + im - 3) = bom(i + im - 3);
        bom(i + im - 3) = tt(im);
      }
      //C 8112 WRITE(*,*) VFREQ(1), I,J, 'STOP 1'                               VAX.4652
      //C      GO TO 8102                                                       VAX.4653
      //C 8122 WRITE(*,*) VFREQ(1), I,J, 'STOP 2'                               VAX.4654
      //C      GO TO 8102                                                       VAX.4655
      //C 8132 WRITE(*,*) VFREQ(1), I,J, 'STOP 3'                               VAX.4656
      //C      GO TO 8102                                                       VAX.4657
      //C 8142 WRITE(*,*) VFREQ(1), I,J, 'STOP 4'                               VAX.4658
      //C      GO TO 8102                                                       VAX.4659
      statement_8102:;
    }
  }
  ic++;
  goto statement_899;
  statement_812:
  //C   * CHECK THE EQUALITY BETWEEN TWO EIGENVALUES *                      VAX.4665
  if (nrp == 1) {
    goto statement_2030;
  }
  ku = 0;
  kunf = 0;
  FEM_DOSTEP(j, 1, kpt - 3, 4) {
    mu = 0;
    FEM_DOSTEP(i, j + 4, kpt - 3, 4) {
      if ((fem::abs(bom(j) - bom(i)) > fem::abs(bom(j) * 1e-6f)) || (
          fem::abs(bom(j + 1) - bom(i + 1)) > fem::abs(bom(j + 1) *
          1e-6f))) {
        goto statement_1005;
      }
      if ((fem::abs(bom(j + kpt) - bom(i + kpt)) > fem::abs(bom(j +
          kpt) * 1e-6f)) || (fem::abs(bom(j + 1 + kpt) - bom(i + 1 +
          kpt)) > fem::abs(bom(j + 1 + kpt) * 1e-6f))) {
        goto statement_1005;
      }
      //CCCC      IF((BOM(J).NE.BOM(I)).OR.(BOM(J+1).NE.BOM(I+1))) GO TO 1005   VAX.4677
      //CCCC      IF((BOM(J+KPT).NE.BOM(I+KPT)).OR.                             VAX.4678
      //CCCC     1 (BOM(J+1+KPT).NE.BOM(I+1+KPT))) GO TO 1005                   VAX.4679
      kunf = 1;
      mu = 1;
      kuid(ku + 1) = (i + 3) / 4;
      ku++;
      statement_1005:;
    }
    if (mu == 0) {
      goto statement_1004;
    }
    kuid(ku + 1) = (j + 3) / 4;
    ku++;
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, 6, star);
        wloop, " Identical eigenvalues.   J, KU, KUID(1:KU) =", j, ku;
        FEM_DO_SAFE(ip, 1, ku) {
          wloop, kuid(ip);
        }
      }
    }
    statement_1004:;
  }
  if (kunf == 0) {
    goto statement_2000;
  }
  mrr++;
  goto statement_2000;
  statement_2030:
  FEM_DO_SAFE(i, 1, ku) {
    kk = ku - i;
    FEM_DO_SAFE(j, 1, kk) {
      if (kuid(j) < kuid(j + 1)) {
        goto statement_2008;
      }
      t = kuid(j);
      kuid(j) = kuid(j + 1);
      kuid(j + 1) = t;
      statement_2008:;
    }
    kuse(i) = i;
  }
  {
    write_loop wloop(cmn, 6, star);
    wloop, " kuid after sorting : ";
    FEM_DO_SAFE(i, 1, ku) {
      wloop, kuid(i);
    }
  }
  FEM_DO_SAFE(i, 1, ku) {
    kk = ku - i;
    FEM_DO_SAFE(j, 1, kk) {
      if (iold(kuid(j)) < iold(kuid(j + 1))) {
        goto statement_2003;
      }
      t = iold(kuid(j));
      iold(kuid(j)) = iold(kuid(j + 1));
      iold(kuid(j + 1)) = t;
      t = kuse(j);
      kuse(j) = kuse(j + 1);
      kuse(j + 1) = t;
      statement_2003:;
    }
  }
  FEM_DO_SAFE(i, 1, ku) {
    kk = ku - i;
    FEM_DO_SAFE(j, 1, kk) {
      if (iseq(kuid(j)) < iseq(kuid(j + 1))) {
        goto statement_2012;
      }
      t = iseq(kuid(j));
      iseq(kuid(j)) = iseq(kuid(j + 1));
      iseq(kuid(j + 1)) = t;
      statement_2012:;
    }
  }
  FEM_DO_SAFE(L, 1, li) {
    iseqt(L) = iseq(L);
  }
  FEM_DO_SAFE(i, 1, ku) {
    iseq(kuid(kuse(i))) = iseqt(kuid(i));
  }
  //C   * RE-ORDERING, IF NECESSARY *                                       VAX.4735
  statement_2000:
  if (ny == 2) {
    goto statement_2004;
  }
  if (vfreq(1) != chf) {
    goto statement_2004;
  }
  FEM_DO_SAFE(L, 1, li) {
    iseqt(L) = iseq(L);
  }
  FEM_DO_SAFE(L, 1, li) {
    iseq(L) = iseqt(iseqa(L));
  }
  statement_2004:
  FEM_DO_SAFE(L, 1, li) {
    FEM_DO_SAFE(im, 1, 4) {
      bom(4 * L - im + 1) = sb(4 * iseq(L) - im + 1);
    }
  }
  if (iprsup >= 1) {
    write(6, star), " End of unwind.  VFREQ(1) =", vfreq(1);
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, 6, star);
      wloop, " End of unwind.   ISEQ(1:LI) =";
      FEM_DO_SAFE(L, 1, li) {
        wloop, iseq(L);
      }
    }
  }
  if (iprsup >= 1) {
    write(6, star), " End of unwind.   KTHL, MRR, NRP, NTOL =", kthl,
      mrr, nrp, ntol;
  }
  FEM_DO_SAFE(i, 1, kpt) {
    ping(i + 1) = bom(i);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct modal_save
{
  arr<int> iseq;
  fem::str<8> text10;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;
  fem::str<8> text8;
  fem::str<8> text9;

  modal_save() :
    iseq(dimension(15), fem::fill0),
    text10(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0),
    text8(fem::char0),
    text9(fem::char0)
  {}
};

void
modal(
  common& cmn,
  arr_cref<double> /* array */,
  arr_ref<double> xwc,
  arr_ref<double> xwy,
  arr_ref<double, 2> yzr,
  arr_ref<double, 2> yzi,
  arr_ref<double, 2> tii,
  arr_ref<double, 2> tir,
  arr_ref<double, 2> tvi,
  arr_ref<double, 2> tvr,
  arr_ref<double> er,
  arr_ref<double> ei,
  arr_ref<double> theta2,
  arr_ref<double> xtir,
  arr_ref<double> xtii,
  arr_ref<double> zsurge,
  arr_ref<double> dummi,
  arr_ref<double> dummr,
  arr_ref<double> tixf,
  arr_ref<double> work1,
  double const& freq,
  int const& m,
  int const& iw,
  double& dist,
  int const& metrik,
  double const& fmipkm,
  int const& ndim,
  int const& ntri,
  int const& nsqr2,
  int const& itrnsf,
  int const& kfull,
  int& mrr,
  int const& nrp,
  int const& ntol,
  double& conduc) try
{
  FEM_CMN_SVE(modal);
  xwc(dimension(ntri));
  xwy(dimension(ntri));
  yzr(dimension(ndim, ndim));
  yzi(dimension(ndim, ndim));
  tii(dimension(ndim, ndim));
  tir(dimension(ndim, ndim));
  tvi(dimension(ndim, ndim));
  tvr(dimension(ndim, ndim));
  er(dimension(ndim));
  ei(dimension(ndim));
  theta2(dimension(ndim));
  xtir(dimension(ndim));
  xtii(dimension(ndim));
  zsurge(dimension(ndim));
  dummi(dimension(ndim));
  dummr(dimension(ndim));
  tixf(dimension(nsqr2));
  work1(dimension(nsqr2));
  common_read read(cmn);
  common_write write(cmn);
  auto& texta6 = cmn.texta6;
  const auto& date1= cmn.date1;
  const auto& tclock= cmn.tclock;
  const auto& abuff = cmn.abuff;
  double& twopi = cmn.twopi;
  double& onehaf = cmn.onehaf;
  auto& lunit2 = cmn.lunit2;
  auto& lunit7 = cmn.lunit7;
  auto& lunit9 = cmn.lunit9;
  auto& lstat = cmn.lstat;
  int& lastov = cmn.lastov;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  const auto& brname = cmn.brname;
  double& pi = static_cast<common_com44&>(cmn).pi;
  int& ll0 = cmn.ll0;
  int& ll1 = cmn.ll1;
  int& nfreq = cmn.nfreq;
  auto& p = cmn.p;
  auto& z = static_cast<common_c44b03&>(cmn).z;
  auto& workr1 = cmn.workr1;
  int& kexact = cmn.kexact;
  //
  arr_ref<int> iseq(sve.iseq, dimension(15));
  fem::str<8>& text10 = sve.text10;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  fem::str<8>& text7 = sve.text7;
  fem::str<8>& text8 = sve.text8;
  fem::str<8>& text9 = sve.text9;
  if (is_called_first_time) {
    text2 = "A";
    text3 = "B";
    text4 = "C";
    text5 = "D";
    text6 = "E";
    text7 = "F";
    text8 = "G";
    text9 = "H";
    text10 = "I";
    fem::data((values, 15*datum(0))), iseq;
  }
  auto& lunit6 = cmn.lunit6;
  int mm = fem::int0;
  double c = fem::double0;
  int i = fem::int0;
  double d13 = fem::double0;
  int k = fem::int0;
  int j = fem::int0;
  int n = fem::int0;
  double cr = fem::double0;
  double cl = fem::double0;
  double cc = fem::double0;
  arr<double, 2> tempr(dimension(20, 20), fem::fill0);
  arr<double, 2> tempi(dimension(20, 20), fem::fill0);
  int ierror = fem::int0;
  int kthl = fem::int0;
  arr_1d<200, double> ping(fem::fill0);
  double d55 = fem::double0;
  double d56 = fem::double0;
  double em = fem::double0;
  double ea = fem::double0;
  double d14 = fem::double0;
  double vmode = fem::double0;
  arr_1d<15, double> ee1(fem::fill0);
  arr_1d<15, double> ee2(fem::fill0);
  arr<double, 2> pp1(dimension(20, 20), fem::fill0);
  arr<double, 2> pp2(dimension(20, 20), fem::fill0);
  int ll = fem::int0;
  arr_1d<15, int> kmax(fem::fill0);
  double dv = fem::double0;
  double da = fem::double0;
  int ij = fem::int0;
  int ibk = fem::int0;
  double fnorm = fem::double0;
  double theta = fem::double0;
  int n5 = fem::int0;
  int n12 = fem::int0;
  double b = fem::double0;
  double g = fem::double0;
  int ig = fem::int0;
  double d1 = fem::double0;
  double xa = fem::double0;
  double xb = fem::double0;
  double ya = fem::double0;
  double dumm1 = fem::double0;
  double gamma = fem::double0;
  double ycharm = fem::double0;
  double ychara = fem::double0;
  double alpha = fem::double0;
  double beta = fem::double0;
  double zr = fem::double0;
  double zi = fem::double0;
  int kk1 = fem::int0;
  int ki1 = fem::int0;
  int jj = fem::int0;
  int kk = fem::int0;
  int L = fem::int0;
  double ci = fem::double0;
  double dr = fem::double0;
  double di = fem::double0;
  double ym = fem::double0;
  double zcharr = fem::double0;
  double zchari = fem::double0;
  double d9 = fem::double0;
  double distm = fem::double0;
  fem::str<8> text1 = fem::char0;
  int n9sq = fem::int0;
  double dd = fem::double0;
  static const char* format_39 = "(/,/,'      REAL COMPONENTS, ROW BY ROW')";
  static const char* format_59 = "(6f12.8)";
  static const char* format_60 =
    "(/,/,'     IMAGINARY COMPONENTS, ROW BY ROW')";
  static const char* format_9 = "(2x,6e12.5)";
  //C!w COMMON / LINEMODEL/ KEXACT, NSOLVE, FMINSV, KBRNUM, NUMRUN
  if (kexact == 88333) {
    goto statement_100;
  }
  if (itrnsf == 1 && nfreq == 1) {
    return;
  }
  if (itrnsf == 1 && nfreq == 2) {
    return;
  }
  if (lastov == 39 && nfreq == 2) {
    return;
  }
  statement_100:
  if (iprsup >= 1) {
    write(lunit6, star), " Top of modal.   NDIM =", ndim;
  }
  ll0 = 0;
  mm = m * (m + 1) / 2;
  c = cmn.unity;
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' AT THE TOP OF MODAL, M AND MM ARE',2i10,/,"
        "' (P(I),  Z (I), I=1, MM) ARE',/(1x,8e15.6))");
      wloop, m, mm;
      FEM_DO_SAFE(i, 1, mm) {
        wloop, p(i), z(i);
      }
    }
  }
  d13 = twopi * freq;
  if (iw == 1) {
    c = c / d13;
  }
  FEM_DO_SAFE(i, 1, mm) {
    xwc(i) = xwc(i) * c;
    xwy(i) = -xwc(i);
  }
  redu44(cmn, xwy(1), workr1(1), m, ll0);
  //C    Const. [T], MARTI SETUP WILL BYPASS THE EXACT DIAGONALIZATION      M43.3661
  //C     AT EACH LOOPING FREQUENCY                                         M43.3662
  if (nfreq != 1 && lastov == 39 && itrnsf != 1) {
    goto statement_2520;
  }
  if (lastov == 39 && nfreq == 3) {
    goto statement_7030;
  }
  if (kexact == 88333) {
    goto statement_7030;
  }
  write(lunit6, "(/,/,' MODAL PARAMETERS AT FREQ = ',e13.5,' HZ')"), freq;
  write(lunit6,
    "(/,/,"
    "' MODE   RESISTANCE  REACTANCE  SUSCEPTANCE             SURGE IMPEDANCE(O"
    "HM)          VELOCITY  ATTENUATION')");
  if (metrik == 1) {
    goto statement_7029;
  }
  write(lunit6,
    "('          OHM/MILE    OHM/MILE   S/MILE        REAL         IMAG       "
    "LOSSLESS     MILE/SEC  NEPER/MILE')");
  goto statement_7030;
  statement_7029:
  write(lunit6,
    "('          OHM/KM      OHM/KM     S/KM         REAL          IMAG      L"
    "OSSLESS     KM/SEC     NEPER/KM')");
  statement_7030:
  //C ***** CREATE Y * Z MATRIX FROM ARRAY FROM LCP MAIN                    M29.4278
  k = 0;
  statement_3:
  k++;
  FEM_DO_SAFE(j, 1, m) {
    //C     N=MAX0Z(J,K)                                                      M36.3600
    n = j;
    if (n < k) {
      n = k;
    }
    n = n * (n - 3) / 2 + j + k;
    er(j) = p(n);
    ei(j) = z(n);
  }
  //C **** THE K-TH COLUMN OF R+XWL IS STORED                               M29.4286
  i = 0;
  statement_2:
  i++;
  cr = 0.0f;
  cl = 0.0f;
  FEM_DO_SAFE(j, 1, m) {
    //C     N=MAX0Z(J,I)                                                      M36.3603
    n = j;
    if (n < i) {
      n = i;
    }
    n = n * (n - 3) / 2 + j + i;
    cc = xwy(n);
    if (lastov == 1) {
      conduc = 0.0f;
    }
    cr += cc * er(j) + conduc * ei(j);
    cl = cl - cc * ei(j) + conduc * er(j);
  }
  //C **** THE ELEMENT OF ROW I AND COLUMN K OF YZ IS OBTAINED              M29.4297
  yzr(i, k) = cl;
  yzi(i, k) = cr;
  if (iprsup >= 1) {
    write(lunit6,
      "('       I       K       YZR(I,K)       YZI(I,K)',/,2i8,2e15.6)"),
      i, k, yzr(i, k), yzi(i, k);
  }
  if (i < m) {
    goto statement_2;
  }
  //C **** YZ IS OBTAINED IN ORDER OF (1,1),(2,1),...,(1,2),(2,2),COLUMNWISEM29.4305
  if (k < m) {
    goto statement_3;
  }
  //C *** FIND EIGENVALUES + EIGENVECTORS ***                               M29.4307
  if (kexact == 88333) {
    goto statement_6999;
  }
  if (itrnsf ==  - 1) {
    goto statement_459;
  }
  if (lastov == 1 || itrnsf != 1) {
    goto statement_7011;
  }
  //C $$$$  CHANGE TO ZY-MATRIX i.e. TRANSFORMATION MATRIX IS TV   $$$$     M43.3668
  statement_6999:
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      tempr(i, j) = yzr(j, i);
      tempi(i, j) = yzi(j, i);
    }
  }
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      yzr(i, j) = tempr(i, j);
      yzi(i, j) = tempi(i, j);
    }
  }
  dceign(cmn, yzr, yzi, tvi, tvr, er, ei, m, m, ierror, ll1, ll0,
    lunit6, iprsup, ndim);
  //C      write(*,*)(ER(i), i=1,m)                                         M43.3681
  //C      write(*,*)(EI(i), i=1,m)                                         M43.3682
  goto statement_7012;
  statement_7011:
  dceign(cmn, yzr, yzi, tii, tir, er, ei, m, m, ierror, ll1, ll0,
    lunit6, iprsup, ndim);
  //C      write(*,*)(ER(i), i=1,m)                                         M43.3686
  //C      write(*,*)(EI(i), i=1,m)                                         M43.3687
  goto statement_7072;
  statement_7012:
  kthl = 1;
  ping(kthl) = alog1z(freq);
  d55 = 1.0f / freq;
  d56 = 1.0f / sqrtz(freq);
  FEM_DO_SAFE(i, 1, m) {
    em = sqrtz(er(i) * er(i) + ei(i) * ei(i));
    ea = std::atan2(ei(i), er(i));
    p(i) = sqrtz(em);
    z(i) = ea / 2;
    if (kexact == 88333) {
      goto statement_5600;
    }
    cc = sqrtz(em) * cosz(ea / 2.f);
    d14 = sqrtz(em) * sinz(ea / 2.f);
    vmode = d13 / d14;
    //C $$$$  PUT DATA IN PING VECTOR  $$$$                                   M43.3701
    ping(kthl + 1) = em * d55;
    ping(kthl + 2) = ea / (twopi / 360.f);
    ping(kthl + 3) = vmode;
    ping(kthl + 4) = cc * d56;
    kthl += 4;
    statement_5600:;
  }
  if (iprsup < 1) {
    goto statement_5602;
  }
  write(lunit6, star), " Tv before UNWIND. ";
  FEM_DO_SAFE(i, 1, m) {
    {
      write_loop wloop(cmn, lunit6, format_59);
      FEM_DO_SAFE(j, 1, m) {
        wloop, tvr(i, j);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_59);
      FEM_DO_SAFE(j, 1, m) {
        wloop, tvi(i, j);
      }
    }
  }
  statement_5602:
  if (kexact == 88333) {
    goto statement_5620;
  }
  unwind(cmn, ping, kthl, mrr, nrp, ntol, iseq);
  if (iprsup < 1) {
    goto statement_5605;
  }
  {
    write_loop wloop(cmn, lunit6, star);
    wloop, " ISEQ after UNWIND are, ";
    FEM_DO_SAFE(i, 1, m) {
      wloop, iseq(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, star);
    wloop, " PING after UNWIND are, ";
    FEM_DO_SAFE(i, 1, kthl) {
      wloop, ping(i);
    }
  }
  statement_5605:
  //C $$$$  BEGIN THE PROCESS OF EIGENVECTORS  $$$$                         M43.3719
  FEM_DO_SAFE(i, 1, m) {
    ee1(i) = p(i);
    ee2(i) = z(i);
    FEM_DO_SAFE(j, 1, m) {
      //C $$$$  use tv  $$$$                                                    M43.3724
      pp1(i, j) = tvr(i, j);
      pp2(i, j) = tvi(i, j);
    }
  }
  FEM_DO_SAFE(i, 1, m) {
    p(i) = ee1(iseq(i));
    z(i) = ee2(iseq(i));
    FEM_DO_SAFE(j, 1, m) {
      //C $$$$ use tv  $$$$                                                     M43.3732
      tvr(i, j) = pp1(i, iseq(j));
      tvi(i, j) = pp2(i, iseq(j));
    }
  }
  //C $$$$ new code to get ti from tv-t $$$$                                M43.3736
  statement_5620:
  ll = 1;
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      tixf(ll) = tvr(i, j);
      tixf(ll + 1) = tvi(i, j);
      ll += 2;
    }
  }
  cominv(cmn, tixf(1), work1(1), m, freq);
  ll = 1;
  if (iprsup >= 3) {
    write(lunit6, star), " Before DO 7004.  M, NDIM, FREQ =", m, ndim, freq;
  }
  FEM_DO_SAFE(j, 1, m) {
    FEM_DO_SAFE(i, 1, m) {
      tir(i, j) = work1(ll);
      tii(i, j) = work1(ll + 1);
      ll += 2;
    }
  }
  if (kexact == 88333) {
    goto statement_7072;
  }
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      pp1(i, j) = sqrtz(fem::pow2((tir(i, j))) + fem::pow2((tii(i, j))));
      pp2(i, j) = std::atan2(tii(i, j), tir(i, j));
    }
  }
  //C                                                                       M43.3764
  if (ntol != 1) {
    goto statement_5812;
  }
  FEM_DO_SAFE(j, 1, m) {
    kmax(j) = 1;
    FEM_DO_SAFE(i, 1, m) {
      if (pp1(i, j) <= pp1(kmax(j), j)) {
        goto statement_5802;
      }
      kmax(j) = i;
      statement_5802:;
    }
  }
  {
    write_loop wloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(j, 1, m) {
      wloop, kmax(j);
    }
  }
  statement_5812:
  FEM_DO_SAFE(j, 1, m) {
    if (pp1(kmax(j), j) == 0.0f) {
      goto statement_5614;
    }
    dv = 1.0f / pp1(kmax(j), j);
    da = pp2(kmax(j), j);
    if (iprsup >= 3) {
      write(6, star), "In do loop 5614, j=, kmax(j)=,dv=,da=", j,
        kmax(j), dv, da;
    }
    FEM_DO_SAFE(i, 1, m) {
      if (iprsup >= 3) {
        write(6, star), "In do loop 5624, i, j, pp1(i,j), pp2(i,j)",
          i, j, pp1(i, j), pp2(i, j);
      }
      pp1(i, j) = pp1(i, j) * dv;
      pp2(i, j) = pp2(i, j) - da;
      //C     *** to keep angles within principal value region                  M43.3787
      if (pp2(i, j) > twopi / 2.f) {
        pp2(i, j) = pp2(i, j) - twopi;
      }
      if (pp2(i, j) <  - twopi / 2.f) {
        pp2(i, j) += twopi;
      }
      if (iprsup >= 3) {
        write(6, star), "just before 5624, i, j, pp1(i,j), pp2(i,j)",
          i, j, pp1(i, j), pp2(i, j);
      }
    }
    statement_5614:;
  }
  //CC    ** fix the error of using  TI as TV  **                           M43.3795
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      tir(i, j) = (pp1(i, j)) * cosz(pp2(i, j));
      tii(i, j) = (pp1(i, j)) * sinz(pp2(i, j));
    }
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' AT ',e12.5,'Hz, EIGENVECTORS TIR AND TII AFTER SCALING ARE ',/(1x,"
        "8e15.6))");
      wloop, freq;
      FEM_DO_SAFE(i, 1, m) {
        FEM_DO_SAFE(j, 1, m) {
          wloop, tir(i, j), tii(i, j);
        }
      }
    }
  }
  statement_7072:
  if (ierror == 0) {
    goto statement_463;
  }
  kill = 221;
  lstat(19) = 72;
  lstat(14) = ierror;
  goto statement_9200;
  statement_459:
  FEM_DO_SAFE(j, 1, m) {
    FEM_DOSTEP(i, 1, m, 3) {
      ij = i + 2;
      cimage(cmn);
      {
        read_loop rloop(abuff(1), "(6e13.0)");
        FEM_DO_SAFE(ibk, i, ij) {
          rloop, tir(j, ibk), tii(j, ibk);
        }
      }
    }
  }
  //CC   $$$$ skip the rotation and normalization  for freq-dep [T] ??      M43.3806
  statement_463:
  if (lastov == 39 && itrnsf == 1 || kexact == 88333) {
    goto statement_2500;
  }
  if (itrnsf ==  - 9 || itrnsf ==  - 1) {
    goto statement_464;
  }
  if (iprsup < 4) {
    goto statement_88;
  }
  write(lunit6,
    "(' CURRENT TRANSFORMATION MATRIX BEFORE ZEROING THE IMAGINARY PART:')");
  write(lunit6, format_39);
  FEM_DO_SAFE(k, 1, m) {
    {
      write_loop wloop(cmn, lunit6, format_9);
      FEM_DO_SAFE(j, 1, m) {
        wloop, tir(k, j);
      }
    }
  }
  write(lunit6, format_60);
  FEM_DO_SAFE(k, 1, m) {
    {
      write_loop wloop(cmn, lunit6, format_9);
      FEM_DO_SAFE(j, 1, m) {
        wloop, tii(k, j);
      }
    }
  }
  statement_88:
  FEM_DO_SAFE(j, 1, m) {
    cr = 0.f;
    fnorm = 0.f;
    FEM_DO_SAFE(i, 1, m) {
      fnorm += (fem::pow2(tir(i, j)) - fem::pow2(tii(i, j)));
      cr += tir(i, j) * tii(i, j);
    }
    cr = -2.0f * cr;
    theta = std::atan2(cr, fnorm) / 2.f;
    cr = cosz(theta);
    cl = sinz(theta);
    FEM_DO_SAFE(i, 1, m) {
      tir(i, j) = tir(i, j) * cr - tii(i, j) * cl;
      tii(i, j) = 0.f;
    }
  }
  statement_464:
  FEM_DO_SAFE(i, 1, m) {
    fnorm = 0.0f;
    FEM_DO_SAFE(j, 1, m) {
      fnorm += fem::pow2(tir(j, i)) + fem::pow2(tii(j, i));
    }
    fnorm = 1.f / sqrtz(fnorm);
    FEM_DO_SAFE(j, 1, m) {
      tii(j, i) = tii(j, i) * fnorm;
      tir(j, i) = tir(j, i) * fnorm;
    }
  }
  //C $$$$  CALCULATION OF TV FROM TI  $$$$                                 M43.3811
  statement_2500:
  ll = 1;
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      tixf(ll) = tir(i, j);
      tixf(ll + 1) = tii(i, j);
      ll += 2;
    }
  }
  cominv(cmn, tixf(1), work1(1), m, freq);
  ll = 1;
  FEM_DO_SAFE(j, 1, m) {
    FEM_DO_SAFE(i, 1, m) {
      tvr(i, j) = work1(ll);
      tvi(i, j) = work1(ll + 1);
      ll += 2;
    }
  }
  //CC    ** Now, we have both TI and TV **                                 M43.3829
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(' EIGENVECTORS TVR AND TVI ARE ',/(1x,8e15.6))");
      FEM_DO_SAFE(i, 1, m) {
        FEM_DO_SAFE(j, 1, m) {
          wloop, tvr(i, j), tvi(i, j);
        }
      }
    }
  }
  if (lastov == 39 && itrnsf != 1) {
    goto statement_166;
  }
  if (lastov != 1) {
    goto statement_2520;
  }
  write(lunit7,
    "('C    PUNCHED OUTPUT OF K. C. LEE''S LINE ',' WHICH BEGAN AT',2x,2a4,2x,"
    "2a4)"),
    tclock, date1;
  write(lunit7,
    "('C  ***** UNTRANSPOSED K.C. LEE LINE SEGMENT CALCULATED AT',2x,e10.3,"
    "' HZ. *****')"),
    freq;
  cmn.io.rewind(lunit2);
  n5 = kfull + nfreq + 1;
  FEM_DO_SAFE(n12, 1, n5) {
    try {
      read_loop rloop(cmn, lunit2, "(13a6,a2)");
      FEM_DO_SAFE(i, 1, 14) {
        rloop, texta6(i);
      }
    }
    catch (fem::read_end const&) {
      goto statement_8775;
    }
    {
      write_loop wloop(cmn, lunit7, "('C ',13a6)");
      FEM_DO_SAFE(i, 1, 13) {
        wloop, texta6(i);
      }
    }
  }
  statement_8775:
  write(lunit7, "('$VINTAGE, 1')");
  //C ****** TO GET MODAL Y *********                                       M43.3837
  statement_2520:
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      //C     $$$ Now, using TV to get Ymode $$$                                M43.3839
      xtir(j) = tvr(j, i);
      xtii(j) = tvi(j, i);
    }
    mult(xwy, xtir, dummi, m, ll0);
    b = 0.0f;
    mult(xwy, xtii, dummr, m, ll0);
    //C *** XWY  IS J(WC) ******                                              M32, 386
    FEM_DO_SAFE(j, 1, m) {
      dummr(j) = -dummr(j);
    }
    FEM_DO_SAFE(j, 1, m) {
      dummi(j) += conduc * xtii(j);
      dummr(j) += conduc * xtir(j);
    }
    g = 0.0f;
    FEM_DO_SAFE(ig, 1, m) {
      c = dummr(ig);
      d1 = dummi(ig);
      xa = xtir(ig);
      xb = xtii(ig);
      b += xa * d1 + xb * c;
      g += xa * c - xb * d1;
    }
    if (iprsup >= 1) {
      write(lunit6, star), " Modal admittance Ym for mode ", i, g, b;
    }
    //C TO GET ROTATION FOR  Y=0+XWC                                          M29.4359
    ya = std::atan2(b, g);
    theta = pi * onehaf - ya;
    theta2(i) = -theta * onehaf;
    dumm1 = sqrtz(g * g + b * b);
    //C **** TO GET ZMODAL, ZSURGE, VMODE FROM YMODAL & EIGENVALUES ****      M29.4363
    if (lastov == 1) {
      goto statement_2900;
    }
    //CC  ** NEW CODING **                                                    M43.3845
    if (itrnsf != 1 && kexact != 88333) {
      goto statement_7041;
    }
    gamma = p(i);
    ea = z(i);
    statement_1232:
    ycharm = dumm1 / gamma;
    ychara = ya - ea;
    //C  ***********************************                                  M43.3853
    //C     Comment the following two lines if Ych is to be fitted            M43.3854
    //C      YCHARM = 1./YCHARM    !  Zch = 1 / Ych                           M43.3855
    //C      YCHARA = - YCHARA                                                M43.3856
    //C   ********************************                                    M43.3857
    alpha = gamma * cosz(ea);
    beta = gamma * sinz(ea);
    if (kexact != 88333) {
      goto statement_7033;
    }
    if (metrik == 1) {
      dist = dist * fmipkm;
    }
    alpha = alpha * dist;
    beta = beta * dist;
    goto statement_155;
    statement_7033:
    alpha = alpha * fmipkm;
    beta = beta * fmipkm;
    goto statement_155;
    statement_7041:
    zr = 0.0f;
    zi = 0.0f;
    kk1 = 2 * m;
    ki1 = 2 * i - kk1 - 1;
    FEM_DO_SAFE(jj, 1, m) {
      kk = kk1 * jj + ki1;
      FEM_DO_SAFE(L, 1, m) {
        cr = 0.0f;
        ci = 0.0f;
        FEM_DO_SAFE(j, 1, m) {
          //C     N = MAX0Z(J,L)                                                    M36.3622
          n = j;
          if (n < L) {
            n = L;
          }
          n = n * (n - 3) / 2 + j + L;
          er(j) = p(n);
          ei(j) = z(n);
          k = kk1 * j + ki1;
          cr += er(j) * tixf(k) - ei(j) * tixf(k + 1);
          ci += er(j) * tixf(k + 1) + ei(j) * tixf(k);
        }
        dummr(L) = cr;
        dummi(L) = ci;
      }
      zr += tixf(kk) * dummr(jj) - tixf(kk + 1) * dummi(jj);
      zi += tixf(kk) * dummi(jj) + tixf(kk + 1) * dummr(jj);
    }
    dr = zr * g - zi * b;
    di = zr * b + zi * g;
    em = sqrtz(dr * dr + di * di);
    gamma = sqrtz(em);
    ea = std::atan2(di, dr) / 2.f;
    ym = sqrtz(fem::pow2(g) + fem::pow2(b));
    ya = std::atan2(b, g);
    goto statement_1232;
    statement_2900:
    g = ei(i) / dumm1;
    b = -er(i) / dumm1;
    zsurge(i) = sqrtz(b / dumm1);
    cc = sqrtz(fem::pow2(g) + fem::pow2(b));
    theta = std::atan2(-g, b) * onehaf;
    zcharr = sqrtz(cc / dumm1);
    zchari = zcharr * sinz(theta);
    zcharr = zcharr * cosz(theta);
    theta += pi * onehaf;
    cc = sqrtz(cc * dumm1);
    d9 = cc * sinz(theta);
    vmode = d13 / d9;
    cc = cc * cosz(theta);
    if (metrik == 0) {
      goto statement_137;
    }
    g = g * fmipkm;
    b = b * fmipkm;
    dumm1 = dumm1 * fmipkm;
    vmode = vmode / fmipkm;
    cc = cc * fmipkm;
    d9 = d9 * fmipkm;
    statement_137:
    write(lunit6, "(i5,3x,9e12.5)"), i, g, b, dumm1, zcharr, zchari,
      zsurge(i), vmode, cc;
    distm = -dist;
    if (m < 10 && lastov == 1) {
      write(lunit7, "('-',i1,2a6,12x,4e12.5,' 1',2x,i1)"), i, brname(
        2 * i - 1), brname(2 * i), g, zsurge(i), vmode, distm, m;
    }
    if (m >= 10 && lastov == 1) {
      goto statement_141;
    }
    goto statement_40;
    statement_141:
    if (m == 10) {
      text1 = text2;
    }
    if (m == 11) {
      text1 = text3;
    }
    if (m == 12) {
      text1 = text4;
    }
    if (m == 13) {
      text1 = text5;
    }
    if (m == 14) {
      text1 = text6;
    }
    if (m == 15) {
      text1 = text7;
    }
    if (m == 16) {
      text1 = text8;
    }
    if (m == 17) {
      text1 = text9;
    }
    if (m == 18) {
      text1 = text10;
    }
    if (i <= 9) {
      write(lunit7, "('-',i1,2a6,12x,4e12.5,' 1',2x,a1)"), i, brname(
        2 * i - 1), brname(2 * i), g, zsurge(i), vmode, distm, text1;
    }
    if (i > 9) {
      write(lunit7, "(i2,2a6,12x,4e12.5,' 1',2x,a1)"), i, brname(2 * i - 1),
        brname(2 * i), g, zsurge(i), vmode, distm, text1;
    }
    goto statement_40;
    statement_155:
    write(lunit9, fem::unformatted), d13, ycharm, ychara, alpha, beta;
    if (iprsup >= 1) {
      write(lunit6,
        "(' AT ',e12.5,' Hz,YCHARM,YCHARA,ALPHA,BETA FOR           MODE',i5,"
        "' ARE',5x,4e12.5)"),
        d13, i, ycharm, ychara, alpha, beta;
    }
    if (kexact == 88333) {
      goto statement_40;
    }
    if (itrnsf != 1) {
      goto statement_40;
    }
    {
      write_loop wloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(j, 1, m) {
        wloop, pp1(j, i), pp2(j, i);
      }
    }
    statement_40:;
  }
  if (kexact != 88333) {
    goto statement_119;
  }
  ll = 1;
  FEM_DO_SAFE(j, 1, m) {
    FEM_DO_SAFE(ij, 1, m) {
      tixf(ll) = tir(ij, j);
      work1(ll) = tii(ij, j);
      ll++;
    }
  }
  n9sq = m * m;
  {
    write_loop wloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(k, 1, n9sq) {
      wloop, tixf(k);
    }
    FEM_DO_SAFE(k, 1, n9sq) {
      wloop, work1(k);
    }
  }
  goto statement_9900;
  statement_119:
  if (lastov == 1) {
    write(lunit7, "('$VINTAGE, 0')");
  }
  if (nfreq != 1 && lastov == 39) {
    goto statement_9900;
  }
  FEM_DO_SAFE(i, 1, m) {
    c = cosz(theta2(i));
    d1 = sinz(theta2(i));
    FEM_DO_SAFE(j, 1, m) {
      cc = tir(j, i);
      dd = tii(j, i);
      tir(j, i) = cc * c - dd * d1;
      tii(j, i) = cc * d1 + dd * c;
    }
  }
  //C ***** END OF ROTATION OF TI MATRIX FOR K.C.LEE'S CONST.PARAM.*******  M32, 449
  statement_166:
  write(lunit6,
    "(/,/,/,/,"
    "' EIGENVECTOR MATRIX TI FOR CURRENT TRANSFORMATION I(PHASE)=TI*I(MODE)')");
  write(lunit6, format_39);
  FEM_DO_SAFE(k, 1, m) {
    {
      write_loop wloop(cmn, lunit6, format_9);
      FEM_DO_SAFE(j, 1, m) {
        wloop, tir(k, j);
      }
    }
  }
  write(lunit6, format_60);
  FEM_DO_SAFE(k, 1, m) {
    {
      write_loop wloop(cmn, lunit6, format_9);
      FEM_DO_SAFE(j, 1, m) {
        wloop, tii(k, j);
      }
    }
  }
  FEM_DO_SAFE(i, 1, m) {
    if (lastov == 39) {
      goto statement_161;
    }
    {
      write_loop wloop(cmn, lunit7, format_59);
      FEM_DO_SAFE(j, 1, m) {
        wloop, tir(i, j);
      }
    }
    {
      write_loop wloop(cmn, lunit7, format_59);
      FEM_DO_SAFE(j, 1, m) {
        wloop, tii(i, j);
      }
    }
    goto statement_1204;
    statement_161:
    {
      write_loop wloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(j, 1, m) {
        wloop, tir(i, j), tii(i, j);
      }
    }
    statement_1204:;
  }
  if (lastov == 39) {
    goto statement_9900;
  }
  //C TO GET ZSURGE MATRIX IN PHASE DOMAIN                                  M29.4409
  FEM_DO_SAFE(i, 1, m) {
    c = 1.f / zsurge(i);
    FEM_DO_SAFE(j, 1, m) {
      yzr(i, j) = tir(j, i) * c;
    }
  }
  n = 0;
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(k, 1, i) {
      c = 0.0f;
      FEM_DO_SAFE(j, 1, m) {
        c = c - tir(i, j) * yzr(j, k);
      }
      n++;
      xwc(n) = c;
    }
  }
  redu44(cmn, xwc(1), workr1(1), m, ll0);
  if (kill != 0) {
    goto statement_9200;
  }
  write(lunit6, "(/,' PHASE DOMAIN ZSURGE (REAL; THE IMAG. OF Ti IGNORED)')");
  n = 1;
  FEM_DO_SAFE(i, 1, m) {
    k = n + i - 1;
    {
      write_loop wloop(cmn, lunit6, format_9);
      FEM_DO_SAFE(j, n, k) {
        wloop, xwc(j);
      }
    }
    n += i;
  }
  goto statement_9900;
  statement_9200:
  lstat(18) = nchain;
  lastov = nchain;
  nchain = 51;
  statement_9900:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
cxred2(
  arr_ref<double> a,
  arr_ref<double> c,
  arr_ref<double> b,
  arr_ref<double> d,
  int const& n,
  int const& m) try
{
  a(dimension(1));
  c(dimension(1));
  b(dimension(1));
  d(dimension(1));
  int j = fem::int0;
  double w = fem::double0;
  int ij = fem::int0;
  double h1 = fem::double0;
  double g1 = fem::double0;
  double x = fem::double0;
  int k = fem::int0;
  int ik = fem::int0;
  int i1 = fem::int0;
  int i = fem::int0;
  double h2 = fem::double0;
  double g2 = fem::double0;
  int i2 = fem::int0;
  int L = fem::int0;
  double y = fem::double0;
  //C)    ELIMINATION OF VARIABLES M+1,...N IN SYMMETRIC COMPLEX MATRIX WITHM15.1632
  //C)    A=REAL PART, C=IMAGINARY PART. A AND C ARE                        M15.1633
  //C)    STORED AS TRIANGLE (1 ELEMENT FOR 1.COLUMN,2 FOR 2.COLUMN ETC.).  M15.1634
  //C)    RESULT IS REDUCED MATRIX IN COLUMNS 1,...M IN CASE OF REDUCTION   M15.1635
  //C)    (M UNEQUAL 0) OR NEGATIVE INVERSE MATRIX IN COLUMNS 1,...N IN CASEM15.1636
  //C)    OF INVERSION (M=0).                                               M15.1637
  j = n + 1;
  w = 1.0f;
  if (m > 0) {
    w = -w;
  }
  ij = n * j / 2;
  statement_3:
  j = j - 1;
  if (j == m) {
    return;
  }
  h1 = a(ij);
  g1 = c(ij);
  x = 1.0f / (h1 * h1 + g1 * g1);
  h1 = -h1 * x;
  g1 = g1 * x;
  b(j) = h1;
  d(j) = g1;
  ij = ij - j;
  k = 0;
  ik = 0;
  //C                                   BEGIN K-LOOP                        M14.3913
  statement_4:
  ik += k;
  i1 = ik + 1;
  k++;
  if (k > n) {
    goto statement_3;
  }
  if (k < j) {
    goto statement_9;
  }
  if (w < 0.f) {
    goto statement_3;
  }
  if (k == j) {
    goto statement_7;
  }
  i = ik + j;
  statement_5:
  h2 = a(i);
  g2 = c(i);
  b(k) = h2 * h1 - g2 * g1;
  d(k) = h2 * g1 + g2 * h1;
  //C                                   BEGIN I-LOOP                        M14.3926
  i2 = ik + k;
  L = 0;
  FEM_DO_SAFE(i, i1, i2) {
    L++;
    x = b(L);
    y = d(L);
    a(i) += x * h2 - y * g2;
    c(i) += x * g2 + y * h2;
  }
  if (k < j) {
    goto statement_4;
  }
  i = ik + j;
  a(i) = b(k);
  c(i) = d(k);
  goto statement_4;
  //C                                   END I-LOOP                          M14.3940
  statement_7:
  i = ij;
  FEM_DO_SAFE(L, 1, j) {
    i++;
    c(i) = d(L);
    a(i) = b(L);
  }
  goto statement_4;
  //C                                   END K-LOOP                          M14.3947
  statement_9:
  i = ij + k;
  goto statement_5;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
symm(
  common& cmn,
  arr_ref<double> p,
  arr_ref<double> z,
  double const& identifier_switch,
  int const& kcirct,
  int& kk) try
{
  p(dimension(1));
  z(dimension(1));
  double& onehaf = cmn.onehaf;
  //
  arr_1d<3, double> fr(fem::fill0);
  arr_1d<3, double> fi(fem::fill0);
  int ki = fem::int0;
  int j = fem::int0;
  int kold = fem::int0;
  int L = fem::int0;
  int k = fem::int0;
  int l3 = fem::int0;
  int l2 = fem::int0;
  int i = fem::int0;
  double f1 = fem::double0;
  double f2 = fem::double0;
  arr_2d<3, 3, double> ar(fem::fill0);
  arr_2d<3, 3, double> ai(fem::fill0);
  int m = fem::int0;
  if (kcirct == 2) {
    goto statement_100;
  }
  fr(1) = cmn.unity;
  fi(1) = 0.f;
  fr(2) = -onehaf;
  fi(2) = cmn.valu7;
  fr(3) = -onehaf;
  fi(3) = -fi(2);
  kk = 0;
  statement_63:
  ki = kk * (kk + 1) / 2;
  j = ki + kk;
  kold = kk;
  kk += 3;
  if (kk > kcirct) {
    goto statement_79;
  }
  statement_75:
  L = ki + 1;
  k = 0;
  statement_64:
  k++;
  if (ki == j) {
    goto statement_76;
  }
  statement_65:
  l3 = L + 2;
  statement_66:
  l2 = L + 1;
  statement_67:
  FEM_DO_SAFE(i, 1, 3) {
    f1 = p(L) + fr(i) * (p(l2) + p(l3));
    f2 = fi(i) * (p(l2) - p(l3));
    if (identifier_switch < 0.0f) {
      goto statement_68;
    }
    f1 += fi(i) * (z(l3) - z(l2));
    f2 += z(L) + fr(i) * (z(l2) + z(l3));
    statement_68:
    ar(i, k) = f1;
    ai(i, k) = f2;
  }
  if (k == 3) {
    goto statement_69;
  }
  L += kold + k;
  goto statement_64;
  statement_69:
  L = ki;
  k = 0;
  statement_70:
  k++;
  FEM_DO_SAFE(i, 1, 3) {
    m = L + i;
    if (ki < j) {
      goto statement_71;
    }
    if (i > k) {
      goto statement_73;
    }
    statement_71:
    p(m) = (ar(i, 1) + fr(k) * (ar(i, 2) + ar(i, 3)) + fi(k) * (ai(i,
      3) - ai(i, 2))) / 3.0f;
    z(m) = (ai(i, 1) + fr(k) * (ai(i, 2) + ai(i, 3)) + fi(k) * (ar(i,
      2) - ar(i, 3))) / 3.0f;
  }
  statement_73:
  if (k == 3) {
    goto statement_74;
  }
  L += kold + k;
  goto statement_70;
  statement_74:
  ki += 3;
  if (ki > j) {
    goto statement_63;
  }
  goto statement_75;
  statement_76:
  if (k == 3) {
    goto statement_65;
  }
  l2 = j + kk - 1;
  l3 = l2 + kk;
  if (k == 2) {
    goto statement_66;
  }
  l3 = l3 - 1;
  goto statement_67;
  statement_79:
  kk = kk - 3;
  //C                                   END OF SYMMETRICAL COMPONENTS MATRIXM14.4010
  return;
  statement_100:
  f1 = (p(1) + p(3)) * onehaf;
  f2 = p(2);
  p(2) = (p(1) - p(3)) * onehaf;
  p(1) = f1 + f2;
  p(3) = f1 - f2;
  p(5) = p(3);
  kk = 2;
  if (identifier_switch < 0.f) {
    return;
  }
  f1 = (z(1) + z(3)) * onehaf;
  f2 = z(2);
  z(2) = (z(1) - z(3)) * onehaf;
  z(1) = f1 + f2;
  z(3) = f1 - f2;
  z(5) = z(3);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
undrfl(
  int& n1)
{
  //C     DUMMY IMITATION OF ONTARIO HYDRO UNIVAC MODULE.                   M33.2368
  n1 = -7654;
}

void
skin(
  common& cmn,
  double const& s,
  double const& r,
  double const& freq,
  double& rf,
  double& xf) try
{
  common_write write(cmn);
  double& tenm6 = cmn.tenm6;
  double& unity = cmn.unity;
  double& onehaf = cmn.onehaf;
  const auto& fbe = cmn.fbe;
  const auto& fbed = cmn.fbed;
  const auto& fke = cmn.fke;
  const auto& fked = cmn.fked;
  double& sqrt2 = cmn.sqrt2;
  double& aaa1 = cmn.aaa1;
  //
  double vsmall = fem::double0;
  int jjj = fem::int0;
  double s2 = fem::double0;
  double s3 = fem::double0;
  double r2 = fem::double0;
  double qremb = fem::double0;
  double q2 = fem::double0;
  auto& lunit6 = cmn.lunit6;
  double x = fem::double0;
  double x2 = fem::double0;
  int iback = fem::int0;
  double berd = fem::double0;
  double a = fem::double0;
  double beid = fem::double0;
  double b = fem::double0;
  double gerd = fem::double0;
  double aremb = fem::double0;
  double geid = fem::double0;
  double bremb = fem::double0;
  double xremb = fem::double0;
  double ber = fem::double0;
  double g = fem::double0;
  double bei = fem::double0;
  double h = fem::double0;
  double e = fem::double0;
  double f = fem::double0;
  double ger = fem::double0;
  double gei = fem::double0;
  double e2f2 = fem::double0;
  double z = fem::double0;
  int ialt = fem::int0;
  int k = fem::int0;
  double xl = fem::double0;
  double thetar = fem::double0;
  double thetai = fem::double0;
  double phir = fem::double0;
  double phii = fem::double0;
  double fr = fem::double0;
  double fi = fem::double0;
  double gr = fem::double0;
  double gi = fem::double0;
  vsmall = 1.e-37f;
  undrfl(jjj);
  s2 = s * s;
  s3 = (unity - s2) * r;
  r2 = freq * cmn.valu8 / s3;
  rf = r;
  xf = 0.f;
  if (r2 == 0.f) {
    goto statement_9900;
  }
  qremb = 0.0f;
  if (s < tenm6) {
    goto statement_5;
  }
  q2 = r2 * s2;
  if (s2 < 0.8f) {
    goto statement_11;
  }
  if (q2 <= 64.0f && r2 > 64.0f) {
    write(lunit6,
      "(' RESULTS FROM SUBROUTINE SKIN UNRELIABLE WITH MQ**2=',f9.4,"
      "' AND MR**2=',f9.4)"),
      q2, r2;
  }
  statement_11:
  if (q2 > 64.0f) {
    qremb = sqrtz(q2) * sqrt2;
  }
  x = sqrtz(q2);
  x2 = x * x / 64.0f;
  iback = 2;
  if (x2 <= unity) {
    goto statement_100;
  }
  goto statement_200;
  statement_4:
  a = -berd;
  b = -beid;
  aremb = gerd;
  bremb = geid;
  xremb = x;
  statement_5:
  x = sqrtz(r2);
  x2 = x * x / 64.0f;
  iback = 1;
  if (x2 <= unity) {
    goto statement_100;
  }
  goto statement_200;
  statement_6:
  g = ber;
  h = bei;
  e = berd;
  f = beid;
  if (s < tenm6) {
    goto statement_7;
  }
  g = a * ger - b * gei + aremb * ber - bremb * bei;
  h = a * gei + b * ger + aremb * bei + bremb * ber;
  e = a * gerd - b * geid + aremb * berd - bremb * beid;
  f = a * geid + b * gerd + aremb * beid + bremb * berd;
  statement_7:
  e2f2 = fem::pow2(e) + fem::pow2(f);
  s2 = x * s3 * onehaf / e2f2;
  if (cmn.iprsup >= 1) {
    write(lunit6, "(' E, F,  E2F2, AND S2 AT 320',4e16.6)"), e, f, e2f2, s2;
  }
  rf = (-h * e + g * f) * s2;
  xf = (g * e + h * f) * s2;
  goto statement_9900;
  //C      CALCULATION OF KELVIN-FUNCTIONS FOR ARGUMENT.LE.8.               M14.4066
  statement_100:
  z = x2;
  ber = unity;
  bei = 0.0f;
  berd = 0.0f;
  beid = onehaf;
  gerd = 0.0f;
  geid = cmn.valu9;
  ger = -cmn.valu10;
  gei = 0.0f;
  ialt = 1;
  FEM_DO_SAFE(k, 1, 14) {
    if (ialt == 1) {
      goto statement_101;
    }
    ber += fbe(k) * z;
    beid += fbed(k) * z;
    if (s < tenm6) {
      goto statement_102;
    }
    geid += fked(k) * z;
    if (iback == 2) {
      goto statement_102;
    }
    ger += fke(k) * z;
    goto statement_102;
    statement_101:
    bei += fbe(k) * z;
    berd += fbed(k) * z;
    if (s < tenm6) {
      goto statement_102;
    }
    gerd += fked(k) * z;
    if (iback == 2) {
      goto statement_102;
    }
    gei += fke(k) * z;
    statement_102:
    z = z * x2;
    ialt = -ialt;
  }
  beid = beid * x;
  berd = berd * x;
  if (s < tenm6) {
    goto statement_104;
  }
  xl = alogz(x * onehaf);
  gerd = -xl * berd - ber / x + beid * aaa1 + x * gerd;
  geid = -xl * beid - bei / x - berd * aaa1 + x * geid;
  if (iback == 2) {
    goto statement_104;
  }
  ger += -xl * ber + bei * aaa1;
  gei += -xl * bei - ber * aaa1;
  statement_104:
  switch (iback) {
    case 1: goto statement_6;
    case 2: goto statement_4;
    default: break;
  }
  //C      CALCULATIONS OF KELVIN-FUNCTIONS FOR ARGUMENT.GT.8.              M14.4104
  statement_200:
  x2 = 8.0f / x;
  z = x2;
  ber = 0.0f;
  bei = -cmn.valu11;
  berd = ber;
  beid = bei;
  ger = unity / sqrt2;
  gei = ger;
  gerd = ger;
  geid = gei;
  ialt = 1;
  FEM_DO_SAFE(k, 1, 6) {
    thetar = fbe(k + 14) * z;
    thetai = fbed(k + 14) * z;
    phir = fke(k + 14) * z;
    phii = fked(k + 14) * z;
    ber += thetar;
    bei += thetai;
    ger += phir;
    gei += phii;
    if (ialt == 1) {
      goto statement_201;
    }
    berd += thetar;
    beid += thetai;
    gerd += phir;
    geid += phii;
    goto statement_202;
    statement_201:
    berd = berd - thetar;
    beid = beid - thetai;
    gerd = gerd - phir;
    geid = geid - phii;
    statement_202:
    ialt = -ialt;
    z = z * x2;
  }
  xl = x * sqrt2;
  if (qremb < 1.0f) {
    goto statement_204;
  }
  xl = xl - qremb;
  statement_204:
  thetar = -xl + berd;
  thetai = -xl + beid;
  z = sqrtz(x);
  x2 = cmn.valu12 / z;
  z = cmn.valu13 / z * expz(thetar);
  fr = z * cosz(thetai);
  fi = z * sinz(thetai);
  x2 = x2 * expz(ber);
  thetar = x2 * cosz(bei);
  thetai = x2 * sinz(bei);
  z = -fr * gerd + fi * geid;
  geid = -fr * geid - fi * gerd;
  gerd = z;
  z = cmn.aaa2 * expz(-qremb);
  gr = z * sinz(qremb);
  gi = z * cosz(qremb);
  berd = thetar * ger - thetai * gei + gerd * gr - geid * gi;
  beid = thetar * gei + thetai * ger + gerd * gi + geid * gr;
  ger = fr;
  gei = fi;
  ber = thetar + ger * gr - gei * gi;
  bei = thetai + ger * gi + gei * gr;
  switch (iback) {
    case 1: goto statement_6;
    case 2: goto statement_4;
    default: break;
  }
  statement_9900:
  if (jjj == 3) {
    z = vsmall;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
wrte(
  common& cmn,
  arr_cref<double> p,
  int const& i2,
  int const& i3,
  int const& iflag,
  int const& L,
  double const& unit,
  int const& lunit6) try
{
  p(dimension(1));
  common_write write(cmn);
  int j = fem::int0;
  int i = fem::int0;
  arr_1d<10, double> r(fem::fill0);
  j = 0;
  FEM_DO_SAFE(i, i2, i3) {
    j++;
    r(j) = p(i) * unit;
  }
  switch (iflag) {
    case 1: goto statement_1;
    case 2: goto statement_2;
    case 3: goto statement_3;
    default: break;
  }
  statement_1:
  {
    write_loop wloop(cmn, lunit6, "('0',3x,9e14.5)");
    FEM_DO_SAFE(i, 1, j) {
      wloop, r(i);
    }
  }
  return;
  statement_2:
  {
    write_loop wloop(cmn, lunit6, "(4x,9e14.5)");
    FEM_DO_SAFE(i, 1, j) {
      wloop, r(i);
    }
  }
  return;
  statement_3:
  {
    write_loop wloop(cmn, lunit6, "('0',i3,9e14.5)");
    wloop, L;
    FEM_DO_SAFE(i, 1, j) {
      wloop, r(i);
    }
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct output_save
{
  fem::str<8> txtkm;
  fem::str<8> txtmi;

  output_save() :
    txtkm(fem::char0),
    txtmi(fem::char0)
  {}
};

void
output(
  common& cmn,
  int const& metrik,
  arr_cref<double> p,
  arr_cref<double> z,
  double const& identifier_switch,
  int const& kmax,
  int const& is,
  int const& k2) try
{
  FEM_CMN_SVE(output);
  p(dimension(1));
  z(dimension(1));
  common_write write(cmn);
  int& ll1 = cmn.ll1;
  int& ll2 = cmn.ll2;
  int& ll3 = cmn.ll3;
  //
  fem::str<8>& txtkm = sve.txtkm;
  fem::str<8>& txtmi = sve.txtmi;
  if (is_called_first_time) {
    txtmi = "MILES ";
    txtkm = "  KM  ";
  }
  fem::str<8> txtunt = fem::char0;
  double unit = fem::double0;
  double check = fem::double0;
  auto& lunit6 = cmn.lunit6;
  int k = fem::int0;
  int kk = fem::int0;
  int ki = fem::int0;
  int icount = fem::int0;
  int i2 = fem::int0;
  int i3 = fem::int0;
  int L = fem::int0;
  static const char* format_350 =
    "(' SUM OF TWO EQUAL SHUNT ADMITTANCES AT BOTH TERMINALS, OR ITS INVERSE, "
    "PRINTED TO CONFORM TO TRANSIENTS PROGRAM INPUT FORMAT')";
  if (cmn.jpralt == 0) {
    return;
  }
  ll1 = 1;
  ll2 = 2;
  ll3 = 3;
  txtunt = txtmi;
  unit = 1.0f;
  if (metrik == 1) {
    txtunt = txtkm;
  }
  if (metrik == 1) {
    unit = 5280.f * 12.f * 2.54e0 / 100000.e0;
  }
  check = identifier_switch;
  write(lunit6, "('0')");
  switch (is) {
    case 1: goto statement_305;
    case 2: goto statement_306;
    case 3: goto statement_307;
    case 4: goto statement_308;
    case 5: goto statement_332;
    case 6: goto statement_333;
    case 7: goto statement_336;
    case 8: goto statement_337;
    case 9: goto statement_340;
    case 10: goto statement_341;
    default: break;
  }
  statement_305:
  write(lunit6,
    "('0',12x,'INVERTED CAPACITANCE MATRIX (DARAF-',a4,')')"), txtunt;
  goto statement_5;
  statement_306:
  write(lunit6, "('0',14x,'INVERTED SUSCEPTANCE MATRIX (OHM-',a4,')')"), txtunt;
  goto statement_5;
  statement_307:
  write(lunit6, "('0',21x,'CAPACITANCE MATRIX (FARAD/',a4,')')"), txtunt;
  unit = 1.0f / unit;
  goto statement_5;
  statement_308:
  write(lunit6, "('0',23x,'SUSCEPTANCE MATRIX (MHO/',a4,')')"), txtunt;
  unit = 1.0f / unit;
  goto statement_5;
  statement_332:
  write(lunit6, "('0',16x,'INVERTED IMPEDANCE MATRIX (MHO-',a4,')')"), txtunt;
  goto statement_5;
  statement_333:
  write(lunit6, "('0',25x,'IMPEDANCE MATRIX (OHM/',a4,')')"), txtunt;
  unit = 1.0f / unit;
  goto statement_5;
  statement_336:
  write(lunit6, "('0',19x,'TRANSFER ADMITTANCE MATRIX (MHOS)')");
  goto statement_5;
  statement_337:
  write(lunit6, "('0',16x,'TWICE SHUNT ADMITTANCE MATRIX (MHOS)')");
  goto statement_5;
  statement_340:
  write(lunit6, "('0',20x,'TRANSFER IMPEDANCE MATRIX (OHMS)')");
  goto statement_5;
  statement_341:
  write(lunit6, "('0',11x,'ONE HALF OF SHUNT IMPEDANCE MATRIX (OHMS)')");
  statement_5:
  switch (k2) {
    case 1: goto statement_320;
    case 2: goto statement_321;
    case 3: goto statement_322;
    default: break;
  }
  statement_320:
  write(lunit6, "('+',53x,'FOR THE SYSTEM OF PHYSICAL CONDUCTORS')");
  goto statement_6;
  statement_321:
  write(lunit6, "('+',53x,'FOR THE SYSTEM OF EQUIVALENT PHASE CONDUCTORS')");
  goto statement_6;
  statement_322:
  write(lunit6,
    "('+',53x,"
    "'FOR THE SYMMETRICAL COMPONENTS OF THE EQUIVALENT PHASE CONDUCTORS')");
  statement_6:
  if (k2 == 3) {
    goto statement_3;
  }
  write(lunit6,
    "(' ',30x,'ROWS AND COLUMNS PROCEED IN SAME ORDER AS SORTED INPUT')");
  statement_4:
  k = 0;
  if (is == 8) {
    write(lunit6, format_350);
  }
  if (is == 10) {
    write(lunit6, format_350);
  }
  kk = 0;
  ki = 0;
  statement_1:
  k++;
  if (k > kmax) {
    return;
  }
  icount = 0;
  i2 = ki + 1;
  i3 = i2 + 8;
  ki += k;
  statement_7:
  if (i3 > ki) {
    i3 = ki;
  }
  if (icount == 0) {
    goto statement_8;
  }
  wrte(cmn, p(1), i2, i3, ll1, L, unit, lunit6);
  statement_10:
  if (check > 0.0f) {
    wrte(cmn, z(1), i2, i3, ll2, L, unit, lunit6);
  }
  if (i3 == ki) {
    goto statement_1;
  }
  i2 = i3 + 1;
  i3 = i2 + 8;
  goto statement_7;
  statement_8:
  icount = 1;
  if (k2 == 3) {
    goto statement_20;
  }
  L = k;
  statement_21:
  wrte(cmn, p(1), i2, i3, ll3, L, unit, lunit6);
  goto statement_10;
  statement_3:
  if (kmax == 2) {
    goto statement_400;
  }
  write(lunit6,
    "(' ',25x,"
    "'ROWS PROCEED IN SEQUENCE 0,1,2, 0,1,2 ETC. AND COLUMNS PROCEED IN SEQUEN"
    "CE 0,2,1, 0,2,1 ETC.')");
  goto statement_4;
  statement_400:
  write(lunit6,
    "(' ',38x,"
    "'THIS IS A TWO-PHASE LINE. ROWS AND COLUMNS PROCEED IN SEQUENCE 0,1')");
  if (is <= 4) {
    check = -1.0f;
  }
  goto statement_4;
  statement_20:
  L = kk;
  kk++;
  if (kk == 3) {
    kk = 0;
  }
  goto statement_21;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
outspc(
  common& cmn,
  arr_cref<double> p,
  arr_cref<double> z,
  int const& kmax,
  int const& metrik,
  double const& fmipkm) try
{
  p(dimension(1));
  z(dimension(1));
  common_write write(cmn);
  double& onehaf = cmn.onehaf;
  double& valu7 = cmn.valu7;
  //
  auto& lunit6 = cmn.lunit6;
  double aa = fem::double0;
  double bb = fem::double0;
  double a2 = fem::double0;
  double b2 = fem::double0;
  double a1 = fem::double0;
  double b1 = fem::double0;
  double a0 = fem::double0;
  double b0 = fem::double0;
  double c0 = fem::double0;
  double c1 = fem::double0;
  double c2 = fem::double0;
  if (kmax == 4) {
    goto statement_999;
  }
  write(lunit6,
    "(/,' SPECIAL OUTPUT FOR MUTUALS NOT APPLICABLE TO THIS CASE')");
  return;
  statement_999:
  aa = valu7 * (z(8) - z(9));
  bb = -valu7 * (p(8) - p(9));
  a2 = p(7) - onehaf * (p(8) + p(9));
  b2 = z(7) - onehaf * (z(8) + z(9));
  a1 = a2 + aa;
  b1 = b2 + bb;
  a2 = a2 - aa;
  b2 = b2 - bb;
  a0 = p(7) + p(8) + p(9);
  b0 = z(7) + z(8) + z(9);
  c0 = sqrtz(fem::pow2(a0) + fem::pow2(b0));
  c1 = sqrtz(fem::pow2(a1) + fem::pow2(b1));
  c2 = sqrtz(fem::pow2(a2) + fem::pow2(b2));
  if (metrik == 1) {
    goto statement_1120;
  }
  write(lunit6,
    "(' MUTUAL IMPEDANCE  POSITIVE=',f8.5,' OHM/MILE  NEGATIVE=',f8.5,"
    "' OHM/MILE  ZERO=',f8.4,' OHM/MILE')"),
    c1, c2, c0;
  return;
  statement_1120:
  c1 = c1 * fmipkm;
  c2 = c2 * fmipkm;
  c0 = c0 * fmipkm;
  write(lunit6,
    "(' MUTUAL IMPEDANCE  POSITIVE=',f8.5,' OHM/KM    NEGATIVE=',f8.5,"
    "' OHM/KM    ZERO=',f8.4,' OHM/KM  ')"),
    c1, c2, c0;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct guts44_save
{
  fem::str<8> englis;
  fem::str<8> fmetrc;
  int mrr;
  int nrp;
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  fem::str<8> text5;
  fem::str<8> text6;
  fem::str<8> text7;
  fem::str<8> text8;
  fem::str<8> text9;

  guts44_save() :
    englis(fem::char0),
    fmetrc(fem::char0),
    mrr(fem::int0),
    nrp(fem::int0),
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text5(fem::char0),
    text6(fem::char0),
    text7(fem::char0),
    text8(fem::char0),
    text9(fem::char0)
  {}
};

void
guts44(
  common& cmn,
  arr_cref<double> array,
  arr_ref<double> xwc,
  arr_ref<double> xwy,
  arr_ref<double, 2> yzr,
  arr_ref<double, 2> yzi,
  arr_ref<double, 2> tii,
  arr_ref<double, 2> tir,
  double& tvi,
  double& tvr,
  arr_ref<double> er,
  arr_ref<double> ei,
  arr_ref<double> theta2,
  arr_ref<double> xtir,
  arr_ref<double> xtii,
  arr_ref<double> zsurge,
  arr_ref<double> dummi,
  arr_ref<double> dummr,
  arr_ref<double> tixf,
  arr_ref<double> work1,
  int const& ndim,
  int const& ntri,
  int const& nsqr2) try
{
  FEM_CMN_SVE(guts44);
  array(dimension(1));
  xwc(dimension(ntri));
  xwy(dimension(ntri));
  yzr(dimension(ndim, ndim));
  yzi(dimension(ndim, ndim));
  tii(dimension(ndim, ndim));
  tir(dimension(ndim, ndim));
  er(dimension(ndim));
  ei(dimension(ndim));
  theta2(dimension(ndim));
  xtir(dimension(ndim));
  xtii(dimension(ndim));
  zsurge(dimension(ndim));
  dummi(dimension(ndim));
  dummr(dimension(ndim));
  tixf(dimension(nsqr2));
  work1(dimension(nsqr2));
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& blank = cmn.blank;
  auto& texta6 = cmn.texta6;
  const auto& date1= cmn.date1;
  const auto& tclock= cmn.tclock;
  const auto& abuff = cmn.abuff;
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  double& epsiln = cmn.epsiln;
  double& twopi = cmn.twopi;
  double& omega = cmn.omega;
  double& fminfs = cmn.fminfs;
  double& fmaxfs = cmn.fmaxfs;
  double& tenm6 = cmn.tenm6;
  double& unity = cmn.unity;
  double& onehaf = cmn.onehaf;
  double& fltinf = cmn.fltinf;
  auto& voltbc = cmn.voltbc;
  const auto& flstat = cmn.flstat;
  auto& lunit1 = cmn.lunit1;
  auto& lunit2 = cmn.lunit2;
  auto& lunit3 = cmn.lunit3;
  int lunit5 = cmn.lunit5;
  auto& lunit7 = cmn.lunit7;
  auto& lunit9 = cmn.lunit9;
  auto& lunt13 = cmn.lunt13;
  auto& nright = cmn.nright;
  auto& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  int& icheck = cmn.icheck;
  int& ipunch = cmn.ipunch;
  int& izero = cmn.izero;
  int& lastov = cmn.lastov;
  int& ktab = cmn.ktab;
  int& ialter = cmn.ialter;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  auto& p = cmn.p;
  auto& z = static_cast<common_c44b03&>(cmn).z;
  auto& ic = cmn.ic;
  auto& r = static_cast<common_c44b05&>(cmn).r;
  auto& x = static_cast<common_c44b08&>(cmn).x;
  auto& dz = cmn.dz;
  auto& gmd = cmn.gmd;
  auto& y = cmn.y;
  auto& tb2 = cmn.tb2;
  auto& itb3 = cmn.itb3;
  auto& workr1 = cmn.workr1;
  auto& workr2 = cmn.workr2;
  auto& text = cmn.text;
  auto& gd = cmn.gd;
  auto& bd = cmn.bd;
  auto& yd = cmn.yd;
  auto& itbic = cmn.itbic;
  auto& tbr = cmn.tbr;
  auto& tbd = cmn.tbd;
  auto& tbg = cmn.tbg;
  auto& tbx = cmn.tbx;
  auto& tby = cmn.tby;
  auto& tbtb2 = cmn.tbtb2;
  auto& itbtb3 = cmn.itbtb3;
  auto& tbtext = cmn.tbtext;
  auto& bcars = cmn.bcars;
  auto& ccars = cmn.ccars;
  auto& dcars = cmn.dcars;
  auto& fbe = cmn.fbe;
  auto& brname = cmn.brname;
  auto& fbed = cmn.fbed;
  auto& fke = cmn.fke;
  auto& fked = cmn.fked;
  double& pi = static_cast<common_com44&>(cmn).pi;
  double& picon = cmn.picon;
  double& sqrt2 = cmn.sqrt2;
  double& valu1 = cmn.valu1;
  double& valu2 = cmn.valu2;
  double& valu3 = cmn.valu3;
  double& valu4 = cmn.valu4;
  double& valu5 = cmn.valu5;
  double& valu6 = cmn.valu6;
  double& valu7 = cmn.valu7;
  double& valu9 = cmn.valu9;
  double& valu10 = cmn.valu10;
  double& corchk = cmn.corchk;
  int& ll0 = cmn.ll0;
  int& ll1 = cmn.ll1;
  int& ll2 = cmn.ll2;
  int& ll3 = cmn.ll3;
  int& ll5 = cmn.ll5;
  int& ll6 = cmn.ll6;
  int& ll7 = cmn.ll7;
  int& ll8 = cmn.ll8;
  int& ll9 = cmn.ll9;
  int& ll10 = cmn.ll10;
  int& lphase = cmn.lphase;
  int& lphpl1 = cmn.lphpl1;
  int& lgdbd = cmn.lgdbd;
  int& jpralt = cmn.jpralt;
  int& nfreq = cmn.nfreq;
  auto& volti = static_cast<common_volpri&>(cmn).volti_50;
  auto& voltk = static_cast<common_volpri&>(cmn).voltk_50;
  int& kexact = cmn.kexact;
  //
  fem::str<8>& englis = sve.englis;
  fem::str<8>& fmetrc = sve.fmetrc;
  int& mrr = sve.mrr;
  int& nrp = sve.nrp;
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  fem::str<8>& text7 = sve.text7;
  fem::str<8>& text8 = sve.text8;
  fem::str<8>& text9 = sve.text9;
  if (is_called_first_time) {
    text1 = "CHANGE";
    text2 = "BRANCH";
    text3 = "FREQUE";
    text4 = "SPECIA";
    text5 = "L DOUB";
    text6 = "UNTRAN";
    text7 = "SPOSED";
    text8 = "TRANSP";
    text9 = "OSED  ";
    fmetrc = "METRIC";
    englis = "ENGLIS";
    nrp = 0;
    mrr = 0;
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int mfrqpr = fem::int0;
  int nfqpl1 = fem::int0;
  int l5save = fem::int0;
  int ldisfr = fem::int0;
  int metrik = fem::int0;
  double finpcm = fem::double0;
  double ftpm = fem::double0;
  double fmipkm = fem::double0;
  double d8 = fem::double0;
  double fspac = fem::double0;
  double valu14 = fem::double0;
  int liu = fem::int0;
  int nbundl = fem::int0;
  int i = fem::int0;
  int isn = fem::int0;
  double d1 = fem::double0;
  int m = fem::int0;
  int mspedb = fem::int0;
  int muntrn = fem::int0;
  int mtrnsp = fem::int0;
  int n1 = fem::int0;
  arr_1d<14, fem::str<8> > bufsem(fem::fill0);
  int j = fem::int0;
  int ik = fem::int0;
  double h1 = fem::double0;
  double h2 = fem::double0;
  double d9 = fem::double0;
  int i3 = fem::int0;
  double d11 = fem::double0;
  double oon = fem::double0;
  int i4 = fem::int0;
  double xx = fem::double0;
  double yy = fem::double0;
  double angl = fem::double0;
  double dangl = fem::double0;
  double radius = fem::double0;
  double d9r = fem::double0;
  int k = fem::int0;
  int jb = fem::int0;
  int ktot = fem::int0;
  int kcirct = fem::int0;
  int i1 = fem::int0;
  int ip = fem::int0;
  int kfull = fem::int0;
  int iprint = fem::int0;
  int ntol = fem::int0;
  double rearth = fem::double0;
  double freq = fem::double0;
  double corr = fem::double0;
  arr_1d<16, int> jprmat(fem::fill0);
  int iw = fem::int0;
  double dist = fem::double0;
  int isegm = fem::int0;
  int mutual = fem::int0;
  int ips = fem::int0;
  int imodal = fem::int0;
  int itrnsf = fem::int0;
  double conduc = fem::double0;
  double distsv = fem::double0;
  double gmode = fem::double0;
  int jspecl = fem::int0;
  int j5out = fem::int0;
  int j8out = fem::int0;
  int j2out = fem::int0;
  int j4out = fem::int0;
  int j6out = fem::int0;
  int j9out = fem::int0;
  int j17 = fem::int0;
  int jj = fem::int0;
  int kkk = fem::int0;
  double factor = fem::double0;
  double fdecad = fem::double0;
  int iii = fem::int0;
  double d13 = fem::double0;
  int nmode = fem::int0;
  double rtio = fem::double0;
  double pkkk = fem::double0;
  int idist = fem::int0;
  int j56 = fem::int0;
  double f1 = fem::double0;
  double f2 = fem::double0;
  double x1 = fem::double0;
  double y1 = fem::double0;
  double rj = fem::double0;
  double yj = fem::double0;
  double xj = fem::double0;
  double dj = fem::double0;
  double gmdj = fem::double0;
  double dx = fem::double0;
  double r1 = fem::double0;
  int j3 = fem::int0;
  double identifier_switch = fem::double0;
  int i2 = fem::int0;
  int k2 = fem::int0;
  int kk = fem::int0;
  int L = fem::int0;
  int kp = fem::int0;
  int imax = fem::int0;
  double g1 = fem::double0;
  int ix = fem::int0;
  double xm = fem::double0;
  double xs = fem::double0;
  double rm = fem::double0;
  double s = fem::double0;
  double z1 = fem::double0;
  double zl = fem::double0;
  double s1 = fem::double0;
  double c1 = fem::double0;
  double cs = fem::double0;
  double sn = fem::double0;
  double phi = fem::double0;
  int m5 = fem::int0;
  double error = fem::double0;
  int k5 = fem::int0;
  int i5 = fem::int0;
  double deltap = fem::double0;
  double deltaq = fem::double0;
  double s2 = fem::double0;
  double c2 = fem::double0;
  double distkm = fem::double0;
  int n8 = fem::int0;
  int kount = fem::int0;
  int n5 = fem::int0;
  int n12 = fem::int0;
  int idebug = fem::int0;
  double rzero = fem::double0;
  double xzero = fem::double0;
  double rpos = fem::double0;
  double xpos = fem::double0;
  double zo = fem::double0;
  double yzero = fem::double0;
  double zso = fem::double0;
  double ypos = fem::double0;
  double zs1 = fem::double0;
  double zoang = fem::double0;
  double z1ang = fem::double0;
  double propo = fem::double0;
  double prop1 = fem::double0;
  double zsodrg = fem::double0;
  double zs1drg = fem::double0;
  double d2 = fem::double0;
  double alphao = fem::double0;
  double alpha1 = fem::double0;
  double beto = fem::double0;
  double bet1 = fem::double0;
  double rdiag = fem::double0;
  double xdiag = fem::double0;
  double roff = fem::double0;
  double xoff = fem::double0;
  int n55 = fem::int0;
  double rcoup = fem::double0;
  double xcoup = fem::double0;
  int jm = fem::int0;
  int jp = fem::int0;
  double zmmag = fem::double0;
  double zmang = fem::double0;
  double ymmag = fem::double0;
  double ymang = fem::double0;
  double rzero1 = fem::double0;
  double rpos1 = fem::double0;
  double xzero1 = fem::double0;
  double xpos1 = fem::double0;
  double yzero1 = fem::double0;
  double ypos1 = fem::double0;
  double vol = fem::double0;
  double v1l = fem::double0;
  double waveo = fem::double0;
  double wave1 = fem::double0;
  int n9sq = fem::int0;
  double temp = fem::double0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  double cdiag = fem::double0;
  double coff = fem::double0;
  double ccoup = fem::double0;
  double zero = fem::double0;
  double czero = fem::double0;
  double cpos = fem::double0;
  int icount = fem::int0;
  int isw = fem::int0;
  int j1516 = fem::int0;
  double distm = fem::double0;
  int isec = fem::int0;
  double deltad = fem::double0;
  double deltam = fem::double0;
  int kcir2 = fem::int0;
  int l4 = fem::int0;
  int l1 = fem::int0;
  int l2 = fem::int0;
  int l3 = fem::int0;
  int n2 = fem::int0;
  static const char* format_11 =
    "(i3,f5.4,f8.5,i2,2f8.5,3f8.3,f8.5,f6.2,a6,i2)";
  static const char* format_13015 = "(3e16.8)";
  static const char* format_140 = "('-',i1,2a6,12x,4e12.5,' 1',2x)";
  static const char* format_1475 = "('-',i1,2a6)";
  static const char* format_22 =
    "(1x,i5,i8,2f14.5,i9,f22.6,f13.5,2f13.3,6x,a6)";
  static const char* format_228 = "('$VINTAGE, 1')";
  static const char* format_29 = "('$VINTAGE, 0')";
  static const char* format_3004 =
    "('0',6x,'-----------------ZERO SEQUENCE-----------------',13x,"
    "'---------------POSITIVE SEQUENCE---------------',/,4x,'ALPHA',8x,'BETA',"
    "8x,'R',8x,'L(MILLI-',4x,'C(MICRO-',6x,'ALPHA',8x,'BETA',8x,'R',8x,"
    "'L(MILLI-',4x,'C(MICRO-',4x,'FREQUENCY',/,"
    "' NEPER/MILE  RADIAN/MILE  OHM/MILE  HENRY/MILE) FARAD/MILE)',"
    "'  NEPER/MILE  RADIAN/MILE  OHM/MILE   HENRY/MILE) FARAD/MILE)',5x,'HZ')";
  static const char* format_4230 = "(13a6,a2)";
  static const char* format_4281 = "(a3)";
  static const char* format_4286 = "(3x,a5)";
  static const char* format_4292 = "(8x,2a4)";
  static const char* format_4297 = "(16x,a2)";
  static const char* format_4306 = "(18x,2a4)";
  static const char* format_4313 = "(26x,2a4)";
  static const char* format_9475 = "(i2,2a6)";
  //C 9-PHASE AS LIMIT FOR LMFS TEST
  //C
  //C!EQUIVALENCE   ( JPRMAT(1), J1 ),     ( JPRMAT(2), J2 )
  //C!EQUIVALENCE   ( JPRMAT(3), J3 ),     ( JPRMAT(4), J4 )
  //C!EQUIVALENCE   ( JPRMAT(5), J5 ),     ( JPRMAT(6), J6 )
  //C!EQUIVALENCE   ( JPRMAT(7), J7 ),     ( JPRMAT(8), J8 )
  //C!EQUIVALENCE   ( JPRMAT(9), J9 ),     ( JPRMAT(10), J10 )
  //C!EQUIVALENCE   ( JPRMAT(11), J11 ),    ( JPRMAT(12), J12 )
  //C!EQUIVALENCE   ( JPRMAT(13), J13 ),    ( JPRMAT(14), J14)
  //C!EQUIVALENCE   ( JPRMAT(15), J15 ),    ( JPRMAT(16), J16)
  mfrqpr = 0;
  if (kexact != 88333) {
    goto statement_423;
  }
  nfqpl1 = 0;
  cmn.io.close(lunit2)
    .status("DELETE");
  cmn.io.open(lunit2, fem::file_not_specified)
    .form("FORMATTED")
    .status("SCRATCH");
  statement_423:
  cmn.io.rewind(lunit9);
  cmn.io.rewind(lunit2);
  cmn.io.rewind(lunit3);
  cmn.io.rewind(lunt13);
  if (ialter != 2) {
    goto statement_7407;
  }
  l5save = lunit5;
  lunit5 = lunit2;
  statement_7407:
  ldisfr = locf(flstat(1)) - locf(voltbc(1));
  metrik = 0;
  finpcm = unity / 2.5400e0;
  ftpm = 100.f * finpcm / 12.f;
  fmipkm = ftpm * 1000.f / 5280.f;
  d8 = 0.3048e0;
  fspac = .024e0 * twopi * alogz(d8);
  //C     FSPAC NEEDED FOR CONVERSION OF REACTANCE AT 1 METER               M28.7182
  //C     SPACING TO 1 FOOT SPACING.                                        M28.7183
  //C              START OF CONSTANTS DEFINITION.                           M14.2820
  valu1 = 5584596.2e0;
  valu2 = .00085646541e0;
  valu3 = .00064373888e0;
  valu4 = .61593152e0;
  valu5 = 8.68588964e0;
  valu6 = .0005000000e0;
  valu7 = 3.0f;
  valu7 = onehaf * sqrtz(valu7);
  cmn.valu8 = .0040447306e0;
  valu9 = .21139217e0;
  valu10 = .5772156649015328606e0;
  cmn.valu11 = .3926991e0;
  cmn.valu12 = .398942280401433e0;
  cmn.valu13 = 1.2533141373155e0;
  valu14 = 2.302585093000e0;
  cmn.aaa1 = .785398163397448e0;
  cmn.aaa2 = .318309886183791e0;
  sqrt2 = 1.4142135623730950488e0;
  ccars(2) = 1.3659315156584124488e0;
  ll0 = 0;
  ll1 = 1;
  ll2 = 2;
  ll3 = 3;
  ll5 = 5;
  ll6 = 6;
  ll7 = 7;
  ll8 = 8;
  ll9 = 9;
  ll10 = 10;
  liu = 0;
  nfreq = 0;
  nbundl = 0;
  pi = twopi * onehaf;
  picon = 360.f / twopi;
  corchk = unity - tenm6 / 10.f;
  //C              BEGIN CALCULATE CONSTANTS FOR CARSON % BESSEL.           M14.2854
  bcars(1) = sqrt2 / 6.f;
  bcars(2) = unity / 16.f;
  dcars(2) = bcars(2) * pi / 4.f;
  FEM_DO_SAFE(i, 3, 30) {
    isn = fem::pow((-1), ((i - 1) / 2));
    bcars(i) = -bcars(i - 2) / (i * i + 2.f * i) * isn;
    dcars(i) = bcars(i) * pi / 4.f;
  }
  ccars(1) = unity / sqrt2;
  ccars(3) = ccars(1);
  ccars(5) = 3.f * sqrt2 / 2.f;
  ccars(7) = -45.f * onehaf * sqrt2;
  FEM_DOSTEP(i, 1, 29, 2) {
    if (i > 8) {
      ccars(i) = 0.0f;
    }
    dcars(i) = ccars(i);
  }
  dcars(3) = -dcars(3);
  dcars(7) = -dcars(7);
  FEM_DOSTEP(i, 4, 30, 2) {
    ccars(i) = ccars(i - 2) + unity / i + unity / (i + 2.f);
  }
  fbe(1) = 16.f;
  fbed(1) = -4.f;
  d1 = unity - valu10;
  fke(1) = fbe(1) * d1;
  FEM_DO_SAFE(i, 2, 14) {
    isn = fem::pow((-1), i);
    fbe(i) = fbe(i - 1) * (16.f / (i * i)) * (-isn);
    fbed(i) = fbe(i) / (2.f * i + 2.f) * isn;
    d1 += unity / i;
    fke(i) = fbe(i) * d1;
    fked(i - 1) = fke(i) * i / 32.f;
  }
  fked(14) = 0.0f;
  valu9 = fke(1) / 32.f;
  fbe(15) = .01104860e0;
  fbe(16) = 0.0f;
  fbe(17) = -.00009060e0;
  fbe(18) = -.00002520e0;
  fbe(19) = -.00000340e0;
  fbe(20) = .00000060e0;
  fbed(15) = -.01104850e0;
  fbed(16) = -.00097650e0;
  fbed(17) = -.00009010e0;
  fbed(18) = .0f;
  fbed(19) = .00000510e0;
  fbed(20) = .00000190e0;
  fke(15) = -.06250010e0;
  fke(16) = -.00138130e0;
  fke(17) = .00000050e0;
  fke(18) = .00003460e0;
  fke(19) = .00001170e0;
  fke(20) = .00000160e0;
  fked(15) = -.00000010e0;
  fked(16) = .00138110e0;
  fked(17) = .00024520e0;
  fked(18) = .00003380e0;
  fked(19) = -.00000240e0;
  fked(20) = -.00000320e0;
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(1x,'DATA FBE /',/,4(1x,5e25.15,/),/,' DATA FBED /',/,4(1x,5e25.15,"
        "/),/,' DATA FKE /',/,4(1x,5e25.15,/),/,' DATA FKED /',/,4(1x,5e25.15,"
        "/),/,' DATA BCARS /',/,6(1x,5e25.15,/),/,' DATA DCARS /',/,6(1x,"
        "5e25.15,/),/,' DATA CCARS /',/,6(1x,5e25.15,/),/,1x)");
      FEM_DO_SAFE(i, 1, 20) {
        wloop, fbe(i);
      }
      FEM_DO_SAFE(i, 1, 20) {
        wloop, fbed(i);
      }
      FEM_DO_SAFE(i, 1, 20) {
        wloop, fke(i);
      }
      FEM_DO_SAFE(i, 1, 20) {
        wloop, fked(i);
      }
      FEM_DO_SAFE(i, 1, 30) {
        wloop, bcars(i);
      }
      FEM_DO_SAFE(i, 1, 30) {
        wloop, dcars(i);
      }
      FEM_DO_SAFE(i, 1, 30) {
        wloop, ccars(i);
      }
    }
  }
  if (iprsup >= 1) {
    write(lunit6, "(/,' AT 3866 ',3e25.15)"), pi, picon, sqrt2;
  }
  statement_2:
  m = 1;
  FEM_DO_SAFE(i, 1, 40) {
    brname(i) = blank;
  }
  mspedb = 0;
  muntrn = 0;
  mtrnsp = 0;
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4154
  if (lastov == 1) {
    cmn.io.rewind(lunit2);
  }
  cmn.io.rewind(lunt13);
  //C     READ INPUT CARD USING CIMAGE                                      M14.2895
  statement_7403:
  cimage(cmn);
  read(abuff, format_4230), bus1;
  if (bus1 != text2) {
    goto statement_37403;
  }
  //C     OPTIONAL "BRANCH" CARD, WHICH SPECIES  A6  BRANCH NAMES           M29.4159
  n1 = m + 11;
  {
    read_loop rloop(abuff(1), "(8x,12a6)");
    FEM_DO_SAFE(i, m, n1) {
      rloop, brname(i);
    }
  }
  m += 12;
  write(kunit6, "('+BUS NAMES FOR EACH PHASE.')");
  goto statement_7403;
  statement_37403:
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  bus1 = bufsem(1);
  if (bus1 != fmetrc) {
    goto statement_4258;
  }
  metrik = 1;
  write(kunit6, "('+REQUEST CARD FOR METRIC  UNITS ON ALL DATA.')");
  goto statement_7403;
  statement_4258:
  if (bus1 != englis) {
    goto statement_24258;
  }
  metrik = 0;
  write(kunit6, "('+REQUEST CARD FOR ENGLISH UNITS ON ALL DATA.')");
  goto statement_7403;
  statement_24258:
  if (bus1 != text3) {
    goto statement_34258;
  }
  write(kunit6, "('+REQUEST FOR FREQUENCY-LOOP PRINTOUT.')");
  mfrqpr = 1;
  goto statement_7403;
  statement_34258:
  if (bufsem(1) != text4) {
    goto statement_54258;
  }
  if (bufsem(2) != text5) {
    goto statement_54258;
  }
  mspedb = 1;
  write(kunit6, "('+REQUEST FOR SPECIAL DOUBLE CIRCUIT TRANSPOSED.')");
  goto statement_7403;
  statement_54258:
  if (bufsem(1) != text6) {
    goto statement_5020;
  }
  if (bufsem(2) != text7) {
    goto statement_5020;
  }
  muntrn = 1;
  write(kunit6, "('+REQUEST FOR UNTRANSPOSED LINE MODELING.')");
  goto statement_7403;
  statement_5020:
  if (bufsem(1) != text8) {
    goto statement_5029;
  }
  if (bufsem(2) != text9) {
    goto statement_5029;
  }
  mtrnsp = 1;
  write(kunit6, "('+REQUEST FOR TRANSPOSED LINE MODELING.')");
  goto statement_7403;
  statement_5029:
  FEM_DO_SAFE(j, 1, 14) {
    if (bufsem(j) != blank) {
      goto statement_4251;
    }
  }
  write(kunit6, "('+BLANK CARD TERMINATING LINE-CONSTANTS CASES.')");
  interp();
  if (lastov == 1) {
    goto statement_7439;
  }
  n1 = lastov;
  lastov = nchain;
  nchain = n1;
  if (ialter == 2) {
    lunit5 = l5save;
  }
  if (ipunch == 0) {
    goto statement_7496;
  }
  d1 = 0.0f;
  write(lunit9, fem::unformatted), d1, d1, d1;
  if (iprsup >= 1 || lastov == 39) {
    write(lunit6,
      "(' LAST RECORD ON UNIT9',3e15.6,/,1x,'IPUNCH =',i10)"), d1,
      d1, d1, ipunch;
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4169
  cmn.io.rewind(lunit9);
  statement_7496:
  goto statement_9900;
  statement_7439:
  lastov = nchain;
  nchain = 51;
  goto statement_9900;
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4170
  statement_4251:
  cmn.io.rewind(lunt13);
  ik = 0;
  if (bus1 != text1) {
    goto statement_4260;
  }
  write(kunit6, "('+REQUEST CARD FOR CHANGE-CASE OPTION.')");
  goto statement_500;
  statement_4260:
  i = 1;
  FEM_THROW_UNHANDLED("executable assign: assign4236tomoon");
  goto statement_4164;
  statement_5:
  i++;
  //C     READ INPUT CARD USING CIMAGE                                      M14.2919
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  statement_4164:
  if (kolbeg > 0) {
    goto statement_8712;
  }
  read(abuff, format_11), itbic(i), tbtb2(i), tbr(i), itbtb3(i),
    tbg(i), tbd(i), tbx(i), h1, h2, d8, d9, tbtext(i), i3;
  goto statement_8715;
  statement_8712:
  cmn.nfrfld = 1;
  freone(cmn, d11);
  itbic(i) = d11;
  frefld(cmn, tbtb2(i));
  frefld(cmn, tbr(i));
  freone(cmn, d11);
  itbtb3(i) = d11;
  frefld(cmn, tbg(i));
  frefld(cmn, tbd(i));
  frefld(cmn, tbx(i));
  freone(cmn, h1);
  freone(cmn, h2);
  freone(cmn, d8);
  freone(cmn, d9);
  nright = -1;
  freone(cmn, d1);
  nright = 0;
  tbtext(i) = texta6(1);
  freone(cmn, d11);
  i3 = d11;
  if (kill > 0) {
    goto statement_9200;
  }
  goto statement_4235;
  statement_8715:
  if (i == 1) {
    goto statement_4320;
  }
  statement_4280:
  if (itbic(i) != 0) {
    goto statement_4285;
  }
  read(abuff, format_4281), bus1;
  if (bus1 != blank) {
    goto statement_4285;
  }
  itbic(i) = itbic(i - 1);
  statement_4285:
  if (tbtb2(i) != 0.0f) {
    goto statement_4291;
  }
  read(abuff, format_4286), bus1;
  if (bus1 != blank) {
    goto statement_4291;
  }
  tbtb2(i) = tbtb2(i - 1);
  statement_4291:
  if (tbr(i) != 0.0f) {
    goto statement_4296;
  }
  read(abuff, format_4292), bus1, bus2;
  if (bus1 != blank) {
    goto statement_4296;
  }
  if (bus2 != blank) {
    goto statement_4296;
  }
  tbr(i) = tbr(i - 1);
  statement_4296:
  if (itbtb3(i) != 0) {
    goto statement_4305;
  }
  read(abuff, format_4297), bus1;
  if (bus1 != blank) {
    goto statement_4305;
  }
  itbtb3(i) = itbtb3(i - 1);
  statement_4305:
  if (tbg(i) != 0.0f) {
    goto statement_4312;
  }
  read(abuff, format_4306), bus1, bus2;
  if (bus1 != blank) {
    goto statement_4312;
  }
  if (bus2 != blank) {
    goto statement_4312;
  }
  tbg(i) = tbg(i - 1);
  statement_4312:
  if (tbd(i) != 0.0f) {
    goto statement_4320;
  }
  read(abuff, format_4313), bus1, bus2;
  if (bus1 != blank) {
    goto statement_4320;
  }
  if (bus2 != blank) {
    goto statement_4320;
  }
  tbd(i) = tbd(i - 1);
  statement_4320:
  if (h1 != 0.0f) {
    goto statement_4227;
  }
  read(abuff, "(42x,2a4)"), bus1, bus2;
  if (bus1 != blank) {
    goto statement_4227;
  }
  if (bus2 != blank) {
    goto statement_4227;
  }
  h1 = h2;
  statement_4227:
  if (h2 != 0.0f) {
    goto statement_4235;
  }
  read(abuff, "(50x,2a4)"), bus1, bus2;
  if (bus1 != blank) {
    goto statement_4235;
  }
  if (bus2 != blank) {
    goto statement_4235;
  }
  h2 = h1;
  statement_4235:
  tby(i) = (h1 + h2 + h2) / 3.0f;
  switch (int(oon)) {
    case 1: goto statement_4236;
    case 2: goto statement_711;
    default: break;
  }
  statement_4236:
  if (tbx(i) != 0.0f) {
    goto statement_4239;
  }
  if (tby(i) != 0.0f) {
    goto statement_4239;
  }
  write(kunit6, "('+BLANK CARD TERMINATING CONDUCTOR CARDS.')");
  goto statement_6;
  statement_4239:
  write(kunit6, "('+LINE-CONDUCTOR CARD.',2e11.3,i6)"), tbtb2(i), tbr(i),
    itbtb3(i);
  if (i3 <= 1) {
    goto statement_706;
  }
  nbundl = 1;
  i4 = 1;
  xx = tbx(i);
  yy = tby(i);
  angl = (pi - twopi / i3) / 2.0f;
  dangl = twopi / i3;
  radius = d8 / (24.0f * cosz(angl));
  if (metrik == 1) {
    radius = radius * .12e0;
  }
  d9r = d9 / picon;
  statement_703:
  tbx(i) = xx + radius * cosz(d9r - dangl * i4);
  tby(i) = yy + radius * sinz(d9r - dangl * i4);
  if (i4 == i3) {
    goto statement_706;
  }
  i4++;
  i++;
  itbic(i) = itbic(i - 1);
  tbtb2(i) = tbtb2(i - 1);
  tbr(i) = tbr(i - 1);
  itbtb3(i) = itbtb3(i - 1);
  tbg(i) = tbg(i - 1);
  tbd(i) = tbd(i - 1);
  tbtext(i) = tbtext(i - 1);
  goto statement_703;
  statement_706:
  if (i <= lphase) {
    goto statement_5;
  }
  statement_7:
  kill = 82;
  lstat(15) = lphase;
  lstat(19) = 7;
  goto statement_9200;
  //C                                         SORTING OF CONDUCTOR DATA     M14.3008
  statement_6:
  tbd(i) = 0.0f;
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,/,' UNSORTED CONDUCTOR TABLE',/(1x,2i6,6e15.5,5x,a6))");
      FEM_DO_SAFE(k, 1, i) {
        wloop, itbic(k), itbtb3(k), tbtb2(k), tbr(k), tbg(k), tbd(k),
          tbx(k), tby(k), tbtext(k);
      }
    }
  }
  //C              '      '      '    CONVERT FROM SI UNITS FOR CALCULATION.M14.3015
  if (metrik != 1) {
    goto statement_981;
  }
  FEM_DO_SAFE(k, 1, i) {
    tbd(k) = tbd(k) * finpcm;
    tbx(k) = tbx(k) * ftpm;
    tby(k) = tby(k) * ftpm;
    tbr(k) = tbr(k) / fmipkm;
    jb = itbtb3(k);
    if (jb < 2) {
      tbg(k) = (tbg(k) + fspac) / fmipkm;
    }
    if (jb == 2) {
      tbg(k) = tbg(k) * finpcm;
    }
  }
  statement_981:
  move0(ic, lphase);
  ktot = 0;
  kcirct = 0;
  k = 0;
  statement_10:
  k++;
  if (tbd(k) == 0.f) {
    goto statement_15;
  }
  i1 = itbic(k);
  if (i1 == 0) {
    goto statement_12;
  }
  if (i1 < 0) {
    goto statement_10;
  }
  if (i1 > kcirct) {
    kcirct = i1;
  }
  i = lphpl1 - i1;
  if (ic(i) == 0) {
    goto statement_13;
  }
  statement_12:
  ktot++;
  i = ktot;
  if (i1 == 0) {
    goto statement_13;
  }
  ip = ktot;
  statement_18:
  j = i - 1;
  if (j == 0) {
    goto statement_13;
  }
  if (ic(j) > 0) {
    goto statement_13;
  }
  i = j;
  ic(ip) = ic(i);
  tb2(ip) = tb2(i);
  itb3(ip) = itb3(i);
  r(ip) = r(i);
  dz(ip) = dz(i);
  gmd(ip) = gmd(i);
  x(ip) = x(i);
  y(ip) = y(i);
  text(ip) = text(i);
  ip = ip - 1;
  goto statement_18;
  statement_13:
  kfull = ktot + kcirct;
  if (kfull > lphase) {
    goto statement_7;
  }
  ic(i) = i1;
  tb2(i) = tbtb2(k);
  itb3(i) = itbtb3(k);
  r(i) = tbr(k);
  dz(i) = tbd(k);
  gmd(i) = tbg(k);
  x(i) = tbx(k);
  y(i) = tby(k);
  text(i) = tbtext(k);
  goto statement_10;
  statement_15:
  iprint = 0;
  ntol = 0;
  statement_16:
  if (ik > 0) {
    goto statement_3006;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M14.3070
  statement_33316:
  cimage(cmn);
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4180
  cmn.io.rewind(lunt13);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  read(abuff,
    "(f8.2,f10.2,f10.6,i2,5i1,i2,5i1,i2,f8.3,i2,5i1,3i3,2i2,e8.2)"),
    rearth, freq, corr, jprmat(1), jprmat(2), jprmat(3), jprmat(4),
    jprmat(5), jprmat(6), jprmat(7), jprmat(8), jprmat(9), jprmat(10),
    jprmat(11), jprmat(12), iw, dist, jprmat(13), jprmat(14), jprmat(15),
    jprmat(16), isegm, mutual, ik, ips, jprmat(17), imodal, itrnsf,
    conduc;
  if (metrik == 1) {
    conduc = conduc / fmipkm;
  }
  if (conduc == 0) {
    conduc = 3.22e-9;
  }
  if (muntrn == 1) {
    imodal = 1;
  }
  if (mtrnsp == 1 || mspedb == 1) {
    imodal = 0;
  }
  if (kexact != 88333) {
    goto statement_3168;
  }
  freq = fminfs;
  ik = alog1z(fmaxfs / fminfs) + epsiln;
  ips = valu14 / alogz(-cmn.delffs) + epsiln;
  distsv = dist;
  goto statement_217;
  statement_3168:
  if (lastov == 1 || imodal == 1) {
    goto statement_217;
  }
  if (lastov != 39) {
    goto statement_217;
  }
  gmode = conduc;
  if (metrik == 1) {
    gmode = gmode * fmipkm;
  }
  statement_217:
  jspecl = jprmat(1) + jprmat(2) + jprmat(3) + jprmat(4) + jprmat(
    5) + jprmat(6) + jprmat(7) + jprmat(8) + jprmat(9) + jprmat(10) +
    jprmat(11) + jprmat(12);
  nfreq++;
  if (lastov != 1 && imodal == 0 && nfreq == 2 && ik == 0 &&
      ips == 0 && lastov != 45) {
    goto statement_33316;
  }
  j5out = jprmat(5);
  j8out = jprmat(8);
  j2out = jprmat(2);
  j4out = jprmat(4);
  j6out = jprmat(6);
  j9out = jprmat(9);
  if (imodal != 0) {
    goto statement_117;
  }
  jprmat(5) = 1;
  jprmat(9) = 1;
  statement_117:
  if (j17 != 44) {
    goto statement_28725;
  }
  jprmat(5) = 1;
  jprmat(8) = 1;
  iw = 1;
  statement_28725:
  if (imodal <= 0) {
    goto statement_18725;
  }
  jprmat(2) = 1;
  jprmat(8) = 1;
  statement_18725:
  if (ik <= 0) {
    goto statement_8726;
  }
  jprmat(6) = 1;
  jprmat(9) = 1;
  statement_8726:
  if (ck1 !=  - fltinf) {
    goto statement_7446;
  }
  if (dist <= 0.0f) {
    goto statement_7446;
  }
  ck1 = dist;
  if (metrik == 1) {
    ck1 = ck1 * fmipkm;
  }
  statement_7446:
  if (ci1 !=  - fltinf) {
    goto statement_7449;
  }
  if (rearth <= 0.0f) {
    goto statement_7449;
  }
  ci1 = rearth;
  statement_7449:
  if (mutual > 0) {
    jprmat(8) = 1;
  }
  if (kolbeg > 0) {
    goto statement_4264;
  }
  if (corr != 0.0f) {
    goto statement_4264;
  }
  read(abuff, "(18x,a6,a4)"), bus1, bus2;
  if (bus1 != blank) {
    goto statement_4264;
  }
  if (bus2 != blank) {
    goto statement_4264;
  }
  corr = tenm6;
  statement_4264:
  iprint++;
  if (rearth != 0.0f) {
    goto statement_4267;
  }
  write(kunit6, "('+BLANK CARD TERMINATING FREQUENCY CARDS.')");
  if (kexact != 88333) {
    goto statement_2;
  }
  lastov = 44;
  //C      NCHAIN = 8
  nchain = 2;
  goto statement_9900;
  statement_4267:
  if (ialter == 2) {
    rearth = ci1;
  }
  write(kunit6, "('+FREQUENCY CARD.',3e11.3)"), rearth, freq, dist;
  interp();
  if (metrik == 1) {
    dist = dist * fmipkm;
  }
  ipunch = j17;
  jpralt = 1;
  if (ialter == 0) {
    goto statement_3729;
  }
  FEM_DO_SAFE(jj, 1, 16) {
    if (jprmat(jj) != 0) {
      goto statement_13721;
    }
  }
  jpralt = 0;
  if (ialter == 3) {
    goto statement_13723;
  }
  statement_3723:
  jprmat(5) = 1;
  jprmat(8) = 1;
  iw = 0;
  goto statement_3729;
  statement_13721:
  if (ialter != 3) {
    goto statement_3723;
  }
  statement_13723:
  jprmat(6) = 1;
  jprmat(9) = 1;
  statement_3729:
  kkk = 0;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' NEW FREQUENCY CARD.  IPRINT  LDISFR  IALTER',/,20x,3i8)"),
      iprint, ldisfr, ialter;
  }
  FEM_DO_SAFE(jj, 1, 16) {
    if (jprmat(jj) != 0) {
      goto statement_3733;
    }
  }
  goto statement_33316;
  statement_3733:
  if (freq == 0.0f) {
    freq = cmn.statfr;
  }
  if (ik > 0) {
    goto statement_7456;
  }
  if (ialter == 3) {
    goto statement_7453;
  }
  if (lastov == 1) {
    goto statement_7453;
  }
  volti(iprint) = rearth;
  if (ialter == 2) {
    goto statement_7453;
  }
  voltk(iprint) = freq;
  if (iprint <= ldisfr) {
    goto statement_7453;
  }
  kill = 170;
  lstat(14) = ldisfr;
  lstat(19) = 7456;
  goto statement_9200;
  statement_7453:
  goto statement_3007;
  statement_7456:
  if (ips == 0) {
    ips = 1;
  }
  if (ips * ik <= 399) {
    goto statement_7458;
  }
  //C     THIS CHECK REALLY BELONGS IN "SEMLYEN SETUP" (OVERLAY 45):        M31.6392
  if (lastov != 45) {
    goto statement_7458;
  }
  kill = 160;
  lstat(14) = 399;
  lstat(19) = 7458;
  goto statement_9200;
  statement_7458:
  factor = ips;
  factor = valu14 / factor;
  fdecad = freq;
  if (lastov == 1 && imodal != 0) {
    goto statement_7459;
  }
  dist = 0.f;
  statement_7459:
  iii = 0;
  voltbc(1) = freq;
  voltbc(2) = freq * fem::pow(10.f, ik);
  voltbc(3) = expz(factor);
  d13 = voltbc(2) / voltbc(1);
  voltbc(4) = alogz(d13) / alogz(voltbc(3)) + 1.5f;
  voltbc(5) = ik;
  voltbc(6) = ips;
  icheck = iprint - 1;
  iprint = icheck;
  ktab = kcirct;
  nmode = 2;
  if (kcirct < 2) {
    nmode = 1;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' LOGARITHMIC FREQUENCY.  ICHECK    KTAB',8x,'VOLT(1)',8x,"
        "'VOLT(2)',8x,'VOLT(3)',/,23x,2i8,3e15.6)");
      wloop, icheck, ktab;
      FEM_DO_SAFE(jj, 1, 3) {
        wloop, voltbc(jj);
      }
    }
  }
  if (mfrqpr > 0) {
    write(lunit6, format_3004);
  }
  goto statement_3006;
  statement_3005:
  iii++;
  //CCCC      IF ( III  .GE.  IK )   GO TO 33316                            M43.3348
  if (iii >= ik) {
    goto statement_8801;
  }
  goto statement_8802;
  statement_8801:
  if (kexact != 88333) {
    goto statement_8701;
  }
  if (nfqpl1 == 1) {
    goto statement_8701;
  }
  nfqpl1 = 1;
  goto statement_8802;
  statement_8701:
  if (nfreq != 3) {
    goto statement_8800;
  }
  //CC    ** IDENTICAL EIGENVALUE ? **                                      M43.3352
  if (nrp > 0 || itrnsf == 0) {
    goto statement_8800;
  }
  write(6, star), "$$  MRR,NTOL,NFREQ ARE  : ", mrr, ntol, nfreq;
  rtio = (mrr * 1.0f) / ntol;
  if (rtio < 0.75f) {
    goto statement_8800;
  }
  nrp = 1;
  freq = fdecad;
  FEM_DO_SAFE(i, 1, ntol * ktab) {
    cmn.io.backspace(lunit9);
  }
  ntol = 0;
  goto statement_16;
  statement_8800:
  goto statement_33316;
  statement_8802:
  fdecad = fdecad * 10.0f;
  kkk = 1;
  statement_3006:
  pkkk = kkk;
  freq = fdecad * expz(pkkk * factor);
  iprint++;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' NEXT LOGARITHMICALLY-SPACED FREQUENCY.  IPRINT     KKK     III',"
      "11x,'FREQ',12x,'CI1',12x,'CK1',/,39x,3i8,3e15.6)"),
      iprint, kkk, iii, freq, ci1, ck1;
  }
  if (kkk > ips) {
    goto statement_3005;
  }
  if (freq + epsiln < fmaxfs || kexact != 88333) {
    goto statement_8806;
  }
  if (nfqpl1 == 1) {
    kkk = ips;
  }
  statement_8806:
  kkk++;
  statement_3007:
  omega = twopi * freq;
  if (ik > 0) {
    goto statement_3008;
  }
  write(lunit6,
    "(/,/,' LINE-CONDUCTOR TABLE AFTER SORTING AND INITIAL PROCESSING.',/,1x,"
    "'TABLE',3x,'PHASE',3x,'SKIN EFFECT',4x,'RESISTANCE',3x,"
    "'REACTANCE-DATA SPECIFICATION',5x,'DIAMETER',3x,'HORIZONTAL',3x,"
    "'AVG HEIGHT',3x,'CONDUCTOR')");
  if (metrik == 0) {
    write(lunit6,
      "(3x,'ROW',2x,'NUMBER',8x,'R-TYPE',4x,'R (OHM/MI)',3x,'X-TYPE',6x,"
      "'X(OHM/MI) OR GMR',5x,'(INCHES)',5x,'X (FEET)',5x,'Y (FEET)',8x,"
      "'NAME')");
  }
  if (metrik == 1) {
    write(lunit6,
      "(3x,'ROW',2x,'NUMBER',8x,'R-TYPE',4x,'R (OHM/KM)',3x,'X-TYPE',6x,"
      "'X(OHM/KM) OR GMR',5x,'(  CM  )',5x,'X (MTRS)',5x,'Y (MTRS)',8x,"
      "'NAME')");
  }
  statement_3008:
  idist = 1;
  if (dist == 0.0f && ipunch != 44) {
    goto statement_4271;
  }
  if (kcirct == 0) {
    goto statement_4271;
  }
  if (kcirct < cmn.lphd2) {
    goto statement_4275;
  }
  statement_4271:
  idist = 0;
  statement_4275:
  j56 = jprmat(5) + jprmat(6) + idist;
  //C                                                                       M14.3132
  //C                                                  FORMATION OF P-MATRIXM14.3133
  ip = 0;
  k = 0;
  f1 = unity / omega;
  if (iw > 0) {
    f1 = unity;
  }
  f1 = f1 * valu1;
  f2 = f1 * 2.0f;
  statement_20:
  k++;
  if (k > kfull) {
    goto statement_30;
  }
  if (k <= kcirct) {
    goto statement_28;
  }
  j = k - kcirct;
  statement_21:
  x1 = x(j);
  y1 = y(j);
  d1 = dz(j);
  if (iprint != 1) {
    goto statement_222;
  }
  if (metrik == 0) {
    goto statement_221;
  }
  rj = r(j) * fmipkm;
  yj = y(j) / ftpm;
  xj = x(j) / ftpm;
  dj = dz(j) / finpcm;
  gmdj = gmd(j);
  jb = itb3(j);
  if (jb < 2) {
    gmdj = gmdj * fmipkm - fspac;
  }
  if (jb == 2) {
    gmdj = gmdj / finpcm;
  }
  write(lunit6, format_22), k, ic(j), tb2(j), rj, jb, gmdj, dj, xj, yj, text(j);
  goto statement_225;
  statement_221:
  write(lunit6, format_22), k, ic(j), tb2(j), r(j), itb3(j), gmd(j),
    dz(j), x(j), y(j), text(j);
  statement_225:
  if (itb3(j) != 4) {
    goto statement_222;
  }
  if (tb2(j) > 0.f) {
    goto statement_224;
  }
  kill = 83;
  lstat(15) = j;
  lstat(19) = 224;
  goto statement_9200;
  statement_224:
  gmd(j) = dz(j);
  statement_222:
  i = 0;
  statement_23:
  i++;
  ip++;
  if (i == k) {
    goto statement_24;
  }
  j = i - kcirct;
  if (i <= kcirct) {
    j = lphpl1 - i;
  }
  dx = fem::pow2((x(j) - x1));
  h1 = y(j) - y1;
  h2 = y(j) + y1;
  if (dx == 0.0f && h1 == 0.0f) {
    goto statement_26;
  }
  r1 = alogz((dx + h2 * h2) / (dx + h1 * h1));
  p(ip) = r1 * f1;
  z(ip) = r1;
  goto statement_23;
  statement_24:
  p(ip) = alogz(48.f * y1 / d1) * f2;
  goto statement_20;
  statement_26:
  kill = 84;
  lstat(15) = i;
  lstat(19) = 28;
  goto statement_9200;
  statement_28:
  j = lphpl1 - k;
  if (ic(j) != 0) {
    goto statement_21;
  }
  kill = 85;
  lstat(19) = 30;
  lstat(15) = k;
  goto statement_9200;
  statement_30:
  if (kkk > 0 && lastov != 1) {
    goto statement_3020;
  }
  if (jspecl == 0) {
    goto statement_7025;
  }
  write(lunit6,
    "(/,/,'0FOLLOWING MATRICES ARE FOR EARTH RESISTIVITY=',f8.2,"
    "' OHM-M AND FREQUENCY=',f13.2,' HZ. CORRECTION FACTOR=',f10.6)"),
    rearth, freq, corr;
  statement_7025:
  if (kkk > 1) {
    goto statement_3020;
  }
  if (isegm > 0) {
    write(lunit6,
      "(' ',30x,'************EARTH WIRES WILL BE SEGMENTED************')");
  }
  if (ik > 0) {
    write(lunit6, format_3004);
  }
  statement_3020:
  {
    write_loop wloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(i, 1, ip) {
      wloop, z(i);
    }
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' AT 4427.  (Z(I), I=1, IP) .',/(1x,8e16.6))");
      FEM_DO_SAFE(i, 1, ip) {
        wloop, z(i);
      }
    }
  }
  if (iprsup >= 1) {
    write(lunit6, "(/,' AT 4428.',7i12)"), jprmat(1), jprmat(4),
      kcirct, jprmat(2), j3, j56, kfull;
  }
  //C                                                                       M14.3215
  //C                                   REDUCTIONS AND INVERSIONS P-MATRIX  M14.3216
  identifier_switch = -unity;
  if (jprmat(1) > 0) {
    goto statement_36;
  }
  statement_31:
  if (jprmat(4) > 0) {
    goto statement_37;
  }
  statement_32:
  if (kcirct == 0) {
    goto statement_80;
  }
  if (jprmat(2) + jprmat(3) + j56 == 0) {
    goto statement_80;
  }
  //C                          BEGIN ELIMINATION OF EARTH WIRES AND BUNDLINGM14.3222
  statement_49:
  k = kcirct;
  statement_50:
  k++;
  if (k > kfull) {
    goto statement_56;
  }
  i = k - kcirct;
  i = ic(i);
  if (i == 0) {
    goto statement_50;
  }
  i2 = i * (i - 1) / 2;
  k2 = k * (k - 1) / 2;
  kk = k2 + i;
  h1 = p(kk);
  h2 = z(kk);
  kk = k2 + k;
  L = 0;
  statement_51:
  if (L < i) {
    goto statement_54;
  }
  i2 += L;
  statement_52:
  if (L < k) {
    goto statement_55;
  }
  k2 += L;
  statement_53:
  L++;
  p(k2) = p(k2) - p(i2);
  if (identifier_switch > 0.f) {
    z(k2) = z(k2) - z(i2);
  }
  if (L != kfull) {
    goto statement_51;
  }
  p(kk) = p(kk) - h1;
  if (identifier_switch > 0.f) {
    z(kk) = z(kk) - h2;
  }
  goto statement_50;
  statement_54:
  i2++;
  goto statement_52;
  statement_55:
  k2++;
  goto statement_53;
  statement_56:
  kp = kcirct * (kcirct + 1) / 2;
  if (identifier_switch > 0.f) {
    goto statement_202;
  }
  redu44(cmn, p(1), workr1(1), kfull, kcirct);
  //CCCC      write (*,*) ' After REDU44 on C.  P(1:6) =',                  M43.3375
  //CCCC     1                                ( P(I), I=1, 6 )              M43.3376
  if (kill > 0) {
    goto statement_9200;
  }
  //C                            END ELIMINATION OF EARTH WIRES AND BUNDLINGM14.3255
  //CCCC      write (*,*) ' Branch to 38?  j2, j3 =',  j2, j3               M43.3377
  if (jprmat(2) + jprmat(3) > 0) {
    goto statement_38;
  }
  statement_33:
  if (j56 > 0) {
    goto statement_39;
  }
  //C                                                                       M14.3258
  //C                                         FORMATION OF Z-MATRIX         M14.3259
  statement_80:
  identifier_switch = +unity;
  j56 = jprmat(8) + jprmat(9) + jprmat(11) + jprmat(12) + idist;
  if (j56 + jprmat(7) + jprmat(10) == 0) {
    goto statement_600;
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4198
  cmn.io.rewind(lunt13);
  k = 0;
  if (rearth == 0.f) {
    goto statement_100;
  }
  f1 = valu2 * sqrtz(freq / rearth);
  statement_100:
  f2 = omega * valu3;
  imax = 30;
  if (corr == 0.f || rearth == 0.f) {
    imax = -1;
  }
  if (corr > corchk) {
    imax = corr - onehaf;
  }
  if (imax > 31) {
    imax = 30;
  }
  {
    read_loop rloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(i, 1, ip) {
      rloop, p(i);
    }
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4201
  cmn.io.rewind(lunt13);
  ip = 0;
  statement_120:
  k++;
  if (k > kfull) {
    goto statement_200;
  }
  if (k <= kcirct) {
    goto statement_129;
  }
  j = k - kcirct;
  goto statement_121;
  statement_129:
  j = lphpl1 - k;
  statement_121:
  x1 = x(j);
  y1 = y(j);
  r1 = r(j);
  h1 = tb2(j);
  h2 = unity - 2.0f * h1;
  if (h1 > 0.f) {
    skin(cmn, h2, r1, freq, r1, h1);
  }
  g1 = gmd(j);
  ix = itb3(j);
  izero = 1;
  xm = 0.f;
  if (ic(j) == 0 && isegm > 0) {
    izero = 0;
  }
  if (ix < 2) {
    goto statement_150;
  }
  if (ix == 3) {
    g1 = g1 * dz(j) / 2.0f;
  }
  xs = alogz(24.0f * y1 / g1) * onehaf;
  statement_122:
  if (ix != 4) {
    goto statement_125;
  }
  xs += h1 / f2 - onehaf * alogz(dz(j) * onehaf / g1);
  statement_125:
  i = 0;
  statement_123:
  i++;
  ip++;
  if (i == k) {
    goto statement_124;
  }
  j = i - kcirct;
  if (i <= kcirct) {
    j = lphpl1 - i;
  }
  rm = 0.f;
  if (izero == 0) {
    goto statement_126;
  }
  xm = p(ip) / 4.0f;
  if (imax < 0) {
    goto statement_126;
  }
  dx = std::abs(x(j) - x1);
  h2 = y(j) + y1;
  s = sqrtz(h2 * h2 + dx * dx);
  z1 = s * f1;
  if (z1 > 5.0f) {
    goto statement_151;
  }
  //C                    BEGIN CARSON SERIES FOR MUTUAL IMPEDANCE IF Z.LE.5.M14.3312
  rm = twopi / 16.f;
  zl = alogz(z1);
  xm += (valu4 - zl) * onehaf;
  if (imax == 0) {
    goto statement_126;
  }
  s1 = dx / s;
  c1 = h2 / s;
  cs = c1 * z1;
  sn = s1 * z1;
  if (imax > 1) {
    phi = std::asin(s1);
  }
  m5 = 0;
  error = 0.f;
  statement_1110:
  k5 = 0;
  i5 = m5 * 4;
  statement_1111:
  k5++;
  i5++;
  if (k5 == 1 || k5 == 3) {
    goto statement_1113;
  }
  deltap = ((ccars(i5) - zl) * cs + phi * sn) * bcars(i5);
  h1 = -dcars(i5) * cs;
  if (k5 == 4) {
    goto statement_1114;
  }
  deltaq = h1;
  statement_1004:
  rm += deltap;
  xm += deltaq;
  if (i5 == imax) {
    goto statement_126;
  }
  if (corr > corchk) {
    goto statement_1005;
  }
  if (std::abs(deltap) < corr && std::abs(deltaq) < corr) {
    goto statement_1115;
  }
  error = 0.f;
  statement_1005:
  h1 = sn * c1 + cs * s1;
  cs = (cs * c1 - sn * s1) * z1;
  sn = h1 * z1;
  if (k5 < 4) {
    goto statement_1111;
  }
  m5++;
  goto statement_1110;
  statement_1113:
  deltaq = bcars(i5) * cs;
  deltap = deltaq;
  if (k5 == 1) {
    deltap = -deltap;
  }
  goto statement_1004;
  statement_1114:
  deltaq = -deltap;
  deltap = h1;
  goto statement_1004;
  statement_1115:
  if (error > onehaf) {
    goto statement_126;
  }
  error = unity;
  goto statement_1005;
  //C                      END CARSON SERIES FOR MUTUAL IMPEDANCE IF Z.LE.5.M14.3355
  //C                                                                       M14.3356
  //C                    BEGIN CARSON SERIES FOR MUTUAL IMPEDANCE IF Z.GT.5.M14.3357
  statement_151:
  s = s * z1;
  sn = dx / s;
  cs = h2 / s;
  s2 = sn * cs * 2.0f;
  c2 = cs * cs - sn * sn;
  rm = -c2;
  FEM_DOSTEP(i5, 1, 7, 2) {
    rm += ccars(i5) * cs;
    xm += dcars(i5) * cs;
    h1 = cs * s2 + sn * c2;
    cs = cs * c2 - sn * s2;
    sn = h1;
  }
  //C                      END CARSON SERIES FOR MUTUAL IMPEDANCE IF Z.GT.5.M14.3370
  statement_126:
  p(ip) = rm * f2;
  z(ip) = xm * f2;
  if (iprsup >= 4) {
    write(lunit6, "(' AT 4439 ',6i10,2e16.6)"), i, k, kfull, kcirct,
      i5, ip, p(ip), z(ip);
  }
  goto statement_123;
  statement_124:
  if (imax < 0) {
    goto statement_128;
  }
  r1 = r1 / f2;
  z1 = y1 * f1 * 2.0f;
  if (z1 > 5.0f) {
    goto statement_152;
  }
  //C                    BEGIN CARSON SERIES FOR SELF IMPEDANCE IF Z.LE.5.0 M14.3381
  r1 += twopi / 16.f;
  zl = alogz(z1);
  xs += (valu4 - zl) * onehaf;
  if (imax == 0) {
    goto statement_127;
  }
  m5 = 0;
  cs = z1;
  error = 0.f;
  statement_2110:
  k5 = 0;
  i5 = m5 * 4;
  statement_2111:
  k5++;
  i5++;
  if (k5 == 1 || k5 == 3) {
    goto statement_2113;
  }
  deltap = (ccars(i5) - zl) * bcars(i5) * cs;
  h1 = -dcars(i5) * cs;
  if (k5 == 4) {
    goto statement_2114;
  }
  deltaq = h1;
  statement_2004:
  r1 += deltap;
  xs += deltaq;
  if (i5 == imax) {
    goto statement_127;
  }
  if (corr > corchk) {
    goto statement_2005;
  }
  if (std::abs(deltap) < corr && std::abs(deltaq) < corr) {
    goto statement_2115;
  }
  error = 0.f;
  statement_2005:
  cs = cs * z1;
  if (k5 < 4) {
    goto statement_2111;
  }
  m5++;
  goto statement_2110;
  statement_2113:
  deltaq = bcars(i5) * cs;
  deltap = deltaq;
  if (k5 == 1) {
    deltap = -deltap;
  }
  goto statement_2004;
  statement_2114:
  deltaq = -deltap;
  deltap = h1;
  goto statement_2004;
  statement_2115:
  if (error > onehaf) {
    goto statement_127;
  }
  error = unity;
  goto statement_2005;
  //C                      END CARSON SERIES FOR SELF IMPEDANCE IF Z.LE.5.0 M14.3418
  //C                                                                       M14.3419
  //C                    BEGIN CARSON SERIES FOR SELF IMPEDANCE IF Z.GT.5.0 M14.3420
  statement_152:
  cs = unity / z1;
  c2 = cs * cs;
  r1 = r1 - c2;
  FEM_DOSTEP(i5, 1, 7, 2) {
    r1 += ccars(i5) * cs;
    xs += dcars(i5) * cs;
    cs = cs * c2;
  }
  //C                      END CARSON SERIES FOR SELF IMPEDANCE IF Z.GT.5.0 M14.3428
  statement_127:
  r1 = r1 * f2;
  statement_128:
  z(ip) = xs * f2;
  p(ip) = r1;
  if (iprsup >= 4) {
    write(lunit6, "(' AT 4440 ',6i10,2e16.6)"), i, k, kfull, kcirct,
      i5, ip, p(ip), z(ip);
  }
  goto statement_120;
  statement_150:
  xs = g1 / f2;
  if (ix == 1) {
    xs = xs * freq / 60.0f;
  }
  xs += alogz(y1 * 2.0f) * onehaf;
  g1 = 24.0f * y1 / expz(2.0f * xs);
  goto statement_122;
  //C                                                                       M14.3441
  //C                                  ROUTINES FOR Z-PRINTING AND INVERSIONM14.3442
  //C     IMPEDANCE MATRIX FOR PHYSICAL CONDUCTORS IS IN P(1),...P(IP) (REALM14.3443
  //C     PART) AND Z(1)....Z(IP) (IMAGINARY PART).                         M14.3444
  statement_200:
  if (jprmat(7) > 0) {
    output(cmn, metrik, p(1), z(1), unity, kfull, ll6, ll1);
  }
  if (iprsup >= 1) {
    write(lunit6, "(/,' AT 4234.   MISC. INTEGERS.',/(1x,10i12))"),
      jprmat(7), jprmat(10), j56, kcirct, jprmat(8), mutual, jprmat(11),
      jprmat(12), idist, jprmat(9), kp, jprmat(2), jprmat(3), jprmat(5),
      jprmat(6);
  }
  if (jprmat(10) > 0) {
    goto statement_250;
  }
  if (j56 == 0) {
    goto statement_600;
  }
  statement_201:
  if (kcirct == 0) {
    goto statement_600;
  }
  goto statement_49;
  statement_202:
  cxred2(p(1), z(1), workr1(1), workr2(1), kfull, kcirct);
  //C     IMPEDANCE MATRIX FOR EQUIVALENT PHASE CONDUCTORS IS IN P(1),...   M14.3456
  //C     P(KP) (REAL PART) AND Z(1),...Z(KP) (IMAGINARY PART).             M14.3457
  if (j8out > 0) {
    output(cmn, metrik, p(1), z(1), unity, kcirct, ll6, ll2);
  }
  if (ipunch != 44) {
    goto statement_8202;
  }
  punpie(cmn, kcirct);
  statement_8202:
  if (iprsup >= 1) {
    write(lunit6, "(' IMODAL, DIST =',i5,e17.5)"), imodal, dist;
  }
  if (lastov != 39) {
    goto statement_3203;
  }
  if (nfreq != 1) {
    goto statement_3203;
  }
  //C     "MARTI SETUP" ASSUMES DISTANCE IN KILOMETERS IS ON 9:             M31.6407
  distkm = dist / fmipkm;
  write(lunit9, fem::unformatted), imodal, metrik, distkm, mspedb, itrnsf;
  if (iprsup > 1) {
    write(lunit6, star), " MSPEDB written on LUNIT9 =", mspedb;
  }
  statement_3203:
  if (imodal <= 0) {
    goto statement_2202;
  }
  if (lastov == 1 && itrnsf !=  - 1 && itrnsf !=  - 9) {
    itrnsf = 0;
  }
  n8 = kfull;
  if (nbundl == 1) {
    n8 = kcirct;
  }
  if (kcirct <= ndim) {
    goto statement_1202;
  }
  kill = 221;
  lstat(19) = 1202;
  lstat(14) = kcirct;
  goto statement_9200;
  statement_1202:
  if (nfreq == 3) {
    ntol++;
  }
  if (kexact == 88333) {
    dist = distsv;
  }
  modal(cmn, array, xwc, xwy, yzr, yzi, tii, tir, tvi, tvr, er, ei,
    theta2, xtir, xtii, zsurge, dummi, dummr, tixf, work1, freq, kcirct,
    iw, dist, metrik, fmipkm, ndim, ntri, nsqr2, itrnsf, kfull, mrr,
    nrp, ntol, conduc);
  if (kill != 0) {
    goto statement_9900;
  }
  statement_2202:
  if (lastov == 39 || lastov == 45 || imodal != 0) {
    goto statement_8777;
  }
  if (kexact == 88333) {
    goto statement_45454;
  }
  kount = 0;
  cmn.io.rewind(lunit1);
  if (ipunch == 0) {
    write(lunit7,
      "('C   PUNCHED CARD OUTPUT OF TRANSPOSED LINE',' WHICH BEGAN AT',2x,2a4,"
      "2x,2a4)"),
      tclock, date1;
  }
  if (ipunch != 0) {
    goto statement_8770;
  }
  if (imodal == 0 && mspedb == 0) {
    write(lunit7,
      "('C   ***** TRANSPOSED K.C. LEE LINE SEGMENT CALCULATED AT',2x,e10.3,"
      "' HZ. *****')"),
      freq;
  }
  if (imodal == 0 && mspedb == 1) {
    write(lunit7,
      "('C **** SPECIAL DOUBLE CIRCUIT TRANSPOSED LINE CALCULATED AT',2x,"
      "e10.3,' HZ. ****')"),
      freq;
  }
  statement_8770:
  cmn.io.rewind(lunit2);
  n5 = 0;
  //C     IF ( JDATCS .GT. 0 )  GO TO 8777                                  M43.3397
  FEM_DO_SAFE(n12, 1, 9999) {
    {
      read_loop rloop(cmn, lunit2, "(13a6,a2)");
      FEM_DO_SAFE(i, 1, 14) {
        rloop, texta6(i);
      }
    }
    if (ipunch == 0) {
      {
        write_loop wloop(cmn, lunit7, "('C ',13a6)");
        FEM_DO_SAFE(i, 1, 13) {
          wloop, texta6(i);
        }
      }
    }
    if (idebug == 0) {
      goto statement_8100;
    }
    {
      write_loop wloop(cmn, lunit1, "(' C ',13a6,a2)");
      FEM_DO_SAFE(i, 1, 14) {
        wloop, texta6(i);
      }
    }
    kount++;
    statement_8100:
    if (texta6(1) == blank && texta6(2) == blank) {
      n5++;
    }
    if (n5 >= 1) {
      goto statement_8777;
    }
  }
  statement_8777:
  if (ialter <= 0) {
    goto statement_3734;
  }
  if (lastov == 39) {
    goto statement_3734;
  }
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(jj, 1, kp) {
      wloop, p(jj);
    }
  }
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(jj, 1, kp) {
      wloop, z(jj);
    }
  }
  if (iprsup == 0) {
    goto statement_3734;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' OUTPUT OF  (R)  AND  (L)  FOR SEMLYEN,',i6,'  CELLS EACH.',/(1x,"
      "8e16.4))");
    wloop, kp;
    FEM_DO_SAFE(jj, 1, kp) {
      wloop, p(jj);
    }
    FEM_DO_SAFE(jj, 1, kp) {
      wloop, z(jj);
    }
  }
  statement_3734:
  if (mutual > 0) {
    outspc(cmn, p(1), z(1), kcirct, metrik, fmipkm);
  }
  j56 = jprmat(11) + jprmat(12) + idist;
  if (lastov == 39) {
    goto statement_253;
  }
  if (jprmat(9) > 0 && kcirct >= 2) {
    goto statement_253;
  }
  statement_203:
  if (j56 == 0) {
    goto statement_600;
  }
  FEM_DO_SAFE(i, 1, kp) {
    p(i) = -p(i);
    z(i) = -z(i);
  }
  cxred2(p(1), z(1), workr1(1), workr2(1), kcirct, ll0);
  //C     INVERTED IMPEDANCE MATRIX FOR EQUIVALENT PHASE CONDUCTORS IS IN   M14.3469
  //C     P(1),...P(KP) (REAL PART) AND Z(1),...Z(KP) (IMAGINARY PART).     M14.3470
  if (jprmat(11) > 0) {
    output(cmn, metrik, p(1), z(1), unity, kcirct, ll5, ll2);
  }
  if (idist == 0) {
    goto statement_207;
  }
  FEM_DO_SAFE(i, 1, kp) {
    gd(i) = p(i);
    bd(i) = z(i);
  }
  statement_207:
  if (jprmat(12) == 0 || kcirct < 2) {
    goto statement_600;
  }
  symm(cmn, p(1), z(1), unity, kcirct, kk);
  //C     INVERTED IMPEDANCE MATRIX FOR SYMMETRICAL COMPONENTS OF EQUIVALENTM14.3479
  //C     PHASE CONDUCTORS IS IN P(1),...P(KK*(KK+1)/2) (REAL PART) AND Z(1)M14.3480
  //C     ,...Z(KK*(KK+1)/2) (IMAGINARY PART). DEFINITION OF KK SAME AS FOR M14.3481
  //C     INVERSE SUSCEPTANCE MATRIX                                        M14.3482
  output(cmn, metrik, p(1), z(1), unity, kk, ll5, ll3);
  goto statement_600;
  statement_250:
  if (j56 == 0) {
    goto statement_251;
  }
  {
    write_loop wloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(i, 1, ip) {
      wloop, p(i), z(i);
    }
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4227
  cmn.io.rewind(lunt13);
  statement_251:
  FEM_DO_SAFE(i, 1, ip) {
    p(i) = -p(i);
    z(i) = -z(i);
  }
  cxred2(p(1), z(1), workr1(1), workr2(1), kfull, ll0);
  //C     INVERTED IMPEDANCE MATRIX FOR PHYSICAL CONDUCTORS IS IN P(1),...  M14.3492
  //C     P(IP) (REAL PART) AND Z(1),...Z(IP) (IMAGINARY PART).             M14.3493
  output(cmn, metrik, p(1), z(1), unity, kfull, ll5, ll1);
  if (j56 == 0) {
    goto statement_600;
  }
  {
    read_loop rloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(i, 1, ip) {
      rloop, p(i), z(i);
    }
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4230
  cmn.io.rewind(lunt13);
  goto statement_201;
  statement_253:
  if (j56 == 0) {
    goto statement_254;
  }
  {
    write_loop wloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(i, 1, kp) {
      wloop, p(i), z(i);
    }
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4233
  cmn.io.rewind(lunt13);
  statement_254:
  goto statement_45454;
  //C  254 IF ( LASTOV .EQ. 39  .OR.                                        M43.3414
  //C     1          KCIRCT .GT. 3 ) GO TO 45454                            M43.3415
  statement_256:
  symm(cmn, p(1), z(1), unity, kcirct, kk);
  //C     IMPEDANCE MATRIX FOR SYMMETRICAL COMPONENTS OF EQUIVALENT PHASE   M14.3503
  //C     CONDUCTORS IS IN P(1),...P(KK*(KK+1)/2) (REAL PART) AND Z(1),...  M14.3504
  //C     Z(KK*(KK+1)/2) (IMAGINARY PART). DEFINITION OF KK SAME AS FOR     M14.3505
  //C     INVERSE SUSCEPTANCE MATRIX.                                       M14.3506
  if (j9out > 0) {
    output(cmn, metrik, p(1), z(1), unity, kk, ll6, ll3);
  }
  if (jprmat(6) == 0) {
    goto statement_9998;
  }
  rzero = p(1);
  xzero = z(1);
  rpos = p(ll5);
  xpos = z(ll5);
  zo = sqrtz(fem::pow2(rzero) + fem::pow2(xzero));
  z1 = sqrtz(fem::pow2(rpos) + fem::pow2(xpos));
  zso = sqrtz(zo / yzero);
  zs1 = sqrtz(z1 / ypos);
  zoang = std::atan2(xzero, rzero) * onehaf;
  z1ang = std::atan2(xpos, rpos) * onehaf;
  propo = sqrtz(zo * yzero);
  prop1 = sqrtz(z1 * ypos);
  zsodrg = zoang * picon - 45.f;
  zs1drg = z1ang * picon - 45.f;
  d2 = twopi / 8.0f;
  alphao = propo * cosz(zoang + d2);
  alpha1 = prop1 * cosz(z1ang + d2);
  beto = propo * sinz(zoang + d2);
  bet1 = prop1 * sinz(z1ang + d2);
  goto statement_2254;
  statement_45454:
  d13 = twopi * freq;
  //CCCC      write (*,*) ' Ready for Z avg.  P(1:6) =',                    M43.3418
  //CCCC     1                              ( P(I), I=1, 6 )                M43.3419
  //CCCC      write (*,*) ' Ready for Z avg.  Z(1:6) =',                    M43.3420
  //CCCC     1                              ( Z(I), I=1, 6 )                M43.3421
  //CCCC      write (*,*) ' imodal, nfreq =',  imodal, nfreq                M43.3422
  //C      IF (IMODAL .NE. 0)    GO TO 2254                                 M43.3423
  if (lastov == 39) {
    goto statement_6256;
  }
  if (imodal != 0) {
    goto statement_256;
  }
  goto statement_6276;
  statement_6256:
  if (nfreq == 1) {
    goto statement_9998;
  }
  if (imodal == 0) {
    goto statement_6276;
  }
  if (nfreq < 3) {
    goto statement_9998;
  }
  goto statement_3006;
  //C     IF (LASTOV .EQ. 39  .AND.  NFREQ  .EQ. 1)    GO TO 9998           M43.3425
  //CCCC  DOR = P(1)                                                        M32, 312
  //CCCC  DOI = Z(1)                                                        M32, 313
  //CCCC  D1R = P(LL5)                                                      M35.9082
  //CCCC  D1I = Z(LL5)                                                      M35.9083
  statement_6276:
  rdiag = 0;
  xdiag = 0;
  roff = 0;
  xoff = 0;
  n55 = 1;
  if (kcirct < 2) {
    goto statement_5059;
  }
  if (mspedb != 1) {
    goto statement_5090;
  }
  rcoup = 0.f;
  xcoup = 0.f;
  FEM_DO_SAFE(i, 1, 6) {
    rdiag += p(n55);
    xdiag += z(n55);
    if (n55 == 10) {
      goto statement_5028;
    }
    jm = n55 - i + 1;
    if (n55 >= 15) {
      jm += 3;
    }
    FEM_DO_SAFE(jp, jm, n55 - 1) {
      roff += p(jp);
      xoff += z(jp);
    }
    statement_5028:
    n55 += i + 1;
  }
  rdiag = rdiag / 6;
  xdiag = xdiag / 6;
  roff = roff / 6;
  xoff = xoff / 6;
  n55 = 6;
  FEM_DO_SAFE(jp, 4, 6) {
    j = n55 + 1;
    FEM_DO_SAFE(i, j, j + 2) {
      rcoup += p(i);
      xcoup += z(i);
    }
    n55 += jp;
  }
  rcoup = rcoup / 9;
  xcoup = xcoup / 9;
  xtir(1) = rdiag + 2 * roff + 3 * rcoup;
  xtii(1) = xdiag + 2 * xoff + 3 * xcoup;
  xtir(2) = xtir(1) - 6 * rcoup;
  xtii(2) = xtii(1) - 6 * xcoup;
  xtir(3) = rdiag - roff;
  xtii(3) = xdiag - xoff;
  if (lastov == 1) {
    goto statement_5080;
  }
  if (lastov != 39 && kexact != 88333) {
    goto statement_9998;
  }
  FEM_DO_SAFE(i, 1, 3) {
    zmmag = sqrtz(fem::pow2(xtir(i)) + fem::pow2(xtii(i)));
    zmang = std::atan2(xtii(i), xtir(i));
    ymmag = sqrtz(fem::pow2(gmode) + fem::pow2(dummi(i)));
    ymang = std::atan2(dummi(i), gmode);
    zsurge(i) = sqrtz(ymmag / zmmag);
    theta2(i) = (ymang - zmang) / 2.f;
    d1 = sqrtz(zmmag * ymmag);
    d2 = (zmang + ymang) / 2.f;
    er(i) = d1 * cosz(d2) * fmipkm;
    ei(i) = d1 * sinz(d2) * fmipkm;
    if (kexact != 88333) {
      goto statement_5053;
    }
    er(i) = d1 * cosz(d2) * distsv;
    ei(i) = d1 * sinz(d2) * distsv;
    statement_5053:;
  }
  FEM_DO_SAFE(i, 1, kcirct) {
    if (i > 2) {
      goto statement_5058;
    }
    write(lunit9, fem::unformatted), d13, zsurge(i), theta2(i), er(i), ei(i);
    goto statement_5060;
    statement_5058:
    write(lunit9, fem::unformatted), d13, zsurge(3), theta2(3), er(3), ei(3);
    statement_5060:;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "('  AT 5065, FREQ,KCIRCT,ZSURGE,THETA2,ER,EI ARE: ',/,e10.3,i3,"
        "12e9.2)");
      wloop, freq, kcirct;
      FEM_DO_SAFE(i, 1, 3) {
        wloop, zsurge(i), theta2(i), er(i), ei(i);
      }
    }
  }
  goto statement_9998;
  statement_5080:
  write(lunit7, format_228);
  FEM_DO_SAFE(i, 1, 3) {
    zsurge(i) = sqrtz(xtii(i) / dummi(i));
    er(i) = d13 / sqrtz(xtii(i) * dummi(i));
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, star);
      wloop, " ZSURGE, ER = ";
      FEM_DO_SAFE(i, 1, 3) {
        wloop, zsurge(i), er(i);
      }
    }
  }
  FEM_DO_SAFE(i, 1, kcirct) {
    if (i > 1) {
      goto statement_5082;
    }
    write(lunit7, format_140), i, brname(2 * i - 1), brname(2 * i),
      xtir(i), zsurge(i), er(i), dist;
    goto statement_5088;
    statement_5082:
    if (i > 2) {
      goto statement_5084;
    }
    write(lunit7, format_140), i, brname(2 * i - 1), brname(2 * i),
      xtir(3), zsurge(3), er(3), dist;
    goto statement_5088;
    statement_5084:
    if (i > 3) {
      goto statement_5086;
    }
    write(lunit7, format_140), i, brname(2 * i - 1), brname(2 * i),
      xtir(2), zsurge(2), er(2), dist;
    goto statement_5088;
    statement_5086:
    if (i <= 9) {
      write(lunit7, format_1475), i, brname(2 * i - 1), brname(2 * i);
    }
    if (i > 9) {
      write(lunit7, format_9475), i, brname(2 * i - 1), brname(2 * i);
    }
    statement_5088:;
  }
  write(lunit7, format_29);
  goto statement_9998;
  statement_5059:
  xtir(1) = p(1);
  xtii(1) = z(1);
  goto statement_480;
  //CCCC      write (*,*) ' Enter DO 478 loop.   KCIRCT =',  KCIRCT         M43.3515
  statement_5090:
  FEM_DO_SAFE(i, 1, kcirct) {
    rdiag += p(n55);
    xdiag += z(n55);
    FEM_DO_SAFE(jp, n55 - i + 1, n55 - 1) {
      roff += p(jp);
      xoff += z(jp);
    }
    n55 += i + 1;
  }
  rdiag = rdiag / kcirct;
  xdiag = xdiag / kcirct;
  roff = roff / (kcirct * (kcirct - 1) / 2);
  xoff = xoff / (kcirct * (kcirct - 1) / 2);
  //CCCC      write (*,*) ' Average of diagonals,  RDIAG, XDIAG =',  RDIAG, M43.3527
  //CCCC      write (*,*) ' Average of off-diag,  ROFF, XOFF =',  ROFF, XOFFM43.3528
  xtir(1) = rdiag + (kcirct - 1) * roff;
  xtii(1) = xdiag + (kcirct - 1) * xoff;
  xtir(2) = rdiag - roff;
  xtii(2) = xdiag - xoff;
  if (lastov == 39 || lastov == 45 || kexact == 88333) {
    goto statement_480;
  }
  if (iprsup < 1) {
    goto statement_1228;
  }
  {
    write_loop wloop(cmn, lunit6, star);
    wloop, " GMODE,XTIR, XTII, , DUMMI =", gmode;
    FEM_DO_SAFE(i, 1, 2) {
      wloop, xtir(i), xtii(i), dummi(i);
    }
  }
  statement_1228:
  write(lunit7, format_228);
  FEM_DO_SAFE(i, 1, 2) {
    zsurge(i) = sqrtz(xtii(i) / dummi(i));
    er(i) = d13 / sqrtz(xtii(i) * dummi(i));
  }
  FEM_DO_SAFE(i, 1, kcirct) {
    if (i > 2) {
      goto statement_1473;
    }
    write(lunit7, format_140), i, brname(2 * i - 1), brname(2 * i),
      xtir(i), zsurge(i), er(i), dist;
    goto statement_1480;
    statement_1473:
    if (i <= 9) {
      write(lunit7, format_1475), i, brname(2 * i - 1), brname(2 * i);
    }
    if (i > 9) {
      write(lunit7, format_9475), i, brname(2 * i - 1), brname(2 * i);
    }
    statement_1480:;
  }
  write(lunit7, format_29);
  goto statement_256;
  statement_480:
  FEM_DO_SAFE(i, 1, nmode) {
    zmmag = sqrtz(fem::pow2(xtir(i)) + fem::pow2(xtii(i)));
    zmang = std::atan2(xtii(i), xtir(i));
    ymmag = sqrtz(fem::pow2(gmode) + fem::pow2(dummi(i)));
    ymang = std::atan2(dummi(i), gmode);
    zsurge(i) = sqrtz(ymmag / zmmag);
    theta2(i) = (ymang - zmang) / 2.f;
    d1 = sqrtz(zmmag * ymmag);
    d2 = (zmang + ymang) / 2.f;
    er(i) = d1 * cosz(d2) * fmipkm;
    ei(i) = d1 * sinz(d2) * fmipkm;
    if (kexact != 88333) {
      goto statement_5093;
    }
    er(i) = d1 * cosz(d2) * distsv;
    ei(i) = d1 * sinz(d2) * distsv;
    statement_5093:;
  }
  FEM_DO_SAFE(i, 1, kcirct) {
    if (i > 1) {
      goto statement_5098;
    }
    write(lunit9, fem::unformatted), d13, zsurge(i), theta2(i), er(i), ei(i);
    goto statement_5094;
    statement_5098:
    write(lunit9, fem::unformatted), d13, zsurge(2), theta2(2), er(2), ei(2);
    statement_5094:;
  }
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6,
        "('  AT 5095, FREQ,KCIRCT,ZSURGE,THETA2,ER,EI ARE: ',/,e10.3,i3,"
        "8e12.3)");
      wloop, freq, kcirct;
      FEM_DO_SAFE(i, 1, 2) {
        wloop, zsurge(i), theta2(i), er(i), ei(i);
      }
    }
  }
  goto statement_9998;
  statement_2254:
  rzero1 = rzero;
  rpos1 = rpos;
  xzero1 = xzero;
  xpos1 = xpos;
  yzero1 = yzero;
  ypos1 = ypos;
  zo = 1000.f / omega;
  z1 = 1000000.f / omega;
  xzero = xzero * zo;
  xpos = xpos * zo;
  yzero = yzero * z1;
  ypos = ypos * z1;
  if (iprsup >= 1) {
    write(lunit6, "(' AT 13012, IPUNCH =',i10)"), ipunch;
  }
  if (ipunch == 0 || ipunch == 44) {
    goto statement_13039;
  }
  if (ipunch != 1) {
    goto statement_13011;
  }
  write(lunit7, "(5e15.5)"), alphao, beto, alpha1, bet1, freq;
  goto statement_13039;
  statement_13011:
  if (mfrqpr > 0) {
    write(lunit6, "(1x,e11.4,9e12.4,e12.5)"), alphao, beto, rzero,
      xzero, yzero, alpha1, bet1, rpos, xpos, ypos, freq;
  }
  if (ipunch != 2) {
    goto statement_13019;
  }
  write(lunit7, format_13015), rzero, xzero, freq;
  goto statement_13039;
  statement_13019:
  if (ipunch != 3) {
    goto statement_13024;
  }
  write(lunit7, format_13015), rpos, xpos, freq;
  goto statement_13039;
  statement_13024:
  if (ipunch != 88) {
    goto statement_13031;
  }
  if (metrik == 0) {
    goto statement_13026;
  }
  rzero = rzero * fmipkm;
  xzero = xzero * fmipkm;
  statement_13026:
  write(lunit9, fem::unformatted), rzero, xzero, freq;
  if (iprsup >= 1) {
    write(lunit6, "(' RZERO, XZERO AND FREQ ON UNIT9',3e15.6)"),
      rzero, xzero, freq;
  }
  goto statement_13039;
  statement_13031:
  if (ipunch == 89) {
    goto statement_13035;
  }
  kill = 162;
  lstat(19) = 13031;
  goto statement_9200;
  statement_13035:
  if (metrik == 0) {
    goto statement_13037;
  }
  rpos = rpos * fmipkm;
  xpos = xpos * fmipkm;
  statement_13037:
  write(lunit9, fem::unformatted), rpos, xpos, freq;
  statement_13039:
  if (ik > 0) {
    goto statement_3006;
  }
  vol = omega / beto;
  alphao = alphao * valu5;
  alpha1 = alpha1 * valu5;
  v1l = omega / bet1;
  waveo = twopi / beto;
  wave1 = twopi / bet1;
  if (metrik == 1) {
    goto statement_9992;
  }
  write(lunit6,
    "('0SEQUENCE',6x,'SURGE IMPEDANCE',7x,"
    "'ATTENUATION   VELOCITY    WAVELENGTH   RESISTANCE    REACTANCE   SUSCEPT"
    "ANCE',/,9x,"
    "'MAGNITUDE(OHM) ANGLE(DEGR.)   DB/MILE      MILES/S       MILES      OHM/"
    "MILE     OHM/MILE     MHO/MILE',/,'   ZERO  ',8e13.5,/,' POSITIVE',"
    "8e13.5)"),
    zso, zsodrg, alphao, vol, waveo, rzero, xzero1, yzero1, zs1,
    zs1drg, alpha1, v1l, wave1, rpos, xpos1, ypos1;
  goto statement_9998;
  statement_9992:
  alphao = alphao * fmipkm;
  alpha1 = alpha1 * fmipkm;
  vol = vol / fmipkm;
  v1l = v1l / fmipkm;
  waveo = waveo / fmipkm;
  wave1 = wave1 / fmipkm;
  rzero1 = rzero1 * fmipkm;
  rpos1 = rpos1 * fmipkm;
  xzero1 = xzero1 * fmipkm;
  xpos1 = xpos1 * fmipkm;
  yzero1 = yzero1 * fmipkm;
  ypos1 = ypos1 * fmipkm;
  write(lunit6,
    "('0SEQUENCE',6x,'SURGE IMPEDANCE',7x,"
    "'ATTENUATION   VELOCITY    WAVELENGTH   RESISTANCE    REACTANCE   SUSCEPT"
    "ANCE',/,9x,"
    "'MAGNITUDE(OHM) ANGLE(DEGR.)    DB/KM         KM/S          KM        OHM"
    "/KM       OHM/KM       MHO/KM ',/,'   ZERO  ',8e13.5,/,' POSITIVE',"
    "8e13.5)"),
    zso, zsodrg, alphao, vol, waveo, rzero1, xzero1, yzero1, zs1,
    zs1drg, alpha1, v1l, wave1, rpos1, xpos1, ypos1;
  statement_9998:
  if (kexact != 88333) {
    goto statement_9996;
  }
  n1 = 1;
  n9sq = fem::pow2(kcirct);
  if (mspedb == 1) {
    goto statement_9540;
  }
  k = 1;
  FEM_DO_SAFE(j, 1, kcirct) {
    FEM_DO_SAFE(i, 1, kcirct) {
      dummr(k) = 1.f;
      if (i == j && i != 1) {
        dummr(k) = 1 - i;
      }
      if (i > j && j != 1) {
        dummr(k) = 0.f;
      }
      k++;
    }
  }
  FEM_DOSTEP(i, 1, n9sq, kcirct) {
    k = i + kcirct - 1;
    temp = 0.f;
    FEM_DO_SAFE(j, i, k) {
      temp += fem::pow2(dummr(j));
    }
    temp = sqrtz(temp);
    FEM_DO_SAFE(j, i, k) {
      tixf(n1) = dummr(j) / temp;
      work1(n1) = 0.0f;
      n1++;
    }
  }
  goto statement_9994;
  statement_9540:
  d1 = 2.0f;
  d2 = 6.0f;
  d3 = 1.0f / sqrtz(d1);
  d4 = 1.0f / sqrtz(d2);
  FEM_DO_SAFE(j, 1, 36) {
    if (j > 9) {
      goto statement_15975;
    }
    tixf(n1) = d4;
    goto statement_25960;
    statement_15975:
    if (j > 12) {
      goto statement_15980;
    }
    tixf(n1) = -d4;
    goto statement_25960;
    statement_15980:
    if (j > 13) {
      goto statement_15985;
    }
    tixf(n1) = d3;
    goto statement_25960;
    statement_15985:
    if (j > 14) {
      goto statement_15990;
    }
    tixf(n1) = -d3;
    goto statement_25960;
    statement_15990:
    if (j > 18) {
      goto statement_15991;
    }
    tixf(n1) = 0.0f;
    goto statement_25960;
    statement_15991:
    if (j > 20) {
      goto statement_15992;
    }
    tixf(n1) = d4;
    goto statement_25960;
    statement_15992:
    if (j > 21) {
      goto statement_15993;
    }
    tixf(n1) = -d1 * d4;
    goto statement_25960;
    statement_15993:
    if (j > 27) {
      goto statement_15994;
    }
    tixf(n1) = 0.0f;
    goto statement_25960;
    statement_15994:
    if (j > 28) {
      goto statement_15995;
    }
    tixf(n1) = d3;
    goto statement_25960;
    statement_15995:
    if (j > 29) {
      goto statement_15996;
    }
    tixf(n1) = -d3;
    goto statement_25960;
    statement_15996:
    if (j > 33) {
      goto statement_15997;
    }
    tixf(n1) = 0.0f;
    goto statement_25960;
    statement_15997:
    if (j > 35) {
      goto statement_15999;
    }
    tixf(n1) = d4;
    goto statement_25960;
    statement_15999:
    tixf(n1) = -d1 * d4;
    statement_25960:
    work1(n1) = 0.0f;
    n1++;
  }
  statement_9994:
  {
    write_loop wloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(i, 1, n9sq) {
      wloop, tixf(i);
    }
    FEM_DO_SAFE(i, 1, n9sq) {
      wloop, work1(i);
    }
  }
  statement_9996:
  if (j56 == 0) {
    goto statement_600;
  }
  {
    read_loop rloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(i, 1, kp) {
      rloop, p(i), z(i);
    }
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4236
  cmn.io.rewind(lunt13);
  goto statement_203;
  //C                          END OF ROUTINES FOR Z-PRINTING AND INVERSIONSM14.3558
  //C                                                                       M14.3559
  //C                                ROUTINES FOR P-PRINTING AND INVERSIONS M14.3560
  statement_36:
  i2 = 1;
  //C     INVERSE SUSCEPTANCE OR CAPACITANCE MATRIX FOR PHYSICAL CONDUCTORS M14.3562
  //C     IS IN P(1),...P(IP).                                              M14.3563
  if (iw == 0) {
    i2++;
  }
  output(cmn, metrik, p(1), z(1), identifier_switch, kfull, i2, ll1);
  goto statement_31;
  statement_37:
  i2 = 3;
  if (iprsup >= 1) {
    write(lunit6, "(/,' AT 4444.  IW, IP, LL0, LL1=',4i10)"), iw, ip, ll0, ll1;
  }
  if (iw == 0) {
    i2++;
  }
  FEM_DO_SAFE(i, 1, ip) {
    z(i) = -p(i);
  }
  redu44(cmn, z(1), workr1(1), kfull, ll0);
  if (kill > 0) {
    goto statement_9200;
  }
  //C     SUSCEPTANCE OR CAPACITANCE MATRIX FOR PHYSICAL CONDUCTORS IS IN   M14.3580
  //C     Z(1),...Z(IP).                                                    M14.3581
  output(cmn, metrik, z(1), p(1), identifier_switch, kfull, i2, ll1);
  goto statement_32;
  statement_38:
  i2 = 1;
  //C     INVERSE SUSCEPTANCE OR CAPACITANCE MATRIX FOR EQUIVALENT PHASE    M14.3585
  //C     CONDUCTORS IS IN P(1),...P(KP)                                    M14.3586
  //C     TO STORE WC(INV) OR C(INV) FOR MODAL ANALYSIS                     M29.4238
  if (iprsup >= 1) {
    write(6, star), " At S.N. 38,  P(1) =", p(1);
  }
  if (imodal <= 0) {
    goto statement_403;
  }
  FEM_DO_SAFE(i, 1, kp) {
    xwc(i) = p(i);
  }
  statement_403:
  if (iw == 0) {
    i2++;
  }
  if (j2out > 0) {
    output(cmn, metrik, p(1), z(1), identifier_switch, kcirct, i2, ll2);
  }
  if (iprsup >= 4) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' BEFORE ''C''-MATRIX CALL TO  ''SYMM'' .',"
        "'      J3  KCIRCT     J56      KP','      IW      I2      J2',/,36x,"
        "7i8,/,' (P(I), I=1, KP)  FOLLOW ....',/(1x,8e16.7))");
      wloop, jprmat(3), kcirct, j56, kp, iw, i2, jprmat(2);
      FEM_DO_SAFE(i, 1, kp) {
        wloop, p(i);
      }
    }
  }
  if (jprmat(3) == 0 || kcirct < 2) {
    goto statement_33;
  }
  if (j56 == 0) {
    goto statement_40;
  }
  {
    write_loop wloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(i, 1, kp) {
      wloop, p(i);
    }
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.4245
  cmn.io.rewind(lunt13);
  statement_40:
  symm(cmn, p(1), z(1), identifier_switch, kcirct, kk);
  i2 = 1;
  if (iw == 0) {
    i2++;
  }
  //C     INVERSE SUSCEPTANCE OR CAPACITANCE MATRIX FOR SYMMETRICAL COMPO-  M14.3597
  //C     NENTS OF EQUIVALENT PHASE CONDUCTORS (GROUPED AS 3-PHASE CIRCUITS M14.3598
  //C     IN ORDER 1-2-3, 4-5-6 ETC.) IS IN P(1),...P(KK*(KK+1)/2) FOR REAL M14.3599
  //C     PART AND Z(1),...Z(KK*(KK+1)/2) FOR IMAGINARY PART WITH KK=HIGHESTM14.3600
  //C     NUMBER OF EQUIVALENT CONDUCTOR BEING A MULTIPLE OF 3.             M14.3601
  if (ik <= 0) {
    output(cmn, metrik, p(1), z(1), unity, kk, i2, ll3);
  }
  if (j56 == 0) {
    goto statement_33;
  }
  read(lunt13, fem::unformatted), d1;
  {
    read_loop rloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(i, 1, kp) {
      rloop, p(i);
    }
  }
  goto statement_33;
  statement_39:
  i2 = 3;
  if (iw == 0) {
    i2++;
  }
  FEM_DO_SAFE(i, 1, kp) {
    p(i) = -p(i);
  }
  redu44(cmn, p(1), workr1(1), kcirct, ll0);
  if (kill > 0) {
    goto statement_9200;
  }
  //C     SUSCEPTANCE OR CAPACITANCE MATRIX FOR EQUIVALENT PHASE CONDUCTORS M14.3613
  //C     IS IN P(1),...P(KP).                                              M14.3614
  if (imodal == 1) {
    goto statement_1378;
  }
  if (iprsup < 1) {
    goto statement_5124;
  }
  {
    write_loop wloop(cmn, 6, star);
    wloop, " Ready for [C] avg.  P(1:6) =";
    FEM_DO_SAFE(i, 1, 6) {
      wloop, p(i);
    }
  }
  write(lunit6, star), " Begin averaging of capacitance.";
  write(lunit6, star), " 1st diagonal,  P(1) =", p(1);
  write(lunit6, star), " 1st off-diagonal,  P(2) =", p(2);
  write(lunit6, star), " =======  IW, KCIRCT, freq =", iw, kcirct, freq;
  statement_5124:
  cdiag = 0;
  coff = 0;
  n55 = 1;
  if (mspedb != 1) {
    goto statement_5190;
  }
  ccoup = 0.f;
  FEM_DO_SAFE(i, 1, 6) {
    cdiag += p(n55);
    if (n55 == 10) {
      goto statement_5128;
    }
    jm = n55 - i + 1;
    if (n55 >= 15) {
      jm += 3;
    }
    FEM_DO_SAFE(jp, jm, n55 - 1) {
      coff += p(jp);
    }
    statement_5128:
    n55 += i + 1;
  }
  cdiag = cdiag / 6;
  coff = coff / 6;
  if (iprsup >= 1) {
    write(lunit6, star), " CDIAG, COFF are ", cdiag, coff;
  }
  n55 = 6;
  FEM_DO_SAFE(jp, 4, 6) {
    j = n55 + 1;
    FEM_DO_SAFE(i, j, j + 2) {
      ccoup += p(i);
    }
    n55 += jp;
  }
  ccoup = ccoup / 9;
  dummi(1) = cdiag + 2 * coff + 3 * ccoup;
  dummi(2) = dummi(1) - 6 * ccoup;
  dummi(3) = cdiag - coff;
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, lunit6, star);
      wloop, " AT 5150, DUMMI =";
      FEM_DO_SAFE(i, 1, 3) {
        wloop, dummi(i);
      }
    }
  }
  if (iw == 0) {
    goto statement_1378;
  }
  d13 = twopi * freq;
  FEM_DO_SAFE(i, 1, 3) {
    dummi(i) = dummi(i) * d13;
  }
  goto statement_1378;
  statement_5190:
  if (kcirct < 2) {
    goto statement_1379;
  }
  FEM_DO_SAFE(i, 1, kcirct) {
    cdiag += p(n55);
    FEM_DO_SAFE(jp, n55 - i + 1, n55 - 1) {
      coff += p(jp);
    }
    n55 += i + 1;
  }
  cdiag = cdiag / kcirct;
  coff = coff / (kcirct * (kcirct - 1) / 2);
  //C     write (*,*) ' Average of diagonals,  CDIAG =',  CDIAG             M43.3635
  //C     write (*,*) ' Average of off-diag,   COFF =',   COFF              M43.3636
  dummi(1) = cdiag + (kcirct - 1) * coff;
  dummi(2) = cdiag - coff;
  goto statement_2379;
  statement_1379:
  dummi(1) = p(1);
  dummi(2) = 0.f;
  statement_2379:
  if (iw == 0) {
    goto statement_1378;
  }
  d13 = twopi * freq;
  dummi(1) = dummi(1) * d13;
  dummi(2) = dummi(2) * d13;
  statement_1378:
  if (j5out > 0) {
    output(cmn, metrik, p(1), z(1), identifier_switch, kcirct, i2, ll2);
  }
  zero = 0.0f;
  if (ialter <= 0) {
    goto statement_3741;
  }
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(jj, 1, kp) {
      wloop, zero;
    }
  }
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(jj, 1, kp) {
      wloop, p(jj);
    }
  }
  if (iprsup <= 0) {
    goto statement_3741;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' OUTPUT  (C)  FOR SEMLYEN.',/(1x,8e16.4))");
    FEM_DO_SAFE(jj, 1, kp) {
      wloop, p(jj);
    }
  }
  statement_3741:
  if (idist == 0) {
    goto statement_393;
  }
  FEM_DO_SAFE(i, 1, kp) {
    yd(i) = p(i);
  }
  statement_393:
  if (jprmat(6) == 0 || kcirct < 2) {
    goto statement_80;
  }
  symm(cmn, p(1), z(1), identifier_switch, kcirct, kk);
  i2 = 3;
  if (iw == 0) {
    i2++;
  }
  //C     SUSCEPTANCE OR CAPACITANCE MATRIX FOR SYMMETRICAL COMPONENTS OF   M14.3624
  //C     EQUIVALENT PHASE CONDUCTORS IS IN P(1),...P(KK*(KK+1)/2) FOR REAL M14.3625
  //C     PART AND Z(1),...Z(KK*(KK+1)/2) FOR IMAGINARY PART. DEFINITION OF M14.3626
  //C     KK SAME AS FOR INVERSE SUSCEPTANCE MATRIX                         M14.3627
  if (j6out > 0) {
    output(cmn, metrik, p(1), z(1), unity, kk, i2, ll3);
  }
  if (ipunch < 88) {
    goto statement_399;
  }
  if (ipunch > 89) {
    goto statement_399;
  }
  if (ik > 0) {
    goto statement_399;
  }
  if (liu != 0) {
    goto statement_399;
  }
  czero = p(1) / tenm6;
  cpos = p(ll5) / tenm6;
  if (iw != 0) {
    goto statement_394;
  }
  czero = czero / omega;
  cpos = cpos / omega;
  statement_394:
  if (ipunch != 88) {
    goto statement_395;
  }
  if (metrik == 1) {
    czero = czero * fmipkm;
  }
  write(lunit9, fem::unformatted), czero;
  if (iprsup >= 1) {
    write(lunit6, "(' CZERO ON UNIT9',e15.6)"), czero;
  }
  goto statement_396;
  statement_395:
  if (metrik == 1) {
    cpos = cpos * fmipkm;
  }
  write(lunit9, fem::unformatted), cpos;
  if (iprsup >= 1) {
    write(lunit6, "(' CPOS ON UNIT9',e15.6)"), cpos;
  }
  statement_396:
  liu = 1;
  statement_399:
  yzero = p(1);
  ypos = p(ll5);
  if (iw == 0) {
    goto statement_80;
  }
  yzero = yzero * omega;
  ypos = ypos * omega;
  goto statement_80;
  //C                          END OF ROUTINES FOR P-PRINTING AND INVERSIONSM14.3635
  //C                                                                       M14.3636
  //C                                        CHANGES IN CONDUCTOR DATA      M14.3637
  statement_500:
  icount = 0;
  k = 0;
  if (kcirct == 0) {
    goto statement_503;
  }
  i2 = lphpl1 - kcirct;
  i = lphase;
  kk = -1;
  statement_501:
  k++;
  itbic(k) = ic(i);
  tbtb2(k) = tb2(i);
  itbtb3(k) = itb3(i);
  tbr(k) = r(i);
  tbd(k) = dz(i);
  tbg(k) = gmd(i);
  tbx(k) = x(i);
  tby(k) = y(i);
  tbtext(k) = text(i);
  if (i == i2) {
    goto statement_502;
  }
  i += kk;
  goto statement_501;
  statement_502:
  if (icount > 0) {
    goto statement_504;
  }
  statement_503:
  icount = 1;
  i = 1;
  i2 = ktot;
  kk = 1;
  if (ktot > 0) {
    goto statement_501;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M14.3663
  statement_504:
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  read(abuff, format_11), i1, y1, r1, i2, g1, d1, x1, h1, h2, d8, d9, bus1, i3;
  if (i1 != 0) {
    goto statement_4423;
  }
  if (y1 != 0) {
    goto statement_4423;
  }
  if (r1 != 0) {
    goto statement_4423;
  }
  if (i2 != 0) {
    goto statement_4423;
  }
  if (g1 != 0.0f) {
    goto statement_4423;
  }
  if (d1 != 0.0f) {
    goto statement_4423;
  }
  if (x1 != 0.0f) {
    goto statement_4423;
  }
  if (h1 != 0.0f) {
    goto statement_4423;
  }
  if (h2 != 0.0f) {
    goto statement_4423;
  }
  if (d8 != 0.0f) {
    goto statement_4423;
  }
  if (d9 != 0.0f) {
    goto statement_4423;
  }
  if (bus1 == blank) {
    goto statement_507;
  }
  statement_4423:
  isw = 1;
  i = 0;
  statement_1505:
  i++;
  if (i > kfull) {
    goto statement_505;
  }
  if (tbtext(i) == bus1) {
    goto statement_506;
  }
  goto statement_1505;
  statement_505:
  if (isw == 2) {
    goto statement_504;
  }
  kfull++;
  if (kfull > lphase) {
    goto statement_7;
  }
  i = kfull;
  itbic(i) = i1;
  tbtb2(i) = y1;
  tbr(i) = r1;
  itbtb3(i) = i2;
  tbg(i) = g1;
  tbd(i) = d1;
  tbx(i) = x1;
  tbtext(i) = bus1;
  FEM_THROW_UNHANDLED("executable assign: assign711tomoon");
  goto statement_4280;
  statement_506:
  read(abuff, format_4281), bus1;
  if (bus1 != blank) {
    itbic(i) = i1;
  }
  read(abuff, format_4286), bus1;
  if (bus1 != blank) {
    tbtb2(i) = y1;
  }
  read(abuff, format_4292), bus1, bus2;
  if (bus1 != blank) {
    tbr(i) = r1;
  }
  if (bus2 != blank) {
    tbr(i) = r1;
  }
  read(abuff, format_4297), bus1;
  if (bus1 != blank) {
    itbtb3(i) = i2;
  }
  read(abuff, format_4306), bus1, bus2;
  if (bus1 != blank) {
    tbg(i) = g1;
  }
  if (bus2 != blank) {
    tbg(i) = g1;
  }
  read(abuff, format_4313), bus1, bus2;
  if (bus1 != blank) {
    tbd(i) = d1;
  }
  if (bus2 != blank) {
    tbd(i) = d1;
  }
  isw = 2;
  goto statement_1505;
  statement_711:
  if (i3 <= 1) {
    goto statement_716;
  }
  i4 = 1;
  xx = tbx(i);
  yy = tby(i);
  angl = (pi - twopi / i3) / 2.0f;
  dangl = twopi / i3;
  radius = d8 / (24.0f * cosz(angl));
  d9r = d9 / picon;
  statement_713:
  tbx(i) = xx + radius * cosz(d9r - dangl * i4);
  tby(i) = yy + radius * sinz(d9r - dangl * i4);
  if (i4 == i3) {
    goto statement_716;
  }
  i4++;
  i++;
  itbic(i) = itbic(i - 1);
  tbtb2(i) = tbtb2(i - 1);
  tbr(i) = tbr(i - 1);
  itbtb3(i) = itbtb3(i - 1);
  tbg(i) = tbg(i - 1);
  tbd(i) = tbd(i - 1);
  tbtext(i) = tbtext(i - 1);
  goto statement_713;
  statement_716:
  kfull = i;
  goto statement_504;
  statement_507:
  i = kfull + 1;
  goto statement_6;
  //C                                                                       M14.3742
  //C                            EXTENDING THE MATRICES FOR SPECIFIED LENGTHM14.3743
  statement_600:
  if (dist == 0.f) {
    goto statement_16;
  }
  j1516 = jprmat(15) + jprmat(16);
  if (jprmat(13) + jprmat(14) + j1516 == 0) {
    goto statement_16;
  }
  if (metrik == 1) {
    goto statement_610;
  }
  write(lunit6, "(/,' MATRICES FOR LINE LENGTH =',e13.6,' MILES.')"), dist;
  goto statement_612;
  statement_610:
  distm = dist / fmipkm;
  write(lunit6, "(/,' MATRICES FOR LINE LENGTH =',f8.3,' KM.')"), distm;
  statement_612:
  if (idist == 1) {
    goto statement_603;
  }
  write(lunit6,
    "('+',41x,'CANNOT BE CALCULATED WITH NUMBER OF EQUIVALENT CONDUCTORS=',"
    "i3)"),
    kcirct;
  goto statement_16;
  statement_603:
  ip = 0;
  d1 = fltinf;
  k = 0;
  statement_604:
  k++;
  if (k > kcirct) {
    goto statement_605;
  }
  ip += k;
  h1 = valu6 * bd(ip) / yd(ip);
  if (std::abs(h1) < d1) {
    d1 = std::abs(h1);
  }
  goto statement_604;
  statement_605:
  if (iw > 0) {
    d1 = d1 / omega;
  }
  d1 = sqrtz(d1 * 2.0f);
  i1 = dist / d1 + onehaf;
  i2 = 1;
  FEM_DO_SAFE(isec, 1, 34) {
    if (i1 <= i2) {
      goto statement_608;
    }
    i2 = i2 * 2;
  }
  write(lunit6,
    "('+',41x,'CANNOT BE CALCULATED WITH NUMBER OF NECESSARY SECTIONS=2**33')");
  goto statement_16;
  statement_608:
  x1 = i2;
  i1 = isec - 1;
  deltad = dist / x1;
  if (metrik == 1) {
    goto statement_613;
  }
  write(lunit6,
    "(' COMPUTED BY CONNECTING IN CASCADE 2**',i2,' EQUAL SECTIONS OF',e13.6,"
    "' MILES EACH.')"),
    i1, deltad;
  goto statement_615;
  statement_613:
  deltam = deltad / fmipkm;
  write(lunit6,
    "('+',41x,'COMPUTED BY CONNECTING IN SERIES 2**',i2,' EQUAL SECTIONS OF',"
    "f9.4,' KM EACH.')"),
    i1, deltam;
  statement_615:
  f1 = unity / deltad;
  f2 = deltad * onehaf;
  if (iw > 0) {
    f2 = omega * f2;
  }
  kp = kcirct * (kcirct + 1) / 2;
  kcir2 = kcirct + kcirct;
  if (i1 == 0) {
    goto statement_670;
  }
  FEM_DO_SAFE(i, 1, kp) {
    r1 = f1 * gd(i);
    x1 = f1 * bd(i);
    g1 = f2 * yd(i);
    d1 = x1 + g1;
    p(i) = r1;
    z(i) = d1;
    gd(i) = r1 + r1;
    bd(i) = x1 + d1;
  }
  //C                                  BEGIN OF LOOP FOR CONNECTING SECTIONSM14.3794
  icount = 0;
  statement_622:
  icount++;
  if (icount == isec) {
    goto statement_650;
  }
  //C                                       EXPANDING MATRIX                M14.3798
  ip = 0;
  i3 = kp;
  k = 0;
  statement_623:
  k++;
  if (k > kcirct) {
    goto statement_626;
  }
  i2 = i3 + kcirct;
  l4 = kp + k;
  i = 0;
  statement_624:
  i++;
  l1 = ip + i;
  l2 = i2 + i;
  l3 = i3 + i;
  r1 = p(l1);
  x1 = z(l1);
  h1 = r1 - gd(l1);
  h2 = x1 - bd(l1);
  p(l2) = r1 * 2.0f;
  z(l2) = x1 * 2.0f;
  p(l3) = h1;
  z(l3) = h2;
  gd(l1) = r1;
  bd(l1) = x1;
  if (i == k) {
    goto statement_625;
  }
  p(l4) = h1;
  z(l4) = h2;
  l4 += i + kcirct;
  goto statement_624;
  statement_625:
  ip += k;
  i3 = i2 + k;
  goto statement_623;
  statement_626:
  cxred2(p(1), z(1), workr1(1), workr2(1), kcir2, kcirct);
  goto statement_622;
  //C                                       OUTPUT OF MATRICES FOR LENGTH   M14.3831
  statement_650:
  FEM_DO_SAFE(i, 1, kp) {
    gd(i) = gd(i) - p(i);
    bd(i) = bd(i) - z(i);
    p(i) = (p(i) - gd(i)) * 2.f;
    z(i) = (z(i) - bd(i)) * 2.f;
  }
  statement_673:
  if (j1516 > 0) {
    goto statement_660;
  }
  statement_652:
  if (jprmat(13) == 0) {
    goto statement_653;
  }
  //C     TRANSFER ADMITTANCE MATRIX FOR EQUIVALENT COND. IS IN GD+J*BD.    M14.3839
  output(cmn, ll0, gd(1), bd(1), unity, kcirct, ll7, ll2);
  //C     SHUNT ADMITTANCE MATRIX FOR EQUIVALENT COND. IS IN P+J*Z.         M14.3841
  output(cmn, ll0, p(1), z(1), unity, kcirct, ll8, ll2);
  statement_653:
  if (jprmat(14) == 0) {
    goto statement_654;
  }
  symm(cmn, gd(1), bd(1), unity, kcirct, kk);
  //C     TRANSFER ADMITTANCE MATRIX FOR SYMMETRICAL COMP. IS IN GD+J*BD.   M14.3845
  output(cmn, ll0, gd(1), bd(1), unity, kk, ll7, ll3);
  symm(cmn, p(1), z(1), unity, kcirct, kk);
  //C     SHUNT ADMITTANCE MATRIX FOR SYMMETRICAL COMP. IS IN P+J*Z.        M14.3848
  output(cmn, ll0, p(1), z(1), unity, kk, ll8, ll3);
  statement_654:
  if (j1516 == 0) {
    goto statement_16;
  }
  FEM_DO_SAFE(i, 1, kp) {
    n1 = 2 * lgdbd + 1 + i;
    n2 = i + lgdbd;
    gd(i) = -p(n2);
    bd(i) = -z(n2);
    p(i) = -p(n1);
    z(i) = -z(n1);
  }
  cxred2(gd(1), bd(1), workr1(1), workr2(1), kcirct, ll0);
  cxred2(p(1), z(1), workr1(1), workr2(1), kcirct, ll0);
  if (jprmat(15) == 0) {
    goto statement_656;
  }
  //C     TRANSFER IMPEDANCE MATRIX FOR EQUIVALENT CONDUCTORS IS IN GD+J*BD.M14.3860
  output(cmn, ll0, gd(1), bd(1), unity, kcirct, ll9, ll2);
  //C     SHUNT IMPEDANCE MATRIX FOR EQUIVALENT CONDUCTORS IS IN P+J*Z.     M14.3862
  output(cmn, ll0, p(1), z(1), unity, kcirct, ll10, ll2);
  statement_656:
  if (jprmat(16) == 0) {
    goto statement_16;
  }
  symm(cmn, gd(1), bd(1), unity, kcirct, kk);
  //C     TRANSFER IMPEDANCE MATRIX FOR SYMMETRICAL COMP. IS IN GD+J*BD.    M14.3866
  output(cmn, ll0, gd(1), bd(1), unity, kk, ll9, ll3);
  symm(cmn, p(1), z(1), unity, kcirct, kk);
  //C     SHUNT IMPEDANCE MATRIX FOR SYMMETRICAL COMP. IS IN P+J*Z.         M14.3869
  output(cmn, ll0, p(1), z(1), unity, kk, ll10, ll3);
  goto statement_16;
  statement_660:
  i = lgdbd + 1;
  mover(gd(1), p(i), kp);
  mover(bd(1), z(i), kp);
  i = 2 * i;
  mover(p(1), p(i), kp);
  mover(z(1), z(i), kp);
  goto statement_652;
  statement_670:
  f2 = f2 * 2.f;
  FEM_DO_SAFE(i, 1, kp) {
    p(i) = 0.f;
    z(i) = f2 * yd(i);
    gd(i) = f1 * gd(i);
    bd(i) = f1 * bd(i);
  }
  goto statement_673;
  statement_9200:
  lstat(18) = nchain;
  if (ialter == 2) {
    lunit5 = l5save;
  }
  lastov = nchain;
  nchain = 51;
  statement_9900:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
subr44(
  common& cmn) try
{
  common_write write(cmn);
  fem::str<8>& trash = cmn.trash;
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  int& kburro = cmn.kburro;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& lphase = cmn.lphase;
  //
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int n8 = fem::int0;
  arr_1d<20, int> lltemp(fem::fill0);
  int j = fem::int0;
  int n7 = fem::int0;
  int n3 = fem::int0;
  int i = fem::int0;
  int ndim = fem::int0;
  int ntri = fem::int0;
  int nsqr = fem::int0;
  int nsqr2 = fem::int0;
  int iofarr = fem::int0;
  int iofxwc = fem::int0;
  int iofxwy = fem::int0;
  int iofyzr = fem::int0;
  int iofyzi = fem::int0;
  int ioftii = fem::int0;
  int ioftir = fem::int0;
  int ioftvi = fem::int0;
  int ioftvr = fem::int0;
  int iofer = fem::int0;
  int iofei = fem::int0;
  int iofthe = fem::int0;
  int iofxtr = fem::int0;
  int iofxti = fem::int0;
  int iofzsu = fem::int0;
  int iofdum = fem::int0;
  int iofdur = fem::int0;
  int ioftix = fem::int0;
  int iofwor = fem::int0;
  int n5 = fem::int0;
  arr_1d<1, double> stg(fem::fill0);
  //C!w EQUIVALENCE (STG(1), KARRAY(1) )
  //C     LIST-ZERO "KARRAY" IS ALWAYS 1ST, AND MAYBE "OVER29":             M31.6302
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE SUBR44.\"')");
  }
  n8 = nchain;
  if (kburro == 1) {
    n8 = 29;
  }
  dimens(lltemp(1), n8, trash, trash);
  FEM_DOSTEP(j, 1, 9999, 2) {
    if (lltemp(j) == 0) {
      goto statement_5636;
    }
  }
  write(lunit6, "(' TEMP ERROR STOP IN \"SUBR44\".',3i8)"), lltemp(1),
    kburro, nchain;
  stoptp(cmn);
  statement_5636:
  n7 = lltemp(j + 1) * nbyte(4) / nbyte(3);
  dimens(lltemp(1), nchain, trash, trash);
  n3 = 0;
  FEM_DOSTEP(i, 1, 9999, 2) {
    if (n3 >= 2) {
      goto statement_5655;
    }
    if (lltemp(i) != 71) {
      goto statement_5641;
    }
    lphase = lltemp(i + 1);
    n3++;
    statement_5641:
    if (lltemp(i) != 74) {
      goto statement_5654;
    }
    cmn.lgdbd = lltemp(i + 1);
    n3++;
    statement_5654:;
  }
  stoptp(cmn);
  statement_5655:
  cmn.lphpl1 = lphase + 1;
  cmn.lphd2 = lphase / 2;
  write(kunit6, "('+REQUEST FOR LINE-CONSTANTS SUPPORTING PROG.',i6)"), lphase;
  ndim = lphase;
  ntri = ndim * (ndim + 1) / 2;
  nsqr = ndim * ndim;
  nsqr2 = 2 * nsqr;
  iofarr = 1;
  iofxwc = iofarr + ntri;
  iofxwy = iofxwc + ntri;
  iofyzr = iofxwy + ntri;
  iofyzi = iofyzr + nsqr;
  ioftii = iofyzi + nsqr;
  ioftir = ioftii + nsqr;
  ioftvi = ioftir + nsqr;
  ioftvr = ioftvi + nsqr;
  iofer = ioftvr + nsqr;
  iofei = iofer + ndim;
  iofthe = iofei + ndim;
  iofxtr = iofthe + ndim;
  iofxti = iofxtr + ndim;
  iofzsu = iofxti + ndim;
  iofdum = iofzsu + ndim;
  iofdur = iofdum + ndim;
  ioftix = iofdur + ndim;
  iofwor = ioftix + nsqr2;
  n5 = iofwor + nsqr2;
  if (n5 < n7) {
    goto statement_10;
  }
  cmn.kill = 82;
  lstat(19) = 10;
  lstat(15) = lphase;
  lstat(18) = nchain;
  cmn.lastov = nchain;
  nchain = 51;
  goto statement_99999;
  statement_10:
  guts44(cmn, stg(iofarr), stg(iofxwc), stg(iofxwy), stg(iofyzr), stg(iofyzi),
    stg(ioftii), stg(ioftir), stg(ioftvi), stg(ioftvr), stg(iofer),
    stg(iofei), stg(iofthe), stg(iofxtr), stg(iofxti), stg(iofzsu),
    stg(iofdum), stg(iofdur), stg(ioftix), stg(iofwor), ndim, ntri,
    nsqr2);
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE SUBR44.\"')");
  }
  statement_99999:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
over44(
  common& cmn) try
{
  //C!INCLUDE 'DECK29.inc'
  //C!COMMON  / C44B02 /   P     (   22155 )
  //C!COMMON  / C44B03 /   Z     (   22155 )
  //C!COMMON  / C44B04 /   IC    (     210 )
  //C!COMMON  / C44B05 /   R     (     210 )
  //C!COMMON  / C44B06 /   D     (     210 )
  //C!COMMON  / C44B07 /   GMD   (     210 )
  //C!COMMON  / C44B08 /   X     (     210 )
  //C!COMMON  / C44B09 /   Y     (     210 )
  //C!COMMON  / C44B10 /   TB2   (     210 )
  //C!COMMON  / C44B11 /   ITB3  (     210 )
  //C!COMMON  / C44B12 /   WORKR1(     210 )
  //C!COMMON  / C44B13 /   WORKR2(     210 )
  //C!COMMON  / C44B14 /   TEXT  (     420 )
  //C!character*8            TEXT
  //C!COMMON  / C44B15 /   GD    (    5565 )
  //C!COMMON  / C44B16 /   BD    (    5565 )
  //C!COMMON  / C44B17 /   YD    (    5565 )
  //C!COMMON  / C44B18 /   ITBIC (     211 )
  //C!COMMON  / C44B19 /   TBR   (     211 )
  //C!COMMON  / C44B20 /   TBD   (     211 )
  //C!COMMON  / C44B21 /   TBG   (     211 )
  //C!COMMON  / C44B22 /   TBX   (     211 )
  //C!COMMON  / C44B23 /   TBY   (     211 )
  //C!COMMON  / C44B24 /   TBTB2 (     211 )
  //C!COMMON  / C44B25 /   ITBTB3(     211 )
  //C!COMMON  / C44B26 /   TBTEXT(     211 )
  //C!character*8            TBTEXT
  subr44(cmn);
  //C!COMMON  / C29B01 /   KARRAY(1)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
cxc(
  common& cmn,
  arr_cref<double> a,
  arr_ref<double> b,
  arr_ref<double> c,
  int const& kode) try
{
  a(dimension(1));
  b(dimension(1));
  c(dimension(1));
  double& t = cmn.t;
  auto& flstat = cmn.flstat;
  auto& lstat = cmn.lstat;
  double& f = static_cast<common_com45&>(cmn).f;
  int& nph = cmn.nph;
  int& nph2 = cmn.nph2;
  int& n22 = cmn.n22;
  const auto& vim = cmn.vim;
  //
  double epspv2 = fem::double0;
  int n3 = fem::int0;
  int ir = fem::int0;
  int n4 = fem::int0;
  int j = fem::int0;
  int i = fem::int0;
  int n1 = fem::int0;
  int im = fem::int0;
  int n2 = fem::int0;
  int irow = fem::int0;
  int icol = fem::int0;
  arr_1d<50, int> ij(fem::fill0);
  int L = fem::int0;
  double u = fem::double0;
  int k = fem::int0;
  double v = fem::double0;
  double d9 = fem::double0;
  //C)  THIS SUBROUTINE PERFORMS SOME OF THE MATRIX MANIPULATION PROCEDURES M16.5585
  //C)  USED BY OVER45 ON LINEARIZED COMPLEX MATRICES STORED IN COLUMN      M16.5586
  //C)  ORDER.  THESE PROCESSES INCLUDE MULTIPLICATION BY COMPLEX MTX, BY   M16.5587
  //C)  REAL PART OF COMPLEX MTX, BY TRANSPOSE OF REAL PART OC COMPLEX MTX  M16.5588
  //C)  (IN EITHER ORDER FOR LAST TWO) AND INVERSION OF COMPLEX MTX.        M16.5589
  //C)  THESE OPERATIONS EACH HAVE A SEPARATE ENTRY, WHERE THE ARGUMENTS AREM16.5590
  //C)  FIRST, FOLLOWED BY THE RESULT OF THE PROCEDURE.                     M16.5591
  //C!EQUIVALENCE (VIM(9),EPSPV2)
  epspv2 = vim(9);
  switch (kode) {
    case 1: goto statement_1000;
    case 2: goto statement_2000;
    case 3: goto statement_3000;
    case 4: goto statement_4000;
    case 5: goto statement_5000;
    case 6: goto statement_6000;
    default: break;
  }
  statement_1000:
  n3 = 1;
  ir = 1;
  n4 = 0;
  FEM_DO_SAFE(j, 1, nph) {
    n4 += nph2;
    FEM_DOSTEP(i, 1, nph2, 2) {
      n1 = i;
      im = ir + 1;
      c(ir) = 0.f;
      c(im) = 0.f;
      FEM_DOSTEP(n2, n3, n4, 2) {
        c(ir) += a(n1) * b(n2) - a(n1 + 1) * b(n2 + 1);
        c(im) += a(n1) * b(n2 + 1) + a(n1 + 1) * b(n2);
        n1 += nph2;
      }
      ir += 2;
    }
    n3 += nph2;
  }
  return;
  statement_2000:
  irow = 2;
  icol = nph2;
  statement_40:
  ir = 1;
  n3 = 1;
  FEM_DO_SAFE(j, 1, nph) {
    FEM_DOSTEP(i, 1, nph2, 2) {
      im = ir + 1;
      n2 = n3;
      c(ir) = 0.f;
      c(im) = 0.f;
      FEM_DOSTEP(n1, i, n22, nph2) {
        c(ir) += a(n1) * b(n2);
        c(im) += a(n1 + 1) * b(n2);
        n2 += irow;
      }
      ir += 2;
    }
    n3 += icol;
  }
  return;
  statement_3000:
  irow = nph2;
  icol = 2;
  goto statement_40;
  statement_4000:
  irow = 2;
  icol = nph2;
  statement_75:
  n3 = 1;
  FEM_DOSTEP(j, 1, nph2, 2) {
    ir = j;
    FEM_DOSTEP(i, 1, n22, nph2) {
      n1 = n3;
      n4 = i + nph2 - 2;
      im = ir + 1;
      c(ir) = 0.f;
      c(im) = 0.f;
      FEM_DOSTEP(n2, i, n4, 2) {
        c(ir) += a(n1) * b(n2);
        c(im) += a(n1) * b(n2 + 1);
        n1 += icol;
      }
      ir += nph2;
    }
    n3 += irow;
  }
  return;
  statement_5000:
  irow = nph2;
  icol = 2;
  goto statement_75;
  statement_6000:
  FEM_DO_SAFE(i, 1, nph) {
    ij(i) = 0;
  }
  FEM_DO_SAFE(j, 1, n22) {
    b(j) = a(j);
  }
  L = 0;
  statement_130:
  L++;
  if (L > nph) {
    return;
  }
  t = 0.f;
  n1 = 1;
  FEM_DO_SAFE(j, 1, nph) {
    if (ij(j) > 0) {
      goto statement_140;
    }
    u = b(n1) * b(n1) + b(n1 + 1) * b(n1 + 1);
    if (u <= t) {
      goto statement_140;
    }
    t = u;
    n2 = j;
    k = n1;
    statement_140:
    n1 += cmn.nphpi2;
  }
  ij(n2) = 1;
  if (t > epspv2) {
    goto statement_145;
  }
  cmn.kill = 199;
  flstat(15) = f;
  flstat(13) = t;
  flstat(14) = epspv2;
  lstat(13) = L;
  lstat(14) = nph;
  lstat(19) = 145;
  return;
  statement_145:
  u = b(k) / t;
  t = -b(k + 1) / t;
  b(k) = u;
  b(k + 1) = t;
  n3 = (n2 - 1) * nph2 + 1;
  n2 = 2 * n2 - 1;
  FEM_DOSTEP(i, 1, nph2, 2) {
    if (i == n2) {
      goto statement_160;
    }
    n1 = i + (n2 - 1) * nph;
    v = u * b(n1) - t * b(n1 + 1);
    d9 = u * b(n1 + 1) + t * b(n1);
    FEM_DOSTEP(j, 1, n22, nph2) {
      if (j == n3) {
        goto statement_150;
      }
      k = i + j;
      n4 = j + n2;
      b(k - 1) = b(k - 1) - b(n4 - 1) * v + b(n4) * d9;
      b(k) = b(k) - b(n4 - 1) * d9 - b(n4) * v;
      statement_150:;
    }
    statement_160:;
  }
  k = n2;
  FEM_DOSTEP(i, 1, nph2, 2) {
    if (i == n2) {
      goto statement_170;
    }
    n4 = n3 + i;
    v = b(n4 - 1) * u - b(n4) * t;
    b(n4) = b(n4 - 1) * t + b(n4) * u;
    b(n4 - 1) = v;
    v = b(k + 1) * t - b(k) * u;
    b(k + 1) = -b(k) * t - b(k + 1) * u;
    b(k) = v;
    statement_170:
    k += nph2;
  }
  goto statement_130;

}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
frqdom(
  common& cmn,
  int& ioutp,
  arr_ref<double> pbuf,
  arr_ref<double> z,
  arr_ref<double> y,
  arr_ref<double> zy,
  arr_ref<double> zya,
  arr_ref<double> zyb,
  arr_ref<double> zyc,
  arr_ref<double> zyd,
  arr_ref<double> cq,
  arr_ref<double> cqt,
  arr_cref<double> q,
  arr_cref<double> qi,
  arr_ref<double> g,
  arr_ref<double> g60,
  arr_ref<double> yo,
  arr_ref<double> xr,
  arr_ref<double> xl,
  arr_ref<double> xg,
  arr_ref<double> xc) try
{
  pbuf(dimension(1));
  z(dimension(1));
  y(dimension(1));
  zy(dimension(1));
  zya(dimension(1));
  zyb(dimension(1));
  zyc(dimension(1));
  zyd(dimension(1));
  cq(dimension(1));
  cqt(dimension(1));
  q(dimension(1));
  qi(dimension(1));
  g(dimension(1));
  g60(dimension(1));
  yo(dimension(1));
  xr(dimension(1));
  xl(dimension(1));
  xg(dimension(1));
  xc(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  auto& flstat = cmn.flstat;
  auto& lunit3 = cmn.lunit3;
  const auto& ipntv = cmn.ipntv;
  const auto& indtv = cmn.indtv;
  auto& lstat = cmn.lstat;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  double& f = static_cast<common_com45&>(cmn).f;
  double& w = cmn.w;
  double& cold = cmn.cold;
  double& sll = cmn.sll;
  double& spdlt = cmn.spdlt;
  int& i1 = cmn.i1;
  int& iwork = cmn.iwork;
  int& nph = cmn.nph;
  int& nph2 = cmn.nph2;
  int& nphpi2 = cmn.nphpi2;
  int& n22 = cmn.n22;
  int& ntri = cmn.ntri;
  int& iss = cmn.iss;
  int& kreqab = cmn.kreqab;
  const auto& vim = cmn.vim;
  //
  double epseig = fem::double0;
  int nieig = fem::int0;
  int nss = fem::int0;
  int ll1 = fem::int0;
  int ll2 = fem::int0;
  int ll3 = fem::int0;
  int ll4 = fem::int0;
  int ll5 = fem::int0;
  int ll6 = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int m = fem::int0;
  int kcol = fem::int0;
  int ktri = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  int L = fem::int0;
  double zoff = fem::double0;
  double zoff1 = fem::double0;
  double zdia = fem::double0;
  double zdia1 = fem::double0;
  double yoff = fem::double0;
  double yoff1 = fem::double0;
  double ydia = fem::double0;
  double ydia1 = fem::double0;
  int n = fem::int0;
  int m1 = fem::int0;
  int noff = fem::int0;
  int l1 = fem::int0;
  int k1 = fem::int0;
  int iout1 = fem::int0;
  double dx = fem::double0;
  int iq = fem::int0;
  double diagx = fem::double0;
  double zyr = fem::double0;
  double zyi = fem::double0;
  double diag = fem::double0;
  int n3 = fem::int0;
  int l2 = fem::int0;
  double zr = fem::double0;
  double zi = fem::double0;
  int n4 = fem::int0;
  int n5 = fem::int0;
  double d4 = fem::double0;
  int nphpi = fem::int0;
  int n6 = fem::int0;
  static const char* format_107 = "('0',5x,6(5x,e12.5),/,6x,6(5x,e12.5))";
  static const char* format_109 = "(1x,6(2x,f8.5))";
  static const char* format_110 = "('+',64x,'*',1x,6(2x,f8.5))";
  static const char* format_121 = "(1x)";
  static const char* format_123 = "(1x,12(2x,f8.2))";
  static const char* format_152 = "(/,8(3x,e12.5))";
  static const char* format_153 = "(8(3x,e12.5))";
  //C)  THIS SUBROUTINE IS USED TO PROCESS LINE/CABLE CONSTANTS DATA AT A   M16.5717
  //C)  SPECIFIC FREQUENCY.  THE R, L, C MATRICES (LOW. TRI, COL ORDER) ARE M16.5718
  //C)  READ FROM TAPE3.  EACH MATRIX IS A SEPARATE RECORD.  THE ROUTINE CANM16.5719
  //C)  SELECTIVELY CALCULATE AND/OR OUTPUT THE FOLLOWING QUANTITIES.       M16.5720
  //C)                                                                      M16.5721
  //C)     1.  MODAL TRANSFORMATION MARRICES(EXACT ONLY).                   M16.5722
  //C)     2.  ALPHA, BETA, ATTENUATION % VELOCITY FOR EACH MODE.           M16.5723
  //C)     3.  MODAL DISTRIBUTED IMPEDANCE AND SHUNT ADMITTANCE.            M16.5724
  //C)     4.  MODAL CHARACTERISTIC IMPEDANCE.                              M16.5725
  //C)     5.  MODAL EQUIVALENT PI IMPEDANCE AND ADMITANCE.                 M16.5726
  //C)     6.  PHASE EQUIVALENT PI MATRICES.                                M16.5727
  //C)                                                                      M16.5728
  //C)  THESE VALUES MAY BE CALCULATED ON THE BASIS OF EXACT DIAGONAL-      M16.5729
  //C)  IZATION OF ZY MATRIX OR BY USE OF PRE-CALCULATED TRANSFORMATION     M16.5730
  //C)  MATRICES.                                                           M16.5731
  //C!EQUIVALENCE (VIM(8),EPSEIG),(IPNTV(5),NIEIG),(INDTV(2),NSS)
  epseig = vim(8);
  nieig = ipntv(5);
  nss = indtv(2);
  ll1 = 1;
  ll2 = 2;
  ll3 = 3;
  ll4 = 4;
  ll5 = 5;
  ll6 = 6;
  i = ioutp;
  j = iwork;
  k = 1;
  statement_61:
  n1 = i / 2;
  n2 = j / 2;
  if (i != n1 + n1 && j == n2 + n2) {
    iwork += k;
  }
  k += k;
  i = n1;
  j = n2;
  if (i != 0) {
    goto statement_61;
  }
  //C     READ MATRICES  (G), (B), (R), AND (X)  FROM UNIT 3.               M16.5745
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' AT BEGIN ''FRQDOM'' .',"
      "'   IOUTP   IWORK     NPH    NTRI    NPH2     NSS',11x,'COLD',14x,'F',"
      "14x,'W',/,20x,6i8,3e15.5)"),
      ioutp, iwork, nph, ntri, nph2, nss, cold, f, w;
  }
  if (kreqab == 0) {
    goto statement_3603;
  }
  n1 = 2 * nph * nph;
  {
    read_loop rloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(i, 1, n1) {
      rloop, y(i);
    }
  }
  {
    read_loop rloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(i, 1, n1) {
      rloop, z(i);
    }
  }
  m = 1;
  FEM_DO_SAFE(i, 1, nph) {
    kcol = 2 * nph * (i - 1) + 1;
    ktri = kcol + 2 * (i - 1);
    FEM_DOSTEP(j, kcol, ktri, 2) {
      xg(m) = y(j);
      xr(m) = z(j);
      xc(m) = y(j + 1);
      xl(m) = z(j + 1);
      m++;
    }
  }
  d1 = y(2) / f;
  goto statement_3622;
  statement_3603:
  {
    read_loop rloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(i, 1, ntri) {
      rloop, xg(i);
    }
  }
  {
    read_loop rloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(i, 1, ntri) {
      rloop, xc(i);
    }
  }
  {
    read_loop rloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(i, 1, ntri) {
      rloop, xr(i);
    }
  }
  {
    read_loop rloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(i, 1, ntri) {
      rloop, xl(i);
    }
  }
  if (iprsup >= 4) {
    write(lunit6,
      "(/,' AFTER UNIT 3 READ.',10x,'XG(1)',10x,'XC(1)',10x,'XR(1)',10x,"
      "'XL(1)',/,19x,4e15.5)"),
      xg(1), xc(1), xr(1), xl(1);
  }
  d1 = xc(1) / f;
  statement_3622:
  if (cold == 0.0f) {
    goto statement_1;
  }
  d2 = (d1 - cold) / d1;
  d3 = cmn.epsiln * 100.f;
  if (std::abs(d2) <= d3) {
    goto statement_1;
  }
  write(lunit6, "(/,' AT 3629 ',4e20.10)"), f, cold, d1, d2;
  kill = 188;
  flstat(13) = d1;
  flstat(14) = f;
  flstat(15) = cold;
  flstat(19) = 1;
  return;
  statement_1:
  cold = d1;
  if (ioutp != 0) {
    write(lunit6, "(/,/,/,54x,'FREQUENCY = ',e13.4,/,54x,25('*'),/,1x)"), f;
  }
  if (kreqab > 0) {
    goto statement_3637;
  }
  L = 1;
  FEM_DO_SAFE(i, 1, nph) {
    j = (i - 1) * nph2 + 1;
    k = i + i - 1;
    FEM_DO_SAFE(n1, 1, i) {
      z(j) = xr(L);
      z(k) = xr(L);
      y(j) = xg(L);
      y(k) = xg(L);
      z(j + 1) = xl(L);
      z(k + 1) = xl(L);
      y(j + 1) = xc(L);
      y(k + 1) = xc(L);
      j += 2;
      k += nph2;
      L++;
    }
  }
  if (nss == 0) {
    goto statement_3637;
  }
  if (nph == 1) {
    goto statement_3637;
  }
  zoff = 0.0f;
  zoff1 = 0.0f;
  zdia = 0.0f;
  zdia1 = 0.0f;
  yoff = 0.0f;
  yoff1 = 0.0f;
  ydia = 0.0f;
  ydia1 = 0.0f;
  FEM_DOSTEP(i, 1, nph2, 2) {
    k = (i + 1) / 2;
    L = (k - 1) * nphpi2;
    n = L + 1;
    j = 1;
    if (j == k) {
      goto statement_75;
    }
    FEM_DOSTEP(m, i, L, nph2) {
      m1 = m + 1;
      zoff += z(m);
      yoff += y(m);
      zoff1 += z(m1);
      yoff1 += y(m1);
    }
    goto statement_80;
    statement_75:
    n1 = n + 1;
    zdia += z(n);
    ydia += y(n);
    zdia1 += z(n1);
    ydia1 += y(n1);
    statement_80:
    if (i == 1) {
      goto statement_90;
    }
    j += k - 1;
    if (j <= k) {
      goto statement_75;
    }
    statement_90:;
  }
  noff = nph * (nph - 1) / 2;
  zoff = zoff / noff;
  yoff = yoff / noff;
  zoff1 = zoff1 / noff;
  yoff1 = yoff1 / noff;
  zdia = zdia / nph;
  ydia = ydia / nph;
  zdia1 = zdia1 / nph;
  ydia1 = ydia1 / nph;
  FEM_DO_SAFE(i, 1, nph) {
    j = (i - 1) * nphpi2 + 1;
    L = (i - 1) * nph2 + 1;
    l1 = i * nph2;
    FEM_DOSTEP(k, L, l1, 2) {
      k1 = k + 1;
      if (k == j) {
        goto statement_93;
      }
      z(k) = zoff;
      y(k) = yoff;
      z(k1) = zoff1;
      y(k1) = yoff1;
      goto statement_94;
      statement_93:
      z(k) = zdia;
      y(k) = ydia;
      z(k1) = zdia1;
      y(k1) = ydia1;
      statement_94:;
    }
  }
  statement_3637:
  iwork = -iwork;
  iout1 = ioutp;
  ioutp = ioutp / 2;
  if (ioutp + ioutp == iout1) {
    goto statement_13;
  }
  if (kreqab == 1) {
    goto statement_34;
  }
  write(lunit6,
    "(/,10x,'IMPEDANCE MATRIX',25x,'ADMITTANCE MATRIX',/,13x,'(OHM/MILE)',31x,"
    "'(MHO/MILE)')");
  goto statement_27;
  statement_34:
  write(lunit6,
    "(/,10x,'IMPEDANCE MATRIX',25x,'ADMITTANCE MATRIX',/,14x,'(OHM/M )',33x,"
    "'(MHO/M )')");
  goto statement_27;
  statement_30:
  iwork = iwork / 2;
  n1 = iwork / 64;
  n2 = ioutp / 64;
  if (64 * n1 == iwork || nss == 1) {
    goto statement_35;
  }
  if (64 * n2 != ioutp) {
    write(lunit6,
      "(/,10x,"
      "'THE FOLLOWING VALUES ARE COMPUTED ON THE BASIS OF EXACT DIAGONALIZATIO"
      "N OF ZY MTX.')");
  }
  dx = -fem::pow2((spdlt / w));
  j = 1;
  FEM_DO_SAFE(i, 1, n22) {
    zya(i) = dx * zy(i);
    if (i != j) {
      goto statement_14;
    }
    zya(i) = zya(i) - cmn.unity;
    j += nphpi2;
    statement_14:;
  }
  //C     CALCULATION OF EIGENVALUES AND EIGENVECTORS BY THE POWER METHOD.  M16.5892
  FEM_DO_SAFE(i, 1, n22) {
    zyb(i) = zya(i);
  }
  L = 0;
  statement_42:
  L++;
  iq = 0;
  if (L >= nph) {
    goto statement_414;
  }
  statement_43:
  iq++;
  if (iq <= nieig) {
    goto statement_44;
  }
  lstat(19) = 44;
  kill = 165;
  lstat(19) = 44;
  return;
  statement_44:
  FEM_DO_SAFE(i, 1, n22) {
    zyc(i) = zyb(i);
  }
  cxc(cmn, zyc, zyc, zyb, ll1);
  diagx = 0.f;
  j = 1;
  FEM_DOSTEP(i, 1, nph2, 2) {
    dx = zyb(j) * zyb(j) + zyb(j + 1) * zyb(j + 1);
    if (dx <= diagx) {
      goto statement_46;
    }
    diagx = dx;
    n1 = j;
    n2 = i;
    statement_46:
    j += nphpi2;
  }
  zyr = zyb(n1) / diagx;
  zyi = -zyb(n1 + 1) / diagx;
  FEM_DOSTEP(i, 1, n22, 2) {
    dx = zyr * zyb(i) - zyi * zyb(i + 1);
    zyb(i + 1) = zyr * zyb(i + 1) + zyi * zyb(i);
    zyb(i) = dx;
  }
  diag = 0.f;
  j = (n2 - 1) * nph + 1;
  k = j + nph2 - 2;
  FEM_DOSTEP(i, j, k, 2) {
    if (i == n1) {
      goto statement_48;
    }
    dx = zyb(i) * zyb(i) + zyb(i + 1) * zyb(i + 1);
    if (dx <= diag) {
      goto statement_48;
    }
    diag = dx;
    n3 = i;
    statement_48:;
  }
  if (diag > 0.f) {
    goto statement_410;
  }
  FEM_DOSTEP(i, n2, n22, nph2) {
    if (i == n1) {
      goto statement_49;
    }
    dx = zyb(i) * zyb(i) + zyb(i + 1) * zyb(i + 1);
    if (dx <= diag) {
      goto statement_49;
    }
    diag = dx;
    n3 = i;
    statement_49:;
  }
  statement_410:
  dx = (zyc(n1) * zyc(n1) + zyc(n1 + 1) * zyc(n1 + 1)) / (zyc(n3) *
    zyc(n3) + zyc(n3 + 1) * zyc(n3 + 1));
  if (iprsup > 6) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' IN EIGEN POWER LOOP.  N1, N2, N3,  J, IQ, DX, DIAG, ',"
        "'DIAGX, EPSIEG, (ZYB(I), I=J, K), (ZYB(I), I=N2, N22, NPH2) = ',/,1x,"
        "i9,4i10,4e20.11,/(1x,6e20.11))");
      wloop, n1, n2, n3, j, iq, dx, diag, diagx, epseig;
      FEM_DO_SAFE(i, j, k) {
        wloop, zyb(i);
      }
      FEM_DOSTEP(i, n2, n22, nph2) {
        wloop, zyb(i);
      }
    }
  }
  if (std::abs(sqrtz(dx * diag) - 1.0f) > epseig) {
    goto statement_43;
  }
  l2 = L * nph2 + 1;
  n3 = l2 - nph2;
  k = (n2 - 1) * nph + 1;
  zyr = 0.f;
  zr = 0.f;
  zyi = 0.f;
  zi = 0.f;
  FEM_DOSTEP(i, n2, n22, nph2) {
    zyr += zya(i) * zyb(k) - zya(i + 1) * zyb(k + 1);
    zyi += zya(i) * zyb(k + 1) + zya(i + 1) * zyb(k);
    zr += zyb(i) * zyb(k) - zyb(i + 1) * zyb(k + 1);
    zi += zyb(i) * zyb(k + 1) + zyb(i + 1) * zyb(k);
    cq(n3) = zyb(k);
    cq(n3 + 1) = zyb(k + 1);
    cq(l2) = zyb(i);
    cq(l2 + 1) = zyb(i + 1);
    k += 2;
    n3 += 2;
    l2 += 2;
  }
  l2 = L + L;
  g(l2 - 1) = zyr;
  g(l2) = zyi;
  dx = zr * zr + zi * zi;
  zyr = (zr * g(l2 - 1) + zi * g(l2)) / dx;
  zyi = (zr * g(l2) - zi * g(l2 - 1)) / dx;
  k = 1;
  n2 = L * nph2 + 1;
  n1 = n2 - nph2;
  n3 = n2 - 2;
  n4 = n3 + nph2;
  FEM_DOSTEP(i, n2, n4, 2) {
    zr = cq(i) * zyr - cq(i + 1) * zyi;
    zi = cq(i) * zyi + cq(i + 1) * zyr;
    FEM_DOSTEP(j, n1, n3, 2) {
      zyb(k) = zya(k) - cq(j) * zr + cq(j + 1) * zi;
      zyb(k + 1) = zya(k + 1) - cq(j) * zi - cq(j + 1) * zr;
      zya(k) = zyb(k);
      zya(k + 1) = zyb(k + 1);
      k += 2;
    }
  }
  goto statement_42;
  statement_414:
  diagx = 0.f;
  j = 1;
  FEM_DOSTEP(i, 1, nph2, 2) {
    dx = zya(j) * zya(j) + zya(j + 1) * zya(j + 1);
    if (dx <= diagx) {
      goto statement_415;
    }
    diagx = dx;
    n1 = j;
    n2 = i;
    statement_415:
    j += nphpi2;
  }
  n3 = (L - 1) * nph2 + 1;
  k = (n2 - 1) * nph + 1;
  zyr = 0.f;
  zyi = 0.f;
  zr = zya(n1) / diagx;
  zi = -zya(n1 + 1) / diagx;
  FEM_DOSTEP(i, n2, n22, nph2) {
    zyr += zya(i) * zya(k) - zya(i + 1) * zya(k + 1);
    zyi += zya(i) * zya(k + 1) + zya(i + 1) * zya(k);
    cq(n3) = zr * zya(k) - zya(k + 1) * zi;
    cq(n3 + 1) = zi * zya(k) + zya(k + 1) * zr;
    n3 += 2;
    k += 2;
  }
  l2 = L + L;
  g(l2 - 1) = zr * zyr - zi * zyi;
  g(l2) = zr * zyi + zi * zyr;
  if (iprsup < 5) {
    goto statement_418;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,5x,'RAW EIGENVALUES % VECTOR OUTPUT',/(/,10e12.5))");
    FEM_DO_SAFE(i, 1, nph2) {
      wloop, g(i);
    }
  }
  FEM_DOSTEP(i, 1, n22, nph2) {
    j = i + nph2 - 1;
    {
      write_loop wloop(cmn, lunit6, format_107);
      FEM_DO_SAFE(k, i, j) {
        wloop, cq(k);
      }
    }
  }
  statement_418:
  dx = w / spdlt;
  FEM_DOSTEP(i, 1, nph2, 2) {
    g(i) += 1.0f;
    zyr = sqrtz(g(i) * g(i) + g(i + 1) * g(i + 1));
    if (g(i) < 0.0f) {
      goto statement_200;
    }
    zr = sqrtz((g(i) + zyr) / 2.f);
    zi = g(i + 1) / zr / 2.f;
    goto statement_201;
    statement_200:
    zi = sqrtz((-g(i) + zyr) / 2.f);
    if (g(i + 1) < 0.0f) {
      zi = -zi;
    }
    zr = g(i + 1) / zi / 2.f;
    statement_201:
    g(i) = -dx * zi;
    g(i + 1) = dx * zr;
  }
  //C     CALCULATION OF CURRENT TRANSFORMATION MATRIX                      M16.6027
  cxc(cmn, cq, zyb, zya, ll6);
  if (kill > 0) {
    goto statement_9200;
  }
  n1 = 1;
  FEM_DOSTEP(i, 1, nph2, 2) {
    k = n1;
    FEM_DOSTEP(j, i, n22, nph2) {
      zya(k) = zyb(j);
      zya(k + 1) = zyb(j + 1);
      k += 2;
    }
    n1 += nph2;
  }
  iwork = iwork / 2;
  iout1 = ioutp;
  ioutp = ioutp / 2;
  if (ioutp + ioutp == iout1) {
    goto statement_18;
  }
  //C     OUTPUT THE TRANSFORMATION MATRICES.                               M16.6042
  if (nph <= 6) {
    goto statement_127;
  }
  write(lunit6,
    "(/,/,42x,'MODE TO PHASE VOLTAGE',/,42x,'TRANSFORMATION MATRIX',/,1x)");
  n1 = 5 * nph2;
  FEM_DOSTEP(i, 1, nph2, 2) {
    n2 = i;
    write(lunit6, format_121);
    statement_122:
    n3 = n2 + n1;
    if (n3 > n22) {
      n3 = n22;
    }
    n4 = n2 + 1;
    n5 = n3 + 1;
    write(lunit6, format_121);
    {
      write_loop wloop(cmn, lunit6, format_123);
      FEM_DOSTEP(j, n2, n3, nph2) {
        wloop, cq(j);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_123);
      FEM_DOSTEP(j, n4, n5, nph2) {
        wloop, cq(j);
      }
    }
    n2 = n3 + nph2;
    if (n3 < n22) {
      goto statement_122;
    }
  }
  write(lunit6,
    "(/,/,42x,'MODE TO PHASE CURRENT',/,42x,'TRANSFORMATION MATRIX',/,1x)");
  FEM_DOSTEP(i, 1, nph2, 2) {
    n2 = i;
    write(lunit6, format_121);
    statement_125:
    n3 = n2 + n1;
    if (n3 > n22) {
      n3 = n22;
    }
    n4 = n2 + 1;
    n5 = n3 + 1;
    write(lunit6, format_121);
    {
      write_loop wloop(cmn, lunit6, format_123);
      FEM_DOSTEP(j, n2, n3, nph2) {
        wloop, zya(j);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_123);
      FEM_DOSTEP(j, n4, n5, nph2) {
        wloop, zya(j);
      }
    }
    n2 = n3 + nph2;
    if (n3 < n22) {
      goto statement_125;
    }
  }
  statement_127:
  write(lunit6,
    "(/,22x,'MODE TO PHASE VOLTAGE',44x,'MODE TO PHASE CURRENT',/,22x,"
    "'TRANSFORMATION MATRIX',44x,'TRANSFORMATION MATRIX',/,1x)");
  FEM_DOSTEP(i, 1, nph2, 2) {
    write(lunit6, "(65x,'*')");
    {
      write_loop wloop(cmn, lunit6, format_109);
      FEM_DOSTEP(j, i, n22, nph2) {
        wloop, cq(j);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_110);
      FEM_DOSTEP(j, i, n22, nph2) {
        wloop, zya(j);
      }
    }
    k = i + 1;
    {
      write_loop wloop(cmn, lunit6, format_109);
      FEM_DOSTEP(j, k, n22, nph2) {
        wloop, cq(j);
      }
    }
    {
      write_loop wloop(cmn, lunit6, format_110);
      FEM_DOSTEP(j, k, n22, nph2) {
        wloop, zya(j);
      }
    }
  }
  //C     OUTPUT EIGENVECTORS, ATTENUATION, AND VELOCITY                    M16.6057
  statement_18:
  iout1 = ioutp;
  ioutp = ioutp / 2;
  if (ioutp + ioutp == iout1) {
    goto statement_21;
  }
  if (kreqab == 1) {
    goto statement_39138;
  }
  write(lunit6,
    "(/,20x,'ALPHA',13x,'BETA',9x,'ATTENUATION',8x,'VELOCITY',/,9x,'MODE',5x,"
    "'(NEPER/MI)',6x,'(RADIANS/MI)',7x,'(DB/MI)',9x,'(MILE/SEC)',/,1x)");
  goto statement_39168;
  statement_39138:
  write(lunit6,
    "(/,20x,'ALPHA',13x,'BETA',9x,'ATTENUATION',8x,'VELOCITY',/,9x,'MODE',5x,"
    "'(NEPER/M )',6x,'(RADIANS/M )',7x,'(DB/M )',9x,'  (M/SEC) ',/,1x)");
  statement_39168:
  FEM_DO_SAFE(i, 1, nph) {
    j = i + i;
    zyr = cmn.conv5 * g(j - 1);
    zyi = w / g(j);
    write(lunit6, "(10x,i2,4(5x,e12.5))"), i, g(j - 1), g(j), zyr, zyi;
  }
  statement_21:
  iwork = iwork / 2;
  n2 = ioutp / 16;
  n1 = iwork / 16;
  if (16 * n1 == iwork) {
    goto statement_35;
  }
  n = 1;
  FEM_DOSTEP(j, 1, n22, nph2) {
    k = j + nph2 - 1;
    L = n;
    FEM_DOSTEP(i, j, k, 2) {
      cqt(L) = cq(i);
      cqt(L + 1) = cq(i + 1);
      L += nph2;
    }
    n += 2;
  }
  cxc(cmn, z, zya, zyd, ll1);
  cxc(cmn, y, cq, zyc, ll1);
  cxc(cmn, zyb, zyd, z, ll1);
  cxc(cmn, cqt, zyc, y, ll1);
  j = 1;
  FEM_DO_SAFE(i, 1, nph) {
    y(j) = 0.0f;
    j += nphpi2;
  }
  if (iss == 0) {
    goto statement_23;
  }
  FEM_DO_SAFE(i, 1, nph2) {
    g60(i) = g(i);
  }
  j = 1;
  FEM_DOSTEP(i, 1, n22, nphpi2) {
    pbuf(j) = sll * z(i);
    pbuf(j + 1) = sll * z(i + 1);
    pbuf(j + 2) = sll * y(i);
    pbuf(j + 3) = sll * y(i + 1) / cmn.tenm6;
    j += 14;
  }
  statement_23:
  i = iwork / 2;
  n1 = i - 8 * (i / 8);
  i = i / 2;
  n2 = i - 4 * (i / 4);
  i = 2 * (ioutp / 2);
  n3 = ioutp - i;
  j = 4 * (i / 4);
  n4 = i - j;
  n5 = j - 8 * (j / 8);
  i1 = n3 + n4 + n5;
  if (i1 == 0) {
    goto statement_49500;
  }
  if (kreqab == 1) {
    goto statement_49410;
  }
  write(lunit6,
    "(/,9x,'DISTRIBUTED SERIES',7x,'DISTRIBUTED SHUNT',10x,'CHARACTERISTIC',"
    "8x,'EQUIVALENT PI SERIES',5x,'HALF EQUIV PI SHUNT',/,9x,"
    "'IMPEDANCE(OHM/MILE)',5x,'ADMITTANCE(MHO/MILE)',8x,'IMPEDANCE(OHMS)',9x,"
    "'IMPEDANCE(OHMS)',10x,'ADMITTANCE(MHOS)',/,' MODE',5(5x,'REAL',8x,'IMAG',"
    "4x),/,1x)");
  goto statement_49500;
  statement_49410:
  write(lunit6,
    "(/,9x,'DISTRIBUTED SERIES',7x,'DISTRIBUTED SHUNT',10x,'CHARACTERISTIC',"
    "8x,'EQUIVALENT PI SERIES',5x,'HALF EQUIV PI SHUNT',/,9x,"
    "' IMPEDANCE(OHM/M)  ',5x,' ADMITTANCE(MHO/M)  ',8x,'IMPEDANCE(OHMS)',9x,"
    "'IMPEDANCE(OHMS)',10x,'ADMITTANCE(MHOS)',/,' MODE',5(5x,'REAL',8x,'IMAG',"
    "4x),/,1x)");
  statement_49500:
  j = 1;
  move0(zyb, n22);
  move0(zyc, n22);
  FEM_DO_SAFE(i, 1, nph) {
    if (i1 != 0) {
      write(lunit6, "(3x,i1)"), i;
    }
    if (n3 != 0) {
      write(lunit6, "('+',5x,2e12.5,1x,2e12.5)"), z(j), z(j + 1), y(j),
        y(j + 1);
    }
    if (n1 == 0) {
      goto statement_24;
    }
    L = 2 * i - 1;
    zr = g(L + 1) / y(j + 1);
    zi = -g(L) / y(j + 1);
    k = i + i;
    dx = zr * zr + zi * zi;
    yo(k - 1) = zr / dx;
    yo(k) = -zi / dx;
    if (n4 != 0) {
      write(lunit6, "('+',55x,2e12.5)"), zr, zi;
    }
    if (n2 == 0) {
      goto statement_24;
    }
    d1 = z(j) * y(j) - z(j + 1) * y(j + 1);
    d2 = z(j) * y(j + 1) + z(j + 1) * y(j);
    dx = sqrtz(d1 * d1 + d2 * d2);
    if (d1 < 0.0f) {
      goto statement_202;
    }
    d3 = sqrtz((d1 + dx) / 2.f);
    d4 = d2 / d3 / 2.f;
    goto statement_203;
    statement_202:
    d4 = sqrtz((-d1 + dx) / 2.f);
    if (d2 < 0.0f) {
      d4 = -d4;
    }
    d3 = d2 / d4 / 2.f;
    statement_203:
    d3 = sll * d3;
    d4 = sll * d4;
    dx = expz(d3);
    d3 = dx * cosz(d4);
    d4 = dx * sinz(d4);
    dx = d3 * d3 + d4 * d4;
    d1 = (d3 - d3 / dx) / 2.0f;
    d2 = (d4 + d4 / dx) / 2.0f;
    zyb(j) = d1 * zr - d2 * zi;
    zyb(j + 1) = d1 * zi + zr * d2;
    diag = d3 - 1.0f;
    d1 = diag * diag - d4 * d4;
    d2 = 2.0f * diag * d4;
    dx = 2.0f * dx;
    zyr = (d1 * d3 + d2 * d4) / dx;
    zyi = (d2 * d3 - d1 * d4) / dx;
    dx = zyb(j) * zyb(j) + zyb(j + 1) * zyb(j + 1);
    zyc(j) = (zyr * zyb(j) + zyi * zyb(j + 1)) / dx;
    zyc(j + 1) = (zyi * zyb(j) - zyr * zyb(j + 1)) / dx;
    if (n5 != 0) {
      write(lunit6, "('+',80x,2e12.5,1x,2e12.5)"), zyb(j), zyb(j + 1),
        zyc(j), zyc(j + 1);
    }
    statement_24:
    j += nphpi2;
  }
  iwork = iwork / 8;
  n2 = ioutp / 16;
  n1 = iwork / 2;
  if (n1 + n1 == iwork) {
    goto statement_35;
  }
  cxc(cmn, cq, zyb, y, ll4);
  cxc(cmn, y, cq, z, ll3);
  cxc(cmn, zya, zyc, zyb, ll4);
  cxc(cmn, zyb, zya, y, ll3);
  ioutp = ioutp / 8;
  iout1 = ioutp;
  ioutp = ioutp / 2;
  if (ioutp + ioutp == iout1) {
    goto statement_13;
  }
  write(lunit6,
    "(/,9x,'PI EQUIVALENT SERIES',23x,'HALF PI EQUIV SHUNT',/,8x,"
    "'IMPEDANCE MATRIX(OHMS)',20x,'ADMITTANCE MATRIX(MHOS)')");
  statement_27:
  if (nph <= 6) {
    goto statement_157;
  }
  nphpi = nph + 1;
  n1 = 5 * nph2;
  FEM_DOSTEP(i, 1, nph2, 2) {
    n2 = i;
    n3 = (i - 1) * nphpi + 1;
    write(lunit6, format_121);
    statement_151:
    n4 = n2 + n1;
    if (n4 < n3) {
      n4 = n3;
    }
    {
      write_loop wloop(cmn, lunit6, format_152);
      FEM_DOSTEP(j, n2, n4, nph2) {
        wloop, z(j);
      }
    }
    n5 = n2 + 1;
    n6 = n4 + 1;
    {
      write_loop wloop(cmn, lunit6, format_153);
      FEM_DOSTEP(j, n5, n6, nph2) {
        wloop, z(j);
      }
    }
    n2 = n4 + nph2;
    if (n4 < n3) {
      goto statement_151;
    }
  }
  write(lunit6, format_121);
  FEM_DOSTEP(i, 1, nph2, 2) {
    n2 = i;
    n3 = (i - 1) * nphpi + 1;
    write(lunit6, format_121);
    statement_155:
    n4 = n2 + n1;
    {
      write_loop wloop(cmn, lunit6, format_152);
      FEM_DOSTEP(j, n2, n4, nph2) {
        wloop, y(j);
      }
    }
    n5 = n2 + 1;
    n6 = n4 + 1;
    {
      write_loop wloop(cmn, lunit6, format_153);
      FEM_DOSTEP(j, n5, n4, nph2) {
        wloop, y(j);
      }
    }
    n2 = n4 + nph2;
    if (n4 < n3) {
      goto statement_155;
    }
  }
  goto statement_13;
  statement_157:
  n2 = 1;
  n3 = 1;
  FEM_DO_SAFE(n1, 1, nph) {
    write(lunit6, "(1x)");
    statement_4:
    switch (n1) {
      case 1: goto statement_5;
      case 2: goto statement_6;
      case 3: goto statement_7;
      case 4: goto statement_8;
      case 5: goto statement_9;
      case 6: goto statement_10;
      default: break;
    }
    statement_5:
    {
      write_loop wloop(cmn, lunit6, "(1(3x,e12.5),25x,6(3x,e12.5))");
      FEM_DOSTEP(i, n2, n3, nph2) {
        wloop, z(i);
      }
      FEM_DOSTEP(i, n3, n22, nph2) {
        wloop, y(i);
      }
    }
    goto statement_11;
    statement_6:
    {
      write_loop wloop(cmn, lunit6, "(2(3x,e12.5),25x,5(3x,e12.5))");
      FEM_DOSTEP(i, n2, n3, nph2) {
        wloop, z(i);
      }
      FEM_DOSTEP(i, n3, n22, nph2) {
        wloop, y(i);
      }
    }
    goto statement_11;
    statement_7:
    {
      write_loop wloop(cmn, lunit6, "(3(3x,e12.5),25x,4(3x,e12.5))");
      FEM_DOSTEP(i, n2, n3, nph2) {
        wloop, z(i);
      }
      FEM_DOSTEP(i, n3, n22, nph2) {
        wloop, y(i);
      }
    }
    goto statement_11;
    statement_8:
    {
      write_loop wloop(cmn, lunit6, "(4(3x,e12.5),25x,3(3x,e12.5))");
      FEM_DOSTEP(i, n2, n3, nph2) {
        wloop, z(i);
      }
      FEM_DOSTEP(i, n3, n22, nph2) {
        wloop, y(i);
      }
    }
    goto statement_11;
    statement_9:
    {
      write_loop wloop(cmn, lunit6, "(5(3x,e12.5),25x,2(3x,e12.5))");
      FEM_DOSTEP(i, n2, n3, nph2) {
        wloop, z(i);
      }
      FEM_DOSTEP(i, n3, n22, nph2) {
        wloop, y(i);
      }
    }
    goto statement_11;
    statement_10:
    {
      write_loop wloop(cmn, lunit6, "(6(3x,e12.5),25x,1(3x,e12.5))");
      FEM_DOSTEP(i, n2, n3, nph2) {
        wloop, z(i);
      }
      FEM_DOSTEP(i, n3, n22, nph2) {
        wloop, y(i);
      }
    }
    statement_11:
    n2++;
    n3++;
    if (n2 <= n1 + n1) {
      goto statement_4;
    }
    n3 += nph2;
  }
  statement_13:
  if (iwork == 0) {
    return;
  }
  if (iwork > 0) {
    goto statement_31;
  }
  iwork = -iwork;
  cxc(cmn, z, y, zy, ll1);
  if (iprsup < 5) {
    goto statement_29;
  }
  write(lunit6, "(/,5x,'TRANSPOSE OF ZY MATRIX',/,1x)");
  FEM_DOSTEP(i, 1, n22, nph2) {
    j = i + nph2 - 1;
    {
      write_loop wloop(cmn, lunit6, format_107);
      FEM_DO_SAFE(k, i, j) {
        wloop, zy(k);
      }
    }
  }
  statement_29:
  goto statement_30;
  statement_31:
  move0(cq, n22);
  move0(zya, n22);
  i = 1;
  FEM_DOSTEP(j, 1, n22, 2) {
    cq(j) = q(i);
    zya(j) = qi(i);
    i++;
  }
  cxc(cmn, zya, zy, zyb, ll5);
  cxc(cmn, zyb, cq, zyc, ll2);
  i = 1;
  FEM_DOSTEP(j, 1, nph2, 2) {
    dx = sqrtz(zyc(i) * zyc(i) + zyc(i + 1) * zyc(i + 1));
    if (zyc(i) < 0.0f) {
      goto statement_206;
    }
    g(j) = sqrtz((zyc(i) + dx) / 2.f);
    g(j + 1) = zyc(i + 1) / g(j) / 2.f;
    goto statement_33;
    statement_206:
    g(j + 1) = sqrtz((-zyc(i) + dx) / 2.f);
    if (zyc(i + 1) < 0.f) {
      g(j + 1) = -g(j + 1);
    }
    g(j) = zyc(i + 1) / g(j + 1) / 2.f;
    statement_33:
    i += nphpi2;
  }
  if (ioutp != 0) {
    write(lunit6,
      "(/,10x,"
      "'THE FOLLOWING VALUES ARE COMPUTED BY USE OF CONSTANT TRANSFORMATION MA"
      "TRICES.')");
  }
  cxc(cmn, cq, zyb, zya, ll6);
  if (nss == 1) {
    goto statement_19763;
  }
  L = 1;
  FEM_DO_SAFE(i, 1, nph) {
    j = (i - 1) * nph2 + 1;
    k = 2 * i - 1;
    FEM_DO_SAFE(n1, 1, i) {
      z(j) = xr(L);
      z(k) = xr(L);
      y(j) = xg(L);
      y(k) = xg(L);
      z(j + 1) = xl(L);
      z(k + 1) = z(j + 1);
      y(j + 1) = xc(L);
      y(k + 1) = y(j + 1);
      j += 2;
      k += nph2;
      L++;
    }
  }
  statement_19763:
  if (iss == 0) {
    goto statement_18;
  }
  FEM_DO_SAFE(i, 1, nph2) {
    g60(i) = g(i);
  }
  goto statement_18;
  statement_35:
  iwork = n1;
  ioutp = n2;
  goto statement_13;
  statement_9200:;

}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct xift_save
{
  int n1;

  xift_save() :
    n1(fem::int0)
  {}
};

double
xift(
  common& cmn,
  double const& tsp,
  arr_cref<double> omegas,
  arr_cref<double> funw,
  arr_cref<double> cosi) try
{
  double return_value = fem::double0;
  FEM_CMN_SVE(xift);
  omegas(dimension(1));
  funw(dimension(1));
  cosi(dimension(1));
  common_write write(cmn);
  double& w = cmn.w;
  double& xpan = cmn.xpan;
  double& ratio = cmn.ratio;
  double& pi2 = cmn.pi2;
  double& dmin = cmn.dmin;
  int& nfr = cmn.nfr;
  double& twopi = cmn.twopi;
  double& onehaf = cmn.onehaf;
  const auto& indtv = cmn.indtv;
  //
  int& n1 = sve.n1;
  if (is_called_first_time) {
    n1 = 3;
  }
  int npan = fem::int0;
  double fem_time = fem::double0;
  double ttft = fem::double0;
  int j = fem::int0;
  double xtmp = fem::double0;
  int nw = fem::int0;
  double dtemp = fem::double0;
  double d4 = fem::double0;
  double d3 = fem::double0;
  double d2 = fem::double0;
  double d1 = fem::double0;
  double d7 = fem::double0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  double deltaw = fem::double0;
  int i = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int k = fem::int0;
  static const char* format_200 =
    "(/,' INSIDE IFT LOOP.  I, W, DELTAW, OMEGAS(I), FUNW(I),',"
    "'XIFT, D1, D2, D3, D4, D5, D6, D7 =  ',/,i10,6(1x,e20.10),/(6(1x,"
    "e20.10)))";
  //C  THIS ROUTINE CALCULATES THE INVERSE FOURIER TRANSFORM OF A GEOMETRIC M20.5625
  //C     SERIES OF FREQUENCIES IN OMEGAS  WITH THE POINTS IN THE FREQUENCY M20.5626
  //C     DOMAIN IN FUNW(NFR1).  LINEAR INTERPOLATION BETWEEN THE FREQUENCY M20.5627
  //C     SEQUENCE IS USED IN ORDER TO PERFORM THE NUMERICAL INTEGRATION.   M20.5628
  //C     NOTE.  THE FIRST POINT IN 'FUNW' CORRESPONDS TO ZERO PREQUENCY.   M20.5629
  //C     THIS VALUE, OF COURSE, IS NOT MULTIPLIED BY (1/(J*W)) TO CONVERT  M20.5630
  //C     FROM IMPULSE TO STEP RESPONSE.  THE LIMIT OF SIN(W*T)/W FOR W = 0.M20.5631
  //C     BEING EQUAL TO T IS USED.                                         M20.5632
  //C!EQUIVALENCE (INDTV(10), NPAN)
  npan = indtv(10);
  fem_time = tsp;
  if (npan > 0) {
    goto statement_40004;
  }
  ttft = fem_time * fem_time;
  FEM_DO_SAFE(j, 1, nfr) {
    xtmp = fem_time * omegas(j + 1);
    nw = xtmp / twopi;
    xtmp = xtmp - nw * twopi;
    dsinz(xtmp, cosi(j));
  }
  xtmp = omegas(2) * fem_time;
  dcosz(xtmp, dtemp);
  xtmp = xtmp * onehaf * (funw(1) * ttft + funw(2) * fem_time * (
    2.f * dtemp / xtmp + cosi(1))) - ratio / dmin * funw(2) * (cosi(
    2) - cosi(1)) / omegas(3);
  FEM_DO_SAFE(j, 3, nfr) {
    xtmp += funw(j) * (cmn.dplu * cosi(j - 1) - ratio * cosi(j - 2) -
      cosi(j)) / (dmin * omegas(j));
  }
  return_value = pi2 * xtmp / ttft;
  return return_value;
  statement_40004:
  if (cmn.iprsup == 0) {
    n1 = 0;
  }
  return_value = 0.0f;
  w = 0.0f;
  d4 = funw(1);
  d3 = omegas(1);
  d2 = funw(2);
  d1 = omegas(2);
  d7 = d2 * d1;
  d5 = (d7 - d4) / (d1 - d3);
  d6 = d4 - d5 * d3;
  d7 = onehaf * fem_time * d4;
  deltaw = (omegas(2) - omegas(1)) / npan;
  FEM_DO_SAFE(i, 1, npan) {
    return_value += d7;
    w += deltaw;
    xtmp = w * fem_time;
    nw = xtmp / twopi;
    d7 = xtmp - nw * twopi;
    d7 = (d5 * w + d6) * sinz(d7) / w;
  }
  d7 = onehaf * d7;
  return_value = deltaw * (return_value + d7);
  d4 = (omegas(3) - omegas(2)) / npan;
  deltaw = xpan / std::abs(tsp);
  i = 1;
  if (n1 > 0) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' BEFORE INTEGRATION LOOP.  NPAN, XPAN, PI2, DELTAW,',"
        "'TIME, XIFT, D1, D2, D3, D4, D5, D6, D7, (OMEGAS(I), FUNW(I),',"
        "' I=1, 5) = ',/,i10,6(1x,e20.10),/(6(1x,e20.10)))");
      wloop, npan, xpan, pi2, deltaw, fem::time, return_value, d1,
        d2, d3, d4, d5, d6, d7;
      FEM_DO_SAFE(i, 1, 5) {
        wloop, omegas(i), funw(i);
      }
    }
  }
  if (deltaw <= d4) {
    goto statement_40;
  }
  FEM_DO_SAFE(i, 2, nfr) {
    d3 = 0.f;
    d5 = (funw(i + 1) - d2) / (omegas(i + 1) - d1);
    d6 = d2 - d5 * d1;
    d1 = omegas(i + 1);
    d2 = funw(i + 1);
    FEM_DO_SAFE(k, 1, npan) {
      d3 += d7;
      w += d4;
      xtmp = w * fem_time;
      nw = xtmp / twopi;
      d7 = xtmp - nw * twopi;
      d7 = (d5 * w + d6) * sinz(d7);
    }
    d7 = onehaf * d7;
    return_value += d4 * (d3 + d7);
    if (n1 > 0) {
      write(lunit6, format_200), i, w, deltaw, omegas(i), funw(i),
        return_value, d1, d2, d3, d4, d5, d6, d7;
    }
    d4 = (omegas(i + 2) - d1) / npan;
    if (d4 > deltaw) {
      goto statement_40;
    }
  }
  goto statement_70;
  statement_40:
  i++;
  d3 = d7;
  FEM_DO_SAFE(j, i, nfr) {
    d5 = (funw(j + 1) - d2) / (omegas(j + 1) - d1);
    d6 = d2 - d5 * d1;
    d1 = omegas(j + 1);
    d2 = funw(j + 1);
    if (n1 > 0) {
      write(lunit6, format_200), i, w, deltaw, omegas(i), funw(i),
        return_value, d1, d2, d3, d4, d5, d6, d7;
    }
    statement_50:
    if (w > d1) {
      goto statement_60;
    }
    d3 += d7;
    w += deltaw;
    xtmp = w * fem_time;
    nw = xtmp / twopi;
    d7 = xtmp - nw * twopi;
    d7 = (d5 * w + d6) * sinz(d7);
    goto statement_50;
    statement_60:;
  }
  return_value += deltaw * (d3 - onehaf * d7);
  statement_70:
  return_value = pi2 * return_value;
  if (n1 > 0) {
    write(lunit6,
      "(/,'  IFT OF FUNW(W) AT T = ',e20.10,' IS ',e20.10)"),
      fem::time, return_value;
  }
  if (n1 > 0) {
    n1 = n1 - 1;
  }
  return return_value;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
rise(
  common& cmn,
  double& time,
  double& thr,
  double& t2,
  arr_cref<double> vresp,
  arr_cref<double> si,
  arr_cref<double> cosi) try
{
  vresp(dimension(1));
  si(dimension(1));
  cosi(dimension(1));
  common_write write(cmn);
  const auto& ipntv = cmn.ipntv;
  auto& lstat = cmn.lstat;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  double& ffin = cmn.ffin;
  const auto& vim = cmn.vim;
  //
  int nfit = fem::int0;
  double epsrse = fem::double0;
  int n1 = fem::int0;
  double temp = fem::double0;
  int mitt = fem::int0;
  double x1 = fem::double0;
  double target = fem::double0;
  double close = fem::double0;
  double t1 = fem::double0;
  double x2 = fem::double0;
  auto& lunit6 = cmn.lunit6;
  double x3 = fem::double0;
  static const char* format_10 =
    "(/,' IN RISE.  N1, X1, X2, X3, TIME, T1, T2 =',/,i10,6e20.5)";
  //C     THIS ROUTINE IS USED TO ESTIMATE THE TIME AT WHICH THE STEP       M20.5721
  //C     RESPONSE IN THE TIME DOMAIN IS AT VALUE 'THR'(0.0 TO 1.0).        M20.5722
  //C     THE INITIAL GUESS IS IN 'TIME' WHEN THE  'RISE' FUNCTION IS CALLEDM20.5723
  //C     AND THE FINAL APPROXIMATION IS RETURNED THRU THE SAME ARGUMENT.   M20.5724
  //C     THE PRINCIPLE OF OPERATION IS LINEAR INTERPOLATION/EXTRAPOLATION  M20.5725
  //C     TO FIND A NEW TIME CLOSER TO 'THR'.                               M20.5726
  //C                                                                       M20.5727
  //C!EQUIVALENCE (IPNTV(1), NFIT),  (VIM(5), EPSRSE)
  nfit = ipntv(1);
  epsrse = vim(5);
  n1 = nfit;
  temp = time;
  mitt = 0;
  statement_7403:
  x1 = xift(cmn, time, si, vresp, cosi);
  target = ffin * std::abs(thr);
  close = ffin * epsrse;
  statement_15:
  t1 = time + t2;
  if (x1 > target) {
    t1 = time - t2;
  }
  if (t1 <= 0.f) {
    t1 = time / 10.f;
  }
  x2 = xift(cmn, t1, si, vresp, cosi);
  if (iprsup >= 4) {
    write(lunit6, "(/,10x,'X2',13x,'T1',13x,'X1',12x,'TIME')");
  }
  if (iprsup >= 4) {
    write(lunit6, "(4e15.5)"), x2, t1, x1, fem::time;
  }
  if ((x2 - x1) / (t1 - time) < 0.f) {
    goto statement_30;
  }
  if (x1 >= target && x2 <= target) {
    goto statement_5;
  }
  if (x1 <= target && x2 >= target) {
    goto statement_5;
  }
  statement_30:
  time = t1;
  x1 = x2;
  if (time < 0.f || time > 2.f * cmn.tt) {
    goto statement_25;
  }
  goto statement_15;
  statement_25:
  if (mitt > 3 || cmn.ictrl >= 0) {
    goto statement_26;
  }
  thr = thr * cmn.onehaf;
  time = temp;
  mitt++;
  goto statement_7403;
  statement_26:
  kill = 156;
  lstat(11) = nfit;
  lstat(12) = 1;
  return;
  statement_5:
  t2 = (time + t1) / 2.f;
  x3 = xift(cmn, t2, si, vresp, cosi);
  if (iprsup > 3) {
    write(lunit6, format_10), n1, x1, x2, x3, fem::time, t1, t2;
  }
  if (std::abs(x3 - target) > close) {
    goto statement_40;
  }
  time = t2;
  return;
  statement_40:
  if (x2 > target && x3 < target) {
    goto statement_41;
  }
  if (x2 < target && x3 > target) {
    goto statement_41;
  }
  t1 = t2;
  x2 = x3;
  n1 = n1 - 1;
  goto statement_42;
  statement_41:
  time = t2;
  x1 = x3;
  n1 = n1 - 1;
  statement_42:
  if (n1 >= nfit / 2) {
    goto statement_5;
  }
  statement_43:
  t2 = time + (t1 - time) * (target - x1) / (x2 - x1);
  x3 = xift(cmn, t2, si, vresp, cosi);
  if (iprsup > 3) {
    write(lunit6, format_10), n1, x1, x2, x3, time, t1, t2;
  }
  if (x2 > target && x3 < target) {
    goto statement_20;
  }
  if (x2 < target && x3 > target) {
    goto statement_20;
  }
  t1 = time;
  x2 = x1;
  statement_20:
  time = t2;
  x1 = x3;
  n1 = n1 - 1;
  if (std::abs(x1 - target) < close) {
    return;
  }
  if (n1 > 0) {
    goto statement_43;
  }
  kill = 156;
  lstat(11) = nfit;
  lstat(12) = nfit - n1 + 1;

}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct tdfit_save
{
  fem::str<8> text7;
  fem::str<8> text8;
  fem::str<8> text9;

  tdfit_save() :
    text7(fem::char0),
    text8(fem::char0),
    text9(fem::char0)
  {}
};

void
tdfit(
  common& cmn,
  arr_cref<double> vresp,
  arr_cref<double> si,
  arr_ref<double> fv,
  arr_ref<double> hhm,
  arr_ref<double> hhn,
  arr_cref<double> cosi) try
{
  FEM_CMN_SVE(tdfit);
  vresp(dimension(1));
  si(dimension(1));
  fv(dimension(1));
  hhm(dimension(1));
  hhn(dimension(1));
  cosi(dimension(1));
  common_write write(cmn);
  fem::str<8>& blank = cmn.blank;
  double& t = cmn.t;
  double& onehaf = cmn.onehaf;
  double& fltinf = cmn.fltinf;
  auto& flstat = cmn.flstat;
  const auto& ipntv = cmn.ipntv;
  const auto& indtv = cmn.indtv;
  auto& lstat = cmn.lstat;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  auto& pl = cmn.pl;
  double& w = cmn.w;
  double& tt = cmn.tt;
  double& tstrt = cmn.tstrt;
  double& tstep = static_cast<common_com45&>(cmn).tstep;
  double& ffin = cmn.ffin;
  double& shiftr = cmn.shiftr;
  double& shifti = cmn.shifti;
  double& d = cmn.d;
  auto& x = static_cast<common_com45&>(cmn).x;
  int& ictrl = cmn.ictrl;
  int& i1 = cmn.i1;
  const auto& vim = cmn.vim;
  //
  fem::str<8>& text7 = sve.text7;
  fem::str<8>& text8 = sve.text8;
  fem::str<8>& text9 = sve.text9;
  if (is_called_first_time) {
    text7 = ".     ";
    text8 = "0     ";
    text9 = "*     ";
  }
  double eps = fem::double0;
  double eps1 = fem::double0;
  double fit2z = fem::double0;
  double pivthr = fem::double0;
  double ft2emx = fem::double0;
  double epspv2 = fem::double0;
  int niter1 = fem::int0;
  int niter = fem::int0;
  int npoint = fem::int0;
  int ktdiv = fem::int0;
  int ktzer = fem::int0;
  int kcrit = fem::int0;
  int no = fem::int0;
  int kmax = fem::int0;
  int kzero = fem::int0;
  auto& lunit6 = cmn.lunit6;
  double fvmx = fem::double0;
  double fvmin = fem::double0;
  int kmp = fem::int0;
  int k = fem::int0;
  int km = fem::int0;
  int kp = fem::int0;
  int jgrad = fem::int0;
  int iter = fem::int0;
  int nvar = fem::int0;
  double error = fem::double0;
  arr_2d<3, 3, double> db(fem::fill0);
  double temp = fem::double0;
  int i = fem::int0;
  double d1 = fem::double0;
  double y1 = fem::double0;
  double y2 = fem::double0;
  int ncount = fem::int0;
  int ntrd = fem::int0;
  double dy = fem::double0;
  double x1 = fem::double0;
  int iter2 = fem::int0;
  double cnt = fem::double0;
  double error1 = fem::double0;
  double x11 = fem::double0;
  double dd = fem::double0;
  int j = fem::int0;
  arr_1d<4, double> e(fem::fill0);
  arr_2d<3, 3, double> hac(fem::fill0);
  int nn2 = fem::int0;
  double ppi = fem::double0;
  double pno = fem::double0;
  double t2 = fem::double0;
  double ddt = fem::double0;
  double zp = fem::double0;
  double a = fem::double0;
  arr_1d<4, double> b(fem::fill0);
  int ipi = fem::int0;
  arr_1d<3, double> xold(fem::fill0);
  arr_1d<3, double> eold(fem::fill0);
  double d2 = fem::double0;
  double d3 = fem::double0;
  int iiter = fem::int0;
  double zr = fem::double0;
  double zi = fem::double0;
  double d4 = fem::double0;
  double x3 = fem::double0;
  int L = fem::int0;
  static const char* format_60300 = "(4x,i2,4x,5(5x,e12.5))";
  //C     THIS ROUTINE CALCULATES THE TIME DOMAIN SEQUENCE OF POINTS        M20.5761
  //C     REPRESENTING THE STEP RESPONSE IN 'FV' BY INVERSE FOURIER TRANS-  M20.5762
  //C     FORMATION OF 'VRESP'.  THIS SEQUENCE IS THEN FITTED BY A LEAST-   M20.5763
  //C     SQUARES NEWTON-RAPHSON ALGORITHM TO THE FUNCTION                  M20.5764
  //C                                                                       M20.5765
  //C     Z(T) = D*(1.0 - EXP(-(T - X(3))/X(1))) + (FFIN - D) *             M20.5766
  //C                          (1.0 -EXP(-(T-X(3))/X(2)))                   M21. 487
  //C                                                                       M20.5768
  //C!EQUIVALENCE (VIM(1),EPS),(VIM(2),EPS1),(VIM(3),FIT2Z)
  //C!EQUIVALENCE (VIM(4),PIVTHR),(VIM(7),FT2EMX),(VIM(9),EPSPV2)
  //C!EQUIVALENCE (IPNTV(2),NITER1),(IPNTV(3),NITER),(INDTV(1),NPOINT)
  eps = vim(1);
  eps1 = vim(2);
  fit2z = vim(3);
  pivthr = vim(4);
  ft2emx = vim(7);
  epspv2 = vim(9);
  niter1 = ipntv(2);
  niter = ipntv(3);
  npoint = indtv(1);
  //C
  ktdiv = 0;
  ktzer = 0;
  kcrit = npoint * 0.8f;
  statement_40066:
  no = tt / tstep + onehaf;
  kmax = 0;
  tstep = tt / no;
  kzero = 0;
  //C     CALCULATE (BY IFT) STEP RESPONSE IN TIME DOMAIN                   M20.5781
  if (iprsup > 3) {
    write(lunit6, "(/,5x,'OUTPUT OF IFT',/,9x,'T',11x,'FV(K)',/,1x)");
  }
  t = tstep;
  if (ictrl < 0) {
    t = 5.f * tstep;
  }
  fvmx = -fltinf;
  fvmin = ffin / 1000.f;
  kmp = 1;
  statement_40063:
  FEM_DO_SAFE(k, kmp, npoint) {
    fv(k) = xift(cmn, t, si, vresp, cosi);
    if (fv(k) <= fvmx) {
      goto statement_40065;
    }
    fvmx = fv(k);
    kmax = k;
    statement_40065:
    if (fv(k) >= fvmin) {
      goto statement_40064;
    }
    kzero = k;
    fvmx = -fltinf;
    statement_40064:
    if (iprsup > 3) {
      write(lunit6, "(8(2x,e12.5))"), t, fv(k);
    }
    t += tstep;
  }
  if (ictrl < 0) {
    goto statement_40061;
  }
  if (kzero <= 0) {
    goto statement_40061;
  }
  ktzer++;
  if (ktzer <= 5) {
    goto statement_40069;
  }
  write(lunit6,
    "(' TROUBLE IN TDFIT - - PORTIONS OF IFT RESULTS HAVE BEEN DISCARDED MORE "
    "THAN FIVE TIMES',/,' IN SEARCH FOR POSITIVE DATA.',"
    "'   TEMPORARY ERROR STOP IN \"TDFIT\".')");
  stoptp(cmn);
  statement_40069:
  km = npoint - kzero;
  kmax = kmax - kzero;
  FEM_DO_SAFE(k, 1, km) {
    kp = k + kzero;
    fv(k) = fv(kp);
  }
  kmp = km + 1;
  tstrt += kzero * tstep;
  kzero = 0;
  goto statement_40063;
  statement_40061:
  if (ictrl >= 0 || kmax >= kcrit) {
    goto statement_40067;
  }
  tt = kmax * tstep / 2.f;
  tstep = tt / no;
  ktdiv++;
  if (ktdiv <= 5) {
    goto statement_40066;
  }
  write(lunit6,
    "(' TROUBLE IN TDFIT - - TIME SPAN HAS BEEN REDUCED MORE THAN FIVE TIMES',"
    "/,' IN SEARCH OF LEGITIMATE IFT RESULTS.',/,"
    "'   TEMPORARY ERROR STOP IN \"TDFIT\".')");
  stoptp(cmn);
  statement_40067:
  if (ictrl ==  - 10) {
    goto statement_40500;
  }
  //C     THIS ROUTINE FITS TWO EXPONENTIALS WITH AN ARTIFICIAL TIME DELAY  M20.5794
  //C     TO THE LINE PROP OR ADM STEP RESPONSE USING A LEAST SQUARE ERROR  M35.9229
  //C     MINIMIZING TECHNIQUE SOLVED BY A NEWTON-RAPHSON ALGORITHM.        M20.5796
  //C     LIST OF VARIABLES.                                                M20.5797
  //C        FV -    VECTOR CONTAINING NUMERICAL VALUES OF THE CURVE        M20.5798
  //C               TO BE FITTED                                            M20.5799
  //C        NVAR - NUMBER OF VARIABLES TO BE DETERMINED BY NEWTON-RAPHSON  M20.5800
  //C               ALGORITHM. THE SUBROUTINE FIXES BY ITSELF THE VALUE     M20.5801
  //C               OF "NVAR" TO 3 FOR PROPAGATION AND 2 FOR ADMITTANCE.    M35.9230
  //C        X - VECTOR CONTAINING PARAMETERS OF THE EXPONENTIAL FITTING 'Z'M20.5803
  //C            IN THE FORM'                                               M20.5804
  //C                                                                       M20.5805
  //C     Z(T) = D * (1.0 - EXP(-(T - X(3)) / X(1))) + (FFIN - D) *         M20.5806
  //C           (1.0-EXP(-(T-X(3))/X(2)))                                   M21. 489
  //C                                                                       M20.5808
  //C             WHERE'                                                    M20.5809
  //C        FFIN - FINAL VALUE FOR THE CURVE 'Y'                           M20.5810
  //C        X(3) - ARTIFICAL TIME DELAY  (EQUAL TO ZERO FOR ADMITTANCE)    M35.9231
  //C        E - RIGHT HAND SIDE OF SYSTEM OF EQUATIONS TO BE SOLVED        M20.5812
  //C            FOR INCREMENT 'DX' BY A NEWTON RAPHSON ALGORITHM.          M20.5813
  //C            AFTER SOLVING THE SOLUTION 'DX' WILL BE STORED IN E.       M20.5814
  //C        JAC - JACOBIAN MATRIX.                                         M20.5815
  //C        B,DB - AUXILIARY MATRICES FOR CALCULATING JACOBIAN 'JAC'.      M20.5816
  //C        EPS - THE LEAST SQUARE ERROR DESIRED TO BE ATTAINED            M20.5817
  //C              IN THE FITTING ROCESS.                                   M20.5818
  //C        EPS1 - THE FITTING IS STOPPED IF THE RELATIVE INCREMENT 'DX/X' M20.5819
  //C               IS LESS THAN EPS1                                       M20.5820
  //C        NPOINT - NUMBER OF KNOWN POINTS FOR THE STEP RESPONSE          M20.5821
  //C                 TO BE USED FOR FITTING.                               M20.5822
  //C        NITER - MAXIMUM NUMBER OF ITERATIONS ALLOWED.                  M20.5823
  jgrad = 0;
  iter = 0;
  nvar = 3;
  error = 100.f;
  db(1, 2) = 0.f;
  //C     CALCULATE INITIAL GUESS FOR 'X'.                                  M20.5829
  temp = ffin * fit2z;
  if (ictrl < 0) {
    temp = temp * 0.1f;
  }
  FEM_DO_SAFE(i, 1, npoint) {
    if (fv(i) < temp) {
      goto statement_60050;
    }
    d1 = i - 1;
    x(3) = d1 / no;
    goto statement_60051;
    statement_60050:;
  }
  kill = 157;
  lstat(14) = i1;
  lstat(15) = npoint;
  flstat(14) = fv(npoint);
  flstat(15) = temp;
  lstat(19) = 4521;
  goto statement_9200;
  statement_60051:
  FEM_DO_SAFE(k, i, npoint) {
    if (k == 1) {
      goto statement_60053;
    }
    y1 = fv(k + 1) - fv(k);
    y2 = fv(k) - fv(k - 1);
    if (y1 > y2) {
      goto statement_60052;
    }
    ncount = k;
    goto statement_60054;
    statement_60053:
    if (fv(k + 1) - fv(k) > fv(k)) {
      goto statement_60052;
    }
    ncount = k;
    goto statement_60054;
    statement_60052:;
  }
  kill = 157;
  lstat(14) = 0;
  lstat(15) = npoint;
  lstat(16) = i;
  lstat(17) = k;
  flstat(14) = fv(k - 1);
  flstat(15) = fv(k);
  flstat(16) = fv(k + 1);
  lstat(19) = 4533;
  goto statement_9200;
  statement_60054:
  ntrd = npoint / 3;
  dy = (fv(npoint) - fv(npoint - ntrd)) * no / ntrd;
  if (dy <= 0.f) {
    dy = pivthr;
  }
  x(2) = dy / (ffin - fv(npoint));
  x(2) = std::abs(x(2));
  if (ncount == 1) {
    ncount = 2;
  }
  if (ncount == 1) {
    ncount = 2;
  }
  dy = (fv(ncount) - fv(ncount - 1)) * no;
  x(1) = dy / fv(ncount) / 2.f;
  d1 = ncount - onehaf;
  x(3) = d1 / no - onehaf * (fv(ncount) + fv(ncount - 1)) / dy;
  x1 = x(1);
  if (ictrl < 0) {
    goto statement_60055;
  }
  write(lunit6,
    "(/,2x,'NO.ITER.',8x,'AMPL.',13x,'X(1)',13x,'X(2)',13x,'X(3)',13x,'ERROR',"
    "/,1x)");
  goto statement_60012;
  statement_60055:
  x(1) = no * fv(2) * onehaf / fvmx;
  nvar = 2;
  x1 = x(2) / 1.2f;
  x(3) = 0.f;
  write(lunit6,
    "(/,2x,'NO.ITER.',8x,'AMPL.',13x,'X(1)',13x,'X(2)',13x,'ERROR',/,1x)");
  //C     NEWTON-RAPHSON ITERATIVE SOLUTION PROCESS BEGINS HERE.            M20.5888
  statement_60012:
  iter++;
  iter2 = 0;
  cnt = 1.0f;
  error1 = error;
  statement_60014:
  jgrad++;
  if (jgrad > 20) {
    goto statement_62500;
  }
  if (ictrl >= 0) {
    x(1) = x1 * (1.f + fit2z * (jgrad - 1));
  }
  if (ictrl < 0) {
    x(2) = x1 * (1.f + fit2z * (jgrad - 1));
  }
  statement_62500:
  error = 0.f;
  if (jgrad != 21) {
    goto statement_62501;
  }
  if (ictrl >= 0) {
    x(1) = x11;
  }
  if (ictrl < 0) {
    x(2) = x11;
  }
  statement_62501:
  if (x(3) < 0.f) {
    x(3) = 0.f;
  }
  if (x(2) < 0.f) {
    goto statement_60019;
  }
  if (x(1) < 0.f) {
    goto statement_60019;
  }
  dd = 0.f;
  if (iprsup >= 4) {
    write(lunit6, "('  CALC D',5x,i5,3(5x,e20.10))"), iter, x(1), x(2), x(3);
  }
  d = 0.f;
  FEM_DO_SAFE(j, 1, nvar) {
    e(j) = 0.f;
    FEM_DO_SAFE(k, 1, nvar) {
      hac(j, k) = 0.f;
    }
  }
  //C     CALCULATION OF THE FIRST EXPONENTIAL AMPLITUDE 'D'.               M20.5909
  nn2 = x(3) * no + 1;
  FEM_DO_SAFE(i, nn2, npoint) {
    ppi = i;
    pno = no;
    t2 = ppi / pno;
    ddt = t2 - x(3);
    hhm(i) = x(1) * ddt;
    if (hhm(i) > 80.f) {
      hhm(i) = 80.f;
    }
    hhm(i) = expz(-hhm(i));
    hhn(i) = x(2) * ddt;
    if (hhn(i) > 80.f) {
      hhn(i) = 80.f;
    }
    hhn(i) = expz(-hhn(i));
    d += (hhm(i) - hhn(i)) * (ffin * (1.f - hhn(i)) - fv(i));
    dd += fem::pow2((hhm(i) - hhn(i)));
  }
  d = d / dd;
  //C     CALCULATION OF THE FITTED CURVE 'Z' AND SQUARE ERROR 'ERROR'.     M20.5925
  dd = ffin - d;
  FEM_DO_SAFE(i, nn2, npoint) {
    zp = ffin - d * hhm(i) - dd * hhn(i);
    a = zp - fv(i);
    error += a * a;
    if (jgrad <= 20) {
      goto statement_60016;
    }
    d1 = i;
    t2 = d1 / no;
    ddt = t2 - x(3);
    b(1) = ddt * hhm(i) * d;
    b(2) = ddt * hhn(i) * dd;
    b(3) = -hhm(i) * d * x(1) - hhn(i) * dd * x(2);
    db(1, 1) = -ddt * ddt * hhm(i) * d;
    db(1, 3) = -hhm(i) * (1.f - x(1) * ddt) * d;
    db(2, 2) = -ddt * ddt * hhn(i) * dd;
    db(2, 3) = -hhn(i) * (1.0f - x(2) * ddt) * dd;
    db(3, 3) = -x(1) * x(1) * d * hhm(i) - x(2) * x(2) * dd * hhn(i);
    FEM_DO_SAFE(j, 1, nvar) {
      FEM_DO_SAFE(k, 1, j) {
        db(j, k) = db(k, j);
      }
    }
    //C     FORM THE JACOBIAN MATRIX IN 'HAC'                                 M20.5946
    FEM_DO_SAFE(j, 1, nvar) {
      e(j) = e(j) - a * b(j);
      FEM_DO_SAFE(k, 1, nvar) {
        hac(j, k) += b(j) * b(k) + a * db(j, k);
      }
    }
    statement_60016:;
  }
  error = error / (npoint * ffin * ffin);
  {
    write_loop wloop(cmn, lunit6, format_60300);
    wloop, iter, d;
    FEM_DO_SAFE(j, 1, nvar) {
      wloop, x(j);
    }
    wloop, error;
  }
  if (jgrad > 20 && error > error1) {
    goto statement_60019;
  }
  if (error >= error1) {
    goto statement_60306;
  }
  error1 = error;
  x11 = x(1);
  if (ictrl < 0) {
    x11 = x(2);
  }
  statement_60306:
  if (jgrad <= 20) {
    goto statement_60014;
  }
  if (iter < niter) {
    goto statement_60302;
  }
  write(lunit6, "(' REACHED MAX ITTERATIONS =',i3)"), niter;
  goto statement_60010;
  statement_60302:
  if (error >= eps) {
    goto statement_60304;
  }
  write(lunit6, "(' SUCCESSFUL CONVERGENCE')");
  goto statement_60010;
  //C     SOLVE THE SYSTEM OF EQUATIONS FOR INCREMENTING VARIABLES 'X'.     M20.5963
  statement_60304:
  if (iprsup >= 4) {
    {
      write_loop wloop(cmn, lunit6, "(9(2x,e12.5))");
      FEM_DO_SAFE(i, 1, 3) {
        FEM_DO_SAFE(j, i, 3) {
          wloop, hac(i, j);
        }
        wloop, e(i);
      }
    }
  }
  FEM_DO_SAFE(i, 1, nvar) {
    ipi = i + 1;
    if (std::abs(hac(i, i)) >= epspv2) {
      goto statement_50004;
    }
    if (ipi > nvar) {
      goto statement_50003;
    }
    FEM_DO_SAFE(j, ipi, nvar) {
      if (std::abs(hac(j, i)) < epspv2) {
        goto statement_50002;
      }
      FEM_DO_SAFE(k, i, nvar) {
        temp = hac(j, k);
        hac(j, k) = hac(i, k);
        hac(i, k) = temp;
      }
      goto statement_50004;
      statement_50002:;
    }
    //C     KILL THE CASE IF JACOBIAN MATRIX IS SINGULAR.                     M20.5979
    statement_50003:
    kill = 156;
    lstat(19) = 4545;
    goto statement_9200;
    statement_50004:
    temp = hac(i, i);
    e(i) = e(i) / temp;
    if (ipi > nvar) {
      goto statement_50006;
    }
    FEM_DO_SAFE(k, ipi, nvar) {
      hac(i, k) = hac(i, k) / temp;
    }
    statement_50006:
    FEM_DO_SAFE(j, 1, nvar) {
      if (j == i) {
        goto statement_50008;
      }
      temp = hac(j, i);
      e(j) = e(j) - temp * e(i);
      if (ipi > nvar) {
        goto statement_50008;
      }
      FEM_DO_SAFE(k, ipi, nvar) {
        hac(j, k) = hac(j, k) - temp * hac(i, k);
      }
      statement_50008:;
    }
  }
  goto statement_60015;
  //C                           TYPE 3 ITERATION                            M20.5998
  //C                                                                       M20.5999
  //C     THE SUM OF THE SQUARE ERROR HAS INCREASED OVER THE LAST ITERATION.M20.6000
  //C     RECOVER THE ORIGINAL INCREMENT TO THE X VECTOR AND USE A SCALED   M20.6001
  //C     MULTIPLE OF THIS INCREMENT TO FORM THE NEW X VECTOR.              M20.6002
  statement_60019:
  cnt = cnt / 10.f;
  iter2++;
  if (jgrad <= 20) {
    goto statement_4557;
  }
  FEM_DO_SAFE(j, 1, nvar) {
    x(j) = xold(j) + cnt * xold(j) * eold(j) / std::abs(eold(j));
  }
  if (iter2 <= niter) {
    goto statement_62500;
  }
  //C     PROGRAM STUCK IN 'TYPE 3' LOOP.   KILL THE RUN.                   M20.6008
  statement_4557:
  kill = 156;
  lstat(19) = 4557;
  goto statement_9200;
  //C     UPDATE VARIABLES 'X'                                              M20.6012
  statement_60015:
  FEM_DO_SAFE(j, 1, nvar) {
    xold(j) = x(j);
    eold(j) = e(j);
    x(j) += e(j);
  }
  FEM_DO_SAFE(j, 1, nvar) {
    if (std::abs(e(j) / x(j)) > eps1) {
      goto statement_60012;
    }
  }
  write(lunit6,
    "(' TERMINATION OF ITTERATION BECAUSE RELATIVE CORRECTIONS ARE LESS THAN E"
    "PS1')");
  statement_60010:
  x(3) = x(3) * tt + tstrt;
  x(1) = tt / x(1);
  if (ictrl < 0) {
    ictrl = -ictrl - 1;
  }
  d1 = w * x(3);
  d2 = sinz(d1);
  d1 = cosz(d1);
  d3 = shiftr * d1 + shifti * d2;
  shifti = shiftr * d2 - shifti * d1;
  shiftr = d3;
  write(lunit6,
    "(/,5x,"
    "'STEADY STATE FREQUENCY IMPULSE RESPONSE, ROTATED THROUGH DELAY TIME X(3)"
    "',/,5x,"
    "'FOR USE IN ADJUSTING BY HAND FOR A PRECISE FIT AT STEADY STATE FREQUENCY"
    "',/,5x,2e14.5)"),
    shiftr, shifti;
  if (ictrl == 0) {
    goto statement_60205;
  }
  //C     ADJUST FITTING TO AGREE EXACTLY AT STEADY STATE                   M20.6023
  write(lunit6,
    "(/,2x,'ITERATIONS TO ADJUST FITTING AT STEADY STATE FREQUENCY',/,18x,"
    "'AMPL 1',11x,'AMPL 2',9x,'TIME CONST',8x,'ERROR AT 60HZ',/,1x)");
  error = tt / x(2);
  if (error / x(1) < 10.f) {
    goto statement_60205;
  }
  x1 = d;
  a = ffin - d;
  iiter = 0;
  ddt = w * x(1);
  zp = cmn.unity + ddt * ddt;
  ddt = ddt / zp;
  temp = ft2emx * sqrtz(shiftr * shiftr + shifti * shifti);
  //C     THIS LOOP ADJUSTS D AND X(2) TO MAKE THE ANALYTICALLY COMPUTED    M20.6042
  //C     FOURIER TRANSFORM OF THE ANALYTICAL APPROXIMATION AGREE EXACTLY   M20.6043
  //C     WITH THE DATA AT STEADY STATE FREQUENCY.                          M20.6044
  //C                                                                       M20.6045
  //C     FOURIERTX((D/DT)Z(T)) = CEXP(CMPLX(0,-X(3) * W)) *                M20.6046
  //C          (D/CMPLX(1,W / X(1)) + (FFIN - D)/CMPLX(1,W / X(2)))         M20.6047
  if (iprsup >= 3) {
    write(lunit6,
      "(/,/,"
      "' PRIOR TO STEADY STATE ITERATION IN TDFIT, SHIFTR,  SHIFTI, DDT, TT, W"
      ", X(1), X(2), ZP, X1, A, ERROR ARE ',/(2x,6e12.5))"),
      shiftr, shifti, ddt, tt, w, x(1), x(2), zp, x1, a, error;
  }
  statement_61002:
  zr = shiftr - x1 / zp;
  zi = shifti + x1 * ddt;
  d1 = w * error;
  d2 = 1.0f + d1 * d1;
  d3 = zr - a / d2;
  d4 = zi + a * d1 / d2;
  error1 = sqrtz(d3 * d3 + d4 * d4);
  if (error1 < ft2emx) {
    goto statement_61000;
  }
  iiter++;
  if (iiter < niter1) {
    goto statement_61001;
  }
  if (ictrl == 2) {
    goto statement_60205;
  }
  write(lunit6,
    "(5x,'WARNING---ITERATION TO ADJUST TIME DOMAIN STEP RESPONSE TO FIT EXACT"
    "LY AT STEADY STATE FREQUENCY',/,5x,"
    "'HAS FAILED TO CONVERGE,  LAST STEADY STATE FITTING ASSUMED.')");
  goto statement_61004;
  statement_61001:
  error = -zi / zr / w;
  if (error <= 0.0f) {
    goto statement_60205;
  }
  a = (zr * zr + zi * zi) / zr;
  x1 = ffin - a;
  if (iprsup >= 3) {
    write(lunit6,
      "(/,/,' IN THE STEADY STATE ITERATION LOOP IN TDFIT, AT ITERATION',i3,"
      "' ZR, ZI, D1, D2, D3, D4, ERROR1, ERROR, A, X1 ARE',/,2x,10e12.5)"),
      iiter, zr, zi, d1, d2, d3, d4, error1, error, a, x1;
  }
  write(lunit6, format_60300), iiter, x1, a, error, error1;
  goto statement_61002;
  statement_61000:
  write(lunit6,
    "(/,5x,' STEADY STATE FREQUENCY FITTING ITERATIONS=',i3,20x,"
    "'60 HZ FITTING ERROR =',e14.5,/,1x)"),
    iiter, error1;
  statement_61004:
  x(2) = error;
  d = x1;
  goto statement_60206;
  statement_60205:
  a = ffin - d;
  x(2) = tt / x(2);
  if (ictrl == 0) {
    goto statement_60206;
  }
  write(lunit6,
    "(5x,'WARNING---PROGRAM CAN NOT ADJUST TIME DOMAIN STEP RESPONSE TO FIT EX"
    "ACTLY AT STEADY STATE FREQUENCY.',/,15x,'INITIAL FITTING ASSUMED.')");
  statement_60206:
  setplt();
  write(lunit6, "(/,/,/,/,/)");
  write(lunit6,
    "(/,/,30x,'FIRST AMPLITUDE      = ',e15.6,/,30x,'FIRST TIME CONSTANT  = ',"
    "e15.6,/,30x,'SECOND AMPLITUDE     = ',e15.6,/,30x,"
    "'SECOND TIME CONSTANT = ',e15.6,/,30x,'DELAY                = ',e15.6,/,"
    "1x)"),
    d, x(1), a, x(2), x(3);
  //C     OUTPUT PRINTER PLOT OF STEP FUNCTION AND ITS ANALYTICAL APPROX-   M20.6088
  //C     IMATION AND CALCUALTE THE FINAL ERROR.                            M20.6089
  statement_40500:
  x3 = x(3) - tstrt;
  a = ffin - d;
  error1 = 0.f;
  if (fvmx < ffin) {
    fvmx = ffin;
  }
  write(lunit6,
    "('0',5x,'MODE ',i1,5x,'TIME STEP = ',e12.5,"
    "' SEC.(. = EXP. APPROX., 0 = IFT OUTPUT, * = INTERSECTION)',/,8x,'ERROR',"
    "11x,'TIME',5x,'0.0',80x,e12.5,/,33x,'.1',10('........1'))"),
    i1, tstep, fvmx;
  fvmx = 90.f / fvmx;
  FEM_DO_SAFE(i, 1, npoint) {
    t2 = i * tstep - x3;
    if (t2 < 0.0f) {
      goto statement_60403;
    }
    hhm(i) = t2 / x(1);
    if (hhm(i) > 30.f) {
      hhm(i) = 30.f;
    }
    hhm(i) = expz(-hhm(i));
    hhn(i) = t2 / x(2);
    if (hhn(i) > 30.f) {
      hhn(i) = 30.f;
    }
    hhn(i) = expz(-hhn(i));
    zp = d * (1.0f - hhm(i)) + a * (1.0f - hhn(i));
    error = zp - fv(i);
    goto statement_60402;
    statement_60403:
    zp = 0.0f;
    error = 0.0f;
    statement_60402:
    error1 += error * error;
    j = fvmx * zp + 1.5f;
    k = fvmx * fv(i) + 1.5f;
    if (j >= 1 && j <= 91) {
      pl(j) = text7;
    }
    if (k >= 1 && k <= 91) {
      pl(k) = text8;
    }
    if (j == k && j >= 1 && k <= 91) {
      pl(j) = text9;
    }
    t2 += x(3);
    {
      write_loop wloop(cmn, lunit6, "(5x,e12.5,3x,e12.5,' .',91a1)");
      wloop, error, t2;
      FEM_DO_SAFE(L, 1, 91) {
        wloop, pl(L);
      }
    }
    if (k >= 1 && k <= 91) {
      pl(k) = blank;
    }
    if (j >= 1 && j <= 91) {
      pl(j) = blank;
    }
  }
  error1 = error1 / (npoint * ffin * ffin);
  write(lunit6,
    "(2x,'ITERATIONS = ',i3,60x,'NORMALIZED SQUARE ERROR PER POINT = ',e12.5,"
    "/,1x)"),
    iter, error1;
  setstd();
  statement_9200:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct guts45_save
{
  fem::str<8> text1;
  fem::str<8> text10;
  fem::str<8> text11;
  fem::str<8> text12;
  fem::str<8> text13;
  fem::str<8> text14;
  fem::str<8> text15;
  fem::str<8> text16;
  fem::str<8> text17;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text5;
  fem::str<8> text6;

  guts45_save() :
    text1(fem::char0),
    text10(fem::char0),
    text11(fem::char0),
    text12(fem::char0),
    text13(fem::char0),
    text14(fem::char0),
    text15(fem::char0),
    text16(fem::char0),
    text17(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text5(fem::char0),
    text6(fem::char0)
  {}
};

void
guts45(
  common& cmn,
  arr_ref<double> pbuf,
  arr_ref<double> cq,
  arr_ref<double> z,
  arr_ref<double> y,
  arr_ref<double> zy,
  arr_ref<double> zya,
  arr_ref<double> zyb,
  arr_ref<double> zyc,
  arr_ref<double> zyd,
  arr_ref<double> cqt,
  arr_ref<double> q,
  arr_ref<double> qi,
  arr_ref<double> g,
  arr_ref<double> g60,
  arr_ref<double> yo,
  arr_ref<double> xr,
  arr_ref<double> xl,
  arr_ref<double> xg,
  arr_ref<double> xc,
  arr_ref<double> um,
  arr_ref<double> si,
  arr_ref<double> vresp,
  arr_ref<double> ymin,
  arr_ref<double> fv,
  arr_ref<double> hhm,
  arr_ref<double> hhn,
  arr_cref<double> zcos) try
{
  FEM_CMN_SVE(guts45);
  pbuf(dimension(1));
  cq(dimension(1));
  z(dimension(1));
  y(dimension(1));
  zy(dimension(1));
  zya(dimension(1));
  zyb(dimension(1));
  zyc(dimension(1));
  zyd(dimension(1));
  cqt(dimension(1));
  q(dimension(1));
  qi(dimension(1));
  g(dimension(1));
  g60(dimension(1));
  yo(dimension(1));
  xr(dimension(1));
  xl(dimension(1));
  xg(dimension(1));
  xc(dimension(1));
  um(dimension(1));
  si(dimension(1));
  vresp(dimension(1));
  ymin(dimension(1));
  fv(dimension(1));
  hhm(dimension(1));
  hhn(dimension(1));
  zcos(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& blank = cmn.blank;
  auto& vstacs= cmn.vstacs;
  const auto& abuff = cmn.abuff;
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  double& twopi = cmn.twopi;
  double& tenm6 = cmn.tenm6;
  double& fltinf = cmn.fltinf;
  const auto& voltbc = cmn.voltbc;
  auto& flstat = cmn.flstat;
  auto& lunit2 = cmn.lunit2;
  auto& lunit3 = cmn.lunit3;
  auto& lunit7 = cmn.lunit7;
  auto& ipntv = cmn.ipntv;
  auto& indtv = cmn.indtv;
  auto& lstat = cmn.lstat;
  int& icheck = cmn.icheck;
  int& lastov = cmn.lastov;
  int& ialter = cmn.ialter;
  int& ipun = cmn.ipun;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  auto& pl = cmn.pl;
  double& f = static_cast<common_com45&>(cmn).f;
  double& w = cmn.w;
  double& ratio = cmn.ratio;
  double& sll = cmn.sll;
  double& spdlt = cmn.spdlt;
  double& tt = cmn.tt;
  double& tstrt = cmn.tstrt;
  double& tretrd = cmn.tretrd;
  double& tstep = static_cast<common_com45&>(cmn).tstep;
  double& ffin = cmn.ffin;
  double& shiftr = cmn.shiftr;
  double& shifti = cmn.shifti;
  double& d = cmn.d;
  auto& x = static_cast<common_com45&>(cmn).x;
  int& ictrl = cmn.ictrl;
  int& i1 = cmn.i1;
  int& iwork = cmn.iwork;
  int& nph = cmn.nph;
  int& nph2 = cmn.nph2;
  int& nphpi2 = cmn.nphpi2;
  int& nphsq = cmn.nphsq;
  int& iss = cmn.iss;
  int& nfr = cmn.nfr;
  int& nfr1 = cmn.nfr1;
  int& ix = cmn.ix;
  int& kreqab = cmn.kreqab;
  const auto& volti = static_cast<common_volpri&>(cmn).volti_50;
  const auto& voltk = static_cast<common_volpri&>(cmn).voltk_50;
  auto& vim = cmn.vim;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text10 = sve.text10;
  fem::str<8>& text11 = sve.text11;
  fem::str<8>& text12 = sve.text12;
  fem::str<8>& text13 = sve.text13;
  fem::str<8>& text14 = sve.text14;
  fem::str<8>& text15 = sve.text15;
  fem::str<8>& text16 = sve.text16;
  fem::str<8>& text17 = sve.text17;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text5 = sve.text5;
  fem::str<8>& text6 = sve.text6;
  if (is_called_first_time) {
    text1 = "BRANCH";
    text2 = "NEW RH";
    text3 = "O     ";
    text5 = "OLD DA";
    text6 = "TA    ";
    text10 = "TOLERA";
    text11 = "NCES  ";
    text12 = "LINE C";
    text13 = "ONSTAN";
    text14 = "TS    ";
    text15 = "CABLE ";
    text16 = "CONSTA";
    text17 = "NTS   ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  double eps = fem::double0;
  double eps1 = fem::double0;
  double fit2z = fem::double0;
  double pivthr = fem::double0;
  double epsrse = fem::double0;
  double ft2emx = fem::double0;
  double epseig = fem::double0;
  double epspv2 = fem::double0;
  double fmed = fem::double0;
  double epsyc = fem::double0;
  double epsn = fem::double0;
  double ffinp = fem::double0;
  int nfit = fem::int0;
  int niter1 = fem::int0;
  int niter = fem::int0;
  int nitery = fem::int0;
  int nieig = fem::int0;
  int noo = fem::int0;
  int npoint = fem::int0;
  int nss = fem::int0;
  int kfit = fem::int0;
  int kps = fem::int0;
  int kyc = fem::int0;
  int idoc = fem::int0;
  int iotx = fem::int0;
  int ioss = fem::int0;
  int iofl = fem::int0;
  int npan = fem::int0;
  int ll6 = fem::int0;
  int m = fem::int0;
  int i = fem::int0;
  int n1 = fem::int0;
  arr_1d<10, int> mfrecv(fem::fill0);
  arr_1d<5, double> russ(fem::fill0);
  int n7 = fem::int0;
  int n10 = fem::int0;
  arr_1d<12, int> itemp(fem::fill0);
  int n8 = fem::int0;
  int j = fem::int0;
  int n9 = fem::int0;
  int L = fem::int0;
  int n2 = fem::int0;
  int n3 = fem::int0;
  int n4 = fem::int0;
  int lcin = fem::int0;
  int n12 = fem::int0;
  double d1 = fem::double0;
  int nfrph = fem::int0;
  int lcosi = fem::int0;
  int kprec = fem::int0;
  int lcosd = fem::int0;
  int lift = fem::int0;
  int ipunm = fem::int0;
  double zero = fem::double0;
  int k = fem::int0;
  double temp = fem::double0;
  int iadm = fem::int0;
  arr_1d<3, double> ww(fem::fill0);
  int jp1 = fem::int0;
  double wo = fem::double0;
  double wm = fem::double0;
  int kmin = fem::int0;
  int kypr = fem::int0;
  int jxq = fem::int0;
  double d13 = fem::double0;
  int il = fem::int0;
  double constm = fem::double0;
  int jm = fem::int0;
  double sif = fem::double0;
  arr_1d<5, double> amarti(fem::fill0);
  double ttchk = fem::double0;
  double d2 = fem::double0;
  double cst = fem::double0;
  int jmax = fem::int0;
  int kfys = fem::int0;
  int kfps = fem::int0;
  int iy = fem::int0;
  int iy3 = fem::int0;
  int i2 = fem::int0;
  int i3 = fem::int0;
  int i4 = fem::int0;
  int i5 = fem::int0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  arr_1d<6, double> ygr(fem::fill0);
  double ysurg = fem::double0;
  arr_1d<4, double> e(fem::fill0);
  arr_1d<4, double> b(fem::fill0);
  int iter = fem::int0;
  double zr = fem::double0;
  double zi = fem::double0;
  double targ = fem::double0;
  double w2 = fem::double0;
  double den1 = fem::double0;
  double den2 = fem::double0;
  double hssr = fem::double0;
  double hssi = fem::double0;
  double yssr = fem::double0;
  double yssi = fem::double0;
  double hamp = fem::double0;
  double dd11 = fem::double0;
  double hang = fem::double0;
  double alnh = fem::double0;
  int kmax1 = fem::int0;
  int kmin1 = fem::int0;
  int kmax2 = fem::int0;
  int kmin2 = fem::int0;
  int kmax = fem::int0;
  static const char* format_10020 = "(13a6,a2)";
  static const char* format_10130 = "(48x,2e12.5)";
  static const char* format_10290 = "(13a6,a2)";
  static const char* format_10654 = "(/,/,1x)";
  static const char* format_422 =
    "(5x,'INITIAL VALUE OF CHARACTERISTIC ADMITTANCE = ',e12.5)";
  static const char* format_443 = "(7x,6e12.5)";
  static const char* format_444 = "(2x,6e12.5)";
  static const char* format_5021 = "(/(1x,12(2x,f8.6)))";
  static const char* format_6002 = "(6f12.9)";
  //C!EQUIVALENCE (VIM(1),EPS),(VIM(2),EPS1),(VIM(3),FIT2Z)
  //C!EQUIVALENCE (VIM(4),PIVTHR),(VIM(5),EPSRSE)
  //C!EQUIVALENCE (VIM(7),FT2EMX),(VIM(8),EPSEIG),(VIM(9),EPSPV2)
  //C!EQUIVALENCE (VIM(10),FMED),(VIM(11),EPSYC),(VIM(12),EPSN)
  //C!EQUIVALENCE (VIM(13),FFINP)
  //C!EQUIVALENCE (IPNTV(1),NFIT),(IPNTV(2),NITER1),(IPNTV(3),NITER)
  //C!EQUIVALENCE (IPNTV(4),NITERY),(IPNTV(5),NIEIG)
  //C!EQUIVALENCE (IPNTV(10),NOO),(INDTV(1),NPOINT),(INDTV(2),NSS)
  //C!EQUIVALENCE (INDTV(3),KFIT),(INDTV(4),KPS),(INDTV(5),KYC)
  //C!EQUIVALENCE (INDTV(6),IDOC),(INDTV(7),IOTX),(INDTV(8),IOSS)
  //C!EQUIVALENCE (INDTV(9),IOFL),(INDTV(10),NPAN)
  
  eps = vim(1);
  eps1 = vim(2);
  fit2z = vim(3);
  pivthr = vim(4);
  epsrse = vim(5);
  ft2emx = vim(7);
  epseig = vim(8);
  epspv2 = vim(9);
  fmed = vim(10);
  epsyc = vim(11);
  epsn = vim(12);
  ffinp = vim(13);
  //C
  nfit = ipntv(1);
  niter1 = ipntv(2);
  niter = ipntv(3);
  nitery = ipntv(4);
  nieig = ipntv(5);
  noo = ipntv(10);
  npoint = indtv(1);
  nss = indtv(2);
  kfit = indtv(3);
  kps = indtv(4);
  kyc = indtv(5);
  idoc = indtv(6);
  iotx = indtv(7);
  ioss = indtv(8);
  iofl = indtv(9);
  npan = indtv(10);
  //C
  ll6 = 6;
  if (lastov == 1) {
    goto statement_3107;
  }
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' AT BEGINNING OF ''OVER45'' .  LUNIT5  IALTER  LASTOV     NSS  ICHE"
      "CK    IOTX    IOSS    IOFL    KTAB',/,27x,9i8,/,13x,'CI1',12x,'CK1',6x,"
      "'VOLTBC(1)',7x,'VOLTK(1)',7x,'VOLTI(1)',/,1x,5e15.6)"),
      cmn.lunit5, ialter, lastov, nss, icheck, iotx, ioss, iofl,
      cmn.ktab, ci1, ck1, voltbc(1), voltk(1), volti(1);
  }
  if (ialter == 3) {
    goto statement_10140;
  }
  goto statement_10180;
  //C     DEFAULT DEFINITION OF  'TOLERANCES'  PARAMETERS.                  M16.4612
  statement_3107:
  eps = 0.5e-4;
  vim(1) = eps;
  eps1 = .5e-2;
  vim(2) = eps1;
  fit2z = 1.0e-1;
  vim(3) = fit2z;
  pivthr = 1.0e-5;
  vim(4) = pivthr;
  epsrse = 1.0e-2;
  vim(5) = epsrse;
  ft2emx = 1.0e-4;
  vim(7) = ft2emx;
  fmed = 5000.f;
  vim(10) = fmed;
  epsyc = 1.0e-3;
  vim(11) = epsyc;
  epsn = 1.0e-3;
  vim(12) = epsn;
  epspv2 = 1.0e-16;
  vim(9) = epspv2;
  ffinp = 1.0f;
  vim(13) = ffinp;
  epseig = 1.0e-7;
  vim(8) = epseig;
  nieig = 30;
  ipntv(5) = nieig;
  nfit = 10;
  ipntv(1) = nfit;
  niter = 10;
  ipntv(3) = niter;
  niter1 = 10;
  ipntv(2) = niter1;
  nitery = 10;
  ipntv(4) = nitery;
  m = 1;
  FEM_DO_SAFE(i, 1, 24) {
    vstacs(i) = blank;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M16.4633
  statement_2946:
  cimage(cmn);
  statement_10015:
  ialter = 1;
  read(abuff, format_10020), bus1;
  if (bus1 != text1) {
    goto statement_10060;
  }
  //C     OPTIONAL  'BRANCH'  CARD, WHICH SPECIFIES  A6  BRANCH NAMES.      M16.4639
  n1 = m + 11;
  {
    read_loop rloop(abuff(1), "(8x,12a6)");
    FEM_DO_SAFE(i, m, n1) {
      rloop, vstacs(i);
    }
  }
  m += 12;
  write(kunit6, "('+BUS NAMES FOR EACH PHASE.')");
  goto statement_2946;
  statement_10060:
  read(abuff, format_10020), bus1, bus2;
  if (bus1 != text10) {
    goto statement_10090;
  }
  if (bus2 != text11) {
    goto statement_10090;
  }
  //C     OPTIONAL  'TOLERANCES'  CARD, TO REDEFINE OVERLAY TOLERANCES.     M16.4650
  {
    read_loop rloop(abuff(1), "(12x,5(i2,e11.0))");
    FEM_DO_SAFE(i, 1, 5) {
      rloop, mfrecv(i), russ(i);
    }
  }
  {
    write_loop wloop(cmn, kunit6, "('+NEW SEMLYEN TOLERANCES.',5i4)");
    FEM_DO_SAFE(i, 1, 5) {
      wloop, mfrecv(i);
    }
  }
  FEM_DO_SAFE(i, 1, 5) {
    n1 = mfrecv(i);
    if (n1 <= 0) {
      goto statement_10080;
    }
    if (n1 > 18) {
      goto statement_10080;
    }
    if (n1 > 13) {
      goto statement_10075;
    }
    vim(n1) = russ(i);
    goto statement_10080;
    statement_10075:
    ipntv(n1 - 13) = russ(i);
    statement_10080:;
  }
  goto statement_2946;
  //C     READ  'SEMLYEN SETUP'  MISCELLANEOUS DATA PARAMETERS.             M16.4664
  statement_10090:
  read(abuff, "(a6,a2,2i5,6i2,3i6,24x,i3)"), bus1, bus2, noo, npoint,
    nss, kfit, kps, kyc, ipun, idoc, iotx, ioss, iofl, npan;
  indtv(6) = idoc;
  ipntv(10) = noo;
  indtv(1) = npoint;
  indtv(2) = nss;
  indtv(3) = kfit;
  indtv(4) = kps;
  indtv(5) = kyc;
  indtv(7) = iotx;
  indtv(8) = ioss;
  indtv(9) = iofl;
  indtv(10) = npan;
  write(kunit6, "('+MISC. DATA.',7i5)"), noo, npoint, nss, kfit, kps, kyc, ipun;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' SEMLYEN MISC. DATA.',"
      "'     NOO  NPOINT     NSS    KFIT     KPS     KYC    IPUN    IDOC',/,"
      "20x,8i8)"),
      noo, npoint, nss, kfit, kps, kyc, ipun, idoc;
  }
  if (bus1 != text5) {
    goto statement_10120;
  }
  if (bus2 != text6) {
    goto statement_10120;
  }
  ialter = 3;
  if (nss + icheck == 2) {
    goto statement_10132;
  }
  kill = 182;
  lstat(14) = icheck;
  lstat(15) = nss;
  lstat(19) = 10132;
  goto statement_9200;
  statement_10132:
  read(abuff, format_10130), russ(1), ck1;
  if (ck1 == 0.f) {
    ck1 = sll;
  }
  if (russ(1) == ci1 || russ(1) == 0.f) {
    goto statement_10131;
  }
  ialter = 2;
  ci1 = russ(1);
  goto statement_10140;
  statement_10131:
  cmn.io.rewind(lunit3);
  goto statement_9999;
  statement_10120:
  if (bus1 != text2) {
    goto statement_10136;
  }
  if (bus2 != text3) {
    goto statement_10136;
  }
  ialter = 2;
  if (nss + icheck == 2) {
    goto statement_10133;
  }
  kill = 182;
  lstat(14) = icheck;
  lstat(15) = nss;
  lstat(19) = 10133;
  goto statement_9200;
  statement_10133:
  read(abuff, format_10130), ci1, ck1;
  if (ck1 == 0.f) {
    ck1 = sll;
  }
  goto statement_10140;
  statement_10136:
  ci1 = -fltinf;
  ck1 = -fltinf;
  statement_10140:
  if (iotx !=  - 1) {
    goto statement_1774;
  }
  FEM_DO_SAFE(i, 1, 3) {
    n7 = 0;
    n10 = 0;
    //C     READ INPUT CARD USING CIMAGE                                      M21. 449
    cimage(cmn);
    {
      read_loop rloop(abuff(1), "(20i4)");
      FEM_DO_SAFE(n8, 1, 12) {
        rloop, itemp(n8);
      }
    }
    FEM_DO_SAFE(j, 1, 4) {
      n8 = 4;
      n9 = 0;
      FEM_DO_SAFE(L, 1, 3) {
        n7++;
        if (itemp(n7) == 0) {
          goto statement_1729;
        }
        n9 += n8;
        statement_1729:
        n8 = n8 / 2;
      }
      n10 = n10 * 10 + n9;
    }
    if (i > 1) {
      goto statement_1743;
    }
    iotx = n10;
    indtv(7) = iotx;
    write(kunit6, "('+  ''IOTX''  COMPONENTS.   OCTAL VALUE =',i5)"), iotx;
    goto statement_1765;
    statement_1743:
    if (i > 2) {
      goto statement_1753;
    }
    ioss = n10;
    indtv(8) = ioss;
    write(kunit6, "('+  ''IOSS''  COMPONENTS.   OCTAL VALUE =',i5)"), ioss;
    goto statement_1765;
    statement_1753:
    iofl = n10;
    indtv(9) = iofl;
    write(kunit6, "('+  ''IOFL''  COMPONENTS.   OCTAL VALUE =',i5)"), iofl;
    statement_1765:;
  }
  statement_1774:
  FEM_DO_SAFE(i, 7, 9) {
    n1 = fem::iabs(indtv(i));
    n2 = 0;
    n3 = 1;
    statement_10150:
    n4 = n1 / 10;
    n1 = n1 - 10 * n4;
    if (n1 < 8) {
      goto statement_10160;
    }
    kill = 154;
    lstat(13) = i - 6;
    lstat(14) = indtv(i);
    lstat(19) = 10160;
    goto statement_9200;
    statement_10160:
    n2 += n3 * n1;
    n3 = 8 * n3;
    n1 = n4;
    if (n1 > 0) {
      goto statement_10150;
    }
    indtv(i) = n2;
  }
  if (ialter > 2) {
    goto statement_10310;
  }
  if (ialter == 2) {
    goto statement_10172;
  }
  if (lastov == 1) {
    goto statement_3121;
  }
  if (lastov == 44) {
    goto statement_3121;
  }
  if (lastov == 47) {
    goto statement_3121;
  }
  statement_10172:
  n1 = nchain;
  nchain = lastov;
  lastov = n1;
  goto statement_9900;
  //C     READ INPUT CARD USING CIMAGE.                                     M16.4714
  statement_3121:
  cimage(cmn);
  read(abuff, format_10020), bus3, bus4, bus5;
  if (bus3 != text12) {
    goto statement_3128;
  }
  if (bus4 != text13) {
    goto statement_3128;
  }
  if (bus5 != text14) {
    goto statement_3128;
  }
  if (iprsup >= 1) {
    write(lunit6, "(' TRANSFER TO  ''LINE CONSTANTS'' .')");
  }
  kreqab = 0;
  lastov = nchain;
  nchain = 44;
  goto statement_9900;
  statement_3128:
  if (bus3 != text15) {
    goto statement_3136;
  }
  if (bus4 != text16) {
    goto statement_3136;
  }
  if (bus5 != text17) {
    goto statement_3136;
  }
  write(kunit6, "('+TRANSFER TO  ''CABLE CONSTANTS'' .')");
  kreqab = 1;
  lastov = nchain;
  nchain = 47;
  goto statement_9900;
  statement_3136:
  kill = 187;
  lstat(19) = 3136;
  goto statement_9200;
  statement_10180:
  if (nss + icheck == 2) {
    goto statement_10190;
  }
  kill = 182;
  lstat(14) = icheck;
  lstat(15) = nss;
  lstat(19) = 10190;
  goto statement_9200;
  statement_10190:
  FEM_DO_SAFE(i, 1, icheck) {
    if (volti(i) == ci1) {
      goto statement_10200;
    }
    kill = 183;
    lstat(13) = i;
    lstat(19) = 10200;
    goto statement_9200;
    statement_10200:;
  }
  lcin = 0;
  n1 = 1;
  cmn.io.rewind(lunit2);
  cmn.io.rewind(lunit3);
  n1 = 0;
  FEM_DO_SAFE(n12, 1, 9999) {
    {
      read_loop rloop(cmn, lunit2, format_10290);
      FEM_DO_SAFE(i, 1, 14) {
        rloop, pl(i);
      }
    }
    lcin++;
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, lunit6,
          "(/,' 80-COL. CARD IMAGE FROM ''LUNIT2'' , NO.',i3,'.',13a6,a2)");
        wloop, lcin;
        FEM_DO_SAFE(i, 1, 14) {
          wloop, pl(i);
        }
      }
    }
    if (pl(1) == blank && pl(2) == blank) {
      n1++;
    }
    if (n1 >= 1 && kreqab == 1) {
      goto statement_10310;
    }
    if (n1 >= 2 && kreqab == 0) {
      goto statement_10310;
    }
  }
  statement_10310:
  sll = ck1;
  if (npan > 0) {
    cmn.xpan = twopi / npan;
  }
  si(1) = 0.f;
  iss = 0;
  cmn.cold = 0.f;
  if (kreqab == 1) {
    goto statement_10320;
  }
  spdlt = 186283.5807e0;
  goto statement_10330;
  statement_10320:
  spdlt = cmn.speedl;
  statement_10330:
  d1 = 10.f;
  cmn.conv5 = 20.f / alogz(d1);
  nfrph = nfr1 * nph;
  ratio = voltbc(3);
  cmn.dplu = ratio + 1.0f;
  cmn.dmin = ratio - 1.0f;
  lcosi = 3 * nfrph + 1;
  kprec = 1;
  if (locint(pbuf(11)) - locint(pbuf(1)) == locint(zcos(11)) - locint(
      zcos(1))) {
    kprec = 2;
  }
  lcosd = lcosi / 2 + 1;
  if (kprec == 2) {
    lcosd = lcosi;
  }
  lift = lcosi + nfr1 * 2 + 1;
  if (kprec == 2) {
    lift = lcosi + nfr1;
  }
  ipunm = ipun / 10;
  ipun = ipun - 10 * ipunm;
  if (iotx > 0) {
    write(lunit6,
      "('1',5x,"
      "'CALCULATION OF TRANSFORMATION MATRICES.  CONTINUOUS TRANSPOSITION FLAG"
      " = ',i2)"),
      nss;
  }
  //C              ***   AT THE TRANSFORMATION FREQUENCY   ***              M16.4809
  if (nss == 1) {
    goto statement_10520;
  }
  if (iotx < 128) {
    goto statement_10500;
  }
  kill = 185;
  lstat(13) = iotx;
  lstat(14) = 127;
  lstat(19) = 10500;
  goto statement_9200;
  statement_10500:
  iwork = 2;
  f = voltk(1);
  w = twopi * f;
  frqdom(cmn, iotx, pbuf, z, y, zy, zya, zyb, zyc, zyd, cq, cqt, q,
    qi, g, g60, yo, xr, xl, xg, xc);
  if (kill > 0) {
    goto statement_9200;
  }
  j = 1;
  FEM_DOSTEP(i, 1, cmn.n22, 2) {
    q(j) = cq(i);
    qi(j) = zya(i);
    j++;
  }
  if (ipunm < 1) {
    goto statement_10605;
  }
  zero = 0.f;
  FEM_DO_SAFE(i, 1, nph) {
    {
      write_loop wloop(cmn, lunit7, format_6002);
      FEM_DOSTEP(j, i, nphsq, nph) {
        wloop, qi(j);
      }
    }
    {
      write_loop wloop(cmn, lunit7, format_6002);
      FEM_DO_SAFE(j, 1, nph) {
        wloop, zero;
      }
    }
  }
  goto statement_10605;
  statement_10520:
  k = 1;
  FEM_DO_SAFE(j, 1, nph) {
    FEM_DO_SAFE(i, 1, nph) {
      q(k) = 1.f;
      if (i == j && i != 1) {
        q(k) = 1 - i;
      }
      if (i > j && j != 1) {
        q(k) = 0.f;
      }
      k++;
    }
  }
  FEM_DOSTEP(i, 1, nphsq, nph) {
    k = i + nph - 1;
    temp = 0.f;
    FEM_DO_SAFE(j, i, k) {
      temp += fem::pow2(q(j));
    }
    temp = sqrtz(temp);
    FEM_DO_SAFE(j, i, k) {
      q(j) = q(j) / temp;
      qi(j) = q(j);
    }
  }
  iotx = iotx / 2;
  indtv(7) = iotx;
  n1 = iotx / 2;
  if (n1 + n1 == iotx) {
    goto statement_10605;
  }
  if (nph <= 6) {
    goto statement_5025;
  }
  write(lunit6,
    "('0',41x,'MODE TO PHASE VOLTAGE',/,42x,'TRANSFORMATION MATRIX')");
  FEM_DO_SAFE(i, 1, nph) {
    {
      write_loop wloop(cmn, lunit6, format_5021);
      FEM_DOSTEP(j, i, nphsq, nph) {
        wloop, q(j);
      }
    }
  }
  write(lunit6,
    "('0',41x,'MODE TO PHASE CURRENT',/,42x,'TRANSFORMATION MATRIX')");
  FEM_DO_SAFE(i, 1, nph) {
    {
      write_loop wloop(cmn, lunit6, format_5021);
      FEM_DOSTEP(j, i, nphsq, nph) {
        wloop, qi(j);
      }
    }
  }
  goto statement_10605;
  statement_5025:
  write(lunit6,
    "('0',21x,'MODE TO PHASE VOLTAGE',44x,'MODE TO PHASE CURRENT',/,22x,"
    "'TRANSFORMATION MATRIX',45x,'TRANSFORMATION MATRIX',/,/)");
  FEM_DO_SAFE(i, 1, nph) {
    {
      write_loop wloop(cmn, lunit6, "(65x,'*',/,1x,6(2x,f8.6))");
      FEM_DOSTEP(j, i, nphsq, nph) {
        wloop, q(j);
      }
    }
    {
      write_loop wloop(cmn, kunit6, "('+',64x,'*',1x,6(2x,f8.6))");
      FEM_DOSTEP(j, i, nphsq, nph) {
        wloop, qi(j);
      }
    }
  }
  //C              ***   AT THE STEADY-STATE FREQUENCY   ***                M16.4857
  statement_10605:
  f = voltk(icheck);
  w = twopi * f;
  iadm = 1;
  iss = 1;
  ww(iadm) = w;
  if (ioss > 0) {
    write(lunit6,
      "(/,/,' CALCULATION OF STEADY-STATE PARAMETERS, FOR FREQUENCY =',e15.3,"
      "'   HZ.')"),
      f;
  }
  iwork = 896;
  frqdom(cmn, ioss, pbuf, z, y, zy, zya, zyb, zyc, zyd, cq, cqt, q,
    qi, g, g60, yo, xr, xl, xg, xc);
  if (kill > 0) {
    goto statement_9200;
  }
  iss = 0;
  FEM_DO_SAFE(i, 1, nph2) {
    um(i) = yo(i);
  }
  j = 1;
  FEM_DOSTEP(i, 1, nph2, 2) {
    jp1 = j + 1;
    ymin(i) = sqrtz(y(jp1) / z(jp1));
    ymin(i + 1) = sll * g(i + 1) / w;
    j += nphpi2;
  }
  wo = twopi * voltbc(1);
  wm = wo * fem::pow(ratio, (nfr - 1));
  si(nfr1 + 1) = wm * ratio;
  FEM_DO_SAFE(i, 1, 8) {
    mfrecv(i) = i * nfr / 10;
  }
  mfrecv(9) = nfr - 1;
  mfrecv(10) = nfr;
  {
    write_loop wloop(cmn, lunit6,
      "('1',2x,'NO.FREQ = ',i3,5x,'FIRST FREQUENCY = ',f10.5,5x,"
      "'LAST FREQUENCY =',f10.1,5x,'GEO. RATIO =',f5.3)");
    wloop, nfr;
    FEM_DO_SAFE(i, 1, 3) {
      wloop, voltbc(i);
    }
  }
  FEM_DO_SAFE(i, 1, nph) {
    n1 = i * nfr1 - nfr;
    vresp(n1) = ffinp;
  }
  kmin = 640;
  if (kfit <= 9 && kyc <= 9) {
    kmin = 128;
  }
  kypr = kyc / 10;
  kyc = kyc - 10 * kypr;
  indtv(5) = kyc;
  jxq = 0;
  if (kyc != 3) {
    goto statement_3178;
  }
  d13 = 2.0f * voltbc(1) * tt;
  jxq = -alogz(d13) / alogz(ratio);
  jxq++;
  //C     THIS LOOP CALCULATES THE LINE STEP RESPONSE FOR BOTH THE          M16.4899
  //C     PROPAGATION FUNCTION(NFR POINTS) AND FOR THE ADMITTANCE FUNCTION  M16.4900
  //C     (3 POINTS) IN THE FREQUENCY DOMAIN.                               M16.4901
  statement_3178:
  iadm = 2;
  il = 1;
  w = wo;
  constm = 0.62137f;
  if (kreqab == 1) {
    constm = 1000.f;
  }
  FEM_DO_SAFE(jm, 1, nfr) {
    si(jm + 1) = w;
    f = w / twopi;
    //C     FACTOR FOR SURPRESSION OF THE GIBB'S PHENOMENON.                  M16.4908
    //C     NOTE.  1./W FACTOR CONVERTS IMPULSE TO STEP RESPONSE.             M16.4909
    sif = w * twopi / wm / 2.f;
    sif = sinz(sif) / sif / w;
    if (jm != jxq) {
      goto statement_10653;
    }
    n1 = iofl;
    iwork = 640;
    d1 = 1.0f / (2.f * tt);
    if (n1 != 0) {
      write(lunit6,
        "('1',10x,"
        "'THIS FREQUENCY IS CLOSEST(FROM BELOW) TO THE NATURAL FREQUENCY, F = "
        "(SPEED OF LIGHT)/(2*LENGTH) = ',f10.2,/,11x,"
        "'IT WILL BE USED TO CALCULATE THE CONSTANT CHARACTERISTIC ADMITTANCE "
        "FOR USE IN THE TIME-STEP LOOP CONVOLUTION. ')"),
        d1;
    }
    ww(1) = w;
    FEM_DO_SAFE(i, 1, nph2) {
      um(i) = yo(i);
    }
    frqdom(cmn, n1, pbuf, z, y, zy, zya, zyb, zyc, zyd, cq, cqt, q,
      qi, g, g60, yo, xr, xl, xg, xc);
    goto statement_10656;
    statement_10653:
    iwork = kmin;
    n1 = 0;
    if (jm != mfrecv(il)) {
      goto statement_10655;
    }
    n1 = iofl;
    iwork = 640;
    if (n1 != 0 && jm != 1) {
      write(lunit6, format_10654);
    }
    statement_10655:
    frqdom(cmn, n1, pbuf, z, y, zy, zya, zyb, zyc, zyd, cq, cqt, q,
      qi, g, g60, yo, xr, xl, xg, xc);
    if (kill > 0) {
      goto statement_9200;
    }
    if (ipunm < 1) {
      goto statement_10656;
    }
    amarti(1) = w;
    j = 1;
    FEM_DO_SAFE(i, 1, nph) {
      amarti(2) = y(j) * constm;
      amarti(3) = y(j + 1) * constm;
      amarti(4) = z(j) * constm;
      amarti(5) = z(j + 1) * constm;
      write(lunit7, "(5e16.9)"), amarti;
      j += nphpi2;
    }
    statement_10656:
    ix = jm + 1;
    j = 1;
    FEM_DOSTEP(i, 1, nph2, 2) {
      jp1 = j + 1;
      ttchk = sqrtz(y(jp1) / z(jp1));
      if (ttchk < ymin(i)) {
        ymin(i) = ttchk;
      }
      j += nphpi2;
    }
    FEM_DOSTEP(i, 1, nph2, 2) {
      d1 = sif * expz(-g(i) * sll);
      d2 = g(i + 1) * sll;
      ttchk = d2 / w;
      if (ttchk > ymin(i + 1)) {
        ymin(i + 1) = ttchk;
      }
      vresp(ix) = d1 * cosz(d2);
      n1 = ix + nfrph;
      vresp(n1) = d1 * sinz(d2);
      n1 += nfrph;
      vresp(n1) = yo(i);
      ix += nfr1;
    }
    if (jm != mfrecv(il)) {
      goto statement_10690;
    }
    il++;
    cst = w / twopi;
    if (cst < fmed) {
      goto statement_10670;
    }
    iadm = 3;
    statement_10670:
    ww(iadm) = w;
    n1 = nph2 * (iadm - 1);
    FEM_DO_SAFE(i, 1, nph2) {
      n2 = n1 + i;
      um(n2) = yo(i);
    }
    statement_10690:
    w = wo * fem::pow(ratio, jm);
  }
  w = twopi * voltk(icheck);
  if (iprsup < 3) {
    goto statement_70140;
  }
  {
    write_loop wloop(cmn, lunit6,
      "('0',5x,'PROPAGATION STEP RESPONSE IN THE FREQUENCY DOMAIN.',/,'0',5x,"
      "'OMEGA',3(21x,'MODE ',i2,6x),/(11x,3(21x,'MODE ',i2,6x)))");
    FEM_DO_SAFE(i, 1, nph) {
      wloop, i;
    }
  }
  jmax = nfrph;
  FEM_DO_SAFE(i, 1, nfr1) {
    {
      write_loop wloop(cmn, lunit6,
        "(4x,e12.5,6(2x,e13.5,2x),/(16x,6(2x,e13.5,2x)))");
      wloop, si(i);
      FEM_DOSTEP(n2, i, jmax, nfr1) {
        wloop, vresp(n2), vresp(n2 + nfrph);
      }
    }
  }
  if (kfit <= 9 && kypr <= 0) {
    goto statement_70140;
  }
  {
    write_loop wloop(cmn, lunit6,
      "('1',5x,'ADMITTANCE STEP RESPONSE IN THE FREQUENCY DOMAIN.',/,'0',5x,"
      "'OMEGA',3(21x,'MODE ',i2,6x),/(11x,3(21x,'MODE ',i2,6x)))");
    FEM_DO_SAFE(i, 1, nph) {
      wloop, i;
    }
  }
  jmax = 3 * nfrph;
  FEM_DO_SAFE(i, 1, nfr1) {
    n1 = 2 * nfrph + i;
    {
      write_loop wloop(cmn, lunit6,
        "(4x,e12.5,3(10x,e13.5,9x),/(16x,3(10x,e13.5,9x)))");
      wloop, si(i);
      FEM_DOSTEP(n2, n1, jmax, nfr1) {
        wloop, vresp(n2);
      }
    }
  }
  statement_70140:
  cmn.pi2 = 4.f / twopi;
  FEM_DO_SAFE(i, 1, 91) {
    pl(i) = blank;
  }
  kfys = kfit / 10;
  kfps = kfit - 10 * kfys;
  if (kfys == 0 && kypr == 0) {
    goto statement_230;
  }
  n1 = nfrph + nfrph + 1;
  FEM_DOSTEP(i, 1, nph2, 2) {
    vresp(n1) = yo(i) - vresp(n1 + 1);
    n1 += nfr1;
  }
  //C     CALCULATE FREQUENCY DOMAIN SEQUENCE USED TO PRODUCE THE CHAR-     M20.5236
  //C     ACTERISTIC ADMITTANCE STEP REPONSE IN THE TIME DOMAIN             M20.5237
  FEM_DO_SAFE(jm, 2, nfr1) {
    w = si(jm);
    sif = cmn.onehaf * twopi * w / wm;
    sif = sinz(sif) / sif / w;
    n1 = nfrph + nfrph + jm;
    FEM_DOSTEP(i, 1, nph2, 2) {
      vresp(n1) = sif * (yo(i) - vresp(n1));
      n1 += nfr1;
    }
  }
  statement_230:
  d1 = fltinf;
  n1 = 1;
  FEM_DO_SAFE(i, 1, nph) {
    if (d1 < um(n1)) {
      goto statement_344;
    }
    d1 = um(n1);
    kmin = i;
    statement_344:
    n1 += 2;
  }
  if (kyc == 1 || kyc == 3) {
    kmin = nph + nph;
  }
  iy = 2;
  iy3 = 3 * iy;
  if (iprsup <= 5) {
    goto statement_640;
  }
  write(lunit6,
    "('0',5x,"
    "'DATA FOR FITTING OF CHARACTERISTIC ADMITTANCE EXPONENTIAL APPROXIMATION."
    " ',/,10x,'FREQUENCY',17x,'... CMPLX. CHAR. ADMITTANCE ...')");
  FEM_DO_SAFE(i, 1, nph) {
    n1 = (i - 1) * nph2 + 1;
    n2 = n1 - 1 + nph2;
    d1 = ww(i) / twopi;
    {
      write_loop wloop(cmn, lunit6, "(/,1x,7(5x,e12.5),/(18x,6(5x,e12.5)))");
      wloop, d1;
      FEM_DO_SAFE(j, n1, n2) {
        wloop, um(j);
      }
    }
  }
  statement_640:
  write(lunit6, format_10654);
  if (ipunm == 2) {
    goto statement_437;
  }
  //C     LOOP OVER ALL MODES TO CALCULATE(VIA INVERSE FOURIER              M16.4969
  //C     TRANSFORMATION)   AND FIT(VIA LEAST SQUARES) THE PROPAGATION STEP M16.4970
  //C     RESPONSE IN THE TIME DOMAIN.                                      M16.4971
  w = twopi * voltk(icheck);
  FEM_DO_SAFE(i1, 1, nph) {
    lstat(14) = i1;
    write(lunit6,
      "('1',10x,'FITTING OF THE PROPAGATION STEP RESPONSE FOR MODE ',i2,/,/,/,"
      "1x)"),
      i1;
    ix = (i1 - 1) * nfr1 + 1;
    i2 = i1 + i1;
    i3 = 14 * i1;
    i4 = nfrph + nfrph + ix;
    tretrd = sll * g(i2) / wm;
    tt = ymin(i2) - tretrd;
    ffin = ffinp;
    tstrt = tretrd * 0.98f;
    tstep = tt / noo;
    flstat(11) = tstep;
    vresp(lift) = vresp(ix);
    FEM_DO_SAFE(j, 1, nfr) {
      n1 = ix + j;
      n2 = n1 + nfrph;
      n3 = lift + j;
      sif = tstrt * si(j + 1);
      vresp(n3) = vresp(n1) * cosz(sif) + vresp(n2) * sinz(sif);
      if (iprsup >= 6) {
        write(lunit6, "(5x,i10,4(5x,e15.7))"), j, sif, vresp(n1),
          vresp(n2), vresp(n3);
      }
    }
    ictrl = kps;
    if (kfps == 0) {
      goto statement_40040;
    }
    i5 = lift;
    d1 = 0.02f * tretrd;
    d2 = d1;
    d3 = 1.f / 3.f;
    d4 = 2.f / 3.f;
    rise(cmn, d2, d4, tstep, vresp(i5), si, zcos(lcosd));
    if (kill <= 0) {
      goto statement_40026;
    }
    lstat(10) = npoint;
    lstat(13) = kfps;
    lstat(15) = kfit;
    lstat(19) = 40026;
    flstat(16) = d4;
    goto statement_9200;
    statement_40026:
    d1 = d2;
    tstep = 4.f * d2 / npoint;
    if (kfps == 1) {
      goto statement_40040;
    }
    tstep = d2 / 10.f;
    flstat(11) = tstep;
    rise(cmn, d1, d3, tstep, vresp(i5), si, zcos(lcosd));
    if (kill <= 0) {
      goto statement_40027;
    }
    lstat(10) = npoint;
    lstat(13) = kfps;
    lstat(14) = i1;
    lstat(19) = 40027;
    flstat(16) = d3;
    goto statement_9200;
    statement_40027:
    tstep = 20.f * (d2 - d1) / npoint;
    statement_40040:
    i5 = lift;
    shifti = expz(-g60(i2 - 1) * sll);
    d1 = g60(i2) * sll;
    shiftr = shifti * cosz(d1);
    shifti = shifti * sinz(d1);
    tdfit(cmn, vresp(i5), si, fv, hhm, hhn, zcos(lcosd));
    if (kill > 0) {
      goto statement_9200;
    }
    pbuf(i3 - 4) = d;
    pbuf(i3 - 3) = x(1);
    pbuf(i3 - 0) = x(3);
    pbuf(i3 - 2) = ffin - d;
    pbuf(i3 - 1) = x(2);
    //C     TIME DOMAIN FITTING OF THE CHARACTERISTIC ADMITTANCE STEP         M20.5325
    //C     RESPONSE FUNCTION                                                 M20.5326
    tstrt = 0.0f;
    ffin = yo(i2 - 1) - ymin(i2 - 1);
    if (kfys == 1) {
      goto statement_40070;
    }
    //C     FITTING OF CHARACTERISTIC ADMITTANCE STEP IN THE FREQUENCY        M20.5329
    //C     DOMAIN.   TWO POINTS ARE USED TO FIT THE TRANSFORM OF             M20.5330
    //C      YC(I) = Y0 + E(1)*EXP(-T/B(1))  +  E(2)*EXP(-T/B(2))             M20.5331
    //C     ITERATIVELY.                                                      M20.5332
    if (kyc == 0) {
      goto statement_401;
    }
    if (kmin == i1) {
      goto statement_401;
    }
    pbuf(i3 - 9) = 0.0f;
    pbuf(i3 - 8) = 1.0f;
    pbuf(i3 - 7) = 0.0f;
    pbuf(i3 - 6) = 1.0f;
    pbuf(i3 - 5) = um(i2 - 1);
    write(lunit6,
      "(/,5x,'MODE ',i2,'CONSTANT CHARACTERISTIC ADMITTANCE = ',e12.5)"),
      i1, pbuf(i3 - 5);
    goto statement_40090;
    statement_401:
    n1 = i1 + i1;
    n2 = n1 + nph2 + nph2;
    ygr(1) = um(n2 - 1) - um(n1 - 1);
    ygr(2) = um(n2) - um(n1);
    ygr(3) = ww(1);
    n1 += nph2;
    ygr(4) = um(n2 - 1) - um(n1 - 1);
    ygr(5) = um(n2) - um(n1);
    ygr(6) = ww(2);
    ysurg = ymin(i2 - 1);
    setplt();
    write(lunit6,
      "(/,/,/,/,5x,'FITTING FOR CHARACTERISTIC ADMITTANCE MODE NO ',i2)"),
      i1;
    if (iprsup > 0) {
      {
        write_loop wloop(cmn, lunit6,
          "(/,5x,'KMIN, N1, N2, KYC, YGR(J), J=1, 6) FOLLOW .....    ',/,4i10,"
          "6e15.8)");
        wloop, kmin, n1, n2, kyc;
        FEM_DO_SAFE(j, 1, 6) {
          wloop, ygr(j);
        }
      }
    }
    FEM_DO_SAFE(j, 1, iy) {
      e(j) = 0.0f;
      b(j) = 0.0f;
      e(j + 2) = 1.0f;
      b(j + 2) = 1.0f;
    }
    iter = 0;
    statement_406:
    iter++;
    n1 = 1;
    FEM_DOSTEP(j, 1, iy3, 3) {
      zr = ygr(j);
      zi = ygr(j + 1);
      n2 = 1;
      FEM_DOSTEP(k, 1, iy3, 3) {
        if (j == k) {
          goto statement_407;
        }
        d1 = ygr(j + 2) * b(n2);
        d2 = 1.0f + d1 * d1;
        zr += e(n2) / d2;
        zi = zi - e(n2) * d1 / d2;
        statement_407:
        n2++;
      }
      b(n1) = -zi / (ygr(j + 2) * zr);
      e(n1) = -(zr * zr + zi * zi) / zr;
      n1++;
    }
    FEM_DO_SAFE(j, 1, iy) {
      if (std::abs((e(j) - e(j + 2)) / e(j + 2)) > epsyc) {
        goto statement_412;
      }
      if (std::abs((b(j) - b(j + 2)) / b(j + 2)) > epsyc) {
        goto statement_412;
      }
    }
    FEM_DOSTEP(j, 1, iy3, 3) {
      y(j) = ygr(j);
      y(j + 1) = ygr(j + 1);
      FEM_DO_SAFE(k, 1, iy) {
        d1 = ygr(j + 2) * b(k);
        d2 = 1.0f + d1 * d1;
        y(j) += e(k) / d2;
        y(j + 1) = y(j + 1) - e(k) * d1 / d2;
      }
      zr = y(j) * y(j) + y(j + 1) * y(j + 1);
      if (sqrtz(zr) > epsn) {
        goto statement_412;
      }
    }
    goto statement_415;
    statement_412:
    FEM_DO_SAFE(j, 1, iy) {
      b(j + 2) = b(j);
      e(j + 2) = e(j);
    }
    if (iprsup > 5) {
      {
        write_loop wloop(cmn, lunit6,
          "(/,' ADMITTANCE FITTING.',5x,i5,6(5x,e12.5))");
        wloop, iter;
        FEM_DO_SAFE(j, 1, iy) {
          wloop, e(j), b(j);
        }
      }
    }
    if (iter < nitery) {
      goto statement_406;
    }
    kill = 155;
    lstat(13) = nitery;
    flstat(13) = epsyc;
    flstat(14) = epsn;
    lstat(19) = 415;
    goto statement_9200;
    statement_415:
    write(lunit6, "(/,5x,'NO. OF ITERATIONS = ',i3,/,/)"), iter;
    FEM_DOSTEP(j, 1, iy3, 3) {
      d1 = ygr(j + 2) / twopi;
      if (ysurg == 0.f) {
        d1 = -1.0f / (twopi * ygr(j + 2));
      }
      write(lunit6,
        "(2x,'FREQUENCY = ',e12.5,5x,'IMPULSE = ',e12.5,2x,e12.5,5x,"
        "'ERROR = ',e12.5,2x,e12.5)"),
        d1, ygr(j), ygr(j + 1), y(j), y(j + 1);
    }
    n1 = i3 - 9;
    pbuf(i3 - 5) = ysurg;
    FEM_DO_SAFE(j, 1, iy) {
      if (ysurg != 0.f) {
        goto statement_4183;
      }
      b(j) = 1.0f / b(j);
      //C     GO TO 4187                                                        M27.3824
      statement_4183:
      e(j) = -e(j);
      pbuf(i3 - 5) += e(j);
      pbuf(n1) = e(j);
      pbuf(n1 + 1) = b(j);
      if (b(j) <= 0.0f) {
        pbuf(n1) = 0.0f;
      }
      n1 += 2;
    }
    {
      write_loop wloop(cmn, lunit6, "(5x,'AMPLITUDES = ',3(e12.5,5x))");
      FEM_DO_SAFE(j, 1, iy) {
        wloop, e(j);
      }
    }
    {
      write_loop wloop(cmn, lunit6, "(5x,'TIME CONST = ',3(e12.5,5x))");
      FEM_DO_SAFE(j, 1, iy) {
        wloop, b(j);
      }
    }
    write(lunit6, format_422), pbuf(i3 - 5);
    statement_40090:
    if (kypr == 0 && kfys == 0) {
      goto statement_40200;
    }
    if (kypr == 1 && kfys == 0) {
      ffin = pbuf(i3 - 9) + pbuf(i3 - 7);
    }
    d = pbuf(i3 - 9);
    x(1) = pbuf(i3 - 8);
    x(2) = pbuf(i3 - 6);
    x(3) = 0.0f;
    ictrl = -10;
    tstep = pbuf(i3 - 8);
    tt = tstep;
    if (tstep < pbuf(i3 - 6)) {
      tstep = pbuf(i3 - 6);
    }
    if (tt > pbuf(i3 - 6)) {
      tt = pbuf(i3 - 6);
    }
    tt = tt * 2.f;
    tstep = tstep / 10.f;
    if (tt > tstep) {
      tt = tstep;
    }
    tstep = tt / npoint;
    if (kfys <= 0) {
      goto statement_40030;
    }
    statement_40070:
    write(lunit6,
      "('1',10x,"
      "'TIME DOMAIN FITTING OF CHARACTERISTIC ADMITTANCE STEP RESPONSE FOR NOD"
      "E ',i2)"),
      i1;
    ictrl = -kyc - 1;
    pbuf(i3 - 5) = yo(i2 - 1);
    shiftr = yo(i2 - 1) - um(i2 - 1);
    shifti = yo(i2) - um(i2);
    if (kfys > 1) {
      goto statement_40030;
    }
    tt = .005f;
    tstep = tt / 200.f;
    d1 = tstep;
    targ = 0.5f;
    flstat(11) = tstep;
    if (iprsup > 3) {
      write(lunit6,
        "(5x,'AT ENTRY TO RISE, INITIAL TIME, TARGET, TIMESTEP,  FINAL VALUE, "
        "TT, AND INITIAL VALUE ARE',/,25x,6e12.5)"),
        d1, targ, tstep, ffin, tt, yo(i2 - 1);
    }
    rise(cmn, d1, targ, tstep, vresp(i4), si, zcos(lcosd));
    if (kill <= 0) {
      goto statement_40081;
    }
    lstat(10) = npoint;
    lstat(13) = kfys;
    lstat(15) = kfit;
    lstat(19) = 40080;
    flstat(13) = tt * 2;
    flstat(16) = targ;
    goto statement_9200;
    statement_40081:
    tstep = d1 / npoint * 2.f;
    tt = npoint * tstep;
    write(lunit6, format_422), pbuf(i3 - 5);
    statement_40030:
    tdfit(cmn, vresp(i4), si, fv, hhm, hhn, zcos(lcosd));
    if (kill > 0) {
      goto statement_9200;
    }
    tt = sll / spdlt;
    pbuf(i3 - 9) = d;
    pbuf(i3 - 8) = x(1);
    pbuf(i3 - 7) = ffin - d;
    pbuf(i3 - 6) = x(2);
    statement_40200:;
  }
  w = twopi * voltk(icheck);
  w2 = w * w;
  write(lunit6,
    "(/,/,15x,f5.1,'HZ STEADY STATE MODAL PARAMETERS IN OHMS AND MICROMHOS',/,"
    "15x,'AS CALCULATED FROM FITTED EXPONENTIALS VIA FOURIER TRANSFORM',/,/,"
    "25x,'MODE     R           X           G           B')"),
    w;
  FEM_DO_SAFE(i1, 1, nph) {
    i3 = 14 * i1;
    i2 = i3 - 13;
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6,
          "(' PBUF FOR MODE',i3,'  I2=',i3,'  I3=',i3,/(1x,8e16.8))");
        wloop, i1, i2, i3;
        FEM_DO_SAFE(i, i2, i3) {
          wloop, pbuf(i);
        }
      }
    }
    den1 = 1.0f / pbuf(i3 - 3);
    den1 = den1 * den1 + w2;
    den2 = 1.0f / pbuf(i3 - 1);
    den2 = den2 * den2 + w2;
    hssr = 1.0f - pbuf(i3 - 4) * w2 / den1 - pbuf(i3 - 2) * w2 / den2;
    hssi = -pbuf(i3 - 4) / pbuf(i3 - 3) * w / den1 - pbuf(i3 - 2) /
      pbuf(i3 - 1) * w / den2;
    den1 = 1.0f / pbuf(i3 - 8);
    den1 = den1 * den1 + w2;
    den2 = 1.0f / pbuf(i3 - 6);
    den2 = den2 * den2 + w2;
    yssr = pbuf(i3 - 5) - (pbuf(i3 - 9) + pbuf(i3 - 7)) + pbuf(i3 -
      9) * w2 / den1 + pbuf(i3 - 7) * w2 / den2;
    yssi = pbuf(i3 - 9) / pbuf(i3 - 8) * w / den1 + pbuf(i3 - 7) /
      pbuf(i3 - 6) * w / den2;
    hamp = fem::pow((hssr * hssr + hssi * hssi), .5f);
    datn2z(hssi, hssr, dd11);
    hang = w * pbuf(i3) - dd11;
    //dlogz(hamp, dd11);
    dd11 = std::log(hamp);
    alnh = -dd11;
    pbuf(i3 - 11) = alnh * yssr - hang * yssi;
    pbuf(i3 - 10) = alnh * yssi + hang * yssr;
    den1 = yssr * yssr + yssi * yssi;
    pbuf(i3 - 13) = (alnh * yssr + hang * yssi) / den1;
    pbuf(i3 - 12) = (hang * yssr - alnh * yssi) / den1;
    pbuf(i3 - 10) = pbuf(i3 - 10) / tenm6;
    pbuf(i3 - 11) = pbuf(i3 - 11) / tenm6;
    i4 = i3 - 10;
    if (iprsup >= 3) {
      {
        write_loop wloop(cmn, lunit6,
          "(' DURING CALCULATION OF STEADY STATE PARAMETERS FOR MODE',i3,"
          "'  HSSR, HSSI, YSSR, YSSI, HAMP, HANG, PBUF(I),I=',i3,',',i3,/,1x,"
          "10e13.4)");
        wloop, i1, i2, i4, hssr, hssi, yssr, yssi, hamp, hang;
        FEM_DO_SAFE(i, i2, i4) {
          wloop, pbuf(i);
        }
      }
    }
    {
      write_loop wloop(cmn, lunit6, "(26x,i2,4e12.5)");
      wloop, i1;
      FEM_DO_SAFE(i, i2, i4) {
        wloop, pbuf(i);
      }
    }
  }
  //C     DOCUMENTATION OF OUTPUT CARDS TO BE PUNCHED.                      M16.5489
  if (ipun != 1) {
    write(lunit6,
      "(/,/,27x,'SEQUENTIAL LIST OF PUNCHED OUTPUT.',/,27x,34('-'),/,/,4x,"
      "'0         1         2         3         4         5         6         "
      "7         8',/,9(4x,'0',5x),/,4x,81('-'),/,1x)");
  }
  nss = fem::iabs(nss);
  indtv(2) = nss;
  kfit = fem::iabs(kfit);
  indtv(3) = kfit;
  kps = fem::iabs(kps);
  indtv(4) = kps;
  kyc = fem::iabs(kyc) + fem::iabs(kypr) * 10;
  indtv(5) = kyc;
  f = voltk(icheck);
  if (kreqab == 1) {
    goto statement_704;
  }
  if (ipun != 1) {
    write(lunit6,
      "(5x,'C L=',f8.1,'MILES, RHO=',f8.1,', SS FREQ=',f8.2,', NSS=',i1,"
      "', KFIT=',i2,', KPS=',i1,', KYC=',i2)"),
      sll, ci1, f, nss, kfit, kps, kyc;
  }
  if (ipun != 2) {
    write(lunit7,
      "('C L=',f8.1,'MILES, RHO=',f8.1,', SS FREQ=',f8.2,', NSS=',i1,"
      "', KFIT=',i2,', KPS=',i1,', KYC=',i2)"),
      sll, ci1, f, nss, kfit, kps, kyc;
  }
  goto statement_452;
  statement_704:
  if (ipun != 1) {
    write(lunit6,
      "(5x,'C L=',f8.0,'METERS, RHO=',f8.1,', SS FREQ=',f8.2,', NSS=',i1,"
      "', KFIT=',i2,', KPS=',i1,', KYC=',i2)"),
      sll, ci1, f, nss, kfit, kps, kyc;
  }
  if (ipun != 2) {
    write(lunit7,
      "('C L=',f8.0,'METERS, RHO=',f8.1,', SS FREQ=',f8.2,', NSS=',i1,"
      "', KFIT=',i2,', KPS=',i1,', KYC=',i2)"),
      sll, ci1, f, nss, kfit, kps, kyc;
  }
  statement_452:
  if (idoc == 0) {
    goto statement_428;
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.5478
  cmn.io.rewind(lunit2);
  FEM_DO_SAFE(j, 1, lcin) {
    {
      read_loop rloop(cmn, lunit2, "(13a6,a2)");
      FEM_DO_SAFE(i, 1, 14) {
        rloop, pl(i);
      }
    }
    if (ipun != 1) {
      {
        write_loop wloop(cmn, lunit6, "(5x,'C ',14a6)");
        FEM_DO_SAFE(i, 1, 14) {
          wloop, pl(i);
        }
      }
    }
    if (ipun != 2) {
      {
        write_loop wloop(cmn, lunit7, "('C ',13a6)");
        FEM_DO_SAFE(i, 1, 13) {
          wloop, pl(i);
        }
      }
    }
  }
  statement_428:
  d1 = 0.0f;
  //C     PUNCH MODAL DATA                                                  M16.5524
  FEM_DO_SAFE(i, 1, nph) {
    kmax1 = 14 * i;
    kmin1 = kmax1 - 4;
    kmax2 = kmax1 - 6;
    kmin2 = kmax1 - 9;
    kmin = kmax1 - 13;
    kmax = kmax1 - 10;
    pbuf(kmin + 2) = pbuf(kmin + 2) * tenm6;
    pbuf(kmin + 3) = pbuf(kmin + 3) * tenm6;
    pbuf(kmin1 + 1) = 1.0f / pbuf(kmin1 + 1);
    pbuf(kmin1 + 3) = 1.0f / pbuf(kmin1 + 3);
    pbuf(kmin2 + 0) = -pbuf(kmin2 + 0);
    pbuf(kmin2 + 1) = 1.0f / pbuf(kmin2 + 1);
    pbuf(kmin2 + 2) = -pbuf(kmin2 + 2);
    pbuf(kmin2 + 3) = 1.0f / pbuf(kmin2 + 3);
    if (ipun != 1) {
      {
        write_loop wloop(cmn, lunit6,
          "(5x,'-1',2a6,12x,2e12.5,12x,2i3,'  2  2  ',i2,/,7x,5e15.8,/(7x,"
          "6e12.5))");
        wloop, vstacs(2 * i - 1), vstacs(2 * i), pbuf(kmax2 + 1),
          pbuf(kmin1 + 4), i, i, nph;
        FEM_DO_SAFE(k, kmin, kmax) {
          wloop, pbuf(k);
        }
        wloop, voltk(icheck), d1, pbuf(kmin1 + 1), pbuf(kmin1 + 0),
          d1, pbuf(kmin1 + 3), pbuf(kmin1 + 2), d1, pbuf(kmin2 + 1),
          pbuf(kmin2 + 0), d1, pbuf(kmin2 + 3), pbuf(kmin2 + 2);
      }
    }
    if (ipun != 2) {
      {
        write_loop wloop(cmn, lunit7,
          "('-1',2a6,12x,2e12.5,12x,2i3,'  2  2  ',i2,/,2x,5e15.8,/(2x,"
          "6e12.5))");
        wloop, vstacs(2 * i - 1), vstacs(2 * i), pbuf(kmax2 + 1),
          pbuf(kmin1 + 4), i, i, nph;
        FEM_DO_SAFE(k, kmin, kmax) {
          wloop, pbuf(k);
        }
        wloop, voltk(icheck), d1, pbuf(kmin1 + 1), pbuf(kmin1 + 0),
          d1, pbuf(kmin1 + 3), pbuf(kmin1 + 2), d1, pbuf(kmin2 + 1),
          pbuf(kmin2 + 0), d1, pbuf(kmin2 + 3), pbuf(kmin2 + 2);
      }
    }
  }
  //C     PUNCH MODE TO PHASE VOLTAGE & CURRENT TRANSFORMATION MATRICES.    M27.3825
  FEM_DO_SAFE(i, 1, nph) {
    if (ipun != 1) {
      {
        write_loop wloop(cmn, lunit6, format_443);
        FEM_DOSTEP(k, i, nphsq, nph) {
          wloop, q(k), d1;
        }
      }
    }
    if (ipun != 2) {
      {
        write_loop wloop(cmn, lunit7, format_444);
        FEM_DOSTEP(k, i, nphsq, nph) {
          wloop, q(k), d1;
        }
      }
    }
  }
  FEM_DO_SAFE(i, 1, nph) {
    if (ipun != 1) {
      {
        write_loop wloop(cmn, lunit6, format_443);
        FEM_DOSTEP(k, i, nphsq, nph) {
          wloop, qi(k), d1;
        }
      }
    }
    if (ipun != 2) {
      {
        write_loop wloop(cmn, lunit7, format_444);
        FEM_DOSTEP(k, i, nphsq, nph) {
          wloop, qi(k), d1;
        }
      }
    }
  }
  statement_437:
  write(lunit6, format_10654);
  //C     READ INPUT CARD USING CIMAGE                                      M16.5567
  cimage(cmn);
  {
    read_loop rloop(abuff(1), format_10290);
    FEM_DO_SAFE(i, 1, 14) {
      rloop, vstacs(i);
    }
  }
  FEM_DO_SAFE(i, 1, 14) {
    if (vstacs(i) != blank) {
      goto statement_516;
    }
  }
  write(kunit6, "('+BLANK CARD TERMINATING   ''SEMLYEN SETUP'' .')");
  interp();
  nchain = 51;
  ialter = 0;
  goto statement_9900;
  statement_516:
  FEM_DO_SAFE(i, 1, 14) {
    vstacs(i) = blank;
  }
  m = 1;
  goto statement_10015;
  statement_9200:
  nchain = 51;
  lstat(18) = 45;
  if (iprsup >= 1) {
    write(lunit6, "('0 OVER45 EXIT WITH KILL CODE = ',i5,5x,2i10)"),
      kill, lstat(19), lstat(10);
  }
  statement_9900:
  lastov = 45;
  statement_9999:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
subr45(
  common& cmn) try
{
  fem::str<8>& trash = cmn.trash;
  const auto& voltbc = cmn.voltbc;
  const auto& indtv = cmn.indtv;
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  int& lastov = cmn.lastov;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& nph = cmn.nph;
  int& nph2 = cmn.nph2;
  int& n22 = cmn.n22;
  int& nphsq = cmn.nphsq;
  int& ntri = cmn.ntri;
  int& nfr = cmn.nfr;
  int& nfr1 = cmn.nfr1;
  //
  int npoint = fem::int0;
  double d13 = fem::double0;
  int n8 = fem::int0;
  arr_1d<20, int> lltemp(fem::fill0);
  int i = fem::int0;
  int lsem = fem::int0;
  int lx = fem::int0;
  int lpbuf = fem::int0;
  int lcq = fem::int0;
  int lz = fem::int0;
  int ly = fem::int0;
  int lzy = fem::int0;
  int lzya = fem::int0;
  int lzyb = fem::int0;
  int lzyc = fem::int0;
  int lzyd = fem::int0;
  int lcqt = fem::int0;
  int lq = fem::int0;
  int lqi = fem::int0;
  int lg = fem::int0;
  int lg60 = fem::int0;
  int lyo = fem::int0;
  int lxr = fem::int0;
  int lxl = fem::int0;
  int lxg = fem::int0;
  int lxc = fem::int0;
  int lum = fem::int0;
  int lsi = fem::int0;
  int lvresp = fem::int0;
  int lzift = fem::int0;
  arr_1d<11, double> stg(fem::fill0);
  arr_1d<11, double> zift(fem::fill0);
  int lym = fem::int0;
  int lfv = fem::int0;
  int lhhm = fem::int0;
  int lhhn = fem::int0;
  //C     CODE CONNECTED TO  'SEMLYEN SETUP'  SPECIAL REQUEST CARD.         M15.1668
  //C)  THIS OVERLAY IS USED TO CALCULATE                                   M16.4556
  //C)     1)  PROPAGATION STEP RESPONSE AS APPROXIMATED BY AN ANALYTIC     M16.4557
  //C)         (TWO EXPONEBTIALS AND A CONSTANT) FUNCTION.                  M16.4558
  //C)     2)  ADMITTANCE STEP RESPONSE AS APPROXIMATED BY AN ANALYTIC      M16.4559
  //C)         (TWO EXPONENTIALS AND A CONSTANT) FUNCTION.                  M16.4560
  //C)     3)  STEADY STATE MODAL DISTRIBUTED IMPEDANCE AND ADMITTANCE OF   M16.4561
  //C)         THE LINE.                                                    M16.4562
  //C)     4)  PHASE TO MODE TRANSFORMATION MATRICES.                       M16.4563
  //C)  THIS ROUTINE PUNCHES THE BRANCH CARDS TO BE READ IN AS DATA WHEN    M16.4564
  //C)  USING THE 'SEMLYEN RECURSIVE CONVOLUTION' FREQUENCY DEPENDENT LINE. M16.4565
  //C!w EQUIVALENCE( ZIFT(1), KARRAY(1) )
  //C!w EQUIVALENCE ( STG(1), KARRAY(1) )
  //C!EQUIVALENCE (INDTV(1),NPOINT)
  npoint = indtv(1);
  if (lastov == 1) {
    goto statement_20;
  }
  nph = cmn.ktab;
  ntri = nph * (nph + 1) / 2;
  nphsq = nph * nph;
  nph2 = nph + nph;
  cmn.nphpi2 = nph2 + 2;
  n22 = nphsq + nphsq;
  d13 = voltbc(2) / voltbc(1);
  nfr = alogz(d13) / alogz(voltbc(3)) + 1.5f;
  nfr1 = nfr + 1;
  n8 = nchain;
  if (cmn.kburro == 1) {
    n8 = 29;
  }
  dimens(lltemp(1), n8, trash, trash);
  FEM_DOSTEP(i, 1, 9999, 2) {
    if (lltemp(i) != 0) {
      goto statement_5654;
    }
    lsem = lltemp(i + 1) * nbyte(4) / nbyte(3);
    goto statement_5655;
    statement_5654:;
  }
  stoptp(cmn);
  statement_5655:
  lx = nph * (22 * nph + 3 * nfr1 + 30) + 4 * nfr1 + 3 * npoint + 3;
  if (nph <= 50 && lx < lsem) {
    goto statement_10;
  }
  kill = 198;
  lstat(15) = lsem;
  lstat(16) = lx;
  lstat(19) = 10;
  lstat(18) = 45;
  lastov = nchain;
  nchain = 51;
  goto statement_9999;
  statement_10:
  lpbuf = 1;
  lcq = lpbuf + 14 * nph;
  lz = lcq + n22;
  ly = lz + n22;
  lzy = ly + n22;
  lzya = lzy + n22;
  lzyb = lzya + n22;
  lzyc = lzyb + n22;
  lzyd = lzyc + n22;
  lcqt = lzyd + n22;
  lq = lcqt + n22;
  lqi = lq + nphsq;
  lg = lqi + nphsq;
  lg60 = lg + nph2;
  lyo = lg60 + nph2;
  lxr = lyo + nph2;
  lxl = lxr + ntri;
  lxg = lxl + ntri;
  lxc = lxg + ntri;
  lum = lxc + ntri;
  lsi = lum + 3 * nph2;
  lvresp = lsi + nfr1 + 1;
  lzift = lvresp / 2 + 1;
  if (locint(stg(11)) - locint(stg(1)) == locint(zift(11)) - locint(zift(1))) {
    lzift = lvresp;
  }
  lym = lvresp + (3 * nph + 3) * nfr1 + 2;
  lfv = lym + nph2;
  lhhm = lfv + npoint;
  lhhn = lhhm + npoint;
  statement_20:
  guts45(cmn, stg(lpbuf), stg(lcq), stg(lz), stg(ly), stg(lzy), stg(lzya),
    stg(lzyb), stg(lzyc), stg(lzyd), stg(lcqt), stg(lq), stg(lqi), stg(lg),
    stg(lg60), stg(lyo), stg(lxr), stg(lxl), stg(lxg), stg(lxc), stg(lum),
    stg(lsi), stg(lvresp), stg(lym), stg(lfv), stg(lhhm), stg(lhhn), zift(
    lzift));
  if (kill > 0) {
    goto statement_9999;
  }
  if (cmn.ialter != 3) {
    goto statement_9999;
  }
  //C     SEGMENTED, 1, VAX E/T CAN SKIP TRANSLATION OF REWIND:             M29.5412
  cmn.io.rewind(cmn.lunit3);
  goto statement_5655;
  statement_9999:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
over45(
  common& cmn)
{
  //C!include 'DECK29.inc'
  subr45(cmn);
}

std::complex<double>
cmplxz(
  double const& x,
  double const& y)
{
  return std::complex<double>(x, y);
}

void
cha645(
  int const& k,
  int& k1) try
{
  int kk = fem::int0;
  if (k <= 3 || k >= 7) {
    return;
  }
  kk = k - 3;
  switch (kk) {
    case 1: goto statement_10;
    case 2: goto statement_20;
    case 3: goto statement_30;
    default: break;
  }
  statement_10:
  k1 = 6;
  return;
  statement_20:
  k1 = 4;
  return;
  statement_30:
  k1 = 5;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
cha312(
  int const& j,
  int& j1) try
{
  switch (j) {
    case 1: goto statement_10;
    case 2: goto statement_20;
    case 3: goto statement_30;
    default: break;
  }
  statement_10:
  j1 = 3;
  return;
  statement_20:
  j1 = 1;
  return;
  statement_30:
  j1 = 2;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
cha444(
  int const& k,
  int& kk) try
{
  if (k <= 3 || k > 7) {
    return;
  }
  kk = 4;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
pri(
  common& cmn,
  int const& i,
  int const& j,
  int const& k,
  int const& i1,
  int const& j1,
  int const& k1,
  int const& k2,
  int& L,
  int const& ipri,
  str_cref cha,
  arr_cref<double> r,
  arr_cref<double> al,
  arr_cref<double> c,
  int const& npk) try
{
  r(dimension(npk));
  al(dimension(npk));
  c(dimension(npk));
  common_write write(cmn);
  auto& lunit6 = cmn.lunit6;
  auto& lunit7 = cmn.lunit7;
  int ll = fem::int0;
  switch (ipri) {
    case 1: goto statement_10;
    case 2: goto statement_20;
    case 3: goto statement_30;
    case 4: goto statement_40;
    default: break;
  }
  statement_10:
  if (k != 1) {
    goto statement_15;
  }
  write(lunit6,
    "(' ',i2,a1,i2,i1,i2,a1,i2,i1,i2,a1,'IN  1',a1,' 11 1')"), k,
    cha, i1, j1, k1, cha, i, j, k2, cha, cha;
  write(lunit7,
    "(i2,a1,i2,i1,i2,a1,i2,i1,i2,a1,'IN  1',a1,' 11 1')"), k, cha,
    i1, j1, k1, cha, i, j, k2, cha, cha;
  return;
  statement_15:
  write(lunit6, "(' ',i2,a1,i2,i1,i2,a1,i2,i1,i2)"), k, cha, i1, j1,
    k1, cha, i, j, k2;
  write(lunit7, "(i2,a1,i2,i1,i2,a1,i2,i1,i2)"), k, cha, i1, j1, k1,
    cha, i, j, k2;
  return;
  statement_20:
  L++;
  write(lunit6, "(' ',i2,a1,'IN ',i2,a1,i2,i1,i2,12x,3e16.5)"), k,
    cha, k1, cha, i, j, k2, r(L), al(L), c(L);
  write(lunit7, "(i2,a1,'IN ',i2,a1,i2,i1,i2,12x,3e16.5)"), k, cha,
    k1, cha, i, j, k2, r(L), al(L), c(L);
  statement_2000:
  if (k == 1) {
    return;
  }
  FEM_DO_SAFE(ll, 2, k) {
    L++;
    write(lunit6, "(' ',26x,3e16.5)"), r(L), al(L), c(L);
    write(lunit7, "(26x,3e16.5)"), r(L), al(L), c(L);
  }
  return;
  statement_30:
  if (k != 1) {
    goto statement_35;
  }
  write(lunit6,
    "(' ',i2,a1,i2,i1,i2,a1,'OUT',i2,a1,'IN  1',a1,' 11 1')"), k,
    cha, i1, j1, k1, cha, k2, cha, cha;
  write(lunit7,
    "(i2,a1,i2,i1,i2,a1,'OUT',i2,a1,'IN  1',a1,' 11 1')"), k, cha,
    i1, j1, k1, cha, k2, cha, cha;
  return;
  statement_35:
  write(lunit6, "(' ',i2,a1,i2,i1,i2,a1,'OUT',i2)"), k, cha, i1, j1,
    k1, cha, k2;
  write(lunit7, "(i2,a1,i2,i1,i2,a1,'OUT',i2)"), k, cha, i1, j1, k1, cha, k2;
  return;
  statement_40:
  L++;
  write(lunit6, "(' ',i2,a1,'IN ',i2,a1,'OUT',i2,12x,3e16.5)"), k,
    cha, k1, cha, k2, r(L), al(L), c(L);
  write(lunit7, "(i2,a1,'IN ',i2,a1,'OUT',i2,12x,3e16.5)"), k, cha,
    k1, cha, k2, r(L), al(L), c(L);
  goto statement_2000;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
datout(
  common& cmn,
  double const& w,
  arr_cref<std::complex<double>, 2> zc,
  arr_cref<std::complex<double>, 2> yc,
  double const& rs,
  double const& xmajor,
  int const& nub6,
  int const& npais,
  int const& nncros,
  int const& irsep,
  str_cref cha,
  int const& ldn,
  arr_ref<double> r,
  arr_ref<double> al,
  arr_ref<double> c,
  int const& npk) try
{
  zc(dimension(ldn, ldn));
  yc(dimension(ldn, ldn));
  r(dimension(npk));
  al(dimension(npk));
  c(dimension(npk));
  common_write write(cmn);
  const auto& lunit6 = cmn.lunit6;
  const auto& lunit7 = cmn.lunit7;
  int ncros = fem::int0;
  int ltype = fem::int0;
  int ntype = fem::int0;
  int mtype = fem::int0;
  int nub3 = fem::int0;
  int L = fem::int0;
  double xleng = fem::double0;
  int i = fem::int0;
  int j = fem::int0;
  int kstep = fem::int0;
  int kk = fem::int0;
  int kstop = fem::int0;
  int k = fem::int0;
  int k2 = fem::int0;
  int k1 = fem::int0;
  int j1 = fem::int0;
  int i1 = fem::int0;
  int ipri = fem::int0;
  //C 8.19 DATA CARDS PUNCH OUT SUBROUTINE                                  M31.7034
  //C     LTYPE=0 ; OUTPUT RS                                               M31.7039
  //C     LTYPE=1 ; NOT OUTPUT RS                                           M31.7040
  //C     NTYPE=0 ; CROSSBONDED CABLE                                       M31.7041
  //C     NTYPE=1 ; NON-CROSSBONDED CABLE                                   M31.7042
  //C     MTYPE=0 ; ALL SHEATHES ARE CONECTED                               M31.7043
  //C     MTYPE=1 ; ALL SHEATHES ARE NOT CONECTED                           M31.7044
  ncros = fem::iabs(npais);
  ltype = 0;
  if (npais > 0 && nncros == 0) {
    ltype = 1;
  }
  ntype = 1;
  if (npais < 0 && nncros != 0) {
    ntype = 0;
  }
  mtype = irsep;
  if (npais > 0 && nncros == 0) {
    mtype = 1;
  }
  nub3 = 3;
  if (ntype == 1) {
    nub3 = 1;
  }
  L = 0;
  xleng = xmajor;
  if (ntype == 0) {
    xleng = xleng / 3.f;
  }
  FEM_DO_SAFE(i, 1, nub6) {
    FEM_DO_SAFE(j, 1, nub6) {
      if (j > i) {
        goto statement_400;
      }
      L++;
      r(L) = std::real(zc(i, j)) * xleng;
      al(L) = std::imag(zc(i, j)) / w * xleng * 1.e3f;
      c(L) = std::imag(yc(i, j)) / w * xleng * 1.e6f;
      statement_400:;
    }
  }
  write(lunit6, "(' ','$VINTAGE, 1')");
  write(lunit7, "('$VINTAGE, 1')");
  L = 0;
  if (ltype == 1) {
    goto statement_610;
  }
  kstep = 1;
  kk = nub6 / 2 + 1;
  if (nub6 == 4) {
    kk = 4;
  }
  kstop = (nub6 + 1) / 2 + 1;
  if (mtype != 0) {
    kstop = nub6;
  }
  if (nub6 == 4) {
    kstop = 4;
  }
  if (nub6 == 7 && mtype == 0) {
    kstop = 4;
  }
  FEM_DOSTEP(k, kk, kstop, kstep) {
    write(lunit6, "(' ',2x,a1,'IN ',i2,18x,e16.5)"), cha, k, rs;
    write(lunit7, "(2x,a1,'IN ',i2,18x,e16.5)"), cha, k, rs;
  }
  statement_610:
  //C     I ; NUMBER OF MAJOR SECTION                                       M31.7085
  //C     J ; NUMBER OF MINOR SECTION                                       M31.7086
  //C     K ; NUMBER OF PHASE                                               M31.7087
  FEM_DO_SAFE(i, 1, ncros) {
    FEM_DO_SAFE(j, 1, nub3) {
      FEM_DO_SAFE(k, 1, nub6) {
        //C     FOLLOWING TWO STATEMENTS ARE FOR THE THIRD MINOR SECTION          M31.7091
        k2 = k;
        if (mtype == 1) {
          goto statement_910;
        }
        if (j == 3 || ntype == 1) {
          cha444(k, k2);
        }
        statement_910:
        //C     FOLLOWING TWO STATEMENTS ARE FOR CROSSBONDING                     M31.7096
        k1 = k;
        if (j != 1) {
          cha645(k, k1);
        }
        //C     FOLLOWING ONE STATEMENT IS FOR THE FIRST MINOR SECTION            M31.7099
        if (j == 1 && mtype != 1) {
          cha444(k, k1);
        }
        //C     FOLLOWING TWO STATEMENTS ARE FOR SERIESE CONECTION OF             M31.7101
        //C                                 MAJOR SECTION                         M31.7102
        j1 = j;
        if (ntype != 1) {
          cha312(j, j1);
        }
        //C     FOLLOWING TWO STATEMENTS ARE FOR SENDING END                      M31.7105
        i1 = i;
        if (j == 1) {
          i1 = i - 1;
        }
        ipri = 1;
        if (i1 == 0) {
          ipri = 2;
        }
        if (i != ncros) {
          goto statement_700;
        }
        if (ntype == 1 || j == 3) {
          ipri = 3;
        }
        //C     IPRI=1 ;                                                          M31.7112
        //C     IPRI=2 ; SENDING END                                              M31.7113
        //C     IPRI=3 ; RECIEVING END                                            M31.7114
        statement_700:
        if (ncros == 1 && ntype == 1) {
          ipri = 4;
        }
        pri(cmn, i, j, k, i1, j1, k1, k2, L, ipri, cha, r, al, c, npk);
      }
    }
    if (ltype == 1) {
      goto statement_100;
    }
    j = 3;
    if (ntype == 1) {
      j = 1;
    }
    if (i == ncros) {
      goto statement_2010;
    }
    FEM_DOSTEP(k, kk, kstop, kstep) {
      write(lunit6, "(' ',2x,a1,i2,i1,i2,6x,a1,'IN ',i2)"), cha, i,
        j, k, cha, k;
      write(lunit7, "(2x,a1,i2,i1,i2,6x,a1,'IN ',i2)"), cha, i, j, k, cha, k;
    }
    goto statement_100;
    statement_2010:
    FEM_DOSTEP(k, kk, kstop, kstep) {
      write(lunit6, "(' ',2x,a1,'OUT',i2,6x,a1,'IN ',i2)"), cha, k, cha, k;
      write(lunit7, "(2x,a1,'OUT',i2,6x,a1,'IN ',i2)"), cha, k, cha, k;
    }
    statement_100:;
  }
  write(lunit6, "(' ','$VINTAGE, 0')");
  write(lunit7, "('$VINTAGE, 0')");
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
nyan(
  common& cmn,
  int const& itype,
  int const& npc,
  int const& nc,
  arr_cref<int> ncpp,
  int const& ngrnd,
  int const& ncros,
  int const& /* npais */,
  int const& ldm) try
{
  ncpp(dimension(ldm));
  common_write write(cmn);
  const auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  int nwork = fem::int0;
  static const char* format_7000 =
    "('0',10x,'ERRORS FOR A CROSSBONDED CABLE (NCROS.NE',"
    "'.0) WHEN ''NPAIS''=''0''.                   ')";
  if (itype == 1) {
    return;
  }
  if (ncros == 0) {
    return;
  }
  if (npc != 3) {
    goto statement_9000;
  }
  FEM_DO_SAFE(i, 1, 3) {
    if (ncpp(i) == 1 || ncpp(i) > 3) {
      goto statement_9100;
    }
  }
  nwork = 6 + ngrnd;
  if (nwork != nc) {
    goto statement_9200;
  }
  if (ncpp(1) <= ncpp(2) && ncpp(2) <= ncpp(3)) {
    return;
  }
  goto statement_9300;
  statement_9000:
  write(lunit6, format_7000);
  write(lunit6, "('0',10x,'NUMBER OF PHASES SHOULD BE ''3''.')");
  stoptp(cmn);
  statement_9100:
  write(lunit6, format_7000);
  write(lunit6,
    "('0',10x,'NUMBER OF CONDUCTORS IN ONE PHASE SHOULD',"
    "'BE ''2'' (CORE AND SHEATH) WITH ''NGRND''=''0',"
    "''' FOR AN SC CABLE AND ''NGRND''=''1'' FOR A ',/,' ',10x,"
    "'PT CABLE, OF ''3'' (CORE, SHEATH AND ARMOR',"
    "') WITH ''NGRND''=''3, CONSIDERING THE FACT ',"
    "'THAT ALL THE 3-PHASE CABLES HAVE THE    ',/,' ',10x,"
    "'SAME CONFIGURATION.                     ')");
  stoptp(cmn);
  statement_9200:
  write(lunit6, format_7000);
  write(lunit6,
    "('0',10x,'IN THE CASE OF ''NPAIS.GE.0 .AND. NCROS.NE.0'', ',"
    "'THE FINAL NUMBER OF CONDUCTORS ',/,11x,"
    "'CONSIDERING GROUNDED CONDUCTORS REDUCTION SHOULD BE ''6''.',/,11x,"
    "'''NGRND'' SHOULD BE ''3'' FOR AN SC CABLE WI',"
    "'TH ARMOR AND ''1'' FOR A PT CABLE.  IF A 3',"
    "'-PHASE SC CABLE WITH ARMOR IS ENCLOSED  ',/,' ',10x,"
    "'WITHIN A PIPE (I.E., PT CABLE), PLEASE ',"
    "'NEGRECT THE PIPE, I.E., REGARD AS AN SC ',"
    "'CABLE WITH ''NGRAND''=''3'', CONSIDERING THE',/,' ',10x,"
    "'FACT THAT ALL THE 3-PHASE CABLES HAVE ',"
    "'THE SAME CONFIGURATION.                 ')");
  stoptp(cmn);
  statement_9300:
  write(lunit6, format_7000);
  write(lunit6,
    "('0',10x,'EACH CABLE OF A 3-PHASE CABLE SYSTEM HAS',"
    "' THE SAME CONFIGULATION IN GENERAL. IF N',"
    "'OT, PLEASE ARRANGE THE DATA CARDS AS    ',/,' ',10x,"
    "'FOLLOWS : FIRST COMES A CABLE OF WHICH T',"
    "'HE NUMBER OF CONDUCTORS IS SMALLEST, SEC',"
    "'OND COMES A CABLE OF THE SECOND SMALLEST',/,' ',10x,"
    "'NUMBER OF CONDUCTORS,.... PLEASE CHECK Y',"
    "'OUR DATA.                               ')");
  stoptp(cmn);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
gomen(
  common& cmn,
  int const& /* itype */,
  int const& npc,
  int const& nx,
  int const& npais,
  int const& ncros,
  int const& irsep,
  arr_cref<int> ncpp,
  int const& ldm) try
{
  ncpp(dimension(ldm));
  common_write write(cmn);
  const auto& lunit6 = cmn.lunit6;
  int i = fem::int0;
  if (npais < 0) {
    goto statement_1000;
  }
  if (ncros != 0) {
    goto statement_1200;
  }
  if (irsep == 0) {
    return;
  }
  goto statement_9120;
  statement_1000:
  if (ncros == 0) {
    goto statement_1100;
  }
  if (nx < 6 || nx > 7) {
    goto statement_9010;
  }
  statement_1200:
  if (npc != 3) {
    goto statement_9020;
  }
  FEM_DO_SAFE(i, 1, 3) {
    if (ncpp(i) == 1 || ncpp(i) > 3) {
      goto statement_9030;
    }
  }
  if (ncpp(1) > ncpp(2) || ncpp(2) > ncpp(3)) {
    goto statement_9040;
  }
  if (nx == 6) {
    return;
  }
  if (npais <= 0 || ncros == 0) {
    goto statement_200;
  }
  if (nx == 4) {
    return;
  }
  statement_200:
  if (ncpp(2) == 2) {
    return;
  }
  goto statement_9110;
  statement_1100:
  if (nx > 7) {
    goto statement_9050;
  }
  if (nx >= 6) {
    goto statement_1200;
  }
  if (nx == 2) {
    goto statement_1300;
  }
  if (nx == 3) {
    goto statement_1400;
  }
  goto statement_9060;
  statement_1400:
  if (irsep == 0) {
    goto statement_9070;
  }
  if (npc != 1) {
    goto statement_9080;
  }
  return;
  statement_1300:
  if (npc != 1) {
    goto statement_9090;
  }
  return;
  statement_9010:
  write(lunit6,
    "('0',10x,'IN THE CASE OF ''NPAIS.LT.0.AND.NCROS.NE.',"
    "'0'' THE FINAL NUMBER OF CONDUCTORS INCLUD',"
    "'ING GROUNDED CONDUCTORS REDUCTION SHOULD',/,' ',10x,"
    "'BE 6 OR 7, I.E., ''TOTAL NUMBER OF CONDUC',"
    "'TORS OF THE CABLE SYSTEM''-''NGRND''=''6'' OR',"
    "' ''7'', BUT ''NGRND'' SHOULD BE ''1'' FOR A PT',/,' ',10x,"
    "'CABLE.                                  ')");
  stoptp(cmn);
  statement_9020:
  write(lunit6, "('0',10x,'NUMBER OF PHASES SHOULD BE ''3''.         ')");
  stoptp(cmn);
  statement_9030:
  write(lunit6,
    "('0',10x,'NUMBER OF CONDUCTORS IN ONE PHASE SHOULD',"
    "' BE ''2'' (CORE AND SHEATH) WITH ''NGRND''=''',"
    "'0'' FOR AN SC CABLE AND ''NGRND''=''1'' FOR A',/,' ',10x,"
    "'PT CABLE, OR ''3'' (CORE, SHEATH AND ARMOR',"
    "') WITH ''NGRND''=''3'' FOR AN SC CABLE.     ')");
  stoptp(cmn);
  statement_9040:
  write(lunit6,
    "('0',10x,'EACH CABLE OF A 3-PHASE CABLE SYSTEM HAS',"
    "' THE SAME CONFIGULATION IN GENERAL. IF N',"
    "'OT, PLEASE ARRANGE THE DATA CARDS AS    ',/,' ',10x,"
    "'FOLLOWS : FIRST COMES A CABLE OF WHICH T',"
    "'HE NUMBER OF CONDUCTORS IS SMALLEST, SEC',"
    "'OND COMES A CABLE OF THE SECOND SMALLEST',/,' ',10x,"
    "'NUMBER OF CONDUCTORS,.... PLEASE CHECK Y',"
    "'OUR DATA                                ')");
  stoptp(cmn);
  statement_9050:
  write(lunit6,
    "('0',10x,'IN THE CASE OF ''NPAIS.LT.0'', THE FINAL N',"
    "'UMBER OF CONDUCTORS INCLUDING GROUNDED C',"
    "'ONDUCTORS REDUCTION SHOULD NOT BE       ',/,' ',10x,"
    "'GREATER THAN ''7''. PLEASE CHECK YOUR DATA.')");
  stoptp(cmn);
  statement_9060:
  write(lunit6,
    "('0',10x,'IN THE CASE OF ''NPAIS.LT.0'', THE FINAL N',"
    "'UMBER OF CONDUCTORS INCLUDING GROUNDED C',"
    "'ONDUCTORS REDUCTION SHOULD NOT BE ''1'' OR',/,' ',10x,"
    "'''4'' OR ''5''. PLEASE CHECK YOUR DATA.     ')");
  stoptp(cmn);
  statement_9070:
  write(lunit6,
    "('0',10x,'IN THIS CASE, IT SHOULD NOT BE ''IRSEP=0''',"
    "'PLEASE CHANGE ''IRSEP=1''                 ')");
  stoptp(cmn);
  statement_9080:
  write(lunit6,
    "('0',10x,'IN THIS CASE, NUMBER OF PHASES (NPC) SHO',"
    "'ULD ONLY BE ''1''. PLEASE CHECK YOUR DATA.')");
  stoptp(cmn);
  statement_9090:
  write(lunit6,
    "('0',10x,'SORRY, IN THE CASE OF ''NPAIS.LT.0'', A TW',"
    "'O PHASE CABLE (NPC=2) CONSISTING ONLY OF',"
    "' CORE OR CONSISTING OF CORE AND SHEATH  ',/,' ',10x,"
    "'CAN NOT BE DEALT WITH. PLEASE CHECK YOUR',"
    "'DATA.                                   ')");
  stoptp(cmn);
  statement_9110:
  write(lunit6,
    "('0',10x,'IN THIS CASE, NCPP(2) SHOULD BE ''2'' PLEA',"
    "'SE CHECK YOUR DATA.                     ')");
  stoptp(cmn);
  statement_9120:
  write(lunit6,
    "('0',10x,'INTHE CASE OF ''NPAIS.GT.0.AND.NCRO',"
    "'S.EQ.0'', IT SHOULD NOT BE ''IRSEP=1',"
    "''',PLEASE CHANGE ''IRSEP=0''.        ')");
  stoptp(cmn);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct print_save
{
  fem::str<8> text1;
  fem::str<8> text2;

  print_save() :
    text1(fem::char0),
    text2(fem::char0)
  {}
};

void
print(
  common& cmn,
  arr_cref<std::complex<double>, 2> c,
  int const& n,
  int const& iform,
  int const& ldn) try
{
  FEM_CMN_SVE(print);
  c(dimension(ldn, ldn));
  common_write write(cmn);
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  if (is_called_first_time) {
    text1 = "ROW";
    text2 = "   ";
  }
  int nline = fem::int0;
  int i = fem::int0;
  fem::str<8> text3 = fem::char0;
  int im = fem::int0;
  int k = fem::int0;
  int in = fem::int0;
  int L = fem::int0;
  int j = fem::int0;
  arr_1d<8, double> workr(fem::fill0);
  arr_1d<8, double> worki(fem::fill0);
  auto& lunit6 = cmn.lunit6;
  int m = fem::int0;
  nline = (n + 7) / 8;
  FEM_DO_SAFE(i, 1, n) {
    text3 = text2;
    im = -7;
    FEM_DO_SAFE(k, 1, nline) {
      im += 8;
      in = im + 7;
      if (in > n) {
        in = n;
      }
      L = 0;
      FEM_DO_SAFE(j, im, in) {
        L++;
        workr(L) = std::real(c(i, j));
        worki(L) = std::imag(c(i, j));
      }
      if (k == nline) {
        text3 = text1;
      }
      if (iform == 1) {
        goto statement_4658;
      }
      {
        write_loop wloop(cmn, lunit6, "(1x,a3,8e16.7)");
        wloop, text3;
        FEM_DO_SAFE(m, 1, L) {
          wloop, workr(m);
        }
      }
      {
        write_loop wloop(cmn, lunit6, "(4x,8e16.7)");
        FEM_DO_SAFE(m, 1, L) {
          wloop, worki(m);
        }
      }
      goto statement_4681;
      statement_4658:
      {
        write_loop wloop(cmn, lunit6, "(1x,a3,8f16.7)");
        wloop, text3;
        FEM_DO_SAFE(m, 1, L) {
          wloop, workr(m);
        }
      }
      {
        write_loop wloop(cmn, lunit6, "(4x,8f16.7)");
        FEM_DO_SAFE(m, 1, L) {
          wloop, worki(m);
        }
      }
      statement_4681:;
    }
    write(lunit6, "('+',i2,/,1x)"), i;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
eigen(
  common& cmn,
  std::complex<double> const& cjw,
  arr_ref<std::complex<double>, 2> p,
  int const& n,
  arr_ref<std::complex<double>, 2> a,
  arr_ref<std::complex<double>, 2> ai,
  arr_ref<std::complex<double> > qn,
  arr_ref<std::complex<double>, 2> q,
  arr_ref<std::complex<double>, 2> xx,
  arr_ref<std::complex<double>, 2> yy,
  int const& ldn) try
{
  p(dimension(ldn, ldn));
  a(dimension(ldn, ldn));
  ai(dimension(ldn, ldn));
  qn(dimension(ldn));
  q(dimension(ldn, ldn));
  xx(dimension(ldn, ldn));
  yy(dimension(ldn, ldn));
  common_write write(cmn);
  double& unity = cmn.unity;
  std::complex<double>& czero = cmn.czero;
  double& fzero = cmn.fzero;
  double& spdlgt = cmn.spdlgt;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  int kvalue = fem::int0;
  std::complex<double> c1 = fem::double0;
  std::complex<double> c2 = fem::double0;
  std::complex<double> qi = fem::double0;
  int i = fem::int0;
  int j = fem::int0;
  int L = fem::int0;
  int iq = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int k = fem::int0;
  double dm = fem::double0;
  double dx = fem::double0;
  int im = fem::int0;
  int i1 = fem::int0;
  int i2 = fem::int0;
  std::complex<double> sa = fem::double0;
  std::complex<double> s = fem::double0;
  double r = fem::double0;
  double d1 = fem::double0;
  double znvref = fem::double0;
  double d2 = fem::double0;
  std::complex<double> ad = fem::double0;
  int ll0 = fem::int0;
  //C     EIGENVALUE CALCULATION SUBROUTINE.   'KVALUE'  =  ITERATION LIMIT.M16.7364
  kvalue = 20;
  c1 = cjw / cmplxz(spdlgt, fzero);
  c2 = cmplxz(unity, fzero);
  qi = c2 / c1;
  qi = qi * qi;
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' ENTER  ''EIGEN'' .','       N',12x,'REAL-CJW',12x,'IMAG-CJW',13x,"
      "'REAL-QI',13x,'IMAG-QI',/,17x,i8,4e20.11,/,1x)"),
      n, cjw, qi;
  }
  FEM_DO_SAFE(i, 1, n) {
    FEM_DO_SAFE(j, 1, n) {
      p(i, j) = p(i, j) * qi;
    }
    p(i, i) = p(i, i) - c2;
  }
  FEM_DO_SAFE(i, 1, n) {
    FEM_DO_SAFE(j, 1, n) {
      q(i, j) = p(i, j);
    }
  }
  L = 0;
  statement_15:
  L++;
  iq = 0;
  switch (fem::if_arithmetic(L - n)) {
    case -1: goto statement_20;
    case  0: goto statement_90;
    default: goto statement_90;
  }
  statement_20:
  iq++;
  if (iq <= kvalue) {
    goto statement_25;
  }
  iq = iq - 1;
  write(lunit6,
    "(5x,'WARNING ; A HIGHER ACCURACY CAN''T BE',"
    "' ACHIEVED BY THIS COMPUTER.',/,5x,"
    "'EIGEN VALUES   1 VECTORS AT ITTERATION IQ=',i3,' IS ADOPTED.')"),
    iq;
  goto statement_63;
  statement_25:
  FEM_DO_SAFE(i, 1, n) {
    FEM_DO_SAFE(j, 1, n) {
      xx(i, j) = q(i, j);
      yy(i, j) = q(i, j);
    }
  }
  FEM_DO_SAFE(i, 1, n) {
    FEM_DO_SAFE(j, 1, n) {
      q(i, j) = czero;
      FEM_DO_SAFE(k, 1, n) {
        q(i, j) += xx(i, k) * yy(k, j);
      }
    }
  }
  dm = 0.f;
  FEM_DO_SAFE(i, 1, n) {
    dx = std::abs(q(i, i));
    if (dx <= dm) {
      goto statement_40;
    }
    dm = dx;
    im = i;
    statement_40:;
  }
  qi = 1. / q(im, im);
  FEM_DO_SAFE(i, 1, n) {
    FEM_DO_SAFE(j, 1, n) {
      q(i, j) = q(i, j) * qi;
    }
  }
  dm = 0.f;
  FEM_DO_SAFE(i, 1, n) {
    if (i == im) {
      goto statement_50;
    }
    dx = std::abs(q(i, im));
    if (dx <= dm) {
      goto statement_50;
    }
    dm = dx;
    i1 = i;
    i2 = im;
    statement_50:;
  }
  if (dm != 0.f) {
    goto statement_60;
  }
  FEM_DO_SAFE(i, 1, n) {
    if (i == im) {
      goto statement_59;
    }
    dx = std::abs(q(im, i));
    if (dx <= dm) {
      goto statement_59;
    }
    dm = dx;
    i1 = im;
    i2 = i;
    statement_59:;
  }
  statement_60:
  sa = q(im, im) / q(i1, i2);
  s = xx(im, im) / xx(i1, i2);
  r = std::abs(s / sa);
  d1 = 50.f * cmn.epsiln;
  //C     NON-64-BIT COMPLEX MATH REDEFINES TOLERANCE IN "SYSDEP":          M35.9708
  if (znvref != 0.0f) {
    d1 = 50.f * znvref;
  }
  d2 = r - unity;
  if (iprs47 >= 31) {
    write(logsix,
      "(' DONE ANOTHER ITERATION.   L, IQ, KVALUE =',3i8,10x,'D2, D1 =',"
      "2e15.6)"),
      L, iq, kvalue, d2, d1;
  }
  if (std::abs(d2) > d1) {
    goto statement_20;
  }
  statement_63:
  FEM_DO_SAFE(i, 1, n) {
    a(i, L) = q(i, im);
    ai(L, i) = q(im, i);
  }
  ad = czero;
  FEM_DO_SAFE(i, 1, n) {
    ad += p(im, i) * q(i, im);
  }
  qn(L) = ad / q(im, im);
  ad = czero;
  FEM_DO_SAFE(i, 1, n) {
    ad += ai(L, i) * a(i, L);
  }
  ad = 1. / ad;
  FEM_DO_SAFE(i, 1, n) {
    ai(L, i) = ad * ai(L, i);
  }
  FEM_DO_SAFE(i, 1, n) {
    FEM_DO_SAFE(j, 1, n) {
      q(i, j) = p(i, j) - a(i, L) * qn(L) * ai(L, j);
      p(i, j) = q(i, j);
    }
  }
  if (iprs47 >= 7) {
    write(logsix,
      "(' EIGENVALUE FINISHED.','       L',10x,'REAL-QN(L)',10x,'IMAG-QN(L)',"
      "13x,'REAL-AD',13x,'IMAG-AD',/,21x,i8,4e20.11,/,1x)"),
      L, qn(L), ad;
  }
  goto statement_15;
  statement_90:
  dm = 0.f;
  FEM_DO_SAFE(i, 1, n) {
    dx = std::abs(p(i, i));
    if (dx <= dm) {
      goto statement_95;
    }
    dm = dx;
    im = i;
    statement_95:;
  }
  ad = czero;
  FEM_DO_SAFE(i, 1, n) {
    ad += p(im, i) * p(i, im);
    a(i, L) = p(i, im) / p(im, im);
  }
  qn(L) = ad / p(im, im);
  FEM_DO_SAFE(i, 1, n) {
    ai(L, i) = p(im, i) / qn(L);
  }
  FEM_DO_SAFE(i, 1, n) {
    qn(i) = c1 * std::sqrt(c2 + qn(i));
  }
  if (iprs47 >= 3) {
    {
      write_loop wloop(cmn, logsix,
        "(/,' DONE ALL EIGENVALUES IN  ''EIGEN'' .',18x,'DM',14x,'SPDLGT',7x,"
        "'REAL-P(IM,IM)',7x,'IMAG-P(IM,IM)',/,35x,4e20.11,/,"
        "' COMPLEX EIGENVALUES  (QN(I), I=1, N)  FOLLOW ...',/(1x,6e20.11))");
      wloop, dm, spdlgt, p(im, im);
      FEM_DO_SAFE(i, 1, n) {
        wloop, qn(i);
      }
    }
  }
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' DIAGNOSTIC UPON EXIT  ''EIGEN'' .   MATRIX OF EIGENVECTORS  A(I,L)"
      "  FOR  (I,L)=1, ... N .')");
  }
  ll0 = 0;
  if (iprs47 >= 6) {
    print(cmn, a(1, 1), n, ll0, ldn);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
minv(
  common& cmn,
  arr_ref<std::complex<double>, 2> tcmpx,
  int const& m,
  arr_cref<std::complex<double>, 2> f,
  int const& ldn,
  int const& ldn2) try
{
  tcmpx(dimension(ldn, ldn));
  f(dimension(ldn, ldn2));
  common_write write(cmn);
  double& value2 = cmn.value2;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  double d1 = fem::double0;
  int i = fem::int0;
  int j = fem::int0;
  std::complex<double> d2 = fem::double0;
  arr_2d<10, 20, double> fr(fem::fill0);
  arr_2d<10, 20, double> fi(fem::fill0);
  int ll0 = fem::int0;
  int j1 = fem::int0;
  int m1 = fem::int0;
  int k1 = fem::int0;
  double d9 = fem::double0;
  int n = fem::int0;
  int i2 = fem::int0;
  double d18 = fem::double0;
  double d19 = fem::double0;
  auto& lunit6 = cmn.lunit6;
  double ccr = fem::double0;
  double cci = fem::double0;
  double dr = fem::double0;
  double di = fem::double0;
  double d14 = fem::double0;
  double d22 = fem::double0;
  double d23 = fem::double0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  double adr = fem::double0;
  double adi = fem::double0;
  double d16 = fem::double0;
  arr_2d<10, 20, std::complex<double> > fnew(fem::fill0);
  arr_2d<10, 20, std::complex<double> > fident(fem::fill0);
  int k = fem::int0;
  d1 = 0.0f;
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      d2 = tcmpx(i, j);
      if (std::abs(d2) > d1) {
        d1 = std::abs(d2);
      }
      fr(i, j) = std::real(d2);
      fi(i, j) = std::imag(d2);
    }
  }
  //CCCC    4 F(I,J) = D2                                                   M16.7574
  d1 = d1 * value2;
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' START  ''MINV'' .','       M',14x,'VALUE6',18x,'D1',9x,"
      "'REAL-F(1,1)',9x,'IMAG-F(1,1)',/,16x,i8,4e20.11,/,"
      "' DIAGNOSTIC   TCMPX(I,J)  FOR  (I,J)=1, ... M .')"),
      m, value2, d1, f(1, 1);
  }
  ll0 = 0;
  if (iprs47 >= 7) {
    print(cmn, tcmpx(1, 1), m, ll0, ldn);
  }
  FEM_DO_SAFE(i, 1, m) {
    j1 = m + 1;
    m1 = m * 2;
    FEM_DO_SAFE(j, j1, m1) {
      if ((j - m) == i) {
        goto statement_20;
      }
      //CCCC     F(I,J) = CZERO                                                 M27.3835
      fr(i, j) = 0.0f;
      fi(i, j) = 0.0f;
      goto statement_25;
      //CCCC  20 F(I,J) = CREAL1                                                M16.7582
      statement_20:
      fr(i, j) = 1.0f;
      fi(i, j) = 0.0f;
      statement_25:;
    }
  }
  FEM_DO_SAFE(k1, 1, m) {
    d9 = 0.0f;
    n = k1;
    FEM_DO_SAFE(i2, k1, m) {
      //CCCC     BX=CABSZ(F(I2,K1))                                             M18.1274
      //CCCC     IF (BX .LE. D9)   GO TO 50                                     M16.7590
      d18 = std::abs(fr(i2, k1));
      d19 = std::abs(fi(i2, k1));
      if (d18 < d19) {
        d18 = d19;
      }
      if (d18 <= d9) {
        goto statement_50;
      }
      d9 = d18;
      n = i2;
      statement_50:;
    }
    //C      write (*,*) ' Next variable.  K1, N, D9, D1 =',                  M43.4079
    //C     1                              K1, N, D9, D1                      M43.4080
    if (d9 > d1) {
      goto statement_60;
    }
    write(lunit6,
      "(/,' STOP. ---- MATRIX INVERSION WITHIN SUBROUTINE  ''MINV''  HAS BEEN "
      "SUSPENDED, DUE TO FAILURE TO FIND A LARGE',/,12x,"
      "'ENOUGH PIVOT ELEMENT.   THE MATRIX IN QUESTION IS OF ORDER',i5,"
      "' ,    WITH BREAKDOWN HAVING OCCURRED',/,12x,"
      "'WHILE WORKING ON THE ELIMINATION OF VARIABLE NUMBER',i5,"
      "'.   In this columns, the largest real or',/,12x,"
      "' imaginary part had absolute value',e14.3,"
      "' ,   WHILE THE APPLICABLE NEAR-ZERO TOLERANCE')"),
      m, k1, d9;
    write(lunit6,
      "(12x,'IS EQUAL TO',e14.3,' .    THIS LATTER NUMBER IS EQUAL TO',e14.3,"
      "'   TIMES THE LARGEST',/,12x,"
      "'ELEMENT OF THE ORIGINAL INPUT MATRIX (CONSIDERING ABSOLUTE VALUES).')"),
      d1, value2;
    FEM_STOP(0);
    statement_60:
    if (n == k1) {
      goto statement_75;
    }
    FEM_DO_SAFE(j, k1, m1) {
      //CCCC     CC=F(K1,J)                                                     M16.7612
      ccr = fr(k1, j);
      cci = fi(k1, j);
      //CCCC     F(K1,J)=F(N,J)                                                 M16.7613
      fr(k1, j) = fr(n, j);
      fi(k1, j) = fi(n, j);
      //CCCC   70 F(N,J)=CC                                                     M16.7614
      fr(n, j) = ccr;
      fi(n, j) = cci;
    }
    statement_75:
    FEM_DO_SAFE(i, 1, m) {
      if (i == k1) {
        goto statement_100;
      }
      //CCCC     D = F(I,K1)                                                    M16.7617
      dr = fr(i, k1);
      di = fi(i, k1);
      FEM_DO_SAFE(j, k1, m1) {
        //CCCC  F(I,J) = F(I,J) - D/F(K1,K1) * F(K1,J)                            M16.7619
        d14 = fem::pow2(fr(k1, k1)) + fem::pow2(fi(k1, k1));
        d22 = dr * fr(k1, k1) + di * fi(k1, k1);
        d23 = di * fr(k1, k1) - dr * fi(k1, k1);
        d5 = d22 * fr(k1, j) - d23 * fi(k1, j);
        d6 = d22 * fi(k1, j) + d23 * fr(k1, j);
        fr(i, j) = fr(i, j) - d5 / d14;
        fi(i, j) = fi(i, j) - d6 / d14;
        //C      write (*,*) ' Revise F(I,J).  I, J, K1, F(I,J) =',               M43.4099
        //C     1                              I, J, K1, FR(I,J), FI(I,J)         M43.4100
      }
      statement_100:;
    }
    //CCCC     AD = F(K1, K1)                                                 M16.7622
    adr = fr(k1, k1);
    adi = fi(k1, k1);
    d14 = fem::pow2(adr) + fem::pow2(adi);
    adr = adr / d14;
    adi = -adi / d14;
    FEM_DO_SAFE(j, k1, m1) {
      //CCCC 110 F(K1,J) = F(K1,J)/AD                                           M16.7624
      d16 = fr(k1, j) * adr - fi(k1, j) * adi;
      fi(k1, j) = fr(k1, j) * adi + fi(k1, j) * adr;
      fr(k1, j) = d16;
    }
    //C  110 write (*,*) ' New  F(K1,J).   K1, J, FR(K1,J), FI(K1,J) =',      M43.4109
    //C     1                              K1, J, FR(K1,J), FI(K1,J)          M43.4110
  }
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      j1 = j + m;
      fnew(i, j) = cmplxz(fr(i, j1), fi(i, j1));
    }
  }
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      fident(i, j) = cmn.czero;
      FEM_DO_SAFE(k, 1, m) {
        fident(i, j) += tcmpx(i, k) * fnew(k, j);
      }
    }
  }
  //C      WRITE (*,*) ' Minv, [A]*[A]-1  follows.   M =',  M               M43.4121
  //C      DO 725  I = 1, M                                                 M43.4122
  //C  725 write (*,*) ' Row', I, ( fident(i,j), j=1, m )                   M43.4123
  FEM_DO_SAFE(i, 1, m) {
    FEM_DO_SAFE(j, 1, m) {
      j1 = j + m;
      //CCCC 125 TCMPX(I,J) = F(I,J1)                                           M18.1276
      tcmpx(i, j) = cmplxz(fr(i, j1), fi(i, j1));
    }
  }
  //C  125 write (*,*) ' Transfer.',                                        M43.4125
  //C     1  ' I, J, J1, FR(I,J1), FI(I,J1), TCMPX(I,J) =',                 M43.4126
  //C     2    I, J, J1, FR(I,J1), FI(I,J1), TCMPX(I,J)                     M43.4127
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' EXIT  ''MINV''  NORMALLY.',5x,'REAL-TCMPX(1,1)',5x,"
      "'IMAG-TCMPX(1,1)',5x,'REAL-TCMPX(1,2)',5x,'IMAG-TCMPX(1,2)',/,24x,"
      "4e20.11,/,' DIAGNOSTIC INVERSE.   TCMPX(I,J)  FOR  (I,J)=1, ... M.')"),
      tcmpx(1, 1), tcmpx(1, 2);
  }
  if (iprs47 >= 7) {
    print(cmn, tcmpx(1, 1), m, ll0, ldn);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
mxm(
  common& cmn,
  arr_cref<std::complex<double>, 2> xm,
  arr_cref<std::complex<double>, 2> yym,
  arr_ref<std::complex<double>, 2> c,
  int const& n,
  int const& ldn) try
{
  xm(dimension(ldn, ldn));
  yym(dimension(ldn, ldn));
  c(dimension(ldn, ldn));
  common_write write(cmn);
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  int ll0 = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' ENTER  ''MXM'' .','       N',7x,'REAL- XM(1,1)',7x,"
      "'IMAG- XM(1,1)',7x,'REAL-YYM(1,1)',7x,'IMAG-YYM(1,1)',/,15x,i8,4e20.11,"
      "/,' DIAGNOSTIC LEFT FACTOR.   XM(I,J)  FOR  (I,J)=1, ... N .')"),
      n, xm(1, 1), yym(1, 1);
  }
  if (iprs47 < 8) {
    goto statement_4079;
  }
  ll0 = 0;
  print(cmn, xm(1, 1), n, ll0, ldn);
  write(logsix,
    "(/,' DIAGNOSTIC RIGHT FACTOR.  YYM(I,J)  FOR  (I,J)=1, ... N .')");
  print(cmn, yym(1, 1), n, ll0, ldn);
  statement_4079:
  FEM_DO_SAFE(i, 1, n) {
    FEM_DO_SAFE(j, 1, n) {
      c(i, j) = cmn.czero;
      FEM_DO_SAFE(k, 1, n) {
        c(i, j) += xm(i, k) * yym(k, j);
      }
    }
  }
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' EXIT  ''MXM'' .',9x,'REAL-C(1,1)',9x,'IMAG-C(1,1)',9x,"
      "'REAL-C(1,2)',9x,'IMAG-C(1,2)',/,14x,4e20.11,/,"
      "' DIAGNOSTIC PRODUCT.   C(I,J)  FOR  (I,J)=1, ... N .')"),
      c(1, 1), c(1, 2);
  }
  if (iprs47 >= 8) {
    print(cmn, c(1, 1), n, ll0, ldn);
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct prcon_save
{
  arr<int> iseq;

  prcon_save() :
    iseq(dimension(15), fem::fill0)
  {}
};

void
prcon(
  common& cmn,
  double const& w,
  int const& nconpw,
  arr_cref<std::complex<double>, 2> zc,
  arr_ref<std::complex<double>, 2> zs,
  arr_ref<std::complex<double>, 2> ys,
  arr_cref<std::complex<double>, 2> yc,
  arr_ref<std::complex<double>, 2> yo,
  arr_ref<std::complex<double> > qn,
  arr_ref<double> gn,
  arr_ref<std::complex<double>, 2> ze,
  arr_ref<std::complex<double>, 2> a,
  arr_ref<std::complex<double>, 2> ai,
  arr_ref<std::complex<double>, 2> b,
  arr_ref<std::complex<double>, 2> bi,
  arr_ref<double> an,
  arr_ref<std::complex<double>, 2> ca,
  arr_ref<std::complex<double>, 2> zo,
  arr_ref<std::complex<double>, 2> cc,
  arr_cref<std::complex<double>, 2> f,
  int const& ldn,
  int const& ldn2,
  int const& lnq2,
  int& mrr,
  int const& nrp) try
{
  FEM_CMN_SVE(prcon);
  zc(dimension(ldn, ldn));
  zs(dimension(ldn, ldn));
  ys(dimension(ldn, ldn));
  yc(dimension(ldn, ldn));
  yo(dimension(ldn, ldn));
  qn(dimension(ldn));
  gn(dimension(ldn));
  ze(dimension(ldn, ldn));
  a(dimension(ldn, ldn));
  ai(dimension(ldn, ldn));
  b(dimension(ldn, ldn));
  bi(dimension(ldn, ldn));
  an(dimension(lnq2));
  ca(dimension(ldn, ldn));
  zo(dimension(ldn, ldn));
  cc(dimension(ldn, ldn));
  f(dimension(ldn, ldn2));
  common_write write(cmn);
  double& twopi = cmn.twopi;
  auto& lunit9 = cmn.lunit9;
  int& lastov = cmn.lastov;
  int& iprsup = cmn.iprsup;
  std::complex<double>& creal1 = cmn.creal1;
  std::complex<double>& czero = cmn.czero;
  double& fzero = cmn.fzero;
  double& pai = cmn.pai;
  double& spdlgt = cmn.spdlgt;
  double& value3 = cmn.value3;
  int& npc = cmn.npc;
  int& npc2 = cmn.npc2;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  int& numaki = cmn.numaki;
  int& iprint = cmn.iprint;
  //
  arr_ref<int> iseq(sve.iseq, dimension(15));
  if (is_called_first_time) {
    fem::data((values, 15*datum(0))), iseq;
  }
  int ntol = fem::int0;
  std::complex<double> cjw = fem::double0;
  int ll1 = fem::int0;
  int ll2 = fem::int0;
  int n1 = fem::int0;
  int icorr = fem::int0;
  int npc1 = fem::int0;
  int i = fem::int0;
  int i1 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  int j = fem::int0;
  int iz = fem::int0;
  arr_1d<30, double> ps(fem::fill0);
  arr_1d<30, double> zz(fem::fill0);
  double a1 = fem::double0;
  double spdtol = fem::double0;
  arr<double, 2> tir(dimension(20, 20), fem::fill0);
  arr<double, 2> tii(dimension(20, 20), fem::fill0);
  int kthl = fem::int0;
  arr_1d<200, double> ping(fem::fill0);
  double d55 = fem::double0;
  double d56 = fem::double0;
  double em = fem::double0;
  double ea = fem::double0;
  double db = fem::double0;
  double vmode = fem::double0;
  arr_1d<15, std::complex<double> > ee6(fem::fill0);
  arr<std::complex<double>, 2> pp6(dimension(20, 20), fem::fill0);
  arr<double, 2> pp1(dimension(20, 20), fem::fill0);
  arr<double, 2> pp2(dimension(20, 20), fem::fill0);
  arr_1d<15, int> kmax(fem::fill0);
  double dv = fem::double0;
  double da = fem::double0;
  double fout = fem::double0;
  double u1 = fem::double0;
  double u2 = fem::double0;
  double aii = fem::double0;
  double air = fem::double0;
  double d18 = fem::double0;
  double deg = fem::double0;
  double acomi = fem::double0;
  double acomr = fem::double0;
  double d19 = fem::double0;
  double aa = fem::double0;
  double bb = fem::double0;
  double w1 = fem::double0;
  double ycharm = fem::double0;
  double ychara = fem::double0;
  double alpha = fem::double0;
  double beta = fem::double0;
  int k = fem::int0;
  double zsr = fem::double0;
  double zsi = fem::double0;
  double ysi = fem::double0;
  double zor = fem::double0;
  double zoi = fem::double0;
  double yor = fem::double0;
  double yoi = fem::double0;
  ntol = iprint - 1;
  cjw = cmplxz(fzero, w);
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' ENTER  ''PRCON'' .','  NCONPW  NUMAKI',13x,'VALUE1',13x,'VALUE3',"
      "16x,'PAI',11x,'REAL-CJW',11x,'IMAG-CJW',/,17x,2i8,5e19.10)"),
      nconpw, numaki, cmn.value1, value3, pai, cjw;
  }
  ll1 = 1;
  ll2 = 2;
  mxm(cmn, zc, yc, zs, nconpw, ldn);
  eigen(cmn, cjw, zs, nconpw, a, ai, qn, ca, zo, cc, ldn);
  //CCCC  *****                                                             VAX.4217
  if (cmn.kill > 1) {
    goto statement_9200;
  }
  if (cmn.itypec != 2) {
    goto statement_75;
  }
  n1 = npc * 2;
  if (nconpw != n1) {
    goto statement_75;
  }
  icorr = 0;
  npc1 = npc + 1;
  FEM_DO_SAFE(i, npc1, npc2) {
    if (std::real(qn(i)) > 0.f) {
      goto statement_65;
    }
    i1 = i + 1;
    if (i1 > npc2) {
      i1 = i - 1;
    }
    if (i1 <= npc) {
      goto statement_65;
    }
    if (std::real(qn(i1)) < 0.f) {
      goto statement_63;
    }
    statement_61:
    qn(i) = qn(i1);
    icorr = 1;
    write(lunit6,
      "('0','MODIFICATIONS OF MODAL QUANTITIES FOR MODE',i2,' ARE MADE.',/)"),
      i;
    goto statement_65;
    statement_63:
    i1 = i + 2;
    if (i1 > npc2) {
      i1 = i - 2;
    }
    if (std::real(qn(i1)) > 0.f) {
      goto statement_61;
    }
    statement_65:;
  }
  if (icorr == 0) {
    goto statement_75;
  }
  FEM_DO_SAFE(i, npc1, npc2) {
    i1 = i - npc;
    FEM_DO_SAFE(j, 1, npc2) {
      ai(i, j) = czero;
      if (i1 == j) {
        ai(i, j) = creal1;
      }
      if (i == j) {
        ai(i, j) = -creal1;
      }
    }
  }
  FEM_DO_SAFE(i, 1, nconpw) {
    FEM_DO_SAFE(j, 1, nconpw) {
      a(i, j) = ai(i, j);
    }
  }
  write(6, star), " after #71 ";
  minv(cmn, a, nconpw, f, ldn, ldn2);
  statement_75:
  FEM_DO_SAFE(iz, 1, 30) {
    ps(iz) = 0.f;
    zz(iz) = 0.f;
  }
  FEM_DO_SAFE(i, 1, nconpw) {
    an(i) = value3 * std::real(qn(i));
    gn(i) = w / std::imag(qn(i));
    if (an(i) < 0.f) {
      goto statement_50;
    }
    a1 = 1.05f;
    spdtol = spdlgt * a1;
    if (gn(i) > spdtol) {
      goto statement_50;
    }
    if (gn(i) < spdlgt) {
      goto statement_55;
    }
    gn(i) = spdlgt;
    write(lunit6, "('0',10x,'MODIFICATION FOR IMAG(Q) IS MADE.',/,/,1x)");
    goto statement_55;
    statement_50:
    write(lunit6,
      "('0',10x,'CONDUCTOR IMPEDANCE MAY INCLUDE NUMERICAL ERRORS.',/,11x,"
      "'THE CORRECT SOLUTIONS FOR MODES SHOWING ERRORS CAN BE GIVEN BY THE VER"
      "Y LAST MODE.',/,/,1x)");
    statement_55:
    //C       IF (LASTOV .NE. 39 )  GO TO 600                                 M43.4062
    //C       IF (IPRINT .GT. 1 )  GO TO 600                                  M43.4063
    FEM_DO_SAFE(j, 1, nconpw) {
      bi(i, j) = a(j, i);
      b(i, j) = ai(j, i);
      if (lastov != 39) {
        goto statement_60;
      }
      if (iprint > 1) {
        goto statement_60;
      }
      tir(i, j) = std::real(b(i, j));
      tii(i, j) = std::imag(b(i, j));
      statement_60:;
    }
  }
  if (ntol == 0 || lastov != 39) {
    goto statement_5602;
  }
  kthl = 1;
  ping(kthl) = alog1z(w / twopi);
  d55 = 1.0f / (w / twopi);
  d56 = 1.0f / sqrtz(w / twopi);
  FEM_DO_SAFE(i, 1, nconpw) {
    //C     EM=(std::real(QN(I)))**2 + (AIMAGZ(QN(I)))**2                         VAX.4238
    //C     EA=2.0*ATAN2Z( AIMAG(QN(I)),REAL(QN(I)) )                         VAX.4239
    em = sqrtz(fem::pow2((std::real(fem::pow2(qn(i))))) + fem::pow2((
      std::imag(fem::pow2(qn(i))))));
    ea = std::atan2(std::imag(fem::pow2(qn(i))), std::real(fem::pow2(qn(i))));
    db = value3 * std::real(qn(i));
    vmode = w / std::imag(qn(i));
    ping(kthl + 1) = em * d55;
    ping(kthl + 2) = ea / (twopi / 360.f);
    ping(kthl + 3) = vmode;
    ping(kthl + 4) = db * d56;
    kthl += 4;
  }
  unwind(cmn, ping, kthl, mrr, nrp, ntol, iseq);
  FEM_DO_SAFE(i, 1, nconpw) {
    ee6(i) = fem::pow2(qn(i));
    FEM_DO_SAFE(j, 1, nconpw) {
      pp6(i, j) = a(i, j);
    }
  }
  FEM_DO_SAFE(i, 1, nconpw) {
    qn(i) = std::sqrt(ee6(iseq(i)));
    FEM_DO_SAFE(j, 1, nconpw) {
      a(i, j) = pp6(i, iseq(j));
    }
  }
  FEM_DO_SAFE(i, 1, nconpw) {
    FEM_DO_SAFE(j, 1, nconpw) {
      ai(i, j) = a(i, j);
    }
  }
  if (iprsup >= 1) {
    write(6, star), " PRCON after S.N. 5701.   [A]  follows ....";
  }
  FEM_DO_SAFE(i, 1, nconpw) {
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, 6, star);
        FEM_DO_SAFE(j, 1, nconpw) {
          wloop, a(i, j);
        }
      }
    }
  }
  minv(cmn, ai, nconpw, f, ldn, ldn2);
  if (iprsup >= 1) {
    write(6, star), " After \"MINV\".   [AI]  follows ..... ";
  }
  FEM_DO_SAFE(i, 1, nconpw) {
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, 6, star);
        FEM_DO_SAFE(j, 1, nconpw) {
          wloop, ai(i, j);
        }
      }
    }
  }
  FEM_DO_SAFE(i, 1, nconpw) {
    FEM_DO_SAFE(j, 1, nconpw) {
      pp1(j, i) = sqrtz(fem::pow2((std::real(ai(i, j)))) + fem::pow2((std::imag(ai(i,
        j)))));
      pp2(j, i) = std::atan2(std::imag(ai(i, j)), std::real(ai(i, j)));
    }
  }
  if (ntol == 1) {
    goto statement_5800;
  }
  goto statement_5810;
  statement_5800:
  FEM_DO_SAFE(j, 1, nconpw) {
    kmax(j) = 1;
    FEM_DO_SAFE(i, 1, nconpw) {
      if (pp1(i, j) <= pp1(kmax(j), j)) {
        goto statement_5802;
      }
      kmax(j) = i;
      statement_5802:;
    }
  }
  {
    write_loop wloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(j, 1, nconpw) {
      wloop, kmax(j);
    }
  }
  statement_5810:
  if (iprsup >= 1) {
    {
      write_loop wloop(cmn, 6, star);
      wloop, " PRCON.  Use normalization cells KMAX(1:NCONPW) =";
      FEM_DO_SAFE(i, 1, nconpw) {
        wloop, kmax(i);
      }
    }
  }
  FEM_DO_SAFE(j, 1, nconpw) {
    if (pp1(kmax(j), j) == 0.0f) {
      goto statement_5614;
    }
    dv = 1.0f / pp1(kmax(j), j);
    da = pp2(kmax(j), j);
    FEM_DO_SAFE(i, 1, nconpw) {
      pp1(i, j) = pp1(i, j) * dv;
      pp2(i, j) = pp2(i, j) - da;
      //C     *** to keep angles within principal value region                  VAX.4308
      if (pp2(i, j) > twopi / 2.f) {
        pp2(i, j) = pp2(i, j) - twopi;
      }
      if (pp2(i, j) <  - twopi / 2.f) {
        pp2(i, j) += twopi;
      }
      if (iprsup >= 3) {
        write(6, star), "just before 5624, i, j, pp1(i,j), pp2(i,j)",
          i, j, pp1(i, j), pp2(i, j);
      }
    }
    statement_5614:;
  }
  fout = w / twopi;
  //C   ******************** TEMPORARY DIAGNOSTIC ************              VAX.4317
  if (iprsup >= 0) {
    write(6, star), " PRCON.  Freq =", fout, "     PP1 follow : ";
  }
  FEM_DO_SAFE(i, 1, nconpw) {
    if (iprsup >= 0) {
      {
        write_loop wloop(cmn, 6, star);
        FEM_DO_SAFE(j, 1, nconpw) {
          wloop, pp1(i, j);
        }
      }
    }
  }
  if (iprsup >= 0) {
    write(6, star), " PP2  follow ... ";
  }
  FEM_DO_SAFE(i, 1, nconpw) {
    if (iprsup >= 0) {
      {
        write_loop wloop(cmn, 6, star);
        FEM_DO_SAFE(j, 1, nconpw) {
          wloop, pp2(i, j);
        }
      }
    }
  }
  FEM_DO_SAFE(i, 1, nconpw) {
    FEM_DO_SAFE(j, 1, nconpw) {
      u1 = (pp1(i, j)) * cosz(pp2(i, j));
      u2 = (pp1(i, j)) * sinz(pp2(i, j));
      ai(j, i) = cmplxz(u1, u2);
    }
  }
  FEM_DO_SAFE(j, 1, nconpw) {
    FEM_DO_SAFE(i, 1, nconpw) {
      a(i, j) = ai(i, j);
    }
  }
  minv(cmn, a, nconpw, f, ldn, ldn2);
  FEM_DO_SAFE(i, 1, nconpw) {
    FEM_DO_SAFE(j, 1, nconpw) {
      bi(i, j) = a(j, i);
      b(i, j) = ai(j, i);
    }
  }
  statement_5602:
  FEM_DO_SAFE(i, 1, nconpw) {
    FEM_DO_SAFE(j, 1, nconpw) {
      aii = std::imag(ai(i, j));
      air = std::real(ai(i, j));
      d18 = std::abs(ai(i, j));
      deg = std::atan2(aii, air) * 180.0f / pai;
      ze(i, j) = cmplxz(d18, deg);
      acomi = std::imag(a(i, j));
      acomr = std::real(a(i, j));
      d19 = std::abs(a(i, j));
      deg = std::atan2(acomi, acomr) * 180.0f / pai;
      ys(i, j) = cmplxz(d19, deg);
    }
  }
  if (numaki > 3) {
    goto statement_5673;
  }
  write(lunit6,
    "(/,10x,'VOLTAGE TRANSFORMATION MATRICES IN POLAR',"
    "' COORDINATES (WITH ANGLES IN DEGREES).',/,15x,"
    "' INVERSE OF [Tv] --- FROM PHASE TO MODE DOMAIN:')");
  print(cmn, ze, nconpw, ll1, ldn);
  write(lunit6, "(15x,' [Tv] --- FROM MODE TO PHASE DOMAIN:')");
  print(cmn, ys, nconpw, ll1, ldn);
  statement_5673:
  mxm(cmn, bi, yc, ca, nconpw, ldn);
  mxm(cmn, ca, a, ys, nconpw, ldn);
  FEM_DO_SAFE(i, 1, nconpw) {
    FEM_DO_SAFE(j, 1, nconpw) {
      if (i != j) {
        goto statement_79;
      }
      aa = std::imag(ys(i, i));
      bb = std::real(ys(i, i));
      if (iprsup >= 1) {
        write(6, star), " I, YS(I,I) =", i, ys(i, i);
      }
      //Cc  $$$$ protection ?? $$$$                                             VAX.4378
      //C     IF((ABSZ(BB).LE.1.0E-18).OR.(ABSZ(AA).LE.1.0E-18))                VAX.4379
      if ((std::abs(bb) <= 1.0e-18f) && (std::abs(aa) <= 1.0e-18f)) {
        goto statement_9801;
      }
      goto statement_9802;
      statement_9801:
      ys(i, j) = ys(i, j) * 1.0e10;
      zs(i, i) = fem::pow2(qn(i)) / ys(i, i) * 1.e-10;
      //C     ZO(I,I) = (QN(I)/YS(I,I))*1.0E10                                  VAX.4386
      write(6, star), "qn, ys  for i=", qn(i), ys(i, j), i;
      ys(i, i) = ys(i, i) * 1.0e-10;
      goto statement_9803;
      statement_9802:
      //C     ZO(I,I) = QN(I)/YS(I,I)                                           VAX.4391
      zs(i, i) = fem::pow2(qn(i)) / ys(i, i);
      statement_9803:
      //Cc  $$$$ end of protection  $$$$                                        VAX.4394
      //C     YO(I,I) = 1./ZO(I,I)                                              VAX.4395
      //C     ZS(I,I) = QN(I) * ZO(I,I)                                         VAX.4396
      yo(i, i) = std::sqrt(ys(i, i) / zs(i, i));
      zo(i, i) = 1. / yo(i, i);
      goto statement_80;
      statement_79:
      zo(i, j) = czero;
      yo(i, j) = czero;
      zs(i, j) = cmplxz(fzero, fzero);
      statement_80:;
    }
    if (lastov != 39) {
      goto statement_1980;
    }
    if (iprint < 2) {
      goto statement_1978;
    }
    //C     YSRE = REALZ(YS(I,I))                                             VAX.4400
    //C     YSIM = AIMAGZ(YS(I,I))                                            VAX.4401
    //C     ZSRE = REALZ(ZS(I,I))                                             VAX.4402
    //C     ZSIM = AIMAGZ(ZS(I,I))                                            VAX.4403
    //CC      WRITE (LUNIT9)  W, YSRE,YSIM,ZSRE,ZSIM                          VAX.4404
    w1 = w;
    //C   ** THE UNIT HERE IS /km NOW! **                                     VAX.4406
    //C     ZZ(I)=ZSRE *1000.                                                 VAX.4407
    //C     ZZ(I+NCONPW)=ZSIM*1000.                                           VAX.4408
    //C     PS(I)=YSRE*1000.                                                  VAX.4409
    //C     PS(I+NCONPW)=YSIM*1000.                                           VAX.4410
    ycharm = std::abs(yo(i, i));
    ychara = std::atan2(std::imag(yo(i, i)), std::real(yo(i, i)));
    alpha = std::real(qn(i)) * 1000.f;
    beta = std::imag(qn(i)) * 1000.f;
    if (lastov != 39) {
      goto statement_1980;
    }
    if (iprint < 2) {
      goto statement_1978;
    }
    write(lunit9, fem::unformatted), w1, ycharm, ychara, alpha, beta;
    FEM_DO_SAFE(k, 1, nconpw) {
      pp1(k, i) = std::abs(b(k, i));
      pp2(k, i) = std::atan2(std::imag(b(k, i)), std::real(b(k, i)));
    }
    {
      write_loop wloop(cmn, lunit9, fem::unformatted);
      FEM_DO_SAFE(k, 1, nconpw) {
        wloop, pp1(k, i), pp2(k, i);
      }
    }
    //C    **********  THLTHL                                                 VAX.4423
    //C    **********  THLTHL                                                 VAX.4425
    statement_1978:
    if (iprsup >= 0) {
      write(lunit6,
        "(' Ychar AND EIGENVALUE FOR MODE',i3,' AT FREQUENCY =',e12.5,2x,"
        "' ARE ',4e12.5)"),
        i, w, ycharm, ychara, alpha, beta;
    }
    statement_1980:;
  }
  if (numaki > 3) {
    goto statement_9900;
  }
  write(lunit6, "(/,10x,'CHARACTERISTIC IMPEDANCES IN THE PHASE DOMAIN')");
  mxm(cmn, a, zo, ca, nconpw, ldn);
  mxm(cmn, ca, bi, ze, nconpw, ldn);
  print(cmn, ze, nconpw, ll1, ldn);
  write(lunit6, "(/,/,53x,' TABLE OF MODAL QUANTITIES.')");
  write(lunit6,
    "(/,/,11x,'MODAL',4x,'PROPAGATION',7x,'MODAL IMPEDANCE',12x,'MODAL',6x,"
    "'CHARAC. IMP., NATURAL MODE',4x,'CHARAC. ADM., NATURAL MODE',/,' MODE',"
    "3x,'ATTENUATION   VELOCITY',7x,'REAL',7x,'IMAGINARY',4x,'SUSCEPTANCE',7x,"
    "'REAL',8x,'IMAGINARY',9x,'REAL',8x,'IMAGINARY',/,10x,'(DB/KM)',6x,"
    "'(M/S)',12x,'Z(OHM/M)',14x,'IMY(MHO/M)',9x,'SQRT(Z/Y) (OHM)  ',13x,"
    "'SQRT(Y/Z) (MHO)  ')");
  FEM_DO_SAFE(i, 1, nconpw) {
    zsr = std::real(zs(i, i));
    zsi = std::imag(zs(i, i));
    ysi = std::imag(ys(i, i));
    zor = std::real(zo(i, i));
    zoi = std::imag(zo(i, i));
    yor = std::real(yo(i, i));
    yoi = std::imag(yo(i, i));
    write(lunit6, "(/,1x,i3,3x,2e12.5,1x,3e14.6,2(1x,2e14.6))"), i,
      an(i), gn(i), zsr, zsi, ysi, zor, zoi, yor, yoi;
  }
  write(lunit6, "(/,/,/,1x)");
  goto statement_9900;
  statement_9200:
  statement_9900:
  if (iprs47 >= 1) {
    write(logsix, "(/,' EXIT  ''PRCON'' .')");
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
cutmat(
  arr_cref<std::complex<double>, 2> cinput,
  arr_ref<std::complex<double>, 2> ca,
  arr_ref<std::complex<double>, 2> cb,
  arr_ref<std::complex<double>, 2> cc,
  arr_ref<std::complex<double>, 2> cd,
  int const& n,
  int const& L,
  int const& ldn) try
{
  cinput(dimension(ldn, ldn));
  ca(dimension(ldn, ldn));
  cb(dimension(ldn, ldn));
  cc(dimension(ldn, ldn));
  cd(dimension(ldn, ldn));
  int i = fem::int0;
  int j = fem::int0;
  FEM_DO_SAFE(i, 1, L) {
    FEM_DO_SAFE(j, 1, L) {
      ca(i, j) = cinput(i, j);
    }
  }
  int nml = n - L;
  int jpl = fem::int0;
  FEM_DO_SAFE(i, 1, L) {
    FEM_DO_SAFE(j, 1, nml) {
      jpl = j + L;
      cb(i, j) = cinput(i, jpl);
    }
  }
  int ipl = fem::int0;
  FEM_DO_SAFE(i, 1, nml) {
    FEM_DO_SAFE(j, 1, L) {
      ipl = i + L;
      cc(i, j) = cinput(ipl, j);
    }
  }
  FEM_DO_SAFE(i, 1, nml) {
    FEM_DO_SAFE(j, 1, nml) {
      ipl = i + L;
      jpl = j + L;
      cd(i, j) = cinput(ipl, jpl);
    }
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
mxmnm(
  arr_cref<std::complex<double>, 2> ca,
  arr_cref<std::complex<double>, 2> cb,
  arr_ref<std::complex<double>, 2> cc,
  int const& L,
  int const& m,
  int const& n,
  int const& ldn) try
{
  ca(dimension(ldn, ldn));
  cb(dimension(ldn, ldn));
  cc(dimension(ldn, ldn));
  int i = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  FEM_DO_SAFE(i, 1, L) {
    FEM_DO_SAFE(j, 1, n) {
      cc(i, j) = 0.f;
      FEM_DO_SAFE(k, 1, m) {
        cc(i, j) += ca(i, k) * cb(k, j);
      }
    }
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
minvn(
  common& cmn,
  arr_ref<std::complex<double>, 2> cinout,
  int const& n,
  int const& L,
  int const& ix,
  int const& ldn,
  arr_ref<std::complex<double>, 2> ca,
  arr_ref<std::complex<double>, 2> cb,
  arr_ref<std::complex<double>, 2> cc,
  arr_ref<std::complex<double>, 2> cd,
  arr_ref<std::complex<double>, 2> cwork1,
  arr_ref<std::complex<double>, 2> cwork2,
  arr_ref<std::complex<double>, 2> cwork3,
  arr_cref<std::complex<double>, 2> f,
  int const& ldn2) try
{
  cinout(dimension(ldn, ldn));
  ca(dimension(ldn, ldn));
  cb(dimension(ldn, ldn));
  cc(dimension(ldn, ldn));
  cd(dimension(ldn, ldn));
  cwork1(dimension(ldn, ldn));
  cwork2(dimension(ldn, ldn));
  cwork3(dimension(ldn, ldn));
  f(dimension(ldn, ldn2));
  int nml = n - L;
  cutmat(cinout, ca, cb, cc, cd, n, L, ldn);
  int i = fem::int0;
  int j = fem::int0;
  FEM_DO_SAFE(i, 1, nml) {
    FEM_DO_SAFE(j, 1, nml) {
      cwork1(i, j) = cd(i, j);
    }
  }
  minv(cmn, cwork1, nml, f, ldn, ldn2);
  mxmnm(cwork1, cc, cwork2, nml, nml, L, ldn);
  mxmnm(cb, cwork2, cwork1, L, nml, L, ldn);
  FEM_DO_SAFE(i, 1, L) {
    FEM_DO_SAFE(j, 1, L) {
      cwork1(i, j) = ca(i, j) - cwork1(i, j);
      cinout(i, j) = cwork1(i, j);
    }
  }
  if (ix == 1) {
    return;
  }
  minv(cmn, cwork1, L, f, ldn, ldn2);
  FEM_DO_SAFE(i, 1, L) {
    FEM_DO_SAFE(j, 1, L) {
      cinout(i, j) = cwork1(i, j);
    }
  }
  mxmnm(cwork2, cwork1, cwork3, nml, L, L, ldn);
  int ipl = fem::int0;
  FEM_DO_SAFE(i, 1, nml) {
    FEM_DO_SAFE(j, 1, L) {
      ipl = i + L;
      cinout(ipl, j) = -cwork3(i, j);
    }
  }
  FEM_DO_SAFE(i, 1, L) {
    FEM_DO_SAFE(j, 1, L) {
      cwork1(i, j) = ca(i, j);
    }
  }
  minv(cmn, cwork1, L, f, ldn, ldn2);
  mxmnm(cwork1, cb, cwork2, L, L, nml, ldn);
  mxmnm(cc, cwork2, cwork1, nml, L, nml, ldn);
  FEM_DO_SAFE(i, 1, nml) {
    FEM_DO_SAFE(j, 1, nml) {
      cwork1(i, j) = cd(i, j) - cwork1(i, j);
    }
  }
  minv(cmn, cwork1, nml, f, ldn, ldn2);
  int jpl = fem::int0;
  FEM_DO_SAFE(i, 1, nml) {
    FEM_DO_SAFE(j, 1, nml) {
      ipl = i + L;
      jpl = j + L;
      cinout(ipl, jpl) = cwork1(i, j);
    }
  }
  mxmnm(cwork2, cwork1, cwork3, L, nml, nml, ldn);
  FEM_DO_SAFE(i, 1, L) {
    FEM_DO_SAFE(j, 1, nml) {
      jpl = j + L;
      cinout(i, jpl) = -cwork3(i, j);
    }
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
crosa4(
  common& cmn,
  arr_ref<std::complex<double>, 2> czy,
  int const& icont,
  int const& ldn,
  arr_ref<std::complex<double>, 2> ca,
  arr_ref<std::complex<double>, 2> cb,
  arr_ref<std::complex<double>, 2> cc,
  arr_ref<std::complex<double>, 2> cd,
  arr_ref<std::complex<double>, 2> ce,
  arr_ref<std::complex<double>, 2> cf,
  arr_ref<std::complex<double>, 2> cg,
  arr_cref<std::complex<double>, 2> f,
  int const& ldn2) try
{
  czy(dimension(ldn, ldn));
  ca(dimension(ldn, ldn));
  cb(dimension(ldn, ldn));
  cc(dimension(ldn, ldn));
  cd(dimension(ldn, ldn));
  ce(dimension(ldn, ldn));
  cf(dimension(ldn, ldn));
  cg(dimension(ldn, ldn));
  f(dimension(ldn, ldn2));
  common_write write(cmn);
  std::complex<double> cwork1 = fem::double0;
  int i = fem::int0;
  int j = fem::int0;
  write(6, "('  BEGIN MODULE \"CROSA4\".  ****** ')");
  cwork1 = 0.f;
  FEM_DO_SAFE(i, 4, 6) {
    cwork1 += czy(i, i);
  }
  cwork1 = cwork1 / 3.;
  FEM_DO_SAFE(i, 4, 6) {
    czy(i, i) = cwork1;
  }
  cwork1 = czy(4, 5) + czy(4, 6) + czy(5, 6);
  cwork1 = cwork1 / 3.;
  czy(4, 5) = cwork1;
  czy(4, 6) = cwork1;
  czy(5, 6) = cwork1;
  FEM_DO_SAFE(i, 1, 3) {
    cwork1 = 0.f;
    FEM_DO_SAFE(j, 4, 6) {
      cwork1 += czy(i, j);
    }
    cwork1 = cwork1 / 3.;
    FEM_DO_SAFE(j, 4, 6) {
      czy(i, j) = cwork1;
    }
  }
  FEM_DO_SAFE(i, 1, 6) {
    FEM_DO_SAFE(j, 1, 6) {
      if (i <= 3 && j <= 3) {
        goto statement_60;
      }
      if (i >= j) {
        goto statement_60;
      }
      czy(j, i) = czy(i, j);
      statement_60:;
    }
  }
  if (icont == 0) {
    minvn(cmn, czy, 6, 3, 0, ldn, ca, cb, cc, cd, ce, cf, cg, f, ldn2);
  }
  FEM_DO_SAFE(j, 1, 3) {
    czy(4, j) += czy(5, j) + czy(6, j);
    czy(j, 4) += czy(j, 5) + czy(j, 6);
  }
  czy(4, 4) += czy(5, 4) + czy(6, 4) + czy(4, 5) + czy(5, 5) + czy(6,
    5) + czy(4, 6) + czy(5, 6) + czy(6, 6);
  if (icont == 0) {
    minvn(cmn, czy, 4, 3, 0, ldn, ca, cb, cc, cd, ce, cf, cg, f, ldn2);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
bsikm(
  common& cmn,
  std::complex<double> const& x,
  int const& kn,
  arr_ref<std::complex<double> > bbin,
  arr_ref<std::complex<double> > bbkn,
  int const& ikm,
  int const& ixa) try
{
  bbin(dimension(kn));
  bbkn(dimension(kn));
  common_write write(cmn);
  std::complex<double>& creal1 = cmn.creal1;
  double& fzero = cmn.fzero;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  double xa = fem::double0;
  double c1 = fem::double0;
  double c2 = fem::double0;
  std::complex<double> y = fem::double0;
  std::complex<double> y1 = fem::double0;
  std::complex<double> y2 = fem::double0;
  std::complex<double> y3 = fem::double0;
  std::complex<double> y4 = fem::double0;
  std::complex<double> y5 = fem::double0;
  std::complex<double> y6 = fem::double0;
  std::complex<double> bi0 = fem::double0;
  std::complex<double> bj1 = fem::double0;
  std::complex<double> y0 = fem::double0;
  std::complex<double> y7 = fem::double0;
  std::complex<double> y8 = fem::double0;
  std::complex<double> bk0 = fem::double0;
  std::complex<double> bk1 = fem::double0;
  int ikn = fem::int0;
  int ik1 = fem::int0;
  int ik2 = fem::int0;
  int L = fem::int0;
  xa = std::abs(x);
  c1 = 3.75f;
  c2 = 2.f;
  y = x / cmplxz(c1, fzero);
  if (iprs47 >= 5) {
    write(logsix,
      "(/,' BEGIN  ''BSIKM'' .','      KN     IKM     IXA',9x,'REAL-X',9x,"
      "'IMAG-X',9x,'REAL-Y',9x,'IMAG-Y',13x,'XA',/,17x,3i8,5e15.6)"),
      kn, ikm, ixa, x, y, xa;
  }
  if (xa > c1) {
    goto statement_25;
  }
  y1 = y * y;
  y2 = y1 * y1;
  y3 = y2 * y1;
  y4 = y3 * y1;
  y5 = y4 * y1;
  y6 = y5 * y1;
  bi0 = 1. + 3.5156229 * y1 + 3.0899424 * y2 + 1.2067492 * y3 +
    0.2659732 * y4 + 0.0360768 * y5 + 0.0045813 * y6;
  bj1 = x * (0.5 + 0.87890594 * y1 + 0.51498869 * y2 +
    0.15084934 * y3 + 0.02658733 * y4 + 0.00301532 * y5 +
    0.00032411 * y6);
  goto statement_29;
  statement_25:
  y0 = std::sqrt(x);
  if (ixa != 1) {
    y0 = y0 * std::exp(-x);
  }
  y1 = 1. / y;
  y2 = y1 / y;
  y3 = y2 / y;
  y4 = y3 / y;
  y5 = y4 / y;
  y6 = y5 / y;
  y7 = y6 / y;
  y8 = y7 / y;
  bi0 = (0.39894228 + 0.01328592 * y1 + 0.00225319 * y2 -
    0.00157565 * y3 + 0.00916281 * y4 - 0.02057706 * y5 +
    0.02635537 * y6 - 0.01647633 * y7 + 0.00392377 * y8) / y0;
  bj1 = (0.39894228 - 0.03988024 * y1 - 0.00362018 * y2 +
    0.00163801 * y3 - 0.01031555 * y4 + 0.02282967 * y5 -
    0.02895312 * y6 + 0.01787654 * y7 - 0.00420059 * y8) / y0;
  statement_29:
  if (xa > c2) {
    goto statement_35;
  }
  y = x / cmplxz(c2, fzero);
  y0 = std::log(y);
  y1 = y * y;
  y2 = y1 * y1;
  y3 = y2 * y1;
  y4 = y3 * y1;
  y5 = y4 * y1;
  y6 = y5 * y1;
  bk0 = -y0 * bi0 - 0.57721566 + 0.42278420 * y1 + 0.23069756 * y2 +
    0.03488590 * y3 + 0.00262698 * y4 + 0.00010750 * y5 +
    0.00000740 * y6;
  bk1 = y0 * bj1 + (1. + 0.15443144 * y1 - 0.67278579 * y2 -
    0.18156897 * y3 - 0.01919402 * y4 - 0.00110404 * y5 -
    0.00004686 * y6) / x;
  goto statement_40;
  statement_35:
  y = cmplxz(c2, fzero) / x;
  y0 = std::sqrt(x);
  if (ixa != 1) {
    y0 = y0 * std::exp(x);
  }
  y1 = y * y;
  y2 = y1 * y;
  y3 = y2 * y;
  y4 = y3 * y;
  y5 = y4 * y;
  bk0 = (1.25331414 - 0.07832358 * y + 0.02189568 * y1 -
    0.01062446 * y2 + 0.00587872 * y3 - 0.00251540 * y4 +
    0.00053208 * y5) / y0;
  bk1 = (1.25331414 + 0.23498619 * y - 0.03655620 * y1 +
    0.01504268 * y2 - 0.00780353 * y3 + 0.00325614 * y4 -
    0.00068245 * y5) / y0;
  statement_40:
  bbin(1) = bi0;
  bbin(2) = bj1;
  bbkn(1) = bk0;
  bbkn(2) = bk1;
  if (iprs47 >= 5) {
    write(logsix,
      "(/,' SCALARS.',7x,'REAL-BI0',7x,'IMAG-BI0',7x,'REAL-BJ1',7x,'IMAG-BJ1',"
      "7x,'REAL-BK0',7x,'IMAG-BK0',7x,'REAL-BK1',7x,'IMAG-BK1',/,9x,8e15.6)"),
      bi0, bj1, bk0, bk1;
  }
  if (ikm == 1) {
    goto statement_70;
  }
  FEM_DO_SAFE(ikn, 3, kn) {
    bbin(ikn) = creal1;
    bbkn(ikn) = creal1;
  }
  if (ikm == 3) {
    goto statement_60;
  }
  FEM_DO_SAFE(ikn, 3, kn) {
    ik1 = ikn - 1;
    ik2 = ikn - 2;
    bbin(ikn) = bbin(ik2) - 2. * ik2 / x * bbin(ik1);
  }
  if (ikm == 2) {
    goto statement_70;
  }
  statement_60:
  FEM_DO_SAFE(ikn, 3, kn) {
    ik1 = ikn - 1;
    ik2 = ikn - 2;
    bbkn(ikn) = bbkn(ik2) + 2. * ik2 / x * bbkn(ik1);
  }
  statement_70:
  if (iprs47 >= 6) {
    {
      write_loop wloop(cmn, logsix,
        "(/,' EXIT    ''BSIKM'' .',5x,'ROW',11x,'REAL-BBIN',11x,'IMAG-BBIN',"
        "11x,'REAL-BBKN',11x,'IMAG-BBKN',/(18x,i8,4e20.11))");
      FEM_DO_SAFE(L, 1, kn) {
        wloop, L, bbin(L), bbkn(L);
      }
    }
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
zegen(
  common& cmn,
  double const& be1,
  double const& be2,
  double const& th,
  double const& w,
  std::complex<double>& xe,
  int const& isyst) try
{
  common_write write(cmn);
  auto& bin = cmn.bin;
  auto& bkn = cmn.bkn;
  double& fzero = cmn.fzero;
  double& pai = cmn.pai;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  double unity = fem::double0;
  std::complex<double> c1 = fem::double0;
  std::complex<double> cj = fem::double0;
  double euc = fem::double0;
  double d1 = fem::double0;
  double sq2 = fem::double0;
  int ll1 = fem::int0;
  int ll2 = fem::int0;
  std::complex<double> cjw = fem::double0;
  std::complex<double> x1 = fem::double0;
  std::complex<double> x2 = fem::double0;
  int ixa = fem::int0;
  double xa = fem::double0;
  double xa1 = fem::double0;
  double e = fem::double0;
  double r2 = fem::double0;
  double r1 = fem::double0;
  double sn = fem::double0;
  double bn = fem::double0;
  double cn = fem::double0;
  double dn = fem::double0;
  double en = fem::double0;
  double fn = fem::double0;
  int iter = fem::int0;
  int i = fem::int0;
  double t = fem::double0;
  double t1 = fem::double0;
  double t2 = fem::double0;
  double cs1 = fem::double0;
  double ss1 = fem::double0;
  double cs2 = fem::double0;
  double ss2 = fem::double0;
  double cs3 = fem::double0;
  double cs4 = fem::double0;
  double a1 = fem::double0;
  double a2 = fem::double0;
  double a3 = fem::double0;
  double a4 = fem::double0;
  double b1 = fem::double0;
  double b2 = fem::double0;
  double b3 = fem::double0;
  double b4 = fem::double0;
  double evennn = fem::double0;
  double t3 = fem::double0;
  double t4 = fem::double0;
  double t5 = fem::double0;
  double t6 = fem::double0;
  double t7 = fem::double0;
  double t8 = fem::double0;
  double verbin = fem::double0;
  double p1 = fem::double0;
  double q1 = fem::double0;
  unity = 1.0f;
  c1 = cmplxz(cmn.u2p, fzero);
  cj = cmn.cimag1;
  euc = 2.f / cmn.value4;
  d1 = 2.0f;
  sq2 = sqrtz(d1);
  ll1 = 1;
  ll2 = 2;
  if (isyst >= 0) {
    goto statement_140;
  }
  cjw = cj * cmplxz(w, fzero);
  xe = std::sqrt(cjw);
  x1 = cmplxz(be1, fzero) * xe;
  x2 = cmplxz(be2, fzero) * xe;
  ixa = 0;
  xa = std::abs(x2);
  if (xa > 10.f) {
    ixa = 1;
  }
  bsikm(cmn, x1, ll2, bin, bkn, ll1, ixa);
  xe = bkn(1);
  if (xa > 100.f) {
    goto statement_130;
  }
  bsikm(cmn, x2, ll2, bin, bkn, ll1, ixa);
  if (ixa > 0) {
    goto statement_120;
  }
  xe = cjw * c1 * (xe - bkn(1));
  goto statement_5;
  statement_120:
  xe = cjw * c1 * (xe - bkn(1) / std::exp(x2 - x1)) / std::exp(x1);
  goto statement_5;
  statement_130:
  xa1 = std::abs(x1);
  if (xa1 > cmn.pekexp) {
    goto statement_140;
  }
  xe = cjw * c1 * xe / std::exp(x1);
  goto statement_5;
  statement_140:
  xe = cmn.czero;
  statement_5:
  e = be2 * sqrtz(w);
  if (iprs47 >= 2) {
    write(logsix,
      "(/,' WITHIN  ''ZEGEN'' .','   ISYST     IXA',16x,'BE1',16x,'BE2',17x,"
      "'XA',17x,'TH',16x,'XA1',/,18x,2i8,5e19.10,/,1x,13x,'REAL-XE',13x,"
      "'IMAG-XE',19x,'W',19x,'E',/,1x,4e20.11)"),
      isyst, ixa, be1, be2, xa, th, xa1, xe, w, e;
  }
  if (e > 5.f) {
    goto statement_60;
  }
  r2 = fem::pow4(e);
  r1 = r2 / 16.f;
  sn = fem::pow2(e) / 8.f;
  bn = r1 / 12.f;
  cn = e / 3.f;
  dn = 5.f / 4.f;
  en = fem::pow3(e) / 45.f;
  fn = 5.f / 3.f;
  iter = 11;
  if (e >= 1.f) {
    iter = 21;
  }
  iter = 21;
  FEM_DO_SAFE(i, 1, iter) {
    t = i - 1;
    t1 = t * 2.f;
    t2 = t * 4.f;
    cs1 = cosz((t2 + 2.f) * th);
    ss1 = sinz((t2 + 2.f) * th);
    cs2 = cosz((t2 + 4.f) * th);
    ss2 = sinz((t2 + 4.f) * th);
    cs3 = cosz((t2 + 1.f) * th);
    cs4 = cosz((t2 + 3.f) * th);
    if (i > 1) {
      goto statement_30;
    }
    a1 = sn * cs1;
    a2 = sn * ss1;
    a3 = bn * cs2;
    a4 = bn * ss2;
    b1 = cn * cs3;
    b2 = dn * a1;
    b3 = en * cs4;
    b4 = fn * a3;
    evennn = a1 + a2 + a3 + a4 + b1 + b2 + b3 + b4;
    goto statement_50;
    statement_30:
    t3 = -t1 * fem::pow2((t1 + 1.f)) * (t1 + 2.f);
    t4 = -(t1 + 1.f) * fem::pow2((t1 + 2.f)) * (t1 + 3.f);
    t5 = -(t2 - 1.f) * fem::pow2((t2 + 1.f)) * (t2 + 3.f);
    t6 = 1.f / t2 + 1.f / (t1 + 1.f) + 1.f / (t1 + 2.f) - 1.f / (t2 + 4.f);
    t7 = -(t2 + 1.f) * fem::pow2((t2 + 3.f)) * (t2 + 5.f);
    t8 = 1.f / (t2 + 2.f) + 1.f / (t1 + 2.f) + 1.f / (t1 + 3.f) -
      1.f / (t2 + 6.f);
    sn = sn * r1 / t3;
    bn = bn * r1 / t4;
    cn = cn * r2 / t5;
    dn += t6;
    en = en * r2 / t7;
    fn += t8;
    a1 += sn * cs1;
    a2 += sn * ss1;
    a3 += bn * cs2;
    a4 += bn * ss2;
    b1 += cn * cs3;
    b2 += dn * sn * cs1;
    b3 += en * cs4;
    b4 += fn * bn * cs2;
    verbin = evennn;
    evennn = a1 + a2 + a3 + a4 + b1 + b2 + b3 + b4;
    if ((1.f - verbin / evennn) * (1.f - verbin / evennn) < 1.e-12f) {
      goto statement_888;
    }
    statement_50:;
  }
  statement_888:
  p1 = pai * (1.f - a3) / 4.f + a1 * alogz(euc / e) + th * a2 + b2 +
    sq2 * (b3 - b1);
  q1 = 0.5f + (1.f - a3) * alogz(euc / e) - th * a4 - pai * a1 /
    4.f - b4 + sq2 * (b1 + b3);
  goto statement_70;
  statement_60:
  cs1 = sq2 * cosz(th);
  cs2 = cosz(2.f * th) * 2.f;
  cs3 = sq2 * cosz(3.f * th);
  cs4 = 3.f * sq2 * cosz(5.f * th);
  p1 = (cs1 + (cs4 / fem::pow3(e) + cs3 / e - cs2) / e) / e;
  q1 = (cs1 + (cs4 / fem::pow2(e) - cs3) / fem::pow2(e)) / e;
  statement_70:
  xe += cmplxz(w, fzero) * c1 * (cmplxz(p1, fzero) + cj * cmplxz(q1, fzero));
  if (iprs47 >= 2) {
    write(logsix,
      "(/,' EXIT  ''ZEGEN'' .',17x,'P1',17x,'Q1',12x,'REAL-XE',12x,'IMAG-XE',"
      "/,16x,4e19.10)"),
      p1, q1, xe;
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
zest(
  common& cmn,
  double const& h1,
  double const& h2,
  double const& e,
  double const& res,
  double const& omg,
  std::complex<double>& s) try
{
  common_write write(cmn);
  std::complex<double>& czero = cmn.czero;
  double& alf1 = cmn.alf1;
  double& alf2 = cmn.alf2;
  double& dep1 = cmn.dep1;
  double& dep2 = cmn.dep2;
  double& hyud2 = cmn.hyud2;
  double& hyud3 = cmn.hyud3;
  double& hyud4 = cmn.hyud4;
  double& htoj2 = cmn.htoj2;
  double& htoj3 = cmn.htoj3;
  double& fzero = cmn.fzero;
  double& htoj4 = cmn.htoj4;
  double& pai = cmn.pai;
  double& u0 = cmn.u0;
  double& value5 = cmn.value5;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  double toj = fem::double0;
  double hkr = fem::double0;
  double yud = fem::double0;
  double h1ph2 = fem::double0;
  double ab = fem::double0;
  double omg2 = fem::double0;
  double d1 = fem::double0;
  std::complex<double> rom = fem::double0;
  double bp = fem::double0;
  double rmax = fem::double0;
  int L = fem::int0;
  double ram = fem::double0;
  double ram2 = fem::double0;
  double d2 = fem::double0;
  std::complex<double> c1 = fem::double0;
  std::complex<double> c2 = fem::double0;
  std::complex<double> s1 = fem::double0;
  double d3 = fem::double0;
  std::complex<double> c3 = fem::double0;
  std::complex<double> c4 = fem::double0;
  std::complex<double> s2 = fem::double0;
  double d4 = fem::double0;
  std::complex<double> c5 = fem::double0;
  std::complex<double> c6 = fem::double0;
  std::complex<double> s3 = fem::double0;
  std::complex<double> s6 = fem::double0;
  std::complex<double> s5 = fem::double0;
  double d5 = fem::double0;
  double d6 = fem::double0;
  double d7 = fem::double0;
  std::complex<double> s8 = fem::double0;
  std::complex<double> sp12 = fem::double0;
  std::complex<double> sp23 = fem::double0;
  std::complex<double> sm12 = fem::double0;
  double d8 = fem::double0;
  std::complex<double> c7 = fem::double0;
  std::complex<double> sm23 = fem::double0;
  double d9 = fem::double0;
  std::complex<double> c8 = fem::double0;
  std::complex<double> bbb = fem::double0;
  double d10 = fem::double0;
  double contwo = fem::double0;
  std::complex<double> z = fem::double0;
  std::complex<double> u1 = fem::double0;
  int jd = fem::int0;
  double rmin = fem::double0;
  std::complex<double> u2 = fem::double0;
  int jjj = fem::int0;
  std::complex<double> qq = fem::double0;
  int n = fem::int0;
  double dx = fem::double0;
  double d11 = fem::double0;
  std::complex<double> sq1 = fem::double0;
  double dx2 = fem::double0;
  int kn = fem::int0;
  std::complex<double> u = fem::double0;
  double d12 = fem::double0;
  std::complex<double> sq3 = fem::double0;
  std::complex<double> sa = fem::double0;
  double r = fem::double0;
  double v5 = fem::double0;
  double c9 = fem::double0;
  toj = u0;
  if (iprs47 >= 2) {
    write(logsix,
      "(/,' ENTER  ''ZEST'' .',18x,'H1',18x,'H2',19x,'E',17x,'RES',17x,'OMG',"
      "/,16x,5e20.11)"),
      h1, h2, e, res, omg;
  }
  hkr = fem::pow2(cmn.spdlgt);
  yud = 1.f / toj / hkr;
  h1ph2 = h1 + h2;
  ab = 10.f * e / h1ph2;
  omg2 = omg * omg;
  d1 = toj * omg / res;
  rom = cmplxz(fzero, d1);
  bp = pai / 2.f;
  rmax = 0.f;
  s = czero;
  L = 2;
  ram = 0.f;
  statement_700:
  ram2 = ram * ram;
  d2 = ram2 + omg2 * (1.f - htoj2 * hyud2) / hkr;
  c1 = cmplxz(d2, fzero);
  c2 = rom * cmplxz(htoj2, fzero);
  s1 = std::sqrt(c1 + c2);
  d3 = ram2 + omg2 * (1.f - htoj3 * hyud3) / hkr;
  c3 = cmplxz(d3, fzero);
  c4 = cmplxz(alf1, fzero) * rom * cmplxz(htoj3, fzero);
  s2 = std::sqrt(c3 + c4);
  d4 = ram2 + omg2 * (1.f - htoj4 * hyud4) / hkr;
  c5 = cmplxz(d4, fzero);
  c6 = cmplxz(alf2, fzero) * rom * cmplxz(htoj4, fzero);
  s3 = std::sqrt(c5 + c6);
  s6 = s2;
  s5 = s1;
  d5 = 1.f / htoj2 / toj;
  s1 = s1 * cmplxz(d5, fzero);
  d6 = 1.f / htoj3 / toj;
  s2 = s2 * cmplxz(d6, fzero);
  d7 = 1.f / htoj4 / toj;
  s3 = s3 * cmplxz(d7, fzero);
  s8 = cmplxz(toj, fzero) * s1;
  sp12 = s1 + s2;
  sp23 = s2 + s3;
  sm12 = s1 - s2;
  d8 = 2.f * (dep1 - dep2);
  c7 = cmplxz(d8, fzero);
  sm23 = (s2 - s3) * std::exp(s6 * c7);
  d9 = -2.f * dep1;
  c8 = cmplxz(d9, fzero);
  bbb = std::exp(s5 * c8);
  d10 = expz(-h1ph2 * ram) * cosz(e * ram);
  contwo = 2.0f;
  z = cmplxz(fzero, contwo) * (sp12 * sp23 + sm12 * sm23 + bbb * (
    sm12 * sp23 + sp12 * sm23)) * cmplxz(d10, fzero) / ((cmplxz(ram,
    fzero) + s8) * (sp12 * sp23 + sm12 * sm23) + (cmplxz(ram,
    fzero) - s8) * bbb * (sm12 * sp23 + sp12 * sm23));
  if (iprs47 >= 5) {
    write(logsix,
      "(/,1x,'       L',18x,'BP',18x,'AB',17x,'RAM',16x,'RMAX',14x,'REAL-Z',"
      "14x,'IMAG-Z',/,1x,i8,6e20.11)"),
      L, bp, ab, ram, rmax, z;
  }
  switch (L) {
    case 1: goto statement_702;
    case 2: goto statement_701;
    default: break;
  }
  statement_701:
  u1 = z;
  jd = 50;
  goto statement_650;
  statement_600:
  u1 = czero;
  statement_650:
  if (bp < ab) {
    goto statement_300;
  }
  jd = 100;
  rmin = rmax;
  rmax = 10.f / h1ph2;
  L = 1;
  ram = rmax;
  goto statement_700;
  statement_702:
  u2 = z;
  goto statement_210;
  statement_300:
  rmin = rmax;
  rmax = bp / e;
  bp += pai;
  u2 = czero;
  statement_210:
  jjj = 1;
  qq = u1 + u2;
  n = 123;
  dx = rmax - rmin;
  d11 = dx / 2.f;
  sq1 = qq * cmplxz(d11, fzero);
  if (iprs47 >= 6) {
    write(logsix,
      "(/,1x,14x,'DX',11x,'HTOJ2',12x,'RMIN',12x,'OMG2',13x,'TOJ',10x,"
      "'VALUE5',9x,'REAL-QQ',9x,'IMAG-QQ',/,1x,8e16.7)"),
      dx, htoj2, rmin, omg2, toj, value5, qq;
  }
  statement_75:
  dx2 = dx;
  dx = dx / 2.0f;
  ram = rmin + dx;
  n = 2 * n;
  if (jjj == 1) {
    n = 1;
  }
  jjj = 100;
  FEM_DO_SAFE(kn, 1, n) {
    ram2 = ram * ram;
    d2 = ram2 + omg2 * (1.f - htoj2 * hyud2) / hkr;
    c1 = cmplxz(d2, fzero);
    c2 = rom * cmplxz(htoj2, fzero);
    s1 = std::sqrt(c1 + c2);
    d3 = ram2 + omg2 * (1.f - htoj3 * hyud3) / hkr;
    c3 = cmplxz(d3, fzero);
    c4 = cmplxz(alf1, fzero) * rom * cmplxz(htoj3, fzero);
    s2 = std::sqrt(c3 + c4);
    d4 = ram2 + omg2 * (1.f - htoj4 * hyud4) / hkr;
    c5 = cmplxz(d4, fzero);
    c6 = cmplxz(alf2, fzero) * rom * cmplxz(htoj4, fzero);
    s3 = std::sqrt(c5 + c6);
    s6 = s2;
    s5 = s1;
    d5 = 1.f / htoj2 / toj;
    s1 = s1 * cmplxz(d5, fzero);
    d6 = 1.f / htoj3 / toj;
    s2 = s2 * cmplxz(d6, fzero);
    d7 = 1.f / htoj4 / toj;
    s3 = s3 * cmplxz(d7, fzero);
    s8 = cmplxz(toj, fzero) * s1;
    sp12 = s1 + s2;
    sp23 = s2 + s3;
    sm12 = s1 - s2;
    d8 = 2.f * (dep1 - dep2);
    c7 = cmplxz(d8, fzero);
    sm23 = (s2 - s3) * std::exp(s6 * c7);
    d9 = -2.f * dep1;
    c8 = cmplxz(d9, fzero);
    bbb = std::exp(s5 * c8);
    d10 = expz(-h1ph2 * ram) * cosz(e * ram);
    z = cmplxz(fzero, contwo) * (sp12 * sp23 + sm12 * sm23 + bbb * (
      sm12 * sp23 + sp12 * sm23)) * cmplxz(d10, fzero) / ((cmplxz(ram,
      fzero) + s8) * (sp12 * sp23 + sm12 * sm23) + (cmplxz(ram,
      fzero) - s8) * bbb * (sm12 * sp23 + sp12 * sm23));
    ram += dx2;
    u = 2. * z;
    qq += u;
  }
  d12 = dx / 2.f;
  sq3 = qq * cmplxz(d12, fzero);
  sa = sq1 - sq3;
  r = std::abs(sa) / std::abs(sq3);
  v5 = value5 * .5f;
  if (iprs47 >= 24) {
    write(logsix,
      "(/,' BOTTOM LOOP.','       N',19x,'R',18x,'DX',17x,'RAM',13x,'REAL-QQ',"
      "13x,'IMAG-QQ',/,13x,i8,5e20.11)"),
      n, r, dx, ram, qq;
  }
  if (r <= v5) {
    goto statement_50;
  }
  sq1 = sq3;
  goto statement_75;
  statement_50:
  s += sq3;
  if (jd == 100) {
    goto statement_55;
  }
  goto statement_600;
  statement_55:
  c9 = .5f * u0 / pai;
  s = s * cmplxz(omg, fzero) * cmplxz(c9, fzero);
  if (iprs47 >= 2) {
    write(logsix,
      "(/,' EXIT  ''ZEST'' .',17x,'OMG',14x,'VALUE2',14x,'REAL-S',14x,"
      "'IMAG-S',/,15x,4e20.11)"),
      omg, cmn.value2, s;
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
sczy1(
  common& cmn,
  double const& w,
  int const& isyst,
  arr_cref<double, 2> zy,
  arr_cref<double, 2> dir,
  arr_cref<double, 2> dij,
  arr_cref<double, 2> ang,
  arr_cref<double> hi,
  arr_cref<double> di,
  arr_ref<std::complex<double>, 2> zs,
  arr_ref<std::complex<double>, 2> ze,
  int const& ldm,
  int const& ldn) try
{
  zy(dimension(ldn, ldn));
  dir(dimension(ldm, ldm));
  dij(dimension(ldm, ldm));
  ang(dimension(ldm, ldm));
  hi(dimension(ldm));
  di(dimension(ldn));
  zs(dimension(ldn, ldn));
  ze(dimension(ldn, ldn));
  common_write write(cmn);
  double& fzero = cmn.fzero;
  double& roe = cmn.roe;
  double& u0 = cmn.u0;
  double& u2p = cmn.u2p;
  int& iearth = cmn.iearth;
  int& itypec = cmn.itypec;
  int& ncc = cmn.ncc;
  int& npc = cmn.npc;
  int& npc2 = cmn.npc2;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  std::complex<double> cjw = fem::double0;
  double c2 = fem::double0;
  int i = fem::int0;
  int j = fem::int0;
  double c1 = fem::double0;
  double be1 = fem::double0;
  double be2 = fem::double0;
  double th = fem::double0;
  std::complex<double> xe = fem::double0;
  double d12 = fem::double0;
  int ll0 = fem::int0;
  int i1 = fem::int0;
  int j1 = fem::int0;
  cjw = cmplxz(fzero, w);
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' ENTER  ''SCZY1'' .','   ISYST     NPC  IEARTH  ITYPEC',17x,'ROE',"
      "18x,'U0',19x,'W',/,17x,4i8,3e20.11)"),
      isyst, npc, iearth, itypec, roe, u0, w;
  }
  c2 = u2p * zy(1, 1);
  if (itypec == 3) {
    goto statement_50;
  }
  if (isyst ==  - 1) {
    goto statement_35;
  }
  FEM_DO_SAFE(i, 1, npc) {
    FEM_DO_SAFE(j, 1, npc) {
      c1 = u2p * zy(i, j);
      zs(i, j) = cjw * cmplxz(c1, fzero);
    }
  }
  statement_35:
  FEM_DO_SAFE(i, 1, npc) {
    FEM_DO_SAFE(j, 1, npc) {
      if (j < i) {
        goto statement_40;
      }
      if (iearth == 99) {
        goto statement_37;
      }
      be1 = dir(i, j) * sqrtz(u0 / roe);
      if (isyst !=  - 1) {
        be1 = 0.f;
      }
      be2 = dij(i, j) * sqrtz(u0 / roe);
      th = ang(i, j);
      zegen(cmn, be1, be2, th, w, xe, isyst);
      goto statement_38;
      statement_37:
      d12 = std::abs(di(j) - di(i));
      zest(cmn, hi(i), hi(j), d12, roe, w, xe);
      statement_38:
      ze(i, j) = xe;
      ze(j, i) = xe;
      statement_40:;
    }
  }
  if (iprs47 >= 2) {
    write(logsix,
      "(/,' DIAGNOSTIC WITHIN  ''SCZY1'' ,   ZE(I,J)  FOR',"
      "'(I,J)=1, ... NPC .')");
  }
  ll0 = 0;
  if (iprs47 >= 4) {
    print(cmn, ze(1, 1), npc, ll0, ldn);
  }
  if (npc == ncc) {
    goto statement_90;
  }
  if (isyst ==  - 1) {
    goto statement_45;
  }
  FEM_DO_SAFE(i, 1, ncc) {
    FEM_DO_SAFE(j, 1, ncc) {
      if (j < i) {
        goto statement_43;
      }
      i1 = i;
      j1 = j;
      if (i1 > npc2) {
        i1 = i - npc2;
      }
      if (i1 > npc) {
        i1 = i - npc;
      }
      if (j1 > npc2) {
        j1 = j - npc2;
      }
      if (j1 > npc) {
        j1 = j - npc;
      }
      zs(i, j) = zs(i1, j1);
      zs(j, i) = zs(i, j);
      statement_43:;
    }
  }
  statement_45:
  FEM_DO_SAFE(i, 1, ncc) {
    FEM_DO_SAFE(j, 1, ncc) {
      if (j < i) {
        goto statement_47;
      }
      i1 = i;
      j1 = j;
      if (i1 > npc2) {
        i1 = i - npc2;
      }
      if (i1 > npc) {
        i1 = i - npc;
      }
      if (j1 > npc2) {
        j1 = j - npc2;
      }
      if (j1 > npc) {
        j1 = j - npc;
      }
      ze(i, j) = ze(i1, j1);
      ze(j, i) = ze(i, j);
      statement_47:;
    }
  }
  goto statement_90;
  statement_50:
  if (isyst ==  - 1) {
    goto statement_60;
  }
  if (cmn.npp == 0) {
    goto statement_90;
  }
  FEM_DO_SAFE(i, 1, ncc) {
    FEM_DO_SAFE(j, 1, ncc) {
      if (j < i) {
        goto statement_55;
      }
      zs(i, j) = cjw * cmplxz(c2, fzero);
      zs(j, i) = zs(i, j);
      statement_55:;
    }
  }
  statement_60:
  be1 = dir(1, 1) * sqrtz(u0 / roe);
  if (isyst !=  - 1) {
    be1 = 0.f;
  }
  be2 = dij(1, 1) * sqrtz(u0 / roe);
  th = ang(1, 1);
  zegen(cmn, be1, be2, th, w, xe, isyst);
  FEM_DO_SAFE(i, 1, ncc) {
    FEM_DO_SAFE(j, 1, ncc) {
      ze(i, j) = xe;
    }
  }
  statement_90:
  if (iprs47 >= 2) {
    write(logsix,
      "(/,' DIAGNOSTIC AT EXIT  ''SCZY1'' .   ZS(I,J)  FOR',"
      "'  (I,J)=1, ... NPC .    REAL-XE =',e20.11,4x,'IMAG-XE =',e20.11)"),
      xe;
  }
  if (iprs47 >= 4) {
    print(cmn, zs(1, 1), npc, ll0, ldn);
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
sczy2(
  common& cmn,
  std::complex<double> const& s,
  arr_cref<int> ncpp,
  arr_cref<double, 2> radi,
  arr_cref<double, 2> usi,
  arr_cref<double, 2> usr,
  arr_cref<double> bio,
  arr_cref<double> bi1,
  arr_cref<double> bi2,
  arr_cref<double> bi3,
  arr_cref<double> bi4,
  arr_cref<double> bi5,
  arr_cref<double> al1i,
  arr_cref<double> al2i,
  arr_cref<double> al3i,
  arr_ref<std::complex<double>, 2> zc,
  int const& ldm,
  int const& ldn) try
{
  ncpp(dimension(ldm));
  radi(dimension(ldm, 7));
  usi(dimension(ldm, 3));
  usr(dimension(ldm, 3));
  bio(dimension(ldm));
  bi1(dimension(ldm));
  bi2(dimension(ldm));
  bi3(dimension(ldm));
  bi4(dimension(ldm));
  bi5(dimension(ldm));
  al1i(dimension(ldm));
  al2i(dimension(ldm));
  al3i(dimension(ldm));
  zc(dimension(ldn, ldn));
  common_write write(cmn);
  auto& bin = cmn.bin;
  auto& bkn = cmn.bkn;
  std::complex<double>& czero = cmn.czero;
  double& fzero = cmn.fzero;
  double& u2p = cmn.u2p;
  int& npc = cmn.npc;
  int& npc2 = cmn.npc2;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  double& pekexp = cmn.pekexp;
  //
  int ll1 = fem::int0;
  int ll2 = fem::int0;
  int inm = fem::int0;
  int i = fem::int0;
  double b0 = fem::double0;
  double b1 = fem::double0;
  double b2 = fem::double0;
  double b3 = fem::double0;
  double b4 = fem::double0;
  double b5 = fem::double0;
  double al1 = fem::double0;
  double al2 = fem::double0;
  double al3 = fem::double0;
  std::complex<double> ss = fem::double0;
  std::complex<double> c1 = fem::double0;
  std::complex<double> s0 = fem::double0;
  std::complex<double> s1 = fem::double0;
  std::complex<double> s2 = fem::double0;
  std::complex<double> s3 = fem::double0;
  std::complex<double> su0 = fem::double0;
  int ixa = fem::int0;
  double xa = fem::double0;
  std::complex<double> z11 = fem::double0;
  std::complex<double> s4 = fem::double0;
  std::complex<double> s5 = fem::double0;
  std::complex<double> s6 = fem::double0;
  std::complex<double> z12 = fem::double0;
  std::complex<double> s7 = fem::double0;
  double d1 = fem::double0;
  std::complex<double> z2i = fem::double0;
  std::complex<double> z2m = fem::double0;
  std::complex<double> z2o = fem::double0;
  std::complex<double> z23 = fem::double0;
  std::complex<double> z3i = fem::double0;
  std::complex<double> z3m = fem::double0;
  std::complex<double> z3o = fem::double0;
  std::complex<double> z34 = fem::double0;
  int ido = fem::int0;
  std::complex<double> s8 = fem::double0;
  std::complex<double> c2 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  std::complex<double> c3 = fem::double0;
  int i1 = fem::int0;
  int i2 = fem::int0;
  ll1 = 1;
  ll2 = 2;
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' ENTER  ''SCZY2'' .','     NPC',14x,'REAL-S',14x,'IMAG-S',/,17x,i8,"
      "2e20.11)"),
      npc, s;
  }
  inm = 0;
  FEM_DO_SAFE(i, 1, npc) {
    b0 = bio(i);
    b1 = bi1(i);
    b2 = bi2(i);
    b3 = bi3(i);
    b4 = bi4(i);
    b5 = bi5(i);
    al1 = al1i(i);
    al2 = al2i(i);
    al3 = al3i(i);
    ss = std::sqrt(s);
    c1 = cmplxz(b0, fzero);
    s0 = c1 * ss;
    c1 = cmplxz(b1, fzero);
    s1 = c1 * ss;
    c1 = cmplxz(b2, fzero);
    s2 = c1 * ss;
    c1 = cmplxz(b3, fzero);
    s3 = c1 * ss;
    c1 = cmplxz(u2p, fzero);
    su0 = s * c1;
    if (iprs47 >= 2) {
      write(logsix,
        "(/,' RE-LOOP OVER  ''I'' .','       I',18x,'B0',12x,'REAL-SU0',12x,"
        "'IMAG-SU0',13x,'REAL-S0',13x,'IMAG-S0',/,19x,i8,5e20.11)"),
        i, b0, su0, s0;
    }
    c1 = cmplxz(usr(i, 1), fzero);
    ixa = 0;
    xa = std::abs(s0);
    if (radi(i, 1) <= 0.f) {
      xa = std::abs(s1);
    }
    if (xa > 10.f) {
      ixa = 1;
    }
    bsikm(cmn, s1, ll2, bin, bkn, ll1, ixa);
    if (radi(i, 1) > 0.f) {
      goto statement_15;
    }
    z11 = su0 / s1 * bin(1) / bin(2) * c1;
    goto statement_25;
    statement_15:
    s4 = bin(1);
    s5 = bin(2);
    s6 = bkn(1);
    z12 = bkn(2);
    bsikm(cmn, s0, ll2, bin, bkn, ll1, ixa);
    if (ixa > 0) {
      goto statement_20;
    }
    ss = s5 * bkn(2) - z12 * bin(2);
    z11 = su0 / s1 * (bkn(2) * s4 + s6 * bin(2)) / ss * c1;
    goto statement_25;
    statement_20:
    ss = s1 - s0;
    if (std::abs(ss) > pekexp) {
      goto statement_23;
    }
    ss = std::exp(ss);
    s7 = s5 * bkn(2) * ss - z12 * bin(2) / ss;
    z11 = su0 / s1 * (bkn(2) * s4 * ss + s6 * bin(2) / ss) / s7 * c1;
    goto statement_25;
    statement_23:
    z11 = su0 / s1 * s4 / s5 * c1;
    statement_25:
    d1 = usi(i, 1) * al1;
    c1 = cmplxz(d1, fzero);
    z12 = su0 * c1;
    z2i = czero;
    z2m = czero;
    z2o = czero;
    d1 = usi(i, 2) * al2;
    c1 = cmplxz(d1, fzero);
    z23 = su0 * c1;
    if (iprs47 >= 3) {
      write(logsix,
        "(/,1x,'     IXA NCPP(I)',11x,'RADI(I,1)',12x,'REAL-Z11',12x,"
        "'IMAG-Z11',12x,'REAL-Z12',12x,'IMAG-Z12',/,1x,2i8,5e20.11)"),
        ixa, ncpp(i), radi(i, 1), z11, z12;
    }
    z3i = czero;
    z3m = czero;
    z3o = czero;
    d1 = usi(i, 3) * al3;
    c1 = cmplxz(d1, fzero);
    z34 = su0 * c1;
    if (ncpp(i) == 1) {
      goto statement_90;
    }
    ido = 2;
    statement_28:
    ixa = 0;
    xa = std::abs(s2);
    if (xa > 10) {
      ixa = 1;
    }
    bsikm(cmn, s2, ll2, bin, bkn, ll1, ixa);
    s4 = bin(1);
    s5 = bin(2);
    s1 = bkn(1);
    s0 = bkn(2);
    bsikm(cmn, s3, ll2, bin, bkn, ll1, ixa);
    c1 = cmplxz(usr(i, ido), fzero);
    if (ixa > 0) {
      goto statement_35;
    }
    ss = bin(2) * s0 - s5 * bkn(2);
    s7 = su0 / s2 * (s4 * bkn(2) + s1 * bin(2)) / ss * c1;
    s8 = su0 / s3 * (bin(1) * s0 + bkn(1) * s5) / ss * c1;
    goto statement_40;
    statement_35:
    s6 = s3 - s2;
    if (std::abs(s6) > pekexp) {
      goto statement_42;
    }
    s6 = std::exp(s6);
    ss = bin(2) * s0 * s6 - s5 * bkn(2) / s6;
    s7 = su0 / s2 * (s4 * bkn(2) / s6 + s1 * bin(2) * s6) / ss * c1;
    s8 = su0 / s3 * (bin(1) * s0 * s6 + bkn(1) * s5 / s6) / ss * c1;
    statement_40:
    if (ido != 2) {
      goto statement_41;
    }
    d1 = u2p * radi(i, 3) / radi(i, 4) / b2 / b2 * usr(i, 2);
    c2 = cmplxz(d1, fzero);
    z2m = c2 / ss;
    goto statement_44;
    statement_41:
    d1 = u2p * radi(i, 5) / radi(i, 6) / b4 / b4 * usr(i, 3);
    c2 = cmplxz(d1, fzero);
    if (ido == 3) {
      z3m = c2 / ss;
    }
    goto statement_44;
    statement_42:
    s7 = su0 / s2 * s1 / s0 * c1;
    s8 = su0 / s3 * bin(1) / bin(2) * c1;
    z2m = czero;
    z3m = czero;
    statement_44:
    if (iprs47 >= 3) {
      write(logsix,
        "(/,1x,8x,'REAL-Z2I',8x,'IMAG-Z2I',8x,'REAL-Z2O',8x,'IMAG-Z2O',8x,"
        "'REAL-Z2M',8x,'IMAG-Z2M',8x,'REAL-Z23',8x,'IMAG-Z23',/,1x,8e16.7)"),
        z2i, z2o, z2m, z23;
    }
    if (ido == 3) {
      goto statement_60;
    }
    z2i = s7;
    z2o = s8;
    z3i = czero;
    z3m = czero;
    z3o = czero;
    z34 = czero;
    if (ncpp(i) == 2) {
      goto statement_90;
    }
    ss = std::sqrt(s);
    c1 = cmplxz(b4, fzero);
    s2 = c1 * ss;
    c1 = cmplxz(b5, fzero);
    s3 = c1 * ss;
    ido = 3;
    goto statement_28;
    statement_60:
    z3i = s7;
    z3o = s8;
    statement_90:
    s1 = z11 + z12 + z2i;
    s2 = z2o + z23 + z3i;
    s3 = z3o + z34;
    s4 = s3 - 2. * z3m;
    s5 = s3 - z3m;
    s6 = s2 + s4;
    s7 = s6 - z2m;
    s8 = cmn.cimag1;
    d1 = std::imag(s5);
    d2 = std::imag(s6);
    d3 = std::imag(s7);
    c1 = cmplxz(d1, fzero);
    c2 = cmplxz(d2, fzero);
    c3 = cmplxz(d3, fzero);
    if (std::real(s5) < 0.f) {
      s5 = s8 * c1;
    }
    if (std::real(s6) < 0.f) {
      s6 = s8 * c2;
    }
    if (std::real(s7) < 0.f) {
      s7 = s8 * c3;
    }
    zc(i, i) = s1 + s2 - 2. * z2m + s4;
    if (ncpp(i) == 1) {
      goto statement_100;
    }
    i1 = i + npc;
    if (i1 > npc2) {
      goto statement_100;
    }
    zc(i1, i1) = s6;
    zc(i, i1) = s7;
    zc(i1, i) = s7;
    if (ncpp(i) == 2) {
      goto statement_100;
    }
    i1 = i + npc2;
    zc(i1, i1) = s3;
    zc(i1, i) = s5;
    zc(i, i1) = s5;
    i2 = i + npc;
    zc(i1, i2) = s5;
    zc(i2, i1) = s5;
    if (iprs47 >= 3) {
      write(logsix,
        "(/,' STORE  ''ZC''  VALUES.',13x,'REAL-S1',13x,'IMAG-S1',13x,"
        "'REAL-S2',13x,'IMAG-S2',/,21x,4e20.11,/,8x,'REAL-ZC(I,I)',8x,"
        "'IMAG-ZC(I,I)',7x,'REAL-ZC(I,I1)',7x,'IMAG-ZC(I,I1)',/,1x,4e20.11)"),
        s1, s2, zc(i, i), zc(i, i1);
    }
    statement_100:;
  }
  if (iprs47 >= 1) {
    write(logsix, "(/,' EXIT  ''SCZY2'' .')");
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
ptzy2(
  common& cmn,
  std::complex<double> const& s,
  arr_cref<int> ncpp,
  arr_cref<double> dci,
  arr_cref<double, 2> dr0,
  arr_cref<double, 2> th0,
  arr_cref<double, 2> al0,
  arr_ref<std::complex<double>, 2> zp,
  arr_ref<std::complex<double>, 2> zpc,
  int const& ldm,
  int const& ldn) try
{
  ncpp(dimension(ldm));
  dci(dimension(ldm));
  dr0(dimension(ldm, ldm));
  th0(dimension(ldm, ldm));
  al0(dimension(ldm, ldm));
  zp(dimension(ldn, ldn));
  zpc(dimension(ldn, ldn));
  common_write write(cmn);
  auto& bin = cmn.bin;
  auto& bkn = cmn.bkn;
  std::complex<double>& czero = cmn.czero;
  double& e2p = cmn.e2p;
  const auto& radp = cmn.radp;
  double& alpi = cmn.alpi;
  double& usp = cmn.usp;
  double& fzero = cmn.fzero;
  double& pai = cmn.pai;
  double& u2p = cmn.u2p;
  int& ncc = cmn.ncc;
  int& npc = cmn.npc;
  int& npc2 = cmn.npc2;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  int& npp = cmn.npp;
  //
  double unity = fem::double0;
  double contwo = fem::double0;
  std::complex<double> c3 = fem::double0;
  std::complex<double> c4 = fem::double0;
  double c8 = fem::double0;
  std::complex<double> c6 = fem::double0;
  int ll1 = fem::int0;
  int ll3 = fem::int0;
  int nbess = fem::int0;
  int kn = fem::int0;
  std::complex<double> ss = fem::double0;
  std::complex<double> su0 = fem::double0;
  std::complex<double> se0 = fem::double0;
  std::complex<double> s1 = fem::double0;
  std::complex<double> s2 = fem::double0;
  std::complex<double> zm = fem::double0;
  std::complex<double> zzo = fem::double0;
  int ixa = fem::int0;
  double xa = fem::double0;
  std::complex<double> s3 = fem::double0;
  std::complex<double> s4 = fem::double0;
  std::complex<double> s5 = fem::double0;
  std::complex<double> zzi = fem::double0;
  std::complex<double> s6 = fem::double0;
  int i = fem::int0;
  int j = fem::int0;
  std::complex<double> zi = fem::double0;
  int k = fem::int0;
  int k1 = fem::int0;
  double ak = fem::double0;
  double ck = fem::double0;
  std::complex<double> c1 = fem::double0;
  double c9 = fem::double0;
  std::complex<double> c2 = fem::double0;
  std::complex<double> c5 = fem::double0;
  int i1 = fem::int0;
  int j1 = fem::int0;
  int i2 = fem::int0;
  int j2 = fem::int0;
  int ll0 = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  int nc1 = fem::int0;
  unity = 1.0f;
  contwo = 2.0f;
  c3 = cmplxz(usp, fzero);
  c4 = cmplxz(contwo, fzero);
  c8 = cmn.rop / 2.f / pai / radp(1) / radp(2);
  c6 = cmplxz(c8, fzero);
  ll1 = 1;
  ll3 = 3;
  nbess = 19;
  kn = nbess + 1;
  ss = std::sqrt(s);
  su0 = s * cmplxz(u2p, fzero);
  se0 = s * cmplxz(e2p, fzero);
  s1 = ss * cmplxz(cmn.bp1, fzero);
  s2 = ss * cmplxz(cmn.bp2, fzero);
  zm = czero;
  zzo = su0 * cmplxz(alpi, fzero);
  ixa = 0;
  xa = std::abs(s1);
  if (xa > 10.f) {
    ixa = 1;
  }
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' BEGIN  ''PTZY2'' .','     NPC     NPP',18x,'XA',16x,'ALPI',14x,"
      "'REAL-S',14x,'IMAG-S',/,17x,2i8,4e20.11)"),
      npc, npp, xa, alpi, s;
  }
  if (npp == 0) {
    goto statement_40;
  }
  bsikm(cmn, s2, kn, bin, bkn, ll1, ixa);
  se0 = bin(2);
  s3 = bkn(2);
  s4 = bin(1);
  s5 = bkn(1);
  statement_40:
  bsikm(cmn, s1, kn, bin, bkn, ll3, ixa);
  if (npp != 0) {
    goto statement_42;
  }
  zzi = su0 * c3 * bkn(1) / bkn(2) / s1;
  goto statement_55;
  statement_42:
  if (ixa == 1) {
    goto statement_45;
  }
  ss = se0 * bkn(2) - bin(2) * s3;
  zm = c6 / ss;
  zzo += su0 * c3 / s2 * (s4 * bkn(2) + s5 * bin(2)) / ss;
  zzi = su0 * c3 * (bin(1) * s3 + bkn(1) * se0) / ss / s1;
  goto statement_55;
  statement_45:
  s6 = s2 - s1;
  if (std::abs(s6) > cmn.pekexp) {
    goto statement_50;
  }
  s6 = std::exp(s6);
  ss = se0 * bkn(2) * s6 - bin(2) * s3 / s6;
  zm = c6 / ss;
  zzo += su0 * c3 / s2 * (s4 * bkn(2) * s6 + s5 * bin(2) / s6) / ss;
  zzi = su0 * c3 * (bin(1) * s3 / s6 + bkn(1) * se0 * s6) / ss / s1;
  goto statement_55;
  statement_50:
  zzo += su0 * c3 / s2 * s4 / se0;
  zzi = su0 * c3 * bkn(1) / bkn(2) / s1;
  statement_55:
  FEM_DO_SAFE(i, 1, npc) {
    FEM_DO_SAFE(j, 1, npc) {
      zi = czero;
      if (j < i) {
        goto statement_25;
      }
      if (dci(i) * dci(j) < 1.e-6f) {
        goto statement_21;
      }
      FEM_DO_SAFE(k, 1, nbess) {
        k1 = k + 1;
        ak = k;
        ck = fem::pow(dr0(i, j), k) * cosz(ak * th0(i, j));
        c1 = cmplxz(ck, fzero);
        c9 = ak * (usp + 1.f);
        c2 = cmplxz(c9, fzero);
        zi += c1 / (c2 + s1 * bkn(k) / bkn(k1));
      }
      statement_21:
      c5 = cmplxz(al0(i, j), fzero);
      zp(i, j) = su0 * (c3 * c4 * zi + c5);
      zp(j, i) = zp(i, j);
      statement_25:
      i1 = i + npc;
      j1 = j + npc;
      if (ncpp(i) == 1) {
        goto statement_26;
      }
      zp(i1, j) = zp(i, j);
      zp(i1, j1) = zp(i, j);
      statement_26:
      if (ncpp(j) == 1) {
        goto statement_30;
      }
      zp(i, j1) = zp(i, j);
      i2 = i + npc2;
      j2 = j + npc2;
      if (ncpp(i) == 2) {
        goto statement_27;
      }
      zp(i2, j) = zp(i, j);
      zp(i2, j2) = zp(i, j);
      zp(i2, j1) = zp(i, j);
      statement_27:
      if (ncpp(j) == 2) {
        goto statement_30;
      }
      zp(i, j2) = zp(i, j);
      zp(i1, j2) = zp(i, j);
      statement_30:;
    }
  }
  if (iprs47 >= 2) {
    {
      write_loop wloop(cmn, logsix,
        "(/,' MIDDLE.',8x,'REAL-ZP(1,1)',8x,'IMAG-ZP(1,1)',8x,'REAL-ZP(1,2)',"
        "8x,'IMAG-ZP(1,2)',8x,'REAL-ZP(1,3)',8x,'IMAG-ZP(1,3)',/,8x,6e20.11,/,"
        "' DIAGNOSTIC   ZP(I,J)  FOR  (I,J)=1, ... NPC .')");
      FEM_DO_SAFE(j, 1, 3) {
        wloop, zp(1, j);
      }
    }
  }
  ll0 = 0;
  if (iprs47 >= 5) {
    print(cmn, zp(1, 1), npc, ll0, ldn);
  }
  if (npp == 0) {
    goto statement_90;
  }
  s1 = zzi + zzo - 2. * zm;
  s2 = zzo - zm;
  s3 = cmn.cimag1;
  d1 = std::imag(s1);
  d2 = std::imag(s2);
  c1 = cmplxz(d1, fzero);
  c2 = cmplxz(d2, fzero);
  if (std::real(s1) < 0.f) {
    s1 = s3 * c1;
  }
  if (std::real(s2) < 0.f) {
    s2 = s3 * c2;
  }
  if (iprs47 >= 3) {
    write(logsix,
      "(/,' PIPE.',13x,'REAL-SS',13x,'IMAG-SS',13x,'REAL-ZM',13x,'IMAG-ZM',"
      "12x,'REAL-ZZO',12x,'IMAG-ZZO',/,6x,6e20.11)"),
      ss, zm, zzo;
  }
  nc1 = ncc - npp;
  if (iprs47 > 1) {
    write(logsix,
      "(/,' MORE PIPE.','     NCC     NC1     IXA',13x,'REAL-S1',13x,"
      "'IMAG-S1',13x,'REAL-S2',13x,'IMAG-S2',/,11x,3i8,4e20.11)"),
      ncc, nc1, ixa, s1, s2;
  }
  FEM_DO_SAFE(i, 1, nc1) {
    zp(i, ncc) = czero;
    zp(ncc, i) = czero;
    zpc(i, ncc) = s2;
    zpc(ncc, i) = s2;
    FEM_DO_SAFE(j, 1, nc1) {
      if (j < i) {
        goto statement_65;
      }
      zpc(i, j) = s1;
      zpc(j, i) = s1;
      statement_65:;
    }
  }
  zp(ncc, ncc) = czero;
  zpc(ncc, ncc) = zzo;
  statement_90:
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' EXIT  ''PTZY2'' .',16x,'USP',16x,'PAI',16x,'U2P',16x,'E2P',11x,"
      "'REAL-SU0',11x,'IMAG-SU0',/,16x,6e19.10)"),
      usp, pai, u2p, e2p, su0;
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
skin47(
  common& cmn,
  double const& b1,
  double const& b2,
  double const& ur,
  std::complex<double> const& cjw,
  std::complex<double> const& sjw,
  std::complex<double>& zcc) try
{
  common_write write(cmn);
  auto& bin = cmn.bin;
  auto& bkn = cmn.bkn;
  double& fzero = cmn.fzero;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  std::complex<double> c1 = fem::double0;
  std::complex<double> c2 = fem::double0;
  std::complex<double> x1 = fem::double0;
  std::complex<double> x2 = fem::double0;
  int ixa = fem::int0;
  double xa = fem::double0;
  int ll1 = fem::int0;
  int ll2 = fem::int0;
  double d15 = fem::double0;
  double xb = fem::double0;
  double ten = fem::double0;
  double d1 = fem::double0;
  std::complex<double> x3 = fem::double0;
  std::complex<double> x4 = fem::double0;
  c1 = cmplxz(cmn.u2p, fzero);
  c2 = cmplxz(ur, fzero);
  x1 = cmplxz(b1, fzero) * sjw;
  x2 = cmplxz(b2, fzero) * sjw;
  ixa = 0;
  xa = std::abs(x2);
  ll1 = 1;
  ll2 = 2;
  d15 = cmn.value1 * cmn.value5 / 100.f;
  if (iprs47 >= 2) {
    write(logsix,
      "(/,' BEGIN  ''SKIN47'' .',18x,'B1',18x,'B2',17x,'D15',18x,'XA',18x,"
      "'XB',/,18x,5e20.11)"),
      b1, b2, d15, xa, xb;
  }
  if (b1 < d15) {
    goto statement_30;
  }
  xb = std::abs(x1);
  ten = 10.f;
  if (xa < ten) {
    goto statement_10;
  }
  d1 = 15.f / 4.f;
  if (xb > d1) {
    ixa = 1;
  }
  statement_10:
  bsikm(cmn, x1, ll2, bin, bkn, ll1, ixa);
  x3 = bin(2);
  x4 = bkn(2);
  bsikm(cmn, x2, ll2, bin, bkn, ll1, ixa);
  if (ixa == 1) {
    goto statement_20;
  }
  zcc = cjw * c1 / x2 * (bin(1) * x4 + bkn(1) * x3) * c2;
  x3 = bin(2) * x4 - bkn(2) * x3;
  goto statement_25;
  statement_20:
  x1 = x2 - x1;
  //CCCC  D2 = 50.                                                          VAX.4797
  if (std::abs(x1) > cmn.pekexp) {
    goto statement_33;
  }
  x1 = std::exp(x1);
  zcc = cjw * c1 / x2 * (bin(1) * x4 * x1 + bkn(1) * x3 / x1) * c2;
  x3 = bin(2) * x4 * x1 - bkn(2) * x3 / x1;
  statement_25:
  zcc = zcc / x3;
  goto statement_40;
  statement_30:
  bsikm(cmn, x2, ll2, bin, bkn, ll1, ll1);
  statement_33:
  zcc = cjw * c1 / x2 * bin(1) / bin(2) * c2;
  statement_40:
  if (iprs47 >= 2) {
    write(logsix,
      "(/,' EXIT  ''SKIN47'' .',18x,'UR',12x,'REAL-CJW',12x,'IMAG-CJW',12x,"
      "'REAL-ZCC',12x,'IMAG-ZCC',/,17x,5e20.11)"),
      ur, cjw, zcc;
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
olzy(
  common& cmn,
  double const& w,
  arr_cref<int> ncpp,
  arr_cref<double, 2> zy,
  arr_cref<double, 2> dij,
  arr_cref<double, 2> ang,
  arr_cref<double, 2> usi,
  arr_cref<double, 2> usr,
  arr_cref<double, 2> esi,
  arr_cref<double> hi,
  arr_cref<double> di,
  arr_ref<std::complex<double>, 2> zs,
  arr_ref<std::complex<double>, 2> ze,
  arr_ref<std::complex<double>, 2> zc,
  int const& ldm,
  int const& ldn) try
{
  ncpp(dimension(ldm));
  zy(dimension(ldn, ldn));
  dij(dimension(ldm, ldm));
  ang(dimension(ldm, ldm));
  usi(dimension(ldm, 3));
  usr(dimension(ldm, 3));
  esi(dimension(ldm, 3));
  hi(dimension(ldm));
  di(dimension(ldn));
  zs(dimension(ldn, ldn));
  ze(dimension(ldn, ldn));
  zc(dimension(ldn, ldn));
  common_write write(cmn);
  double& fzero = cmn.fzero;
  double& roe = cmn.roe;
  double& u0 = cmn.u0;
  double& u2p = cmn.u2p;
  int& iearth = cmn.iearth;
  int& ncct = cmn.ncct;
  int& npc = cmn.npc;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  std::complex<double> s = fem::double0;
  std::complex<double> cwu = fem::double0;
  std::complex<double> ss = fem::double0;
  int ll1 = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  double b1 = fem::double0;
  double b2 = fem::double0;
  double zero = fem::double0;
  std::complex<double> xe = fem::double0;
  double d12 = fem::double0;
  int ll0 = fem::int0;
  int jnc = fem::int0;
  int im = fem::int0;
  int j1 = fem::int0;
  double ur = fem::double0;
  std::complex<double> xc = fem::double0;
  int j2 = fem::int0;
  int k = fem::int0;
  s = cmplxz(fzero, w);
  cwu = s * cmplxz(u2p, fzero);
  ss = std::sqrt(s);
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' BEGIN  ''OLZY'' .','  IEARTH    NCCT',17x,'U2P',19x,'W',13x,"
      "'REAL-SS',13x,'IMAG-SS',/,16x,2i8,4e20.11)"),
      iearth, ncct, u2p, w, ss;
  }
  ll1 = 1;
  FEM_DO_SAFE(i, 1, npc) {
    FEM_DO_SAFE(j, 1, npc) {
      if (j < i) {
        goto statement_20;
      }
      zs(i, j) = cwu * cmplxz(zy(i, j), fzero);
      zs(j, i) = zs(i, j);
      if (iearth == 99) {
        goto statement_15;
      }
      b1 = dij(i, j) * sqrtz(u0 / roe);
      b2 = ang(i, j);
      zero = 0.0f;
      zegen(cmn, zero, b1, b2, w, xe, ll1);
      goto statement_18;
      statement_15:
      d12 = std::abs(di(j) - di(i));
      zest(cmn, hi(i), hi(j), d12, roe, w, xe);
      statement_18:
      ze(i, j) = xe;
      ze(j, i) = xe;
      statement_20:;
    }
  }
  if (iprs47 >= 2) {
    write(logsix,
      "(' DIAGNOSTIC WITHIN  ''OLZY'' .   ZE(I,J)  FOR  (I,J)=1, ... NPC .',"
      "5x,'    NCCT     NPC',13x,'U0',12x,'ROE',/,68x,2i8,2e15.6)"),
      ncct, npc, u0, roe;
  }
  ll0 = 0;
  if (iprs47 >= 4) {
    print(cmn, ze(1, 1), npc, ll0, ldn);
  }
  jnc = 1;
  FEM_DO_SAFE(j, 1, 2) {
    FEM_DO_SAFE(i, 1, ncct) {
      im = 4 * (i - 1) + 1;
      j1 = im + j + 1;
      j1 = ncpp(j1);
      if (j1 == 0) {
        goto statement_40;
      }
      b1 = usi(i, j);
      b2 = esi(i, j);
      ur = usr(i, j);
      skin47(cmn, b1, b2, ur, s, ss, xc);
      xc = xc / double(j1);
      j1 = im + j - 1;
      j1 = ncpp(j1);
      j2 = j1 + jnc - 1;
      FEM_DO_SAFE(k, jnc, j2) {
        zc(k, k) = xc;
      }
      if (iprs47 >= 6) {
        write(logsix,
          "(/,' INSIDE  (J,I)  LOOP OF  ''OLZY'' .',"
          "'       J       I     JNC      J2      J1',13x,'REAL-XC',13x,"
          "'IMAG-XC',/,33x,5i8,2e20.11)"),
          j, i, jnc, j2, j1, xc;
      }
      jnc = j2 + 1;
      statement_40:;
    }
  }
  if (iprs47 >= 1) {
    write(logsix, "(/,' EXIT  ''OLZY'' .')");
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
transp(
  common& cmn,
  arr_ref<std::complex<double>, 2> yyc,
  arr_cref<int> ncpp,
  arr_ref<double> ann,
  arr_ref<int> jnn,
  arr_ref<std::complex<double> > znn,
  int const& ldm,
  int const& ldn) try
{
  yyc(dimension(ldn, ldn));
  ncpp(dimension(ldm));
  ann(dimension(ldn));
  jnn(dimension(ldn));
  znn(dimension(ldn));
  common_write write(cmn);
  std::complex<double>& czero = cmn.czero;
  double& fzero = cmn.fzero;
  int& ncct = cmn.ncct;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  int i2 = fem::int0;
  int ll0 = fem::int0;
  int k = fem::int0;
  int k1 = fem::int0;
  int j1 = fem::int0;
  std::complex<double> zss = fem::double0;
  double ass = fem::double0;
  std::complex<double> zmm = fem::double0;
  double amm = fem::double0;
  int i = fem::int0;
  int j = fem::int0;
  double dnn = fem::double0;
  int L = fem::int0;
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' ENTER  ''TRANSP'' .','    NCCT',7x,'REAL-YYC(1,1)',7x,"
      "'IMAG-YYC(1,1)',7x,'REAL-YYC(1,2)',7x,'IMAG-YYC(1,2)',/,18x,i8,4e20.11,"
      "/,' DIAGNOSTIC INPUT MATRIX.   YYC(I,J)  FOR  (I,J)=1, ... I2 .')"),
      ncct, yyc(1, 1), yyc(1, 2);
  }
  i2 = 6;
  ll0 = 0;
  if (iprs47 >= 4) {
    print(cmn, yyc(1, 1), i2, ll0, ldn);
  }
  i2 = 0;
  FEM_DO_SAFE(k, 1, ncct) {
    k1 = (k - 1) * 4 + 1;
    j1 = i2 + 1;
    i2 += ncpp(k1);
    jnn(k) = j1;
    zss = czero;
    ass = 0.0f;
    zmm = czero;
    amm = 0.0f;
    FEM_DO_SAFE(i, 1, ncct) {
      znn(i) = czero;
      ann(i) = 0.0f;
    }
    FEM_DO_SAFE(i, 1, i2) {
      FEM_DO_SAFE(j, j1, i2) {
        if (i < j1) {
          goto statement_20;
        }
        switch (fem::if_arithmetic(j - i)) {
          case -1: goto statement_40;
          case  0: goto statement_10;
          default: goto statement_15;
        }
        statement_10:
        zss += yyc(i, j);
        ass += 1.0f;
        goto statement_40;
        statement_15:
        zmm += yyc(i, j);
        amm += 1.0f;
        goto statement_40;
        statement_20:
        if (k == 1) {
          goto statement_40;
        }
        dnn = (j - jnn(k)) / (jnn(k) - 1);
        if (dnn < 1.0f) {
          dnn = 0.0f;
        }
        L = dnn + 1.0f;
        znn(L) += yyc(i, j);
        ann(L) += 1.0f;
        statement_40:;
      }
    }
    zss = zss / cmplxz(ass, fzero);
    zmm = zmm / cmplxz(amm, fzero);
    k1 = k - 1;
    if (k1 <= 0) {
      goto statement_55;
    }
    FEM_DO_SAFE(i, 1, k1) {
      znn(i) = znn(i) / cmplxz(ann(i), fzero);
    }
    statement_55:
    FEM_DO_SAFE(i, 1, i2) {
      FEM_DO_SAFE(j, j1, i2) {
        if (j < i) {
          goto statement_90;
        }
        if (i < j1) {
          goto statement_70;
        }
        switch (fem::if_arithmetic(j - i)) {
          case -1: goto statement_90;
          case  0: goto statement_60;
          default: goto statement_65;
        }
        statement_60:
        yyc(i, j) = zss;
        goto statement_90;
        statement_65:
        yyc(i, j) = zmm;
        goto statement_85;
        statement_70:
        if (k == 1) {
          goto statement_85;
        }
        dnn = (j - jnn(k)) / (jnn(k) - 1);
        if (dnn < 1.0f) {
          dnn = 0.0f;
        }
        L = dnn + 1.0f;
        yyc(i, j) = znn(L);
        statement_85:
        yyc(j, i) = yyc(i, j);
        statement_90:;
      }
    }
  }
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' EXIT  ''TRANSP'' .',7x,'REAL-YYC(1,1)',7x,'IMAG-YYC(1,1)',7x,"
      "'REAL-YYC(1,2)',7x,'IMAG-YYC(1,2)',/,17x,4e20.11,/,"
      "' DIAGNOSTIC OUTPUT MATRIX.  YYC(I,J)  FOR  (I,J)=1, ... I2 .')"),
      yyc(1, 1), yyc(1, 2);
  }
  if (iprs47 >= 4) {
    print(cmn, yyc(1, 1), i2, ll0, ldn);
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
zymx(
  common& cmn,
  double const& w,
  int const& nw,
  int const& isyst,
  int const& ngrnd,
  arr_cref<int> ngg,
  arr_cref<int> ncpp,
  arr_cref<double, 2> radi,
  arr_cref<double, 2> zy,
  arr_cref<double, 2> yz,
  arr_cref<double, 2> dir,
  arr_cref<double, 2> dij,
  arr_cref<double, 2> ang,
  arr_cref<double, 2> usi,
  arr_cref<double, 2> usr,
  arr_cref<double, 2> esi,
  arr_cref<double, 2> dr0,
  arr_cref<double, 2> th0,
  arr_cref<double, 2> al0,
  arr_cref<double> hi,
  arr_cref<double> di,
  arr_cref<double> bio,
  arr_cref<double> bi1,
  arr_cref<double> bi2,
  arr_cref<double> bi3,
  arr_cref<double> bi4,
  arr_cref<double> bi5,
  arr_cref<double> al1i,
  arr_cref<double> al2i,
  arr_cref<double> al3i,
  arr_cref<double> dci,
  int& nx,
  arr_ref<double> yzn,
  arr_ref<std::complex<double>, 2> ys,
  arr_ref<std::complex<double>, 2> yc,
  arr_ref<std::complex<double>, 2> zp,
  arr_ref<std::complex<double>, 2> zpc,
  arr_ref<std::complex<double>, 2> zs,
  arr_ref<std::complex<double>, 2> ze,
  arr_ref<std::complex<double>, 2> zc,
  arr_ref<std::complex<double>, 2> ca,
  arr_ref<std::complex<double>, 2> cb,
  arr_ref<std::complex<double>, 2> cc,
  arr_ref<std::complex<double>, 2> cd,
  arr_cref<std::complex<double>, 2> f,
  int const& ldm,
  int const& ldn,
  int const& ldn2,
  int const& lnq2) try
{
  ngg(dimension(ldn));
  ncpp(dimension(ldm));
  radi(dimension(ldm, 7));
  zy(dimension(ldn, ldn));
  yz(dimension(ldn, ldn));
  dir(dimension(ldm, ldm));
  dij(dimension(ldm, ldm));
  ang(dimension(ldm, ldm));
  usi(dimension(ldm, 3));
  usr(dimension(ldm, 3));
  esi(dimension(ldm, 3));
  dr0(dimension(ldm, ldm));
  th0(dimension(ldm, ldm));
  al0(dimension(ldm, ldm));
  hi(dimension(ldm));
  di(dimension(ldn));
  bio(dimension(ldm));
  bi1(dimension(ldm));
  bi2(dimension(ldm));
  bi3(dimension(ldm));
  bi4(dimension(ldm));
  bi5(dimension(ldm));
  al1i(dimension(ldm));
  al2i(dimension(ldm));
  al3i(dimension(ldm));
  dci(dimension(ldm));
  yzn(dimension(lnq2));
  ys(dimension(ldn, ldn));
  yc(dimension(ldn, ldn));
  zp(dimension(ldn, ldn));
  zpc(dimension(ldn, ldn));
  zs(dimension(ldn, ldn));
  ze(dimension(ldn, ldn));
  zc(dimension(ldn, ldn));
  ca(dimension(ldn, ldn));
  cb(dimension(ldn, ldn));
  cc(dimension(ldn, ldn));
  cd(dimension(ldn, ldn));
  f(dimension(ldn, ldn2));
  common_write write(cmn);
  double& twopi = cmn.twopi;
  auto& lunit3 = cmn.lunit3;
  int& kill = cmn.kill;
  int& iprsup = cmn.iprsup;
  std::complex<double>& czero = cmn.czero;
  double& fzero = cmn.fzero;
  int& itypec = cmn.itypec;
  int& izflag = cmn.izflag;
  int& iyflag = cmn.iyflag;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  int& numaki = cmn.numaki;
  int& npp = cmn.npp;
  //
  int ll0 = fem::int0;
  int ll1 = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  std::complex<double> cjw = fem::double0;
  int ll2 = fem::int0;
  auto& lunit6 = cmn.lunit6;
  double c1 = fem::double0;
  int mdx = fem::int0;
  int mdy = fem::int0;
  int k = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int L = fem::int0;
  double freq = fem::double0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  ll0 = 0;
  ll1 = 1;
  nx = ngrnd;
  FEM_DO_SAFE(i, 1, ldn) {
    FEM_DO_SAFE(j, 1, ldn) {
      ys(i, j) = czero;
      yc(i, j) = czero;
      zp(i, j) = czero;
      zpc(i, j) = czero;
      zs(i, j) = czero;
      zc(i, j) = czero;
      ze(i, j) = czero;
    }
  }
  cjw = cmplxz(fzero, w);
  ll2 = 2;
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' BEGIN  ''ZYMX'' .','      NW   ISYST     NP2',"
      "'  ITYPEC  NUMAKI     NPC     NCC  IZFLAG  IYFLAG',19x,'W',/,16x,9i8,"
      "e20.11)"),
      nw, isyst, cmn.np2, itypec, numaki, cmn.npc, cmn.ncc, izflag,
      iyflag, w;
  }
  switch (itypec) {
    case 1: goto statement_710;
    case 2: goto statement_720;
    case 3: goto statement_30;
    default: break;
  }
  statement_710:
  olzy(cmn, w, ncpp, zy, dij, ang, usi, usr, esi, hi, di, zs, ze, zc, ldm, ldn);
  if (kill >= 1) {
    goto statement_9200;
  }
  goto statement_800;
  statement_720:
  sczy1(cmn, w, isyst, zy, dir, dij, ang, hi, di, zs, ze, ldm, ldn);
  if (kill >= 1) {
    goto statement_9200;
  }
  sczy2(cmn, cjw, ncpp, radi, usi, usr, bio, bi1, bi2, bi3, bi4, bi5,
    al1i, al2i, al3i, zc, ldm, ldn);
  if (kill >= 1) {
    goto statement_9200;
  }
  goto statement_800;
  statement_30:
  if (npp != 0) {
    sczy1(cmn, w, isyst, zy, dir, dij, ang, hi, di, zs, ze, ldm, ldn);
  }
  if (kill >= 1) {
    goto statement_9200;
  }
  sczy2(cmn, cjw, ncpp, radi, usi, usr, bio, bi1, bi2, bi3, bi4, bi5,
    al1i, al2i, al3i, zc, ldm, ldn);
  if (kill >= 1) {
    goto statement_9200;
  }
  ptzy2(cmn, cjw, ncpp, dci, dr0, th0, al0, zp, zpc, ldm, ldn);
  if (kill >= 1) {
    goto statement_9200;
  }
  statement_800:
  if (numaki > 3) {
    goto statement_840;
  }
  if (iprs47 < 1) {
    goto statement_840;
  }
  write(lunit6, "(/,10x,'CONDUCTOR INTERNAL IMPEDANCE   ')");
  print(cmn, zc, nw, ll2, ldn);
  if (itypec != 3) {
    goto statement_105;
  }
  write(lunit6, "(/,10x,'PIPE IMPEDANCE')");
  print(cmn, zp, nw, ll2, ldn);
  if (npp == 0) {
    goto statement_840;
  }
  write(lunit6, "(/,10x,'CONNECTION IMPEDANCE')");
  print(cmn, zpc, nw, ll2, ldn);
  statement_105:
  write(lunit6, "(/,10x,'EARTH IMPEDANCE   ')");
  print(cmn, ze, nw, ll2, ldn);
  if (isyst ==  - 1) {
    goto statement_840;
  }
  write(lunit6, "(/,10x,'SPACE IMPEDANCE   ')");
  print(cmn, zs, nw, ll2, ldn);
  statement_840:
  FEM_DO_SAFE(i, 1, nw) {
    FEM_DO_SAFE(j, 1, nw) {
      c1 = cmn.e2p * yz(i, j);
      yc(i, j) = cjw * cmplxz(c1, fzero);
      zc(i, j) += ze(i, j) + zs(i, j) + zp(i, j) + zpc(i, j);
    }
  }
  if (itypec == 1 && cmn.nenerg != 0) {
    goto statement_335;
  }
  i = nx;
  statement_1945:
  i = i - 1;
  if (ngg(i) < 1) {
    goto statement_1966;
  }
  mdx = i + 1;
  FEM_DO_SAFE(j, 1, nw) {
    yzn(j) = std::real(zc(i, j));
  }
  FEM_DO_SAFE(j, mdx, nx) {
    mdy = j - 1;
    FEM_DO_SAFE(k, 1, nw) {
      yc(mdy, k) = yc(j, k);
      zc(mdy, k) = zc(j, k);
    }
  }
  FEM_DO_SAFE(j, 1, nw) {
    zc(nx, j) = cmplxz(yzn(j), fzero);
  }
  FEM_DO_SAFE(j, 1, nw) {
    yzn(j) = std::real(zc(j, i));
  }
  FEM_DO_SAFE(j, mdx, nx) {
    mdy = j - 1;
    FEM_DO_SAFE(k, 1, nw) {
      yc(k, mdy) = yc(k, j);
      zc(k, mdy) = zc(k, j);
    }
  }
  FEM_DO_SAFE(j, 1, nw) {
    zc(j, nx) = cmplxz(yzn(j), fzero);
  }
  nx = nx - 1;
  statement_1966:
  if (i > 1) {
    goto statement_1945;
  }
  if (itypec != 1) {
    goto statement_300;
  }
  switch (fem::if_arithmetic(nw - nx)) {
    case -1: goto statement_890;
    case  0: goto statement_340;
    default: goto statement_310;
  }
  statement_300:
  if (nx == nw) {
    goto statement_350;
  }
  statement_310:
  minvn(cmn, zc, nw, nx, ll1, ldn, ca, cb, cc, cd, ze, zp, zpc, f, ldn2);
  if (itypec != 1) {
    goto statement_350;
  }
  if (kill >= 1) {
    goto statement_9200;
  }
  goto statement_340;
  statement_335:
  nx = nw;
  statement_340:
  if (isyst == 2) {
    ; //w transp(cmn, zc, ncpp, yzn(1), yzn(ldn2), ca, ldm, ldn);
  }
  if (kill >= 1) {
    goto statement_9200;
  }
  if (cmn.ialter <= 0) {
    goto statement_90;
  }
  if (numaki < 9) {
    goto statement_90;
  }
  statement_350:
  if (cmn.ncros == 0 || cmn.npais < 0) {
    goto statement_890;
  }
  nx = 4;
  crosa4(cmn, zc, ll0, ldn, ca, cb, cc, cd, ze, zp, zpc, f, ldn2);
  crosa4(cmn, yc, ll1, ldn, ca, cb, cc, cd, ze, zp, zpc, f, ldn2);
  statement_890:
  n1 = nx;
  n2 = 2 * n1 * n1;
  k = 1;
  FEM_DO_SAFE(j, 1, n1) {
    FEM_DO_SAFE(i, 1, n1) {
      yzn(k) = std::real(yc(i, j));
      L = k + 1;
      yzn(L) = std::imag(yc(i, j));
      k = L + 1;
    }
  }
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(i, 1, n2) {
      wloop, yzn(i);
    }
  }
  if (iprsup < 1) {
    goto statement_1983;
  }
  freq = w / twopi;
  {
    write_loop wloop(cmn, lunit6,
      "('  Y WRITTEN ON LUNIT3 AT FREQ ',e16.7,2x,'ARE',/(1x,8e15.6))");
    wloop, freq;
    FEM_DO_SAFE(i, 1, n2) {
      wloop, yzn(i);
    }
  }
  statement_1983:
  k = 1;
  FEM_DO_SAFE(j, 1, n1) {
    FEM_DO_SAFE(i, 1, n1) {
      yzn(k) = std::real(zc(i, j));
      L = k + 1;
      yzn(L) = std::imag(zc(i, j));
      k = L + 1;
    }
  }
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(i, 1, n2) {
      wloop, yzn(i);
    }
  }
  if (iprsup < 1) {
    goto statement_90;
  }
  freq = w / twopi;
  {
    write_loop wloop(cmn, lunit6,
      "('  Z WRITTEN ON LUNIT3 AT FREQ ',e16.7,2x,'ARE',/(1x,8e15.6))");
    wloop, freq;
    FEM_DO_SAFE(i, 1, n2) {
      wloop, yzn(i);
    }
  }
  statement_90:
  if (numaki > 3) {
    goto statement_900;
  }
  if (izflag == 0) {
    goto statement_100;
  }
  write(lunit6, "(/,10x,'IMPEDANCE MATRIX')");
  print(cmn, zc, nx, ll2, ldn);
  if (izflag == 1) {
    goto statement_150;
  }
  statement_100:
  write(lunit6, "(/,10x,'RESISTANCE AND INDUCTANCE')");
  //C         Begin code associated with [Z] dump onto unit-34 plot file    VAX.4780
  //CCCC      K = 1                                                         VAX.4781
  //CCCC      SING(K) = ALOG1Z ( W / TWOPI )                                VAX.4782
  FEM_DO_SAFE(i, 1, nx) {
    FEM_DO_SAFE(j, 1, nx) {
      d1 = std::real(zc(i, j));
      d2 = std::imag(zc(i, j)) / w;
      //CCCC      SING(K+1) = D1            ! Store resistance in REAL*4 vector VAX.4783
      //CCCC      SING(K+2) = D2            ! Store inductance in REAL*4 vector VAX.4784
      //CCCC      K = K + 2          !  Advance index to last-stored number     VAX.4785
      zc(i, j) = cmplxz(d1, d2);
    }
  }
  //CCCC      WRITE (JUNIT4) ( SING(J), J=1, K ) ! Output vector written to VAX.4786
  //CCCC      write (*, 4488)  SING(1), SING(2), SING(3), SING(K-1), SING(K)VAX.4787
  //CCCC 4488 FORMAT ( ' SING(1), SING(2), SING(3), SING(K-1), SING(K) =',  VAX.4788
  //CCCC     1         F10.4, 4E13.4 )                                      VAX.4789
  print(cmn, zc, nx, ll2, ldn);
  //C     NOW RESTORE  'ZC'  TO IMPEDANCE IN  DO 4908  LOOP BELOW.          M18.1147
  FEM_DO_SAFE(i, 1, nx) {
    FEM_DO_SAFE(j, 1, nx) {
      d1 = std::real(zc(i, j));
      d2 = std::imag(zc(i, j)) * w;
      zc(i, j) = cmplxz(d1, d2);
    }
  }
  statement_150:
  if (iyflag == 0) {
    goto statement_160;
  }
  write(lunit6, "(/,10x,'ADMITTANCE MATRIX')");
  print(cmn, yc, nx, ll2, ldn);
  if (iyflag == 1) {
    goto statement_900;
  }
  statement_160:
  write(lunit6, "(/,10x,'CONDUCTANCE AND CAPACITANCE')");
  FEM_DO_SAFE(i, 1, nx) {
    FEM_DO_SAFE(j, 1, nx) {
      d3 = std::real(yc(i, j));
      d4 = std::imag(yc(i, j)) / w;
      yc(i, j) = cmplxz(d3, d4);
    }
  }
  print(cmn, yc, nx, ll2, ldn);
  //C     NOW RESTORE  'YC'  TO ADMITTANCE IN  DO 4928  LOOP BELOW.         M18.1166
  FEM_DO_SAFE(i, 1, nx) {
    FEM_DO_SAFE(j, 1, nx) {
      d1 = std::real(yc(i, j));
      d2 = std::imag(yc(i, j)) * w;
      yc(i, j) = cmplxz(d1, d2);
    }
  }
  statement_9200:
  statement_900:
  if (iprs47 >= 1) {
    write(logsix, "(/,' EXIT  ''ZYMX'' .')");
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
ymatrx(
  common& cmn,
  int const& isyst,
  int const& lunit6,
  arr_cref<int> ncpp,
  arr_ref<double, 2> zy,
  arr_ref<double, 2> yz,
  arr_cref<double, 2> esi,
  arr_cref<double, 2> al0,
  arr_cref<double> al1i,
  arr_cref<double> al2i,
  arr_cref<double> al3i,
  arr_ref<double, 2> a1,
  arr_ref<double, 2> a2,
  int const& ldm,
  int const& ldn) try
{
  ncpp(dimension(ldm));
  zy(dimension(ldn, ldn));
  yz(dimension(ldn, ldn));
  esi(dimension(ldm, 3));
  al0(dimension(ldm, ldm));
  al1i(dimension(ldm));
  al2i(dimension(ldm));
  al3i(dimension(ldm));
  a1(dimension(ldn, ldn));
  a2(dimension(ldn, ldn));
  common_write write(cmn);
  double& alpi = cmn.alpi;
  double& es1 = cmn.es1;
  int& itypec = cmn.itypec;
  int& ncc = cmn.ncc;
  int& npc = cmn.npc;
  int& npc2 = cmn.npc2;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  int& npp = cmn.npp;
  //
  int i = fem::int0;
  int j = fem::int0;
  int i1 = fem::int0;
  int j1 = fem::int0;
  int i2 = fem::int0;
  double ypo1 = fem::double0;
  int j2 = fem::int0;
  FEM_DO_SAFE(i, 1, ldn) {
    FEM_DO_SAFE(j, 1, ldn) {
      a1(i, j) = 0.0f;
      a2(i, j) = 0.0f;
      yz(i, j) = 0.0f;
    }
  }
  if (iprs47 >= 1) {
    write(lunit6,
      "(/,' AT BEGINNING OF  ''YMATRX'' .',"
      "'   ISYST     NP2  ITYPEC     NPC     NPP',/,28x,5i8)"),
      isyst, cmn.np2, itypec, npc, npp;
  }
  if (iprs47 >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,5x,'ROW',4x,'NCPP',11x,'AL1I',11x,'AL2I',11x,'AL3I',7x,'ESI(I,1)',"
        "7x,'ESI(I,2)',7x,'ESI(I,3)',/(1x,i7,i8,6e15.6))");
      FEM_DO_SAFE(i, 1, 10) {
        wloop, i, ncpp(i), al1i(i), al2i(i), al3i(i), esi(i, 1), esi(i,
          2), esi(i, 3);
      }
    }
  }
  if (itypec == 3) {
    goto statement_25;
  }
  if (isyst ==  - 1) {
    goto statement_25;
  }
  FEM_DO_SAFE(i, 1, npc) {
    FEM_DO_SAFE(j, 1, npc) {
      if (j < i) {
        goto statement_15;
      }
      yz(i, j) = zy(i, j);
      yz(j, i) = zy(i, j);
      statement_15:;
    }
  }
  if (itypec == 1) {
    goto statement_200;
  }
  FEM_DO_SAFE(i, 1, ncc) {
    i1 = i;
    if (i > npc) {
      i1 = i - npc;
    }
    if (i > npc2) {
      i1 = i - npc2;
    }
    FEM_DO_SAFE(j, 1, ncc) {
      if (j < i) {
        goto statement_20;
      }
      j1 = j;
      if (j > npc) {
        j1 = j - npc;
      }
      if (j > npc2) {
        j1 = j - npc2;
      }
      yz(i, j) = zy(i1, j1);
      yz(j, i) = yz(i, j);
      statement_20:;
    }
  }
  statement_25:
  FEM_DO_SAFE(i, 1, npc) {
    i1 = i + npc;
    i2 = i + npc2;
    if (i2 > ncc) {
      goto statement_35;
    }
    a1(i2, i2) = al3i(i) / esi(i, 3);
    a1(i2, i) = a1(i2, i2);
    a1(i, i2) = a1(i2, i2);
    a1(i1, i2) = a1(i2, i2);
    a1(i2, i1) = a1(i2, i2);
    statement_35:
    if (ncpp(i) == 1) {
      i1 = i;
    }
    if (i1 > npc2) {
      goto statement_39;
    }
    a1(i1, i1) = al2i(i) / esi(i, 2) + a1(i2, i2);
    a1(i1, i) = a1(i1, i1);
    a1(i, i1) = a1(i1, i1);
    statement_39:
    a1(i, i) = a1(i1, i1) + al1i(i) / esi(i, 1);
  }
  if (itypec == 3) {
    goto statement_60;
  }
  FEM_DO_SAFE(i, 1, ncc) {
    FEM_DO_SAFE(j, 1, ncc) {
      if (j < i) {
        goto statement_50;
      }
      yz(i, j) += a1(i, j);
      yz(j, i) = yz(i, j);
      statement_50:;
    }
  }
  goto statement_200;
  statement_60:
  ypo1 = 0.0f;
  if (npp != 0) {
    ypo1 = alpi / cmn.es2;
  }
  if (npp == 0) {
    zy(1, 1) = 0.f;
  }
  if (isyst !=  - 1) {
    ypo1 += zy(1, 1);
  }
  FEM_DO_SAFE(i, 1, npc) {
    i1 = i + npc;
    i2 = i + npc2;
    FEM_DO_SAFE(j, 1, npc) {
      j1 = j + npc;
      j2 = j + npc2;
      a2(i, j) = al0(i, j) / es1;
      if (ncpp(i) == 1) {
        goto statement_65;
      }
      a2(i1, j) = a2(i, j);
      a2(i1, j1) = a2(i, j);
      statement_65:
      if (ncpp(j) == 1) {
        goto statement_70;
      }
      a2(i, j1) = a2(i, j);
      if (ncpp(i) == 2) {
        goto statement_67;
      }
      a2(i2, j) = a2(i, j);
      a2(i2, j1) = a2(i, j);
      a2(i2, j2) = a2(i, j);
      statement_67:
      if (ncpp(j) == 2) {
        goto statement_70;
      }
      a2(i, j2) = a2(i, j);
      a2(i1, j2) = a2(i, j);
      statement_70:;
    }
  }
  FEM_DO_SAFE(i, 1, ncc) {
    if (npp == 0) {
      goto statement_85;
    }
    a1(i, ncc) = 0.f;
    a1(ncc, i) = 0.f;
    a2(i, ncc) = 0.f;
    a2(ncc, i) = 0.f;
    statement_85:
    FEM_DO_SAFE(j, 1, ncc) {
      if (j < i) {
        goto statement_90;
      }
      yz(i, j) = a1(i, j) + a2(i, j) + ypo1;
      yz(j, i) = yz(i, j);
      statement_90:;
    }
  }
  statement_200:
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' EXIT  ''YMATRX'' .','     NCC',16x,'YPO1',17x,'ES1',16x,'ALPI',"
      "13x,'YZ(1,1)',13x,'YZ(1,2)',/,17x,i8,5e20.11)"),
      ncc, ypo1, es1, alpi, yz(1, 1), yz(1, 2);
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
simp(
  common& cmn,
  int const& nw,
  arr_cref<double> h,
  arr_cref<double> dd,
  arr_cref<double> rad,
  arr_ref<double, 2> zy,
  arr_ref<double, 2> dir,
  arr_ref<double, 2> dij,
  arr_ref<double, 2> ang,
  int const& ldm,
  int const& ldn) try
{
  h(dimension(ldm));
  dd(dimension(ldn));
  rad(dimension(ldn));
  zy(dimension(ldn, ldn));
  dir(dimension(ldm, ldm));
  dij(dimension(ldm, ldm));
  ang(dimension(ldm, ldm));
  common_write write(cmn);
  const auto& radp = cmn.radp;
  int& itypec = cmn.itypec;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  //
  int i = fem::int0;
  int j = fem::int0;
  double r = fem::double0;
  double v = fem::double0;
  double r1 = fem::double0;
  double r2 = fem::double0;
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' ENTER  ''SIMP'' .','      NW  ITYPEC',16x,'H(1)',15x,'DD(1)',15x,"
      "'DD(2)',14x,'RAD(1)',13x,'RADP(3)',/,16x,2i8,5e20.11)"),
      nw, itypec, h(1), dd(1), dd(2), rad(1), radp(3);
  }
  FEM_DO_SAFE(i, 1, nw) {
    FEM_DO_SAFE(j, 1, nw) {
      dij(i, j) = 0.0f;
      dir(i, j) = 0.0f;
      ang(i, j) = 0.0f;
      zy(i, j) = 0.0f;
    }
  }
  FEM_DO_SAFE(i, 1, nw) {
    r = rad(i);
    if (itypec == 3) {
      r = radp(3);
    }
    FEM_DO_SAFE(j, 1, nw) {
      if (i >= j) {
        goto statement_15;
      }
      v = dd(i) - dd(j);
      r1 = h(i) - h(j);
      r2 = std::abs(h(i) + h(j));
      ang(i, j) = std::atan(std::abs(v) / r2);
      ang(j, i) = ang(i, j);
      v = v * v;
      r1 = r1 * r1;
      r2 = r2 * r2;
      dij(i, j) = sqrtz(v + r2);
      dij(j, i) = dij(i, j);
      dir(i, j) = sqrtz(v + r1);
      dir(j, i) = dir(i, j);
      goto statement_20;
      statement_15:
      if (i > j) {
        goto statement_30;
      }
      ang(i, j) = 0.f;
      dij(i, j) = 2.f * std::abs(h(i));
      dir(i, j) = r;
      statement_20:
      zy(i, j) = alogz(dij(i, j) / dir(i, j));
      zy(j, i) = zy(i, j);
      statement_30:;
    }
  }
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' EXIT  ''SIMP'' .',12x,'DIR(1,2)',12x,'DIJ(1,2)',19x,'V',13x,"
      "'ZY(1,1)',13x,'ZY(1,2)',/,15x,5e20.11)"),
      dir(1, 2), dij(1, 2), v, zy(1, 1), zy(1, 2);
  }
  if (iprs47 >= 5) {
    {
      write_loop wloop(cmn, logsix,
        "(/,' EXIT  ''SIMP'' .   ((ZY(I,J), J=1, NW), I=1, NW)',/(1x,"
        "6e20.11))");
      FEM_DO_SAFE(i, 1, nw) {
        FEM_DO_SAFE(j, 1, nw) {
          wloop, zy(i, j);
        }
      }
    }
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
ptzy1(
  common& cmn,
  arr_cref<double, 2> radi,
  arr_cref<double> dci,
  arr_cref<double> thc,
  arr_ref<double, 2> dr0,
  arr_ref<double, 2> th0,
  arr_ref<double, 2> al0,
  int const& ldm) try
{
  radi(dimension(ldm, 7));
  dci(dimension(ldm));
  thc(dimension(ldm));
  dr0(dimension(ldm, ldm));
  th0(dimension(ldm, ldm));
  al0(dimension(ldm, ldm));
  common_write write(cmn);
  const auto& radp = cmn.radp;
  double& alpi = cmn.alpi;
  double& bp1 = cmn.bp1;
  double& bp2 = cmn.bp2;
  double& rop = cmn.rop;
  double& usp = cmn.usp;
  double& pai = cmn.pai;
  double& u0 = cmn.u0;
  int& npc = cmn.npc;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& iprs47 = cmn.iprs47;
  int& npp = cmn.npp;
  //
  double p2 = fem::double0;
  int i = fem::int0;
  int j = fem::int0;
  double dkl = fem::double0;
  int n = fem::int0;
  double cn = fem::double0;
  int k = fem::int0;
  double ak = fem::double0;
  p2 = 2.f * pai;
  bp1 = radp(1) * sqrtz(u0 / rop * usp);
  bp2 = radp(2) * sqrtz(u0 / rop * usp);
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' BEGIN  ''PTZY1'' .','     NPP     NPC',17x,'BP1',17x,'BP2',13x,"
      "'RADP(3)',/,17x,2i8,3e20.11)"),
      npp, npc, bp1, bp2, radp(3);
  }
  if (npp == 0) {
    goto statement_5;
  }
  alpi = alogz(radp(3) / radp(2));
  goto statement_8;
  statement_5:
  alpi = 0.0f;
  statement_8:
  FEM_DO_SAFE(i, 1, npc) {
    FEM_DO_SAFE(j, 1, npc) {
      dr0(i, j) = dci(i) * dci(j) / fem::pow2(radp(1));
      switch (fem::if_arithmetic(i - j)) {
        case -1: goto statement_10;
        case  0: goto statement_20;
        default: goto statement_50;
      }
      statement_10:
      th0(i, j) = (thc(j) - thc(i)) * pai / 180.f;
      if (th0(i, j) > p2) {
        th0(i, j) = th0(i, j) - p2;
      }
      dkl = sqrtz(fem::pow2(dci(i)) + fem::pow2(dci(j)) - 2.f * dci(
        i) * dci(j) * cosz(th0(i, j)));
      al0(i, j) = alogz(radp(1) / dkl);
      th0(j, i) = th0(i, j);
      al0(j, i) = al0(i, j);
      goto statement_50;
      statement_20:
      th0(i, j) = 0.f;
      dkl = radi(i, 7);
      al0(i, j) = alogz(radp(1) / dkl * (1.f - dr0(i, j)));
      statement_50:;
    }
  }
  n = 19;
  FEM_DO_SAFE(i, 1, npc) {
    FEM_DO_SAFE(j, 1, npc) {
      cn = 0.0f;
      if (i == j) {
        goto statement_70;
      }
      if (j < i) {
        goto statement_70;
      }
      if (dci(i) * dci(j) < 1.0e-6f) {
        goto statement_65;
      }
      FEM_DO_SAFE(k, 1, n) {
        ak = k;
        cn += fem::pow(dr0(i, j), k) * cosz(ak * th0(i, j)) / ak;
      }
      statement_65:
      al0(i, j) = al0(i, j) - cn;
      al0(j, i) = al0(i, j);
      statement_70:;
    }
  }
  if (iprs47 >= 1) {
    write(logsix,
      "(/,' EXIT  ''PTZY1'' .',17x,'DKL',18x,'CN',16x,'ALPI',12x,'AL0(1,1)',"
      "12x,'AL0(1,2)',/,16x,5e20.11)"),
      dkl, cn, alpi, al0(1, 1), al0(1, 2);
  }
  if (iprs47 >= 4) {
    {
      write_loop wloop(cmn, logsix,
        "(/,' DIAGNOSTIC OUTPUT MATRIX.    ( (AL0(I,J), J=1, NPC), I=1, NPC)',"
        "/(1x,6e20.11))");
      FEM_DO_SAFE(i, 1, npc) {
        FEM_DO_SAFE(j, 1, npc) {
          wloop, al0(i, j);
        }
      }
    }
  }
  //C     END OF COMPLEX VARIABLES                                          M29.  14
  //C     END OF REAL VARIABLES                                             M29.  18
  //C     END OF INTEGER VARIABLES                                          M29.  19
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct guts47_save
{
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;

  guts47_save() :
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0)
  {}
};

void
guts47(
  common& cmn,
  arr_ref<int> ngg,
  arr_ref<int> ncpp,
  arr_ref<double> al1i,
  arr_ref<double> al2i,
  arr_ref<double> al3i,
  arr_ref<double> dci,
  arr_ref<double> thc,
  arr_ref<double> bio,
  arr_ref<double> bi1,
  arr_ref<double> bi2,
  arr_ref<double> bi3,
  arr_ref<double> bi4,
  arr_ref<double> bi5,
  arr_ref<double> hi,
  arr_ref<double> di,
  arr_ref<double> gn,
  arr_ref<double> rad,
  arr_cref<double> /* wy */,
  arr_ref<double, 2> zy,
  arr_ref<double, 2> yz,
  arr_cref<double, 2> /* sc */,
  arr_cref<double, 2> /* qc */,
  arr_ref<double, 2> dr0,
  arr_ref<double, 2> th0,
  arr_ref<double, 2> al0,
  arr_ref<double, 2> dij,
  arr_ref<double, 2> dir,
  arr_ref<double, 2> ang,
  arr_ref<double, 2> roi,
  arr_ref<double, 2> esi,
  arr_ref<double, 2> usi,
  arr_ref<double, 2> usr,
  arr_ref<double, 2> gi,
  arr_ref<double, 2> radi,
  arr_ref<double> yzn,
  arr_ref<std::complex<double> > qn,
  arr_ref<std::complex<double>, 2> yo,
  arr_ref<std::complex<double>, 2> ys,
  arr_ref<std::complex<double>, 2> yc,
  arr_ref<std::complex<double>, 2> zs,
  arr_ref<std::complex<double>, 2> zc,
  arr_ref<std::complex<double>, 2> ze,
  arr_ref<std::complex<double>, 2> zp,
  arr_ref<std::complex<double>, 2> zpc,
  arr_ref<std::complex<double>, 2> a,
  arr_ref<std::complex<double>, 2> ai,
  arr_ref<std::complex<double>, 2> b,
  arr_ref<std::complex<double>, 2> bi,
  arr_ref<std::complex<double>, 2> ca,
  arr_ref<std::complex<double>, 2> cb,
  arr_ref<std::complex<double>, 2> cc,
  arr_ref<std::complex<double>, 2> cd,
  arr_cref<std::complex<double>, 2> f,
  int const& ldm,
  int const& ldn,
  int const& ldn2,
  int const& lnq2) try
{
  FEM_CMN_SVE(guts47);
  ngg(dimension(ldn));
  ncpp(dimension(ldm));
  al1i(dimension(ldm));
  al2i(dimension(ldm));
  al3i(dimension(ldm));
  dci(dimension(ldm));
  thc(dimension(ldm));
  bio(dimension(ldm));
  bi1(dimension(ldm));
  bi2(dimension(ldm));
  bi3(dimension(ldm));
  bi4(dimension(ldm));
  bi5(dimension(ldm));
  hi(dimension(ldm));
  di(dimension(ldn));
  gn(dimension(ldn));
  rad(dimension(ldn));
  zy(dimension(ldn, ldn));
  yz(dimension(ldn, ldn));
  dr0(dimension(ldm, ldm));
  th0(dimension(ldm, ldm));
  al0(dimension(ldm, ldm));
  dij(dimension(ldm, ldm));
  dir(dimension(ldm, ldm));
  ang(dimension(ldm, ldm));
  roi(dimension(ldm, 3));
  esi(dimension(ldm, 3));
  usi(dimension(ldm, 3));
  usr(dimension(ldm, 3));
  gi(dimension(ldn, 3));
  radi(dimension(ldm, 7));
  yzn(dimension(lnq2));
  qn(dimension(ldn));
  yo(dimension(ldn, ldn));
  ys(dimension(ldn, ldn));
  yc(dimension(ldn, ldn));
  zs(dimension(ldn, ldn));
  zc(dimension(ldn, ldn));
  ze(dimension(ldn, ldn));
  zp(dimension(ldn, ldn));
  zpc(dimension(ldn, ldn));
  a(dimension(ldn, ldn));
  ai(dimension(ldn, ldn));
  b(dimension(ldn, ldn));
  bi(dimension(ldn, ldn));
  ca(dimension(ldn, ldn));
  cb(dimension(ldn, ldn));
  cc(dimension(ldn, ldn));
  cd(dimension(ldn, ldn));
  f(dimension(ldn, ldn2));
  common_read read(cmn);
  common_write write(cmn);
  const auto& abuff = cmn.abuff;
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  double& epsiln = cmn.epsiln;
  double& twopi = cmn.twopi;
  double& tenm3 = cmn.tenm3;
  double& tenm6 = cmn.tenm6;
  double& unity = cmn.unity;
  double& fltinf = cmn.fltinf;
  double& statfr = cmn.statfr;
  auto& voltbc = cmn.voltbc;
  auto& flstat = cmn.flstat;
  double& speedl = cmn.speedl;
  auto& lunit2 = cmn.lunit2;
  auto& lunit4 = cmn.lunit4;
  int lunit5 = cmn.lunit5;
  auto& lunit9 = cmn.lunit9;
  auto& lstat = cmn.lstat;
  int& ipunch = cmn.ipunch;
  int& lastov = cmn.lastov;
  int& ktab = cmn.ktab;
  int& ialter = cmn.ialter;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& nenerg = cmn.nenerg;
  double& alf1 = cmn.alf1;
  double& alf2 = cmn.alf2;
  double& dep1 = cmn.dep1;
  double& dep2 = cmn.dep2;
  double& e0 = cmn.e0;
  auto& radp = cmn.radp;
  double& es1 = cmn.es1;
  double& es2 = cmn.es2;
  double& rop = cmn.rop;
  double& usp = cmn.usp;
  double& hyud2 = cmn.hyud2;
  double& hyud3 = cmn.hyud3;
  double& hyud4 = cmn.hyud4;
  double& htoj2 = cmn.htoj2;
  double& htoj3 = cmn.htoj3;
  double& fzero = cmn.fzero;
  double& htoj4 = cmn.htoj4;
  double& pai = cmn.pai;
  double& roe = cmn.roe;
  double& u0 = cmn.u0;
  double& value2 = cmn.value2;
  double& valu14 = cmn.valu14;
  int& iearth = cmn.iearth;
  int& itypec = cmn.itypec;
  int& ncct = cmn.ncct;
  int& ncc = cmn.ncc;
  int& npc = cmn.npc;
  int& izflag = cmn.izflag;
  int& iyflag = cmn.iyflag;
  int& npc2 = cmn.npc2;
  int& np2 = cmn.np2;
  int& logsix = static_cast<common_com47&>(cmn).logsix;
  int& kmode = cmn.kmode;
  int& iprs47 = cmn.iprs47;
  int& npais = cmn.npais;
  int& ncros = cmn.ncros;
  int& numaki = cmn.numaki;
  int& npp = cmn.npp;
  int& iprint = cmn.iprint;
  auto& volti = static_cast<common_volpri&>(cmn).volti_50;
  auto& voltk = static_cast<common_volpri&>(cmn).voltk_50;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  if (is_called_first_time) {
    text1 = "PUNCH ";
    text2 = " LINE ";
    text3 = "CABLE ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = cmn.lunit6;
  int nrp = fem::int0;
  int mrr = fem::int0;
  int junit4 = fem::int0;
  int mispun = fem::int0;
  int lnq1 = fem::int0;
  int ncmod = fem::int0;
  int l5save = fem::int0;
  int ldisfr = fem::int0;
  double ten = fem::double0;
  int liu = fem::int0;
  double spl2 = fem::double0;
  int irsep = fem::int0;
  double xmajor = fem::double0;
  double rsg = fem::double0;
  int ngrnd = fem::int0;
  arr_1d<14, fem::str<8> > bufsem(fem::fill0);
  int n1 = fem::int0;
  int n2 = fem::int0;
  int n3 = fem::int0;
  int n4 = fem::int0;
  int n5 = fem::int0;
  int n6 = fem::int0;
  int n7 = fem::int0;
  int n8 = fem::int0;
  int n9 = fem::int0;
  double d1 = fem::double0;
  int isyst = fem::int0;
  fem::str<8> cname = fem::char0;
  int i = fem::int0;
  int im = fem::int0;
  int in = fem::int0;
  int j = fem::int0;
  int lines = fem::int0;
  int npipe = fem::int0;
  int jdx1 = fem::int0;
  int jdx2 = fem::int0;
  int kgc = fem::int0;
  double d9 = fem::double0;
  double freq = fem::double0;
  int ik = fem::int0;
  int ips = fem::int0;
  double dist = fem::double0;
  int j13 = fem::int0;
  int j14 = fem::int0;
  int itrnsf = fem::int0;
  double roe3 = fem::double0;
  double roe4 = fem::double0;
  double anpais = fem::double0;
  double xtotal = fem::double0;
  int jnc = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  int i1 = fem::int0;
  double d0 = fem::double0;
  int in1 = fem::int0;
  int k = fem::int0;
  int j3 = fem::int0;
  int nw = fem::int0;
  int nz = fem::int0;
  int kpd = fem::int0;
  int jn = fem::int0;
  double three = fem::double0;
  double rlimit = fem::double0;
  int nx = fem::int0;
  int iii = fem::int0;
  int kkk = fem::int0;
  int l1 = fem::int0;
  int l0 = fem::int0;
  double factor = fem::double0;
  double fdecad = fem::double0;
  double d13 = fem::double0;
  double pkkk = fem::double0;
  fem::str<8> text4 = fem::char0;
  double w = fem::double0;
  double freqs = fem::double0;
  int npk = fem::int0;
  int nki = fem::int0;
  int nkj = fem::int0;
  double cczero = fem::double0;
  double rzero = fem::double0;
  double xzero = fem::double0;
  double rtio = fem::double0;
  double freqsv = fem::double0;
  static const char* format_170 =
    "(/,/,"
    "'------------------------------------------------------------------------"
    "------------------------------------------------------------',/,/,1x)";
  static const char* format_3240 =
    "('+PHYSICAL CONSTANTS FOR CONDUCTORS AND INSULATORS.')";
  static const char* format_3256 = "('+FREQ. CARD',2e10.3,2i3,e8.3,2i2)";
  static const char* format_3280 =
    "('+DEPTHS & RESISTIVITIES OF 2ND & 3RD LAYER EARTH.')";
  static const char* format_3290 =
    "('+PERMEABILITY & PERMITTIVITY OF THE THREE LAYERS.')";
  static const char* format_4230 = "(13a6,a2)";
  static const char* format_900 = "(20i5)";
  static const char* format_901 = "(8e10.1)";
  static const char* format_902 = "(2e15.6,2i5,f8.3,i10,i2)";
  static const char* format_913 = "(10x,'EARTH | RESISTIVITY',f12.5)";
  static const char* format_915 =
    "(10x,'DISTANCE BETWEEN PHASES     |',5f17.5)";
  static const char* format_916 =
    "(10x,'3-LAYER EARTH',/,10x,'DEPTH FROM SURFACE , 1ST LAYER',f7.2,3x,"
    "'2ND LAYER',f8.2,3x,'3RD LAYER TO INFINITE',/,10x,'EARTH RESISTIVITY 0',"
    "e18.2,6x,e14.2,6x,e18.2,/,10x,'RELATIVE PERMEABILITY 0',e14.2,6x,e14.2,"
    "6x,e18.2,/,10x,'RELATIVE PERMITTIVITY 0',e14.2,6x,e14.2,6x,e18.2)";
  static const char* format_917 =
    "(10x,'BEGINNING FREQUENCY ',5x,e15.6,5x,'NUMBER OF DECADES ',i5,5x,"
    "'NUMBER OF POINTS IN EACH DECADE ',i5)";
  nrp = 0;
  mrr = 0;
  junit4 = 77;
  mispun = 0;
  lnq1 = ldn * ldn + 1;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' ENTER  ''GUTS47'' .','  LASTOV  IALTER  LUNIT2  LUNIT5',14x,"
      "'SPEEDL',14x,'EPSILN',15x,'TWOPI',/,18x,4i8,3e20.11)"),
      lastov, ialter, lunit2, lunit5, speedl, epsiln, twopi;
  }
  cmn.io.rewind(lunit2);
  cmn.io.rewind(cmn.lunit3);
  cmn.io.rewind(lunit4);
  if (iprsup >= 1) {
    write(lunit6, star), " %%--  Ready to rewind lunit9.";
  }
  cmn.io.rewind(lunit9);
  numaki = 0;
  ncmod = 0;
  fzero = 0.0f;
  cmn.cimag1 = cmplxz(fzero, unity);
  cmn.creal1 = cmplxz(unity, fzero);
  cmn.czero = cmplxz(fzero, fzero);
  if (lastov == 45) {
    numaki = 9;
  }
  if (lastov == 39) {
    numaki = 9;
  }
  if (lastov == 43) {
    numaki = 9;
  }
  if (ialter != 2) {
    goto statement_7407;
  }
  l5save = lunit5;
  lunit5 = lunit2;
  statement_7407:
  ldisfr = locf(voltk(1)) - locf(volti(1));
  cmn.spdlgt = speedl;
  logsix = lunit6;
  iprs47 = iprsup;
  ten = 10.f;
  value2 = epsiln;
  cmn.value1 = .5f * value2 / 1000.f;
  cmn.value3 = 20.f * 1000.f / alogz(ten);
  cmn.value4 = 1.781072417990e0;
  cmn.value5 = tenm3;
  valu14 = 2.302585093000e0;
  liu = 0;
  pai = twopi / 2.f;
  u0 = 2 * twopi * tenm6 / ten;
  spl2 = fem::pow2(speedl);
  e0 = 1.f / u0 / spl2;
  cmn.u2p = u0 / twopi;
  cmn.e2p = e0 * twopi;
  npais = 0;
  ncros = 0;
  irsep = 0;
  xmajor = 1.f;
  rsg = 1.e10f;
  statement_5:
  ngrnd = 0;
  //C     READ INPUT CARD USING CIMAGE.                                     M16.6355
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  if (bufsem(1) != text1) {
    goto statement_8214;
  }
  mispun = 1;
  goto statement_5;
  statement_8214:
  read(abuff, format_900), n1, n2, n3, n4, n5, n6, n7, n8, n9;
  nenerg = 0;
  if (n1 != 0) {
    goto statement_6;
  }
  if (n2 != 0) {
    goto statement_4501;
  }
  if (n3 != 0) {
    goto statement_4501;
  }
  write(kunit6, "('+BLANK CARD TERMINATING  ''CABLE CONSTANTS''  CASES.')");
  interp();
  if (lastov == 1) {
    goto statement_7439;
  }
  n1 = lastov;
  lastov = nchain;
  nchain = n1;
  if (ialter == 2) {
    lunit5 = l5save;
  }
  if (ipunch == 0) {
    goto statement_7496;
  }
  d1 = 0.0f;
  write(lunit9, fem::unformatted), d1, d1, d1;
  cmn.io.rewind(lunit9);
  if (iprs47 >= 1) {
    write(lunit6,
      "(' LAST RECORD ON UNIT9.',3e15.6,/,' IPUNCH =',i10)"), d1, d1,
      d1, ipunch;
  }
  statement_7496:
  goto statement_9900;
  statement_7439:
  lastov = nchain;
  nchain = 51;
  goto statement_9900;
  statement_4501:
  kill = 172;
  lstat(14) = n1;
  lstat(19) = 4501;
  goto statement_9200;
  statement_6:
  itypec = n1;
  isyst = n2;
  iearth = n4;
  kmode = n5;
  izflag = n6;
  iyflag = n7;
  //C     INITIALIZE OPTIONAL "PUNCH" CARD VARIABLES (WSM, NOV, 81):        M31.6715
  npais = 0;
  ncros = 0;
  irsep = 0;
  xmajor = 0.0f;
  rsg = 0.0f;
  cname = cmn.blank;
  if (mispun != 1) {
    goto statement_8234;
  }
  //C     READ INPUT CARD USING CIMAGE.                                     M31.6723
  cimage(cmn);
  read(abuff, "(3i5,2e10.1,a1)"), npais, ncros, irsep, xmajor, rsg, cname;
  statement_8234:
  mispun = 0;
  switch (itypec) {
    case 1: goto statement_10;
    case 2: goto statement_20;
    case 3: goto statement_20;
    default: break;
  }
  //C     OVERHEAD LINE DATA INPUT                                          M16.6387
  statement_10:
  ncct = n3;
  if (n9 != 0) {
    nenerg = n9;
  }
  write(kunit6, "('+MISC. DATA FOR LINES',1x,8i3)"), itypec, isyst,
    ncct, iearth, kmode, izflag, iyflag, nenerg;
  if (npais != 0) {
    write(lunit6, "(' MISC. DATA FOR LINES',i3,2e10.3,a1)"), npais,
      xmajor, rsg, cname;
  }
  FEM_DO_SAFE(i, 1, ncct) {
    im = 4 * (i - 1) + 1;
    in = im + 3;
    //C     READ INPUT CARD USING CIMAGE.                                     M16.6394
    cimage(cmn);
    read(abuff, format_4230), bufsem;
    if (ialter != 2) {
      write(lunit2, format_4230), bufsem;
    }
    {
      read_loop rloop(abuff(1), format_900);
      FEM_DO_SAFE(j, im, in) {
        rloop, ncpp(j);
      }
    }
    write(kunit6, "('+ADDITIONAL DATA FOR PHASE & GROUND WIRES.')");
    //C     READ INPUT CARD USING CIMAGE.                                     M16.6402
    cimage(cmn);
    read(abuff, format_4230), bufsem;
    if (ialter != 2) {
      write(lunit2, format_4230), bufsem;
    }
    {
      read_loop rloop(abuff(1), format_901);
      FEM_DO_SAFE(j, 1, 4) {
        rloop, radi(i, j);
      }
      FEM_DO_SAFE(j, 1, 2) {
        rloop, dr0(i, j);
      }
    }
    write(kunit6, "('+GEOMETRICAL DATA OF BUNDLED CONDUCTORS.')");
    //C     READ INPUT CARD USING CIMAGE.                                     M16.6411
    cimage(cmn);
    read(abuff, format_4230), bufsem;
    if (ialter != 2) {
      write(lunit2, format_4230), bufsem;
    }
    {
      read_loop rloop(abuff(1), format_901);
      FEM_DO_SAFE(j, 1, 2) {
        rloop, roi(i, j), usr(i, j);
      }
    }
    write(kunit6, "('+RESISTIVITY & PERMEABILITY OF PHASE & GD. WIRES.')");
  }
  ncc = 0;
  npc = 0;
  FEM_DO_SAFE(i, 1, ncct) {
    im = 4 * (i - 1) + 1;
    in = im + 1;
    ncc += ncpp(im);
    npc += ncpp(im) + ncpp(in);
  }
  np2 = npc;
  lines = (npc + 1) / 2;
  im = -1;
  FEM_DO_SAFE(j, 1, lines) {
    im += 2;
    in = im + 1;
    //C     READ INPUT CARD USING CIMAGE.                                     M16.6434
    cimage(cmn);
    read(abuff, format_4230), bufsem;
    if (ialter != 2) {
      write(lunit2, format_4230), bufsem;
    }
    {
      read_loop rloop(abuff(1), format_901);
      FEM_DO_SAFE(i, im, in) {
        rloop, thc(i), dci(i), di(i);
      }
    }
    if (j > 1) {
      goto statement_19;
    }
    write(kunit6, "('+HEIGHTS AND HORIZONTAL DISTANCE OF EACH LINE.')");
    statement_19:;
  }
  goto statement_85;
  //C     CABLE DATA INPUT                                                  M20.6327
  statement_20:
  npc = n3;
  npp = n8;
  ngrnd = n9;
  ncc = 0;
  npc2 = 0;
  if (itypec == 3) {
    goto statement_3010;
  }
  write(kunit6, "('+MISC. DATA FOR CABLES',8i3)"), itypec, isyst,
    npc, iearth, kmode, izflag, iyflag, ngrnd;
  if (npais != 0) {
    write(lunit6, "(' MISC. DATA FOR CABLES',3i3,2e8.1,a1)"), npais,
      ncros, irsep, xmajor, rsg, cname;
  }
  if (isyst !=  - 1) {
    goto statement_21;
  }
  if (iearth != 99) {
    goto statement_21;
  }
  kill = 173;
  lstat(19) = 3210;
  goto statement_9200;
  statement_21:
  np2 = npc * 3;
  goto statement_3050;
  statement_3010:
  write(kunit6, "('+MISC. DATA FOR PIPE CABLE',9i3)"), itypec, isyst,
    npc, iearth, kmode, izflag, iyflag, npp, ngrnd;
  if (npais != 0) {
    write(lunit6, "(' MISC. DATA FOR PIPE CABLE',2i3,2e8.1,a1)"),
      npais, ncros, xmajor, rsg, cname;
  }
  if (npp != 1) {
    npp = 1;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M20.6335
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  {
    read_loop rloop(abuff(1), format_901);
    FEM_DO_SAFE(i, 1, 3) {
      rloop, radp(i);
    }
    rloop, rop, usp, es1, es2;
  }
  write(kunit6, "('+PIPE CHARACTERISTIC.')");
  if (radp(3) != 0.0f) {
    goto statement_3036;
  }
  radp(3) = radp(2) + 100.f * epsiln;
  es2 = 1.0f;
  //C     READ INPUT CARD USING CIMAGE                                      M20.6343
  statement_3036:
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  {
    read_loop rloop(abuff(1), format_901);
    FEM_DO_SAFE(i, 1, npc) {
      rloop, dci(i), thc(i);
    }
  }
  write(kunit6, "('+RELATION BETWEEN CABLES AND PIPE.')");
  np2 = npc * 3 + npp;
  //C     READ INPUT CARD USING CIMAGE.                                     M16.6456
  statement_3050:
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  {
    read_loop rloop(abuff(1), format_900);
    FEM_DO_SAFE(i, 1, npc) {
      rloop, ncpp(i);
    }
  }
  write(kunit6, "('+NUMBER OF CONDUCTORS IN EACH CABLE.')");
  if (itypec == 2) {
    goto statement_22;
  }
  i = npc;
  statement_3223:
  thc(i) = thc(i) - thc(1);
  i = i - 1;
  if (i > 0) {
    goto statement_3223;
  }
  statement_22:
  FEM_DO_SAFE(i, 1, npc) {
    //C     READ INPUT CARD USING CIMAGE.                                     M16.6465
    cimage(cmn);
    read(abuff, format_4230), bufsem;
    if (ialter != 2) {
      write(lunit2, format_4230), bufsem;
    }
    {
      read_loop rloop(abuff(1), format_901);
      FEM_DO_SAFE(j, 1, 7) {
        rloop, radi(i, j);
      }
    }
    {
      write_loop wloop(cmn, kunit6, "('+RADII.',1x,7f6.2)");
      FEM_DO_SAFE(j, 1, 7) {
        wloop, radi(i, j);
      }
    }
    //C     READ INPUT CARD USING CIMAGE.                                     M16.6473
    cimage(cmn);
    read(abuff, format_4230), bufsem;
    if (ialter != 2) {
      write(lunit2, format_4230), bufsem;
    }
    {
      read_loop rloop(abuff(1), format_901);
      FEM_DO_SAFE(j, 1, 2) {
        rloop, roi(i, j), usr(i, j), usi(i, j), esi(i, j);
      }
    }
    write(kunit6, format_3240);
    if (ncpp(i) <= 2) {
      goto statement_3245;
    }
    //C     READ INPUT CARD USING CIMAGE.                                     M22.6597
    cimage(cmn);
    read(abuff, format_4230), bufsem;
    if (ialter != 2) {
      write(lunit2, format_4230), bufsem;
    }
    read(abuff, format_901), roi(i, 3), usr(i, 3), usi(i, 3), esi(i, 3);
    write(kunit6, format_3240);
    if (radi(i, 7) != 0.f) {
      goto statement_3239;
    }
    radi(i, 7) = radi(i, 6) + 100.f * epsiln;
    usi(i, 3) = 1.0f;
    esi(i, 3) = 1.0f;
    goto statement_3239;
    statement_3245:
    usi(i, 3) = 1.0f;
    esi(i, 3) = 1.0f;
    if (ncpp(i) == 2) {
      goto statement_3235;
    }
    if (radi(i, 3) != 0.f) {
      goto statement_3231;
    }
    radi(i, 3) = radi(i, 2) + 100.f * epsiln;
    usi(i, 1) = 1.0f;
    esi(i, 1) = 1.0f;
    statement_3231:
    radi(i, 4) = radi(i, 3);
    radi(i, 5) = radi(i, 4);
    radi(i, 6) = radi(i, 5);
    radi(i, 7) = radi(i, 6);
    usi(i, 2) = 1.0f;
    esi(i, 2) = 1.0f;
    usr(i, 2) = 1.0f;
    usr(i, 3) = 1.0f;
    roi(i, 2) = roi(i, 1);
    roi(i, 3) = roi(i, 2);
    goto statement_3239;
    statement_3235:
    if (radi(i, 5) != 0.f) {
      goto statement_3237;
    }
    radi(i, 5) = radi(i, 4) + 100.f * epsiln;
    usi(i, 2) = 1.0f;
    esi(i, 2) = 1.0f;
    statement_3237:
    radi(i, 6) = radi(i, 5);
    radi(i, 7) = radi(i, 6);
    usr(i, 3) = 1.0f;
    roi(i, 3) = roi(i, 2);
    statement_3239:
    if (ncpp(i) < 2) {
      goto statement_23;
    }
    npc2++;
    ncmod += 1 - ngrnd;
    if (ncpp(i) >= 3) {
      ncmod++;
    }
    statement_23:
    ncc += ncpp(i);
  }
  npc2 += npc;
  if (itypec == 2) {
    goto statement_24;
  }
  ncc += npp;
  if (npp == 0) {
    goto statement_85;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M20.6363
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  {
    read_loop rloop(abuff(1), format_901);
    FEM_DO_SAFE(i, 1, npp) {
      rloop, hi(i), di(i);
    }
  }
  write(kunit6, "('+HEIGHT AND HORIZONTAL DISTANCE OF EACH PIPE.')");
  goto statement_85;
  statement_24:
  lines = (npc + 3) / 4;
  FEM_DO_SAFE(j, 1, lines) {
    im = 4 * (j - 1) + 1;
    in = im + 3;
    //C     READ INPUT CARD USING CIMAGE.                                     M16.6487
    cimage(cmn);
    read(abuff, format_4230), bufsem;
    if (ialter != 2) {
      write(lunit2, format_4230), bufsem;
    }
    {
      read_loop rloop(abuff(1), format_901);
      FEM_DO_SAFE(i, im, in) {
        rloop, hi(i), di(i);
      }
    }
    if (j > 1) {
      goto statement_93;
    }
    write(kunit6, "('+HEIGHT AND HORIZONTAL DISTANCE OF EACH CABLE.')");
    statement_93:;
  }
  statement_85:
  if (npc <= ldm && ncc <= ldn) {
    goto statement_1945;
  }
  kill = 225;
  lstat(14) = ldn;
  lstat(15) = ldm;
  lstat(19) = 85;
  goto statement_9200;
  statement_1945:
  FEM_DO_SAFE(i, 1, ncc) {
    ngg(i) = 0;
  }
  if (ngrnd <= 3) {
    goto statement_3983;
  }
  cimage(cmn);
  {
    read_loop rloop(abuff(1), "(2x,78i1)");
    FEM_DO_SAFE(i, 1, npc) {
      rloop, ngg(i);
    }
    rloop, npipe;
  }
  FEM_DO_SAFE(i, 1, npc) {
    if (ngg(i) <= 1) {
      goto statement_1919;
    }
    jdx1 = npc + i;
    jdx2 = npc2 + i;
    kgc = ngg(i);
    if (kgc < 5) {
      ngg(i) = 0;
    }
    if (kgc != 3 && kgc != 6) {
      ngg(jdx1) = 1;
    }
    if (kgc != 2 && kgc != 5) {
      ngg(jdx2) = 1;
    }
    statement_1919:;
  }
  if (itypec == 2) {
    goto statement_3983;
  }
  ngg(ncc) = npipe;
  statement_3983:
  if (numaki == 0) {
    goto statement_87;
  }
  write(lunit4, fem::unformatted), itypec, isyst, npc, ncc;
  if (iprs47 >= 1) {
    write(lunit6, "(' AT 86 OF SUBR47',/,4i5)"), itypec, isyst, npc, ncc;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M16.6497
  statement_87:
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  read(abuff, format_902), d9, freq, ik, ips, dist, j13, j14;
  ipunch = j13;
  roe = d9;
  itrnsf = j14;
  if (freq == 0.f) {
    freq = statfr;
  }
  if (ips == 0) {
    ips = 1;
  }
  write(kunit6, format_3256), roe, freq, ik, ips, dist, ipunch, itrnsf;
  interp();
  if (iearth != 99) {
    goto statement_95;
  }
  //C     READ INPUT CARD USING CIMAGE.                                     M16.6510
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  read(abuff, format_901), dep1, dep2, roe3, roe4;
  write(kunit6, format_3280);
  //C     READ INPUT CARD USING CIMAGE.                                     M16.6518
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  read(abuff, format_901), htoj2, htoj3, htoj4, hyud2, hyud3, hyud4;
  write(kunit6, format_3290);
  alf1 = roe / roe3;
  alf2 = roe / roe4;
  statement_95:
  anpais = fem::iabs(npais);
  xtotal = xmajor * anpais;
  if (npais == 0) {
    xtotal = xmajor;
  }
  if (npais >= 0) {
    nyan(cmn, itypec, npc, ncc, ncpp, ngrnd, ncros, npais, ldm);
  }
  if (itypec != 1) {
    goto statement_200;
  }
  //C     OVERHEAD LINE DATA OUTPUTS & PRECAL.                              M24. 792
  jnc = 1;
  FEM_DO_SAFE(i, 1, ncct) {
    im = 4 * (i - 1) + 1;
    FEM_DO_SAFE(j, 1, 2) {
      j1 = im + j + 1;
      in = ncpp(j1);
      if (in == 0) {
        goto statement_120;
      }
      j2 = 2 * j - 1;
      i1 = i + ncct;
      if (in == 1) {
        goto statement_111;
      }
      d0 = dr0(i, j) / sinz(pai / in);
      usi(i, j) = radi(i, j2);
      in1 = in - 1;
      FEM_DO_SAFE(k, 1, in1) {
        usi(i, j) = usi(i, j) * d0 * sinz(pai / in * k);
      }
      usi(i1, j) = fem::pow(usi(i, j), (1.f / in));
      goto statement_120;
      statement_111:
      usi(i1, j) = radi(i, j2);
      statement_120:;
    }
    if (iprsup >= 1) {
      {
        write_loop wloop(cmn, lunit6,
          "(1x,'CIRCUIT',i3,'0  ','EQUIVALENT RADIUS OF PHASE WIRE ',e10.4,/,"
          "34x,'GROUND WIRE',e10.4)");
        wloop, i;
        FEM_DO_SAFE(j, 1, 2) {
          wloop, usi(i1, j);
        }
      }
    }
    FEM_DO_SAFE(j, 1, 2) {
      j1 = im + j - 1;
      if (ncpp(j1) != 0) {
        goto statement_123;
      }
      usi(i, j) = 0.0f;
      esi(i, j) = 0.0f;
      gi(i, j) = 0.0f;
      goto statement_125;
      statement_123:
      j1 = 2 * j;
      j2 = j1 - 1;
      usi(i, j) = radi(i, j1) * sqrtz(u0 * usr(i, j) / roi(i, j));
      esi(i, j) = radi(i, j2) * sqrtz(u0 * usr(i, j) / roi(i, j));
      if (radi(i, j1) < radi(i, j2)) {
        goto statement_124;
      }
      kill = 174;
      lstat(14) = i;
      flstat(15) = radi(i, j2);
      flstat(16) = radi(i, j1);
      lstat(19) = 123;
      goto statement_9200;
      statement_124:
      gi(i, j) = roi(i, j) / pai / (fem::pow2(radi(i, j2)) - fem::pow2(radi(i,
        j1)));
      //C     1          /NCPP(IM+J+1)                                          M43.4023
      statement_125:;
    }
  }
  FEM_DO_SAFE(j, 1, 2) {
    FEM_DO_SAFE(i, 1, ncct) {
      i1 = i + ncct;
      im = 4 * (i - 1) + 1;
      j1 = im + j - 1;
      j1 = ncpp(j1);
      if (j1 == 0) {
        goto statement_135;
      }
      j2 = j1 + jnc - 1;
      FEM_DO_SAFE(k, jnc, j2) {
        rad(k) = usi(i1, j);
      }
      jnc = j2 + 1;
      statement_135:;
    }
  }
  write(lunit6, format_170);
  if (isyst != 0) {
    goto statement_140;
  }
  write(lunit6, "(' TABLE OF OVERHEAD UNTRANSPOSED LINE PARAMETERS',/,1x)");
  goto statement_142;
  statement_140:
  write(lunit6, "(' TABLE OF OVERHEAD TRANSPOSED LINE PARAMETERS',/,1x)");
  statement_142:
  j1 = npc - ncc;
  write(lunit6,
    "(10x,'TOTAL NUMBER OF PHASE WIRES',i3,3x,'GROUND WIRES',i3,/,1x)"),
    ncc, j1;
  FEM_DO_SAFE(i, 1, ncct) {
    i1 = i + ncct;
    im = 4 * (i - 1) + 1;
    j1 = im + 1;
    j2 = im + 2;
    j3 = im + 3;
    {
      write_loop wloop(cmn, lunit6,
        "(10x,'CIRCUIT',i2,/,10x,'RADIUS | PHASE WIRE  (OUTER',e11.4,"
        "'  , INNER',e11.4,' )*',i2,' BUNDLES',/,20x,'EQUIV. RADIUS',e11.4)");
      wloop, i;
      FEM_DO_SAFE(j, 1, 2) {
        wloop, radi(i, j);
      }
      wloop, ncpp(j2), usi(i1, 1);
    }
    j1 = ncpp(j1);
    if (j1 == 0) {
      goto statement_148;
    }
    {
      write_loop wloop(cmn, lunit6,
        "(19x,'GROUND WIRE (OUTER',e11.4,'  , INNER',e11.4,' )*',i2,"
        "' BUNDLES',/,20x,'EQUIV. RADIUS',e11.4)");
      FEM_DO_SAFE(j, 3, 4) {
        wloop, radi(i, j);
      }
      wloop, ncpp(j3), usi(i1, 2);
    }
    statement_148:
    {
      write_loop wloop(cmn, lunit6,
        "(10x,'RESISTIVITY(OHM-M) | PHASE WIRE',e11.4,3x,'GROUND WIRE',e11.4,"
        "/,10x,'RELATIVE PERMEABILITY |',8x,f11.4,14x,f11.4,/,10x,"
        "'DC RESISTANCE(OHM/M) |',9x,e11.4,14x,e11.4)");
      FEM_DO_SAFE(j, 1, 2) {
        wloop, roi(i, j);
      }
      FEM_DO_SAFE(j, 1, 2) {
        wloop, usr(i, j);
      }
      FEM_DO_SAFE(j, 1, 2) {
        wloop, gi(i, j);
      }
    }
  }
  FEM_DO_SAFE(i, 1, npc) {
    hi(i) = (2.f * dci(i) + thc(i)) / 3.f;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(10x,'EFFECTIVE HEIGHT OF THE LINE ',5(i5,f12.5))");
    FEM_DO_SAFE(i, 1, npc) {
      wloop, i, hi(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_915);
    FEM_DO_SAFE(i, 1, npc) {
      wloop, di(i);
    }
  }
  write(lunit6, format_917), freq, ik, ips;
  write(lunit6, format_913), roe;
  if (iearth != 99) {
    goto statement_167;
  }
  write(lunit6, format_916), dep1, dep2, roe, roe3, roe4, htoj2,
    htoj3, htoj4, hyud2, hyud3, hyud4;
  statement_167:
  nw = npc;
  nz = npc;
  ngrnd = ncc;
  goto statement_700;
  //C     CABLE DATA OUTPUTS AND PRECALCULATION                             M20.6382
  statement_200:
  FEM_DO_SAFE(i, 1, npc) {
    rad(i) = radi(i, 7);
    FEM_DO_SAFE(j, 1, 3) {
      gi(i, j) = speedl / sqrtz(esi(i, j));
    }
  }
  write(lunit6, format_170);
  if (isyst >= 0) {
    goto statement_211;
  }
  write(lunit6, "(' TABLE OF UNDER-GROUND CABLE PARAMETERS',/,1x)");
  goto statement_214;
  statement_211:
  if (isyst > 0) {
    goto statement_213;
  }
  write(lunit6,
    "(' TABLE OF CABLE PARAMETERS FOR CABLES ON THE EARTH SURFACE')");
  goto statement_214;
  statement_213:
  write(lunit6, "(' TABLE OF OVERHEAD CABLE PARAMETERS',/,1x)");
  statement_214:
  if (ngrnd > 3) {
    goto statement_1980;
  }
  if (ngrnd != 0) {
    goto statement_325;
  }
  ngrnd = ncc;
  goto statement_215;
  statement_325:
  if (ngrnd > 1) {
    goto statement_330;
  }
  ngrnd = ncc;
  if (itypec == 2) {
    goto statement_215;
  }
  ngrnd = ncc - 1;
  goto statement_215;
  statement_330:
  if (ngrnd > 2) {
    goto statement_3333;
  }
  ngrnd = npc2;
  goto statement_215;
  statement_3333:
  ngrnd = npc;
  goto statement_215;
  statement_1980:
  FEM_DO_SAFE(i, 1, ncc) {
    kpd = ncc + 1 - i;
    if (ngg(kpd) > 0) {
      goto statement_1982;
    }
    ngrnd = kpd;
    goto statement_215;
    statement_1982:;
  }
  write(lunit6, "('  NO UNGROUNDED CONDUCTOR NEEDS CALCULATION')");
  stoptp(cmn);
  statement_215:
  if (itypec == 2) {
    goto statement_1215;
  }
  write(lunit6, "(' PIPE TYPE CABLES',/,1x)");
  if (npp != 0) {
    goto statement_216;
  }
  write(lunit6, "(' EARTH RETURN PATH NOT INCLUDED')");
  statement_216:
  write(lunit6, "(10x,' PIPE AND ITS INSULATOR')");
  if (npp != 0) {
    goto statement_1216;
  }
  radp(2) = fltinf;
  radp(3) = fltinf;
  statement_1216:
  {
    write_loop wloop(cmn, lunit6,
      "(10x,'PIPE | INNER RADIUS',e13.5,2x,'OUTER',e13.5,2x,"
      "'OUTER RADIUS OF PIPE INSULATOR',e13.5,/,18x,'RESISTIVITY(OHM-M)',"
      "e16.5,2x,'RELATIVE PERMEABILITY',f8.1)");
    FEM_DO_SAFE(i, 1, 3) {
      wloop, radp(i);
    }
    wloop, rop, usp;
  }
  write(lunit6,
    "(10x,'INSULATOR | RELATIVE PERMITTIVITY  INNER',f8.1,2x,'OUTER',f8.1)"),
    es1, es2;
  if (es2 == 0.0f) {
    es2 = 1.0f;
  }
  if (npp != 0) {
    {
      write_loop wloop(cmn, lunit6,
        "(10x,'PIPE',i2,' | DIST. FROM EARTH SURFACE',f9.4,'M',3x,"
        "'DIST. FROM PIPE 1',f9.4,'M')");
      FEM_DO_SAFE(i, 1, npp) {
        wloop, i, hi(i), di(i);
      }
    }
  }
  write(lunit6, "(10x,'INNER CONDUCTORS (SC CABLES)')");
  {
    write_loop wloop(cmn, lunit6,
      "(10x,'DIST. FROM PIPE CENTER |',6(i5,f9.4))");
    FEM_DO_SAFE(i, 1, npc) {
      wloop, i, dci(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6, "(10x,'ANGLE TO FIRST CABLE   |',6(f14.4))");
    FEM_DO_SAFE(i, 1, npc) {
      wloop, thc(i);
    }
  }
  statement_1215:
  FEM_DO_SAFE(i, 1, npc) {
    jn = ncpp(i);
    {
      write_loop wloop(cmn, lunit6,
        "(10x,'PHASE',i2,1x,'BOUNDARY RADII  |',/,10x,7(i3,e13.5))");
      wloop, i;
      FEM_DO_SAFE(j, 1, 7) {
        wloop, j, radi(i, j);
      }
    }
    {
      write_loop wloop(cmn, lunit6,
        "(18x,'RESISTIVITY(OHM-M)| CORE',e12.5,3x,'SHEATH',e12.5,3x,'ARMOR',"
        "e12.5,/,18x,'RELATIVE PERMEABILITY |  ',f12.5,9x,f12.5,8x,f12.5,/,"
        "3(18x,'INSULATOR',i2,'| (RELATIVE) PERMEABILITY',f6.2,3x,"
        "'PERMITTIVITY',f6.2,3x,'VELOCITY(M/S)',e12.5,/,1x))");
      FEM_DO_SAFE(j, 1, 3) {
        wloop, roi(i, j);
      }
      FEM_DO_SAFE(j, 1, 3) {
        wloop, usr(i, j);
      }
      FEM_DO_SAFE(j, 1, jn) {
        wloop, j, usi(i, j), esi(i, j), gi(i, j);
      }
    }
  }
  if (itypec != 3) {
    goto statement_220;
  }
  three = 3.0f;
  rlimit = (1.0f + 2.0f / sqrtz(three)) * radi(1, 7);
  if (npc == 2) {
    rlimit = 2.0f * radi(1, 7);
  }
  if (npc == 1) {
    rlimit = radi(1, 7);
  }
  if (radp(1) > rlimit) {
    goto statement_221;
  }
  write(lunit6,
    "('0',10x,'PHYSICALLY INNER CONDUCTORS CANNOT BE EXSISTED IN THE PIPE.',/,"
    "11x,'PLEASE CHECK THE RADII OF THE PIPE AND INNER CONDUCTORS.',/,/,1x)");
  stoptp(cmn);
  statement_220:
  {
    write_loop wloop(cmn, lunit6,
      "(10x,'DISTANCE FROM EARTH SURFACE |',5(i5,f12.5))");
    FEM_DO_SAFE(i, 1, npc) {
      wloop, i, hi(i);
    }
  }
  statement_221:
  FEM_DO_SAFE(i, 1, npc) {
    if (i == 1) {
      goto statement_223;
    }
    i1 = i - 1;
    if (ncpp(i1) >= ncpp(i)) {
      goto statement_223;
    }
    write(lunit6,
      "('0',10x,'INVALID DATA OF ''NCPP(I)'', NO FURTHER ',"
      "'CALCULATION.  IT SHOULD BE ''NCPP(I-1).GE.NCPP(I)''.',/,11x,"
      "'PLEASE CHECK YOUR DATA.')");
    stoptp(cmn);
    statement_223:
    bio(i) = radi(i, 1) * sqrtz(u0 / roi(i, 1) * usr(i, 1));
    bi1(i) = radi(i, 2) * sqrtz(u0 / roi(i, 1) * usr(i, 1));
    al1i(i) = alogz(radi(i, 3) / radi(i, 2));
    bi2(i) = radi(i, 3) * sqrtz(u0 / roi(i, 2) * usr(i, 2));
    bi3(i) = radi(i, 4) * sqrtz(u0 / roi(i, 2) * usr(i, 2));
    al2i(i) = alogz(radi(i, 5) / radi(i, 4));
    bi4(i) = radi(i, 5) * sqrtz(u0 / roi(i, 3) * usr(i, 3));
    bi5(i) = radi(i, 6) * sqrtz(u0 / roi(i, 3) * usr(i, 3));
    al3i(i) = alogz(radi(i, 7) / radi(i, 6));
  }
  if (iprs47 > 1) {
    write(lunit6,
      "(/,' VARIOUS INTEGERS.','     NPC     NCC     NPP    NCCT  NUMAKI',"
      "'  LASTOV  IPUNCH  IALTER  IEARTH  ITYPEC',"
      "'   ISYST   KMODE  IZFLAG  IYFLAG',/,18x,14i8)"),
      npc, ncc, npp, ncct, numaki, lastov, ipunch, ialter, iearth,
      itypec, isyst, kmode, izflag, iyflag;
  }
  if (iprsup >= 2) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' DERIVED VECTORS OF LENGTH  ''NPC''  IN  ''SUBR47'' ,   AS MATRIX"
        " GRUNT BEGINS.',/,1x,5x,'ROW',17x,'BI1',17x,'BI2',17x,'BI3',16x,"
        "'AL1I',16x,'AL2I',/(1x,i8,5e20.11))");
      FEM_DO_SAFE(i, 1, npc) {
        wloop, i, bi1(i), bi2(i), bi3(i), al1i(i), al2i(i);
      }
    }
  }
  if (itypec == 3) {
    ptzy1(cmn, radi, dci, thc, dr0, th0, al0, ldm);
  }
  if (kill >= 1) {
    goto statement_9200;
  }
  nw = npc;
  nz = ncc;
  if (itypec != 3) {
    goto statement_1710;
  }
  nw = npp;
  switch (fem::if_arithmetic(npp)) {
    case -1: goto statement_1750;
    case  0: goto statement_1750;
    default: goto statement_1711;
  }
  statement_1710:
  {
    write_loop wloop(cmn, lunit6, format_915);
    FEM_DO_SAFE(i, 1, npc) {
      wloop, di(i);
    }
  }
  statement_1711:
  write(lunit6, format_917), freq, ik, ips;
  write(lunit6, format_913), roe;
  if (iearth != 99) {
    goto statement_700;
  }
  write(lunit6, format_916), dep1, dep2, roe, roe3, roe4, htoj2,
    htoj3, htoj4, hyud2, hyud3, hyud4;
  statement_700:
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' BEFORE CALL TO  ''SIMP'' .',7x,'I',12x,'RAD',11x,'RADP',13x,"
        "'DD',14x,'H',/(25x,i8,4e15.6))");
      FEM_DO_SAFE(i, 1, nw) {
        wloop, i, rad(i), radp(i), di(i), hi(i);
      }
    }
  }
  if (npais == 0) {
    goto statement_610;
  }
  write(lunit6,
    "('0',10x,'DATA CARDS BY PI-CIRCUIT MODELING ARE PUNCHED',"
    "' OUT FOR THE FOLLOWING SPECIFICATIONS ; NODE NAME ''',a1,'''')"),
    cname;
  goto statement_615;
  statement_610:
  if (ncros == 0) {
    goto statement_714;
  }
  statement_615:
  if (itypec != 1) {
    goto statement_620;
  }
  write(lunit6,
    "(10x,'TOTAL LENGTH OF OVERHEAD LINE =',e12.5,/,10x,"
    "'LENGTH OF ONE PI-SECTION =',e12.5,3x,'NUMBER OF PI SECTIONS =',i3)"),
    xtotal, xmajor, npais;
  goto statement_714;
  statement_620:
  if (npais > 0 && ncros == 0) {
    goto statement_625;
  }
  write(lunit6,
    "(10x,'TOTAL LENGTH OF CABLE =',e12.5,/,10x,"
    "'LENGTH OF ONE MAJOR SECTION =',e12.5,3x,'NUMBER OF MAJOR SECTIONS =',i3,"
    "/,10x,'SHEATH GROUNDING RESISTANCE AT MAJOR SECTION ;',e12.5)"),
    xtotal, xmajor, npais, rsg;
  goto statement_630;
  statement_625:
  write(lunit6,
    "(10x,'TOTAL LRNGTH OF CABLE =',e12.5,/,10x,"
    "'LENGTH OF ONE MAJOR SECTION =',e12.5,3x,'NUMBER OF MAJOR SECTIONS =',"
    "i3)"),
    xtotal, xmajor, npais;
  statement_630:
  if (ncros != 0) {
    write(lunit6, "(10x,'THE CABLE IS CROSSBONDED.')");
  }
  if (npais < 0) {
    write(lunit6, "(10x,'DISCRETE PI-CIRCUIT MODELING')");
  }
  if (npais > 0) {
    write(lunit6, "(10x,'HOMOGENEOUS PI-CIRCUIT MODELING')");
  }
  statement_714:
  simp(cmn, nw, hi, di, rad, zy, dir, dij, ang, ldm, ldn);
  if (kill >= 1) {
    goto statement_9200;
  }
  if (iprsup < 3) {
    goto statement_1750;
  }
  write(lunit6,
    "(/,' AFTER CALL TO  ''SIMP'' .',"
    "'      NW      NZ   ISYST  ITYPEC  IEARTH     NPC     NCC',/,24x,7i8)"),
    nw, nz, isyst, itypec, iearth, npc, ncc;
  {
    write_loop wloop(cmn, lunit6,
      "(/,' ((ZY(I,J), J=1, NW), I=1, NW)',/(1x,8e15.8))");
    FEM_DO_SAFE(i, 1, nw) {
      FEM_DO_SAFE(j, 1, nw) {
        wloop, zy(i, j);
      }
    }
  }
  statement_1750:
  ymatrx(cmn, isyst, lunit6, ncpp, zy, yz, esi, al0, al1i, al2i,
    al3i, yzn(1), yzn(lnq1), ldm, ldn);
  if (kill >= 1) {
    goto statement_9200;
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' ((YZ(I,J), J=1, NZ), I=1, NZ)   AFTER CALL TO  ''YMATRX'' .',"
        "/(1x,8e15.8))");
      FEM_DO_SAFE(i, 1, nz) {
        FEM_DO_SAFE(j, 1, nz) {
          wloop, yz(i, j);
        }
      }
    }
  }
  FEM_DO_SAFE(i, 1, nz) {
    FEM_DO_SAFE(j, 1, nz) {
      if (j < i) {
        goto statement_702;
      }
      ys(i, j) = cmplxz(yz(i, j), fzero);
      ys(j, i) = ys(i, j);
      statement_702:;
    }
  }
  minv(cmn, ys, nz, f, ldn, ldn2);
  if (kill >= 1) {
    goto statement_9200;
  }
  if (itypec != 1) {
    goto statement_703;
  }
  if (isyst == 2) {
    ; //w transp(cmn, ys, ncpp, yzn(1), yzn(ldn2), ca, ldm, ldn);
  }
  if (kill >= 1) {
    goto statement_9200;
  }
  statement_703:
  FEM_DO_SAFE(i, 1, nz) {
    FEM_DO_SAFE(j, 1, nz) {
      if (j < i) {
        goto statement_705;
      }
      yz(i, j) = std::real(ys(i, j));
      yz(j, i) = yz(i, j);
      statement_705:;
    }
  }
  nx = ngrnd;
  if (npais >= 0 && ncros != 0) {
    nx = 4;
  }
  if (npais != 0) {
    gomen(cmn, itypec, npc, nx, npais, ncros, irsep, ncpp, ldm);
  }
  if (iprsup >= 3) {
    {
      write_loop wloop(cmn, lunit6,
        "(/,' IN  ''SUBR47'' ,   CAPACITANCE.   ( (YZ(I,J), J=1, NZ), I=1, NZ "
        ")',/(1x,6e20.11))");
      FEM_DO_SAFE(i, 1, nz) {
        FEM_DO_SAFE(j, 1, nz) {
          wloop, yz(i, j);
        }
      }
    }
  }
  iprint = 0;
  statement_9003:
  statement_706:
  if (ck1 !=  - fltinf) {
    goto statement_7446;
  }
  if (dist <= 0.0f) {
    goto statement_7446;
  }
  ck1 = dist;
  statement_7446:
  if (ci1 !=  - fltinf) {
    goto statement_7449;
  }
  if (roe <= 0.0f) {
    goto statement_7449;
  }
  ci1 = roe;
  statement_7449:
  if (ialter == 2) {
    roe = ci1;
  }
  iii = 0;
  kkk = 1;
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' IN  ''SUBR47'' ,   DONE WITH CAPACITANCE.',"
      "'      NZ      IK  IALTER  IPRSUP',/,40x,4i8,/,1x,17x,'ROE',17x,'CI1',"
      "17x,'CK1',16x,'DIST',13x,'YZ(1,1)',13x,'YZ(1,2)',/,1x,6e20.11)"),
      nz, ik, ialter, iprsup, roe, ci1, ck1, dist, yz(1, 1), yz(1, 2);
  }
  if (ik > 0) {
    goto statement_7456;
  }
  iprint++;
  if (lastov != 39) {
    goto statement_7451;
  }
  if (iprint > 1) {
    goto statement_7451;
  }
  kmode = 1;
  l1 = 1;
  l0 = 0;
  d9 = dist * tenm3;
  //CCC      write (*,*)  ' %%-- guts47 write on  lunit9.',                 M43.4028
  //CCC     1             '    DIST, D9, =',  DIST, D9,                     M43.4029
  write(lunit9, fem::unformatted), l1, l1, d9, l0, itrnsf;
  statement_7451:
  if (ialter != 1) {
    goto statement_3007;
  }
  volti(iprint) = roe;
  voltk(iprint) = freq;
  if (iprint <= ldisfr) {
    goto statement_3007;
  }
  kill = 170;
  lstat(14) = ldisfr;
  lstat(19) = 7456;
  goto statement_9200;
  statement_7456:
  factor = ips;
  factor = valu14 / factor;
  fdecad = freq;
  iprint++;
  voltbc(1) = freq;
  voltbc(2) = freq * fem::pow(10.f, ik);
  voltbc(3) = expz(factor);
  d13 = voltbc(2) / voltbc(1);
  voltbc(4) = alogz(d13) / alogz(voltbc(3)) + 1.5f;
  voltbc(5) = ik;
  voltbc(6) = ips;
  write(6, star), " guts47.   Below S.N. 7456, VOLTBC(6) = ", voltbc(6);
  dist = 0.0f;
  cmn.icheck = iprint - 1;
  goto statement_3007;
  statement_3005:
  iii++;
  fdecad = fdecad * 10.0f;
  freq = fdecad;
  iprint++;
  kkk = 1;
  goto statement_3007;
  statement_3006:
  pkkk = kkk;
  freq = fdecad * expz(pkkk * factor);
  kkk++;
  if (kkk > ips) {
    goto statement_3005;
  }
  iprint++;
  if (iprs47 >= 1) {
    write(lunit6,
      "(/,' NEXT LOGARITHMACALLY SPACED FREQUENCY.  IPRINT     KKK     III',"
      "11x,'FREQ',12x,'CI1',12x,'CK1',/,39x,3i8,3e16.6)"),
      iprint, kkk, iii, freq, ci1, ck1;
  }
  statement_3007:
  if (numaki == 9) {
    goto statement_730;
  }
  text4 = text2;
  if (itypec != 1) {
    text4 = text3;
  }
  write(lunit6,
    "(/,/,' *******************',a6,' CONSTANTS MATRICES FOR FREQUENCY =',"
    "e15.6,' HZ   **********************************')"),
    text4, freq;
  statement_730:
  w = freq * twopi;
  if (numaki == 1) {
    freqs = freq;
  }
  zymx(cmn, w, nz, isyst, ngrnd, ngg, ncpp, radi, zy, yz, dir, dij,
    ang, usi, usr, esi, dr0, th0, al0, hi, di, bio, bi1, bi2, bi3,
    bi4, bi5, al1i, al2i, al3i, dci, nx, yzn, ys, yc, zp, zpc, zs,
    ze, zc, ca, cb, cc, cd, f, ldm, ldn, ldn2, lnq2);
  if (npais == 0) {
    goto statement_810;
  }
  write(lunit6, "(/,/,'0',10x,'*****LISTS OF PUNCHED OUT DATA CARDS*****')");
  npk = lnq2 / 3;
  nki = npk + 1;
  nkj = nki + npk;
  datout(cmn, w, zc, yc, rsg, xmajor, nx, npais, ncros, irsep, cname,
    ldn, yzn(1), yzn(nki), yzn(nkj), npk);
  statement_810:
  if (kill >= 1) {
    goto statement_9200;
  }
  if (kmode == 0) {
    goto statement_750;
  }
  ktab = nx;
  prcon(cmn, w, nx, zc, zs, ys, yc, yo, qn, gn, ze, a, ai, b, bi,
    yzn, ca, cb, cc, f, ldn, ldn2, lnq2, mrr, nrp);
  if (kill >= 1) {
    goto statement_9200;
  }
  if (lastov != 43) {
    goto statement_750;
  }
  if (ipunch == 0) {
    goto statement_750;
  }
  if (ik > 0) {
    goto statement_2745;
  }
  if (liu != 0) {
    goto statement_2745;
  }
  cczero = std::imag(ys(1, 1)) / w / tenm6;
  write(lunit9, fem::unformatted), cczero;
  liu = 1;
  if (iprs47 >= 1) {
    write(lunit6,
      "(' CAPACITANCE ON UNIT9 AT ',e15.6,'HZ.',5x,e16.8)"), freq,
      cczero;
  }
  statement_2745:
  rzero = std::real(zs(1, 1));
  xzero = std::imag(zs(1, 1)) / w * 1000.f;
  write(lunit9, fem::unformatted), rzero, xzero, freq;
  if (iprs47 >= 1) {
    write(lunit6, "(' R, L AND F ON UNIT9.',5x,3e16.8)"), rzero, xzero, freq;
  }
  statement_750:
  if (iii == ik) {
    goto statement_9001;
  }
  goto statement_3006;
  //CC                                            ** IDENTICAL EIGENVALUE ? M43.4037
  statement_9001:
  if (iprint == 1) {
    goto statement_9002;
  }
  if (nrp > 0) {
    goto statement_9002;
  }
  rtio = (mrr * 1.0f) / (iprint - 1.0f);
  if (rtio < 0.75f) {
    goto statement_9002;
  }
  nrp = 1;
  freq = freqsv;
  FEM_DO_SAFE(i, 1, (iprint - 1) * ktab) {
    cmn.io.backspace(lunit9);
    write(6, star), " GUTS47.  Backspace lunit 9.  iprint, i = ", iprint;
  }
  FEM_DO_SAFE(i, 1, (iprint - 1)) {
    cmn.io.backspace(junit4);
  }
  write(6, star), " Backspace junit4.  junit4, iprint =", junit4, iprint;
  iprint = 1;
  goto statement_9003;
  statement_9002:
  //C     READ INPUT CARD USING CIMAGE                                      M19.3390
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  read(abuff, format_902), d9, freq, ik, ips, dist, j13, j14;
  freqsv = freq;
  if (d9 != 0.f) {
    goto statement_3899;
  }
  if (freq == 0.f) {
    goto statement_929;
  }
  statement_3899:
  roe = d9;
  ipunch = j13;
  itrnsf = j14;
  if (freq == 0.f) {
    freq = statfr;
  }
  if (ips == 0) {
    ips = 1;
  }
  write(kunit6, format_3256), roe, freq, ik, ips, dist, ipunch, itrnsf;
  if (iearth != 99) {
    goto statement_706;
  }
  //C     READ INPUT CARD USING CIMAGE.                                     M16.6786
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  read(abuff, format_901), dep1, dep2, roe3, roe4;
  write(kunit6, format_3280);
  //C     READ INPUT CARD USING CIMAGE.                                     M16.6793
  cimage(cmn);
  read(abuff, format_4230), bufsem;
  if (ialter != 2) {
    write(lunit2, format_4230), bufsem;
  }
  read(abuff, format_901), htoj2, htoj3, htoj4, hyud2, hyud3, hyud4;
  write(kunit6, format_3290);
  alf1 = roe / roe3;
  alf2 = roe / roe4;
  goto statement_706;
  statement_929:
  write(kunit6, "('+BLANK CARD TERMINATING FREQUENCY CARDS.')");
  interp();
  write(lunit6, "(/,/,/,1x)");
  goto statement_5;
  statement_9200:
  lstat(18) = nchain;
  if (ialter == 2) {
    lunit5 = l5save;
  }
  lastov = nchain;
  nchain = 51;
  statement_9900:
  if (iprsup >= 1) {
    write(lunit6,
      "(/,' EXIT  ''SUBR47'' .','  NCHAIN  LUNIT5  NUMAKI  IALTER',/,17x,4i8)"),
      nchain, lunit5, numaki, ialter;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
subr47(
  common& cmn) try
{
  common_write write(cmn);
  fem::str<8>& trash = cmn.trash;
  auto& lstat = cmn.lstat;
  const auto& nbyte = cmn.nbyte;
  const auto& ktrlsw = cmn.ktrlsw;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  //
  auto& lunit6 = cmn.lunit6;
  int n8 = fem::int0;
  arr_1d<20, int> lltemp(fem::fill0);
  int n7 = fem::int0;
  double cc = fem::double0;
  double ppa = fem::double0;
  double dd = fem::double0;
  double ppb = fem::double0;
  int ldm = fem::int0;
  int ldn = fem::int0;
  int ldn2 = fem::int0;
  int lmq = fem::int0;
  int lnq = fem::int0;
  int lnq2 = fem::int0;
  int loq = fem::int0;
  int iof01 = fem::int0;
  int iof02 = fem::int0;
  int iof03 = fem::int0;
  int iof04 = fem::int0;
  int iof05 = fem::int0;
  int iof06 = fem::int0;
  int iof07 = fem::int0;
  int iof08 = fem::int0;
  int iof09 = fem::int0;
  int iof10 = fem::int0;
  int iof11 = fem::int0;
  int iof12 = fem::int0;
  int iof13 = fem::int0;
  int iof14 = fem::int0;
  int iof15 = fem::int0;
  int iof16 = fem::int0;
  int iof17 = fem::int0;
  int iof18 = fem::int0;
  int iof19 = fem::int0;
  int iof20 = fem::int0;
  int iof21 = fem::int0;
  int iof22 = fem::int0;
  int iof23 = fem::int0;
  int iof24 = fem::int0;
  int iof25 = fem::int0;
  int iof26 = fem::int0;
  int iof27 = fem::int0;
  int iof28 = fem::int0;
  int iof29 = fem::int0;
  int iof30 = fem::int0;
  int iof31 = fem::int0;
  int iof32 = fem::int0;
  int iof33 = fem::int0;
  int iof34 = fem::int0;
  int iof35 = fem::int0;
  int iof36 = fem::int0;
  int iof37 = fem::int0;
  int iof38 = fem::int0;
  int iof39 = fem::int0;
  int iof40 = fem::int0;
  int iof41 = fem::int0;
  int iof42 = fem::int0;
  int iof43 = fem::int0;
  int iof44 = fem::int0;
  int iof45 = fem::int0;
  int iof46 = fem::int0;
  int iof47 = fem::int0;
  int iof48 = fem::int0;
  int iof49 = fem::int0;
  int iof50 = fem::int0;
  int iof51 = fem::int0;
  int iof52 = fem::int0;
  int iof53 = fem::int0;
  int n13 = fem::int0;
  arr_1d<1, int> itg(fem::fill0);
  arr_1d<1, double> rtg(fem::fill0);
  arr_1d<1, std::complex<double> > ctg(fem::fill0);
  //C!w EQUIVALENCE  ( KARRAY(1), ITG(1), RTG(1), CTG(1) )
  //C
  if (iprsup >= 1) {
    write(lunit6, "('  BEGIN MODULE \"SUBR47\".')");
  }
  n8 = nchain;
  if (cmn.kburro == 1) {
    n8 = 29;
  }
  dimens(lltemp(1), n8, trash, trash);
  n7 = lltemp(2) * nbyte(4) / nbyte(3);
  cc = 2 * nbyte(2);
  ppa = nbyte(3);
  cc = cc / ppa;
  dd = 2 + ktrlsw(3);
  ppa = 12.f + 12.f * dd * dd * (1.f + 3.f * cc * cc);
  ppb = 36.f + dd * (5.f + cc);
  cc = n7 - 50;
  cc = 2.f * ppa * cc + ppb * ppb;
  cc = (sqrtz(cc) - ppb) / ppa;
  ldm = cc;
  ldn = cc * dd;
  if (iprsup > 0) {
    write(lunit6,
      "('  THE CABLE NUMBER IS LIMITED TO ',i4,/,"
      "'  THE CONDUCTOR NUMBER IS LIMITED TO ',i4)"),
      ldm, ldn;
  }
  ldn2 = ldn + ldn;
  lmq = ldm * ldm;
  lnq = ldn * ldn;
  lnq2 = lnq + lnq;
  loq = 3 * ldm;
  iof01 = 1;
  iof02 = iof01 + ldn;
  iof03 = (iof02 + ldm) * nbyte(4) / nbyte(3) + 2;
  iof04 = iof03 + ldm;
  iof05 = iof04 + ldm;
  iof06 = iof05 + ldm;
  iof07 = iof06 + ldm;
  iof08 = iof07 + ldm;
  iof09 = iof08 + ldm;
  iof10 = iof09 + ldm;
  iof11 = iof10 + ldm;
  iof12 = iof11 + ldm;
  iof13 = iof12 + ldm;
  iof14 = iof13 + ldm;
  iof15 = iof14 + ldm;
  iof16 = iof15 + ldn;
  iof17 = iof16 + ldn;
  iof18 = iof17 + ldn;
  iof19 = iof18 + ldn;
  iof20 = iof19 + lnq;
  iof21 = iof20 + lnq;
  iof22 = iof21 + lnq;
  iof23 = iof22 + lnq;
  iof24 = iof23 + lmq;
  iof25 = iof24 + lmq;
  iof26 = iof25 + lmq;
  iof27 = iof26 + lmq;
  iof28 = iof27 + lmq;
  iof29 = iof28 + lmq;
  iof30 = iof29 + loq;
  iof31 = iof30 + loq;
  iof32 = iof31 + loq;
  iof33 = iof32 + loq;
  iof34 = iof33 + 3 * ldn;
  iof35 = iof34 + 7 * ldm;
  iof36 = (iof35 + lnq2) * nbyte(3) / (nbyte(2) * 2) + 2;
  iof37 = iof36 + ldn;
  iof38 = iof37 + lnq;
  iof39 = iof38 + lnq;
  iof40 = iof39 + lnq;
  iof41 = iof40 + lnq;
  iof42 = iof41 + lnq;
  iof43 = iof42 + lnq;
  iof44 = iof43 + lnq;
  iof45 = iof44 + lnq;
  iof46 = iof45 + lnq;
  iof47 = iof46 + lnq;
  iof48 = iof47 + lnq;
  iof49 = iof48 + lnq;
  iof50 = iof49 + lnq;
  iof51 = iof50 + lnq;
  iof52 = iof51 + lnq;
  iof53 = iof52 + lnq;
  //C     STEP OVER LAST VECTOR TO FIND TOTAL MEMORY REQUIREMENTS:          M35.9321
  n13 = (iof53 + lnq2) * 2 * nbyte(2) / nbyte(3);
  if (n13 <= n7) {
    goto statement_7835;
  }
  lstat(19) = 7835;
  kill = 225;
  goto statement_7842;
  statement_7835:
  guts47(cmn, itg(iof01), itg(iof02), rtg(iof03), rtg(iof04), rtg(iof05),
    rtg(iof06), rtg(iof07), rtg(iof08), rtg(iof09), rtg(iof10), rtg(iof11),
    rtg(iof12), rtg(iof13), rtg(iof14), rtg(iof15), rtg(iof16), rtg(iof17),
    rtg(iof18), rtg(iof19), rtg(iof20), rtg(iof21), rtg(iof22), rtg(iof23),
    rtg(iof24), rtg(iof25), rtg(iof26), rtg(iof27), rtg(iof28), rtg(iof29),
    rtg(iof30), rtg(iof31), rtg(iof32), rtg(iof33), rtg(iof34), rtg(iof35),
    ctg(iof36), ctg(iof37), ctg(iof38), ctg(iof39), ctg(iof40), ctg(iof41),
    ctg(iof42), ctg(iof43), ctg(iof44), ctg(iof45), ctg(iof46), ctg(iof47),
    ctg(iof48), ctg(iof49), ctg(iof50), ctg(iof51), ctg(iof52), ctg(iof53),
    ldm, ldn, ldn2, lnq2);
  statement_7842:
  if (kill > 0) {
    lstat(18) = nchain;
  }
  cmn.lastov = 47;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
over47(
  common& cmn)
{
  //C!include 'DECK29.inc'
  subr47(cmn);
}

struct blockdata_unnamed_save
{
};

void
blockdata_unnamed(
  common& cmn) try
{
  FEM_CMN_SVE(blockdata_unnamed);
  // COMMON spykom
  auto& ivec = cmn.ivec;
  auto& iascii = cmn.iascii;
  // COMMON spyf77
  auto& symb = cmn.symb;
  //
  if (is_called_first_time) {
    symb(1) = "BUS1  ";
    ivec(1) = 0;
    iascii(1) = 1;
    symb(2) = "BUS2  ";
    ivec(2) = 0;
    iascii(2) = 1;
    symb(3) = "BUS3  ";
    ivec(3) = 0;
    iascii(3) = 1;
    symb(4) = "BUS4  ";
    ivec(4) = 0;
    iascii(4) = 1;
    symb(5) = "BUS5  ";
    ivec(5) = 0;
    iascii(5) = 1;
    symb(6) = "BUS6  ";
    ivec(6) = 0;
    iascii(6) = 1;
    symb(7) = "TRASH ";
    ivec(7) = 0;
    iascii(7) = 1;
    symb(8) = "BLANK ";
    ivec(8) = 0;
    iascii(8) = 1;
    symb(9) = "TERRA ";
    ivec(9) = 0;
    iascii(9) = 1;
    symb(10) = "USERID";
    ivec(10) = 0;
    iascii(10) = 1;
    symb(11) = "BRANCH";
    ivec(11) = 0;
    iascii(11) = 1;
    symb(12) = "COPY  ";
    ivec(12) = 0;
    iascii(12) = 1;
    symb(13) = "CSEPAR";
    ivec(13) = 0;
    iascii(13) = 1;
    symb(14) = "CHCONT";
    ivec(14) = 0;
    iascii(14) = 1;
    symb(15) = "TEXCOL";
    ivec(15) = 1;
    iascii(15) = 1;
    symb(16) = "TEXTA6";
    ivec(16) = 1;
    iascii(16) = 1;
    symb(17) = "DATE1 ";
    ivec(17) = 1;
    iascii(17) = 1;
    symb(18) = "TCLOCK";
    ivec(18) = 1;
    iascii(18) = 1;
    symb(19) = "VSTACS";
    ivec(19) = 1;
    iascii(19) = 1;
    symb(20) = "ABUFF ";
    ivec(20) = 1;
    iascii(20) = 1;
    symb(21) = "CI1   ";
    ivec(21) = 0;
    iascii(21) = 0;
    symb(22) = "CK1   ";
    ivec(22) = 0;
    iascii(22) = 0;
    symb(23) = "DELTAT";
    ivec(23) = 0;
    iascii(23) = 0;
    symb(24) = "DELTA2";
    ivec(24) = 0;
    iascii(24) = 0;
    symb(25) = "FREQCS";
    ivec(25) = 0;
    iascii(25) = 0;
    symb(26) = "EPSILN";
    ivec(26) = 0;
    iascii(26) = 0;
    symb(27) = "XUNITS";
    ivec(27) = 0;
    iascii(27) = 0;
    symb(28) = "AINCR ";
    ivec(28) = 0;
    iascii(28) = 0;
    symb(29) = "XMAXMX";
    ivec(29) = 0;
    iascii(29) = 0;
    symb(30) = "ZNVREF";
    ivec(30) = 0;
    iascii(30) = 0;
    symb(31) = "EPSZNO";
    ivec(31) = 0;
    iascii(31) = 0;
    symb(32) = "EPWARN";
    ivec(32) = 0;
    iascii(32) = 0;
    symb(33) = "EPSTOP";
    ivec(33) = 0;
    iascii(33) = 0;
    symb(34) = "T     ";
    ivec(34) = 0;
    iascii(34) = 0;
    symb(35) = "HERTZ ";
    ivec(35) = 0;
    iascii(35) = 0;
    symb(36) = "TOLMAT";
    ivec(36) = 0;
    iascii(36) = 0;
    symb(37) = "TWOPI ";
    ivec(37) = 0;
    iascii(37) = 0;
    symb(38) = "TMAX  ";
    ivec(38) = 0;
    iascii(38) = 0;
    symb(39) = "OMEGA ";
    ivec(39) = 0;
    iascii(39) = 0;
    symb(40) = "COPT  ";
    ivec(40) = 0;
    iascii(40) = 0;
    symb(41) = "XOPT  ";
    ivec(41) = 0;
    iascii(41) = 0;
    symb(42) = "SZPLT ";
    ivec(42) = 0;
    iascii(42) = 0;
    symb(43) = "SZBED ";
    ivec(43) = 0;
    iascii(43) = 0;
    symb(44) = "SGLFIR";
    ivec(44) = 0;
    iascii(44) = 0;
    symb(45) = "SIGMAX";
    ivec(45) = 0;
    iascii(45) = 0;
    symb(46) = "EPSUBA";
    ivec(46) = 0;
    iascii(46) = 0;
    symb(47) = "EPDGEL";
    ivec(47) = 0;
    iascii(47) = 0;
    symb(48) = "EPOMEG";
    ivec(48) = 0;
    iascii(48) = 0;
    symb(49) = "FMINFS";
    ivec(49) = 0;
    iascii(49) = 0;
    symb(50) = "DELFFS";
    ivec(50) = 0;
    iascii(50) = 0;
    symb(51) = "FMAXFS";
    ivec(51) = 0;
    iascii(51) = 0;
    symb(52) = "TENERG";
    ivec(52) = 0;
    iascii(52) = 0;
    symb(53) = "BEGMAX";
    ivec(53) = 1;
    iascii(53) = 0;
    symb(54) = "TENM3 ";
    ivec(54) = 0;
    iascii(54) = 0;
    symb(55) = "TENM6 ";
    ivec(55) = 0;
    iascii(55) = 0;
    symb(56) = "UNITY ";
    ivec(56) = 0;
    iascii(56) = 0;
    symb(57) = "ONEHAF";
    ivec(57) = 0;
    iascii(57) = 0;
    symb(58) = "PEAKND";
    ivec(58) = 1;
    iascii(58) = 0;
    symb(59) = "FLTINF";
    ivec(59) = 0;
    iascii(59) = 0;
    symb(60) = "FLZERO";
    ivec(60) = 0;
    iascii(60) = 0;
    symb(61) = "DEGMIN";
    ivec(61) = 0;
    iascii(61) = 0;
    symb(62) = "DEGMAX";
    ivec(62) = 0;
    iascii(62) = 0;
    symb(63) = "STATFR";
    ivec(63) = 0;
    iascii(63) = 0;
    symb(64) = "VOLTBC";
    ivec(64) = 1;
    iascii(64) = 0;
    symb(65) = "FLSTAT";
    ivec(65) = 1;
    iascii(65) = 0;
    symb(66) = "DTNEXT";
    ivec(66) = 1;
    iascii(66) = 0;
    symb(67) = "ANGLE ";
    ivec(67) = 0;
    iascii(67) = 0;
    symb(68) = "PU    ";
    ivec(68) = 0;
    iascii(68) = 0;
    symb(69) = "SEEDR ";
    ivec(69) = 0;
    iascii(69) = 0;
    symb(70) = "SPEEDL";
    ivec(70) = 0;
    iascii(70) = 0;
    symb(71) = "KSTART";
    ivec(71) = 0;
    iascii(71) = 0;
    symb(72) = "KNT   ";
    ivec(72) = 0;
    iascii(72) = 0;
    symb(73) = "KBASE ";
    ivec(73) = 0;
    iascii(73) = 0;
    symb(74) = "LTDELT";
    ivec(74) = 0;
    iascii(74) = 0;
    symb(75) = "UNUSED";
    ivec(75) = 0;
    iascii(75) = 0;
    symb(76) = "MTAPE ";
    ivec(76) = 0;
    iascii(76) = 0;
    symb(77) = "LUNIT1";
    ivec(77) = 0;
    iascii(77) = 0;
    symb(78) = "LUNIT2";
    ivec(78) = 0;
    iascii(78) = 0;
    symb(79) = "LUNIT3";
    ivec(79) = 0;
    iascii(79) = 0;
    symb(80) = "LUNIT4";
    ivec(80) = 0;
    iascii(80) = 0;
    symb(81) = "LUNIT5";
    ivec(81) = 0;
    iascii(81) = 0;
    symb(82) = "LUNIT6";
    ivec(82) = 0;
    iascii(82) = 0;
    symb(83) = "LUNIT7";
    ivec(83) = 0;
    iascii(83) = 0;
    symb(84) = "LUNIT8";
    ivec(84) = 0;
    iascii(84) = 0;
    symb(85) = "LUNIT9";
    ivec(85) = 0;
    iascii(85) = 0;
    symb(86) = "LUNT10";
    ivec(86) = 0;
    iascii(86) = 0;
    symb(87) = "LUNT11";
    ivec(87) = 0;
    iascii(87) = 0;
    symb(88) = "LUNT12";
    ivec(88) = 0;
    iascii(88) = 0;
    symb(89) = "LUNT13";
    ivec(89) = 0;
    iascii(89) = 0;
    symb(90) = "LUNT14";
    ivec(90) = 0;
    iascii(90) = 0;
    symb(91) = "LUNT15";
    ivec(91) = 0;
    iascii(91) = 0;
    symb(92) = "NEXOUT";
    ivec(92) = 1;
    iascii(92) = 0;
    symb(93) = "NRIGHT";
    ivec(93) = 0;
    iascii(93) = 0;
    symb(94) = "NFRFLD";
    ivec(94) = 0;
    iascii(94) = 0;
    symb(95) = "KOLBEG";
    ivec(95) = 0;
    iascii(95) = 0;
    symb(96) = "KPRCHG";
    ivec(96) = 1;
    iascii(96) = 0;
    symb(97) = "MULTPR";
    ivec(97) = 1;
    iascii(97) = 0;
    symb(98) = "IPNTV ";
    ivec(98) = 1;
    iascii(98) = 0;
    symb(99) = "INDTV ";
    ivec(99) = 1;
    iascii(99) = 0;
    symb(100) = "LSTAT ";
    ivec(100) = 1;
    iascii(100) = 0;
    symb(101) = "NBYTE ";
    ivec(101) = 1;
    iascii(101) = 0;
    symb(102) = "LUNSAV";
    ivec(102) = 1;
    iascii(102) = 0;
    symb(103) = "IPRSOV";
    ivec(103) = 1;
    iascii(103) = 0;
    symb(104) = "ICHECK";
    ivec(104) = 0;
    iascii(104) = 0;
    symb(105) = "UNUSED";
    ivec(105) = 0;
    iascii(105) = 0;
    symb(106) = "IEND  ";
    ivec(106) = 0;
    iascii(106) = 0;
    symb(107) = "ILINE ";
    ivec(107) = 0;
    iascii(107) = 0;
    symb(108) = "INONL ";
    ivec(108) = 0;
    iascii(108) = 0;
    symb(109) = "IOLD  ";
    ivec(109) = 0;
    iascii(109) = 0;
    symb(110) = "IOUT  ";
    ivec(110) = 0;
    iascii(110) = 0;
    symb(111) = "IPRINT";
    ivec(111) = 0;
    iascii(111) = 0;
    symb(112) = "IPUNCH";
    ivec(112) = 0;
    iascii(112) = 0;
    symb(113) = "IREAD ";
    ivec(113) = 0;
    iascii(113) = 0;
    symb(114) = "KOL132";
    ivec(114) = 0;
    iascii(114) = 0;
    symb(115) = "ISTEP ";
    ivec(115) = 0;
    iascii(115) = 0;
    symb(116) = "UNUSED";
    ivec(116) = 0;
    iascii(116) = 0;
    symb(117) = "ITYPE ";
    ivec(117) = 0;
    iascii(117) = 0;
    symb(118) = "IT1   ";
    ivec(118) = 0;
    iascii(118) = 0;
    symb(119) = "IT2   ";
    ivec(119) = 0;
    iascii(119) = 0;
    symb(120) = "IUPPER";
    ivec(120) = 0;
    iascii(120) = 0;
    symb(121) = "IZERO ";
    ivec(121) = 0;
    iascii(121) = 0;
    symb(122) = "KCOUNT";
    ivec(122) = 0;
    iascii(122) = 0;
    symb(123) = "ISTEAD";
    ivec(123) = 0;
    iascii(123) = 0;
    symb(124) = "UNUSED";
    ivec(124) = 0;
    iascii(124) = 0;
    symb(125) = "LDATA ";
    ivec(125) = 0;
    iascii(125) = 0;
    symb(126) = "LBRNCH";
    ivec(126) = 0;
    iascii(126) = 0;
    symb(127) = "LIMTXF";
    ivec(127) = 0;
    iascii(127) = 0;
    symb(128) = "MDEBUG";
    ivec(128) = 0;
    iascii(128) = 0;
    symb(129) = "LEXCT ";
    ivec(129) = 0;
    iascii(129) = 0;
    symb(130) = "LBUS  ";
    ivec(130) = 0;
    iascii(130) = 0;
    symb(131) = "LYMAT ";
    ivec(131) = 0;
    iascii(131) = 0;
    symb(132) = "LSWTCH";
    ivec(132) = 0;
    iascii(132) = 0;
    symb(133) = "LNONL ";
    ivec(133) = 0;
    iascii(133) = 0;
    symb(134) = "LCHAR ";
    ivec(134) = 0;
    iascii(134) = 0;
    symb(135) = "M4PLOT";
    ivec(135) = 0;
    iascii(135) = 0;
    symb(136) = "LPAST ";
    ivec(136) = 0;
    iascii(136) = 0;
    symb(137) = "LSMAT ";
    ivec(137) = 0;
    iascii(137) = 0;
    symb(138) = "IPLOT ";
    ivec(138) = 0;
    iascii(138) = 0;
    symb(139) = "NCOMP ";
    ivec(139) = 0;
    iascii(139) = 0;
    symb(140) = "NV    ";
    ivec(140) = 0;
    iascii(140) = 0;
    symb(141) = "LCOMP ";
    ivec(141) = 0;
    iascii(141) = 0;
    symb(142) = "NUMSM ";
    ivec(142) = 0;
    iascii(142) = 0;
    symb(143) = "IFDEP ";
    ivec(143) = 0;
    iascii(143) = 0;
    symb(144) = "LTAILS";
    ivec(144) = 0;
    iascii(144) = 0;
    symb(145) = "LFDEP ";
    ivec(145) = 0;
    iascii(145) = 0;
    symb(146) = "LWT   ";
    ivec(146) = 0;
    iascii(146) = 0;
    symb(147) = "LAST  ";
    ivec(147) = 0;
    iascii(147) = 0;
    symb(148) = "NPOWER";
    ivec(148) = 0;
    iascii(148) = 0;
    symb(149) = "MAXPE ";
    ivec(149) = 0;
    iascii(149) = 0;
    symb(150) = "LPEAK ";
    ivec(150) = 0;
    iascii(150) = 0;
    symb(151) = "NOUT  ";
    ivec(151) = 0;
    iascii(151) = 0;
    symb(152) = "IV    ";
    ivec(152) = 0;
    iascii(152) = 0;
    symb(153) = "INEOF ";
    ivec(153) = 0;
    iascii(153) = 0;
    symb(154) = "KTRLSW";
    ivec(154) = 1;
    iascii(154) = 0;
    symb(155) = "NUM99 ";
    ivec(155) = 0;
    iascii(155) = 0;
    symb(156) = "KPARTB";
    ivec(156) = 0;
    iascii(156) = 0;
    symb(157) = "LLBUFF";
    ivec(157) = 0;
    iascii(157) = 0;
    symb(158) = "KANAL ";
    ivec(158) = 0;
    iascii(158) = 0;
    symb(159) = "NSMTH ";
    ivec(159) = 0;
    iascii(159) = 0;
    symb(160) = "NTCSEX";
    ivec(160) = 0;
    iascii(160) = 0;
    symb(161) = "NSTACS";
    ivec(161) = 0;
    iascii(161) = 0;
    symb(162) = "KLOAEP";
    ivec(162) = 0;
    iascii(162) = 0;
    symb(163) = "LASTOV";
    ivec(163) = 0;
    iascii(163) = 0;
    symb(164) = "LTACST";
    ivec(164) = 0;
    iascii(164) = 0;
    symb(165) = "LHIST ";
    ivec(165) = 0;
    iascii(165) = 0;
    symb(166) = "IFX   ";
    ivec(166) = 0;
    iascii(166) = 0;
    symb(167) = "NDELTA";
    ivec(167) = 0;
    iascii(167) = 0;
    symb(168) = "IDELTA";
    ivec(168) = 0;
    iascii(168) = 0;
    symb(169) = "INECHO";
    ivec(169) = 0;
    iascii(169) = 0;
    symb(170) = "NOUTPR";
    ivec(170) = 0;
    iascii(170) = 0;
    symb(171) = "KTAB  ";
    ivec(171) = 0;
    iascii(171) = 0;
    symb(172) = "JFLSOS";
    ivec(172) = 0;
    iascii(172) = 0;
    symb(173) = "NUMDCD";
    ivec(173) = 0;
    iascii(173) = 0;
    symb(174) = "NUMUM ";
    ivec(174) = 0;
    iascii(174) = 0;
    symb(175) = "LSPCUM";
    ivec(175) = 0;
    iascii(175) = 0;
    symb(176) = "NPHCAS";
    ivec(176) = 0;
    iascii(176) = 0;
    symb(177) = "LOCZ11";
    ivec(177) = 0;
    iascii(177) = 0;
    symb(178) = "LOCBR1";
    ivec(178) = 0;
    iascii(178) = 0;
    symb(179) = "IALTER";
    ivec(179) = 0;
    iascii(179) = 0;
    symb(180) = "ICHAR ";
    ivec(180) = 0;
    iascii(180) = 0;
    symb(181) = "KTREF ";
    ivec(181) = 0;
    iascii(181) = 0;
    symb(182) = "KPH   ";
    ivec(182) = 0;
    iascii(182) = 0;
    symb(183) = "KREQAB";
    ivec(183) = 0;
    iascii(183) = 0;
    symb(184) = "KSAT  ";
    ivec(184) = 0;
    iascii(184) = 0;
    symb(185) = "MEMSAV";
    ivec(185) = 0;
    iascii(185) = 0;
    symb(186) = "LISOFF";
    ivec(186) = 0;
    iascii(186) = 0;
    symb(187) = "LSPOV4";
    ivec(187) = 0;
    iascii(187) = 0;
    symb(188) = "KBURRO";
    ivec(188) = 0;
    iascii(188) = 0;
    symb(189) = "IAVERG";
    ivec(189) = 0;
    iascii(189) = 0;
    symb(190) = "LSIZ23";
    ivec(190) = 0;
    iascii(190) = 0;
    symb(191) = "LSIZ26";
    ivec(191) = 0;
    iascii(191) = 0;
    symb(192) = "NUMOUT";
    ivec(192) = 0;
    iascii(192) = 0;
    symb(193) = "MOLDAT";
    ivec(193) = 0;
    iascii(193) = 0;
    symb(194) = "LSIZ27";
    ivec(194) = 0;
    iascii(194) = 0;
    symb(195) = "LTLABL";
    ivec(195) = 0;
    iascii(195) = 0;
    symb(196) = "IWT   ";
    ivec(196) = 0;
    iascii(196) = 0;
    symb(197) = "IFDEP2";
    ivec(197) = 0;
    iascii(197) = 0;
    symb(198) = "IDOUBL";
    ivec(198) = 0;
    iascii(198) = 0;
    symb(199) = "IOUTIN";
    ivec(199) = 0;
    iascii(199) = 0;
    symb(200) = "IPUN  ";
    ivec(200) = 0;
    iascii(200) = 0;
    symb(201) = "JST   ";
    ivec(201) = 0;
    iascii(201) = 0;
    symb(202) = "JST1  ";
    ivec(202) = 0;
    iascii(202) = 0;
    symb(203) = "UNUSED";
    ivec(203) = 0;
    iascii(203) = 0;
    symb(204) = "NUMSUB";
    ivec(204) = 0;
    iascii(204) = 0;
    symb(205) = "MAXZNO";
    ivec(205) = 0;
    iascii(205) = 0;
    symb(206) = "KALPLT";
    ivec(206) = 0;
    iascii(206) = 0;
    symb(207) = "NIOMAX";
    ivec(207) = 0;
    iascii(207) = 0;
    symb(208) = "NIAMAX";
    ivec(208) = 0;
    iascii(208) = 0;
    symb(209) = "IBR1  ";
    ivec(209) = 0;
    iascii(209) = 0;
    symb(210) = "IFSEM ";
    ivec(210) = 0;
    iascii(210) = 0;
    symb(211) = "LFSEM ";
    ivec(211) = 0;
    iascii(211) = 0;
    symb(212) = "IADD  ";
    ivec(212) = 0;
    iascii(212) = 0;
    symb(213) = "LFD   ";
    ivec(213) = 0;
    iascii(213) = 0;
    symb(214) = "LAUX  ";
    ivec(214) = 0;
    iascii(214) = 0;
    symb(215) = "IOFGND";
    ivec(215) = 0;
    iascii(215) = 0;
    symb(216) = "IOFBND";
    ivec(216) = 0;
    iascii(216) = 0;
    symb(217) = "UNUSED";
    ivec(217) = 0;
    iascii(217) = 0;
    symb(218) = "JSEEDR";
    ivec(218) = 0;
    iascii(218) = 0;
    symb(219) = "MODOUT";
    ivec(219) = 0;
    iascii(219) = 0;
    symb(220) = "IFTAIL";
    ivec(220) = 0;
    iascii(220) = 0;
    symb(221) = "IPOINT";
    ivec(221) = 0;
    iascii(221) = 0;
    symb(222) = "LPAST2";
    ivec(222) = 0;
    iascii(222) = 0;
    symb(223) = "NCURR ";
    ivec(223) = 0;
    iascii(223) = 0;
    symb(224) = "IOFFD ";
    ivec(224) = 0;
    iascii(224) = 0;
    symb(225) = "ISPLOT";
    ivec(225) = 0;
    iascii(225) = 0;
    symb(226) = "ISPRIN";
    ivec(226) = 0;
    iascii(226) = 0;
    symb(227) = "MAXOUT";
    ivec(227) = 0;
    iascii(227) = 0;
    symb(228) = "IPOS  ";
    ivec(228) = 0;
    iascii(228) = 0;
    symb(229) = "UNUSED";
    ivec(229) = 0;
    iascii(229) = 0;
    symb(230) = "UNUSED";
    ivec(230) = 0;
    iascii(230) = 0;
    symb(231) = "KILL  ";
    ivec(231) = 0;
    iascii(231) = 0;
    symb(232) = "IVOLT ";
    ivec(232) = 0;
    iascii(232) = 0;
    symb(233) = "NCHAIN";
    ivec(233) = 0;
    iascii(233) = 0;
    symb(234) = "IPRSUP";
    ivec(234) = 0;
    iascii(234) = 0;
    symb(235) = "UNUSED";
    ivec(235) = 0;
    iascii(235) = 0;
    symb(236) = "INTINF";
    ivec(236) = 0;
    iascii(236) = 0;
    symb(237) = "KCONST";
    ivec(237) = 0;
    iascii(237) = 0;
    symb(238) = "KSWTCH";
    ivec(238) = 0;
    iascii(238) = 0;
    symb(239) = "IT    ";
    ivec(239) = 0;
    iascii(239) = 0;
    symb(240) = "NTOT  ";
    ivec(240) = 0;
    iascii(240) = 0;
    symb(241) = "IBR   ";
    ivec(241) = 0;
    iascii(241) = 0;
    symb(242) = "LCOM10";
    ivec(242) = 0;
    iascii(242) = 0;
    symb(243) = "LTRNST";
    ivec(243) = 0;
    iascii(243) = 0;
    symb(244) = "LSYN  ";
    ivec(244) = 0;
    iascii(244) = 0;
    symb(245) = "KSSOUT";
    ivec(245) = 0;
    iascii(245) = 0;
    symb(246) = "LOOPSS";
    ivec(246) = 1;
    iascii(246) = 0;
    symb(247) = "INFEXP";
    ivec(247) = 0;
    iascii(247) = 0;
    symb(248) = "NUMREF";
    ivec(248) = 0;
    iascii(248) = 0;
    symb(249) = "NWORD1";
    ivec(249) = 0;
    iascii(249) = 0;
    symb(250) = "NWORD2";
    ivec(250) = 0;
    iascii(250) = 0;
    symb(251) = "ILOAEP";
    ivec(251) = 0;
    iascii(251) = 0;
    symb(252) = "LNPIN ";
    ivec(252) = 0;
    iascii(252) = 0;
    symb(253) = "NTOT1 ";
    ivec(253) = 0;
    iascii(253) = 0;
    symb(254) = "LIMSTP";
    ivec(254) = 0;
    iascii(254) = 0;
    symb(255) = "INDSTP";
    ivec(255) = 0;
    iascii(255) = 0;
    symb(256) = "NC    ";
    ivec(256) = 0;
    iascii(256) = 0;
    symb(257) = "UNUSED";
    ivec(257) = 0;
    iascii(257) = 0;
    symb(258) = "UNUSED";
    ivec(258) = 0;
    iascii(258) = 0;
    symb(259) = "ICAT  ";
    ivec(259) = 0;
    iascii(259) = 0;
    symb(260) = "NUMNVO";
    ivec(260) = 0;
    iascii(260) = 0;
    symb(261) = "UNUSED";
    ivec(261) = 0;
    iascii(261) = 0;
    symb(262) = "NENERG";
    ivec(262) = 0;
    iascii(262) = 0;
    symb(263) = "ISW   ";
    ivec(263) = 0;
    iascii(263) = 0;
    symb(264) = "ITEST ";
    ivec(264) = 0;
    iascii(264) = 0;
    symb(265) = "IDIST ";
    ivec(265) = 0;
    iascii(265) = 0;
    symb(266) = "X     ";
    ivec(266) = 1;
    iascii(266) = 0;
    symb(267) = "YKM   ";
    ivec(267) = 1;
    iascii(267) = 0;
    symb(268) = "KM    ";
    ivec(268) = 1;
    iascii(268) = 0;
    symb(269) = "XK    ";
    ivec(269) = 1;
    iascii(269) = 0;
    symb(270) = "XM    ";
    ivec(270) = 1;
    iascii(270) = 0;
    symb(271) = "WEIGHT";
    ivec(271) = 1;
    iascii(271) = 0;
    symb(272) = "IWTENT";
    ivec(272) = 1;
    iascii(272) = 0;
    symb(273) = "CON1  ";
    ivec(273) = 1;
    iascii(273) = 0;
    symb(274) = "ISKIP ";
    ivec(274) = 1;
    iascii(274) = 0;
    symb(275) = "ZINF  ";
    ivec(275) = 1;
    iascii(275) = 0;
    symb(276) = "ETA   ";
    ivec(276) = 1;
    iascii(276) = 0;
    symb(277) = "NHIST ";
    ivec(277) = 1;
    iascii(277) = 0;
    symb(278) = "STAILM";
    ivec(278) = 1;
    iascii(278) = 0;
    symb(279) = "STAILK";
    ivec(279) = 1;
    iascii(279) = 0;
    symb(280) = "XMAX  ";
    ivec(280) = 1;
    iascii(280) = 0;
    symb(281) = "KOUTVP";
    ivec(281) = 1;
    iascii(281) = 0;
    symb(282) = "BNRG  ";
    ivec(282) = 1;
    iascii(282) = 0;
    symb(283) = "SCONST";
    ivec(283) = 1;
    iascii(283) = 0;
    symb(284) = "CNVHST";
    ivec(284) = 1;
    iascii(284) = 0;
    symb(285) = "SFD   ";
    ivec(285) = 1;
    iascii(285) = 0;
    symb(286) = "QFD   ";
    ivec(286) = 1;
    iascii(286) = 0;
    symb(287) = "SEMAUX";
    ivec(287) = 1;
    iascii(287) = 0;
    symb(288) = "IBSOUT";
    ivec(288) = 1;
    iascii(288) = 0;
    symb(289) = "BVALUE";
    ivec(289) = 1;
    iascii(289) = 0;
    symb(290) = "SPTACS";
    ivec(290) = 1;
    iascii(290) = 0;
    symb(291) = "KSWTYP";
    ivec(291) = 1;
    iascii(291) = 0;
    symb(292) = "MODSWT";
    ivec(292) = 1;
    iascii(292) = 0;
    symb(293) = "KBEGSW";
    ivec(293) = 1;
    iascii(293) = 0;
    symb(294) = "LASTSW";
    ivec(294) = 1;
    iascii(294) = 0;
    symb(295) = "KENTNB";
    ivec(295) = 1;
    iascii(295) = 0;
    symb(296) = "NBHDSW";
    ivec(296) = 1;
    iascii(296) = 0;
    symb(297) = "TOPEN ";
    ivec(297) = 1;
    iascii(297) = 0;
    symb(298) = "CRIT  ";
    ivec(298) = 1;
    iascii(298) = 0;
    symb(299) = "KDEPSW";
    ivec(299) = 1;
    iascii(299) = 0;
    symb(300) = "TDNS  ";
    ivec(300) = 1;
    iascii(300) = 0;
    symb(301) = "ISOURC";
    ivec(301) = 1;
    iascii(301) = 0;
    symb(302) = "ENERGY";
    ivec(302) = 1;
    iascii(302) = 0;
    symb(303) = "IARDUB";
    ivec(303) = 1;
    iascii(303) = 0;
    symb(304) = "ARDUBE";
    ivec(304) = 1;
    iascii(304) = 0;
    symb(305) = "NONLAD";
    ivec(305) = 1;
    iascii(305) = 0;
    symb(306) = "NONLE ";
    ivec(306) = 1;
    iascii(306) = 0;
    symb(307) = "VNONL ";
    ivec(307) = 1;
    iascii(307) = 0;
    symb(308) = "CURR  ";
    ivec(308) = 1;
    iascii(308) = 0;
    symb(309) = "ANONL ";
    ivec(309) = 1;
    iascii(309) = 0;
    symb(310) = "VECNL1";
    ivec(310) = 1;
    iascii(310) = 0;
    symb(311) = "VECNL2";
    ivec(311) = 1;
    iascii(311) = 0;
    symb(312) = "BRNONL";
    ivec(312) = 1;
    iascii(312) = 1;
    symb(313) = "VZER5 ";
    ivec(313) = 1;
    iascii(313) = 0;
    symb(314) = "ILAST ";
    ivec(314) = 1;
    iascii(314) = 0;
    symb(315) = "NLTYPE";
    ivec(315) = 1;
    iascii(315) = 0;
    symb(316) = "KUPL  ";
    ivec(316) = 1;
    iascii(316) = 0;
    symb(317) = "NLSUB ";
    ivec(317) = 1;
    iascii(317) = 0;
    symb(318) = "CURSUB";
    ivec(318) = 1;
    iascii(318) = 0;
    symb(319) = "CCHAR ";
    ivec(319) = 1;
    iascii(319) = 0;
    symb(320) = "VCHAR ";
    ivec(320) = 1;
    iascii(320) = 0;
    symb(321) = "GSLOPE";
    ivec(321) = 1;
    iascii(321) = 0;
    symb(322) = "KK    ";
    ivec(322) = 1;
    iascii(322) = 0;
    symb(323) = "C     ";
    ivec(323) = 1;
    iascii(323) = 0;
    symb(324) = "TR    ";
    ivec(324) = 1;
    iascii(324) = 0;
    symb(325) = "TX    ";
    ivec(325) = 1;
    iascii(325) = 0;
    symb(326) = "R     ";
    ivec(326) = 1;
    iascii(326) = 0;
    symb(327) = "NR    ";
    ivec(327) = 1;
    iascii(327) = 0;
    symb(328) = "LENGTH";
    ivec(328) = 1;
    iascii(328) = 0;
    symb(329) = "CIK   ";
    ivec(329) = 1;
    iascii(329) = 0;
    symb(330) = "CI    ";
    ivec(330) = 1;
    iascii(330) = 0;
    symb(331) = "CK    ";
    ivec(331) = 1;
    iascii(331) = 0;
    symb(332) = "SWNAME";
    ivec(332) = 1;
    iascii(332) = 1;
    symb(333) = "IBRNCH";
    ivec(333) = 1;
    iascii(333) = 0;
    symb(334) = "JBRNCH";
    ivec(334) = 1;
    iascii(334) = 0;
    symb(335) = "TSTOP ";
    ivec(335) = 1;
    iascii(335) = 0;
    symb(336) = "NONLK ";
    ivec(336) = 1;
    iascii(336) = 0;
    symb(337) = "NONLM ";
    ivec(337) = 1;
    iascii(337) = 0;
    symb(338) = "SPUM  ";
    ivec(338) = 1;
    iascii(338) = 0;
    symb(339) = "KKS   ";
    ivec(339) = 1;
    iascii(339) = 0;
    symb(340) = "KKNONL";
    ivec(340) = 1;
    iascii(340) = 0;
    symb(341) = "ZNONL ";
    ivec(341) = 1;
    iascii(341) = 0;
    symb(342) = "ZNONLB";
    ivec(342) = 1;
    iascii(342) = 0;
    symb(343) = "ZNONLC";
    ivec(343) = 1;
    iascii(343) = 0;
    symb(344) = "FINIT ";
    ivec(344) = 1;
    iascii(344) = 0;
    symb(345) = "KSUB  ";
    ivec(345) = 1;
    iascii(345) = 0;
    symb(346) = "MSUB  ";
    ivec(346) = 1;
    iascii(346) = 0;
    symb(347) = "ISUBEG";
    ivec(347) = 1;
    iascii(347) = 0;
    symb(348) = "LITYPE";
    ivec(348) = 1;
    iascii(348) = 0;
    symb(349) = "IMODEL";
    ivec(349) = 1;
    iascii(349) = 0;
    symb(350) = "KBUS  ";
    ivec(350) = 1;
    iascii(350) = 0;
    symb(351) = "MBUS  ";
    ivec(351) = 1;
    iascii(351) = 0;
    symb(352) = "KODEBR";
    ivec(352) = 1;
    iascii(352) = 0;
    symb(353) = "CKI   ";
    ivec(353) = 1;
    iascii(353) = 0;
    symb(354) = "CKKJM ";
    ivec(354) = 1;
    iascii(354) = 0;
    symb(355) = "INDHST";
    ivec(355) = 1;
    iascii(355) = 0;
    symb(356) = "KODSEM";
    ivec(356) = 1;
    iascii(356) = 0;
    symb(357) = "BRNAME";
    ivec(357) = 1;
    iascii(357) = 1;
    symb(358) = "IFORM ";
    ivec(358) = 1;
    iascii(358) = 0;
    symb(359) = "NODE  ";
    ivec(359) = 1;
    iascii(359) = 0;
    symb(360) = "CREST ";
    ivec(360) = 1;
    iascii(360) = 0;
    symb(361) = "TIME1 ";
    ivec(361) = 1;
    iascii(361) = 0;
    symb(362) = "TIME2 ";
    ivec(362) = 1;
    iascii(362) = 0;
    symb(363) = "TSTART";
    ivec(363) = 1;
    iascii(363) = 0;
    symb(364) = "SFREQ ";
    ivec(364) = 1;
    iascii(364) = 0;
    symb(365) = "KMSWIT";
    ivec(365) = 1;
    iascii(365) = 0;
    symb(366) = "NEXTSW";
    ivec(366) = 1;
    iascii(366) = 0;
    symb(367) = "RMFD  ";
    ivec(367) = 1;
    iascii(367) = 0;
    symb(368) = "CIKFD ";
    ivec(368) = 1;
    iascii(368) = 0;
    symb(369) = "IMFD  ";
    ivec(369) = 1;
    iascii(369) = 0;
    symb(370) = "TCLOSE";
    ivec(370) = 1;
    iascii(370) = 0;
    symb(371) = "ADELAY";
    ivec(371) = 1;
    iascii(371) = 0;
    symb(372) = "KPOS  ";
    ivec(372) = 1;
    iascii(372) = 0;
    symb(373) = "E     ";
    ivec(373) = 1;
    iascii(373) = 0;
    symb(374) = "F     ";
    ivec(374) = 1;
    iascii(374) = 0;
    symb(375) = "KSSFRQ";
    ivec(375) = 1;
    iascii(375) = 0;
    symb(376) = "KODE  ";
    ivec(376) = 1;
    iascii(376) = 0;
    symb(377) = "KPSOUR";
    ivec(377) = 1;
    iascii(377) = 0;
    symb(378) = "VOLTI ";
    ivec(378) = 1;
    iascii(378) = 0;
    symb(379) = "VOLTK ";
    ivec(379) = 1;
    iascii(379) = 0;
    symb(380) = "VOLT  ";
    ivec(380) = 1;
    iascii(380) = 0;
    symb(381) = "BUS   ";
    ivec(381) = 1;
    iascii(381) = 1;
    symb(382) = "ELD   ";
    ivec(382) = 1;
    iascii(382) = 0;
    symb(383) = "ELAF  ";
    ivec(383) = 1;
    iascii(383) = 0;
    symb(384) = "ELF   ";
    ivec(384) = 1;
    iascii(384) = 0;
    symb(385) = "ELAKD ";
    ivec(385) = 1;
    iascii(385) = 0;
    symb(386) = "ELFKD ";
    ivec(386) = 1;
    iascii(386) = 0;
    symb(387) = "ELKD  ";
    ivec(387) = 1;
    iascii(387) = 0;
    symb(388) = "ELQ   ";
    ivec(388) = 1;
    iascii(388) = 0;
    symb(389) = "ELAG  ";
    ivec(389) = 1;
    iascii(389) = 0;
    symb(390) = "ELG   ";
    ivec(390) = 1;
    iascii(390) = 0;
    symb(391) = "ELAKQ ";
    ivec(391) = 1;
    iascii(391) = 0;
    symb(392) = "ELGKQ ";
    ivec(392) = 1;
    iascii(392) = 0;
    symb(393) = "ELKQ  ";
    ivec(393) = 1;
    iascii(393) = 0;
    symb(394) = "EL0   ";
    ivec(394) = 1;
    iascii(394) = 0;
    symb(395) = "RA    ";
    ivec(395) = 1;
    iascii(395) = 0;
    symb(396) = "RF    ";
    ivec(396) = 1;
    iascii(396) = 0;
    symb(397) = "RKD   ";
    ivec(397) = 1;
    iascii(397) = 0;
    symb(398) = "RG    ";
    ivec(398) = 1;
    iascii(398) = 0;
    symb(399) = "RKQ   ";
    ivec(399) = 1;
    iascii(399) = 0;
    symb(400) = "R0    ";
    ivec(400) = 1;
    iascii(400) = 0;
    symb(401) = "AGLINE";
    ivec(401) = 1;
    iascii(401) = 0;
    symb(402) = "RAT1  ";
    ivec(402) = 1;
    iascii(402) = 0;
    symb(403) = "SMOUTP";
    ivec(403) = 1;
    iascii(403) = 0;
    symb(404) = "SMOUTQ";
    ivec(404) = 1;
    iascii(404) = 0;
    symb(405) = "TEG   ";
    ivec(405) = 1;
    iascii(405) = 0;
    symb(406) = "TEXC  ";
    ivec(406) = 1;
    iascii(406) = 0;
    symb(407) = "CNP   ";
    ivec(407) = 1;
    iascii(407) = 0;
    symb(408) = "A22   ";
    ivec(408) = 1;
    iascii(408) = 0;
    symb(409) = "A12   ";
    ivec(409) = 1;
    iascii(409) = 0;
    symb(410) = "A21   ";
    ivec(410) = 1;
    iascii(410) = 0;
    symb(411) = "AC    ";
    ivec(411) = 1;
    iascii(411) = 0;
    symb(412) = "AI    ";
    ivec(412) = 1;
    iascii(412) = 0;
    symb(413) = "AT    ";
    ivec(413) = 1;
    iascii(413) = 0;
    symb(414) = "AH    ";
    ivec(414) = 1;
    iascii(414) = 0;
    symb(415) = "XAY   ";
    ivec(415) = 1;
    iascii(415) = 0;
    symb(416) = "CU    ";
    ivec(416) = 1;
    iascii(416) = 0;
    symb(417) = "CV    ";
    ivec(417) = 1;
    iascii(417) = 0;
    symb(418) = "DSAT  ";
    ivec(418) = 1;
    iascii(418) = 0;
    symb(419) = "QSAT  ";
    ivec(419) = 1;
    iascii(419) = 0;
    symb(420) = "ACR   ";
    ivec(420) = 1;
    iascii(420) = 0;
    symb(421) = "CE    ";
    ivec(421) = 1;
    iascii(421) = 0;
    symb(422) = "DSR   ";
    ivec(422) = 1;
    iascii(422) = 0;
    symb(423) = "DSD   ";
    ivec(423) = 1;
    iascii(423) = 0;
    symb(424) = "HICO  ";
    ivec(424) = 1;
    iascii(424) = 0;
    symb(425) = "DSM   ";
    ivec(425) = 1;
    iascii(425) = 0;
    symb(426) = "HSP   ";
    ivec(426) = 1;
    iascii(426) = 0;
    symb(427) = "POWER ";
    ivec(427) = 1;
    iascii(427) = 0;
    symb(428) = "EXTRS ";
    ivec(428) = 1;
    iascii(428) = 0;
    symb(429) = "HISTQ ";
    ivec(429) = 1;
    iascii(429) = 0;
    symb(430) = "HISTR ";
    ivec(430) = 1;
    iascii(430) = 0;
    symb(431) = "YFOR  ";
    ivec(431) = 1;
    iascii(431) = 0;
    symb(432) = "ZSK   ";
    ivec(432) = 1;
    iascii(432) = 0;
    symb(433) = "Y     ";
    ivec(433) = 1;
    iascii(433) = 0;
    symb(434) = "TORK  ";
    ivec(434) = 1;
    iascii(434) = 0;
    symb(435) = "TEMP  ";
    ivec(435) = 1;
    iascii(435) = 0;
    symb(436) = "Z     ";
    ivec(436) = 1;
    iascii(436) = 0;
    symb(437) = "X1    ";
    ivec(437) = 1;
    iascii(437) = 0;
    symb(438) = "SQRT3 ";
    ivec(438) = 0;
    iascii(438) = 0;
    symb(439) = "ASQRT3";
    ivec(439) = 0;
    iascii(439) = 0;
    symb(440) = "SQRT32";
    ivec(440) = 0;
    iascii(440) = 0;
    symb(441) = "THTW  ";
    ivec(441) = 0;
    iascii(441) = 0;
    symb(442) = "ATHTW ";
    ivec(442) = 0;
    iascii(442) = 0;
    symb(443) = "RADEG ";
    ivec(443) = 0;
    iascii(443) = 0;
    symb(444) = "OMDT  ";
    ivec(444) = 0;
    iascii(444) = 0;
    symb(445) = "FACTOM";
    ivec(445) = 0;
    iascii(445) = 0;
    symb(446) = "DAMRAT";
    ivec(446) = 0;
    iascii(446) = 0;
    symb(447) = "ISAT  ";
    ivec(447) = 1;
    iascii(447) = 0;
    symb(448) = "ISED  ";
    ivec(448) = 1;
    iascii(448) = 0;
    symb(449) = "ISEQ  ";
    ivec(449) = 1;
    iascii(449) = 0;
    symb(450) = "IMDUAL";
    ivec(450) = 1;
    iascii(450) = 0;
    symb(451) = "ICONFG";
    ivec(451) = 1;
    iascii(451) = 0;
    symb(452) = "KMAC  ";
    ivec(452) = 1;
    iascii(452) = 0;
    symb(453) = "KEXC  ";
    ivec(453) = 1;
    iascii(453) = 0;
    symb(454) = "NUMAS ";
    ivec(454) = 1;
    iascii(454) = 0;
    symb(455) = "NODMA ";
    ivec(455) = 1;
    iascii(455) = 0;
    symb(456) = "NODMB ";
    ivec(456) = 1;
    iascii(456) = 0;
    symb(457) = "NODMC ";
    ivec(457) = 1;
    iascii(457) = 0;
    symb(458) = "JASMIT";
    ivec(458) = 1;
    iascii(458) = 0;
    symb(459) = "JSMTOR";
    ivec(459) = 1;
    iascii(459) = 0;
    symb(460) = "JEXCIT";
    ivec(460) = 1;
    iascii(460) = 0;
    symb(461) = "ISLOC ";
    ivec(461) = 1;
    iascii(461) = 0;
    symb(462) = "NOUTSM";
    ivec(462) = 1;
    iascii(462) = 0;
    symb(463) = "ISMOUT";
    ivec(463) = 1;
    iascii(463) = 0;
    symb(464) = "MFIRST";
    ivec(464) = 0;
    iascii(464) = 0;
    symb(465) = "LIMASS";
    ivec(465) = 0;
    iascii(465) = 0;
    symb(466) = "NST   ";
    ivec(466) = 0;
    iascii(466) = 0;
    symb(467) = "ITOLD ";
    ivec(467) = 0;
    iascii(467) = 0;
    symb(468) = "IBROLD";
    ivec(468) = 0;
    iascii(468) = 0;
    symb(469) = "BUSUM ";
    ivec(469) = 1;
    iascii(469) = 1;
    symb(470) = "PTHETA";
    ivec(470) = 1;
    iascii(470) = 0;
    symb(471) = "ZTHEVR";
    ivec(471) = 1;
    iascii(471) = 0;
    symb(472) = "VINP  ";
    ivec(472) = 1;
    iascii(472) = 0;
    symb(473) = "ZTHEVS";
    ivec(473) = 1;
    iascii(473) = 0;
    symb(474) = "UMCUR ";
    ivec(474) = 1;
    iascii(474) = 0;
    symb(475) = "CON   ";
    ivec(475) = 1;
    iascii(475) = 0;
    symb(476) = "DUMVEC";
    ivec(476) = 1;
    iascii(476) = 0;
    symb(477) = "DUMMAT";
    ivec(477) = 1;
    iascii(477) = 0;
    symb(478) = "DATE  ";
    ivec(478) = 1;
    iascii(478) = 0;
    symb(479) = "CLOCK ";
    ivec(479) = 1;
    iascii(479) = 0;
    symb(480) = "PI    ";
    ivec(480) = 0;
    iascii(480) = 0;
    symb(481) = "SROOT2";
    ivec(481) = 0;
    iascii(481) = 0;
    symb(482) = "SROOT3";
    ivec(482) = 0;
    iascii(482) = 0;
    symb(483) = "OMEGRF";
    ivec(483) = 0;
    iascii(483) = 0;
    symb(484) = "INPU  ";
    ivec(484) = 0;
    iascii(484) = 0;
    symb(485) = "NUMBUS";
    ivec(485) = 0;
    iascii(485) = 0;
    symb(486) = "NCLTOT";
    ivec(486) = 0;
    iascii(486) = 0;
    symb(487) = "NDUM  ";
    ivec(487) = 1;
    iascii(487) = 0;
    symb(488) = "INITUM";
    ivec(488) = 0;
    iascii(488) = 0;
    symb(489) = "IUREAC";
    ivec(489) = 0;
    iascii(489) = 0;
    symb(490) = "IUGPAR";
    ivec(490) = 0;
    iascii(490) = 0;
    symb(491) = "IUFPAR";
    ivec(491) = 0;
    iascii(491) = 0;
    symb(492) = "IUHIST";
    ivec(492) = 0;
    iascii(492) = 0;
    symb(493) = "IUUMRP";
    ivec(493) = 0;
    iascii(493) = 0;
    symb(494) = "IUNOD1";
    ivec(494) = 0;
    iascii(494) = 0;
    symb(495) = "IUNOD2";
    ivec(495) = 0;
    iascii(495) = 0;
    symb(496) = "IUJCLT";
    ivec(496) = 0;
    iascii(496) = 0;
    symb(497) = "IUJCLO";
    ivec(497) = 0;
    iascii(497) = 0;
    symb(498) = "IUJTYP";
    ivec(498) = 0;
    iascii(498) = 0;
    symb(499) = "IUNODO";
    ivec(499) = 0;
    iascii(499) = 0;
    symb(500) = "IUJTMT";
    ivec(500) = 0;
    iascii(500) = 0;
    symb(501) = "IUHISM";
    ivec(501) = 0;
    iascii(501) = 0;
    symb(502) = "IUOMGM";
    ivec(502) = 0;
    iascii(502) = 0;
    symb(503) = "IUOMLD";
    ivec(503) = 0;
    iascii(503) = 0;
    symb(504) = "IUTHAM";
    ivec(504) = 0;
    iascii(504) = 0;
    symb(505) = "IUREDU";
    ivec(505) = 0;
    iascii(505) = 0;
    symb(506) = "IUREDS";
    ivec(506) = 0;
    iascii(506) = 0;
    symb(507) = "IUFLDS";
    ivec(507) = 0;
    iascii(507) = 0;
    symb(508) = "IUFLDR";
    ivec(508) = 0;
    iascii(508) = 0;
    symb(509) = "IUREQU";
    ivec(509) = 0;
    iascii(509) = 0;
    symb(510) = "IUFLQS";
    ivec(510) = 0;
    iascii(510) = 0;
    symb(511) = "IUFLQR";
    ivec(511) = 0;
    iascii(511) = 0;
    symb(512) = "IUJCDS";
    ivec(512) = 0;
    iascii(512) = 0;
    symb(513) = "IUJCQS";
    ivec(513) = 0;
    iascii(513) = 0;
    symb(514) = "IUFLXD";
    ivec(514) = 0;
    iascii(514) = 0;
    symb(515) = "IUFLXQ";
    ivec(515) = 0;
    iascii(515) = 0;
    symb(516) = "IUNPPA";
    ivec(516) = 0;
    iascii(516) = 0;
    symb(517) = "IUROTM";
    ivec(517) = 0;
    iascii(517) = 0;
    symb(518) = "IUNCLD";
    ivec(518) = 0;
    iascii(518) = 0;
    symb(519) = "IUNCLQ";
    ivec(519) = 0;
    iascii(519) = 0;
    symb(520) = "IUJTQO";
    ivec(520) = 0;
    iascii(520) = 0;
    symb(521) = "IUJOMO";
    ivec(521) = 0;
    iascii(521) = 0;
    symb(522) = "IUJTHO";
    ivec(522) = 0;
    iascii(522) = 0;
    symb(523) = "IUREQS";
    ivec(523) = 0;
    iascii(523) = 0;
    symb(524) = "IUEPSO";
    ivec(524) = 0;
    iascii(524) = 0;
    symb(525) = "IUDCOE";
    ivec(525) = 0;
    iascii(525) = 0;
    symb(526) = "IUKCOI";
    ivec(526) = 0;
    iascii(526) = 0;
    symb(527) = "IUVOLT";
    ivec(527) = 0;
    iascii(527) = 0;
    symb(528) = "IUANGL";
    ivec(528) = 0;
    iascii(528) = 0;
    symb(529) = "IUNODF";
    ivec(529) = 0;
    iascii(529) = 0;
    symb(530) = "IUNODM";
    ivec(530) = 0;
    iascii(530) = 0;
    symb(531) = "IUKUMO";
    ivec(531) = 0;
    iascii(531) = 0;
    symb(532) = "IUJUMO";
    ivec(532) = 0;
    iascii(532) = 0;
    symb(533) = "IUUMOU";
    ivec(533) = 0;
    iascii(533) = 0;
    symb(534) = "NCLFIX";
    ivec(534) = 0;
    iascii(534) = 0;
    symb(535) = "NUMFIX";
    ivec(535) = 0;
    iascii(535) = 0;
    symb(536) = "IOTFIX";
    ivec(536) = 0;
    iascii(536) = 0;
    symb(537) = "IBSFIX";
    ivec(537) = 0;
    iascii(537) = 0;
    symb(538) = "KSUBUM";
    ivec(538) = 0;
    iascii(538) = 0;
    symb(539) = "NSMACH";
    ivec(539) = 0;
    iascii(539) = 0;
    symb(540) = "ISTART";
    ivec(540) = 0;
    iascii(540) = 0;
    symb(541) = "KARRAY";
    ivec(541) = 1;
    iascii(541) = 0;
    symb(542) = "RAMPCN";
    ivec(542) = 1;
    iascii(542) = 0;
    symb(543) = "RAMPSL";
    ivec(543) = 1;
    iascii(543) = 0;
    symb(544) = "KYRAMP";
    ivec(544) = 1;
    iascii(544) = 0;
    symb(545) = "TEXPAR";
    ivec(545) = 1;
    iascii(545) = 0;
    symb(546) = "FENDRP";
    ivec(546) = 1;
    iascii(546) = 0;
    symb(547) = "TMINRP";
    ivec(547) = 0;
    iascii(547) = 0;
    symb(548) = "TMAXRP";
    ivec(548) = 0;
    iascii(548) = 0;
    symb(549) = "TBEGRP";
    ivec(549) = 1;
    iascii(549) = 0;
    symb(550) = "TENDRP";
    ivec(550) = 1;
    iascii(550) = 0;
    symb(551) = "FBEGRP";
    ivec(551) = 1;
    iascii(551) = 0;
    symb(552) = "TBREAK";
    ivec(552) = 0;
    iascii(552) = 0;
    symb(553) = "INDXRP";
    ivec(553) = 1;
    iascii(553) = 0;
    symb(554) = "IVEC  ";
    ivec(554) = 1;
    iascii(554) = 0;
    symb(555) = "IASCII";
    ivec(555) = 1;
    iascii(555) = 0;
    symb(556) = "NUMSYM";
    ivec(556) = 0;
    iascii(556) = 0;
    symb(557) = "JJROLL";
    ivec(557) = 0;
    iascii(557) = 0;
    symb(558) = "ITEXP ";
    ivec(558) = 0;
    iascii(558) = 0;
    symb(559) = "LABELS";
    ivec(559) = 1;
    iascii(559) = 0;
    symb(560) = "MAXARG";
    ivec(560) = 0;
    iascii(560) = 0;
    symb(561) = "KILPER";
    ivec(561) = 0;
    iascii(561) = 0;
    symb(562) = "KFILE5";
    ivec(562) = 0;
    iascii(562) = 0;
    symb(563) = "KVERFY";
    ivec(563) = 0;
    iascii(563) = 0;
    symb(564) = "IBEGCL";
    ivec(564) = 0;
    iascii(564) = 0;
    symb(565) = "IENDCL";
    ivec(565) = 0;
    iascii(565) = 0;
    symb(566) = "LIDNT1";
    ivec(566) = 0;
    iascii(566) = 0;
    symb(567) = "LIDNT2";
    ivec(567) = 0;
    iascii(567) = 0;
    symb(568) = "LINNOW";
    ivec(568) = 0;
    iascii(568) = 0;
    symb(569) = "LINSPN";
    ivec(569) = 0;
    iascii(569) = 0;
    symb(570) = "NUMCRD";
    ivec(570) = 0;
    iascii(570) = 0;
    symb(571) = "MUNIT5";
    ivec(571) = 0;
    iascii(571) = 0;
    symb(572) = "INDBUF";
    ivec(572) = 0;
    iascii(572) = 0;
    symb(573) = "INDBEG";
    ivec(573) = 0;
    iascii(573) = 0;
    symb(574) = "MFLUSH";
    ivec(574) = 0;
    iascii(574) = 0;
    symb(575) = "NEWVEC";
    ivec(575) = 0;
    iascii(575) = 0;
    symb(576) = "MUNIT6";
    ivec(576) = 0;
    iascii(576) = 0;
    symb(577) = "LSERLC";
    ivec(577) = 0;
    iascii(577) = 0;
    symb(578) = "KSERLC";
    ivec(578) = 0;
    iascii(578) = 0;
    symb(579) = "KBRSER";
    ivec(579) = 0;
    iascii(579) = 0;
    symb(580) = "LOCKBR";
    ivec(580) = 0;
    iascii(580) = 0;
    symb(581) = "IPRSPY";
    ivec(581) = 0;
    iascii(581) = 0;
    symb(582) = "MONITR";
    ivec(582) = 0;
    iascii(582) = 0;
    symb(583) = "MONITS";
    ivec(583) = 0;
    iascii(583) = 0;
    symb(584) = "LOCATE";
    ivec(584) = 1;
    iascii(584) = 0;
    symb(585) = "NLINE ";
    ivec(585) = 1;
    iascii(585) = 0;
    symb(586) = "KWTSPY";
    ivec(586) = 0;
    iascii(586) = 0;
    symb(587) = "KBREAK";
    ivec(587) = 0;
    iascii(587) = 0;
    symb(588) = "LIMBUF";
    ivec(588) = 0;
    iascii(588) = 0;
    symb(589) = "INCHLP";
    ivec(589) = 0;
    iascii(589) = 0;
    symb(590) = "KSYMBL";
    ivec(590) = 0;
    iascii(590) = 0;
    symb(591) = "KOPYIT";
    ivec(591) = 0;
    iascii(591) = 0;
    symb(592) = "KSLOWR";
    ivec(592) = 0;
    iascii(592) = 0;
    symb(593) = "LIMCRD";
    ivec(593) = 0;
    iascii(593) = 0;
    symb(594) = "LOOPRP";
    ivec(594) = 1;
    iascii(594) = 0;
    symb(595) = "N10RMP";
    ivec(595) = 1;
    iascii(595) = 0;
    symb(596) = "MEMRMP";
    ivec(596) = 1;
    iascii(596) = 0;
    symb(597) = "KAR1  ";
    ivec(597) = 1;
    iascii(597) = 0;
    symb(598) = "KAR2  ";
    ivec(598) = 1;
    iascii(598) = 0;
    symb(599) = "NUMRMP";
    ivec(599) = 0;
    iascii(599) = 0;
    symb(600) = "LUNTSP";
    ivec(600) = 0;
    iascii(600) = 0;
    symb(601) = "LOGVAR";
    ivec(601) = 0;
    iascii(601) = 0;
    symb(602) = "FILEXT";
    ivec(602) = 1;
    iascii(602) = 0;
    symb(603) = "SYMB  ";
    ivec(603) = 1;
    iascii(603) = 0;
    symb(604) = "COL   ";
    ivec(604) = 1;
    iascii(604) = 0;
    symb(605) = "BYTFND";
    ivec(605) = 0;
    iascii(605) = 0;
    symb(606) = "CHAR1 ";
    ivec(606) = 0;
    iascii(606) = 0;
    symb(607) = "SYMBRP";
    ivec(607) = 1;
    iascii(607) = 0;
    symb(608) = "CHARD4";
    ivec(608) = 0;
    iascii(608) = 0;
    symb(609) = "BYTBUF";
    ivec(609) = 0;
    iascii(609) = 0;
    symb(610) = "BUFF77";
    ivec(610) = 0;
    iascii(610) = 0;
    symb(611) = "FILE6B";
    ivec(611) = 1;
    iascii(611) = 0;
    symb(612) = "FILE6 ";
    ivec(612) = 1;
    iascii(612) = 0;
    symb(613) = "BLAN80";
    ivec(613) = 0;
    iascii(613) = 0;
    symb(614) = "PROM80";
    ivec(614) = 0;
    iascii(614) = 0;
    symb(615) = "DIGIT ";
    ivec(615) = 1;
    iascii(615) = 0;
    symb(616) = "IAC   ";
    ivec(616) = 0;
    iascii(616) = 0;
    symb(617) = "IDCTCS";
    ivec(617) = 0;
    iascii(617) = 0;
    symb(618) = "IPL   ";
    ivec(618) = 0;
    iascii(618) = 0;
    symb(619) = "IPR   ";
    ivec(619) = 0;
    iascii(619) = 0;
    symb(620) = "IXR   ";
    ivec(620) = 0;
    iascii(620) = 0;
    symb(621) = "JPL   ";
    ivec(621) = 0;
    iascii(621) = 0;
    symb(622) = "JPR   ";
    ivec(622) = 0;
    iascii(622) = 0;
    symb(623) = "KINT  ";
    ivec(623) = 0;
    iascii(623) = 0;
    symb(624) = "KOUT  ";
    ivec(624) = 0;
    iascii(624) = 0;
    symb(625) = "NDS   ";
    ivec(625) = 0;
    iascii(625) = 0;
    symb(626) = "NKN   ";
    ivec(626) = 0;
    iascii(626) = 0;
    symb(627) = "NMAX  ";
    ivec(627) = 0;
    iascii(627) = 0;
    symb(628) = "NUK   ";
    ivec(628) = 0;
    iascii(628) = 0;
    symb(629) = "KWRITE";
    ivec(629) = 0;
    iascii(629) = 0;
    symb(630) = "KPR   ";
    ivec(630) = 0;
    iascii(630) = 0;
    symb(631) = "KPL   ";
    ivec(631) = 0;
    iascii(631) = 0;
    symb(632) = "MXTACW";
    ivec(632) = 0;
    iascii(632) = 0;
    symb(633) = "IPTACW";
    ivec(633) = 0;
    iascii(633) = 0;
    symb(634) = "NHST  ";
    ivec(634) = 0;
    iascii(634) = 0;
    symb(635) = "KVIN  ";
    ivec(635) = 0;
    iascii(635) = 0;
    symb(636) = "KVOU  ";
    ivec(636) = 0;
    iascii(636) = 0;
    symb(637) = "KVXX  ";
    ivec(637) = 0;
    iascii(637) = 0;
    symb(638) = "ICSUP ";
    ivec(638) = 0;
    iascii(638) = 0;
    symb(639) = "NXIC  ";
    ivec(639) = 0;
    iascii(639) = 0;
    symb(640) = "KKSJ  ";
    ivec(640) = 0;
    iascii(640) = 0;
    symb(641) = "KKSK  ";
    ivec(641) = 0;
    iascii(641) = 0;
    symb(642) = "KKFST ";
    ivec(642) = 0;
    iascii(642) = 0;
    symb(643) = "KKNI  ";
    ivec(643) = 0;
    iascii(643) = 0;
    symb(644) = "KKHST ";
    ivec(644) = 0;
    iascii(644) = 0;
    symb(645) = "KIFLS ";
    ivec(645) = 0;
    iascii(645) = 0;
    symb(646) = "KIDUM ";
    ivec(646) = 0;
    iascii(646) = 0;
    symb(647) = "KSLIM1";
    ivec(647) = 0;
    iascii(647) = 0;
    symb(648) = "KSLIM2";
    ivec(648) = 0;
    iascii(648) = 0;
    symb(649) = "KSLIM3";
    ivec(649) = 0;
    iascii(649) = 0;
    symb(650) = "KPAC1R";
    ivec(650) = 0;
    iascii(650) = 0;
    symb(651) = "KPAC1I";
    ivec(651) = 0;
    iascii(651) = 0;
    symb(652) = "KPAC2R";
    ivec(652) = 0;
    iascii(652) = 0;
    symb(653) = "KPAC2I";
    ivec(653) = 0;
    iascii(653) = 0;
    symb(654) = "KALKSX";
    ivec(654) = 0;
    iascii(654) = 0;
    symb(655) = "KILMS1";
    ivec(655) = 0;
    iascii(655) = 0;
    symb(656) = "KILMS2";
    ivec(656) = 0;
    iascii(656) = 0;
    symb(657) = "KDUMJ ";
    ivec(657) = 0;
    iascii(657) = 0;
    symb(658) = "KDUMK ";
    ivec(658) = 0;
    iascii(658) = 0;
    symb(659) = "KKZJ  ";
    ivec(659) = 0;
    iascii(659) = 0;
    symb(660) = "KKZK  ";
    ivec(660) = 0;
    iascii(660) = 0;
    symb(661) = "KIFLZ ";
    ivec(661) = 0;
    iascii(661) = 0;
    symb(662) = "KGNZ  ";
    ivec(662) = 0;
    iascii(662) = 0;
    symb(663) = "KZLIM1";
    ivec(663) = 0;
    iascii(663) = 0;
    symb(664) = "KZLIM2";
    ivec(664) = 0;
    iascii(664) = 0;
    symb(665) = "KALKZX";
    ivec(665) = 0;
    iascii(665) = 0;
    symb(666) = "KILMZ1";
    ivec(666) = 0;
    iascii(666) = 0;
    symb(667) = "KILMZ2";
    ivec(667) = 0;
    iascii(667) = 0;
    symb(668) = "KKSUS ";
    ivec(668) = 0;
    iascii(668) = 0;
    symb(669) = "KALKSU";
    ivec(669) = 0;
    iascii(669) = 0;
    symb(670) = "KIUTY ";
    ivec(670) = 0;
    iascii(670) = 0;
    symb(671) = "KUD1  ";
    ivec(671) = 0;
    iascii(671) = 0;
    symb(672) = "KUD2  ";
    ivec(672) = 0;
    iascii(672) = 0;
    symb(673) = "KUD3  ";
    ivec(673) = 0;
    iascii(673) = 0;
    symb(674) = "KUD4  ";
    ivec(674) = 0;
    iascii(674) = 0;
    symb(675) = "KUD5  ";
    ivec(675) = 0;
    iascii(675) = 0;
    symb(676) = "KALIU ";
    ivec(676) = 0;
    iascii(676) = 0;
    symb(677) = "KTYSUP";
    ivec(677) = 0;
    iascii(677) = 0;
    symb(678) = "KJSUP ";
    ivec(678) = 0;
    iascii(678) = 0;
    symb(679) = "KKSUP ";
    ivec(679) = 0;
    iascii(679) = 0;
    symb(680) = "KSPVAR";
    ivec(680) = 0;
    iascii(680) = 0;
    symb(681) = "KOPSUP";
    ivec(681) = 0;
    iascii(681) = 0;
    symb(682) = "KFNSUP";
    ivec(682) = 0;
    iascii(682) = 0;
    symb(683) = "KRGSUP";
    ivec(683) = 0;
    iascii(683) = 0;
    symb(684) = "KPRSUP";
    ivec(684) = 0;
    iascii(684) = 0;
    symb(685) = "KTYPDV";
    ivec(685) = 0;
    iascii(685) = 0;
    symb(686) = "KKDJ  ";
    ivec(686) = 0;
    iascii(686) = 0;
    symb(687) = "KKDK  ";
    ivec(687) = 0;
    iascii(687) = 0;
    symb(688) = "KGNDEV";
    ivec(688) = 0;
    iascii(688) = 0;
    symb(689) = "KDEV1 ";
    ivec(689) = 0;
    iascii(689) = 0;
    symb(690) = "KDEV2 ";
    ivec(690) = 0;
    iascii(690) = 0;
    symb(691) = "KLDEV1";
    ivec(691) = 0;
    iascii(691) = 0;
    symb(692) = "KLDEV2";
    ivec(692) = 0;
    iascii(692) = 0;
    symb(693) = "KKDUS ";
    ivec(693) = 0;
    iascii(693) = 0;
    symb(694) = "KALKDU";
    ivec(694) = 0;
    iascii(694) = 0;
    symb(695) = "KTBDEV";
    ivec(695) = 0;
    iascii(695) = 0;
    symb(696) = "KPN   ";
    ivec(696) = 0;
    iascii(696) = 0;
    symb(697) = "KPD   ";
    ivec(697) = 0;
    iascii(697) = 0;
    symb(698) = "KXHST ";
    ivec(698) = 0;
    iascii(698) = 0;
    symb(699) = "KHSCR ";
    ivec(699) = 0;
    iascii(699) = 0;
    symb(700) = "KHSCI ";
    ivec(700) = 0;
    iascii(700) = 0;
    symb(701) = "KILIM1";
    ivec(701) = 0;
    iascii(701) = 0;
    symb(702) = "KILIM2";
    ivec(702) = 0;
    iascii(702) = 0;
    symb(703) = "KROWCS";
    ivec(703) = 0;
    iascii(703) = 0;
    symb(704) = "KRHSDE";
    ivec(704) = 0;
    iascii(704) = 0;
    symb(705) = "KVLIM1";
    ivec(705) = 0;
    iascii(705) = 0;
    symb(706) = "KVLIM2";
    ivec(706) = 0;
    iascii(706) = 0;
    symb(707) = "KKXIC ";
    ivec(707) = 0;
    iascii(707) = 0;
    symb(708) = "KAWKCS";
    ivec(708) = 0;
    iascii(708) = 0;
    symb(709) = "KXAR  ";
    ivec(709) = 0;
    iascii(709) = 0;
    symb(710) = "KXAI  ";
    ivec(710) = 0;
    iascii(710) = 0;
    symb(711) = "KBWKCS";
    ivec(711) = 0;
    iascii(711) = 0;
    symb(712) = "KXTCS ";
    ivec(712) = 0;
    iascii(712) = 0;
    symb(713) = "KLNTAB";
    ivec(713) = 0;
    iascii(713) = 0;
    symb(714) = "KLMXIC";
    ivec(714) = 0;
    iascii(714) = 0;
    symb(715) = "KCOLCS";
    ivec(715) = 0;
    iascii(715) = 0;
    symb(716) = "KATCS ";
    ivec(716) = 0;
    iascii(716) = 0;
    symb(717) = "KBTCS ";
    ivec(717) = 0;
    iascii(717) = 0;
    symb(718) = "KJOUT ";
    ivec(718) = 0;
    iascii(718) = 0;
    symb(719) = "KKOUT ";
    ivec(719) = 0;
    iascii(719) = 0;
    symb(720) = "KXMNCS";
    ivec(720) = 0;
    iascii(720) = 0;
    symb(721) = "KTXMN ";
    ivec(721) = 0;
    iascii(721) = 0;
    symb(722) = "KXMXCS";
    ivec(722) = 0;
    iascii(722) = 0;
    symb(723) = "KTXMX ";
    ivec(723) = 0;
    iascii(723) = 0;
    symb(724) = "KLNOUT";
    ivec(724) = 0;
    iascii(724) = 0;
    symb(725) = "EKBUF ";
    ivec(725) = 1;
    iascii(725) = 0;
    symb(726) = "EKTEMP";
    ivec(726) = 1;
    iascii(726) = 0;
    symb(727) = "ERRCHK";
    ivec(727) = 0;
    iascii(727) = 0;
    symb(728) = "SOLRSV";
    ivec(728) = 1;
    iascii(728) = 0;
    symb(729) = "SOLISV";
    ivec(729) = 1;
    iascii(729) = 0;
    symb(730) = "NITERA";
    ivec(730) = 0;
    iascii(730) = 0;
    symb(731) = "NEKREQ";
    ivec(731) = 0;
    iascii(731) = 0;
    symb(732) = "NEKCOD";
    ivec(732) = 1;
    iascii(732) = 0;
    cmn.numsym = 732;
  }
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct blockdata_blkplt_save
{
};

void
blockdata_blkplt(
  common& cmn) try
{
  FEM_CMN_SVE(blockdata_blkplt);
  // COMMON cblock
  auto& fvcom = cmn.fvcom;
  auto& ivcom = cmn.ivcom;
  // COMMON pltans
  auto& horzl = cmn.horzl;
  auto& anplt = cmn.anplt;
  //
  if (is_called_first_time) {
    cmn.texfnt = "F7X13.B ";
    cmn.xytitl(1, 24) = "                        ";
    cmn.headl(1, 16) = "                ";
    cmn.vertl(1, 16) = "                ";
    horzl(1) = "DEGREES BASED ON 60 HZ  ";
    horzl(2) = "CYCLES BASED ON 60 HZ   ";
    horzl(3) = "SECONDS                 ";
    horzl(4) = "MILLISECONDS            ";
    horzl(5) = "MICROSECONDS            ";
    horzl(6) = "FREQUENCY IN HERTZ      ";
    horzl(7) = "LOG10 FREQUENCY IN HERTZ";
    horzl(8) = "1ST VARIABLE OF X-Y PAIR";
    cmn.curren = "CURRENT ";
    cmn.voltag = "VOLTAGE ";
    anplt(1) = "CHOICE  ";
    anplt(2) = "STOP    ";
    anplt(3) = "PURGE   ";
    anplt(5) = "HELP    ";
    anplt(6) = "SMOOTH  ";
    anplt(7) = "SIZE    ";
    anplt(8) = "SHOW    ";
    anplt(9) = "LINE    ";
    anplt(10) = "COPY    ";
    anplt(37) = "END     ";
    anplt(11) = "REPEAT  ";
    anplt(12) = "FLUSH   ";
    anplt(13) = "PLAYBACK";
    anplt(14) = "PEN     ";
    anplt(15) = "FACTOR  ";
    anplt(16) = "OFFSET  ";
    anplt(17) = "LIMITS  ";
    cmn.time = "TIME    ";
    anplt(38) = "TIMESPAN";
    anplt(18) = "DEBUG   ";
    anplt(19) = "TEK     ";
    anplt(20) = "STACK   ";
    anplt(21) = "PRINTER ";
    anplt(22) = "METRIC  ";
    anplt(23) = "ALL TIME";
    anplt(24) = "COLUMN  ";
    anplt(25) = "SET COLU";
    anplt(4) = "OUT     ";
    anplt(26) = "LONGER  ";
    anplt(27) = "AVERAGE ";
    anplt(28) = "IN      ";
    anplt(29) = "RESCALE ";
    anplt(30) = "LAST    ";
    anplt(31) = "BATCH   ";
    anplt(32) = "PUNCH   ";
    anplt(33) = "EXTREMA ";
    anplt(34) = "LEVEL   ";
    anplt(35) = "NO PLOT ";
    anplt(36) = "MESSAGE ";
    anplt(40) = "TIME UNI";
    anplt(39) = "LABEL   ";
    anplt(41) = "CURSOR  ";
    anplt(42) = "X-Y PLOT";
    anplt(43) = "SLOPE   ";
    anplt(44) = "BACK    ";
    anplt(45) = "REFILE  ";
    anplt(46) = "BLANK   ";
    anplt(47) = "SET DATA";
    fvcom(7) = 8.e-5f;
    cmn.finfin = 1.e12f;
    fvcom(30) = 0.0f;
    fvcom(31) = 1.e20f;
    fvcom(46) = 36.f;
    fvcom(26) = 1.0f;
    fvcom(27) = 5.0f;
    fvcom(28) = 6.0f;
    ivcom(22) = 50;
    cmn.kslowr = 3;
    cmn.limfix = 0;
    ivcom(1) = 0;
    ivcom(2) = 0;
    cmn.jhmsp = 0;
    fvcom(6) = 5.0f;
    ivcom(59) = 6;
    fvcom(8) = 4.0f;
    ivcom(6) = 79;
    ivcom(9) = 1;
    cmn.numtek = 0;
    ivcom(55) = 1;
    ivcom(27) = 74;
    ivcom(28) = 68;
    ivcom(29) = 100;
    ivcom(30) = 40;
    ivcom(50) = 30;
    ivcom(53) = 2;
    ivcom(54) = 2;
    ivcom(31) = 6;
    ivcom(25) = 800;
    ivcom(24) = 800;
    ivcom(26) = 2;
    ivcom(32) = 1;
    ivcom(33) = 2;
    ivcom(34) = 0;
    ivcom(35) = 0;
    ivcom(39) = 0;
    ivcom(40) = 0;
    ivcom(41) = 1;
    ivcom(42) = 1;
    ivcom(43) = 0;
    ivcom(44) = 0;
    ivcom(49) = 0;
    ivcom(36) = 2;
    ivcom(37) = 7;
    ivcom(38) = 0;
    ivcom(45) = 10;
    ivcom(46) = 330;
    ivcom(47) = 512;
    ivcom(48) = 50;
    cmn.icurse = 0;
    ivcom(51) = int('P'); // "P";
    ivcom(52) = int('E'); // "E";
    fvcom(40) = 4.0f;
    fvcom(41) = 1.5f;
    fvcom(42) = 5.0f;
    fvcom(44) = 0.0f;
    fvcom(45) = .83f;
    ivcom(23) = 1;
    ivcom(57) = 0;
    ivcom(58) = 0;
    ivcom(8) = 960;
    ivcom(4) = 7;
    ivcom(7) = 9;
    cmn.mxypl = 0;
    cmn.numflt = 0;
    ivcom(10) = 0;
    fvcom(9) = 0.5f;
    fvcom(10) = 8.5f;
    fvcom(11) = .12f;
    fvcom(12) = 1.0f;
    fvcom(13) = 9.0f;
    fvcom(14) = 0.3f;
    cmn.nchsup = 0;
    cmn.nchver = 0;
    fvcom(20) = 1.0f;
    fvcom(21) = 1.0f;
    fvcom(22) = 0.2f;
    fvcom(23) = 0.2f;
    fvcom(24) = 1.0f;
    fvcom(25) = 1.0f;
    ivcom(20) = 1;
    ivcom(21) = 1;
    ivcom(11) = 3;
    fvcom(15) = 1.7f;
    fvcom(16) = .12f;
    fvcom(17) = 0.5f;
    fvcom(18) = .75f;
    fvcom(19) = 1.0f;
    fvcom(32) = 0.5f;
    fvcom(33) = 0.3f;
    fvcom(34) = -.03f;
    fvcom(35) = .10f;
    fvcom(36) = .15f;
    fvcom(37) = .05f;
    fvcom(38) = .10f;
    fvcom(39) = 1.0f;
    fvcom(43) = -7.5f;
    ivcom(12) = 3;
    ivcom(13) = 3;
    ivcom(14) = 3;
    ivcom(15) = 2;
    ivcom(16) = 1;
    ivcom(17) = 5;
    ivcom(18) = 3;
    ivcom(19) = 3;
    cmn.killpl = 0;
  }
  //C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.5932
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.5933
  //C     BEGIN COMMAND-WORD DEFINITIONS.   ^^^^^^  ^^^^^^   ^^^^^^   ^^^^^ M35.5949
  //C     END OF COMMAND DEFINITIONS  ^^^^^^   ^^^^^^   ^^^^^^   ^^^^^^     M35.5998
  //C     BEGIN PARAMETERS OF TEKTRONIX SCREEN                              M35.6018
  //C     END PARAMETERS OF TEKTRONIX SCREEN                                M35.6060
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
  //C     USAGE IS RESTRICTED TO "PLOT" FUNCTION OF "EMTSPY", DUE           M35.  37
  //C     TO VARIABLE-LENGTH CONFLICT (THIS IS SINGLE-PRECISION).           M35.  38
  //C!w nc -> ncz, numnvo -> numnvz, numout -> numouz, nv -> nvz
  //C     EVNBYT PUTS BUSLST ON REAL*8 BYTE BOUNDARY (IBM LEVEL 4 ERROR):   M39.  44
  //C!w EQUIVALENCE  ( EV(   1), BUSLST(1) ),  ( EV(1001), IBSOUT(1) )
  //C!w EQUIVALENCE  ( EV(1301), IBRNCH(1) ),  ( EV(1601), JBRNCH(1) )
  //C!w EQUIVALENCE  ( FVCOM( 1),   VMIN ),  ( FVCOM( 2),   VMAX )
  //C!w EQUIVALENCE  ( FVCOM( 3),   HMIN ),  ( FVCOM( 4),   HMAX )
  //C!w EQUIVALENCE  ( FVCOM( 5),     HA ),  ( FVCOM( 6), TAXISL )
  //C!w EQUIVALENCE  ( FVCOM( 7), TOLRCE ),  ( FVCOM( 8),   HTAX )
  //C!w EQUIVALENCE  ( FVCOM( 9),   XTIT ),  ( FVCOM(10),   YTIT )
  //C!w EQUIVALENCE  ( FVCOM(11), SIZTIT ),  ( FVCOM(12), XSUPER )
  //C!w EQUIVALENCE  ( FVCOM(13), YSUPER ),  ( FVCOM(14), SIZSUP )
  //C!w EQUIVALENCE  ( FVCOM(15),  FLINE ),  ( FVCOM(16),  SIZID )
  //C!w EQUIVALENCE  ( FVCOM(17),    XID ),  ( FVCOM(18),    YID )
  //C!w EQUIVALENCE  ( FVCOM(19),   FACT ),  ( FVCOM(20), DXGRD1 )
  //C!w EQUIVALENCE  ( FVCOM(21), DYGRD1 ),  ( FVCOM(22), DXGRD2 )
  //C!w EQUIVALENCE  ( FVCOM(23), DYGRD2 ),  ( FVCOM(24),  FILL1 )
  //C!w EQUIVALENCE  ( FVCOM(25),  FILL2 ),  ( FVCOM(26),     VS )
  //C!w EQUIVALENCE  ( FVCOM(27),     VL ),  ( FVCOM(28),     VH )
  //C!w EQUIVALENCE  ( FVCOM(29), PAPMAX ),  ( FVCOM(30), TIMBEG )
  //C!w EQUIVALENCE  ( FVCOM(31), TIMEND ),  ( FVCOM(32), FHTAX  )
  //C!w EQUIVALENCE  ( FVCOM(33), FXSUP  ),  ( FVCOM(34), FYSUP  )
  //C!w EQUIVALENCE  ( FVCOM(35), FXTIT  ),  ( FVCOM(36), FYTIT  )
  //C!w EQUIVALENCE  ( FVCOM(37), FXID   ),  ( FVCOM(38), FYID   )
  //C!w EQUIVALENCE  ( FVCOM(39), FTCARR ),  ( FVCOM(40), VAXISL )
  //C!w EQUIVALENCE  ( FVCOM(41), FXNUMV ),  ( FVCOM(42), FXNUMH )
  //C!w EQUIVALENCE  ( FVCOM(43), FVAXTT ),  ( FVCOM(44), FXVERT )
  //C!w EQUIVALENCE  ( FVCOM(45), FSYMB  ),  ( FVCOM(46), PAPLIM )
  //C!w EQUIVALENCE  ( IVCOM( 1),  KLEVL ),  ( IVCOM( 2),  KEXTR )
  //C!w EQUIVALENCE  ( IVCOM( 3),    IHS ),  ( IVCOM( 4), LU7PLT )
  //C!w EQUIVALENCE  ( IVCOM( 5), IPRSRT ),  ( IVCOM( 6), LIMCOL )
  //C!w EQUIVALENCE  ( IVCOM( 7), LINEPR ),  ( IVCOM( 8),  IBAUD )
  //C!w EQUIVALENCE  ( IVCOM( 9),   LTEK ),  ( IVCOM(10), NUMTIT )
  //C!w EQUIVALENCE  ( IVCOM(11), MAXSYM ),  ( IVCOM(12),   MTIT )
  //C!w EQUIVALENCE  ( IVCOM(13), MAXISX ),  ( IVCOM(14), MAXISY )
  //C!w EQUIVALENCE  ( IVCOM(15), MGRID1 ),  ( IVCOM(16), MGRID2 )
  //C!w EQUIVALENCE  ( IVCOM(17), MSUPER ),  ( IVCOM(18),    MID )
  //C!w EQUIVALENCE  ( IVCOM(19),  MLINE ),  ( IVCOM(20),  NCUT1 )
  //C!w EQUIVALENCE  ( IVCOM(21),  NCUT2 ),  ( IVCOM(22), NSMPLT )
  //C!w EQUIVALENCE  ( IVCOM(23),  LSYMB ),  ( IVCOM(24),  NXMAX )
  //C!w EQUIVALENCE  ( IVCOM(25),  NYMAX ),  ( IVCOM(26),  LCHID )
  //C!w EQUIVALENCE  ( IVCOM(27), NXINCH ),  ( IVCOM(28), NYINCH )
  //C!w EQUIVALENCE  ( IVCOM(29),  NXOFF ),  ( IVCOM(30),  NYOFF )
  //C!w EQUIVALENCE  ( IVCOM(31),   LOOK ),  ( IVCOM(32), LCHSUP )
  //C!w EQUIVALENCE  ( IVCOM(33), LCHTIT ),  ( IVCOM(34), LCHXAX )
  //C!w EQUIVALENCE  ( IVCOM(35), LCHYAX ),  ( IVCOM(36),  ITERM )
  //C!w EQUIVALENCE  ( IVCOM(37),   LTIC ),  ( IVCOM(38),  IZTIT )
  //C!w EQUIVALENCE  ( IVCOM(39),  IZGR1 ),  ( IVCOM(40),  IZGR2 )
  //C!w EQUIVALENCE  ( IVCOM(41), LDSHG1 ),  ( IVCOM(42), LDSHG2 )
  //C!w EQUIVALENCE  ( IVCOM(43),  IZXAX ),  ( IVCOM(44),  IZYAX )
  //C!w EQUIVALENCE  ( IVCOM(45),  NXID6 ),  ( IVCOM(46),  NYID6 )
  //C!w EQUIVALENCE  ( IVCOM(47),  NXEND ),  ( IVCOM(48),  NYEND )
  //C!w EQUIVALENCE  ( IVCOM(49),   IZID ),  ( IVCOM(50), NXVERN )
  //C!w EQUIVALENCE  ( IVCOM(51), ICHREF ),  ( IVCOM(52), ICHEND )
  //C!w EQUIVALENCE  ( IVCOM(53), INCHPX ),  ( IVCOM(54), INCHPY )
  //C!w EQUIVALENCE  ( IVCOM(55), INWAIT ),  ( IVCOM(56), NOLABL )
  //C!w EQUIVALENCE  ( IVCOM(57), LCHFIL ),  ( IVCOM(58), LCHLIM )
  //C!w EQUIVALENCE  ( IVCOM(59), MU6STD )
  //C       NEXT TYPE KEY CHARACTER KEY WORDS IN COMMON, IN ORDER:          M35. 120
  //C!w EQUIVALENCE ( ANPLT( 1), CHOICE ),  ( ANPLT( 2),   STOP )
  //C!w EQUIVALENCE ( ANPLT( 3),  PURGE ),  ( ANPLT( 4),    OUT )
  //C!w EQUIVALENCE ( ANPLT( 5),   HELP ),  ( ANPLT( 6), SMOOTH )
  //C!w EQUIVALENCE ( ANPLT( 7),   SIZE ),  ( ANPLT( 8),   SHOW )
  //C!w EQUIVALENCE ( ANPLT( 9), LINEZZ ),  ( ANPLT(10),  PHOTO )
  //C!w EQUIVALENCE ( ANPLT(11), REPEAT ),  ( ANPLT(12),  FLUSH )
  //C!w EQUIVALENCE ( ANPLT(13), PLAYBA ),  ( ANPLT(14),    PEN )
  //C!w EQUIVALENCE ( ANPLT(15), MULTIP ),  ( ANPLT(16), OFFSET )
  //C!w EQUIVALENCE ( ANPLT(17), LIMITS ),  ( ANPLT(18),  DEBUG )
  //C!w EQUIVALENCE ( ANPLT(19),    TEK ),  ( ANPLT(20),  STACK )
  //C!w EQUIVALENCE ( ANPLT(21), PRINTE ),  ( ANPLT(22), METRIC )
  //C!w EQUIVALENCE ( ANPLT(23), ALLTIM ),  ( ANPLT(24), COLUMN )
  //C!w EQUIVALENCE ( ANPLT(25), SETCOL ),  ( ANPLT(26), LONGER )
  //C!w EQUIVALENCE ( ANPLT(27), AVERAG ),  ( ANPLT(28),  INNER )
  //C!w EQUIVALENCE ( ANPLT(29), RESCAL ),  ( ANPLT(30),  LASTPL)
  //C!w EQUIVALENCE ( ANPLT(31),  BATCH ),  ( ANPLT(32),  PUNCH )
  //C!w EQUIVALENCE ( ANPLT(33), EXTREM ),  ( ANPLT(34),  LEVEL )
  //C!w EQUIVALENCE ( ANPLT(35), NOPLOT ),  ( ANPLT(36), MESSAG )
  //C!w EQUIVALENCE ( ANPLT(37),    END ),  ( ANPLT(38), TIMESP )
  //C!w EQUIVALENCE ( ANPLT(39),  LABEL ),  ( ANPLT(40), TIMEUN )
  //C!w EQUIVALENCE ( ANPLT(41), CURSOR ),  ( ANPLT(42), XYPLOT )
  //C!w EQUIVALENCE ( ANPLT(43),  SLOPE ),  ( ANPLT(44),   BACK )
  //C!w EQUIVALENCE ( ANPLT(45), REFILE ),  ( ANPLT(46), TEXBLK )
  //C!w EQUIVALENCE ( ANPLT(47), SETDAT )
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
crdchg(
  common& cmn) try
{
  common_read read(cmn);
  common_write write(cmn);
  const auto& abuff = cmn.abuff;
  double& twopi = cmn.twopi;
  double& xopt = cmn.xopt;
  auto& lunit9 = cmn.lunit9;
  fem::str<32>& ansi32 = cmn.ansi32;
  //
  fem::str<80> blanks = fem::char0;
  fem::str<80> work = fem::char0;
  auto& lunit6 = cmn.lunit6;
  int icount = fem::int0;
  arr_1d<14, fem::str<8> > text(fem::fill0);
  fem::str<80> card = fem::char0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  int n6 = fem::int0;
  double resist = fem::double0;
  double seal = fem::double0;
  double flash = fem::double0;
  double wl1 = fem::double0;
  double wl2 = fem::double0;
  double ys = fem::double0;
  double cur1 = fem::double0;
  double cur2 = fem::double0;
  double y = fem::double0;
  int i = fem::int0;
  static const char* format_100 = "(13a6,a2)";
  static const char* format_1400 = "(13a6,a2)";
  static const char* format_600 = "(13a6,a2)";
  //C                                                                       M42.7958
  //C     FORTRAN77 USED TO PROVIDE A SUBROUTINE TO                         M42.7959
  //C     INPUT OLD DATA CARDS AND CHANGE THEIR FORMAT;                     M42.7960
  //C     THIS INCLUDES DOING ANY APPROPRIATE CALCULATIONS.                 M42.7961
  //C     OLD 91,92,93 TYPES CHANGED TO NEW 91,99,98 TYPES                  M42.7962
  //C     RESPECTIVELY.                                                     M42.7963
  //C                                                                       M42.7964
  //C                                                                       M42.7969
  blanks = " ";
  work = " ";
  //C                                                                       M42.7972
  write(lunit6,
    "(' This code will read data types 91-switched',"
    "' resistor, 92-Switched Resistance, and',' 93-Switched Inductor.')");
  write(lunit6,
    "(' The data will be converted, formated,',"
    "' and written out to meet the new EMTP',' rule book''s requirements.')");
  //C                                                                       M42.7981
  try {
    cmn.io.open(7, fem::file_not_specified)
      .status("NEW");
  }
  catch (fem::io_err const&) {
    goto statement_40;
  }
  //C                                                                       M42.7985
  goto statement_50;
  //C                                                                       M42.7987
  statement_40:
  FEM_STOP(" ERROR OPENING OUTPUT FILE ");
  //C                                                                       M42.7990
  statement_50:
  //C                                                                       M42.7992
  cmn.noutpr = 1;
  FEM_DO_SAFE(icount, 1, 9999) {
    //C                                                                       M42.7995
    cimage(cmn);
    read(abuff, format_100), text;
    write(card, format_100), text;
    //C                                                                       M42.8000
    //C     *** CASE '91' ***                                                 M42.8001
    //C                                                                       M42.8002
    if (card(1, 2) == "91") {
      if (card(39, 44) == " 3333.") {
        goto statement_200;
      }
      write(lunit6,
        "(' TYPE-91:  PIECE-WISE LINEAR RESISTOR',14x,'1',a80)"),
        card;
      write(7, "('C ',a78)"), card(1, 78);
      write(7, "(a26,12x,' 3333.',37x,a1)"), card(1, 26), card(80, 80);
      write(lunit9, "(a26,12x,' 3333.',37x,a1)"), card(1, 26), card(80, 80);
      //C                                                                       M42.8015
      work(1, 25) = blanks(1, 19) + card(27, 32);
      //C                                                                       M42.8017
      write(7, "('C',18x,'VSTART')");
      write(7, "(a80)"), work;
      write(lunit9, "(a80)"), work;
      //C                                                                       M42.8024
      write(7, "('C ',14x,'TR IN SEC.',4x,'R(TR) IN OHMS')");
      //C                                                                       M42.8027
      statement_1250:
      if (card(13, 16) != "9999") {
        cimage(cmn);
        read(abuff, format_1400), text;
        write(card, format_1400), text;
        work(1, 25) = blanks(1, 9) + card(1, 16);
        work(26, 50) = blanks(1, 9) + card(17, 32);
        //C                                                                       M42.8036
        write(7, "('C ',a78)"), card(1, 78);
        write(7, "(a80)"), work;
        write(lunit6, "(1x,'CHARACTERISTICS',a32,3x,'1',a80)"), card(1,
          32), work;
        write(lunit9, "(a80)"), work;
        //C                                                                       M42.8045
        goto statement_1250;
      }
    }
    //C                                                                       M42.8049
    if (card == blanks) {
      goto statement_500;
    }
    if (card(1, 5) == "BLANK") {
      goto statement_500;
    }
    //C                                                                       M42.8052
    statement_200:;
  }
  //C                                                                       M42.8054
  statement_500:
  FEM_DO_SAFE(cmn.kcount, 1, 9999) {
    //C                                                                       M42.8056
    cimage(cmn);
    read(abuff, format_600), text;
    write(card, format_600), text;
    if (card == blanks) {
      goto statement_10000;
    }
    if (card(1, 5) == "BLANK") {
      goto statement_10000;
    }
    //C                                                                       M42.8063
    //C     *** CASE '92' ***                                                 M42.8064
    //C                                                                       M42.8065
    if (card(1, 2) == "92") {
      write(lunit6, "(' TYPE-92:  SWITCHED RESISTANCE',21x,'1',a80)"), card;
      work = " ";
      write(7, "('C ',a78)"), card(1, 78);
      //C                                                                       M42.8072
      read(card, "(34x,2e10.6)"), d7, d8;
      n6 = 6;
      fltopt(cmn, d7, n6);
      work(1, 6) = ansi32(27, 32);
      n6 = 6;
      fltopt(cmn, d8, n6);
      write(7, "('99',a12,12x,a6,6x,'     2',a6,a30,a1)"), card(3,
        14), work(1, 6), ansi32(27, 32), work(13, 79), card(80, 80);
      //C                                                                       M42.8083
      write(7, "('C',8x,'CURRENT',12x,'VOLT',50x)");
      write(7, "(7x,'0.0000001',6x,a10,50x)"), card(35, 44);
      write(lunit9, "('99',a12,12x,a6,6x,'     2',a6,a30,a1)"), card(3,
        14), work(1, 6), ansi32(27, 32), work(13, 79), card(80, 80);
      //C                                                                       M42.8091
      write(lunit9, "(7x,'0.0000001',6x,a10,50x)"), card(35, 44);
      //C                                                                       M42.8094
      read(card(15, 24), "(e10.6)"), resist;
      read(card(39, 44), "(e10.6)"), seal;
      flash = resist + seal;
      write(work(13, 44), "(13x,'1.0',e16.9)"), flash;
      write(7, "(a64)"), work(13, 80);
      write(7, "(12x,'9999')");
      write(lunit9, "(a64)"), work(13, 80);
      write(lunit9, "(12x,'9999')");
      goto statement_700;
    }
    //C                                                                       M42.8112
    //C     *** CASE '93' ***                                                 M42.8113
    //C                                                                       M42.8114
    if (card(1, 2) == "93") {
      write(lunit6, "(' TYPE-93:  SWITCHED INDUCTANCE',21x,'1',a80)"), card;
      work = " ";
      write(7, "('C ',a78)"), card(1, 78);
      //C                                                                       M42.8121
      read(card, "(24x,3e10.6)"), wl1, wl2, ys;
      if (xopt == 0.0f) {
        wl1 = wl1 / 1000.0f;
        wl2 = wl2 / 1000.0f;
      }
      else {
        wl1 = wl1 / (twopi * xopt);
        wl2 = wl2 / (twopi * xopt);
      }
      n6 = 6;
      fltopt(cmn, ys, n6);
      write(7, "('98',a12,12x,'   1.0',a6,42x,a1)"), card(3, 14),
        ansi32(27, 32), card(80, 80);
      write(lunit9, "('98',a12,12x,'   1.0',a6,42x,a1)"), card(3,
        14), ansi32(27, 32), card(80, 80);
      write(7, "('C',8x,'CURRENT',12x,'FLUX',50x)");
      cur1 = ys / wl1;
      cur2 = cur1 * 2;
      y = ys + (wl2 * (cur2 - cur1));
      write(work(23, 70), "(3e16.7)"), cur1, cur2, y;
      write(7, "(a16,6x,a10,47x)"), work(23, 38), card(45, 54);
      write(7, "(a32,47x)"), work(39, 70);
      write(7, "(12x,'9999',65x)");
      write(lunit9, "(a16,6x,a10,47x)"), work(23, 38), card(45, 54);
      write(lunit9, "(a32,47x)"), work(39, 70);
      write(lunit9, "(12x,'9999',65x)");
    }
    //C                                                                       M42.8157
    statement_700:;
  }
  //C                                                                       M42.8159
  statement_10000:
  cmn.io.rewind(lunit9);
  write(lunit6,
    "(/,27x,'SEQUENTIAL LIST OF PUNCHED OUTPUT.',/,81('-'),/,1x,"
    "'         1         2         3         4',"
    "'         5         6         7         8',/,1x,"
    "'1234567890123456789012345678901234567890',"
    "'1234567890123456789012345678901234567890',/,1x,81('-'),/,1x)");
  FEM_DO_SAFE(i, 1, 9999) {
    try {
      read(lunit9, "(a80)"), card;
    }
    catch (fem::read_end const&) {
      goto statement_10200;
    }
    write(lunit6, "(1x,a80)"), card;
  }
  statement_10200:
  FEM_STOP(0);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
round(
  double& x) try
{
  double a = fem::double0;
  int i10 = fem::int0;
  double a10 = fem::double0;
  int n1 = fem::int0;
  //C                                                                          15586
  //C)    THE PURPOSE OF THIS MODULE IS TO NUMERICALLY ROUND THE ARGUMENT   M15.1505
  //C)    'X'  TO FIVE DECIMAL DIGITS (OR THEREABOUTS), AND THEN PASS THIS  M15.1506
  //C)    ROUNDED NUMBER BACK TO THE CALLING MODULE.   THIS VERSION WILL    M15.1507
  //C)    WORK ON ANY COMPUTER SYSTEM.   YET IF  ENCODE  AND  DECODE  ARE   M15.1508
  //C     AVAILABLE, IT IS PERHAPS PREFERABLE TO USE THESE, AS PER  ....    M15.1509
  //C                  DIMENSION  ADUM(5)                                   M15.1510
  //C                  ENCODE (20, 5540, ADUM(1) )  X                       M15.1511
  //C                  DECODE (20, 5540, ADUM(1) )  X                       M15.1512
  //C             5540 FORMAT ( 1E20.5 )                                    M15.1513
  a = std::abs(x);
  if (a == 0.0f) {
    goto statement_1492;
  }
  i10 = alog1z(a);
  a10 = fem::pow(10.0f, (i10 - 5));
  a = a / a10;
  n1 = a + 0.5f;
  a = n1;
  a = a * a10;
  if (x < 0.0f) {
    a = -a;
  }
  statement_1492:
  x = a;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
newton(
  common& cmn,
  arr_ref<double> x,
  int const& maxit,
  double const& err) try
{
  x(dimension(1));
  common_write write(cmn);
  const auto& rwin = cmn.rwin;
  double& zhl = cmn.zhl;
  double& zht = cmn.zht;
  double& zlt = cmn.zlt;
  int& k = cmn.k;
  int& m = cmn.m;
  //
  int i = fem::int0;
  double a4 = fem::double0;
  double a3 = fem::double0;
  double a2 = fem::double0;
  double a1 = fem::double0;
  double rtot = fem::double0;
  double zdif = fem::double0;
  double a = fem::double0;
  double b = fem::double0;
  double c = fem::double0;
  double f = fem::double0;
  double df = fem::double0;
  double dx = fem::double0;
  int kcode = fem::int0;
  auto& lunit6 = cmn.lunit6;
  i = 0;
  statement_2:
  i++;
  if (i >= maxit) {
    goto statement_10;
  }
  a4 = rwin(k);
  a3 = x(1);
  a2 = rwin(m);
  a1 = rwin(cmn.idelt);
  rtot = a2 + a1;
  zdif = zlt - zht;
  a = fem::pow2(a3) - 2.0f * zht * a3 + a4 * rtot + a2 * a1 - zht * zdif;
  b = 2.0f * a1 * a3 + a4 * zlt + a1 * zdif + a2 * zht;
  c = zhl * zhl * (fem::pow2(rtot) + fem::pow2(zlt));
  f = fem::pow2(a) + fem::pow2(b) - c;
  df = 2.0f * a * (2.0f * x(1) - 2.0f * zht) + 2.0f * 2.0f * a1 * b;
  dx = -f / df;
  if (std::abs(dx) <= err) {
    goto statement_1;
  }
  x(1) = a3 + dx;
  goto statement_2;
  statement_10:
  kcode = 5;
  write(lunit6,
    "(' MODIFICATION OF ZERO SEQUENCE SHORT-CIRCUIT TEST ','BETWEEN',i3,"
    "' AND',i3,' NOT POSSIBLE. ERROR CODE =',i3)"),
    k, m, kcode;
  stoptp(cmn);
  statement_1:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct bctran_save
{
  int maxit;

  bctran_save() :
    maxit(fem::int0)
  {}
};

void
bctran(
  common& cmn) try
{
  FEM_CMN_SVE(bctran);
  common_read read(cmn);
  common_write write(cmn);
  const auto& abuff = cmn.abuff;
  double& epsiln = cmn.epsiln;
  double& unity = cmn.unity;
  double& onehaf = cmn.onehaf;
  auto& lunit7 = cmn.lunit7;
  auto& lstat = cmn.lstat;
  auto& rwin = cmn.rwin;
  double& zhl = cmn.zhl;
  double& zht = cmn.zht;
  double& zlt = cmn.zlt;
  int& k = cmn.k;
  int& m = cmn.m;
  int& idelt = cmn.idelt;
  int& logsix = static_cast<common_newt1&>(cmn).logsix;
  //
  int& maxit = sve.maxit;
  if (is_called_first_time) {
    maxit = 200;
  }
  auto& lunit6 = cmn.lunit6;
  double err = fem::double0;
  double aq = fem::double0;
  double d1 = fem::double0;
  double othree = fem::double0;
  double etwo = fem::double0;
  double ethree = fem::double0;
  double three = fem::double0;
  int iwin = fem::int0;
  double freq = fem::double0;
  double bexs = fem::double0;
  double ratpos = fem::double0;
  double gexs = fem::double0;
  double bexm = fem::double0;
  double ratzer = fem::double0;
  double gexm = fem::double0;
  int nphase = fem::int0;
  int itest = fem::int0;
  int iput = fem::int0;
  int iprint = fem::int0;
  double hfreq = fem::double0;
  int k1 = fem::int0;
  int in = fem::int0;
  int j = fem::int0;
  arr_1d<55, int> nad(fem::fill0);
  int m1 = fem::int0;
  double z1 = fem::double0;
  double zo = fem::double0;
  arr_1d<6, double> iname(fem::fill0);
  int i = fem::int0;
  int m5 = fem::int0;
  arr_1d<60, double> name(fem::fill0);
  arr_1d<10, double> rwin2(fem::fill0);
  arr_1d<10, double> v(fem::fill0);
  int nn1 = fem::int0;
  int nn2 = fem::int0;
  int imagn = fem::int0;
  int ibg = fem::int0;
  int ien = fem::int0;
  double h1 = fem::double0;
  double xpos = fem::double0;
  double xzero = fem::double0;
  int k3 = fem::int0;
  int iloss = fem::int0;
  arr_1d<55, int> kb(fem::fill0);
  arr_1d<55, int> ke(fem::fill0);
  arr_1d<55, double> rmva(fem::fill0);
  arr_1d<55, double> xp(fem::fill0);
  arr_1d<55, double> xo(fem::fill0);
  double b = fem::double0;
  int iad = fem::int0;
  int kk2 = fem::int0;
  int kk3 = fem::int0;
  int kdelta = fem::int0;
  int mdelta = fem::int0;
  arr_1d<3, double> x(fem::fill0);
  int k2 = fem::int0;
  int ik = fem::int0;
  double a = fem::double0;
  double a1 = fem::double0;
  double a2 = fem::double0;
  double rtot = fem::double0;
  double dnom = fem::double0;
  double d = fem::double0;
  double e = fem::double0;
  double c = fem::double0;
  double a3 = fem::double0;
  double b1 = fem::double0;
  double b2 = fem::double0;
  double b3 = fem::double0;
  double xtot = fem::double0;
  double h11 = fem::double0;
  double ww = fem::double0;
  double q = fem::double0;
  double bb = fem::double0;
  double zss = fem::double0;
  double zmm = fem::double0;
  arr_1d<10, double> zsd(fem::fill0);
  arr_1d<10, double> zmd(fem::fill0);
  int mz = fem::int0;
  arr_1d<55, double> zs(fem::fill0);
  arr_1d<55, double> zm(fem::fill0);
  int n = fem::int0;
  int ib = fem::int0;
  int ie = fem::int0;
  int ia = fem::int0;
  int mk = fem::int0;
  int ij = fem::int0;
  int iagain = fem::int0;
  double zpos = fem::double0;
  double az = fem::double0;
  double var1 = fem::double0;
  int i1 = fem::int0;
  double h2 = fem::double0;
  double h22 = fem::double0;
  double dm2 = fem::double0;
  int i2 = fem::int0;
  int L = fem::int0;
  double dm3 = fem::double0;
  double dm4 = fem::double0;
  int n2 = fem::int0;
  int n1 = fem::int0;
  double r = fem::double0;
  double s = fem::double0;
  int iss = fem::int0;
  int icount = fem::int0;
  arr_1d<30, double> rout(fem::fill0);
  int iw1 = fem::int0;
  int iw2 = fem::int0;
  int ii = fem::int0;
  int ip = fem::int0;
  int iw = fem::int0;
  int nf = fem::int0;
  int nt = fem::int0;
  arr_1d<30, double> y(fem::fill0);
  int jj = fem::int0;
  int jp = fem::int0;
  int jw = fem::int0;
  int ii50 = fem::int0;
  int kcode = fem::int0;
  //C     MULTI-PHASE TRANSFORMER DATA GENERATOR THAT WAS HANDED OVER       M29.3508
  //C     TO US AT BPA BY PROF. HERMANN W. DOMMEL OF THE UNIVERSITY OF      M29.3509
  //C     BRITISH COLUMBIA (VANCOUVER, B.C., CANADA) ON DECEMBER            M29.3510
  //C     18, 1980.   THIS USES  [A], [B]  REPRESENTATION.   ORIGINAL       M29.3511
  //C     FILE IS  [SCOTT]HWD.FOR;1 ,   AS READ FROM HERMANN'S CARDS.       M29.3512
  //C     IF NUMBER OF WINDINGS IS TO BE INCREASED FROM 10 TO N,            M29.3514
  //C     THEN SIMPLY CHANGE 10 TO N AND 55 TO N*(N+1)/2, 30 TO 3*N         M29.3515
  //C     AND 60 TO 6*N IN NEXT 6 LINES AND IN ONE LINE BETWEEN STATEMENT   M29.3516
  //C     NUMBER 1 AND 4.                                                   M29.3517
  logsix = lunit6;
  err = cmn.flzero * 10.f;
  aq = unity / 3.0f;
  d1 = 3.0f;
  othree = unity / sqrtz(d1);
  etwo = 1.0e-2;
  ethree = cmn.tenm3;
  three = 3.0f;
  //C     READ INPUT CARD USING CIMAGE.                                     M29.3533
  statement_100:
  cimage(cmn);
  read(abuff, "(i2,7e10.2,4i2)"), iwin, freq, bexs, ratpos, gexs,
    bexm, ratzer, gexm, nphase, itest, iput, iprint;
  if (iwin <= 0) {
    goto statement_312;
  }
  if (iwin > 10 || iwin == 1) {
    goto statement_120;
  }
  if (nphase != 1) {
    goto statement_36;
  }
  bexm = bexs;
  ratzer = ratpos;
  gexm = gexs;
  write(lunit6, "(' THREE PHASE BANK CONSISTS OF SINGLE PHASE UNITS')");
  statement_36:
  write(lunit6,
    "('0',i6,'-WINDING TRANSFORMER. FREQ.=',f6.2,'HZ',10x,'OUTPUT OPTION =',"
    "i3,/,/,7x,'EXCITING CURRENT(PERCENT) RATING(MVA) EXCITATION LOSS(KW)',/,"
    "' POS. SEQ.',f13.5,f18.2,f19.4,/,' ZERO SEQ.',f13.5,f18.2,f19.4,/,1x,"
    "'WINDING NO. VOLTAGE(KV)   R(OHM)',16x,"
    "'NODE NAME PAIRS FOR LEGS I, II, III')"),
    iwin, freq, iprint, bexs, ratpos, gexs, bexm, ratzer, gexm;
  hfreq = freq;
  freq = freq * cmn.twopi;
  k1 = iwin - 1;
  in = (iwin * k1) / 2;
  FEM_DO_SAFE(j, 1, in) {
    nad(j) = 0;
  }
  FEM_DO_SAFE(k, 1, iwin) {
    //C     READ INPUT CARD USING CIMAGE.                                     M29.3562
    cimage(cmn);
    {
      read_loop rloop(abuff(1), "(i3,2e10.2,1x,6a6)");
      rloop, m1, z1, zo;
      FEM_DO_SAFE(i, 1, 6) {
        rloop, iname(i);
      }
    }
    {
      write_loop wloop(cmn, lunit6, "(' ',i6,f16.3,f10.5,6(4x,a6))");
      wloop, m1, z1, zo;
      FEM_DO_SAFE(i, 1, 6) {
        wloop, iname(i);
      }
    }
    m5 = (m1 - 1) * 6;
    FEM_DO_SAFE(i, 1, 6) {
      m5++;
      name(m5) = iname(i);
    }
    rwin(m1) = zo * aq / fem::pow2(z1);
    rwin2(k) = 0.0f;
    v(m1) = othree / z1;
  }
  write(lunit6,
    "(' EXCITATION TEST MADE FROM WINDING',i3,"
    "'. MAGN. IMPEDANCE PLACED ACROSS WINDING',i3)"),
    itest, iput;
  gexs = gexs * ethree;
  gexm = gexm * ethree;
  bexs = fem::pow2((bexs * ratpos * etwo)) - fem::pow2(gexs);
  if (bexs < 0.0f) {
    goto statement_850;
  }
  bexs = sqrtz(bexs);
  bexm = fem::pow2((bexm * ratzer * etwo)) - fem::pow2(gexm);
  if (bexm < 0.0f) {
    goto statement_850;
  }
  bexm = sqrtz(bexm);
  nn1 = itest;
  nn2 = iput;
  imagn = 0;
  if (itest < iput) {
    goto statement_12;
  }
  nn1 = iput;
  nn2 = itest;
  statement_12:
  i = 0;
  if (nn1 <= 0 && nn2 > 0) {
    goto statement_320;
  }
  write(lunit6,
    "('0',24x,'POSITIVE SEQUENCE',25x,'ZERO SEQUENCE',10x,' CLOSED DELTA',/,"
    "' FROM  TO  LOAD LOSS(KW)  IMPEDANCE',"
    "'(PERCENT)  RATING(MVA)   IMPEDANCE(PERCENT)',' RATING(MVA)',5x,'IN')");
  //C     READ INPUT CARD USING CIMAGE.                                     M29.3599
  statement_25:
  cimage(cmn);
  read(abuff, "(2i2,5e10.2,2i2)"), ibg, ien, h1, xpos, ratpos,
    xzero, ratzer, idelt, k3;
  if (i == 0) {
    iloss = k3;
  }
  if (ibg <= 0 || ien <= 0) {
    goto statement_10;
  }
  if (nphase != 1) {
    goto statement_38;
  }
  idelt = 0;
  xzero = xpos;
  ratzer = ratpos;
  statement_38:
  write(lunit6, "(' ',2i4,2f15.5,f17.2,f16.5,f14.2,7x,i3)"), ibg,
    ien, h1, xpos, ratpos, xzero, ratzer, idelt;
  if (ibg == ien) {
    goto statement_300;
  }
  if (ibg > iwin || ien > iwin) {
    goto statement_300;
  }
  if (ibg < ien) {
    goto statement_20;
  }
  idelt = -idelt;
  k3 = ibg;
  ibg = ien;
  ien = k3;
  statement_20:
  if (i == 0) {
    goto statement_15;
  }
  FEM_DO_SAFE(m, 1, i) {
    if (kb(m) == ibg && ke(m) == ien) {
      goto statement_300;
    }
  }
  statement_15:
  i++;
  kb(i) = ibg;
  ke(i) = ien;
  nad(i) = idelt;
  rmva(i) = ratzer / etwo;
  if (ibg == nn1 && ien == nn2) {
    imagn = i;
  }
  z1 = fem::pow2((rwin(ibg) + rwin(ien)));
  if (h1 < epsiln) {
    goto statement_16;
  }
  h1 = h1 * ethree / (fem::pow2(ratpos));
  z1 = fem::pow2(h1);
  if (iloss == 0 || iwin > 3) {
    goto statement_18;
  }
  h1 = h1 * onehaf;
  rwin2(ibg) += h1;
  rwin2(ien) += h1;
  k3 = 6 - ibg - ien;
  if (k3 <= 0) {
    k3 = 4;
  }
  rwin2(k3) = rwin2(k3) - h1;
  goto statement_18;
  statement_16:
  iloss = 0;
  statement_18:
  xpos = fem::pow2((xpos * etwo / ratpos)) - z1;
  if (xpos < 0.0f) {
    goto statement_301;
  }
  xp(i) = -sqrtz(xpos);
  xo(i) = -xzero * etwo / ratzer;
  if (fem::iabs(idelt) > 0) {
    goto statement_25;
  }
  xzero = fem::pow2((xzero * etwo / ratzer)) - z1;
  if (xzero < 0.0f) {
    goto statement_301;
  }
  xo(i) = -sqrtz(xzero);
  goto statement_25;
  statement_10:
  if (in != i) {
    goto statement_310;
  }
  write(lunit6, "(' ILOSS =',i3)"), iloss;
  if (iloss == 0) {
    goto statement_303;
  }
  if (iwin > 3) {
    goto statement_303;
  }
  FEM_DO_SAFE(i, 1, iwin) {
    b = rwin2(i);
    if (b > 0.0f) {
      goto statement_181;
    }
    write(lunit6,
      "(' RESISTANCE OF WINDING',i3,' WAS CALCULATED AS',e15.6,/,"
      "'AND IS SET EQUAL TO ZERO')"),
      i, b;
    b = 0.0f;
    statement_181:
    rwin(i) = b;
  }
  write(lunit6, "(' RESISTANCE MATRIX VALUES CALCULATED FROM ','LOAD LOSSES')");
  //C     PROCESS INPUT DATA TO ACCOUNT FOR THE CLOSED DELTA EFFECT IN THE  M29.3668
  //C     ZERO  SEQUENCE  SHORT-CIRCUIT TESTS****************************** M29.3669
  statement_19:
  i = 0;
  statement_800:
  i++;
  if (i > in) {
    goto statement_888;
  }
  iad = nad(i);
  if (iad == 0) {
    goto statement_800;
  }
  idelt = fem::iabs(iad);
  k = kb(i);
  m = ke(i);
  if (idelt == k || idelt == m) {
    goto statement_830;
  }
  kk2 = 0;
  kk3 = 0;
  kdelta = idelt;
  mdelta = idelt;
  k3 = k;
  m1 = m;
  if (k < idelt) {
    goto statement_801;
  }
  k3 = idelt;
  kdelta = k;
  statement_801:
  if (m < idelt) {
    goto statement_802;
  }
  m1 = idelt;
  mdelta = m;
  statement_802:
  FEM_DO_SAFE(j, 1, in) {
    if (kb(j) == k3 && ke(j) == kdelta) {
      kk2 = j;
    }
    if (kb(j) == m1 && ke(j) == mdelta) {
      kk3 = j;
    }
  }
  if (kk2 == 0 || kk3 == 0) {
    goto statement_830;
  }
  if (iad > 0) {
    goto statement_222;
  }
  k3 = k;
  k = m;
  m = k3;
  k3 = kk2;
  kk2 = kk3;
  kk3 = k3;
  statement_222:
  zht = -xo(kk2);
  zlt = -xo(kk3);
  zhl = -xo(i);
  x(1) = onehaf * (zhl + zht - zlt);
  k2 = nad(kk2);
  k3 = nad(kk3);
  if (k2 == 0 && k3 == 0) {
    goto statement_210;
  }
  if (k2 == 0) {
    goto statement_833;
  }
  if (k3 != 0) {
    goto statement_832;
  }
  ik = kb(kk2);
  if (k2 < 0) {
    ik = ke(kk2);
  }
  if (ik != k) {
    goto statement_833;
  }
  goto statement_212;
  statement_210:
  newton(cmn, x, maxit, err);
  x(2) = zlt - zht + x(1);
  x(3) = zht - x(1);
  goto statement_180;
  statement_212:
  a = onehaf * zlt;
  x(2) = a;
  x(3) = a;
  a1 = rwin(idelt);
  a2 = rwin(m);
  rtot = a1 + a2;
  dnom = fem::pow2(rtot) + fem::pow2(zlt);
  d = a1 * a2 - fem::pow2(a);
  e = a * rtot;
  b = (d * rtot + e * zlt) / dnom;
  c = (rtot * e - d * zlt) / dnom;
  a = fem::pow2(zhl) - fem::pow2((rwin(k) + b));
  if (a < 0.0f) {
    goto statement_837;
  }
  x(1) = sqrtz(a) - c;
  //C     TO CHECK IMPEDANCES                                               M29.3738
  statement_180:
  a1 = rwin(k);
  a2 = rwin(m);
  a3 = rwin(idelt);
  b1 = x(1);
  b2 = x(2);
  b3 = x(3);
  rtot = a2 + a3;
  xtot = b2 + b3;
  a = fem::pow2((a1 * rtot - b1 * xtot + a2 * a3 - b2 * b3)) +
    fem::pow2((a1 * xtot + b1 * rtot + a2 * b3 + a3 * b2));
  b = fem::pow2(rtot) + fem::pow2(xtot);
  zhl = a / b;
  if (zhl < 0.0f) {
    goto statement_950;
  }
  zhl = sqrtz(zhl) * rmva(i);
  write(lunit6,
    "('0ZERO SEQUENCE TEST DATA BETWEEN',i3,' AND',i3,"
    "' IS MODIFIED FOR OPEN DELTA IN',i3,/,"
    "'WITH DELTA CLOSED AGAIN, MODIFIED DATA PRODUCES Z=',e14.6,"
    "' PERCENT, WHICH SHOULD AGREE WITH INPUT VALUE.')"),
    k, m, idelt, zhl;
  xo(i) = -b1 - b2;
  nad(i) = 0;
  if (k2 == 0) {
    goto statement_800;
  }
  write(lunit6,
    "('0INPUT VALUE OF ZERO SEQUENCE SHORT-CIRCUIT IMPED','ANCE FROM',i3,"
    "' TO',i3,' IS IGNORED AND SET EQUAL TO VALUE',' FROM',i3,' TO',i3,/,"
    "'BECAUSE BOTH IMPEDANCES MUST BE EQUAL IF',' THERE ARE CLOSED DELTAS IN',"
    "i3,' AND',i3)"),
    k, idelt, k, m, m, idelt;
  xo(kk2) = -b1 - b3;
  nad(kk2) = 0;
  goto statement_800;
  statement_888:
  FEM_DO_SAFE(j, 1, in) {
    nad(j) = 0;
  }
  //C     END  OF  INPUT  DATA  PROCESSING *********************************M29.3767
  if (nn1 == 0) {
    goto statement_154;
  }
  a = rwin(itest);
  z1 = 0.0f;
  zo = 0.0f;
  if (imagn == 0) {
    goto statement_158;
  }
  z1 = -xp(imagn);
  zo = -xo(imagn);
  statement_158:
  h1 = (fem::pow2(gexs) + fem::pow2(bexs)) * a;
  if (gexs >= h1) {
    goto statement_845;
  }
  gexs = h1;
  write(lunit6, "('0POS. SEQ. EXCITATION LOSSES RAISED TO',e15.6,' MW')"), gexs;
  statement_845:
  h1 = fem::pow2(gexs) + fem::pow2(bexs);
  if (h1 < epsiln) {
    goto statement_157;
  }
  h11 = gexs / h1 - a;
  h1 = bexs / h1 - z1;
  ww = fem::pow2(h11) + fem::pow2(h1);
  gexs = h11 / ww;
  bexs = h1 / ww;
  statement_157:
  h1 = (fem::pow2(gexm) + fem::pow2(bexm)) * a;
  if (gexm >= h1) {
    goto statement_847;
  }
  gexm = h1;
  write(lunit6, "('0ZERO SEQ. EXCITATION LOSSES RAISED TO',e15.6,' MW')"), gexm;
  statement_847:
  h1 = fem::pow2(gexm) + fem::pow2(bexm);
  if (h1 < epsiln) {
    goto statement_154;
  }
  h11 = gexm / h1 - a;
  h1 = bexm / h1 - zo;
  ww = fem::pow2(h11) + fem::pow2(h1);
  gexm = h11 / ww;
  bexm = h1 / ww;
  statement_154:
  write(lunit6,
    "('0',15x,'SHUNT RESISTANCES FOR REPRESENTATION OF ',"
    "'EXCITATION LOSSES%')");
  if (gexm >= gexs) {
    goto statement_861;
  }
  gexm = gexs;
  write(lunit6,
    "(' ZERO SEQUENCE SHUNT RESISTANCE REDUCED TO BE',"
    "' EQUAL TO POSITIVE SEQUENCE VALUE.')");
  statement_861:
  if (std::abs(gexm) < epsiln || std::abs(gexs) < epsiln) {
    goto statement_852;
  }
  gexm = gexs / gexm;
  gexs = 1.0f / gexs;
  gexm = (gexm - unity) * gexs * aq;
  gexs += gexm;
  if (nn1 == 0) {
    goto statement_854;
  }
  q = fem::pow2(v(iput));
  b = gexs / q;
  bb = gexm / q;
  write(lunit6,
    "(' PLACE SHUNT RESISTANCE MATRIX ACROSS WINDING',i3,' WITH R(SELF/OHM)=',"
    "e15.6,5x,' AND R(MUTUAL/OHM)=',e15.6)"),
    iput, b, bb;
  goto statement_153;
  statement_854:
  write(lunit6,
    "(' PLACE SHUNT RESISTANCE MATRIX ACROSS ALL TERMINALS',"
    "' WITH THE FOLLOWING VALUES%',/,'WINDING NO.',10x,'R(SELF/OHM)',10x,"
    "'R(MUTUAL/OHM)')");
  FEM_DO_SAFE(i, 1, iwin) {
    q = fem::pow2(v(i));
    b = gexs * iwin / q;
    bb = gexm * iwin / q;
    write(lunit6, "(i6,e28.6,e21.6)"), i, b, bb;
  }
  goto statement_153;
  statement_852:
  write(lunit6,
    "(' LEAVE OFF, BECAUSE SERIES RESISTANCES ALREADY',"
    "' PRODUCE LOSSES WHICH ARE GREATER THAN INPUT VALUES OF ',"
    "'EXCITATION LOSSES.')");
  statement_153:
  FEM_DO_SAFE(i, 1, in) {
    z1 = xp(i) * aq;
    zo = xo(i) * aq;
    zss = zo + 2.0f * z1;
    zmm = zo - z1;
    if (ke(i) == iwin) {
      goto statement_85;
    }
    xp(i) = -zss;
    xo(i) = -zmm;
    goto statement_80;
    statement_85:
    m = kb(i);
    zsd(m) = zss;
    zmd(m) = zmm;
    mz = (m * (m + 1)) / 2;
    zs(mz) = zss;
    zm(mz) = zmm;
    nad(m) = mz;
    statement_80:;
  }
  FEM_DO_SAFE(n, 1, in) {
    if (ke(n) == iwin) {
      goto statement_90;
    }
    ib = kb(n);
    ie = ke(n);
    zss = (zsd(ib) + xp(n) + zsd(ie)) * onehaf;
    zmm = (zmd(ib) + xo(n) + zmd(ie)) * onehaf;
    ia = (ie * (ie - 1)) / 2;
    lstat(52) = ia;
    mk = ia + ib;
    zs(mk) = zss;
    zm(mk) = zmm;
    statement_90:;
  }
  j = iwin;
  ij = (k1 * j) / 2;
  iagain = 0;
  statement_33:
  j = j - 1;
  if (j == 0) {
    goto statement_200;
  }
  h1 = zs(ij);
  h11 = zm(ij);
  if (std::abs(h1) < epsiln) {
    goto statement_110;
  }
  zpos = h1 - h11;
  ww = 2.0f * h11;
  az = zpos / (h1 + ww);
  zpos = 1.0f / zpos;
  var1 = zpos * aq;
  h1 = -(2.0f + az) * var1;
  h11 = -(az - 1.0f) * var1;
  xp(j) = h1;
  xo(j) = h11;
  ij = ij - j;
  k = 0;
  ik = 0;
  statement_44:
  ik += k;
  i1 = ik + 1;
  k++;
  if (k > k1) {
    goto statement_33;
  }
  if (k < j) {
    goto statement_99;
  }
  if (k == j) {
    goto statement_77;
  }
  i = ik + j;
  statement_55:
  h2 = zs(i);
  h22 = zm(i);
  dm2 = h22 * h11;
  xp(k) = h2 * h1 + 2.0f * dm2;
  xo(k) = h2 * h11 + h1 * h22 + dm2;
  i2 = ik + k;
  L = 0;
  FEM_DO_SAFE(i, i1, i2) {
    L++;
    dm3 = xp(L);
    dm4 = xo(L) * h22;
    zs(i) += dm3 * h2 + 2.0f * dm4;
    zm(i) += dm3 * h22 + xo(L) * h2 + dm4;
  }
  if (k < j) {
    goto statement_44;
  }
  i = ik + j;
  zs(i) = xp(k);
  zm(i) = xo(k);
  goto statement_44;
  statement_77:
  i = ij;
  FEM_DO_SAFE(L, 1, j) {
    i++;
    zs(i) = xp(L);
    zm(i) = xo(L);
  }
  goto statement_44;
  statement_99:
  i = ij + k;
  goto statement_55;
  statement_200:
  j = 0;
  if (iagain == 1) {
    goto statement_503;
  }
  k = 0;
  n2 = in;
  n1 = in + 1;
  statement_51:
  k++;
  i = nad(k);
  r = -zs(i);
  s = -zm(i);
  if (k == 1) {
    goto statement_48;
  }
  FEM_DO_SAFE(i, n1, n2) {
    j++;
    a = zs(j);
    b = zm(j);
    zs(i) = zs(i) - a;
    zm(i) = zm(i) - b;
    r = r - a;
    s = s - b;
  }
  statement_48:
  j++;
  n2++;
  zs(n2) = r;
  zm(n2) = s;
  if (k < k1) {
    goto statement_51;
  }
  a = 0.0f;
  b = 0.0f;
  FEM_DO_SAFE(i, n1, n2) {
    a = a - zs(i);
    b = b - zm(i);
  }
  n2++;
  zs(n2) = a;
  zm(n2) = b;
  bexm = (bexm - bexs) * aq;
  bexs += bexm;
  if (iput == 0) {
    goto statement_201;
  }
  nn1 = iput * (iput + 1) / 2;
  zs(nn1) += bexs;
  zm(nn1) += bexm;
  goto statement_203;
  statement_201:
  nn1 = 0;
  a = unity / iwin;
  FEM_DO_SAFE(i, 1, iwin) {
    nn1 += i;
    zs(nn1) += bexs * a;
    zm(nn1) += bexm * a;
  }
  statement_203:
  m = 0;
  FEM_DO_SAFE(k, 1, iwin) {
    a = v(k) * freq;
    FEM_DO_SAFE(i, 1, k) {
      m++;
      c = v(i) * a;
      zs(m) = zs(m) * c;
      zm(m) = zm(m) * c;
    }
  }
  iss = 0;
  if (iprint > 0) {
    goto statement_752;
  }
  write(lunit6,
    "('0','BRANCH DATA - RESISTANCE MATRIX (OHMS) AND',"
    "' INVERSE INDUCTANCE MATRIX (1/HENRIES)')");
  if (iss <= 0) {
    goto statement_730;
  }
  statement_506:
  write(lunit6,
    "('0','BRANCH DATA - RESISTANCE MATRIX (OHMS) AND',"
    "' REACTANCE MATRIX (OHMS) AT',f6.2,' HZ')"),
    hfreq;
  statement_730:
  ib = 3 * iwin;
  icount = 0;
  if (nphase == 1) {
    ib = iwin;
  }
  statement_952:
  FEM_DO_SAFE(i, 1, ib) {
    rout(i) = 0.0f;
  }
  FEM_DO_SAFE(i, 1, iwin) {
    a = rwin(i) / fem::pow2(v(i));
    rout(i) = a;
    iw1 = iwin + i;
    iw2 = iwin + iw1;
    rout(iw1) = a;
    rout(iw2) = a;
  }
  FEM_DO_SAFE(ii, 1, ib) {
    ip = (ii - 1) / iwin + 1;
    iw = ii - ((ii - 1) / iwin) * iwin;
    nf = (iw - 1) * 6 + (ip - 1) * 2 + 1 + icount;
    nt = nf + 1;
    FEM_DO_SAFE(i, 1, ib) {
      y(i) = 0.0f;
    }
    FEM_DO_SAFE(jj, 1, ii) {
      jp = (jj - 1) / iwin + 1;
      jw = jj - ((jj - 1) / iwin) * iwin;
      if (iw < jw) {
        goto statement_710;
      }
      k = (iw - 1) * iw / 2 + jw;
      goto statement_711;
      statement_710:
      k = (jw - 1) * jw / 2 + iw;
      statement_711:
      if (ip == jp) {
        goto statement_703;
      }
      y(jj) = zm(k);
      goto statement_705;
      statement_703:
      y(jj) = zs(k);
      statement_705:;
    }
    ii50 = ii;
    if (ii == 1) {
      goto statement_722;
    }
    {
      write_loop wloop(cmn, lunit6,
        "(' ',i2,2a6,12x,2e17.10,/(' ',26x,2e17.10))");
      wloop, ii50, name(nf), name(nt);
      FEM_DO_SAFE(i, 1, ii) {
        wloop, rout(i), y(i);
      }
    }
    {
      write_loop wloop(cmn, lunit7, "(i2,2a6,12x,2e16.10,/(26x,2e16.10))");
      wloop, ii50, name(nf), name(nt);
      FEM_DO_SAFE(i, 1, ii) {
        wloop, rout(i), y(i);
      }
    }
    goto statement_724;
    statement_722:
    {
      write_loop wloop(cmn, lunit6, "(' ',i2,2a6,12x,2e17.10)");
      wloop, ii50, name(nf), name(nt);
      FEM_DO_SAFE(i, 1, ii) {
        wloop, rout(i), y(i);
      }
    }
    {
      write_loop wloop(cmn, lunit7, "(i2,2a6,12x,2e16.10)");
      wloop, ii50, name(nf), name(nt);
      FEM_DO_SAFE(i, 1, ii) {
        wloop, rout(i), y(i);
      }
    }
    statement_724:
    rout(ii) = 0.0f;
  }
  if (nphase != 1) {
    icount = 5;
  }
  icount += 2;
  if (icount <= 4) {
    goto statement_952;
  }
  if (iss == 1 || iprint == 0) {
    goto statement_100;
  }
  statement_752:
  iagain = 1;
  j = iwin + 1;
  ij = iwin * j / 2;
  k1 = iwin;
  goto statement_33;
  statement_503:
  m = 0;
  FEM_DO_SAFE(k, 1, iwin) {
    FEM_DO_SAFE(i, 1, k) {
      m++;
      zs(m) = -zs(m) * freq;
      zm(m) = -zm(m) * freq;
    }
  }
  iss = 1;
  goto statement_506;
  statement_120:
  write(lunit6, "(' NUMBER OF WINDINGS =',i3)"), iwin;
  stoptp(cmn);
  statement_300:
  write(lunit6, "(' ',2i3,' WRONG WINDING NUMBERS')"), ibg, ien;
  stoptp(cmn);
  statement_301:
  write(lunit6,
    "(' LOAD LOSSES OR WINDING RESISTANCES TOO LARGE',2i3)"), ibg,
    ien;
  stoptp(cmn);
  statement_303:
  write(lunit6,
    "(' RESISTANCE MATRIX VALUES ARE THOSE WHICH ','WERE READ IN')");
  goto statement_19;
  statement_310:
  write(lunit6,
    "(' ONLY',i3,' SHORT-CIRCUIT TESTS SPECIFIED',' BUT',i3,' ARE NEEDED')"),
    i, in;
  stoptp(cmn);
  statement_320:
  write(lunit6,
    "(' EITHER ITEST =',i3,' OR IPUT =',i3,' NOT PERMITTED')"),
    itest, iput;
  stoptp(cmn);
  statement_110:
  write(lunit6, "(' DIAGONAL ELEMENT IN ROW',i3,' CLOSE TO ZERO')"), j;
  stoptp(cmn);
  statement_830:
  write(lunit6,
    "(' IDELTA=',i2,' WRONG IN SHORT-CIRCUIT TEST BETWEEN',i3,' AND',i3)"),
    idelt, k, m;
  stoptp(cmn);
  statement_832:
  kcode = 1;
  statement_835:
  write(lunit6,
    "(' MODIFICATION OF ZERO SEQUENCE SHORT-CIRCUIT TEST ','BETWEEN',i3,"
    "' AND',i3,' NOT POSSIBLE. ERROR CODE =',i3)"),
    k, m, kcode;
  stoptp(cmn);
  statement_833:
  kcode = 2;
  goto statement_835;
  statement_837:
  kcode = 3;
  goto statement_835;
  //C 839 KCODE = 4   15 FEB 1983 "M34" IBM EMTP FEEDBACK FROM              M35.8998
  //C     GO TO 835   PACIFIC POWER: UNREACHABLE S.N. 839.  WSM.            M35.8999
  statement_950:
  kcode = 5;
  goto statement_835;
  statement_850:
  write(lunit6,
    "(' P.U. EXCITATION LOSS LARGER THAN P.U. EXCITING',"
    "' CURRENT (EITHER IN POS. OR ZERO SEQUENCE)')");
  statement_312:
  stoptp(cmn);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
cxred1(
  arr_ref<double> as,
  arr_ref<double> cs,
  int const& n,
  int const& m) try
{
  as(dimension(1));
  cs(dimension(1));
  int nnn = fem::int0;
  int j = fem::int0;
  arr_1d<100, double> a(fem::fill0);
  arr_1d<100, double> c(fem::fill0);
  double w = fem::double0;
  int ij = fem::int0;
  double h1 = fem::double0;
  double g1 = fem::double0;
  double x = fem::double0;
  arr_1d<100, double> b(fem::fill0);
  arr_1d<100, double> d(fem::fill0);
  int k = fem::int0;
  int ik = fem::int0;
  int i1 = fem::int0;
  int i = fem::int0;
  double h2 = fem::double0;
  double g2 = fem::double0;
  int i2 = fem::int0;
  int L = fem::int0;
  double y = fem::double0;
  //C)    FOR AN EXPLANATION  AS TO THE CALLING SEQUENCE OF THIS MODULE,    M15.1524
  //C)    REFER TO THE SAME SUBROUTINE OF OVERLAY 3.                        M15.1525
  //C     DEFINE DOUBLE PRECISION FOR SINGLE PRECISION UNIVAC               M32, 270
  nnn = n * (n + 1) / 2;
  FEM_DO_SAFE(j, 1, nnn) {
    a(j) = as(j);
    c(j) = cs(j);
  }
  j = n + 1;
  w = 1.0f;
  if (m > 0) {
    w = -w;
  }
  ij = n * j / 2;
  statement_3:
  j = j - 1;
  if (j == m) {
    goto statement_60;
  }
  h1 = a(ij);
  g1 = c(ij);
  x = 1.0f / (h1 * h1 + g1 * g1);
  h1 = -h1 * x;
  g1 = g1 * x;
  b(j) = h1;
  d(j) = g1;
  ij = ij - j;
  k = 0;
  ik = 0;
  //C                                   BEGIN K-LOOP                           15627
  statement_4:
  ik += k;
  i1 = ik + 1;
  k++;
  if (k > n) {
    goto statement_3;
  }
  if (k < j) {
    goto statement_9;
  }
  if (w < 0.f) {
    goto statement_3;
  }
  if (k == j) {
    goto statement_7;
  }
  i = ik + j;
  statement_5:
  h2 = a(i);
  g2 = c(i);
  b(k) = h2 * h1 - g2 * g1;
  d(k) = h2 * g1 + g2 * h1;
  //C                                   BEGIN I-LOOP                           15640
  i2 = ik + k;
  L = 0;
  FEM_DO_SAFE(i, i1, i2) {
    L++;
    x = b(L);
    y = d(L);
    a(i) += x * h2 - y * g2;
    c(i) += x * g2 + y * h2;
  }
  if (k < j) {
    goto statement_4;
  }
  i = ik + j;
  a(i) = b(k);
  c(i) = d(k);
  goto statement_4;
  //C                                   END I-LOOP                             15654
  statement_7:
  i = ij;
  FEM_DO_SAFE(L, 1, j) {
    i++;
    c(i) = d(L);
    a(i) = b(L);
  }
  goto statement_4;
  //C                                   END K-LOOP                             15661
  statement_9:
  i = ij + k;
  goto statement_5;
  //C     NNN = N * (N+1) / 2 ! DEFINED AT TOP, SO UNNEDED HERE. WSM        M33.2362
  statement_60:
  FEM_DO_SAFE(j, 1, nnn) {
    as(j) = a(j);
    cs(j) = c(j);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct over41_save
{
  fem::str<8> t1;
  fem::str<8> t2;
  fem::str<8> t3;
  fem::str<8> text10;
  fem::str<8> text11;
  fem::str<8> text12;
  fem::str<8> text9;
  arr<fem::str<8> > typec;

  over41_save() :
    t1(fem::char0),
    t2(fem::char0),
    t3(fem::char0),
    text10(fem::char0),
    text11(fem::char0),
    text12(fem::char0),
    text9(fem::char0),
    typec(dimension(20), fem::fill0)
  {}
};

void
over41(
  common& cmn) try
{
  FEM_CMN_SVE(over41);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& bus6 = cmn.bus6;
  fem::str<8>& blank = cmn.blank;
  fem::str<8>& csepar = cmn.csepar;
  fem::str<8>& chcont = cmn.chcont;
  const auto& texta6 = cmn.texta6;
  const auto& abuff = cmn.abuff;
  double& epsiln = cmn.epsiln;
  double& omega = cmn.omega;
  double& xopt = cmn.xopt;
  double& statfr = cmn.statfr;
  auto& lunit7 = cmn.lunit7;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  int& ipunch = cmn.ipunch;
  int& lastov = cmn.lastov;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  //
  fem::str<8>& t1 = sve.t1;
  fem::str<8>& t2 = sve.t2;
  fem::str<8>& t3 = sve.t3;
  fem::str<8>& text10 = sve.text10;
  fem::str<8>& text11 = sve.text11;
  fem::str<8>& text12 = sve.text12;
  fem::str<8>& text9 = sve.text9;
  str_arr_ref<1> typec(sve.typec, dimension(20));
  if (is_called_first_time) {
    t1 = "HIGH  ";
    t2 = "MEDIUM";
    t3 = "LOW   ";
    text9 = "BRANCH";
    text10 = "0     ";
    text11 = "1     ";
    text12 = "TRANSF";
    typec(1) = "51    ";
    typec(2) = "52    ";
    typec(3) = "53    ";
    typec(4) = "54    ";
    typec(5) = "55    ";
    typec(6) = "56    ";
    typec(7) = "57    ";
    typec(8) = "58    ";
    typec(9) = "59    ";
    typec(10) = "60    ";
    typec(11) = "61    ";
    typec(12) = "62    ";
    typec(13) = "63    ";
    typec(14) = "64    ";
    typec(15) = "65    ";
    typec(16) = "66    ";
    typec(17) = "67    ";
    typec(18) = "68    ";
    typec(19) = "69    ";
    typec(20) = "70    ";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  arr_1d<3, fem::str<8> > text1(fem::fill0);
  arr_1d<3, fem::str<8> > text2(fem::fill0);
  arr_1d<3, fem::str<8> > text3(fem::fill0);
  int ll0 = fem::int0;
  int ll2 = fem::int0;
  int ll3 = fem::int0;
  int i = fem::int0;
  arr_1d<3, fem::str<8> > text7(fem::fill0);
  arr_1d<3, fem::str<8> > text8(fem::fill0);
  int n4 = fem::int0;
  double d1 = fem::double0;
  int iwind = fem::int0;
  double cmag = fem::double0;
  double pmag = fem::double0;
  double d11 = fem::double0;
  double rsum = fem::double0;
  double xsum = fem::double0;
  double vtap = fem::double0;
  double ploss = fem::double0;
  double z = fem::double0;
  double pratg = fem::double0;
  arr_1d<3, double> temp1(fem::fill0);
  arr_1d<3, double> temp2(fem::fill0);
  arr_1d<3, double> temp3(fem::fill0);
  double resist = fem::double0;
  arr_1d<3, double> v(fem::fill0);
  arr_1d<3, double> rik(fem::fill0);
  arr_1d<3, double> xik(fem::fill0);
  double ar = fem::double0;
  double ai = fem::double0;
  double cr = fem::double0;
  double cii = fem::double0;
  int ki = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  arr_1d<6, double> rr(fem::fill0);
  arr_1d<6, double> xx(fem::fill0);
  int n = fem::int0;
  int ichck = fem::int0;
  double v1 = fem::double0;
  double v2 = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  double d4 = fem::double0;
  double d5 = fem::double0;
  int kk = fem::int0;
  arr_1d<20, fem::str<8> > aupper(fem::fill0);
  arr_1d<20, fem::str<8> > alower(fem::fill0);
  arr_1d<20, double> ohm(fem::fill0);
  arr_1d<20, double> henry(fem::fill0);
  arr_1d<20, double> volt(fem::fill0);
  double d9 = fem::double0;
  double d10 = fem::double0;
  double d6 = fem::double0;
  double d7 = fem::double0;
  double d8 = fem::double0;
  int n1 = fem::int0;
  fem::str<8> text6 = fem::char0;
  double d12 = fem::double0;
  double d13 = fem::double0;
  double d14 = fem::double0;
  arr_1d<20, double> volti(fem::fill0);
  arr_1d<20, double> voltk(fem::fill0);
  int m = fem::int0;
  static const char* format_10 = "(5e10.0)";
  static const char* format_140 = "(1x,a6,' TO ',a6,2f15.5)";
  static const char* format_15 =
    "(/,' SINGLE-PHASE',i2,'-WINDING TRANSFORMER.   ''IMAGN'' =',f8.5,"
    "' PER CENT BASED ON',f8.3,' MVA',/,' VOLTAGE ACROSS WINDING',15x,"
    "'LOSSES  IMPEDANCE BASED ON',/,9x,'(KV)',26x,'(KW)   (PER CENT) (MVA)')";
  static const char* format_20 =
    "(1x,a6,f7.2,6x,a6,' TO ',a6,f8.2,f10.4,f10.3)";
  static const char* format_3861 = "(a6,2x,12a6)";
  static const char* format_3904 = "('+WIND.',4e11.3)";
  static const char* format_4201 =
    "(/,/,"
    "' 80-COLUMN CARD-IMAGE LISTING OF PUNCHED-CARD OUTPUT FOLLOWS (TYPE-51-53"
    " EMTP BRANCH CARDS).',/,1x,80('-'),/,1x,8(9x,i1),/,1x,8(9x,'0'),/,1x,"
    "80('-'))";
  static const char* format_4271 = "(1x,80('-'),/,/,1x)";
  static const char* format_4568 = "('  \"EXIT  MODULE OVER41.\"')";

  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER41.\"')");
  }
  if (cmn.iofbnd != 33666) {
    goto statement_4574;
  }
  crdchg(cmn);
  goto statement_9200;
  statement_4574:
  text1(1) = t1;
  text2(1) = t1;
  text2(2) = t1;
  text1(2) = t2;
  text2(3) = t2;
  text3(1) = t2;
  text1(3) = t3;
  text3(2) = t3;
  text3(3) = t3;
  ll0 = 0;
  ll2 = 2;
  ll3 = 3;
  read(abuff, "(32x,2e8.0)"), statfr, xopt;
  if (statfr != 44.f) {
    goto statement_7119;
  }
  //C     ENTER HERMANN'S UBC 3-PHASE TRANSFORMER ROUTINE  "BCTRAN"         M29.3455
  bctran(cmn);
  if (kill > 0) {
    goto statement_9200;
  }
  goto statement_3872;
  statement_7119:
  omega = cmn.twopi * statfr;
  if (statfr > 0.0f) {
    goto statement_7122;
  }
  statement_5:
  FEM_DO_SAFE(i, 1, 3) {
    text7(i) = blank;
    text8(i) = blank;
  }
  //C     READ INPUT CARD USING CIMAGE                                      M22.5748
  statement_3857:
  cimage(cmn);
  n4 = kolbeg;
  if (kolbeg > 0) {
    goto statement_1723;
  }
  read(abuff, format_3861), bus1;
  goto statement_1725;
  statement_1723:
  nfrfld = 1;
  nright = -1;
  freone(cmn, d1);
  nright = 0;
  bus1 = texta6(1);
  statement_1725:
  if (bus1 != text9) {
    goto statement_3869;
  }
  write(kunit6, "('+NODE NAMES FOR PUNCHED BRANCH CARDS.')");
  if (kolbeg > 0) {
    goto statement_1733;
  }
  {
    read_loop rloop(abuff(1), format_3861);
    rloop, bus1;
    FEM_DO_SAFE(i, 1, 3) {
      rloop, text7(i), text8(i);
    }
  }
  goto statement_1735;
  statement_1733:
  nfrfld = 6;
  nright = -1;
  freone(cmn, d1);
  nright = 0;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  if (kill > 0) {
    goto statement_99999;
  }
  text7(1) = texta6(1);
  text8(1) = texta6(2);
  text7(2) = texta6(3);
  text8(2) = texta6(4);
  text7(3) = texta6(5);
  text8(3) = texta6(6);
  statement_1735:
  goto statement_3857;
  statement_3869:
  kolbeg = n4;
  if (kolbeg > 0) {
    goto statement_1743;
  }
  read(abuff, "(i1,e9.0,e10.0,i10)"), iwind, cmag, pmag, ipunch;
  goto statement_1745;
  statement_1743:
  nfrfld = 1;
  freone(cmn, d11);
  iwind = d11;
  freone(cmn, cmag);
  freone(cmn, pmag);
  freone(cmn, d11);
  ipunch = d11;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  if (kill > 0) {
    goto statement_99999;
  }
  statement_1745:
  if (iwind == 2) {
    goto statement_7;
  }
  if (iwind == 3) {
    goto statement_7;
  }
  statement_3870:
  write(kunit6, "('+BLANK CARD TERMINATING  ''XFORMER''  CASES.')");
  interp();
  interp();
  statement_3872:
  lastov = nchain;
  nchain = 51;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
  statement_7:
  write(kunit6, "('+NEW DEVICE.',i6,2e12.3,i7)"), iwind, cmag, pmag, ipunch;
  if (iwind == 2) {
    goto statement_500;
  }
  text1(2) = t2;
  rsum = 0.f;
  xsum = 0.f;
  FEM_DO_SAFE(i, 1, 3) {
    cimage(cmn);
    //C     READ INPUT CARD USING CIMAGE                                      M20.4972
    if (kolbeg > 0) {
      goto statement_1753;
    }
    read(abuff, format_10), vtap, ploss, z, pratg;
    goto statement_1755;
    statement_1753:
    nfrfld = 1;
    freone(cmn, vtap);
    freone(cmn, ploss);
    freone(cmn, z);
    freone(cmn, pratg);
    if (iprsup >= 1) {
      write(lunit6, format_4568);
    }
    if (kill > 0) {
      goto statement_99999;
    }
    statement_1755:
    write(kunit6, format_3904), vtap, ploss, z, pratg;
    interp();
    temp1(i) = ploss;
    temp2(i) = z;
    temp3(i) = pratg;
    resist = ploss / (pratg * 1000.f);
    v(i) = vtap;
    rik(i) = resist / pratg;
    xik(i) = sqrtz(fem::pow2(z) / 10000.f - fem::pow2(resist)) / pratg;
    if (z < 0.0f) {
      xik(i) = -xik(i);
    }
    rsum += rik(i);
    xsum += xik(i);
  }
  write(lunit6, format_15), iwind, cmag, pmag;
  FEM_DO_SAFE(i, 1, 3) {
    write(lunit6, format_20), text1(i), v(i), text2(i), text3(i),
      temp1(i), temp2(i), temp3(i);
  }
  cmag = cmag * pmag / 300.f;
  rsum = rsum / 2.0f;
  xsum = xsum / 2.0f;
  ar = rsum - rik(1);
  ai = xsum - xik(1);
  cr = rik(2) * rik(3) - xik(2) * xik(3) - fem::pow2(ar) + fem::pow2(ai);
  cii = rik(2) * xik(3) + xik(2) * rik(3) - 2.0f * ar * ai;
  ai = fem::pow2(cr) + fem::pow2(cii);
  ar = cr / ai;
  ai = -cii / ai;
  ki = 0;
  i = 0;
  j = 0;
  statement_40:
  i++;
  if (i > 3) {
    goto statement_70;
  }
  k = 0;
  statement_50:
  k++;
  ki++;
  vtap = v(i) * v(k);
  if (k == i) {
    goto statement_60;
  }
  j++;
  cr = (rik(j) - rsum) / vtap;
  cii = (xik(j) - xsum) / vtap;
  rr(ki) = cii * ai - cr * ar;
  xx(ki) = -cii * ar - cr * ai;
  goto statement_50;
  statement_60:
  n = 4 - i;
  cr = rik(n) / vtap;
  cii = xik(n) / vtap;
  rr(ki) = cii * ai - cr * ar;
  cr = -cii * ar - cr * ai;
  cii = cmag / vtap;
  if (cii > std::abs(cr) * epsiln) {
    goto statement_65;
  }
  statement_62:
  write(lunit6,
    "(/,' PROBLEM.  ----  ADMITTANCE MATRIX FOR TRANSFORMER IS TOO CLOSE TO BE"
    "ING SINGULAR TO BE INVERTIBLE.   HENCE',/,17x,"
    "'THE INVERSION WILL BE SKIPPED.   PARAMETERS WHICH DOCUMENT THIS BREAKDOW"
    "N FOLLOW.',/,20x,9x,'EPSILN',12x,'CII',13x,'CR',/,20x,3e15.6)"),
    epsiln, cii, cr;
  goto statement_600;
  statement_65:
  xx(ki) = cr + cii;
  goto statement_40;
  statement_70:
  cxred1(rr(1), xx(1), ll3, ll0);
  statement_75:
  write(lunit6,
    "(/,' IMPEDANCE MATRIX AS REQUIRED FOR EMTP STUDIES (WITH  ''X''  IN OHMS "
    "AT THE POWER FREQUENCY)',/,3(14x,'R',14x,'X'))");
  i = 0;
  n = 1;
  statement_95:
  i++;
  if (i > iwind) {
    goto statement_110;
  }
  ki = n + i - 1;
  {
    write_loop wloop(cmn, lunit6, "(' ',a6,6e15.7)");
    wloop, text1(i);
    FEM_DO_SAFE(k, n, ki) {
      wloop, rr(k), xx(k);
    }
  }
  n += i;
  goto statement_95;
  statement_110:
  write(lunit6, "(/,1x)");
  if (ipunch > 0) {
    goto statement_4273;
  }
  {
    write_loop wloop(cmn, lunit6, format_4201);
    FEM_DO_SAFE(i, 1, 8) {
      wloop, i;
    }
  }
  FEM_DO_SAFE(i, 1, iwind) {
    if (i > 1) {
      goto statement_4228;
    }
    write(lunit7,
      "('51,',a6,',',a6,',  ,  ,   ',2(e22.13,' ,'),1x,',,,, ')"),
      text7(i), text8(i), rr(1), xx(1);
    write(lunit6,
      "(1x,'51,',a6,',',a6,',  ,  ,   ',2(e22.13,' ,'),1x,',,,, ')"),
      text7(i), text8(i), rr(1), xx(1);
    goto statement_4270;
    statement_4228:
    if (i > 2) {
      goto statement_4238;
    }
    write(lunit7,
      "('52,',a6,',',a6,',  ,  ,   ',e22.13,' ,',e22.13,' $',/,26x,2(e22.13,"
      "' ,'),1x,',,,, ')"),
      text7(i), text8(i), rr(2), xx(2), rr(3), xx(3);
    write(lunit6,
      "(1x,'52,',a6,',',a6,',  ,  ,   ',e22.13,' ,',e22.13,' $',/,27x,"
      "2(e22.13,' ,'),1x,',,,, ')"),
      text7(i), text8(i), rr(2), xx(2), rr(3), xx(3);
    goto statement_4270;
    statement_4238:
    {
      write_loop wloop(cmn, lunit7,
        "('53,',a6,',',a6,',  ,  ,   ',e22.13,' ,',e22.13,' $',/,26x,e22.13,"
        "' ,',e22.13,' $',/,26x,2(e22.13,' ,'),1x,',,,, ')");
      wloop, text7(i), text8(i);
      FEM_DO_SAFE(j, 4, 6) {
        wloop, rr(j), xx(j);
      }
    }
    {
      write_loop wloop(cmn, lunit6,
        "(1x,'53,',a6,',',a6,',  ,  ,   ',e22.13,' ,',e22.13,' $',/,27x,"
        "e22.13,' ,',e22.13,' $',/,27x,2(e22.13,' ,'),1x,',,,, ')");
      wloop, text7(i), text8(i);
      FEM_DO_SAFE(j, 4, 6) {
        wloop, rr(j), xx(j);
      }
    }
    statement_4270:;
  }
  write(lunit6, format_4271);
  statement_4273:
  ichck = 0;
  write(lunit6,
    "(/,' SHORT-CIRCUIT INPUT IMPEDANCES WHICH ARE OBTAINED FROM THE JUST-PRIN"
    "TED IMPEDANCE MATRIX, BY REVERSE',/,"
    "' COMPUTATION.   THIS IS SORT OF A CHECK ON THE COMPUTATION.')");
  statement_135:
  ar = fem::pow2(rr(2)) - fem::pow2(xx(2));
  ai = 2.0f * rr(2) * xx(2);
  cr = fem::pow2(rr(3)) + fem::pow2(xx(3));
  rsum = rr(3) / cr;
  xsum = -xx(3) / cr;
  cr = rr(1) - ar * rsum + ai * xsum;
  cii = xx(1) - ar * xsum - ai * rsum;
  if (iwind == 2) {
    goto statement_145;
  }
  write(lunit6, format_140), text2(1), text3(1), cr, cii;
  cr = fem::pow2(rr(6)) + fem::pow2(xx(6));
  rsum = rr(6) / cr;
  xsum = -xx(6) / cr;
  ar = fem::pow2(rr(4)) - fem::pow2(xx(4));
  ai = 2.0f * rr(4) * xx(4);
  cr = rr(1) - ar * rsum + ai * xsum;
  cii = xx(1) - ar * xsum - ai * rsum;
  write(lunit6, format_140), text2(2), text3(2), cr, cii;
  ar = fem::pow2(rr(5)) - fem::pow2(xx(5));
  ai = 2.0f * rr(5) * xx(5);
  cr = rr(3) - ar * rsum + ai * xsum;
  cii = xx(3) - ar * xsum - ai * rsum;
  write(lunit6, format_140), text2(3), text3(3), cr, cii;
  goto statement_146;
  statement_145:
  write(lunit6, format_140), text1(1), text1(3), cr, cii;
  statement_146:
  if (ichck > 0) {
    goto statement_600;
  }
  j = (iwind - 1) * 3;
  FEM_DO_SAFE(i, 1, j) {
    if (xx(i) < 0.0f) {
      write(lunit6,
        "(' INPUT DATA LOOKS SUSPICIOUS, BECAUSE ONE OR MORE INDUCTANCES IS NE"
        "GATIVE.')");
    }
    round(rr(i));
    round(xx(i));
  }
  write(lunit6,
    "(' REPEAT OF PRECEDING CALCULATION, ONLY THIS TIME THE STARTING POINT WIL"
    "L BE THE IMPEDANCE MATRIX WITH ALL',/,"
    "' ELEMENTS ROUNDED TO FIVE DECIMAL DIGITS.')");
  ichck = 1;
  goto statement_135;
  //C     READ INPUT CARD USING CIMAGE                                      M20.5044
  statement_500:
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_1763;
  }
  read(abuff, format_10), v1, v2, ploss, z, pratg;
  goto statement_1765;
  statement_1763:
  nfrfld = 1;
  freone(cmn, v1);
  freone(cmn, v2);
  freone(cmn, ploss);
  freone(cmn, z);
  freone(cmn, pratg);
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  if (kill > 0) {
    goto statement_99999;
  }
  statement_1765:
  write(kunit6, format_3904), v1, v2, ploss, z;
  interp();
  write(lunit6, format_15), iwind, cmag, pmag;
  write(lunit6, format_20), text1(1), v1, text1(1), text1(3), ploss, z, pratg;
  text1(2) = t3;
  cmag = cmag * pmag / 200.f;
  rsum = ploss / (pratg * 1000.f);
  xsum = sqrtz(fem::pow2(z) / 10000.f - fem::pow2(rsum));
  if (z < 0.0f) {
    xsum = -xsum;
  }
  cii = (fem::pow2(rsum) + fem::pow2(xsum)) / pratg;
  ar = rsum / cii;
  ai = -xsum / cii;
  if (cmag > std::abs(ai) * epsiln) {
    goto statement_3926;
  }
  cii = cmag;
  cr = ai;
  goto statement_62;
  statement_3926:
  vtap = fem::pow2(v1);
  rr(1) = -ar / vtap;
  xx(1) = (cmag - ai) / vtap;
  vtap = v1 * v2;
  rr(2) = ar / vtap;
  xx(2) = ai / vtap;
  vtap = fem::pow2(v2);
  rr(3) = -ar / vtap;
  xx(3) = (cmag - ai) / vtap;
  cxred1(rr(1), xx(1), ll2, ll0);
  goto statement_75;
  statement_600:
  write(lunit6, "(/,1x)");
  goto statement_5;
  //C     BEGIN CODE FOR THE CONVERSION OF SATURABLE  'TRANSFORMER'         M22.5806
  //C     DATA INTO  (R)  AND  (L)  SPECIFICATION (TYPE 51, 52, .. ).       M22.5807
  //C     LET  'ZK'  DENOTE THE COMPLEX (PHASOR) LEAKAGE IMPEDANCE FOR      M22.5808
  //C     WINDING  'K' ,   AND LET  'ZMAG'  DENOTE THE COMPLEX              M22.5809
  //C     MAGNETIZING IMPEDANCE.   FURTHER, LET  'TK'  BE THE RELATIVE      M22.5810
  //C     NUMBER OF TURNS FOR WINDING  'K' ,   AND LET  (Z)  BE THE         M22.5811
  //C     DESIRED OUTPUT MATRIX, WHERE    (Z) = (R) + JW(L)    AT           M22.5812
  //C     SINUSOIDAL FREQUENCE  'W' .   THEN THE RELEVANT CONVERSION        M22.5813
  //C     FORMULAS ARE  .....                                               M22.5814
  //C          Z(K,K)  =  ZK  +  ZMAG * (TK/T1)**2                          M22.5815
  //C          Z(K,J)  =  ZMAG * TK * TJ / T1**2      (FOR  J .NE. K )      M22.5816
  //C     READ INPUT CARD USING CIMAGE                                      M22.5817
  statement_7122:
  cimage(cmn);
  statement_7123:
  read(abuff, "(2x,a6,18x,2e6.2,6x,e6.2)"), bus5, d1, d2, d3;
  if (bus5 == text12) {
    goto statement_7132;
  }
  lstat(19) = 7132;
  lstat(14) = 1;
  goto statement_9000;
  statement_7132:
  write(kunit6, "('+SAT. XFORMER.  ',3e11.3)"), d1, d2, d3;
  d4 = d2 / d1;
  d5 = d4 * omega;
  FEM_DO_SAFE(i, 1, 99) {
    //C     READ INPUT CARD USING CIMAGE                                      M22.5831
    cimage(cmn);
    read(abuff, "(2a1)"), bus5, bus6;
    if (bus6 != text11) {
      goto statement_7151;
    }
    if (bus5 == text10) {
      goto statement_7157;
    }
    if (bus5 == blank) {
      goto statement_7157;
    }
    statement_7151:
    write(kunit6, "('+IGNORE CHARACTERISTIC IN SEARCH FOR WINDINGS.')");
  }
  lstat(19) = 7152;
  lstat(14) = 2;
  goto statement_9000;
  statement_7157:
  FEM_DO_SAFE(i, 1, 20) {
    if (i == 1) {
      goto statement_7161;
    }
    //C     READ INPUT CARD USING CIMAGE                                      M22.5845
    cimage(cmn);
    statement_7161:
    read(abuff, "(i2,2a6,12x,3e6.2)"), kk, aupper(i), alower(i),
      ohm(i), henry(i), volt(i);
    if (kk != i) {
      goto statement_7175;
    }
    iwind = kk;
    write(kunit6, "('+  WINDING',i2,'. ',3e12.4)"), i, ohm(i), henry(i),
      volt(i);
  }
  lstat(19) = 7175;
  lstat(14) = 3;
  goto statement_9000;
  statement_7175:
  write(kunit6, "('+DATA CARD FOR FOLLOWING TRANSFORMER, IF ANY.')");
  write(lunit6,
    "(/,/,"
    "' SATURABLE TRANSFORMER INPUT DATA IS NOW COMPLETE.   RELEVANT SCALAR PAR"
    "AMETERS MAY BE SUMMARIZED AS FOLLOWS ...',/,1x,i19,"
    "'  =  NUMBER OF TRANSFORMER WINDINGS',/,e20.6,"
    "'  =  POWER FREQUENCY IN HERTZ (EQUIVALENCE WILL BE EXACT AT THIS FREQUEN"
    "CY)',/,e20.6,"
    "'  =  ''XOPT''  (EMTP INDUCTANCE/REACTANCE SPECIFICATION PARAMETER)',/,"
    "e20.8,'  =  ASSUMED LINEAR MAGNETIZING INDUCTANCE IN HENRIES',/,e20.8,"
    "'  =  MAGNETIZING REACTANCE AT THE POWER FREQUENCY, IN OHMS')"),
    iwind, statfr, xopt, d4, d5;
  if (d3 > 0.0f) {
    goto statement_7206;
  }
  d9 = 0.0f;
  d10 = d5;
  goto statement_7216;
  statement_7206:
  d6 = fem::pow2(d3);
  d7 = fem::pow2(d5);
  d8 = d6 + d7;
  d9 = d3 * d7 / d8;
  d10 = d6 * d4 / d8;
  statement_7216:
  if (xopt == 0.0f) {
    d10 = d10 * 1000.f / omega;
  }
  if (xopt > 0.0f) {
    d10 = d10 * xopt / statfr;
  }
  {
    write_loop wloop(cmn, lunit6, format_4201);
    FEM_DO_SAFE(i, 1, 8) {
      wloop, i;
    }
  }
  FEM_DO_SAFE(i, 1, iwind) {
    n1 = i - 1;
    d11 = volt(i) / volt(1);
    text6 = typec(i);
    bus1 = aupper(i);
    bus2 = alower(i);
    if (n1 <= 0) {
      goto statement_7253;
    }
    FEM_DO_SAFE(j, 1, n1) {
      d12 = d11 * volt(j) / volt(1);
      d13 = d12 * d9;
      d14 = d12 * d10;
      write(lunit7, "(a2,2a6,12x,2(e22.13,1x,a1),1x,a1,6x)"), text6,
        bus1, bus2, d13, csepar, d14, chcont;
      write(lunit6, "(1x,a2,2a6,12x,2(e22.13,1x,a1),1x,a1,6x)"),
        text6, bus1, bus2, d13, csepar, d14, chcont;
      bus1 = blank;
      bus2 = blank;
      text6 = blank;
    }
    statement_7253:
    d12 = fem::pow2(d11);
    volti(i) = d12 * d9;
    voltk(i) = d12 * d10;
    d13 = ohm(i) + volti(i);
    d14 = henry(i) + voltk(i);
    {
      write_loop wloop(cmn, lunit7, "(a2,2a6,12x,2(e22.13,1x,a1),1x,5a1,2x)");
      wloop, text6, bus1, bus2, d13, csepar, d14;
      FEM_DO_SAFE(m, 1, 5) {
        wloop, csepar;
      }
    }
    {
      write_loop wloop(cmn, lunit6,
        "(1x,a2,2a6,12x,2(e22.13,1x,a1),1x,5a1,2x)");
      wloop, text6, bus1, bus2, d13, csepar, d14;
      FEM_DO_SAFE(m, 1, 5) {
        wloop, csepar;
      }
    }
  }
  write(lunit6, format_4271);
  {
    write_loop wloop(cmn, lunit6,
      "(' COMPONENTS WHICH ARE ADDED TO FORM DIAGONALS OF THE MATRIX.   COMPUT"
      "ER WORD-LENGTH SHOULD BE ABLE TO ACCURATELY',/,"
      "' HANDLE THIS ADDITION WITHOUT THE LEAKAGE BEING LOST IN THE ROUNDOFF. "
      "  IF NOT, THE RESULTING  (R)  AND  (L)  ARE OF',/,"
      "' QUESTIONABLE VALUE FOR PURPOSES OF EMTP SIMULATION.   COLUMN  1  IS T"
      "O BE ADDED TO COLUMN  3 ,   AND COLUMN  2  IS',/,"
      "' TO BE ADDED TO COLUMN  4  TO PRODUCE THE DIAGONALS.',/,7x,'ROW',11x,"
      "'LEAKAGE R',6x,'LEAKAGE L OR X',12x,'MAGNETIZING R',6x,"
      "'MAGNET. L OR X',16x,/(i10,2e20.10,5x,2e20.10))");
    FEM_DO_SAFE(i, 1, iwind) {
      wloop, i, ohm(i), henry(i), volti(i), voltk(i);
    }
  }
  {
    read_loop rloop(abuff(1), "(13a6,a2)");
    FEM_DO_SAFE(i, 1, 14) {
      rloop, aupper(i);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,/,/,"
      "' ANOTHER SATURABLE TRANSFORMER HAS NOW BEEN SUCCESSFULLY CONVERTED TO "
      " (R), (L)  FORMAT.   THAT COMPUTATION',/,"
      "' IS NOW COMPLETE.  THE EMTP NOW BEGINS TO PROCESS THE FOLLOWING CASE ("
      "IF ANY) BY RE-LISTING THE LAST-READ DATA',/,"
      "' CARD (WHICH DID NOT BELONG TO THE LAST CASE, RECALL).',/,1x,131('-'),"
      "/,'+',50x,'1',/,51x,'1',13a6,a2)");
    FEM_DO_SAFE(i, 1, 14) {
      wloop, aupper(i);
    }
  }
  read(abuff, "(2x,a6)"), bus5;
  if (bus5 == text12) {
    goto statement_7123;
  }
  if (bus5 == blank) {
    goto statement_3870;
  }
  lstat(14) = 1;
  lstat(19) = 7288;
  statement_9000:
  kill = 158;
  statement_9200:
  lstat(18) = nchain;
  lastov = nchain;
  nchain = 51;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  statement_99999:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct hysdat_save
{
  arr<int, 2> ibot;
  arr<int, 2> itop;

  hysdat_save() :
    ibot(dimension(1, 4), fem::fill0),
    itop(dimension(1, 4), fem::fill0)
  {}
};

void
hysdat(
  common& cmn) try
{
  FEM_CMN_SVE(hysdat);
  common_read read(cmn);
  common_write write(cmn);
  const auto& abuff = cmn.abuff;
  auto& voltbc = cmn.voltbc;
  auto& lunit7 = cmn.lunit7;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  int& ipunch = cmn.ipunch;
  int& itype = cmn.itype;
  int& iprsup = cmn.iprsup;
  //
  arr_ref<int, 2> ibot(sve.ibot, dimension(1, 4));
  arr_ref<int, 2> itop(sve.itop, dimension(1, 4));
  if (is_called_first_time) {
    {
      static const int values[] = {
        1, 5, 15, 29
      };
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE),
        itop;
    }
    {
      static const int values[] = {
        4, 14, 28, 50
      };
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE),
        ibot;
    }
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  arr_1d<50, double> b(fem::fill0);
  arr_1d<50, double> h(fem::fill0);
  int level = fem::int0;
  double cursat = fem::double0;
  double flxsat = fem::double0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  double scalef = fem::double0;
  double scalei = fem::double0;
  int i = fem::int0;
  double d1 = fem::double0;
  static const char* format_175 = "(20x,2e16.7)";
  static const char* format_178 = "(2e16.8)";
  //C     SET THE TOP AND BOTTOM POINTERS.                                  M29.4123
  //C     SET THE B POINTS (KILOGAUSS)                                      M25.1236
  b(1) = -15.6f;
  b(2) = 14.6f;
  b(3) = 17.0f;
  b(4) = 17.1f;
  b(5) = -16.5f;
  b(6) = -15.63f;
  b(7) = -14.4f;
  b(8) = -11.2f;
  b(9) = 9.7f;
  b(10) = 12.8f;
  b(11) = 14.7f;
  b(12) = 16.0f;
  b(13) = 17.0f;
  b(14) = 17.1f;
  b(15) = -16.6f;
  b(16) = -16.4f;
  b(17) = -15.9f;
  b(18) = -15.4f;
  b(19) = -14.2f;
  b(20) = -12.0f;
  b(21) = 8.6f;
  b(22) = 12.3f;
  b(23) = 13.8f;
  b(24) = 15.0f;
  b(25) = 15.8f;
  b(26) = 16.4f;
  b(27) = 17.0f;
  b(28) = 17.1f;
  b(29) = -16.6f;
  b(30) = -16.5f;
  b(31) = -16.15f;
  b(32) = -15.8f;
  b(33) = -15.5f;
  b(34) = -14.9f;
  b(35) = -14.2f;
  b(36) = -13.0f;
  b(37) = -11.0f;
  b(38) = -8.0f;
  b(39) = 5.35f;
  b(40) = 7.4f;
  b(41) = 10.0f;
  b(42) = 12.0f;
  b(43) = 13.0f;
  b(44) = 14.0f;
  b(45) = 14.9f;
  b(46) = 15.6f;
  b(47) = 16.1f;
  b(48) = 16.6f;
  b(49) = 17.0f;
  b(50) = 17.1f;
  //C     SET THE H POINTS (OERSTEDS)                                       M25.1242
  h(1) = .04f;
  h(2) = .17f;
  h(3) = 1.60f;
  h(4) = 2.20f;
  h(5) = -.40f;
  h(6) = -.05f;
  h(7) = .03f;
  h(8) = .07f;
  h(9) = .135f;
  h(10) = .21f;
  h(11) = .36f;
  h(12) = .665f;
  h(13) = 1.60f;
  h(14) = 2.20f;
  h(15) = -.60f;
  h(16) = -.30f;
  h(17) = -.10f;
  h(18) = -.02f;
  h(19) = .035f;
  h(20) = .066f;
  h(21) = .12f;
  h(22) = .19f;
  h(23) = .27f;
  h(24) = .40f;
  h(25) = .59f;
  h(26) = .92f;
  h(27) = 1.60f;
  h(28) = 2.20f;
  h(29) = -.60f;
  h(30) = -.40f;
  h(31) = -.18f;
  h(32) = -.08f;
  h(33) = -.03f;
  h(34) = .01f;
  h(35) = .035f;
  h(36) = .058f;
  h(37) = .07f;
  h(38) = .08f;
  h(39) = .10f;
  h(40) = .11f;
  h(41) = .14f;
  h(42) = .18f;
  h(43) = .218f;
  h(44) = .285f;
  h(45) = .39f;
  h(46) = .535f;
  h(47) = .70f;
  h(48) = 1.00f;
  h(49) = 1.60f;
  h(50) = 2.20f;
  statement_3548:
  if (iprsup >= 1) {
    write(lunit6, "(1x,'ENTER ITYPE AND LEVEL IN 2I1 FORMAT')");
  }
  //C     READ INPUT CARD USING CIMAGE.                                     M25.1255
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_3628;
  }
  read(abuff, "(10i8)"), itype, level, ipunch;
  if (itype != 0) {
    goto statement_3645;
  }
  if (level != 0) {
    goto statement_3645;
  }
  if (ipunch != 0) {
    goto statement_3645;
  }
  write(kunit6, "('+BLANK CARD ENDING HYSTERESIS-CURVE REQUESTS.')");
  interp();
  goto statement_9200;
  statement_3628:
  nfrfld = 3;
  frefld(cmn, voltbc(1));
  itype = voltbc(1);
  level = voltbc(2);
  ipunch = voltbc(3);
  statement_3645:
  write(kunit6, "('+BEGIN B-H.  (ITYPE, LEVEL, IPUNCH) =',3i4)"),
    itype, level, ipunch;
  if (itype == 1) {
    goto statement_125;
  }
  write(lunit6,
    "(1x,'JOB IS BEING HALTED- THE VALUE OF ITYPE=',i3,2x,'IS ILLEGAL')"),
    itype;
  goto statement_3548;
  statement_125:
  if ((level >= 1) && (level <= 4)) {
    goto statement_150;
  }
  write(lunit6,
    "(1x,'JOB IS BEING HALTED- THE VALUE OF LEVEL=',i3,2x,'IS ILLEGAL')"),
    level;
  goto statement_3548;
  statement_150:
  if (iprsup >= 1) {
    write(lunit6, "(1x,'ENTER ISAT(AMPS) AND FLXSAT(WB-TURNS) 2F10.4 FORMAT')");
  }
  //C     READ INPUT CARD USING CIMAGE                                      M25.1287
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_3682;
  }
  read(abuff, "(10e8.0)"), cursat, flxsat;
  goto statement_3695;
  statement_3682:
  nfrfld = 1;
  freone(cmn, cursat);
  freone(cmn, flxsat);
  if (cmn.kill > 0) {
    goto statement_9200;
  }
  statement_3695:
  write(kunit6, "('+CURSAT, FLXSAT =',2e13.4)"), cursat, flxsat;
  n1 = itop(itype, level);
  n2 = ibot(itype, level);
  scalef = flxsat / b(n2 - 1);
  scalei = cursat / h(n2 - 1);
  //C     RESCALE THE LOOP AND WRITE TO THE PUNCH UNIT.                     M25.1303
  write(lunit6,
    "(/,20x,'DERIVED TYPE-96 CHARACTERISTIC FOLLOWS:',/,20x,9x,'CURRENT',12x,"
    "'FLUX')");
  FEM_DO_SAFE(i, n1, n2) {
    h(i) = scalei * h(i);
    b(i) = scalef * b(i);
    write(lunit6, format_175), h(i), b(i);
    if (ipunch == 0) {
      write(lunit7, format_178), h(i), b(i);
    }
  }
  d1 = 9999.f;
  write(lunit6, format_175), d1;
  if (ipunch == 0) {
    write(lunit7, format_178), d1;
  }
  write(lunit6, format_175);
  goto statement_3548;
  statement_9200:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct arrdat_save
{
  fem::str<8> text1;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  fem::str<8> text55;
  fem::str<8> text92;
  fem::str<8> textb;

  arrdat_save() :
    text1(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text55(fem::char0),
    text92(fem::char0),
    textb(fem::char0)
  {}
};

void
arrdat(
  common& cmn) try
{
  FEM_CMN_SVE(arrdat);
  common_read read(cmn);
  common_write write(cmn);
  const auto& abuff = cmn.abuff;
  double& ci1 = cmn.ci1;
  double& ck1 = cmn.ck1;
  auto& lunit7 = cmn.lunit7;
  auto& lstat = cmn.lstat;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text55 = sve.text55;
  fem::str<8>& text92 = sve.text92;
  fem::str<8>& textb = sve.textb;
  if (is_called_first_time) {
    text1 = "GAPP";
    text2 = "ED  ";
    text3 = "GAPL";
    text4 = "ESS ";
    textb = "BRANCH";
    text92 = "92";
    text55 = "5555.";
  }
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int maxexp = fem::int0;
  int nbran = fem::int0;
  double derlim = fem::double0;
  double ainf = fem::double0;
  int jcase = fem::int0;
  int icar = fem::int0;
  int ndat = fem::int0;
  arr_1d<60, fem::str<8> > textna(fem::fill0);
  fem::str<8> textc = fem::char0;
  int nkc = fem::int0;
  int nk1 = fem::int0;
  int jv = fem::int0;
  int nexp = fem::int0;
  int iphase = fem::int0;
  double d66 = fem::double0;
  int iprzno = fem::int0;
  double vref = fem::double0;
  double vflash = fem::double0;
  int ifit = fem::int0;
  int jkp = fem::int0;
  arr_1d<2, int> nd(fem::fill0);
  double a1 = fem::double0;
  double a2 = fem::double0;
  double a3 = fem::double0;
  double a4 = fem::double0;
  double a5 = fem::double0;
  double amin = fem::double0;
  int jd = fem::int0;
  double alvref = fem::double0;
  double ala5 = fem::double0;
  double errlim = fem::double0;
  double dq = fem::double0;
  int j = fem::int0;
  int nk = fem::int0;
  int i = fem::int0;
  double d = fem::double0;
  double e = fem::double0;
  double f = fem::double0;
  double g = fem::double0;
  int n6 = fem::int0;
  double a = fem::double0;
  double b = fem::double0;
  arr_1d<200, double> cc(fem::fill0);
  arr_1d<200, double> vc(fem::fill0);
  arr_1d<200, double> v(fem::fill0);
  arr_1d<200, double> c(fem::fill0);
  int ip = fem::int0;
  int ju = fem::int0;
  arr_1d<200, double> s(fem::fill0);
  double bv = fem::double0;
  double by = fem::double0;
  double bx = fem::double0;
  double bu = fem::double0;
  double vcor1 = fem::double0;
  double vcorr = fem::double0;
  int ku = fem::int0;
  double cref = fem::double0;
  arr_1d<200, double> bg(fem::fill0);
  arr_1d<200, double> vs(fem::fill0);
  arr_1d<100, int> nt(fem::fill0);
  int jkb = fem::int0;
  int i1 = fem::int0;
  int ikb = fem::int0;
  double d1 = fem::double0;
  double alb = fem::double0;
  int ks = fem::int0;
  arr_1d<200, double> ck(fem::fill0);
  double err = fem::double0;
  double vmin = fem::double0;
  int nb = fem::int0;
  int k = fem::int0;
  int jk = fem::int0;
  int ki = fem::int0;
  int kp = fem::int0;
  int n4 = fem::int0;
  int ij = fem::int0;
  double bk = fem::double0;
  static const char* format_1220 = "(2i12,e12.0,i12,2e12.0)";
  static const char* format_1540 = "(6e12.0)";
  static const char* format_1622 =
    "(' INPUT DATA AFTER CONVERSION TO A LOG-LOG PLANE',"
    "'  ==================',/,23x,'CURRENT',18x,'VOLTAGE',/(5x,2e25.15))";
  static const char* format_1660 =
    "(/,' CALCULATED VALUES.  J, I =',2i5,5x,'S(JU), BG(JU) =',2e20.10)";
  static const char* format_2243 =
    "(1x,'----------------------------------------',"
    "'----------------------------------------')";
  static const char* format_2245 = "(1x,8i10)";
  static const char* format_2248 =
    "(' C RATING =',f9.2,'  V-MULT =',e13.5,'  I-MULT =',e13.5,2x,2a4)";
  static const char* format_2252 =
    "('C RATING =',f9.2,'  V-MULT =',e13.5,'  I-MULT =',e13.5,2x,2a4)";
  static const char* format_3278 =
    "(/,'THE PRESENT CASE REQUIRES MORE THAN THE PRESENT',' LIMIT OF',i4,"
    "' EXPONENTIALS')";
  static const char* format_3354 =
    "(2x,'VREFERENCE RESET TO PREVENT NUMERICAL OVERFLOW.',"
    "' THE OLD AND NEW VALUES FOLLOW....',2x,2e15.6)";
  //C     PROGRAM TO PERFORM LEAST-SQUARES FIT OF STRAIGHT-LINE SEGMENTS TO M27.3451
  //C     A SET OF DATA POINTS. THE NUMBER OF SEGMENTS IS LIMITED TO MAXEXP M27.3452
  //C     DEFINE CONSTANTS************************************************* M37.8047
  maxexp = 100;
  nbran = 60;
  derlim = .05f;
  ainf = alog1z(cmn.fltinf);
  jcase = 0;
  statement_1200:
  icar = 0;
  ndat = 0;
  copya(cmn.blank, textna(1), nbran);
  statement_1202:
  //C     READ INPUT CARD USING CIMAGE                                      M37.8055
  cimage(cmn);
  //C     CHECK FOR "BRANCH" REQUEST                                        M37.8056
  read(abuff, "(a6)"), textc;
  if (textc != textb) {
    goto statement_1212;
  }
  //C     PROCESS TERMINAL NODES INPUT************************************* M37.8060
  nkc = ndat + 12;
  if (nkc <= nbran) {
    goto statement_1308;
  }
  lstat(19) = 1308;
  write(lunit6,
    "(/,' REQUIRED NUMBER OF NODES EQUAL',i10,"
    "'IS GREATER THAN MAXIMUM WHICH EQUALS',i10)"),
    nkc, nbran;
  goto statement_9200;
  statement_1308:
  nk1 = ndat + 1;
  ndat += 12;
  {
    read_loop rloop(abuff(1), "(8x,12a6)");
    FEM_DO_SAFE(jv, nk1, ndat) {
      rloop, textna(jv);
    }
  }
  write(kunit6, "('+BUS NAMES FOR EACH PHASE. ')");
  goto statement_1202;
  //C     PROCESS MISCELLANEOUS DATA CARD********************************** M37.8077
  statement_1212:
  read(abuff, format_1220), nexp, iphase, d66, iprzno, vref, vflash;
  if (nexp != 0 || iphase != 0) {
    goto statement_1232;
  }
  write(kunit6, "('+BLANK CARD ENDS ARRESTER CASES.')");
  goto statement_9900;
  statement_1232:
  write(kunit6, "('+ARRESTER.',3i4,2e12.3)"), nexp, iphase, iprzno,
    vref, vflash;
  if (iprzno >= 3) {
    write(lunit6,
      "(/,/,' BEGIN NEXT DATA CASE.',' **********  **********  **********',"
      "'  **********')");
  }
  jcase++;
  ifit = 1;
  if (nexp > 0) {
    goto statement_1260;
  }
  ifit = -1;
  statement_1260:
  if (vref > 0.0f) {
    goto statement_1280;
  }
  vref = 0.0f;
  statement_1280:
  if (iphase <= 0) {
    iphase = 1;
  }
  jkp = 0;
  nd(2) = 0;
  //C     READ INPUT CARD USING CIMAGE.                                     M27.3514
  cimage(cmn);
  read(abuff, format_1540), a1, a2, a3, a4, a5, amin;
  write(kunit6, "('+RATINGS.',4e10.2)"), a1, a2, a3, a4;
  if (a1 > 0.0f) {
    goto statement_1340;
  }
  lstat(19) = 1328;
  write(lunit6, "(/,' ILLEGAL NON-POSITIVE  \"A1\"  EQUALS',e15.5)"), a1;
  goto statement_9200;
  statement_1340:
  if (a2 > 0.0f) {
    goto statement_1360;
  }
  lstat(19) = 1348;
  write(lunit6, "(/,' ILLEGAL NON-POSITIVE  \"A2\"  EQUALS',e15.5)"), a2;
  goto statement_9200;
  statement_1360:
  if (a3 > 0.0f) {
    goto statement_1380;
  }
  lstat(19) = 1366;
  write(lunit6, "(/,' ILLEGAL NON-POSITIVE  \"A3\"  EQUALS',e15.5)"), a3;
  goto statement_9200;
  statement_1380:
  if (a4 > 0.0f) {
    goto statement_1400;
  }
  lstat(19) = 1387;
  write(lunit6, "(/,' ILLEGAL NON-POSITIVE  \"A4\"  EQUALS',e15.5)"), a4;
  goto statement_9200;
  statement_1400:
  if (amin > 0.0f) {
    goto statement_1420;
  }
  lstat(19) = 1402;
  write(lunit6, "(/,' ILLEGAL NON-POSITIVE  \"AMIN\"  EQUALS',e15.5)"), amin;
  goto statement_9200;
  statement_1420:
  if (a5 == 0.0f) {
    a5 = 1.0f;
  }
  if (vref > 0.0f) {
    goto statement_1421;
  }
  vref = 2.0f * a2;
  statement_1421:
  if (a5 == 1.0f && vflash == 0.0f) {
    goto statement_1425;
  }
  if (a5 != 1.0f && vflash > 0.0f) {
    goto statement_1425;
  }
  lstat(19) = 1421;
  write(lunit6,
    "(/,' ILLEGAL \"A5\"-\"VFLASH\" COMBINATION',2e15.5)"), a5,
    vflash;
  goto statement_9200;
  statement_1425:
  if (iprzno < 3) {
    goto statement_1451;
  }
  write(lunit6,
    "(5x,' NUMBER OF SEGMENTS',5x,' REFERENCE VOLTAGE',5x,' NUMBER OF PHASES',"
    "5x,' FLASHOVER VOLTAGE',/,5x,i19,5x,e18.8,5x,i17,5x,e18.8)"),
    nexp, vref, iphase, vflash;
  write(lunit6,
    "(2x,'CONSTANTS FOR CONVERSION OF INPUT DATA',/,7x,'ORIGINAL RATING',12x,"
    "'NEW RATING',4x,'VOLTAGE MULTIPLIER',4x,'CURRENT MULTIPLIER',6x,"
    "'ADDITIONAL BLOCKS FACTOR',/,4e22.8,e30.8)"),
    a1, a2, a3, a4, a5;
  statement_1451:
  amin = alog1z(amin * a4);
  jd = 0;
  alvref = alog1z(vref);
  ala5 = 0.0f;
  if (a5 > 0.0f) {
    ala5 = alog1z(a5);
  }
  statement_1455:
  if (ifit > 0) {
    goto statement_1460;
  }
  write(lunit6, "(2x,' TOLERANCE \"ERRLIM\".',5x,e15.6)"), d66;
  if (d66 <= 0.0f) {
    d66 = derlim;
  }
  errlim = d66;
  nexp = 1;
  //C     PROCESS CARDS WITH ARRESTER DATA********************************* M37.8114
  statement_1460:
  if (nexp <= maxexp) {
    goto statement_1465;
  }
  write(lunit6, format_3278), maxexp;
  lstat(19) = 1460;
  goto statement_9200;
  statement_1465:
  icar = 0;
  jkp++;
  dq = (a2 / a1) * a3;
  j = 0;
  nk = 0;
  statement_1480:
  i = 0;
  ck1 = 0.0f;
  ci1 = 0.0f;
  d = 0.0f;
  e = 0.0f;
  f = 0.0f;
  g = 0.0f;
  n6 = nk + 1;
  //C     READ INPUT CARD USING CIMAGE.                                     M27.3571
  statement_1520:
  cimage(cmn);
  read(abuff, format_1540), a, b;
  icar++;
  if (a == 0.0f && icar > 2) {
    goto statement_1620;
  }
  write(kunit6, "('+(I,V) POINT.',2e15.6)"), a, b;
  nk++;
  if (a > ck1 && b > ci1) {
    goto statement_1590;
  }
  write(lunit6,
    "(/,' NONPOSITVE OR NONMOMTONIC \"A\" AND/OR \"B\"',"
    "' THE READ-IN VALUES ARE',2e15.6)"),
    a, b;
  lstat(19) = 1580;
  goto statement_9200;
  statement_1590:
  ck1 = a;
  ci1 = b;
  i++;
  a = a * a4;
  cc(nk) = a;
  vc(nk) = b * dq;
  a = alog1z(a);
  b = alog1z(vc(nk)) - alvref;
  v(nk) = b;
  c(nk) = a;
  if (iprzno >= 8) {
    write(lunit6, "(5x,4e25.10)"), a, b;
  }
  e += a;
  d += b;
  f += b * b;
  g += a * b;
  goto statement_1520;
  statement_1620:
  write(kunit6, "('+BLANK CARD ENDS CHARACTERISTIC.')");
  interp();
  if (iprzno >= 2) {
    {
      write_loop wloop(cmn, lunit6, format_1622);
      FEM_DO_SAFE(ip, n6, nk) {
        wloop, c(ip), v(ip);
      }
    }
  }
  if (ifit < 0) {
    goto statement_3100;
  }
  //C     CODE FOR USER DEFINED SEGMENTS*********************************** M37.8138
  if (cmn.iprsup > 1) {
    write(lunit6,
      "(1x,'CONSTANTS FOR THE FITTING PROCEDURE',/,' D =',e16.7,5x,'E =',"
      "e16.7,5x,'F =',e16.7,5x,'G =',e16.7)"),
      d, e, f, g;
  }
  j++;
  a = (g - (d * e) / i) / (f - (d * d) / i);
  ju = j + jd;
  s(ju) = a;
  bv = (e - a * d) / i;
  by = bv;
  bx = std::abs(by);
  if (ala5 == 0.0f) {
    goto statement_1642;
  }
  bu = bv - a * ala5;
  if (std::abs(bu) > bx) {
    by = bu;
  }
  statement_1642:
  if (std::abs(by) <= ainf) {
    goto statement_1650;
  }
  vcor1 = ainf * bx / bv - by;
  vcorr = vcor1 / a;
  FEM_DO_SAFE(ku, 1, nk) {
    v(ku) = v(ku) - vcorr;
  }
  cref = vref;
  vref = vref * fem::pow(10.0f, vcorr);
  write(lunit6, format_3354), cref, vref;
  alvref += vcorr;
  bv += vcor1;
  FEM_DO_SAFE(ku, 1, ju) {
    bg(ku) += vcor1;
  }
  if (jd == 0) {
    goto statement_1650;
  }
  FEM_DO_SAFE(ku, 1, jd) {
    vs(ku) = vs(ku) - vcorr;
  }
  statement_1650:
  bg(ju) = bv;
  if (iprzno > 1) {
    write(lunit6, format_1660), j, i, s(ju), bg(ju);
  }
  nt(j) = i;
  if (j < nexp) {
    goto statement_1480;
  }
  goto statement_1680;
  //C     START AUTOMATIC DETERMINATION OF SEGMENTS************************ M37.8142
  statement_3100:
  jkb = n6 - 1;
  nexp = 0;
  statement_3200:
  jkb++;
  if (jkb > nk) {
    goto statement_1680;
  }
  if (jkb < nk) {
    goto statement_3250;
  }
  nt(j) = nt(j) - 1;
  jkb = jkb - 1;
  statement_3250:
  j++;
  i1 = 1;
  nexp++;
  if (nexp <= maxexp) {
    goto statement_3280;
  }
  lstat(19) = 3280;
  write(lunit6, format_3278), maxexp;
  goto statement_9200;
  statement_3280:
  ju = j + jd;
  e = c(jkb);
  d = v(jkb);
  f = d * d;
  g = e * d;
  ikb = jkb;
  //C     START INTERNAL FITTING LOOP************************************** M37.8165
  statement_3300:
  ikb++;
  if (ikb <= nk) {
    goto statement_3350;
  }
  nt(j) = nt(j) - 1;
  goto statement_1680;
  statement_3350:
  i1++;
  a = c(ikb);
  b = v(ikb);
  e += a;
  d += b;
  f += b * b;
  g += a * b;
  d1 = d / i1;
  a = (g - d1 * e) / (f - d1 * d);
  bv = (e - a * d) / i1;
  by = bv;
  bx = std::abs(by);
  if (ala5 == 0.0f) {
    goto statement_3342;
  }
  bu = bv - a * ala5;
  if (std::abs(bu) > bx) {
    by = bu;
  }
  statement_3342:
  if (std::abs(by) <= ainf) {
    goto statement_3352;
  }
  vcor1 = ainf * bx / bv - by;
  vcorr = vcor1 / a;
  FEM_DO_SAFE(ku, 1, nk) {
    v(ku) = v(ku) - vcorr;
  }
  cref = vref;
  vref = vref * fem::pow(10.0f, vcorr);
  write(lunit6, format_3354), cref, vref;
  alvref += vcorr;
  bv += vcor1;
  FEM_DO_SAFE(ku, 1, ju) {
    bg(ku) += vcor1;
  }
  if (jd == 0) {
    goto statement_3352;
  }
  FEM_DO_SAFE(ku, 1, jd) {
    vs(ku) = vs(ku) - vcorr;
  }
  statement_3352:
  alb = fem::pow(10.0f, bv);
  //C     CHECK LOCAL FITTING ERRORS AFTER EXPANSION*********************** M37.8181
  FEM_DO_SAFE(ks, jkb, ikb) {
    ck(ks) = alb * fem::pow((vc(ks) / vref), a);
    err = std::abs(ck(ks) - cc(ks)) / cc(ks);
    if (err > errlim) {
      goto statement_3500;
    }
  }
  bg(ju) = bv;
  s(ju) = a;
  nt(j) = i1;
  if (iprzno > 1) {
    write(lunit6, format_1660), j, i1, s(ju), bg(ju);
  }
  goto statement_3300;
  //C     REMOVE LAST POINT (ERROR TOO LARGE)****************************** M37.8193
  statement_3500:
  jkb = ikb - 2;
  if (nexp > 1) {
    nt(j) = nt(j) - 1;
  }
  goto statement_3200;
  statement_1680:
  vmin = (amin - bg(jd + 1)) / s(jd + 1);
  vs(jd + 1) = vmin;
  nd(jkp) = nexp;
  if (nexp < 2) {
    goto statement_1720;
  }
  nb = nexp - 1;
  FEM_DO_SAFE(i, 1, nb) {
    k = i + jd;
    j = k + 1;
    a = (bg(j) - bg(k)) / (s(k) - s(j));
    vs(j) = a;
  }
  statement_1720:
  if (iprzno < 2) {
    goto statement_1780;
  }
  FEM_DO_SAFE(i, 1, nexp) {
    ju = i + jd;
    write(lunit6, "(i5,4e20.10)"), i, bg(ju), vs(ju);
  }
  statement_1780:
  write(lunit6,
    "(/,3x,'**********','  ERROR STATISTICS  **********',/,3x,'SEGMENT',14x,"
    "'LOCAL ERROR',8x,'ACCUMULATED ERROR')");
  jk = 0;
  b = 0.f;
  FEM_DO_SAFE(j, 1, nexp) {
    a = 0.0f;
    ju = jd + j;
    bv = fem::pow(10.0f, bg(ju));
    i = nt(j);
    ki = jk + 1;
    jk += i;
    FEM_DO_SAFE(k, ki, jk) {
      ck(k) = bv * fem::pow((vc(k) / vref), s(ju));
      a += fem::pow2((c(k) - s(ju) * v(k) - bg(ju)));
    }
    b += a;
    write(lunit6, "(i10,2x,2e20.10)"), j, a, b;
  }
  if (iprzno < 1) {
    goto statement_1940;
  }
  write(lunit6,
    "(/,'  COMPARISON BETWEEN INPUT DATA AND',' THE RECALCULATED POINTS',/,8x,"
    "'INPUT VOLTAGE',7x,'INPUT CURRENT',2x,'CALCULATED CURRENT','  &&&&&&&&')");
  FEM_DO_SAFE(k, 1, jk) {
    write(lunit6, "(3e20.10)"), vc(k), cc(k), ck(k);
  }
  statement_1940:
  if (a5 == 0.0f || a5 == 1.0f) {
    goto statement_2080;
  }
  jd += nexp;
  if (a5 < 0.0f) {
    goto statement_2020;
  }
  if (iprzno >= 1) {
    write(lunit6,
      "(/,'  REPROCESS INPUT DATA.  MULTIPLIER \"A5\" =',e20.10)"),
      a5;
  }
  if (iprzno >= 2) {
    write(lunit6, format_1622);
  }
  jk = 0;
  jkp++;
  FEM_DO_SAFE(j, 1, nexp) {
    i = nt(j);
    ki = jk + 1;
    jk += i;
    kp = 0;
    FEM_DO_SAFE(k, ki, jk) {
      kp++;
      vc(k) = vc(k) * a5;
      v(k) += ala5;
    }
    ju = j + jd;
    a = s(j);
    s(ju) = a;
    bg(ju) = bg(j) - a * ala5;
    if (iprzno > 1) {
      write(lunit6, format_1660), j, kp, s(ju), bg(ju);
    }
  }
  a5 = 0.f;
  goto statement_1680;
  statement_2020:
  write(lunit6,
    "('  PROCESS SECOND PART OF CASE NO.',i6,'   &&&&&&&&&&&&&&&&&')"),
    jcase;
  //C     READ INPUT CARD USING CIMAGE.                                     M27.3722
  cimage(cmn);
  read(abuff, format_1220), nexp;
  ifit = 1;
  if (nexp <= maxexp) {
    goto statement_2060;
  }
  ifit = -1;
  statement_2060:
  a5 = 0.f;
  goto statement_1455;
  statement_2080:
  vflash = vflash / vref;
  if (vflash == 0.0f) {
    vflash = -100.0f;
  }
  write(lunit6,
    "(/,/,'  **********   80-COLUMN CARD-IMAGE',"
    "' LISTING OF UNIT-7 PUNCHED CARDS.','   *******')");
  write(lunit6, format_2243);
  {
    write_loop wloop(cmn, lunit6, format_2245);
    FEM_DO_SAFE(ip, 1, 8) {
      wloop, ip;
    }
  }
  n4 = 0;
  {
    write_loop wloop(cmn, lunit6, format_2245);
    FEM_DO_SAFE(ip, 1, 8) {
      wloop, n4;
    }
  }
  write(lunit6, format_2243);
  if (a5 == 0.f) {
    goto statement_2260;
  }
  write(lunit6, format_2248), a2, a3, a4, text3, text4;
  write(lunit7, format_2252), a2, a3, a4, text3, text4;
  goto statement_2320;
  statement_2260:
  write(lunit6, format_2248), a2, a3, a4, text1, text2;
  write(lunit7, format_2252), a2, a3, a4, text1, text2;
  statement_2320:
  nkc = 2;
  FEM_DO_SAFE(k, 1, iphase) {
    if (k > 1) {
      goto statement_2422;
    }
    write(lunit6, "(1x,a2,2a6,25x,a5)"), text92, textna(1), textna(2), text55;
    write(lunit7, "(a2,2a6,25x,a5)"), text92, textna(1), textna(2), text55;
    write(lunit6, "(1x,'C',12x,'  VREFERENCE',15x,'VFLASHOVER')");
    write(lunit6, "(1x,2e25.15)"), vref, vflash;
    write(lunit7, "('C',12x,'  VREFERENCE',15x,'VFLASHOVER')");
    write(lunit7, "(2e25.15)"), vref, vflash;
    j = 0;
    write(lunit6, "(1x,'C',12x,'  MULTIPLIER',17x,'EXPONENT',21x,'VMIN')");
    write(lunit7, "('C',12x,'  MULTIPLIER',17x,'EXPONENT',21x,'VMIN')");
    FEM_DO_SAFE(ij, 1, jkp) {
      ju = j + 1;
      jk = j + nd(ij);
      FEM_DO_SAFE(i, ju, jk) {
        bv = fem::pow(10.0f, vs(i));
        bk = fem::pow(10.0f, bg(i));
        write(lunit6, "(1x,3e25.15)"), bk, s(i), bv;
        write(lunit7, "(3e25.15)"), bk, s(i), bv;
      }
      write(lunit6, "(1x,21x,'9999')");
      write(lunit7, "(21x,'9999')");
      j = jk;
    }
    goto statement_2440;
    statement_2422:
    write(lunit6, "(1x,a2,4a6,13x,a5)"), text92, textna(nkc + 1),
      textna(nkc + 2), textna(1), textna(2), text55;
    write(lunit7, "(a2,4a6,13x,a5)"), text92, textna(nkc + 1), textna(nkc + 2),
      textna(1), textna(2), text55;
    nkc += 2;
    statement_2440:;
  }
  write(lunit6, format_2243);
  write(lunit6, "(/,1x)");
  goto statement_1200;
  statement_9200:
  cmn.kill = 1000;
  statement_9900:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
zinold(
  common& cmn) try
{
  common_read read(cmn);
  common_write write(cmn);
  const auto& abuff = cmn.abuff;
  auto& lunit7 = cmn.lunit7;
  int& noutpr = cmn.noutpr;
  //
  auto& lunit6 = cmn.lunit6;
  int iarest = fem::int0;
  int noup = fem::int0;
  fem::str<30> cblank = fem::char0;
  arr_1d<14, fem::str<8> > text(fem::fill0);
  fem::str<80> cbuff = fem::char0;
  arr_1d<35, fem::str<80> > bbuff(fem::fill0);
  int iblank = fem::int0;
  int icond = fem::int0;
  int ik = fem::int0;
  int iphase = fem::int0;
  arr_1d<20, double> zk(fem::fill0);
  int k = fem::int0;
  double vref = fem::double0;
  double vref1 = fem::double0;
  double vflash = fem::double0;
  double vzero7 = fem::double0;
  int L = fem::int0;
  int k2 = fem::int0;
  int k1 = fem::int0;
  int ki = fem::int0;
  int n19 = fem::int0;
  double vstart = fem::double0;
  static const char* format_3417 = "(13a6,a2)";
  static const char* format_3421 = "(i8,4e16.0,e8.0)";
  static const char* format_3422 = "(3e25.15)";
  static const char* format_3423 = "(1x,3e25.15)";
  static const char* format_3424 = "(21x,'9999')";
  static const char* format_3425 = "(1x,21x,'9999')";
  //C     THIS MODULE IS USED TO CONVERT OLD  ("M36." OR EARLIER VINTAGE )  M39.3422
  //C     ZINC OXIDE ARRESTER DATA INTO THE NEW FORM AS REQUIRED FOR THE    M39.3423
  //C     M37 (AND LATER EMTP VERSIONS).                                    M39.3424
  //C     THIS MODULE USES THE ANSI 77 FORTRAN FEATURES AND MAY, THEREFORE, M39.3425
  //C     NOT RUN ON SYSTEMS THAT DO NOT HAVE THOSE CAPABILITIES.           M39.3426
  //C     IT IS ASSUMED THAT THE DATA CASE TO BE PROCESSED IS A VALID ONE,  M39.3427
  //C     I.E., IT DID EXECUTE CORRECTLY ON THE OLDER PROGRAM VERSIONS      M39.3428
  write(lunit6,
    "(' BEGIN EXECUTION OF \"ZINOLD\", TO CONVERT',"
    "' FROM OLD TO NEW ZNO FORMATS.')");
  iarest = 0;
  noup = noutpr;
  noutpr = 1;
  cblank = "                              ";
  //C     PROCESS BRANCH CARDS ******************************************** M39.3441
  //C     READ INPUT CARD USING CIMAGE                                      M39.3442
  statement_100:
  cimage(cmn);
  read(abuff, format_3417), text;
  write(cbuff, format_3417), text;
  if (cbuff(1, 2) != "92") {
    goto statement_150;
  }
  if (cbuff(28, 32) != "5555." && cbuff(27, 31) != "5555.") {
    goto statement_150;
  }
  cbuff(27, 32) = "      ";
  cbuff(40, 44) = "5555.";
  cbuff(15, 20) = "      ";
  cbuff(21, 26) = "      ";
  iarest++;
  bbuff(iarest) = cbuff;
  goto statement_100;
  statement_150:
  if (cbuff(1, 6) == "BLANK " || cbuff(1, 30) == cblank) {
    if (iarest > 0) {
      goto statement_200;
    }
  }
  else {
    goto statement_100;
  }
  if (iarest > 0) {
    goto statement_200;
  }
  FEM_STOP(0);
  //C     PROCESS SWITCH DATA CARDS *************************************** M39.3467
  //C     READ CARDS USING CIMAGE                                           M39.3468
  statement_200:
  cimage(cmn);
  read(abuff, format_3417), text;
  write(cbuff, format_3417), text;
  if (cbuff(1, 6) == "BLANK " || cbuff(1, 30) == cblank) {
    goto statement_300;
  }
  goto statement_200;
  //C     PROCESS SOURCE CARDS ******************************************** M39.3475
  //C     READ CARDS USING CIMAGE                                           M39.3476
  statement_300:
  cimage(cmn);
  read(abuff, format_3417), text;
  write(cbuff, format_3417), text;
  if (cbuff(1, 1) == "5") {
    //C     READ CARDS USING CIMAGE                                           M39.3481
    statement_340:
    cimage(cmn);
    read(abuff, format_3417), text;
    write(cbuff, format_3417), text;
    if (cbuff(3, 8) == "FINISH") {
      goto statement_300;
    }
    goto statement_340;
  }
  else if (cbuff(1, 6) == "BLANK " || cbuff(1, 30) == cblank) {
    goto statement_400;
  }
  else if (cbuff(1, 2) == "19") {
    iblank = 0;
    //C     READ CARDS USING CIMAGE                                           M39.3492
    statement_350:
    cimage(cmn);
    read(abuff, format_3417), text;
    write(cbuff, format_3417), text;
    if (cbuff(1, 6) != "BLANK " && cbuff(1, 30) != cblank) {
      goto statement_350;
    }
    iblank++;
    if (iblank == 1) {
      goto statement_350;
    }
  }
  goto statement_300;
  statement_400:
  //C     REMOVE INITIAL CONDITIONS, IF ANY ******************************* M39.3503
  //C     READ CARDS USING CIMAGE                                           M39.3504
  cimage(cmn);
  read(abuff, "(i2)"), icond;
  if (icond > 1 && icond < 6) {
    goto statement_400;
  }
  ik = 0;
  goto statement_510;
  //C     PROCESS ARRESTER DATA ******************************************* M39.3511
  //C     READ CARDS USING CIMAGE                                           M39.3512
  statement_500:
  cimage(cmn);
  statement_510:
  {
    read_loop rloop(abuff(1), format_3421);
    rloop, iphase;
    FEM_DO_SAFE(k, 1, 5) {
      rloop, zk(k);
    }
  }
  ik++;
  write(lunit7, "(a80)"), bbuff(ik);
  if (iphase > 0) {
    goto statement_530;
  }
  vref = zk(5);
  if (vref == 0.0f) {
    vref = vref1;
  }
  vref1 = vref;
  vflash = -100.0f;
  vzero7 = zk(4);
  write(lunit7, format_3422), vref, vflash, vzero7;
  write(lunit6, format_3423), vref, vflash, vzero7;
  {
    write_loop wloop(cmn, lunit7, format_3422);
    FEM_DO_SAFE(L, 1, 3) {
      wloop, zk(L);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3423);
    FEM_DO_SAFE(L, 1, 3) {
      wloop, zk(L);
    }
  }
  write(lunit7, format_3424);
  write(lunit6, format_3425);
  goto statement_590;
  statement_530:
  k2 = 4;
  FEM_DO_SAFE(k, 1, 3) {
    k1 = k2 + 1;
    k2 += 4;
    //C     READ CARDS USING CIMAGE                                           M39.3540
    cimage(cmn);
    {
      read_loop rloop(abuff(1), format_3421);
      rloop, iphase;
      FEM_DO_SAFE(ki, k1, k2) {
        rloop, zk(ki);
      }
    }
    if (k == 1 || k == 3) {
      goto statement_555;
    }
    goto statement_560;
    statement_555:
    cimage(cmn);
    read(abuff, "(i16)"), n19;
    statement_560:;
  }
  //C     READ CARDS USING CIMAGE                                           M39.3549
  cimage(cmn);
  read(abuff, "(e16.0)"), vref;
  vref = vref * 2.0f;
  vflash = zk(16) * vref;
  if (vflash > (1.5f * vref)) {
    vflash = -100.f;
  }
  if (vflash == 0.0f) {
    vflash = -100.f;
  }
  if (zk(11) == zk(3) && zk(7) == zk(15)) {
    vflash = -100.f;
  }
  vzero7 = zk(4);
  write(lunit7, format_3422), vref, vflash, vzero7;
  write(lunit6, format_3423), vref, vflash, vzero7;
  {
    write_loop wloop(cmn, lunit7, format_3422);
    FEM_DO_SAFE(L, 1, 3) {
      wloop, zk(L);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3423);
    FEM_DO_SAFE(L, 1, 3) {
      wloop, zk(L);
    }
  }
  if (zk(7) == vstart) {
    goto statement_570;
  }
  {
    write_loop wloop(cmn, lunit7, format_3422);
    FEM_DO_SAFE(L, 5, 7) {
      wloop, zk(L);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3423);
    FEM_DO_SAFE(L, 5, 7) {
      wloop, zk(L);
    }
  }
  statement_570:
  write(lunit7, format_3424);
  write(lunit6, format_3425);
  //C     CHECK WHETHER GAPLESS ARRESTER ********************************** M39.3569
  if (vflash < 0.0f) {
    goto statement_590;
  }
  {
    write_loop wloop(cmn, lunit7, format_3422);
    FEM_DO_SAFE(L, 9, 11) {
      wloop, zk(L);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3423);
    FEM_DO_SAFE(L, 9, 11) {
      wloop, zk(L);
    }
  }
  if (zk(11) == zk(15)) {
    goto statement_580;
  }
  {
    write_loop wloop(cmn, lunit7, format_3422);
    FEM_DO_SAFE(L, 13, 15) {
      wloop, zk(L);
    }
  }
  {
    write_loop wloop(cmn, lunit6, format_3423);
    FEM_DO_SAFE(L, 13, 15) {
      wloop, zk(L);
    }
  }
  statement_580:
  write(lunit7, format_3424);
  write(lunit6, format_3425);
  statement_590:
  iarest = iarest - 1;
  if (iarest > 0) {
    goto statement_500;
  }
  //C     CHECK FOR 'BEGIN NEW DATA CASE' ********************************* M39.3580
  //C     READ CARDS USING CIMAGE                                           M39.3581
  statement_600:
  cimage(cmn);
  read(abuff, format_3417), text;
  write(cbuff, format_3417), text;
  if (cbuff(1, 7) == "BEGIN N") {
    goto statement_620;
  }
  goto statement_600;
  statement_620:
  noutpr = noup;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
over42(
  common& cmn) try
{
  common_read read(cmn);
  common_write write(cmn);
  const auto& abuff = cmn.abuff;
  double& twopi = cmn.twopi;
  double& fltinf = cmn.fltinf;
  auto& flstat = cmn.flstat;
  auto& lunit7 = cmn.lunit7;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  auto& lstat = cmn.lstat;
  int& lastov = cmn.lastov;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  //
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int maxpt = fem::int0;
  double pi = fem::double0;
  double picon = fem::double0;
  int i = fem::int0;
  arr_1d<90, double> sss(fem::fill0);
  double d1 = fem::double0;
  double sq2 = fem::double0;
  int n = fem::int0;
  double freq = fem::double0;
  double vbase = fem::double0;
  double pbase = fem::double0;
  int ipnch = fem::int0;
  int kthird = fem::int0;
  double d11 = fem::double0;
  arr_1d<101, double> flux(fem::fill0);
  arr_1d<101, double> currr(fem::fill0);
  double omegah = fem::double0;
  double vfact = fem::double0;
  double cfact = fem::double0;
  double dltat = fem::double0;
  double slope1 = fem::double0;
  double c1old = fem::double0;
  double vold = fem::double0;
  double c1 = fem::double0;
  double v = fem::double0;
  double slope2 = fem::double0;
  double psiold = fem::double0;
  int j = fem::int0;
  int L = fem::int0;
  double d2 = fem::double0;
  double y = fem::double0;
  double check = fem::double0;
  double tee = fem::double0;
  double dflux = fem::double0;
  double cnew = fem::double0;
  double ratio = fem::double0;
  double oldc = fem::double0;
  double oldf = fem::double0;
  double a1 = fem::double0;
  double a2 = fem::double0;
  double a3 = fem::double0;
  int k = fem::int0;
  int m = fem::int0;
  double psi = fem::double0;
  int n1 = fem::int0;
  double bb = fem::double0;
  double cc = fem::double0;
  double xx = fem::double0;
  double bbb = fem::double0;
  static const char* format_45 = "('+(I, V) POINT.',2x,2e13.5)";
  static const char* format_4568 = "('  \"EXIT  MODULE OVER42.\"')";
  static const char* format_504 = "(i10,2f30.10)";
  static const char* format_505 = "(2e16.8)";
  static const char* format_82 =
    "(/,' ********************************************************************"
    "****************************************************',/,1x)";
  //C     THE FOLLOWING LIMIT CHECKS OVERFLOW OF  CURR, FLUX                   15668
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER42.\"')");
  }
  maxpt = 101;
  pi = twopi / 2.0f;
  picon = pi / 180.f;
  FEM_DO_SAFE(i, 1, 90) {
    sss(i) = sinz(i * picon);
  }
  d1 = 2.0f;
  sq2 = sqrtz(d1) * 1000.f;
  //C     CHECK FOR "CONVERT ZNO" CONNECTION OF "REQUES" (OVERLAY 1):       M39.3405
  if (cmn.iofbnd != 99876) {
    goto statement_5;
  }
  zinold(cmn);
  goto statement_9200;
  statement_5:
  n = 1;
  //C     READ INPUT CARD USING CIMAGE                                         15676
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_2103;
  }
  read(abuff, "(3e8.0,2i8)"), freq, vbase, pbase, ipnch, kthird;
  goto statement_2105;
  statement_2103:
  nfrfld = 1;
  freone(cmn, freq);
  freone(cmn, vbase);
  freone(cmn, pbase);
  freone(cmn, d11);
  ipnch = d11;
  freone(cmn, d11);
  kthird = d11;
  if (kill > 0) {
    goto statement_9200;
  }
  statement_2105:
  if (freq == 0.0f) {
    goto statement_2050;
  }
  if (freq != 88.f) {
    goto statement_7219;
  }
  //C     CONNECT WITH ROUTINE WRITTEN BY PROF. NED MOHAN OF THE            M25.1222
  //C     UNIVERSITY OF MINNESOTA.   THIS GENERATES THE CURRENT             M25.1223
  //C     VS. FLUX POINTS NEEDED FOR  TYPE-96  HYSTERETIC INDUCTOR          M25.1224
  //C     MODELING.                                                         M25.1225
  write(kunit6, "('+FREQ=88 REQUESTS HYSTERESIS DATA.')");
  hysdat(cmn);
  if (kill > 0) {
    goto statement_9200;
  }
  goto statement_5;
  statement_7219:
  if (freq != 77.f) {
    goto statement_7228;
  }
  //C     CONNECT WITH ROUTINE WRITTEN BY DR. VLADIMIR BRANDWAJN            M27.3440
  //C     OF ONTARIO HYDRO.  THIS GENERATES EMTP DATA CARDS FOR             M27.3441
  //C     ZNO  SURGE ARRESTERS USING LEAST SQUARES FITTING.                 M27.3442
  write(kunit6, "('+FREQ=77 REQUESTS  ZNO  DATA GENERATOR.')");
  arrdat(cmn);
  if (kill > 0) {
    goto statement_9200;
  }
  goto statement_5;
  statement_7228:
  write(kunit6, "('+MISC. CONST.',2x,3e10.3,i5)"), freq, vbase, pbase, ipnch;
  if (freq ==  - 1.f) {
    goto statement_19;
  }
  if (vbase > 0.0f) {
    goto statement_18;
  }
  statement_16:
  kill = 90;
  flstat(14) = vbase;
  flstat(15) = pbase;
  lstat(19) = 16;
  goto statement_9200;
  statement_18:
  if (pbase <= 0.0f) {
    goto statement_16;
  }
  flux(1) = 0.0f;
  currr(1) = 0.0f;
  omegah = twopi * freq;
  vfact = sq2 * vbase / omegah;
  cfact = pbase * 1000.0f / vbase;
  dltat = picon;
  slope1 = fltinf;
  c1old = 0.0f;
  vold = 0.0f;
  goto statement_20;
  statement_19:
  if (pbase <= 0.0f) {
    pbase = 1.0f;
  }
  if (vbase <= 0.0f) {
    vbase = 1.0f;
  }
  vfact = pbase;
  cfact = vbase;
  c1old = -1.0f / fltinf;
  n = 0;
  //C     READ INPUT CARD USING CIMAGE                                         15699
  statement_20:
  cimage(cmn);
  if (kolbeg > 0) {
    goto statement_2113;
  }
  read(abuff, "(2e16.0)"), c1, v;
  goto statement_2115;
  statement_2113:
  nfrfld = 1;
  freone(cmn, c1);
  if (c1 == 9999.f) {
    goto statement_2115;
  }
  freone(cmn, v);
  if (kill > 0) {
    goto statement_9200;
  }
  statement_2115:
  if (c1 == 9999.f) {
    goto statement_100;
  }
  if (freq > 0.0f) {
    goto statement_41;
  }
  write(kunit6, "('+(I, L) POINT.',2x,2e13.5)"), c1, v;
  goto statement_49;
  statement_41:
  write(kunit6, format_45), c1, v;
  statement_49:
  n++;
  if (n <= maxpt) {
    goto statement_70;
  }
  kill = 69;
  lstat(12) = maxpt;
  lstat(19) = 70;
  goto statement_9200;
  statement_70:
  if (freq > 0.0f) {
    goto statement_74;
  }
  if (c1 <= c1old) {
    goto statement_75;
  }
  if (v <= 0.0f) {
    goto statement_75;
  }
  goto statement_90;
  statement_74:
  if (v > vold) {
    goto statement_80;
  }
  statement_75:
  lstat(12) = n - 1;
  flstat(13) = c1;
  flstat(14) = c1old;
  flstat(15) = v;
  flstat(16) = vold;
  kill = 71;
  lstat(19) = 75;
  goto statement_9200;
  statement_80:
  if (c1 <= c1old) {
    goto statement_75;
  }
  slope2 = (v - vold) / (c1 - c1old);
  if (slope1 >= slope2) {
    goto statement_90;
  }
  write(lunit6, format_82);
  write(lunit6,
    "(' WARNING.  THE LAST DATA POINT CAUSES THE V-I CURVE TO DEVIATE FROM THE"
    " EXPECTED CONVEX FORM.  THAT IS THE SLOPE',/,"
    "' OF THIS SECTION IS GREATER THAN THAT OF THE PREVIOUS SECTION.  ALTHOUGH"
    " THIS IS NOT CONSIDERED AN ERROR, THIS',/,"
    "' CONDITION WARRENTS DOUBLE CHECKING THE DATA FOR ACCURACY.')");
  write(lunit6, format_82);
  statement_90:
  slope1 = slope2;
  c1old = c1;
  vold = v;
  flux(n) = v * vfact;
  currr(n) = c1 * cfact;
  goto statement_20;
  statement_100:
  if (n > 1) {
    goto statement_1784;
  }
  if (freq < 0.0f) {
    goto statement_1784;
  }
  write(kunit6, format_45), c1, v;
  write(lunit6,
    "(' PROBLEM ----- THE VERY FIRST POINT OF THE CHARACTERISTIC HAS JUST BEEN"
    " READ, AND IT HAS BEEN OBSERVED THAT THIS',/,15x,"
    "'HAS VOLTAGE EQUAL TO ZERO.   THIS IS ILLEGAL.   THE FIRST SECTION OF THE"
    " CURVE MUST HAVE POSITIVE SLOPE,',/,15x,"
    "'AND THE ORIGIN (I=0, V=0) IS AN IMPLIED POINT, NOT TO BE INPUTTED BY THE"
    " USER.   THE EMTP WILL DISCARD THE',/,15x,"
    "'JUST-READ CARD, AND BEGIN READING THE CHARACTERISTIC POINTS ONCE AGAIN, "
    "UNDER THE ASSUMPTION THAT THE USER',/,15x,"
    "'HAS OVERLOOKED THIS MINOR DETAIL.   TALK ABOUT A FORGIVING PROGRAM (SOME"
    "TIMES).')");
  goto statement_20;
  statement_1784:
  write(kunit6, "('+SPECIAL TERMINATION-OF-POINTS CARD.')");
  interp();
  write(lunit6,
    "(/,' DERIVED SATURATION CURVE GIVING PEAK CURRENT VS. FLUX',/,7x,'ROW',"
    "17x,'CURRENT (AMP)',15x,'FLUX (VOLT-SEC)')");
  if (freq > 0.0f) {
    goto statement_195;
  }
  psiold = 0.0f;
  if (n >= 2) {
    goto statement_124;
  }
  write(lunit6,
    "(/,/,"
    "' NOTE. ---- THE JUST-READ CURRENT VS. INCREMENTAL INDUCTANCE CHARACTERIS"
    "TIC DOES NOT CONTAIN TWO OR MORE',/,12x,"
    "'POINTS.   NO CURVE IS THUS DEFINED, AND THE EMTP CAN NOT INTEGRATE INDUC"
    "TANCE TO PRODUCE FLUX.   THIS',/,12x,"
    "'''SATURATION''  DATA CASE IS THUS BEING ABORTED IN OVERLAY 42, AND CONTR"
    "OL WILL PASS ON TO READ THE NEXT',/,12x,"
    "'SUCH  ''SATURATION''  DATA CASE.',/,/,1x)");
  goto statement_5;
  statement_124:
  if (currr(1) == 0.0f) {
    goto statement_138;
  }
  d1 = flux(1) / vfact;
  write(lunit6,
    "(/,/,"
    "' WARNING. ---- THE JUST-READ CURRENT VS. INCREMENTAL INDUCTANCE CHARACTE"
    "RISTIC DOES NOT BEGIN WITH A POINT FOR',/,15x,"
    "'ZERO CURRENT.   THIS MISSING POINT IS BEING AUTOMATICALLY SUPPLIED BY TH"
    "E EMTP, WITH ASSOCIATED',/,15x,"
    "'INDUCTANCE VALUE TAKEN TO EQUAL THE FIRST-INPUTED VALUE, WHICH WAS',"
    "e15.5,'  .   HAS THE USER',/,15x,"
    "'EVER SEEN SUCH AN INTELLIGENT, BENEVOLENT, CONSIDERATE, FORGIVING PROGRA"
    "M AS THIS.',/,/,1x)"),
    d1;
  FEM_DO_SAFE(j, 1, n) {
    L = n + 1 - j;
    currr(L + 1) = currr(L);
    flux(L + 1) = flux(L);
  }
  currr(1) = 0.0f;
  n++;
  statement_138:
  psiold = 0.0f;
  FEM_DO_SAFE(j, 2, n) {
    d1 = (flux(j - 1) + flux(j)) / 2.0f;
    d2 = currr(j) - currr(j - 1);
    flux(j - 1) = psiold;
    psiold += d1 * d2;
  }
  flux(n) = psiold;
  write(lunit6,
    "(10x,100('-'),/,10x,"
    "'REMEMBER.   THE JUST-COMPLETED CONVERSION BEGAN WITH A CURRENT VS. INCRE"
    "MENTAL INDUCTANCE',/,10x,"
    "'CHARACTERISTIC, DUE TO MISCELLANEOUS DATA PARAMETER  ''FREQ''  OF COLUMN"
    "S 1-8 BEING PUNCHED WITH A VALUE OF',/,10x,"
    "' -1.0  .    TRAPEZOIDAL RULE INTEGRATION OF THE INDUCTANCE CURVE WAS USE"
    "D, TO PRODUCE FLUX.',/,10x,100('-'))");
  goto statement_500;
  statement_195:
  currr(2) = currr(2) * sq2 / 1000.f;
  i = 2;
  statement_200:
  if (i >= n) {
    goto statement_500;
  }
  i++;
  y = flux(i);
  check = flux(2);
  tee = 0.0f;
  dflux = check;
  cnew = currr(2);
  ratio = cnew / check;
  oldc = 0.0f;
  oldf = 0.0f;
  a1 = 0.0f;
  a2 = 0.0f;
  a3 = 0.0f;
  k = 2;
  m = 0;
  statement_215:
  m++;
  tee += dltat;
  psi = y * sinz(tee);
  if (psi <= check) {
    goto statement_230;
  }
  k++;
  oldf = check;
  check = flux(k);
  dflux = check - oldf;
  oldc = cnew;
  cnew = currr(k);
  ratio = (cnew - oldc) / dflux;
  if (k <= i) {
    goto statement_224;
  }
  kill = 70;
  lstat(19) = 224;
  goto statement_9200;
  statement_224:
  if (k == i) {
    goto statement_350;
  }
  statement_230:
  a1 += fem::pow2((oldc + (psi - oldf) * ratio));
  goto statement_215;
  statement_350:
  cfact = oldc * 2.0f;
  vfact = fem::pow2(oldc);
  statement_310:
  a1 += vfact;
  ratio = (psi - oldf) / dflux;
  a2 += cfact * ratio;
  a3 += fem::pow2(ratio);
  if (m >= 90) {
    goto statement_400;
  }
  tee += dltat;
  m++;
  psi = y * sinz(tee);
  goto statement_310;
  statement_400:
  a1 = a1 - vfact / 2.0f - 90.0f * fem::pow2(currr(i));
  a2 = a2 - cfact * ratio / 2.0f;
  a3 = a3 - fem::pow2(ratio) / 2.0f;
  c1 = (-a2 + sqrtz(fem::pow2(a2) - 4.0f * a1 * a3)) / (2.0f * a3);
  currr(i) = oldc + c1;
  goto statement_200;
  statement_500:
  if (kthird != 1) {
    goto statement_503;
  }
  n1 = n - 1;
  FEM_DO_SAFE(j, 1, n1) {
    L = n + 1 - j;
    d1 = -currr(L);
    d2 = -flux(L);
    i = -L;
    write(lunit6, format_504), i, d1, d2;
    if (ipnch == 0) {
      write(lunit7, format_505), d1, d2;
    }
  }
  statement_503:
  FEM_DO_SAFE(i, 1, n) {
    if (i != 1) {
      goto statement_1503;
    }
    if (kthird == 1) {
      goto statement_510;
    }
    statement_1503:
    write(lunit6, format_504), i, currr(i), flux(i);
    if (i == 1) {
      goto statement_510;
    }
    if (ipnch == 0) {
      write(lunit7, format_505), currr(i), flux(i);
    }
    statement_510:;
  }
  write(lunit6, "(36x,'9999')");
  if (ipnch == 0) {
    write(lunit7, "(12x,'9999')");
  }
  if (freq ==  - 1.0f) {
    goto statement_1029;
  }
  write(lunit6,
    "(/,' CHECK OF DERIVED CURVE BY INDEPENDENT REVERSE COMPUTATION.  ASSUMING"
    " SINUSOIDAL VOLTAGE (FLUX) AT LEVEL OF EACH POINT,',/,"
    "' RMS CURRENT IS FOUND NUMERICALLY.  THIS CURVE SHOULD BE EQUAL TO THE OR"
    "IGINAL I-V POINTS INPUTTED.')");
  write(lunit6, "(2x,'ROW',5x,'CURRENT IN P.U.',5x,'VOLTAGE IN P.U.')");
  i = 1;
  bb = flux(1);
  FEM_DO_SAFE(L, 2, n) {
    cc = 0.0f;
    xx = flux(L);
    FEM_DO_SAFE(m, 1, 90) {
      v = xx * sss(m);
      if (v > bb) {
        goto statement_960;
      }
      statement_940:
      j = i - 1;
      bbb = flux(j);
      if (bbb <= v) {
        goto statement_980;
      }
      i = j;
      bb = bbb;
      goto statement_940;
      statement_960:
      i++;
      bb = flux(i);
      if (bb < v) {
        goto statement_960;
      }
      statement_980:
      a1 = (v - flux(i - 1)) * (currr(i) - currr(i - 1)) / (flux(i) -
        flux(i - 1));
      a2 = fem::pow2((currr(i - 1) + a1));
      cc += a2;
    }
    c1 = sqrtz((cc - a2 / 2.0f) / 90.0f) * vbase / (pbase * 1000.0f);
    v = flux(L) * omegah / (sq2 * vbase);
    write(lunit6, "(i5,2f20.8)"), L, c1, v;
  }
  statement_1029:
  write(lunit6, "(/,/,1x)");
  goto statement_5;
  statement_2050:
  write(kunit6, "('+BLANK CARD TERMINATING ALL SATURATION CASES.')");
  interp();
  lastov = nchain;
  nchain = 51;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
  statement_9200:
  lastov = nchain;
  nchain = 51;
  lstat(18) = 42;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  statement_99999:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

struct subr51_save
{
  arr<int> kpen;

  subr51_save() :
    kpen(dimension(20), fem::fill0)
  {}
};

void
subr51(
  common& cmn) try
{
  FEM_CMN_SVE(subr51);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& bus6 = cmn.bus6;
  auto& texcol = cmn.texcol;
  const auto& abuff = cmn.abuff;
  double& t = cmn.t;
  auto& flstat = cmn.flstat;
  int& nfrfld = cmn.nfrfld;
  auto& ipntv = cmn.ipntv;
  auto& lstat = cmn.lstat;
  int& lastov = cmn.lastov;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  //
  arr_ref<int> kpen(sve.kpen, dimension(20));
  if (is_called_first_time) {
    kpen(1) = 50;
    kpen(2) = 90;
    kpen(3) = 150;
    kpen(4) = 200;
  }
  int ia = fem::int0;
  auto& lunit6 = cmn.lunit6;
  double vmin = fem::double0;
  double vmax = fem::double0;
  int i = fem::int0;
  int j = fem::int0;
  double d1 = fem::double0;
  int ksat = fem::int0;
  static const char* format_5316 =
    "(' ----------------------------------------------------------------------"
    "-------------------------------------------------------------')";
  static const char* format_7115 =
    "(5x,'THIS IS PROBABLY A PROGRAM BUG, NOT THE FAULT OF THE USER.   GO SEEK"
    " HELP FROM PROGRAM MAINTENANCE ABOUT THIS.')";
  static const char* format_7131 =
    "(5x,'CHECK NAME(S) FOR SPELLING, AS WELL AS THE COLUMN-POSITIONING OF ANY"
    " BLANKS IN THE FIELD(S) WHICH IS(ARE)',/,5x,'SIX CHARACTERS WIDE.')";
  static const char* format_7138 =
    "(5x,'REST OF THE NETWORK.   IF ACTUALLY DISCONNECTED, USER SHOULD ADD A C"
    "ONNECTING BRANCH.   IF CONNECTED BY A VERY-HIGH-',/,5x,"
    "'IMPEDANCE BRANCH, EITHER MAKE  EPSILN  NEARER TO ZERO, OR DECREASE THE I"
    "MPEDANCE OF THE CONNECTION.',/,5x,"
    "'BUT BE CAREFUL IN RESORTING TO A SMALLER ''EPSILN'', AS NUMERICAL SOLUTI"
    "ON DIFFICULTY WILL INEVITABLY RESULT AS',/,5x,"
    "'''EPSILN'' APPROACHES THE COMPUTER ROUNDOFF LIMIT (DETERMINED BY COMPUTE"
    "R WORD-SIZE).   THE USER IS ADVISED TO REREAD')";
  static const char* format_7139 =
    "(5x,'WHILE THE PROBLEM MAY BE WELL-POSED PHYSICALLY, THE PRESENT EMTP SOL"
    "UTION ASSUMPTIONS CONCERNING THE USE OF',/,5x,"
    "'COMPENSATION CANNOT HANDLE SUCH A CASE.   TO REMEDY THIS DILEMA, THE USE"
    "R HAS TWO GENERAL POTENTIAL COURSES OF',/,5x,'ACTION ....',/,8x,"
    "'1) ELIMINATE THE OFFENDING NONLINEAR OR TIME-VARYING ELEMENT(S).   IF TH"
    "E OFFENDING ELEMENTS ARE NONLINEAR',/,11x,"
    "'RATHER THAN TIME-VARYING, USE MIGHT BE MADE OF SWITCHED OR PSEUDO-NONLIN"
    "EAR ELEMENTS OF THE SAME TYPE.')";
  static const char* format_7142 =
    "(5x,'MATRIX  (YAA)  IS THE FIRST-PARTITION DIAGONAL SUBMATRIX AMONG NON-S"
    "WITCH (OR PSEUDO-NONLINEAR-ELEMENT)',/,5x,"
    "'NODES WHICH IS TO BE TRIANGULARIZED ONCE AND FOR ALL OUTSIDE OF THE TIME"
    "-STEP LOOP.')";
  static const char* format_7239 =
    "(11x,"
    "'WHILE THIS CONVERTS TRUE NONLINEARITIES TO PSEUDO-NONLINEARITIES WHICH I"
    "NHERENTLY LAG ONE TIME STEP',/,11x,"
    "'BEHIND THE SOLUTION (AND THUS MUST BE USED WITH CAUTION TO ENSURE THAT M"
    "OVEMENT ALONG THE DESIRED CHARACTERISTIC',/,11x,"
    "'IS SLOW), ONE DOES AVOID ALL ISOLATION PROBLEMS ASSOCIATED WITH COMPENSA"
    "TION.',/,8x,"
    "'2) INTRODUCE SUFFICIENT STUB LINES (SMALL SERIES-INDUCTANCE ELEMENTS WHI"
    "CH ARE REPRESENTED BY LOSSLESS DISTRIBUTED-',/,11x,"
    "'PARAMETER LINES HAVING TRAVEL-TIME EQUAL TO THE TIME-STEP-SIZE ''DELTAT'"
    "') TO ISOLATE THE INTERFERING ELEMENTS.')";
  static const char* format_7338 =
    "(5x,'THE PROGRAM THINKS THAT EITHER THE NODE IN QUESTION, OR A SUBNETWORK"
    " TO WHICH IT BELONGS, IS DISCONNECTED FROM THE')";
  static const char* format_7339 =
    "(11x,"
    "'IF ''DELTAT'' IS SMALL ENOUGH, SUCH ADDED ELEMENTS MAY NOT SERIOUSLY DIS"
    "TURB THE PROBLEM PHYSICALLY, WHILE',/,11x,"
    "'PROVIDING THE NEEDED ISOLATION.',/,5x,"
    "'AS BOTH OF THESE REMEDIES ARE POTENTIALLY DANGEROUS IF NOT USED WITH CON"
    "SIDERABLE CAUTION AND UNDERSTANDING, IT',/,5x,"
    "'IS SUGGESTED THAT THE USER APPLY SOME THOUGHT TO THE MATTER WHILE STUDYI"
    "NG THE USER''S MANUAL ABOUT THESE QUESTIONS.',/,5x,"
    "'A CALL TO PROGRAM MAINTENANCE FOR SOME PROFESSIONAL ADVICE MIGHT ALSO BE"
    " APPROPRIATE, IF IN DOUBT.')";
  static const char* format_7438 =
    "(5x,'THE EMTP USER''S MANUAL EXPLANATION OF THE SIGNIFICANCE OF ''EPSILN'"
    "', SHOULD HE BE IN DOUBT.   A CALL TO PROGRAM',/,5x,"
    "'MAINTENANCE MIGHT ALSO BE IN ORDER, IN THIS CASE.')";
  static const char* format_8943 = "(' EXIT \"SUBR51\".  NCHAIN, KILL =',2i6)";
  //C     NOTE. --- AS THE STRUCTURE OF THE EMTP ERROR OVERLAYS CHANGE,     M39.3638
  //C               THE FOLLOWING ASSIGNMENTS MAY HAVE TO BE ALTERED ...    M39.3639
  //C                    NFRFLD  ---- TOTAL NUMBER OF ERROR OVERLAYS        M39.3640
  //C                    KPEN(J) ---- STORAGE FOR THE HIGHEST KILL-CODE     M39.3641
  //C                                 NUMBER HANDLED BY ERROR OVERLAY       M39.3642
  //C                                 NUMBER  50+J ,   FOR ALL BUT THE      M39.3643
  //C                                 LAST ERROR OVERLAY.                   M39.3644
  ia = lstat(52);
  nfrfld = 5;
  if (iprsup >= 1) {
    write(lunit6, "(' BEGIN \"SUBR51\".  KILL =',i8)"), kill;
  }
  if (kill == 99 && lstat(19) == 11111) {
    stoptp(cmn);
  }
  kpen(nfrfld) = cmn.intinf;
  runtym(vmin, vmax);
  flstat(9) = vmin - flstat(9);
  if (ipntv(1) !=  - 8888) {
    goto statement_1643;
  }
  //C     FOLLOWING ASSIGNMENTS ARE TO DEFINE EXCEPTIONAL /BLANK/           M32,2235
  //C     VARIABLES USED IN  "KILL CODES"  USAGE:                           M32,2236
  if (kill == 38) {
    flstat(12) = 1.0f;
  }
  if (kill == 41) {
    lstat(10) = 1;
  }
  if (kill == 43) {
    flstat(12) = 1.f;
  }
  if (kill - 1 != ipntv(3)) {
    goto statement_1643;
  }
  ipntv(3) = kill;
  goto statement_1649;
  statement_1643:
  if (lastov >= nchain) {
    goto statement_1649;
  }
  cmn.noutpr = 0;
  interp();
  write(lunit6, "(' ')");
  write(lunit6, format_5316);
  FEM_DO_SAFE(i, 1, 2) {
    write(lunit6,
      "(' ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ER"
      "ROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR')");
  }
  write(lunit6, format_5316);
  if (cmn.m4plot == 1) {
    goto statement_5534;
  }
  write(lunit6,
    "('0YOU LOSE, FELLA.   THE EMTP LOGIC HAS DETECTED AN ERROR CONDITION, AND"
    " IS GOING TO TERMINATE YOUR RUN.  THE FOLLOWING',/,"
    "' PRINTOUT MESSAGE SUMMARIZES THE DATA DIFFICULTY LEADING TO THIS PROGRAM"
    " DECISION.  BY STUDYING THIS MESSAGE, THE PROBLEM',/,"
    "' DATA,  AND THE RULES DELINEATED BY THE  840-PAGE EMTP RULE BOOK,  IT IS"
    " HOPED THAT THE USER CAN RECTIFY THE PROBLEM. ',/,"
    "' IF STILL IN DOUBT AFTER SOME STUDY, COME SEE PROGRAM MAINTENANCE FOR AS"
    "SISTANCE.')");
  {
    read_loop rloop(abuff(1), "(13a6,a2)");
    FEM_DO_SAFE(j, 1, 14) {
      rloop, texcol(j);
    }
  }
  {
    write_loop wloop(cmn, lunit6,
      "(' WHERE AN OTHERWISE-UNIDENTIFIED CARD IS REFERRED TO, OR IS CALLED TH"
      "E ''LAST'' CARD, THIS MEANS THE MOST-RECENTLY-',/,"
      "' READ CARD OF THE INPUT DATA DECK.   THE 80-COLUMN CARD IMAGE IN QUEST"
      "ION IS THE LAST ONE PRINTED OUT BEFORE THIS',/,"
      "' TERMINATION MESSAGE.   A COPY FOLLOWS....',13a6,a2)");
    FEM_DO_SAFE(j, 1, 14) {
      wloop, texcol(j);
    }
  }
  statement_5534:
  write(lunit6,
    "(14x,'KILL CODE NUMBER',16x,'OVERLAY NUMBER',10x,'NEARBY STATEMENT NO.',"
    "/,3i30)"),
    kill, lstat(18), lstat(19);
  statement_1649:
  FEM_DO_SAFE(j, 1, nfrfld) {
    if (kill > kpen(j)) {
      goto statement_1658;
    }
    if (j == 1) {
      goto statement_1684;
    }
    lastov = nchain;
    nchain = 50 + j;
    if (iprsup >= 1) {
      write(lunit6,
        "(' ERROR OVERLAY FOUND.','   KILL, J, KPEN(J), NCHAIN =',4i8)"),
        kill, j, kpen(j), nchain;
    }
    goto statement_9000;
    statement_1658:;
  }
  statement_1684:
  switch (kill) {
    case 1: goto statement_6001;
    case 2: goto statement_6002;
    case 3: goto statement_6003;
    case 4: goto statement_6004;
    case 5: goto statement_6005;
    case 6: goto statement_6006;
    case 7: goto statement_6007;
    case 8: goto statement_6008;
    case 9: goto statement_6009;
    case 10: goto statement_6010;
    case 11: goto statement_6011;
    case 12: goto statement_6012;
    case 13: goto statement_6013;
    case 14: goto statement_6014;
    case 15: goto statement_6015;
    case 16: goto statement_6016;
    case 17: goto statement_6017;
    case 18: goto statement_6018;
    case 19: goto statement_6019;
    case 20: goto statement_6020;
    case 21: goto statement_6021;
    case 22: goto statement_6022;
    case 23: goto statement_6023;
    case 24: goto statement_6024;
    case 25: goto statement_6025;
    case 26: goto statement_6026;
    case 27: goto statement_6027;
    case 28: goto statement_6028;
    case 29: goto statement_6029;
    case 30: goto statement_6030;
    case 31: goto statement_6031;
    case 32: goto statement_6032;
    case 33: goto statement_6033;
    case 34: goto statement_6034;
    case 35: goto statement_6035;
    case 36: goto statement_6036;
    case 37: goto statement_6037;
    case 38: goto statement_6038;
    case 39: goto statement_6039;
    case 40: goto statement_6040;
    case 41: goto statement_6041;
    case 42: goto statement_6042;
    case 43: goto statement_6043;
    case 44: goto statement_6044;
    case 45: goto statement_6045;
    case 46: goto statement_6046;
    case 47: goto statement_6047;
    case 48: goto statement_6048;
    case 49: goto statement_6049;
    case 50: goto statement_6050;
    default: break;
  }
  statement_6001:
  write(lunit6,
    "(5x,'STORAGE EXCEEDED FOR LIST NUMBER ',i2,"
    "'.   SEE DIMENSIONED LIMIT IN TABULATION BELOW.',/,5x,"
    "'THE PROBLEM BEING INPUTTED IS SIMPLY TOO BIG FOR THE PROGRAM AS CURRENTL"
    "Y DIMENSIONED.   SINCE THERE USUALLY ARE',/,5x,"
    "'WAYS OF CIRCUMVENTING THIS DIFFICULTY, IT IS SUGGESTED THAT THE USER CON"
    "SULT HIS FRIENDLY NEIGHBORHOOD PROGRAM',/,5x,'MAINTENANCE MAN.')"),
    lstat(16);
  goto statement_6220;
  statement_6002:
  if (t < 0.0f) {
    goto statement_7102;
  }
  write(lunit6,
    "(5x,'TIME-STEP SIZE ''DELTAT'' AS READ FROM COLUMNS 1-8 OF THE FIRST MISC"
    "ELLANEOUS DATA CARD IS NOT POSITIVE.   THE',/,5x,"
    "'USER PUNCHED A VALUE OF',e14.4,"
    "'.   UNLIKE JULES VERNE, YOU ARE NOT ALLOWED TO STOP OR DECREASE TIME DUR"
    "ING',/,5x,"
    "'A SIMULATION, MY FRIEND.   DON''T TRY RIDING OUT OF AN ACTIVE VOLCANO ON"
    " A RAFT FLOATING ON MOLTEN LAVA, EITHER,',/,5x,"
    "'ALTHOUGH THAT''S ANOTHER STORY.')"),
    flstat(16);
  goto statement_6220;
  statement_7102:
  write(lunit6,
    "(5x,'THE STARTING TIME   ''T''   AS READ FROM THE FLOATING-POINT MISCELLA"
    "NEOUS DATA CARD IS NEGATIVE, WHICH IS',/,5x,'ILLEGAL.   A VALUE OF',"
    "e15.5,'   WAS READ FROM THE DATA FIELD OF COLUMNS 49-56.')"),
    t;
  goto statement_6220;
  statement_6003:
  write(lunit6,
    "(5x,'ILLEGAL TYPE CODE READ FROM COLUMNS 1-2 OF LAST BRANCH CARD.   THE U"
    "SER PUNCHED A VALUE OF ',i2,'.   EITHER',/,5x,"
    "'THE PUNCHED NUMBER ITSELF IS PATENTLY ILLEGAL (ALWAYS AN ERROR, UNDER AN"
    "Y CIRCUMSTANCES), OR THE CARD IN QUESTION',/,5x,"
    "'IS OUT OF SEQUENCE IN RELATION TO THE PRECEDING DATA CARD WHICH WAS INPU"
    "TTED.   AS AN EXAMPLE OF THE LATTER',/,5x,"
    "'CASE, CONSIDER A ''-3'' PUNCH, WITH THE PRECEEDING CARD NOT BEARING A ''"
    "-2'' PUNCH.   IN ANY CASE, OPEN UP THE USER''S',/,5x,"
    "'MANUAL, AND REREAD THE RULES FOR THE DATA TYPE THAT YOU HAVE BEEN TRYING"
    " TO INPUT, MY FRIEND.')"),
    lstat(16);
  write(lunit6,
    "(5x,'YET, IN CASE THIS GENERAL ADVICE DOES NOT SEEM TO APPLY, CONSIDER TH"
    "E POSSIBLE TROUBLE WHICH CAN ARISE FROM A',/,5x,"
    "'PRECEDING FAULTY USE OF THE REFERENCE-BRANCH CAPABILITY.   THIS FEATURE "
    "HAS THE EMTP LOOKING FOR A CERTAIN NUMBER',/,5x,"
    "'AND TYPE OF BRANCH CARDS, BASED ON PROPERTIES OF THE COMPONENT TO WHICH "
    "REFERENCE HAS BEEN MADE.   IF THE USER''S',/,5x,"
    "'DATA CARDS DO NOT IN STRUCTURE MATCH THOSE OF THE REFERENCE COMPONENT, A"
    "N ERROR STOP OF THE PRESENT TYPE MAY VERY')");
  write(lunit6,
    "(5x,'BE EXPECTED.   REMEMBER THAT IN CASES WHERE TWO OR MORE BRANCHES FRO"
    "M REFERENCE BUS  ''BUS3''  TO REFERENCE BUS',/,5x,"
    "'''BUS4''  (ORDERED PAIR OF NAMES, READ FROM COLUMNS 15-24 AS  2A6  INFOR"
    "MATION) EXIST, THE EMTP WILL ALWAYS PICK',/,5x,"
    "'THE FIRST ONE THAT IT FINDS (IN ORDER OF BRANCH INPUT) FOR REFERENCE PUR"
    "POSES.')");
  goto statement_6220;
  statement_6004:
  write(lunit6,
    "(5x,'LAST BRANCH WAS ZERO IMPEDANCE (R, L, C FIELDS OF COLUMNS 27-44 WERE"
    " ALL ZERO).   IF YOU REALLY WANT A SHORT',/,5x,"
    "'CIRCUIT, YOU MUST PUNCH A VERY SMALL VALUE FOR  R  OR  L.   OR BETTER YE"
    "T, WHY NOT DO AWAY WITH ONE OF THE NODE',/,5x,"
    "'NAMES OF THIS BRANCH, TREATING BOTH ENDS AS THE SAME BUS (A PERFECT SHOR"
    "T CIRCUIT).')");
  goto statement_6220;
  statement_6005:
  write(lunit6,
    "(5x,'THE USER HAS BEEN INPUTTING PAIRS OF POINTS WHICH DEFINE A NONLINEAR"
    " (OR PSEUDO-NONLINEAR) ELEMENT CHARACTERISTIC.',/,5x,"
    "'THESE MUST BE IN ORDER, MOVING EVER TO THE RIGHT AND UPWARD IN THE X-Y P"
    "LANE.   BUT THE USER''S JUST-INPUTTED')");
  write(lunit6,
    "(5x,'CHARACTERISTIC IS NOT MONOTONE INCREASING AS IT SHOULD BE.   A DECRE"
    "ASE IN ONE OF THE TWO COORDINATE POINTS',/,5x,"
    "'HAS BEEN DETECTED ON THE LAST DATA CARD WHICH WAS READ.   SHAPE UP OR SH"
    "IP OUT, JACK.')");
  goto statement_6220;
  statement_6006:
  write(lunit6,
    "(5x,'REFERENCE BRANCH NAMES OF LAST DATA CARD DO NOT REFER TO PREVIOUSLY-"
    "INPUTTED BRANCH OF SAME TYPE.   THE DATA BEING',/,5x,"
    "'REFERENCED CAN NOT BE FOUND.   CHECK FOR SPELLING ERRORS, OR POSITION DI"
    "FFERENCES OF BLANKS WITHIN THE FIELD WIDTHS.',/,5x,"
    "'DEFECTIVE NAMES AS READ OFF CARD FROM COLUMNS 15-26 WERE ''',a6,"
    "''' AND ''',a6,'''.')"),
    bus3, bus4;
  goto statement_6220;
  statement_6007:
  write(lunit6,
    "(5x,'AN ILLEGAL TYPE CODE HAS BEEN READ FROM COLUMNS 1-2 OF THE LAST DATA"
    " CARD, WHICH THE EMTP BELIEVES TO BE A',/,5x,"
    "'SWITCH CARD.   THE EMTP READ A VALUE OF ',i2,"
    "'.   BUT SUCH A VALUE CANNOT BE ACCEPTED, SINCE',/,5x,"
    "'ONLY TYPE CODES  0 (ORDINARY SWITCH),  92 (',"
    "'SWITCHED RESISTANCE),  93 (SWITCHED INDUCTANCE),',/,5x,"
    "'  11 (DIODE AND TACS-CONTROLLED VALVE),  12 (',"
    "'TACS-CONTROLLED SPARK GAP OR TRIAC)',/,5x,"
    "'AND  13 (TACS-CONTROLLED ORDINARY SWITCH)  ARE',' ALLOWED. ')"),
    lstat(16);
  goto statement_6220;
  statement_6008:
  write(lunit6,
    "(5x,'AN ERROR IN THE ORDERING OF SWITCH CARDS HAS OCCURED.   ALL SWITCHED"
    "-RESISTANCE ELEMENTS (TYPE-92) MUST PRECEDE',/,5x,"
    "'ANY SWITCHED-INDUCTANCE (TYPE-93) ELEMENTS.   THE LAST DATA CARD WHICH H"
    "AS BEEN READ VIOLATES THIS RULE.',/,5x,'GET WITH IT, GUY, SHAPE UP.')");
  goto statement_6220;
  statement_6009:
  write(lunit6,
    "(5x,'THE LAST DATA CARD WHICH WAS READ HAS BEEN TAKEN BY THE EMTP TO BE A"
    " SWITCHED-INDUCTANCE ELEMENT.')");
  write(lunit6,
    "(5x,'BUT THIS COMPONENT  HAS SATURATION (BREAKPOINT) FLUX NONPOSITIVE, WH"
    "ICH IS ABSURD.   FROM COLUMNS 45-54, THE',/,5x,'PROGRAM READ THE VALUE',"
    "e12.3,' FROM THE LAST DATA CARD.')"),
    flstat(16);
  goto statement_6220;
  statement_6010:
  write(lunit6,
    "(5x,'THE LAST DATA CARD WHICH WAS READ HAS BEEN TAKEN TO BE A SOURCE CARD"
    ".   BUT IT BEARS AN ILLEGAL TYPE CODE',/,5x,"
    "'IN COLUMNS 1-2 (A VALUE OF ',i2,"
    "' WAS READ).   OPEN UP THE USER''S MANUAL, AND REREAD THE RULES FOR SOURC"
    "E CARDS.')"),
    lstat(16);
  goto statement_6220;
  statement_6011:
  write(lunit6,
    "(5x,'TYPE-16 CONTROLLED DC VOLTAGE SOURCE CARD HAS ILLEGAL INITIAL CONDIT"
    "ION CODE IN COLUMNS 9-10.',/,5x,'THE VALUE READ WAS ',i2)"),
    lstat(16);
  goto statement_6220;
  statement_6012:
  write(lunit6,
    "(5x,'THE BUS NAME READ FROM COLUMNS 3-8 OF THE LAST SOURCE CARD IS UNRECO"
    "GNIZABLE, NOT HAVING BEEN PREVIOUSLY',/,5x,"
    "'DEFINED BY A BRANCH CARD OR A SWITCH CARD.   THE NAME READ FROM THE CARD"
    " IS ''',a6,'''.   THE USER IS NOT',/,5x,"
    "'ALLOWED TO CONNECT SOURCES TO NETWORK NODES WHICH ARE NOT A PART OF THE "
    "NETWORK PREVIOUSLY DEFINED BY BRANCH AND',/,5x,"
    "'SWITCH CARDS OF THIS DATA CASE.   AFTER ALL, SUCH NODES WOULD BE COMPLET"
    "ELY DISCONNECTED FROM THE NETWORK, SO COULD',/,5x,"
    "'NOT AFFECT THE NETWORK SOLUTION.   MOST PROBABLY, ONE OR MORE SPELLING E"
    "RRORS HAVE BEEN MADE IN PUNCHING NODE NAMES.')"),
    bus1;
  write(lunit6, format_7131);
  goto statement_6220;
  statement_6013:
  write(lunit6, "(5x,' SIMULATOR VOLTAGE OUTSIDE LIMITS.')");
  goto statement_6220;
  statement_6014:
  write(lunit6,
    "(5x,'TYPE-93 NONLINEAR INDUCTANCE FROM ''',a6,''' TO ''',a6,"
    "''' HAS PSI-STEADY (COLUMNS 33-38) ZERO',/,5x,"
    "'WHILE I-STEADY (COLUMNS 27-32) IS NONZERO.   VALUE READ FOR I-STEADY = '"
    ",e12.3,' .',/,5x,'SUCH ZERO-IMPEDANCE BRANCHES ARE NOT PERMITTED.')"),
    bus1, bus2, flstat(16);
  goto statement_6220;
  statement_6015:
  write(lunit6,
    "(5x,'BREAKDOWN OF LOGIC IN STEADY-STATE SETUP BEFORE CALL TO SUBROUTINE N"
    "UMBER.   NEXT, II=',2i10)"),
    lstat(15), lstat(16);
  write(lunit6, format_7115);
  goto statement_6220;
  statement_6016:
  write(lunit6,
    "(5x,'ARRAYS ''KOLUM'' AND ''KORDER'' OF THE RENUMBERING CALCULATION FOR T"
    "HE STEADY-STATE NETWORK HAVE OVERFLOWED.',/,5x,"
    "'THE PROBLEM IS SIMPLY TOO BIG OR TOO DENSE (ADMITTANCE MATRIX HAS TOO MA"
    "NY NONZERO ELEMENTS) FOR THE EXISTING ARRAY',/,5x,'SIZES OF',i7,"
    "'   CELLS.   OF THE',i6,"
    "'   MATRIX ROWS TOTAL, OVERFLOW HAS OCCURRED WHILE WORKING ON THE',/,5x,"
    "'SIMULATED ELIMINATION FOR ROW',i4,"
    "'.   THIS OVERFLOW TROUBLE IS REALLY TROUBLE WITH DEPENDENT LIST ')"),
    lstat(16), cmn.ntot, lstat(15);
  write(lunit6,
    "(5x,'NUMBER 99, ABOUT WHICH AN EXPLANATION WILL FOLLOW BELOW.',/,5x,"
    "'IF THE CORE STORAGE NEEDED TO PREVENT THIS OVERFLOW CAN NOT BE SPARED, A"
    "S A LAST RESORT',/,5x,"
    "'THE USER MIGHT BYPASS THE STEADY-STATE CALCULATION COMPLETELY, AND SIMPL"
    "Y RUN IN THE TRANSIENTS MODE FOR SEVERAL')");
  write(lunit6,
    "(5x,'CYCLES, HOPING THAT BY THEN THE SOLUTION WILL HAVE SETTLED SUFFICIEN"
    "TLY INTO THE SINUSOIDAL STEADY-STATE',/,5x,"
    "'(FOLLOWING THE ENERGIZATION SHOCK WHICH OCCURS AT TIME ZERO).')");
  kill = 1;
  lstat(16) = 99;
  nchain = 51;
  if (iprsup >= 1) {
    write(lunit6, format_8943), nchain, kill;
  }
  goto statement_9000;
  statement_6017:
  write(lunit6,
    "(5x,'LOGIC BREAKDOWN IN STEADY-STATE SOLUTION AFTER RENUMBERING OF THE S."
    "S. NETWORK HAS BEEN SUCCESSFULLY COMPLETED.')");
  write(lunit6, format_7115);
  write(lunit6,
    "(5x,'BUT THEN AGAIN, MAYBE IT IS NOT',"
    "' THE FAULT OF THE EMTP.  SEVERAL YEARS',"
    "' OF EXPERIENCE WITH THIS MESSAGE HAVE',/,5x,"
    "'SHOWN THAT THE USER''S DATA WAS',"
    "' INVARIABLY ERRONEOUS, THOUGH NOT STOPPED',"
    "' AT THE TIME THE BRANCHES WERE INPUTTED.')");
  write(lunit6,
    "(5x,'FOR EXAMPLE, THERE MIGHT BE A',"
    "' BRANCH BOTH ENDS OF WHICH TOUCH NODE  ''',a6,"
    "''' ,   FOUND IN ROW NUMBER',i4,/,2x,"
    "'   OF THE BRANCH TABLE (ORDER OF INPUT).')"),
    bus1, lstat(15);
  goto statement_6220;
  statement_6018:
  write(lunit6,
    "(5x,'IN FORMING THE NETWORK ADMITTANCE MATRIX FOR THE STEADY-STATE PHASOR"
    " SOLUTION FOR INITIAL CONDITIONS, TROUBLE',/,5x,"
    "'HAS OCCURRED WHILE PROCESSING THE ',i2,"
    "'-PHASE COUPLED R-L ELEMENTS THE FIRST OF WHICH CONNECTS',/,5x,'BUS ''',"
    "a6,''' WITH BUS ''',a6,"
    "'''.   THIS COULD EITHER BE AN ACTUAL COUPLED R-L GROUP, OR THE SERIES SU"
    "B-BRANCHES',/,5x,"
    "'OF A MULTI-PHASE PI-CIRCUIT.   IN EITHER CASE, THE COUPLED-BRANCH-GROUP "
    "IMPEDANCE MATRIX    (Z) = (R) + JW(L)   HAS',/,5x,"
    "'BEEN FOUND TO BE NEAR-SINGULAR (UNINVERTIBLE).   IN PARTICULAR, A NEAR-Z"
    "ERO DIAGONAL ELEMENT HAS BEEN FOUND JUST')"),
    lstat(14), bus1, bus2;
  write(lunit6,
    "(5x,'BEFORE RECIPROCATION, DURING THE INVERSION ATTEMPT.   USING MAGNITUD"
    "ES SQUARED FOR ALL THREE QUANTITIES, WE HAVE',/,5x,"
    "'ORIGINAL DIAGONAL VALUE =',e12.3,',   QUESTIONABLE VALUE =',e12.3,"
    "',   TOLERANCE RATIO =',e12.3,'.',/,5x,"
    "'THE USER HAD BETTER CHECK HIS DATA VALUES FOR THIS COUPLED GROUP VERY CA"
    "REFULLY, TO SEE IF SOMETHING IS NOT ABNORMAL.')"),
    flstat(11), flstat(12), flstat(13);
  write(lunit6,
    "(5x,'THE PROGRAM TOLERANCE RATIO FOR NEAR-ZERO CHECKING IS MISCELLANEOUS "
    "DATA PARAMETER ''TOLMAT''.   PERHAPS A',/,5x,"
    "'REREADING OF THE USER''S MANUAL EXPLANATION OF THIS INPUT CONSTANT WOULD"
    " BE IN ORDER, SHOULD THE USER STILL BE',/,5x,"
    "'UNCERTAIN OF THE REASON FOR HIS TROUBLE.')");
  goto statement_6220;
  statement_6019:
  write(lunit6,
    "(5x,'STEADY-STATE SOLUTION LOGIC TROUBLE.   SEE PROGRAM MAINTENANCE, SINC"
    "E THIS IS THEIR FAULT.')");
  goto statement_6220;
  statement_6020:
  write(lunit6,
    "(5x,'LOGIC BREAKDOWN IN STEADY-STATE SOLUTION WHILE BUILDING ADMITTANCE M"
    "ATRIX.')");
  write(lunit6, format_7115);
  goto statement_6220;
  statement_6021:
  write(lunit6,
    "(5x,'STEADY-STATE SOLUTION BREAKDOWN BECAUSE OVER 25 NODES OF NETWORK ARE"
    " SWITCHED TOGETHER.   THIS REPRESENTS',/,5x,"
    "'OVERFLOW OF ARRAY ITEMP(\?\?).   TO SOLVE THE PROBLEM, SIMPLY REDIMENSIO"
    "N  LIST 26  , OR GET RID OF THAT INORDINATE',/,5x,"
    "'NUMBER OF SWITCHES WHICH ARE ALL CONNECTED TOGETHER.   THAT ANY LEGITIMA"
    "TE POWER-SYSTEM PROBLEM SHOULD EVER REACH THIS',/,5x,"
    "'TERMINATION IS HIGHLY IMPROBABLE, AND SOMEWHAT SUSPECT.   UNLESS THE USE"
    "R UNDERSTANDS WHAT IS WRONG, AND WHY,',/,5x,"
    "'SOME CONSULTATION WITH THE USER''S FRIENDLY NEIGHBORHOOD PROGRAM MAINTEN"
    "ANCE MAN IS STRONGLY RECOMMENDED.')");
  goto statement_6220;
  statement_6022:
  write(lunit6,
    "(5x,'BIG TROUBLE.   SINGULAR NODAL ADMITTANCE MATRIX INVOLVING NODE NUMBE"
    "R ',i3,' OF STEADY-STATE SOLUTION HAS BEEN FOUND.',/,5x,"
    "'BUT USER BUS NUMBER FOR THIS NODE COULD NOT BE FOUND IN RENUMBERING MAP "
    " NORDER.   PROGRAM LOGIC ERROR.')"),
    lstat(16);
  write(lunit6, format_7115);
  goto statement_6220;
  statement_6023:
  write(lunit6,
    "(5x,'NO.   WE CAN NOT VALIDLY SET VOLTAGE OF DISCONNECTED SUBNETWORK LAST"
    " IDENTIFIED TO ZERO, SINCE IT APPEARS',/,5x,"
    "'THAT A CURRENT SOURCE FEEDS THIS SUBNETWORK.   FOR THIS CASE, EITHER KIR"
    "CHHOFF''S CURRENT LAW FOR THE SUBNETWORK',/,5x,"
    "'IS VIOLATED (CURRENT IN DOES NOT EQUAL CURRENT OUT), OR THE SOLUTION IS "
    "INDETERMINATE (SUBNETWORK VOLTAGE SOLUTION',/,5x,"
    "'IS ONLY DETERMINED UP TO AN ARBITRARY CONSTANT).   IN EITHER CASE, THE P"
    "ROBLEM IS ILL-POSED PHYSICALLY, AND',/,5x,"
    "'MUST BE REJECTED.   USER HAD BETTER RECONSIDER HIS NETWORK IN THE VICINI"
    "TY OF NODE ''',a6,''', TO EITHER REMOVE')"),
    bus1;
  write(lunit6, "(5x,'THE SINGULARITY, OR THE CURRENT SOURCE(S), OR BOTH.')");
  goto statement_6220;
  statement_6024:
  write(lunit6,
    "(5x,'LOGIC FAILURE NEAR END STEADY-STATE SOLUTION.   KK, IA, INDEX(IA+1)="
    "',3i10)"),
    lstat(16), lstat(15), lstat(14);
  write(lunit6, format_7115);
  goto statement_6220;
  statement_6025:
  {
    write_loop wloop(cmn, lunit6,
      "(5x,'LOGIC TROUBLE WITHIN STEADY-STATE RENUMBERING.   NEXT, MEXT, IB, I"
      ", JBS, NELIM=',6i8)");
    FEM_DO_SAFE(i, 11, 16) {
      wloop, lstat(i);
    }
  }
  write(lunit6, format_7115);
  goto statement_6220;
  statement_6026:
  write(lunit6,
    "(5x,'LOGIC ERROR IN STEADY-STATE RENUMBERING.   KOLUM ARRAY HAS ERRONEOUS"
    " NUMBERS.')");
  write(lunit6, format_7115);
  goto statement_6220;
  statement_6027:
  write(lunit6,
    "(5x,'SOURCE BEING READ IS TYPE-18',' IDEAL-TRANSFORMER PLUS SOURCE.',"
    "'   BUT ONE OR MORE OF THE COLUMN',/,5x,"
    "'3-22 NAME FIELDS ARE UNRECOGNIZED.','   NAMES ARE ....',3(2x,'\"',a6,"
    "'\"'),' .',/,5x,'UNLESS ALL THREE ARE LEGAL EMTP',"
    "' NETWORK NODE NAMES,  THE CASE',' CAN NOT BE RUN.   CORRECT IT.')"),
    bus1, bus2, bus3;
  goto statement_6220;
  statement_6028:
  write(lunit6,
    "(5x,'THE LAST-READ COMPONENT HAS BEEN',"
    "' IDENTIFIED AS AN OLD-FORMAT (PRE-',"
    "'\"M37.\") ZINC-OXIDE SURGE ARRESTER.',/,5x,"
    "'SUCH OLD DATA MUST BE CONVERTED TO',"
    "' THE NEWER FORMAT.   THE SUPPORTING',"
    "' PROGRAM \"ZINOLD\" (SEE RULE BOOK',/,5x,"
    "'INDEX) WILL PERFORM ALL SUCH CONVERSION',"
    "' FOR THE USER AUTOMATICALLY, IN A',' SINGLE PASS.  TRY IT.')");
  goto statement_6220;
  statement_6029:
  write(lunit6,
    "(5x,'DISTRIBUTED-PARAMETER BRANCH CARD CONNECTING NODE ''',a6,''' TO ''',"
    "a6,''' REPRESENTS PROPAGATION MODE',/,5x,'WITH TRAVEL TIME (SEC) =',"
    "e14.5,"
    "'.   THIS IS LESS THAN TIME-STEP SIZE  DELTAT, A CASE WHICH IS ILLEGAL.  "
    " EITHER',/,5x,"
    "'RUN WITH SMALL ENOUGH DELTAT, OR REPLACE THE DISTRIBUTED MODELLING BY LU"
    "MPED PI-CIRCUIT MODEL.')"),
    bus1, bus2, flstat(16);
  if (flstat(16) == 0.0f) {
    write(lunit6,
      "(5x,'THE JUST-PRINTED TRAVEL TIME IS SEEN TO BE ZERO, THOUGH, WHICH IS "
      "GENERALLY A DEFAULT VALUE DESERVING OF',/,5x,"
      "'FURTHER COMMENT.   ASSUMING THAT THE USER HAS ACTUALLY INPUTTED A LINE"
      " OF FINITE LENGTH, THE TRAVEL TIME MUST OF',/,5x,"
      "'COURSE BE POSITIVE.   A ZERO VALUE IS USED FOR DEFAULT IN THE CASE OF "
      "A FREQUENCY-DEPENDENT MODE, HOWEVER, FOR',/,5x,"
      "'THE CASE WHERE THE INFINITE-FREQUENCY TRAVEL TIME IS LESS THAN THE TIM"
      "E-STEP-SIZE  ''DELTAT''  THAT THE USER HAS',/,5x,"
      "'SELECTED.   TO FIND THE ACTUAL OFFENDING TRAVEL-TIME VALUE, THE USER C"
      "AN CONSULT THE DATA-CARD INTERPRETATION WHICH')");
  }
  if (flstat(16) == 0.0f) {
    write(lunit6,
      "(5x,'GOES ALONG WITH THE ASSOCIATED BRANCH CARD AS IT WAS READ IN.   TH"
      "E EMTP DOES NOT HAVE THE VALUE IN QUESTION',/,5x,"
      "'IMMEDIATELY AVAILABLE AT THIS POINT, AND CAN ONLY TELL THE USER THAT H"
      "E''S IN TROUBLE (WITHOUT KNOWING HOW MUCH).')");
  }
  goto statement_6220;
  statement_6030:
  write(lunit6,
    "(5x,'FROM COLUMNS 1-2 OF LAST DATA CARD, A VALUE OF ',i2,"
    "' WAS READ.   THIS IS ILLEGAL.   THE CARD IN QUESTION',/,5x,"
    "'SHOULD BE EITHER AN INITIAL-CONDITION CARD, WHERE VALUES 2, 3, OR 4 ARE "
    "LEGAL, OR IT IS AN OUTPUT-SPECIFICATION',/,5x,"
    "'CARD, WHERE VALUES 0 OR 1 ARE ALLOWED.   SHAPE UP, FELLA.')"),
    lstat(16);
  goto statement_6220;
  statement_6031:
  write(lunit6,
    "(5x,'LAST CARD GIVES NODE-VOLTAGE INITIAL CONDITION FOR UNRECOGNIZABLE NO"
    "DE.   THE NAME ''',a6,''' WHICH WAS',/,5x,"
    "'PUNCHED COULD NOT BE FOUND IN THE LIST OF BUS NAMES.')"),
    bus1;
  write(lunit6, format_7131);
  goto statement_6220;
  statement_6032:
  write(lunit6,
    "(5x,'LAST CARD GIVES INITIAL-CONDITON CURRENTS FOR LINEAR BRANCH FROM NOD"
    "E ''',a6,''' TO ''',a6,'.')"),
    bus1, bus2;
  statement_7232:
  write(lunit6,
    "(5x,'BUT THE BRANCH REFERRED TO COULD NOT BE FOUND IN THE APPROPRIATE LIS"
    "T OF BRANCHES.   IS THE ORIENTATION CORRECT.')");
  write(lunit6, format_7131);
  goto statement_6220;
  statement_6033:
  write(lunit6,
    "(5x,'LAST CARD GIVES INITIAL CONDITION CURRENTS FOR NONLINEAR BRANCH FROM"
    " NODE ''',a6,''' TO ''',a6,'.')"),
    bus1, bus2;
  goto statement_7232;
  statement_6034:
  write(lunit6,
    "(5x,'LAST CARD GIVES INITIAL CONDITION WHICH IS ILLEGAL FOR NONLINEAR ELE"
    "MENT NUMBER ',i3,'.   THE LAST POINT',/,5x,"
    "'OF THE NONLINEAR CHARACTERISTIC IS STORED IN TABLE LOCATION ',i3,"
    "' AND HAS VALUE ',e13.4,'.   BUT INITIAL',/,5x,"
    "'CONDITION REQUIRES A VALUE OF ',e13.4,"
    "', WHICH IS OFF THE END OF THE CHARACTERISTIC.   USER MUST EXTEND THE',/,"
    "5x,'CHARACTERISTIC, IF THIS IS REALLY THE INITIAL CONDITION THAT HE WANTS"
    ".')"),
    lstat(13), lstat(14), flstat(15), flstat(16);
  goto statement_6220;
  statement_6035:
  write(lunit6,
    "(5x,'BREAKDOWN OF SOLUTION WHEN USING COMPENSATION (SUPERPOSITION) ON NON"
    "LINEAR ELEMENT NUMBER ',i3,/,5x,'WHICH CONNECTS NODE ''',a6,''' TO ''',"
    "a6,'''.',/,5x,"
    "'THEVENIN LOAD LINE DOES NOT INTERSECT THE NONLINEAR CHARACTERISTIC.   MA"
    "YBE USER SHOULD EXTEND THE CHARACTERISTIC,',/,5x,"
    "'ASSUMING THAT THE PROBLEM IS OTHERWISE WELL-POSED.   SOME PROGRAM SOLUTI"
    "ON QUANTITIES BEARING ON THIS BREAKDOWN,',/,5x,"
    "'POTENTIALLY USEFUL TO YOUR PROGRAM MAINTENANCE MAN (IF NOT TO THE USER),"
    " ARE AS FOLLOWS ...',/,5x,'E(K), E(M), A2 =',3e13.4)"),
    lstat(16), bus1, bus2, flstat(11), flstat(12), flstat(13);
  write(lunit6,
    "(5x,'PAST EXPERIENCE BASED ON A NUMBER OF ENCOUNTERS WITH THIS EMTP ERROR"
    " STOP HAS SHOWN THAT MOST OFTEN THE USER',/,5x,"
    "'HAS UNDER-ESTIMATED THE PEAK NONLINEAR (OR TIME-VARYING) ELEMENT ORDINAT"
    "E VALUE.   THAT IS, THE CHARACTERISTIC',/,5x,"
    "'AS INPUTTED WAS CORRECT, PERHAPS, BUT WAS SIMPLY NOT DEFINED FOR LARGE E"
    "NOUGH VALUES.   REMEMBER THAT TRUE NONLINEAR',/,5x,"
    "'OR TIME-VARYING ELEMENTS (WITH TYPE CODES 91, 92, OR 93) DO NOT HAVE THE"
    " FINAL SEGMENTS ON THE TWO ENDS')");
  write(lunit6,
    "(5x,'EXTRAPOLATED LINEARLY TO INFINITY (AS IS THE CASE WITH PSEUDO-NONLIN"
    "EAR ELEMENTS OF TYPE CODES 97, 98, AND 99).',/,5x,"
    "'BEFORE LOOKING FOR ANY MORE SOPHISTICATED TROUBLE, THIS VERY SIMPLE POSS"
    "IBILITY SHOULD ALWAYS BE CHECKED.')");
  goto statement_6220;
  statement_6036:
  write(lunit6,
    "(5x,'BREAKDOWN SURROUNDING NONLINEAR OR TIME-VARYING ELEMENT NUMBER ',i3,"
    "' HAVING TERMINAL NODES ''',a6,''' AND ''',a6,'''.',/,5x,"
    "'THIS IS A TIME-VARYING RESISTANCE WITH LAST TIME POINT OF CHARACTERISTIC"
    " DEFINED BY USER BEING FOR ',e13.4,/,5x,'SEC.   BUT ',e13.4,"
    "' SEC HAVE ELAPSED SINCE ELEMENT WAS TURNED ON.   USER MUST EXTEND CHARAC"
    "TERISTIC IF STUDY',/,5x,"
    "'IS TO BE RUN OUT FURTHER THAN THE PRESENT SIMULATION TIME OF   T =',"
    "e12.3,' SEC   AT WHICH THIS RUN IS NOW',/,5x,'BEING TERMINATED.')"),
    lstat(16), bus1, bus2, flstat(12), flstat(13), flstat(11);
  goto statement_6220;
  statement_6037:
  write(lunit6,
    "(5x,'LAST DATA CARD WAS DECODED USING',"
    "'  4E16.0  AND CAME UP WITH FLOATING POINT',"
    "' ZEROS.   THIS IS NOT LEGAL FOR THE',/,5x,"
    "'MODAL IMPEDANCE DATA OF FREQUENCY-',"
    "'DEPENDENT GENERATOR EQUIVALENTS AS',' WERE BEING READ IN \"FDDATA\".')");
  goto statement_6220;
  statement_6038:
  d1 = flstat(13) / flstat(12);
  write(lunit6,
    "(5x,'MATRIX (Y) IS THE NODAL ADMITTANCE',' MATRIX WHICH MUST',/,5x,"
    "'BE RE-TRIANGULARIZED AT EVERY TIME-STEP THAT A SWITCH OR PSEUDO-NONLINEA"
    "R ELEMENT CHANGES ITS STATUS.')");
  write(lunit6,
    "(5x,'THERE HAS JUST BEEN A BREAKDOWN FACTORING',"
    "' (Y), WHILE ELIMINATING ON ROW',i4,'  WHICH CORRESPONDS TO NODE \"',a6,"
    "'\".   AFTER',/,5x,"
    "'ELIMINATION TO THE LEFT OF THE DIAGONAL IN THIS ROW, THE DIAGONAL ELEMEN"
    "T WAS FOUND TO EQUAL',e13.4,', WHILE',/,5x,"
    "'THE ORIGINAL VALUE BEFORE ANY ELIMINATION WAS PERFORMED WAS',e13.4,"
    "'.   THE RATIO OF THESE TWO NUMBERS',/,5x,"
    "'EXCEEDS THE NEAR-ZERO TOLERANCE OF',e13.4,"
    "', WHICH IS MISCELLANEOUS DATA PARAMETER ''EPSILN''.')"),
    lstat(16), bus1, flstat(14), d1, flstat(12);
  write(lunit6, format_7338);
  write(lunit6, format_7138);
  write(lunit6, format_7438);
  write(lunit6,
    "(/,5x,"
    "'IT MIGHT BE DESIRABLE TO SAY A FEW WORDS ABOUT HOW THE PRINTED 6-CHARACT"
    "ER NODE NAME, AND THE SUBNETWORK',/,5x,"
    "'IN QUESTION, ARE RELATED.   HAVING AN ISOLATED SUBNETWORK MEANS THAT THE"
    " SYSTEM MATRIX WHICH IS BEING TRIANGULARIZED',/,5x,"
    "'IS BLOCK DIAGONAL, WITH THE PROBLEM SUBNETWORK THEN ASSOCIATED WITH A SI"
    "NGULAR (UNINVERTIBLE) BLOCK.   THIS IS',/,5x,"
    "'DECOUPLED FROM THE REST OF THE SYSTEM, AND MATHEMATICALLY THE ASSOCIATED"
    " EQUATIONS HAVE AN INDETERMINATE SOLUTION.')");
  write(lunit6,
    "(5x,'THIS SHOWS UP AS A ZERO DIAGONAL ELEMENT WHILE ELIMINATING ON THE RO"
    "W FOR THE LAST NODE OF THE SUBNETWORK.',/,5x,"
    "'WHICH NODE WILL BE THE LAST OF THE SUBNETWORK IS A FUNCTION OF INTERNAL "
    "EMTP RENUMBERING, AS WELL AS THE ORDER OF',/,5x,"
    "'THE NETWORK INPUT DATA.   HENCE THE USER SHOULD NOT ASSUME THAT THERE IS"
    " TROUBLE SPECIFICALLY AT THE NODE WHOSE',/,5x,"
    "'NAME IS PRINTED ABOVE.   USE OF NETWORK CONNECTIVITY PRINTOUT WILL ALLOW"
    " RECONSTRUCTION OF THE PROBLEM TOPOLOGY')");
  write(lunit6,
    "(5x,'IN THE VICINITY OF THE PRINTED NODE.   THE USER IS ADVISED TO GO AS "
    "FAR AWAY FROM THIS NODE IN ALL DIRECTIONS',/,5x,"
    "'AS IS NECESSARY, UNTIL THE LIMITS TO THE SUBNETWORK IN QUESTION BECOME C"
    "LEAR.   A KNOWLEDGE OF SWITCH STATUS AT THE',/,5x,"
    "'INSTANT OF DIFFICULTY IS OF COURSE CRUCIAL.   OFTEN THIS ERROR STOP WILL"
    " OCCUR JUST AS A SWITCH OPENS, THEREBY',/,5x,"
    "'SEGMENTING THE SYSTEM INTO TWO PIECES, ONE OF WHICH HAS NO PATHS TO GROU"
    "ND (WHICH THEN BECOMES THE DISCONNECTED',/,5x,'SUBSYSTEM).')");
  goto statement_6220;
  statement_6039:
  write(lunit6,
    "(5x,'SOLUTION BREAKDOWN ON NONLINEAR OR TIME-VARYING ELEMENT NUMBER ',i3,"
    "' CONNECTING NODE ''',a6,''' WITH NODE ''',a6,'''.',/,5x,"
    "'ONE OR MORE OTHER SUCH ELEMENTS IS ACTUALLY TOUCHING THIS ONE, RATHER TH"
    "AN BEING SEPARATED FROM IT BY THE REQUIRED',/,5x,'TRAVEL TIME.')"),
    lstat(16), bus1, bus2;
  write(lunit6, format_7139);
  write(lunit6, format_7239);
  write(lunit6, format_7339);
  goto statement_6220;
  statement_6040:
  write(lunit6,
    "(5x,'SOLUTION BREAKDOWN USING COMPENSATION METHOD ON NONLINEAR OR TIME-VA"
    "RYING ELEMENTS NUMBER ',i3,' AND ',i3,'.',/,5x,"
    "'THE FIRST CONNECTS NODE ''',a6,''' WITH NODE ''',a6,"
    "''', WHILE THE SECOND HAS TERMINAL NODES ''',a6,''' AND ''',a6,'''.',/,"
    "5x,'THESE TWO ELEMENTS ARE NOT SEPARATED BY THE REQUIRED TRAVEL TIME (DIS"
    "TRIBUTED-PARAMETER LINE).')"),
    lstat(15), lstat(16), cmn.bus5, bus6, bus3, bus4;
  write(lunit6, format_7139);
  write(lunit6, format_7239);
  write(lunit6, format_7339);
  goto statement_6220;
  statement_6041:
  write(lunit6,
    "(5x,'SWITCH NUMBER ',i3,' CONNECTING NODE ''',a6,''' WITH NODE ''',a6,"
    "''' HAS CLOSED, CAUSING TROUBLE.')"),
    lstat(10), bus1, bus2;
  goto statement_6040;
  statement_6042:
  write(lunit6, format_7142);
  write(lunit6,
    "(5x,'ROW ',i3,"
    "' IN YAA (MATRIX FOR NONSWITCH ROWS) HAS IDENTICALLY-ZERO DIAGONAL ELEMEN"
    "T BEFORE STARTING ELIMINATION.',/,5x,'THIS CORRESPONDS TO NODE ''',a6,"
    "''', WHERE THERE IS EITHER NOTHING CONNECTED, OR THERE IS A VERY STRANGE,"
    " PERFECT',/,5x,"
    "'RESONANCE.   THE USER SHOULD CHECK ALL BRANCHES CONNECTED TO THE NODE IN"
    " QUESTION.   IF THERE ARE NONE, PUT ONE IN OR',/,5x,"
    "'DROP THE NODE IN QUESTION.')"),
    lstat(16), bus1;
  goto statement_6220;
  statement_6043:
  write(lunit6, format_7142);
  d1 = flstat(13) / flstat(12);
  write(lunit6,
    "(5x,'THERE HAS BEEN A BREAKDOWN IN THE TRIANGULARIZATION OF (YAA) WHILE W"
    "ORKING ON ROW',i4,', WHICH CORRESPONDS',/,5x,'TO NODE ''',a6,"
    "'''.   AFTER ELIMINATION TO THE LEFT OF THE DIAGONAL IN THIS ROW, THE DIA"
    "GONAL ELEMENT HAS BEEN',/,5x,'FOUND TO EQUAL',e13.4,"
    "', WHILE THE ORIGINAL MATRIX VALUE (BEFORE ANY ELIMINATION) WAS',e13.4,"
    "'.   THE',/,5x,"
    "'RATIO OF THESE TWO NUMBERS EXCEEDS THE NEAR-ZERO TOLERANCE OF',e13.4,"
    "', WHICH IS MISC. DATA PARAMETER ''EPSILN''.')"),
    lstat(16), bus1, flstat(14), d1, flstat(12);
  write(lunit6, format_7338);
  write(lunit6, format_7138);
  write(lunit6, format_7438);
  goto statement_6220;
  statement_6044:
  write(lunit6,
    "(5x,'YOU DUMMY, YOU FORGOT TO REQUEST OUTPUT VARIABLES.   IF THE BRANCH C"
    "ARDS HAVE NO COLUMN-80 BRANCH-OUTPUT',/,5x,"
    "'REQUESTS, AND NO NODE VOLTAGES WERE REQUESTED FOR OUTPUT, THERE IS NOTHI"
    "NG TO LOOK AT BY WAY OF A PROBLEM SOLUTION.',/,5x,"
    "'NO VARIABLES ARE TO BE PRINTED, AND NONE CAN BE PLOTTED.   THE EMTP WILL"
    " NOT LET YOU RUN A PROBLEM THIS WAY.',/,5x,"
    "'GO BACK TO THE KEYPUNCH AND ADD SOME OUTPUT, DO NOT PASS GO, DO NOT COLL"
    "ECT 200 DOLLARS.')");
  goto statement_6220;
  statement_6045:
  write(lunit6,
    "(5x,'WEIGHTING FUNCTION A',i1,'(T) JUST INPUTTED DOES NOT HAVE ALL',"
    "' WHICH ARE MONOTONE INCREASING.',/,5x,'IN PARTICULAR, POINT NUMBER ',i3,"
    "' IS FOR TIME',e15.6,' SEC, WHILE THE PRECEDING POINT WAS FOR',/,5x,"
    "'TIME',e15.6,"
    "'.   PERHAPS THE CARD DECK HAS BEEN SHUFFLED, OR SOMEHOW ALTERED FROM THA"
    "T AS PUNCHED BY THE',/,5x,'WEIGHTING-FUNCTION SUPPORTING PROGRAM.')"),
    lstat(17), lstat(14), flstat(15), flstat(16);
  goto statement_6220;
  statement_6046:
  write(lunit6,
    "(5x,'THE WEIGHTING FUNCTION FREQUENCY DEPENDENT LINE MODE NUMBER ',i2,"
    "' HAS FAILED',/,5x,"
    "'DURING AN ATTEMPT TO IMPROVE THE LOW FREQUENCY REPRESENTATION',/,5x,"
    "'BY ADJUSTING THE EXPONENTIAL TIME CONSTANT OF THE RESPONSE TAILS',/,5x,"
    "'TO GIVE THE THEORETICALLY CORRECT AREAS.  THE ADJUSTMENT WAS REQUESTED',"
    "/,5x,'BY A NON-ZERO VALUE =',e10.5,' FOR \"RTOTAL\" IN COLUMNS 65 TO 72',"
    "/,5x,"
    "'OF THE MISCELLANEOUS DATA CARD, WHILE A PERMISSIBLE ITERATION COUNT OF N"
    "II =',i4,/,5x,"
    "'WAS PROVIDED FOR THE NEWTON-RAPHSON ALGORITHM IN COLUMNS 73 TO 80')"),
    lstat(15), flstat(15), lstat(14);
  goto statement_6220;
  statement_6047:
  write(lunit6,
    "(5x,'SWITCH-ARRAY OVERFLOW DUE TO TOO MANY SATURABLE TRANSFORMERS.   THE "
    "SWITCH TABLES ARE USED FOR SCRATCH',/,5x,"
    "'STORAGE OF XFORMER STARTING-AND-ENDING DATA POINTERS, DURING BRANCH-DATA"
    " INPUT.   THE USER HAS INPUTTED MORE',/,5x,"
    "'SATURABLE XFORMERS THAN THE PROGRAM LIMIT FOR SWITCHES, WHICH IS ',i3,"
    "'.   EITHER REDUCE THE FORMER, OR INCREASE',/,5x,'THE LATTER.')"),
    lstat(16);
  goto statement_6220;
  statement_6048:
  write(lunit6,
    "(5x,'THE LAST DATA CARD INPUTTED REQUESTS A COPY OF A PRECEDING SATURABLE"
    " TRANSFORMER WHICH PURPORTEDLY BEARS',/,5x,"
    "'INTERNAL IDENTIFYING BUS NAME ''',a6,"
    "'''.   BUT A SEARCH OF PRECEDING COMPONENTS HAS FAILED TO LOCATE SUCH A C"
    "OMPONENT.',/,5x,"
    "'MAYBE THE USER''S DATA IS OUT OF ORDER, OR HE HAS MISSPELLED THE NAME IN"
    " QUESTION.')"),
    bus3;
  write(lunit6, format_7131);
  goto statement_6220;
  statement_6049:
  if (bus1 != cmn.trash) {
    goto statement_7249;
  }
  write(lunit6,
    "(5x,'THE USER IS CURRENTLY INPUTTING A SATURABLE TRANSFORMER COMPONENT, W"
    "HICH BY DEFINITION MUST HAVE TWO OR MORE',/,5x,"
    "'WINDINGS.   THE LAST-READ DATA CARD SHOULD HAVE BEEN A WINDING CARD FOR "
    "WINDING NUMBER',i4,' ,   BUT THIS IS NOT',/,5x,"
    "'WHAT WAS PUNCHED IN COLUMNS  1-2 .   A VALUE OF',i4,"
    "'   WAS READ FROM THIS DATA FIELD.')"),
    ksat, cmn.itype;
  goto statement_6220;
  statement_7249:
  write(lunit6,
    "(5x,'THE USER IS CURRENTLY INPUTTING A SATURABLE TRANSFORMER, USING THE R"
    "EFERENCE BRANCH PROCEDURE TO GET A COPY',/,5x,"
    "'OF THE UNIT BEARING INTERNAL IDENTIFYING BUS NAME ''',a6,"
    "'''.   BUT THAT UNIT HAD ',i2,' WINDINGS.   THE COIL',/,5x,"
    "'CARDS BEING READ ARE EITHER OUT OF NATURAL ORDER (CHECK COLUMNS 1-2 SEQU"
    "ENCE NUMBERS), OR THEY REPRESENT AN',/,5x,"
    "'INCORRECT NUMBER OF WINDINGS.   RECALL THAT THE WINDING CARDS MUST BE NU"
    "MBERED 1, 2, ETC. ----- CONSECUTIVELY,',/,5x,"
    "'WITH NO MISSING NUMBERS.   ONCE A BREAK IN THIS NATURAL ORDER HAS BEEN D"
    "ETECTED FOR THE COLUMN 1-2 NUMBERS, THE')"),
    bus1, lstat(16);
  write(lunit6,
    "(5x,'EMTP LOGIC ASSUMES THAT DATA FOR THE TRANSFORMER IN QUESTION HAS BEE"
    "N COMPLETED.   THIS IS WHY SHUFFLED',/,5x,"
    "'WINDING CARDS PRODUCE AN ''ERRONEOUS-NUMBER-OF-TURNS'' MESSAGE.')");
  goto statement_6220;
  statement_6050:
  write(lunit6,
    "(5x,'DATA ERROR HAS BEEN DETECTED WHILE WORKING ON INPUT OF 3-PHASE TRANS"
    "FORMER COMPONENT BEARING',/,5x,'INTERNAL BUS-NAME IDENTIFIER ''',a6,"
    "'''.   THE PROGRAM EXPECTS 3 SINGLE-PHASE TRANSFORMER COMPONENTS',/,5x,"
    "'TO FOLLOW THE THREE-PHASE CARD, CONTIGUOUSLY.   THE LAST-READ BRANCH HAS"
    " BEEN FOUND AFTER ONLY ',i3,/,5x,'SINGLE-PHASE COMPONENTS.')"),
    bus6, lstat(15);
  statement_6220:
  lastov = nchain;
  nchain = nfrfld + 50;
  if (iprsup >= 1) {
    write(lunit6, format_8943), nchain, kill;
  }
  statement_9000:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
over51(
  common& cmn) try
{
  common_write write(cmn);
  auto& flstat = cmn.flstat;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  //
  auto& lunit6 = cmn.lunit6;
  double vmin = fem::double0;
  double vmax = fem::double0;
  if (iprsup >= 1) {
    write(lunit6, "(' BEGIN \"OVER51\".  KILL =',i8)"), kill;
  }
  runtym(vmin, vmax);
  flstat(9) = vmin - flstat(9);
  flstat(10) = vmax - flstat(10);
  if (kill == 0) {
    goto statement_4521;
  }
  subr51(cmn);
  goto statement_4536;
  statement_4521:
  cmn.lastov = nchain;
  nchain = 55;
  statement_4536:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT MODULE \"OVER51\".')");
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
over52(
  common& cmn) try
{
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  const auto& flstat = cmn.flstat;
  const auto& lstat = cmn.lstat;
  int& lbus = cmn.lbus;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& nenerg = cmn.nenerg;
  //
  auto& lunit6 = cmn.lunit6;
  int n1 = fem::int0;
  static const char* format_7154 =
    "(5x,'THE USER HAS ATTEMPTED TO USE THE STEADY-STATE CASCADING OF PI-CIRCU"
    "ITS OPTION, BUT HAS MADE AN INPUT DATA ERROR.')";
  static const char* format_7166 =
    "(5x,'THE CURRENT PROGRAM DIMENSIONED STORAGE FOR SUCH POINTS IS ',i3,"
    "'.   DOES THE USER REALLY NEED ALL OF',/,5x,"
    "'THESE POINTS THAT HE IS USING, THE EMTP WONDERS.   IF HE REALLY DOES, AN"
    "D CAN JUSTIFY HIS REQUEST TO PROGRAM',/,5x,"
    "'MAINTENANCE, AN EXPANSION OF THESE TABLES WHICH HAVE JUST OVERFLOWED COU"
    "LD EASILY BE MADE.   OTHERWISE, MAYBE A',/,5x,"
    "'RE-READING OF THE USER''S MANUAL, OR A TALK WITH SOMEONE FAMILIAR WITH T"
    "HE WEIGHTING-FUNCTION CALCULATION, OR',/,5x,'BOTH, MIGHT BE IN ORDER.')";
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER52.\"')");
  }
  if (nchain != 52) {
    goto statement_99999;
  }
  n1 = cmn.kill - 50;
  switch (n1) {
    case 1: goto statement_6051;
    case 2: goto statement_6052;
    case 3: goto statement_6053;
    case 4: goto statement_6054;
    case 5: goto statement_6055;
    case 6: goto statement_6056;
    case 7: goto statement_6057;
    case 8: goto statement_6058;
    case 9: goto statement_6059;
    case 10: goto statement_6060;
    case 11: goto statement_6061;
    case 12: goto statement_6062;
    case 13: goto statement_6063;
    case 14: goto statement_6064;
    case 15: goto statement_6065;
    case 16: goto statement_6066;
    case 17: goto statement_6067;
    case 18: goto statement_6068;
    case 19: goto statement_6069;
    case 20: goto statement_6070;
    case 21: goto statement_6071;
    case 22: goto statement_6072;
    case 23: goto statement_6073;
    case 24: goto statement_6074;
    case 25: goto statement_6075;
    case 26: goto statement_6076;
    case 27: goto statement_6077;
    case 28: goto statement_6078;
    case 29: goto statement_6079;
    case 30: goto statement_6080;
    case 31: goto statement_6081;
    case 32: goto statement_6082;
    case 33: goto statement_6083;
    case 34: goto statement_6084;
    case 35: goto statement_6085;
    case 36: goto statement_6086;
    case 37: goto statement_6087;
    case 38: goto statement_6088;
    case 39: goto statement_6089;
    case 40: goto statement_6090;
    default: break;
  }
  statement_6051:
  write(lunit6,
    "(5x,'THE USER''S NETWORK INCLUDES A GROUP OF MUTUALLY-COUPLED BRANCHES OF"
    " ORDER ',i2,' WHICH ARE SPECIFIED BY',/,5x,"
    "'MATRICES (A), (B).   THE FIRST BRANCH OF THIS PROBLEM GROUP CONNECTS BUS"
    " ''',a6,''' WITH BUS ''',a6,'.   WHEN',/,5x,"
    "'USING THE (A), (B) OPTION, THE NUMBER OF UPPER-TRIANGLE MATRIX ELEMENTS "
    "( N(N+1)/2 ) MUST NOT EXCEED THE BUS',/,5x,"
    "'DIMENSIONING (LIST 1) OF THE PROGRAM, AS IT HAS HERE.   IF THE USER REAL"
    "LY WANTS SO MANY CONDUCTORS, HE SHOULD',/,5x,"
    "'SWITCH TO USE OF (R), (L) FORMAT, IF POSSIBLE.')"),
    lstat(14), bus1, cmn.bus2;
  goto statement_6220;
  statement_6052:
  write(lunit6,
    "(5x,'THE USER HAS BEEN INPUTTING A SATURABLE-TRANSFORMER COMPONENT, THE D"
    "ATA FOR WHICH IS NOT ALL LEGAL.   OF THE',/,5x,"
    "'RULES TO FOLLOW, THAT NUMBERED ',i1,"
    "' HAS BEEN VIOLATED.   RULES INCLUDE....',/,10x,"
    "'1)  ZERO-SEQUENCE RELUCTANCE OF AIR-RETURN PATH OF 3-PHASE UNIT MUST BE "
    "POSITIVE.',/,10x,"
    "'2)  LEAKAGE INDUCTANCE  L  FOR ALL BUT THE FIRST WINDING MUST BE NONZERO"
    ".   FIRST WINDING MUST HAVE NONZERO',/,14x,'LEAKAGE IMPEDANCE.')"),
    lstat(16);
  write(lunit6,
    "(10x,"
    "'3)  RATED WINDING VOLTAGES (NUMBER OF WINDING TURNS) MUST ALL BE POSITIV"
    "E.',/,10x,"
    "'4)  THE RATED WINDING VOLTAGE (NUMBER OF WINDING TURNS) MUST BE THE SAME"
    " FOR CORRESPONDING WINDINGS OF ALL 3 PHASES',/,14x,"
    "'OF A 3-PHASE TRANSFORMER.')");
  goto statement_6220;
  statement_6053:
  write(lunit6,
    "(5x,'THE USER IS ATTEMPTING TO USE THE STEADY-STATE CASCADING OF PI-CIRCU"
    "ITS OPTION TO SOLVE A VERY LARGE PROBLEM.')");
  write(lunit6,
    "(5x,'ERROR IN CASCADED-PI DATA.',/,5x,"
    "'THERE ARE TOO MANY PHASES REQUESTED FOR THE PROGRAM TO HANDLE.   THE NUM"
    "BER OF PHASES ''NPHCAS'' AS READ FROM',/,5x,"
    "'COLUMNS 27-32 OF HEADER CARD IS ',i6,"
    "'.   THIS IS TOO LARGE FOR PRESENT PROGRAM DIMENSIONS.   THE CASCADING',"
    "/,5x,"
    "'CODE HAS TEMPORARY WORKING ARRAYS WHICH ARE EQUIVALENCED TO VARIOUS COMP"
    "ONENTS OF REGULAR (PERMANENT) PROGRAM',/,5x,"
    "'TABLES, AND IT IS ONE OF THE LIST LIMITS FOR THESE WHICH IS INSUFFICIENT"
    " FOR THE USER''S PROBLEM.   IN PARTICULAR,')"),
    lstat(12);
  if (lstat(15) != 1) {
    goto statement_7253;
  }
  write(lunit6,
    "(5x,'N*(N+1)/2 =',i5,'  EXCEEDS ''LPAST'' OF',i5,"
    "'   , WHERE  N = 3*NPHCAS ,  AND ''LPAST'' IS',/,5x,"
    "'THE SIZE OF LIST NUMBER 8 (SEE BELOW).')"),
    lstat(16), cmn.lpast;
  statement_7253:
  if (lstat(15) != 2) {
    goto statement_6220;
  }
  write(lunit6,
    "(5x,'NPHCAS*(NPHCAS+1)/2 =',i5,'  EXCEEDS ''LBUS'' OF',i5,"
    "'WHERE ''LBUS'' IS THE SIZE OF LIST NUMBER 1',/,5x,'(SEE BELOW).')"),
    lstat(16), lbus;
  goto statement_6220;
  statement_6054:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'THE LINE-POSITION CARD PROVIDES FOR SPECIFICATION OF A TRANSPOSITION"
    " BY MEANS OF A PHASE-POSITION MAP',/,5x,"
    "'BEGINNING IN COLUMN 25, AND USING ''I4'' FORMAT FOR EACH OF ''NPHCAS'' E"
    "NTRIES.   THESE ENTRIES MUST BE A',/,5x,"
    "'PERMUTATION OF THE INTEGERS 1, 2, 3, ..., ''NPHCAS'', WITH ''NPHCAS'' ='"
    ",i3,' FOR THE PRESENT LINE.   BUT ONE OF',/,5x,"
    "'THE POSITION-MAP ENTRIES HAS BEEN READ AS ',i4,"
    "', WHICH IS CLEARLY IMPOSSIBLE.   ASSUMING THAT THE')"),
    lstat(13), lstat(12);
  write(lunit6,
    "(5x,'DIGITS WHICH WERE PUNCHED ON THE CARD WERE OK, CHECK FOR RIGHT-JUSTI"
    "FICATION WITHIN THE FIELDS OF WIDTH 4.',/,5x,"
    "'RECALL THAT AN ERRONEOUS SHIFT TO THE LEFT BY ONE COLUMN MULTIPLIES THE "
    "NUMBER BY 10, WHILE A SHIFT TO THE RIGHT',/,5x,"
    "'WILL SPILL OVER INTO THE FOLLOWING FIELD, GENERALLY CREATING A VERY LARG"
    "E INTEGER WHEN THE LATTER FIELD IS READ.')");
  goto statement_6220;
  statement_6055:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'''MULTIP'' IS THE MULTIPLICITY PARAMETER, READ FROM COLUMNS 9-12 OF "
    "THE LINE-POSITION CARD.   AS SUCH, IT MUST',/,5x,"
    "'BE A NON-NEGATIVE INTEGER, WITH ZERO OR BLANK GIVEN THE DEFAULT VALUE OF"
    " UNITY.   BUT THE EMTP HAS READ A VALUE',/,5x,'OF ',i4,"
    "' FOR ''MULTIP'', WHICH HAS NO PHYSICAL MEANING, AND MUST BE REJECTED.')"),
    lstat(12);
  goto statement_6220;
  statement_6056:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'THE MOST-RECENTLY-INPUTTED GROUP OF R-L-C SHUNT BRANCHES WERE ',i2,"
    "' IN NUMBER, WITH BOTH ENDS OF NUMBER',/,5x,i2,"
    "' OF THIS GROUP CONNECTED TO THE SAME NODE NUMBER ',i2,"
    "'.   NOW WHILE SUCH A REQUESTED CONNECTION',/,5x,"
    "'PRESENTS NO PROBLEM IF TAKEN LITERALLY, THE EMTP''S INFALLIBLE INTUITION"
    " IS INCLINED TO FEEL THAT THE USER HAS MADE',/,5x,"
    "'A PUNCHING ERROR IN COLUMNS 3-14 OF HIS DATA CARD (WHERE THE TWO NUMBERS"
    " IN QUESTION ARE READ IN).   A NETWORK',/,5x,"
    "'SOLUTION WITH SUCH DEGENERATE TOPOLOGY WILL NOT BE PERMITTED.   SORRY ''"
    "BOUT THAT.')"),
    lstat(13), lstat(14), lstat(12);
  goto statement_6220;
  statement_6057:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'ERROR IN CASCADED-PI DATA.',/,5x,'NODE',i4,"
    "' SHORT CIRCUITED TO NODE',i4,"
    "'.  ONE OF THESE NODES SHOULD BE REMOVED FROM THE CIRCUIT.')"),
    lstat(12), lstat(13);
  goto statement_6220;
  statement_6058:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'''STOP CASCADE'' CARD MISSING IN REFERENCED CASCADED PI SECTION.  TH"
    "IS CAN BE CORRECTED BY EITHER PUTTING',/,5x,"
    "'THIS CARD IN OR REMOVING THE ''CASCADED PI'' CARD.')");
  goto statement_6220;
  statement_6059:
  write(lunit6,
    "(5x,'3-PHASE COMPENSATION FOR SYNCHRONOUS MACHINE NUMBER ',i2,"
    "' BREAKS DOWN.   TERMINAL BUS ''',a6,'''',/,5x,"
    "'ALREADY HAS ANOTHER ELEMENT REQUIRING COMPENSATION CONNECTED TO IT.')"),
    lstat(16), bus1;
  goto statement_6220;
  statement_6060:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'INVALID SHUNT R-L-C NODE NUMBER ',i3,"
    "'WAS USED.  THIS NUMBER IS OUT OF SEQUENCE.',/,5x,"
    "'CHECK CONNECTIONS IN THIS AREA AND RENUMBER NODES.')"),
    lstat(12);
  goto statement_6220;
  statement_6061:
  write(lunit6,
    "(5x,'SWITCHED-INDUCTANCE ELEMENT JUST READ HAS INDUCTANCE PARAMETERS  L1 "
    " AND  L2  (COLUMNS 25-44) PUNCHED',/,5x,'AS',e14.3,' AND',e14.3,"
    "', RESPECTIVELY.   ONE OR BOTH OF THESE ARE NON-POSITIVE, WHICH IS ILLEGA"
    "L.   IF THE',/,5x,"
    "'USER WANTS A ZERO VALUE, HE MUST PUNCH A SMALL POSITIVE NUMBER.')"),
    flstat(15), flstat(16);
  goto statement_6220;
  statement_6062:
  write(lunit6,
    "(5x,'SWITCHED-RESISTANCE ELEMENT JUST READ HAS RESISTANCE  R  (COLUMNS 15"
    "-24) OR BREAKPOINT VOLTAGE',/,5x,"
    "'(COLUMNS 35-44) NONPOSITIVE, WHICH IS ILLEGAL.   IF THE USER WANTS A ZER"
    "O VALUE, HE MUST PUNCH A SMALL POSITVE NUMBER.',/,5x,"
    "'NUMBERS READ FROM THE TWO FIELDS IN QUESTION ARE',e13.3,' AND ',e13.3,"
    "', RESPECTIVELY.')"),
    flstat(14), flstat(15);
  goto statement_6220;
  statement_6063:
  write(lunit6,
    "(5x,'TROUBLE HAS BEEN ENCOUNTERED DURING DECODING OF USER''S INPUT DATA. "
    "  HAD NOT THIS VERY CIVILIZED ERROR',/,5x,"
    "'MESSAGE BEEN SPECIALLY PROVIDED, THE COMPUTER OPERATING SYSTEM WOULD HAV"
    "E PERFORMED THE TERMINATION IN ITS OWN',/,5x,"
    "'CURSORY, INIMITABLY-INSCRUTABLE MANNER.   MOST PROBABLY, THE LAST DATA C"
    "ARD READ CARRIES SOME ERRONEOUS DATA,',/,5x,"
    "'AS PER THE FOLLOWING SUGGESTIONS ....',/,8x,"
    "'1) IT IS POSSIBLE THAT ONE OR MORE COLUMNS CARRY ILLEGAL, COMPLETELY-UNI"
    "NTERPRETABLE PUNCHES, IN WHICH CASE THE')");
  write(lunit6,
    "(11x,"
    "'LAST 80-COLUMN CARD IMAGE PRINTED OUT ABOVE MIGHT NOT BE AN ACCURATE IMA"
    "GE OF THE DATA CARD IN QUESTION.',/,11x,"
    "'THE USER SHOULD BE AWARE OF THIS LIMITATION ON THE FIDELITY OF THE PRINT"
    "ED CARD IMAGES, WHICH CAN ONLY',/,11x,"
    "'BE GUARANTEED IF ALL CHARACTERS ARE LEGALLY-PUNCHED.   YET THIS CASE OF "
    "ILLEGAL PUNCHES IS RARE.   CONTINUE READING.',/,8x,"
    "'2) MORE COMMONLY, THE USER MAY HAVE PUNCHED DATA A LITTLE TO THE LEFT OR"
    " TO THE RIGHT OF WHERE HE HAD',/,11x,"
    "'INTENDED, THEREBY PLACING A DECIMAL POINT IN AN INTEGER FIELD, OR A NON-"
    "NUMERIC CHARACTER IN A NUMERICAL')");
  write(lunit6,
    "(11x,'FIELD.',/,8x,"
    "'3) ONE OR MORE RANDOM PUNCHING ERRORS IN A NUMERIC FIELD WILL GENERALLY "
    "PRODUCE TROUBLE.   LETTERS OR',/,11x,"
    "'PUNCTUATION ARE NOT ALLOWED, OF COURSE (WITH A FEW VERY SPECIAL EXCEPTIO"
    "NS, WHICH ARE HIGHLY IMPROBABLE).',/,8x,"
    "'4) PUNCHING OF FLOATING-POINT NUMBERS WITH AN ''E'' (POWER OF 10) CAN LE"
    "AD TO TROUBLE IF NOT RIGHT-JUSTIFIED IN',/,11x,"
    "'THE FIELD, SINCE ANY BLANK SPACES TO THE RIGHT OF THE LAST-PUNCHED EXPON"
    "ENT DIGIT ARE INTERPRETED AS ZEROES,')");
  write(lunit6,
    "(11x,"
    "'THEREBY INCREASING THE EXPONENT BY A POWER OF TEN.   THIS MAY PRODUCE A "
    "RESULT WHICH IS OUTSIDE THE',/,11x,"
    "'LEGAL RANGE OF FLOATING-POINT NUMBERS.',/,8x,"
    "'5) OUT-OF-SEQUENCE DATA IS A NOTORIOUS OFFENDER.   FOR EXAMPLE, IF A LEG"
    "ITIMATE BRANCH CARD IS READ AS A SWITCH',/,11x,"
    "'CARD (MAYBE IT WAS MIXED IN WITH THE SWITCH CARDS BY MISTAKE), ONE COULD"
    " HAVE 2 DECIMAL POINTS PUNCHED IN A',/,11x,"
    "'DATA FIELD WHICH IS READ UNDER ''E''-FORMAT CONTROL, WHICH IS CLEARLY IL"
    "LEGAL.   THE USER SHOULD CHECK THAT')");
  write(lunit6,
    "(11x,"
    "'BLANK CARDS, AND ANY OTHER DATA-TERMINATION OR DELINEATION CARDS, ARE PR"
    "OPERLY POSITIONED IN THE DATA',/,11x,"
    "'STREAM.   ONLY WITH SUCH CARE WILL THE EMTP THINK THAT IT IS READING WHA"
    "T THE USER THINKS HE IS INPUTTING,',/,11x,'AT SAID POINT IN TIME.')");
  goto statement_6220;
  statement_6064:
  write(lunit6,
    "(5x,'SWITCH CONNECTIVITY ERROR.  SUBROUTINE',"
    "' SWITCH HAS DETERMINED THAT A LOOP OF',"
    "' CLOSED SWITCHES IS ABOUT TO BE',/,5x,'CREATED INVOLVING BUS  \"',a6,"
    "'\".   SUCH SWITCH LOOPS ARE ILLEGAL.')"),
    bus1;
  goto statement_6220;
  statement_6065:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD HAS BEEN TAKEN BY THE EMTP TO BE CARD NUMBER"
    " ',i3,' OF THE USER''S FREQUENCY-',/,5x,"
    "'DEPENDENT LINE-CONSTANTS INPUT.   IT IS ILLEGAL BECAUSE THE FREQUENCY, A"
    "S READ FROM COLUMNS 21-30 USING ''E'' FORMAT,',/,5x,"
    "'IS NOT GREATER THAN THAT READ FROM THE PRECEDING CARD.   THE FREQUENCY O"
    "F THIS CARD IS',e13.4,', WHILE THAT',/,5x,'OF THE PRECEDING CARD WAS',"
    "e13.4,"
    "'.   DATA CARDS FOR LINE CONSTANTS MUST BE INPUTTED IN ORDER OF INCREASIN"
    "G',/,5x,'FREQUENCY ---- STRICTLY MONOTONE-INCREASING.')"),
    lstat(14), flstat(15), flstat(16);
  goto statement_6220;
  statement_6066:
  write(lunit6,
    "(5x,'THE USER IS PRESENTLY TRYING TO INPUT LINE CONSTANTS (''R'', ''L'', "
    "AND ''F'' FIELDS) FOR TOO MANY FREQUENCIES.')");
  write(lunit6, format_7166), lstat(12);
  goto statement_6220;
  statement_6067:
  write(lunit6,
    "(5x,'TO FIND THE NEAR-END WEIGHTING FUNCTION  A2(T) ,  RECOURSE IS MADE T"
    "O THE INFINITELY-LONG LINE.   FOR TIME',/,5x,"
    "'LESS THAN THE INFINITE-FREQUENCY TRAVEL TIME ''TAU'', IT IS THE INFINITE"
    "-LINE RESPONSE WHICH IS ACTUALLY USED.',/,5x,"
    "'INPUT PARAMETER  ''NPINF''  (COLUMNS 25-32 OF THE SECOND MISC. DATA CARD"
    ") SPECIFIES THE NUMBER OF POINTS WHICH ARE',/,5x,"
    "'USED TO DEFINE THIS RESPONSE, WITH THE USER REQUESTING',i4,'.')"),
    lstat(13);
  write(lunit6, format_7166), lstat(12);
  goto statement_6220;
  statement_6068:
  write(lunit6,
    "(5x,'THE NUMBER OF POINTS WHICH ARE USED TO DEFINE THE WEIGHTING FUNCTION"
    "S IS CONTROLLED (IN PART) BY TWO MISC.',/,5x,"
    "'DATA PARAMETERS.   THE FIRST OF THESE IS  ''RMAX''  WITH VALUE',e12.3,"
    "', AND THE SECOND IS  ''MNUM''  WITH VALUE',/,5x,i3,"
    "'.   EITHER THESE WERE USER-PUNCHED NUMBERS, OR THEY ARE DEFAULT VALUES B"
    "UILT INTO THE EMTP   ANYWAY, THESE',/,5x,"
    "'PARAMETERS COMBINE TO PRODUCE A STORAGE REQUIREMENT FOR THE FINITE LINE "
    "GIVEN BY    (RMAX-1)*MNUM = ',i4,' POINTS.')"),
    flstat(14), lstat(15), lstat(13);
  write(lunit6,
    "(5x,'THE PRESENT DIMENSIONS OF THE PROGRAM PERMIT ',i4,' POINTS.')"),
    lstat(12);
  if (flstat(13) > 0.f) {
    write(lunit6,
      "(5x,'SINCE VARIABLE TIME INCREMENT DT WAS REQUESTED BY MNUM LESS THAN Z"
      "ERO, THE TOTAL STORAGE REQUIREMENT',/,5x,"
      "'WAS ESTABLISHED BY SUMMATION OF SIMILAR EXPRESSIONS WITH ADJUSTED VALU"
      "ES OF RMAX AND MNUM FOR EACH TIME SPAN.')");
  }
  goto statement_6220;
  statement_6069:
  write(lunit6,
    "(5x,'THE USER IS PRESENTLY TRYING TO INPUT I-V POINTS WHICH DEFINE HIS MA"
    "GNETIC SATURATION CHARACTERISTIC.',/,5x,"
    "'BUT HE IS USING TOO MANY POINTS TO DEFINE THIS CURVE.')");
  write(lunit6, format_7166), lstat(12);
  goto statement_6220;
  statement_6070:
  write(lunit6,
    "(5x,'THIS ERROR IS MOST LIKELY DUE TO THE COMPUTER SYSTEM LIBRARY SUBROUT"
    "INE FOR THE SINE FUNCTION GIVING A VALUE',/,5x,"
    "'GREATER THAN UNITY.   IF THERE WERE ANY JUSTICE IN THE WORLD, THIS TROUB"
    "LE WOULD NOT HAVE ARISEN.   IN ANY CASE,',/,5x,"
    "'THE DIFFICULTY IS PROBABLY NOT THE USER''S FAULT, SO HE SHOULD GO COMPLA"
    "IN TO PROGRAM MAINTENANCE ABOUT HIS TROUBLE.')");
  goto statement_6220;
  statement_6071:
  write(lunit6,
    "(5x,'THE USER IS PRESENTLY TRYING TO INPUT I-V POINTS WHICH DEFINE HIS MA"
    "GNETIC SATURATION CHARACTERISTIC.',/,5x,"
    "'BUT HE HAS VIOLATED THE RULE WHICH REQUIRES THAT BOTH VOLTAGE AND CURREN"
    "T BE STRICTLY MONOTONE-INCREASING (FOR',/,5x,"
    "'THE ORDER OF DATA-CARD INPUT).   THE LAST-READ CARD (NUMBER ',i3,"
    "' OF THE CHARACTERISTIC) VIOLATES THIS',/,5x,"
    "'REQUIREMENT, AS SHOWN BY THE FOLLOWING VARIABLE VALUES WHICH WERE PUNCHE"
    "D BY THE USER .....',/,20x,'LATEST CURRENT =',e13.4,10x,"
    "'PRECEDING CURRENT =',e13.4)"),
    lstat(12), flstat(13), flstat(14);
  write(lunit6,
    "(20x,'LATEST VOLTAGE =',e13.4,10x,'PRECEDING VOLTAGE =',e13.4,'.')"),
    flstat(15), flstat(16);
  if (lstat(12) > 1) {
    goto statement_6220;
  }
  write(lunit6,
    "(5x,'OF COURSE SINCE TROUBLE WAS SPOTTED UPON AN EXAMINATION OF THE USER'"
    "'S VERY FIRST CARD OF THE CHARACTERISTIC,',/,5x,"
    "'THE ''PRECEDING CARD'' REFERS TO THE IMPLIED POINT (0, 0) WHICH REPRESEN"
    "TS THE ORIGIN.   IN THIS CASE, THE USER''S',/,5x,"
    "'TROUBLE STEMS FROM HIS FAILURE TO PUNCH A POSITIVE PAIR OF VALUES (I, V)"
    " ON HIS FIRST CARD OF THE CHARACTERISTIC.')");
  goto statement_6220;
  statement_6072:
  write(lunit6,
    "(5x,'THE USER HAS BEEN INPUTTING A TYPE-97 (STAIRCASE) TIME-VARYING RESIS"
    "TANCE ELEMENT, AND HAS VIOLATED ONE OF',/,5x,"
    "'THE DATA RULES PERTAINING THERE TO.   IN PARTICULAR, THE LAST-READ DATA "
    "CARD HAS A NONPOSITIVE VALUE OF',e13.4,/,5x,"
    "'PUNCHED IN COLUMNS 9-16.   SUCH A NONPOSITIVE RESISTANCE FOR A PORTION O"
    "F THE TIME-VS.-RESISTANCE CHARACTERISTIC',/,5x,"
    "'IS INTERPRETED AS A DATA-PUNCHING ERROR BY THE EMTP')"),
    flstat(16);
  goto statement_6220;
  statement_6073:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD HAS BEEN TAKEN BY THE EMTP TO BE A SOURCE CA"
    "RD, SPECIFYING A GENERATOR OF TYPE ',i2,/,5x,'LOCATED ON BUS ''',a6,"
    "'''.   NOW FOR SUCH A SOURCE, COLUMNS 11-20 ARE TO BE PUNCHED WITH THE AM"
    "PLITUDE (FOR',/,5x,"
    "'A TYPE-14 SINUSOIDAL SOURCE, THIS IS THE PEAK VALUE).   BUT THE USER HAS"
    " PUNCHED A ZERO, OR LEFT THE FIELD BLANK.',/,5x,"
    "'WHILE SUCH A CASE COULD EASILY BE SOLVED, THE EMTP''S SUPERBLY-HONED PER"
    "SPICACITY IS OFFENDED BY SUCH AN IDEA.',/,5x,"
    "'AFTER ALL, IF A VOLTAGE SOURCE IS INVOLVED, ZERO AMPLITUDE MEANS PERMANE"
    "NT GROUNDING, IN WHICH CASE  ''      ''')"),
    lstat(16), bus1;
  write(lunit6,
    "(5x,'(6 BLANK CHARACTERS AS BUS NAME) OR A SWITCH TO GROUND SHOULD BE USE"
    "D, FOR CLARITY.   IF A CURRENT SOURCE',/,5x,"
    "'IS INVOLVED, ZERO AMPLITUDE MEANS THAT THE SOURCE DOESN''T EXIST AT ALL."
    "   EITHER WAY, THE USER SHOULD CORRECT THIS',/,5x,"
    "'''AESTHETIC DIFFICULTY'', AND TRY AGAIN.   WHO KNOWS, NEXT TIME THE JOB "
    "MAY RUN FURTHER.')");
  goto statement_6220;
  statement_6074:
  write(lunit6,
    "(5x,'WHILE SOLUTION OF THIS PROBLEM COULD CONTINUE, THE EMTP HAS BECOME S"
    "USPICIOUS OF A DATA ''MISUNDERSTANDING'' ON',/,5x,"
    "'THE PART OF THE USER.   NOTE THAT THE TERMINATION TIME OF THE STUDY ( ''"
    "TMAX'' ) IS NONPOSITIVE, INDICATING THAT',/,5x,"
    "'ONLY A SINUSOIDAL STEADY-STATE SOLUTION IS DESIRED.   THE VALUE OF  ''TM"
    "AX''  ACTUALLY READ FROM COLUMNS 9-16 OF',/,5x,"
    "'THE FIRST MISCELLANEOUS DATA CARD IS',e13.4,'.   YET OF THE',i3,"
    "' SOURCES WHICH THE USER HAS',/,5x,"
    "'INPUTTED, NONE IS A SINUSOIDAL SOURCE WHICH IS TO BE PRESENT IN THE STEA"
    "DY-STATE (FOR TIME LESS THAN ZERO).')"),
    flstat(15), lstat(16);
  write(lunit6,
    "(5x,'RECALL THAT  ''TSTART''  OF COLUMNS 61-70 OF THE SOURCE CARD MUST BE"
    " PUNCHED WITH A NEGATIVE NUMBER, IF THE',/,5x,"
    "'SOURCE IS TO BE PRESENT IN THE STEADY-STATE SOLUTION.   THUS THERE ARE N"
    "O SOURCES FOR THE PHASOR SOLUTION WHICH',/,5x,"
    "'WAS REQUESTED, AND THE SOLUTION MUST NECESSARILY BE IDENTICALLY ZERO.   "
    "SUCH A DEGENERATE, TRIVIAL PROBLEM WILL',/,5x,'NOT BE ALLOWED.')");
  goto statement_6220;
  statement_6075:
  write(lunit6,
    "(5x,'THE USER HAS BEEN INPUTTING FREQUENCY-DEPENDENT LINE CONSTANTS TO TH"
    "E WEIGHTING-FUNCTION SUPPORTING',/,5x,"
    "'PROGRAM, IN ORDER TO CALCULATE  A1(T)  AND  A2(T)  FOR THE ZERO-SEQUENCE"
    " MODE OF A DISTRIBUTED-PARAMETER LINE.')");
  write(lunit6,
    "(5x,'BUT THE LAST-READ DATA CARD HAS GOTTEN HIM IN TROUBLE.   COLUMNS 1-1"
    "0 (THE RESISTANCE FIELD, R) ARE BLANK',/,5x,"
    "'OR ZERO, WHILE COLUMNS 11-20 (THE INDUCTANCE FIELD, L) CONTAIN THE NONZE"
    "RO FLOATING-POINT NUMBER',e14.4,'   .',/,5x,"
    "'NOW IF THIS CARD WAS MEANT TO BE THE BLANK CARD TERMINATING THE LINE-CON"
    "STANTS INPUT, THE USER SHOULD REMOVE',/,5x,"
    "'THE PUNCHES FROM COLUMNS 11-20, AND RESUBMIT THE JOB.   IF ON THE OTHER "
    "HAND THIS CARD WAS INTENDED TO BE A',/,5x,"
    "'LINE-CONSTANTS CARD, THE USER HAD BETTER RE-THINK THE MATTER.   RESISTAN"
    "CE IS THE PARAMETER WHICH PROVIDES THE')"),
    flstat(15);
  write(lunit6,
    "(5x,'DAMPING IN THE ZERO-SEQUENCE NETWORK WHICH INCREASES DRAMATICALLY WI"
    "TH FREQUENCY, AND IS A CRUCIAL INGREDIENT',/,5x,"
    "'TO THIS SOPHISTICATED DISTRIBUTED-LINE REPRESENTATION.   THE EMTP WILL N"
    "OT ALLOW THE USER TO CALCULATE WEIGHTING',/,5x,"
    "'FUNCTIONS WITHOUT RESISTANCE PRESENT.   IT IS NOT EVEN CLEAR IF THE INVE"
    "RSE FOURIER TRANSFORMATION LOGIC IS VALID',/,5x,"
    "'FOR SUCH A CASE, SINCE WOULD NOT THE IMPULSE RESPONSE OF SUCH A DISTORTI"
    "ONLESS LINE PRODUCE AN IMPULSE FOR  A1.',/,5x,"
    "'IN THIS CASE, RE-RUN A LINE-CONSTANTS PROGRAM TO CALCULATE LEGITIMATE LI"
    "NE CONSTANTS, AND THEN TRY THIS JOB AGAIN.')");
  goto statement_6220;
  statement_6076:
  write(lunit6,
    "(5x,'THE EMTP LOGIC HAS INTERPRETED THE LAST-READ DATA CARD TO BE PART OF"
    " THE SPECIFICATION CARDS FOR PLOTTED OUTPUT.',/,5x,"
    "'BUT THE TYPE-CODE READ FROM COLUMNS 1-2 CANNOT BE ACCEPTED.   A VALUE OF"
    " ',i2,' WAS READ, WHICH DOES NOT',/,5x,"
    "'CORRESPOND TO ANY OF THE LEGITIMATE EXISTING CODES (0, 1, 2).   IF THE C"
    "ARD IN QUESTION REALLY IS NOT A PLOT CARD,',/,5x,"
    "'THE USER MUST DISCOVER HOW HIS DATA DOES NOT CONFORM TO THE ASSUMED INPU"
    "T SEQUENCING, AND RECTIFY THE ERROR.',/,5x,"
    "'THE CORRECT NUMBER OF, AND PLACEMENT OF, BLANK DELIMITER CARDS IS A NOTO"
    "RIOUS CAUSE OF DATA-SYNCHRONIZATION TROUBLE.')"),
    lstat(16);
  goto statement_6220;
  statement_6077:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD HAS BEEN TAKEN BY THE EMTP TO BE A BRANCH CA"
    "RD FOR CONDUCTOR NUMBER ',i2,' OF A',/,5x,"
    "'DISTRIBUTED-PARAMETER TRANSMISSION LINE.   THE USER IS IN TROUBLE BECAUS"
    "E OF AN INCONSISTENT LINE-LENGTH WHICH',/,5x,"
    "'HE HAS PUNCHED IN COLUMNS 45-50 OF THIS LAST-READ CARD.   THE FIRST CARD"
    " FOR THIS MULTIPHASE LINE CARRIES A LENGTH',/,5x,'OF ',e13.4,"
    "', WHILE THE LAST-READ CARD IS FOR LENGTH ',e13.4,"
    "'.   GET IT ALL TOGETHER, GUY, AND CORRECT',/,5x,"
    "'THIS CONTRADICTION.   THE EASIEST WAY IS TO PUT THE CORRECT LENGTH ON TH"
    "E FIRST (ZERO-SEQUENCE) CARD ONLY, AND')"),
    lstat(14), flstat(15), flstat(16);
  write(lunit6,
    "(5x,'THEN LEAVE COLUMNS 45-50 OF THE OTHER CARDS BLANK.   SUCH A BLANK OR"
    " ZERO LENGTH IS INTERPRETED BY THE EMTP AS A',/,5x,"
    "'DEFAULT VALUE, MEANING THE SAME LENGTH AS ON THE FIRST CARD FOR THE DIST"
    "RIBUTED LINE.')");
  goto statement_6220;
  statement_6078:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD IS FOR THE FIRST CONDUCTOR (OR MODE) OF A DI"
    "STRIBUTED-PARAMETER TRANSMISSION LINE.',/,5x,"
    "'THE FIELD OF COLUMNS 45-50 IS SUPPOSED TO BE PUNCHED WITH THE LINE LENGT"
    "H, WITH A VALUE OF ',e13.4,' READ',/,5x,"
    "'BY THE EMTP FROM THE USER''S CARD.   THOU SHALT NOT INPUT TRANSMISSION L"
    "INES HAVING NONPOSITIVE LENGTH, GOOD BUDDY.')"),
    flstat(16);
  goto statement_6220;
  statement_6079:
  write(lunit6,
    "(5x,'SINCE AN INTERACTIVE EMTP VERSION IS NOT',"
    "' BEING USED, ILLEGAL DATA CARD SHOWN',"
    "' BEFORE \"ERROR\" HEADING MUST BE CORRECTED',/,5x,"
    "'AFTER THE PROGRAM STOPS, AND THEN CASE',"
    "' MUST BE RE-RUN.  TOO BAD (INTERACTIVE',"
    "' CORRECTION MIGHT HAVE BEEN POSSIBLE).')");
  stoptp(cmn);
  statement_6080:
  write(lunit6,
    "(5x,'ASSOCIATED WITH THE STEADY-STATE PHASOR SOLUTION IS A BIAS APPLIED T"
    "O NODE NUMBERS OF SOURCES.   THE BUS TABLES',/,5x,'ARE DIMENSIONED AT',"
    "i6,', WHICH IS OVER ONE THIRD OF THE LARGEST INTEGER PERMITTED FOR THIS P"
    "ROGRAM CONVERSION.',/,5x,"
    "'THE LATTER FIGURE IS STORED IN VARIABLE  ''INTINF'' ,  WHICH FOR THIS CO"
    "NVERSION WAS GIVEN A VALUE OF',i6,'.   THE',/,5x,"
    "'EMTP WONDERS HOW IN THE HELL THE USER CAN HAVE SO MANY BUSSES, OR SUCH S"
    "HORT INTEGERS.   GO SEE PROGRAM MAINTENANCE',/,5x,"
    "'ABOUT THIS PROBLEM, FELLA, .... FAST.')"),
    lbus, cmn.intinf;
  goto statement_6220;
  statement_6081:
  write(lunit6,
    "(5x,'THE USER''S FIRST MISCELLANEOUS DATA CARD IMPLIES A TRANSIENT SIMULA"
    "TION OF (IN E-FIELD NOTATION)',e15.6,/,5x,"
    "'STEPS.   THIS EXCEEDS THE LIMIT  ''INTINF''  FOR INTEGER NUMBERS FOR THI"
    "S PROGRAM CONVERSION OF (IN E-FIELD NOTATION)',/,1x,e15.6,"
    "'.   THE CASE THUS CAN NOT BE RUN, BECAUSE',/,5x,"
    "'WE CAN NOT COUNT HIGH ENOUGH TO COUNT THE FINAL TIME STEP.   THE AFOREME"
    "NTIONED NUMBER OF SOLUTION STEPS',/,5x,"
    "'IS CALCULATED BY DIVIDING THE USER''S  ''TMAX''  (COLUMNS 9-16 OF THE FI"
    "RST MISC. DATA CARD) OF',e13.4,' SECONDS',/,5x,"
    "'BY HIS TIME-STEP  ''DELTAT''  (COLUMNS 1-8 OF THE SAME CARD) OF',e13.4,"
    "'.   IF THE USER DOES NOT UNDERSTAND')"),
    flstat(15), flstat(16), cmn.tmax, cmn.deltat;
  write(lunit6,
    "(5x,'THE ERROR OF HIS WAYS, HE HAD BETTER PAY A CALL TO HIS FRIENDLY NEIG"
    "HBORHOOD PROGRAM MAINTENANCE MAN.')");
  goto statement_6220;
  statement_6082:
  write(lunit6,
    "(5x,'THE USER HAS OVERFLOWED STORAGE WITHIN THE LINE-CONSTANTS SUPPORTING"
    " PROGRAM.   FOR THE CURRENT PROGRAM',/,5x,"
    "'VERSION, ONE IS LIMITED TO CASES HAVING NOT OVER',i4,"
    "' CONDUCTORS.   STORAGE FOR THE ARRAYS IN QUESTION HAS',/,5x,"
    "'BEEN OPTIMALLY (AND DYNAMICALLY) ALLOCATED SO AS TO USE AS MUCH OF THE E"
    "MTP CORE STORAGE AS IS AVAILABLE.   IT THUS',/,5x,"
    "'IS NOT THE FAULT OF THE LINE-CONSTANTS SUPPORTING PROGRAM ITSELF, BUT RA"
    "THER OF THE OVERALL EMTP DIMENSIONING, THAT',/,5x,"
    "'THIS DATA CASE MUST BE REJECTED.   GO PROCURE OR MAKE ANOTHER PROGRAM VE"
    "RSION WHICH HAS MORE TOTAL TABULAR')"),
    lstat(15);
  write(lunit6,
    "(5x,'STORAGE SPACE, AND TRY THE JOB OVER AGAIN.   REMEMBER, THE LINE CONS"
    "TANTS CALCULATION REQUIRES THE STORAGE',/,5x,"
    "'OF FULL MATRICES, SO MEMORY REQUIREMENTS GO UP APPROXIMATELY AS THE SQUA"
    "RE OF THE NUMBER OF CONDUCTORS.')");
  goto statement_6220;
  statement_6083:
  write(lunit6,
    "(5x,'FOR INPUTTING CONDUCTOR DATA OF A LINE-CONSTANTS CASE, DATA-FIELD  '"
    "'XTYPE''  OF COLUMNS 17-18 CAN BE PUNCHED',/,5x,"
    "'WITH A  ''4'' .   IF THIS BE THE CASE, THE EMTP EXPECTS A SPECIFICATION "
    "FOR THE SKIN-EFFECT CALCULATION TO BE PUNCHED',/,5x,"
    "'IN COLUMNS 4-8 (DATA FIELD  ''RTYPE'' ).   BUT THE USER HAS LEFT FIELD  "
    "''RTYPE''  BLANK (OR HAS PUNCHED A ZERO, WHICH',/,5x,"
    "'IS NO BETTER), INDICATING THAT NO SKIN-EFFECT CORRECTION IS TO BE MADE F"
    "OR CONDUCTOR NUMBER',i3,' OF THE SORTED',/,5x,"
    "'INPUT LIST.   THIS CONTRADICTORY SITUATION IS NOT PERMITTED.   RECONCILE"
    " THE DATA FIELDS  ''XTYPE''  AND  ''RTYPE'' ,')"),
    lstat(15);
  write(lunit6, "(5x,'AND TRY AGAIN.')");
  goto statement_6220;
  statement_6084:
  write(lunit6,
    "(5x,'THE JUST-PRINTED CONDUCTOR HAS GEOMETRICAL X-Y POSITIONING (I.E., HO"
    "RIZONTAL DISTANCE AND HEIGHT) WHICH IS',/,5x,"
    "'IDENTICAL WITH THAT OF CONDUCTOR NUMBER',i3,"
    "' OF THE SORTED INPUT.   THOU SHALT NOT PLACE TWO OR MORE SOLID',/,5x,"
    "'OBJECTS IN THE SAME SPACE AT THE SAME TIME, FELLA.')"),
    lstat(15);
  goto statement_6220;
  statement_6085:
  write(lunit6,
    "(5x,'THE USER HAS FAILED TO INPUT A CONDUCTOR FOR CIRCUIT NUMBER',i3,"
    "'.   REMEMBER, CIRCUIT NUMBERS MUST SPAN',/,5x,"
    "'THE FULL RANGE OF NUMBERS FROM UNITY THROUGH THE HIGHEST CONDUCTOR NUMBE"
    "R, WITHOUT ANY GAPS (UNUSED NUMBERS) IN',/,5x,"
    "'BETWEEN.   RENUMBER THE CONDUCTORS, AND TRY AGAIN.')"),
    lstat(15);
  goto statement_6220;
  statement_6086:
  write(lunit6,
    "(5x,'GO SEE PROGRAM MAINTENANCE ABOUT THIS ONE, FAST.   THE CASE HAS STOP"
    "PED INSIDE SUBROUTINE \"REDU44\" OF THE LINE',/,5x,"
    "'CONSTANTS CALCULATION, WITH DIAGONAL ELEMENT OF ROW',i3,' EQUAL TO',"
    "e14.5,', WHICH IS LESS THAN HERMANN''S',/,5x,"
    "'BUILD-IN FIXED TOLERANCE OF  1.0E-8 .   PARAMETERS  ''N''  AND  ''M''  A"
    "RE EQUAL TO ',2i5,'.')"),
    lstat(15), flstat(16), lstat(13), lstat(14);
  goto statement_6220;
  statement_6087:
  write(lunit6,
    "(5x,' BIG TROUBLE.   THE COMPUTER OPERATING',"
    "' SYSTEM HAS INTERRUPTED EMTP EXECUTION.',"
    "'   THIS EMTP SOLUTION IS HEREBY FATALLY',/,5x,"
    "' WOUNDED.   IF MORE INFORMATION ABOUT',"
    "' THE INTERRUPT IS KNOWN, IT WILL BE',"
    "' FOUND IMMEDIATELY PRECEDING THE FIRST',/,5x,"
    "' \"ERROR  ERROR ....\"  LINE ABOVE.   IF',"
    "' THIS COMPUTER SYSTEM CAN SKIP TO A',"
    "' FOLLOWING DATA CASE, IT WILL (BELOW).')");
  goto statement_6220;
  statement_6088:
  write(lunit6,
    "(5x,'THIS IS A STATISTICAL-OVERVOLTAGE STUDY, IN WHICH ALL SOLUTIONS ARE "
    "NOW COMPLETED, AND THE EMTP IS READY TO',/,5x,"
    "'PERFORM THE FINAL STATISTICAL PROCESSING (CALCULATION OF CUMULATIVE DIST"
    "RIBUTION FUNCTIONS, ETC.).   TO DO THIS,',/,5x,'THE OUTPUT VECTORS (',i3,"
    "' CELLS LONG) FOR ALL OF THE ENERGIZATIONS (',i3,"
    "' IN NUMBER) MUST BE SIMULTANEOUSLY',/,5x,"
    "'STORED IN CORE.   THIS IS THE DOMINANT DEMAND FOR MEMORY.   THERE ALSO I"
    "S THE NEED TO STORE VARIOUS VECTORS (A')"),
    lstat(32), nenerg;
  write(lunit6,
    "(5x,'LINEAR OVERHEAD).   TOTAL MEMORY REQUIREMENTS ARE GIVEN BY THE FOLLO"
    "WING FORMULA ....',/,10x,"
    "'STORAGE  =  9*KSWTCH  +  (NENERG +4)*NVAR  +  NC  +  NTOT  +  2*LIMINC',"
    "/,5x,'WHERE  ...',/,10x,'KSWTCH  =',i4,"
    "'  =  NUMBER OF SWITCHES IN THE EMTP DATA CASE',/,10x,'NENERG  =',i4,"
    "'  =  NUMBER OF ENERGIZATIONS')"),
    cmn.kswtch, nenerg;
  write(lunit6,
    "(10x,'NVAR    =',i4,"
    "'  =  NUMBER OF OUTPUT VARIABLES FOR THE ENERGIZATION SIMULATIONS',/,10x,"
    "'NC      =',i4,"
    "'  =  NUMBER OF BRANCH OUTPUT VARIABLES FOR THE ENERGIZATION SIMULATIONS'"
    ",/,10x,'NTOT    =',i4,"
    "'  =  TOTAL NUMBER OF NETWORK NODES (INCLUDING GROUND)',/,10x,"
    "'LIMINC  =',i4,"
    "'  =  MAXIMUM NUMBER OF COMPARTMENTS FOR ANY ONE STATISTICAL TABULATION.'"
    ")"),
    lstat(32), cmn.nc, cmn.ntot, lstat(14);
  write(lunit6,
    "(5x,'BUT THIS REQUIREMENT TOTALS',i7,"
    "'   CELLS, WHICH EXCEEDS THE AVAILABLE',i7)"),
    lstat(15), lstat(16);
  write(lunit6,
    "(5x,'CELLS OF WORKING SPACE.   TO RUN THIS CASE WITHOUT INCREASING THE EM"
    "TP DIMENSIONS, THE USER MUST EITHER',/,5x,"
    "'DECREASE THE NUMBER OF ENERGIZATIONS, OR DECREASE THE NUMBER OF OUTPUT Q"
    "UANTITIES, OR BOTH.   ALTERNATIVELY, THE',/,5x,"
    "'USER MAY BE WILLING TO INCREASE PROGRAM DIMENSIONS, IN WHICH CASE ANY OF"
    " THE INDEPENDENT LISTS CAN BE INCREASED',/,5x,"
    "'(ALL ARE EQUALLY GOOD, DIRECTLY CONTRIBUTING TO THE STORAGE IN QUESTION)"
    ".')");
  goto statement_6220;
  statement_6089:
  write(lunit6,
    "(5x,'THE LAST-READ CARD IS A SWITCH-CARD, BEARING THE KEY WORD  ''STATIST"
    "ICS''  IN COLUMNS 55-64.   THE SWITCH IS',/,5x,"
    "'THUS A CIRCUIT-BREAKER POLE, FOR WHICH THE CLOSING TIME IS TO BE A RANDO"
    "M VARIABLE.   BUT EITHER THE SPECIFIED',/,5x,"
    "'VARIABLE MEAN (PUNCHED IN FIELD  ''TCLOSE'' ,   COLUMNS 15-24) OR THE ST"
    "ANDARD DEVIATION (FIELD  ''TOPEN'' ,  COLUMNS',/,5x,"
    "'25-34) HAS BEEN PUNCHED AS NEGATIVE, WHICH IS NOT ALLOWED.   THE TWO VAL"
    "UES READ ARE',e14.5,' AND',/,5x,e14.5,', RESPECTIVELY.')"),
    flstat(15), flstat(16);
  if (lstat(15) == 4433) {
    write(lunit6,
      "(5x,'====  CORRECTION  ====  THE PROBLEM',"
      "' SWITCH IN QUESTION IS NOT THE LAST-',"
      "'READ ONE, BUT RATHER SWITCH NUMBER',i5,/,5x,"
      "'                        IN ORDER OF',"
      "' INPUT.  IN FACT, ALL SWITCHES HAVE',' BEEN READ BY NOW.')"),
      lstat(14);
  }
  goto statement_6220;
  statement_6090:
  write(lunit6,
    "(5x,'THE EMTP HAS JUST BEGUN READING DATA FOR THE CONVERSION OF AN RMS CU"
    "RRENT-VOLTAGE SATURATION CURVE INTO',/,5x,"
    "'CURRENT-FLUX FORM.   BUT ILLEGAL VALUES FOR EITHER  ''VBASE''  OR  ''PBA"
    "SE''  HAVE BEEN READ FROM THE LAST-READ DATA',/,5x,"
    "'CARD (COLUMNS 9-16  AND  17-24, RESPECTIVELY).   BOTH OF THESE FIELDS MU"
    "ST BE PUNCHED WITH POSITIVE NUMBERS.',/,5x,"
    "'BUT THE EMTP HAS READ VALUES OF',e14.4,' AND',e14.4,"
    "' FOR THESE VARIABLES, RESPECTIVELY.')"),
    flstat(14), flstat(15);
  statement_6220:
  cmn.lastov = nchain;
  nchain = cmn.nfrfld + 50;
  if (iprsup >= 1) {
    write(lunit6, "('  \"EXIT  MODULE OVER52.\"')");
  }
  statement_99999:;

}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
over53(
  common& cmn) try
{
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  fem::str<8>& bus5 = cmn.bus5;
  fem::str<8>& bus6 = cmn.bus6;
  double& deltat = cmn.deltat;
  const auto& flstat = cmn.flstat;
  const auto& ipntv = cmn.ipntv;
  const auto& lstat = cmn.lstat;
  const auto& iprsov = cmn.iprsov;
  int& kburro = cmn.kburro;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& kswtch = cmn.kswtch;
  int& numref = cmn.numref;
  int& nenerg = cmn.nenerg;
  //
  auto& lunit6 = cmn.lunit6;
  int n1 = fem::int0;
  auto& epomeg = cmn.epomeg;
  double d1 = fem::double0;
  int n2 = fem::int0;
  int i = fem::int0;
  int n9 = fem::int0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  static const char* format_7094 =
    "(5x,'THE LAST-READ DATA CARD HAS BEEN TAKEN BY THE T.P. TO BE A SWITCH CA"
    "RD, WITH CLOSING TIME TO BE DETERMINED',/,5x,"
    "'RANDOMLY AS PART OF A STATISTICAL OVERVOLTAGE STUDY.   BUT THE MEAN CLOS"
    "ING TIME OF',e13.4,'  SECONDS AND THE',/,5x,'STANDARD DEVIATION OF',"
    "e13.4,"
    "'  SECONDS ARE SUCH THAT SWITCH CLOSING TIMES LESS THAN ZERO WOULD NOT BE"
    " TOTALLY',/,5x,"
    "'UNEXPECTED.   THE MEAN MUST NOT BE LESS THAN  3.0  TIMES THE STANDARD DE"
    "VIATION, IF THE DATA IS TO BE ACCEPTABLE')";
  static const char* format_7099 =
    "(5x,'THE EMTP HAS FINISHED THE CALCULATION OF WEIGHTING FUNCTIONS  A1(T) "
    " AND  A2(T)  FOR THE USER=S FREQUENCY-',/,5x,"
    "'DEPENDENT LINE-MODE.   NOW THE PROGRAM IS READY TO OUTPUT THESE FUNCTION"
    "S --- ON PUNCHED CARDS, IF THE USER HAS',/,5x,"
    "'GIVEN VARIABLE  =IPUNCH=  (OF COLUMNS 33-40 OF THE SECOND DATA CARD) A V"
    "ALUE OF ZERO.   BUT THIS IS NOT POSSIBLE',/,5x,"
    "'WITHIN THE  =F=-FORMAT FIELDS WHICH HAVE BEEN PROVIDED, WITHOUT OVERFLOW"
    " OCCURRING.')";
  static const char* format_7125 =
    "(5x,'AS PART OF THE USER''S TACS DATA WHICH HAS NOW BEEN COMPLETELY READ "
    "BY THE EMTP, THERE WAS A TYPE-',i2,' TACS',/,5x,"
    "'SOURCE CARD WHICH BORE THE 6-CHARACTER ALPHANUMERIC NAME  ''',a6,"
    "'''  IN COLUMNS 3-8.   NOW, BY DEFINITION, THIS',/,5x,"
    "'FIELD MUST BE PUNCHED WITH A NODE NAME (A6 FORMAT) OF THE EMTP ELECTRICA"
    "L NETWORK WHICH IS A PART OF THIS ''HYBRID''',/,5x,'DATA CASE.')";
  static const char* format_7130 =
    "(5x,'THE EMTP IS IN THE PROCESS OF INPUTTING THE USER''S TACS SUPPLEMENTA"
    "L-VARIABLE DATA CARDS, WITH THE LAST-READ',/,5x,"
    "'SUCH DATA CARD BEING IN ERROR.   SPECIFICALLY, THE USER HAS ATTEMPTED TO"
    " DEFINE A SUPPLEMENTAL VARIABLE HAVING',/,5x,'6-CHARACTER NAME  ''',a6,"
    "'''  (READ FROM COLS. 3-8 OF THE CARD)')";
  static const char* format_7147 =
    "(1x,100('-'),/,/,5x,'THIS SWITCH MAKES REFERENCE TO THE NON-',"
    "'EXISTING CONTROL TACS VARIABLE  ''',a6,'''',/,/,1x,100('-'))";
  static const char* format_7228 =
    "(5x,'BEEN OBSERVED.   SPECIFICALLY, THE TROUBLE HAS ARISEN WHILE ELIMINAT"
    "ING TO THE LEFT OF THE DIAGONAL ON ROW',i4,/,5x,"
    "'OF THE MATRIX, WHICH CORRESPONDS TO THE EQUATION THAT WAS WRITTEN FOR TH"
    "E TACS BLOCK WHICH HAS THE VARIABLE',/,5x,'NAMED  ''',a6,"
    "'''  FOR AN OUTPUT.   NOW, THE ORIGINAL DIAGONAL ELEMENT VALUE WAS',"
    "e14.5)";
  static const char* format_7236 =
    "(5x,'YET NONE OF THE FIVE AVAILABLE DATA FIELDS WHICH DEFINE THE INPUTS T"
    "O THIS BLOCK HAVE BEEN USED (ALL ASSOCIATED',/,5x,"
    "'DATA FIELDS ARE BLANK).   THESE ARE FOR ALPHANUMERIC NAMES, READ FROM CO"
    "LUMNS 12-17, 20-25, 28-33, 36-41, AND 44-49',/,5x,"
    "'USING  A6  FORMATS.   THE EMTP CAN NOT CALCULATE THE OUTPUT OF A BLOCK F"
    "OR WHICH THE INPUT IS A MYSTERY.')";
  static const char* format_7294 =
    "(5x,'IF THE USER REALLY DID DESIRE TO USE THE MEAN AND STANDARD DEVIATION"
    " WHICH GOT HIM INTO TROUBLE HERE, HE IS ADVISED',/,5x,"
    "'OF THE POSSIBILITY OF DELAYING CLOSURE OF ALL SWITCHES BY EXACTLY ONE (O"
    "R MORE) FUNDAMENTAL-FREQUENCY CYCLES.',/,5x,"
    "'PROVIDED ONE IS STARTING FROM THE SINUSOIDAL STEADY STATE, THE ADDED DEL"
    "AY OF AN INTEGER NUMBER OF CYCLES SIMPLY',/,5x,"
    "'DELAYS THE RESPONSE ACCORDINGLY, LEAVING IT OTHERWISE UNCHANGED.   BY AD"
    "DING ONE CYCLE OF FUNDAMENTAL-FREQUENCY TIME')";
  static const char* format_7394 =
    "(5x,'TO THE MEAN OF THE CLOSING TIME OF ALL SWITCHES IN THE DATA CASE, TH"
    "E AFOREMENTIONED PROBLEM OF NEGATIVE CLOSING',/,5x,"
    "'TIMES IS USUALLY ELIMINATED, AND THE CASE CAN BE RUN WITHOUT DIFFICULTY."
    "')";
  static const char* format_7428 =
    "(5x,'MADE AN ERROR IN A FEEDBACK LOOP OF THE TACS CONTROL CIRCUITRY WHICH"
    " CONTAINS THE AFOREMENTIONED TACS BLOCK.',/,5x,"
    "'THE PHYSICAL MEANING ASSOCIATED WITH THIS MATRIX SINGULARITY IS THAT THE"
    " CONTROL SYSTEM IS UNSTABLE.   SINCE',/,5x,"
    "'THE PROBLEM AS POSED HAS NO PHYSICALLY-MEANINGFUL SOLUTION IN THE STEADY"
    "-STATE, EXECUTION IS BEING TERMINATED HERE.')";
  if (iprsup >= 1) {
    write(lunit6, "(' \"BEGIN MODULE OVER53.\" ')");
  }
  if (nchain != 53) {
    goto statement_99999;
  }
  n1 = kill - 90;
  switch (n1) {
    case 1: goto statement_6091;
    case 2: goto statement_6092;
    case 3: goto statement_6093;
    case 4: goto statement_6094;
    case 5: goto statement_6095;
    case 6: goto statement_6096;
    case 7: goto statement_6097;
    case 8: goto statement_6098;
    case 9: goto statement_6099;
    case 10: goto statement_6100;
    case 11: goto statement_6101;
    case 12: goto statement_6102;
    case 13: goto statement_6103;
    case 14: goto statement_6104;
    case 15: goto statement_6105;
    case 16: goto statement_6106;
    case 17: goto statement_6107;
    case 18: goto statement_6108;
    case 19: goto statement_6109;
    case 20: goto statement_6110;
    case 21: goto statement_6111;
    case 22: goto statement_6112;
    case 23: goto statement_6113;
    case 24: goto statement_6114;
    case 25: goto statement_6115;
    case 26: goto statement_6116;
    case 27: goto statement_6117;
    case 28: goto statement_6118;
    case 29: goto statement_6119;
    case 30: goto statement_6120;
    case 31: goto statement_6121;
    case 32: goto statement_6122;
    case 33: goto statement_6123;
    case 34: goto statement_6124;
    case 35: goto statement_6125;
    case 36: goto statement_6126;
    case 37: goto statement_6127;
    case 38: goto statement_6128;
    case 39: goto statement_6129;
    case 40: goto statement_6130;
    case 41: goto statement_6131;
    case 42: goto statement_6132;
    case 43: goto statement_6133;
    case 44: goto statement_6134;
    case 45: goto statement_6135;
    case 46: goto statement_6136;
    case 47: goto statement_6137;
    case 48: goto statement_6138;
    case 49: goto statement_6139;
    case 50: goto statement_6140;
    case 51: goto statement_6141;
    case 52: goto statement_6142;
    case 53: goto statement_6143;
    case 54: goto statement_6144;
    case 55: goto statement_6145;
    case 56: goto statement_6146;
    case 57: goto statement_6147;
    case 58: goto statement_6148;
    case 59: goto statement_6149;
    case 60: goto statement_6150;
    case 61: goto statement_6220;
    default: break;
  }
  statement_6091:
  write(lunit6,
    "(5x,'THE DATA CASE NOW IN ITS FINAL STAGES OF INPUT IS FOR A STATISTICAL "
    "OVERVOLTAGE STUDY, SINCE FIELD  ''NENERG''',/,5x,"
    "'OF COLUMNS 65-72 OF THE 2ND MISCELLANEOUS DATA CARD WAS PUNCHED WITH A P"
    "OSITIVE NUMBER.   YET THE LAST-READ DATA',/,5x,"
    "'CARD REQUESTS THE OUTPUT OF ALL NETWORK NODE VOLTAGES, BY MEANS OF THE  "
    "''1''  PUNCHED IN COLUMN 2.   BUT THE EMTP',/,5x,"
    "'DOES NOT ALLOW THIS COMPLETE VOLTAGE OUTPUT FOR STATISTICAL OVERVOLTAGE "
    "STUDIES.   IF THE USER REALLY WANTS TO LOOK')");
  write(lunit6,
    "(5x,'AT EVERY NODE VOLTAGE IN SUCH A STUDY, HE MUST REQUEST EACH SUCH OUT"
    "PUT INDIVIDUALLY, USING THE SELECTIVE',/,5x,"
    "'NODE VOLTAGE OUTPUT OPTION.')");
  statement_6092:
  write(lunit6,
    "(5x,'THE EMTP LOGIC HAS JUST ATTEMPTED TO READ ANOTHER DATA CARD BY MEANS"
    " OF A CALL TO SUBROUTINE  ''CIMAGE'' .',/,5x,"
    "'BUT NO MORE DATA IS TO BE FOUND ON LOGICAL UNIT NUMBER 5.   AN END-OF-FI"
    "LE MARK HAS BEEN ENCOUNTERED UPON ATTEMPTING',/,5x,"
    "'TO READ FROM THIS UNIT.   EXECUTION MUST BE STOPPED, SINCE DATA WHICH IS"
    " REQUIRED FOR CONTINUATION OF THE STUDY',/,5x,'SIMPLY DOES NOT EXIST.')");
  goto statement_6220;
  statement_6093:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD IS FOR ONE PHASE (MODE) OF A DISTRIBUTED-PAR"
    "AMETER TRANSMISSION LINE.   BUT ONE OR MORE',/,5x,"
    "'OF THE PARAMETER VALUES READ THEREFROM MAKES THE DATA ILLEGAL.   THE FOU"
    "R FIELDS OF COLUMNS 27-50 ARE NOT ALL',/,5x,"
    "'BLANK, SO THIS MODE DATA IS NOT TAKEN BY THE EMTP TO BE A REQUEST FOR A "
    "COPY OF THE PARAMETERS OF THE PRECEDING MODE.',/,5x,"
    "'HENCE COLUMNS 27-32 MUST BE PUNCHED WITH MODE RESISTANCE PER UNIT LENGTH"
    ", COLUMNS 33-44 MUST BE PUNCHED FOR THE')");
  write(lunit6,
    "(5x,'MODE INDUCTANCE AND CAPACITANCE (POSSIBLY DISGUIZED, IN TERMS OF SUR"
    "GE IMPEDANCE, PROPAGATION SPEED, OR',/,5x,"
    "'TRAVEL TIME), AND FINALLY, COLUMNS 45-50 MUST CONTAIN THE LINE LENGTH.  "
    " NOW ONE OR BOTH OF THE TWO FIELDS WHICH',/,5x,"
    "'EQUALLY DIVIDE COLUMNS 33-44 IS NON-POSITIVE, WHICH IS ILLEGAL.   VALUES"
    " READ FROM THE USER''S CARD FOR THESE',/,5x,'TWO FIELDS WERE',e14.4,"
    "' AND',e14.4,' ,   RESPECTIVELY.   REMEMBER, ZERO INDUCTANCE OR')"),
    flstat(14), flstat(15);
  write(lunit6,
    "(5x,'CAPACITANCE (THE CASE WHEN  ''ILINE''  IS ZERO)  IS ILLEGAL BECAUSE "
    "IT IMPLIES INFINITE VELOCITY OF PROPAGATION.',/,5x,"
    "'SIMILAR ABSURDITIES RESULT FOR THE OTHER TWO FORMS OF DISGUIZING INDUCTA"
    "NCE AND CAPACITANCE, IT CAN READILY BE',/,5x,'SEEN.')");
  goto statement_6220;
  statement_6094:
  write(lunit6, format_7094), flstat(14), flstat(15);
  write(lunit6,
    "(5x,'TO THE EMTP IN THE CASE OF GAUSSIAN (NORMAL) DISTRIBUTION OF THE SWI"
    "TCH CLOSING TIMES.   THIS ENSURES',/,5x,"
    "'THAT THERE IS A PROBABILITY OF LESS THAN  0.13  PERCENT FOR ANY PARTICUL"
    "AR SWITCH CLOSING TIME TO BE NEGATIVE',/,5x,"
    "'FOR A NORMAL DISTRIBUTION.   BUT THE USER''S DATA HAS FAILED THIS CHECK,"
    " FOR THE LAST-READ SWITCH.   BECAUSE THE',/,5x,"
    "'EMTP HAS NO PROPER WAY OF HANDLING NEGATIVE SWITCH CLOSING TIMES (THEY A"
    "RE SET TO TIME ZERO, ACTUALLY), THE USER''S',/,5x,"
    "'DATA CASE MUST BE REJECTED.',/,1x)");
  write(lunit6, format_7294);
  write(lunit6, format_7394);
  write(lunit6,
    "(/,5x,"
    "'FOR AN INDEPENDENT SWITCH (FIELDS  ''BUS5''  AND  ''BUS6''  OF COLUMNS 6"
    "5-76 OF THE SWITCH CARD BEING BOTH',/,5x,"
    "'BLANK), THE MEAN CLOSING TIME  ''TBAR''  IS READ FROM COLUMNS  15-24 ,  "
    " AND THE STANDARD DEVIATION  ''SIGMA''  IS',/,5x,"
    "'READ FROM COLUMNS  25-34 .    THIS IS SIMPLE.   BUT SHOULD THE  ''BUS5''"
    "  AND  ''BUS6''  FIELDS BE OTHER THAN BOTH',/,5x,"
    "'BLANK, THEN  ''TBAR''  AND  ''SIGMA''  DEPEND NOT ONLY ON THE COLUMN  15"
    "-34  NUMBERS OF THE SWITCH CARD FOR THE')");
  write(lunit6,
    "(5x,'SWITCH IN QUESTION, BUT ALSO ON ALL OF THE OTHER CORRESPONDING COLUM"
    "N  15-34  NUMBERS AS THE DEPENDENCY CHAIN',/,5x,"
    "'IS TRACED BACK THROUGH PREVIOUSLY-INPUTTED SWITCHES.   IN THIS CASE OF A"
    " DEPENDENT SWITCH,   ''TBAR''  IS THE SUM',/,5x,"
    "'OF THE COLUMN  15-24  NUMBERS IN THE CHAIN, WHILE  ''SIGMA''  IS THE SQU"
    "ARE ROOT OF THE SUM OF THE SQUARES OF THE',/,5x,"
    "'COLUMN  25-36  NUMBERS IN THE CHAIN.')");
  goto statement_6220;
  statement_6095:
  write(lunit6, format_7094), flstat(14), flstat(15);
  write(lunit6,
    "(5x,'THE MEAN MUST NOT BE LESS THAN THE SQUARE ROOT OF THREE TIMES THE ST"
    "ANDARD DEVIATION.   THIS CONDITION WOULD',/,5x,"
    "'GUARANTEE THAT SWITCH CLOSING TIMES WOULD ALWAYS BE POSITIVE, FOR THE UN"
    "IFORM DISTRIBUTION WHICH THE USER HAS',/,5x,"
    "'REQUESTED.   BUT THE USER''S DATA HAS FAILED THIS CHECK, FOR THE LAST-RE"
    "AD SWITCH.   BECAUSE THE',/,5x,"
    "'EMTP HAS NO PROPER WAY OF HANDLING NEGATIVE SWITCH CLOSING TIMES (THEY A"
    "RE SET TO TIME ZERO, ACTUALLY), THE USER''S',/,5x,"
    "'DATA CASE MUST BE REJECTED.',/,1x)");
  write(lunit6, format_7294);
  write(lunit6, format_7394);
  goto statement_6220;
  statement_6096:
  write(lunit6,
    "(5x,'THIS RUN IS BEING TERMINATED DUE TO AN ATTEMPT TO PLOT RESULTS.   TH"
    "E EMTP CAN BE VARIABLY-DIMENSIONED,',/,5x,"
    "'OF COURSE, WITH THE PRESENT VERSION SIMPLY HAVING NO AVAILABLE WORKING S"
    "PACE IN WHICH EVEN THE PLOT-FILE HEADER',/,5x,"
    "'INFORMATION CAN BE STORED.   IF THE USER WANTS TO DO PLOTTING, HE MUST E"
    "ITHER DO IT INTERACTIVELY ON THE CRT, OR',/,5x,"
    "'HE MUST WORK WITH A PROGRAM VERSION WHICH HAS MORE LABELED-COMMON STORAG"
    "E.')");
  write(lunit6,
    "(5x,'MORE SPECIFICALLY, THE SIZE OF THE WORKING AREA IN THIS PARTICULAR N"
    "ON-SOLUTION OVERLAY IS SET BY VARIABLE-',/,5x,"
    "'DIMENSIONING PROGRAM  ''VARDIM''  ACCORDING TO THE RELATION     SIZE = S"
    "ZLAB - OFFSET  .       IN THIS FORMULA, ....',/,10x,"
    "'''SIZE''  =  THE NUMBER OF FLOATING-POINT WORDS OF WORKING SPACE (INSUFF"
    "ICIENT IN THIS CASE),',/,10x,"
    "'''SZLAB''  =  THE NUMBER OF FLOATING-POINT WORDS USED FOR LABELED COMMON"
    " IN THE SOLUTION OVERLAYS,')");
  write(lunit6,
    "(10x,"
    "'''OFFSET''  =  A FIXED, NON-NEGATIVE OFFSET WHICH APPROXIMATELY EQUALS T"
    "HE NUMBER OF FLOATING-POINT WORDS',/,23x,"
    "'BY WHICH THE COMPILED INSTRUCTIONS OF THIS OVERLAY EXCEEDS THE CORRESPON"
    "DING FIGURE FOR THE LONGEST',/,23x,"
    "'SOLUTION OVERLAY (ONE OF THE SECONDARY-LEVEL MODULES).',/,5x,"
    "'SHOULD  ''OFFSET''  EXCEED  ''SZLAB'' ,   THEN  ''SIZE''  IS SET TO UNIT"
    "Y, SO AS TO AVOID COMPILATION ERRORS (FORTRAN',/,5x,"
    "'GENERALLY REQUIRES POSITIVE DIMENSIONS FOR ALL ARRAYS).   RECALL THAT  '"
    "'SZLAB''  IS PRINTED OUT FOR THE USER EVERY')");
  write(lunit6,
    "(5x,'TIME THE EMTP IS EXECUTED, AS PART OF THE HEADER INFORMATION THAT PR"
    "ECEDES THE LISTING OF THE INPUT DATA.',/,5x,"
    "'FOR THE PRESENT CASE IN QUESTION, THE EMTP FINDS  ''SIZE''  EQUAL TO',"
    "i6,' ,   WHILE A MINIMUM OF',i7,'  WORDS',/,5x,"
    "'ARE NEEDED IN ORDER FOR EXECUTION TO CONTINUE BEYOND THE POINT WHERE IT "
    "IS NOW BEING STOPPED.   IF IT IS NOT CLEAR',/,5x,"
    "'AS TO WHAT REMEDIAL ACTION SHOULD BE TAKEN, THE USER IS ADVISED TO SEEK "
    "EXPERIENCED COUNSEL ABOUT THIS MATTER.')"),
    lstat(14), lstat(15);
  write(lunit6,
    "(5x,'A BRIEF CAUTION ABOUT USE OF A MARGINAL WORKING AREA FOR PLOTTING IS"
    " PERHAPS ALSO IN ORDER, HOWEVER.   THE',/,5x,"
    "'AFOREMENTIONED MINIMUM FIGURE SHOULD ALLOW FOR CORRECT PLOTTING, BUT WIL"
    "L GENERALLY PRODUCE REPEATED BUFFER-',/,5x,"
    "'FLUSHING-TYPE SPILLOVER ONTO LOGICAL UNIT NUMBER  9  DURING THE PLOTTING"
    " OF EACH GRAPH, WITH ITS ASSOCIATED',/,5x,"
    "'SLOWDOWN IN EXECUTION SPEED.   IN ORDER TO AVOID ALL SUCH TEMPORARY DISK"
    " STORAGE,   ''SIZE''  CAN BE SET NO SMALLER')");
  write(lunit6,
    "(5x,'THAN TWICE THE NUMBER OF PLOT POINTS OF THE PARTICULAR GRAPH MULTIPL"
    "IED BY THE NUMBER OF CURVES ON THE GRAPH.',/,5x,"
    "'DOUBLE-PRECISION CONVERSIONS (IBM  REAL*8  IS THE COMMON EXAMPLE) CAN GE"
    "NERALLY IGNORE THE JUST-STATED  ''TWICE''',/,5x,"
    "'FACTOR, SINCE PLOTTING-POINT STORAGE FOR USE WITH SOFTWARE PLOTTING ROUT"
    "INES LIKE CALCOMP IS ALMOST INVARIABLY',/,5x,'SINGLE-PRECISION.')");
  goto statement_6220;
  statement_6097:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD HAS AN =E=-FIELD NUMBER WHICH IS NOT RIGHT-A"
    "DJUSTED IN ITS DATA FIELD.',/,5x,"
    "'IN PARTICULAR, EITHER THE LETTER =E=, OR A SIGN FOLLOWING A NUMERAL WAS "
    "FOUND IN THE FIELD',/,5x,'WHICH STARTS IN COLUMN NUMBER',i4,"
    "', WHILE COLUMN NUMBER',i4,"
    "', WHICH IS THE RIGHT-MOST COLUMN OF THE FIELD',/,5x,"
    "'IS NOT PUNCHED EXPLICITELY WITH A DECIMAL DIGIT (I.E., 0, 1, .... 9 ).',"
    "/,5x,"
    "'NOW IT MAY WELL BE THAT SUCH USAGE IS INDEED LEGAL FORTRAN DATA-FORMAT I"
    "NPUT FOR THE USER''S OWN PARTICULAR',/,5x,"
    "'COMPUTER SYSTEM, BUT IT OFFENDS THE KEENLY-HONED SENSIBILITIES OF THE EM"
    "TP (AT WHOSE MERCY THE USER NOW FINDS')"),
    lstat(14), lstat(15);
  write(lunit6,
    "(5x,'HIMSELF, IT MAY BE NOTED).   TOO OFTEN A USER WILL ERRONEOUSLY WIND "
    "UP WITH AN EXPONENT OF TEN WHICH IS IN',/,5x,"
    "'ERROR BY A POWER OF TEN ITSELF, IN SUCH A CASE.   HENCE SUCH DATA IS NOT"
    " ALLOWED BY THE EMTP   REPUNCH THIS DATA',/,5x,"
    "'RECORD, AND TRY AGAIN, FRIEND.')");
  write(lunit6,
    "(5x,'ALTERNATIVELY, A CARD SEQUENCE ERROR MAY HAVE RESULTED IN AN ATTEMPT"
    " TO READ DATA WITH THE WRONG FORMAT.',/,5x,"
    "'CHECK FOR MISSING OR OUT-OF-SEQUENCE DATA.')");
  goto statement_6220;
  statement_6098:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD HAS AN =I=-FIELD NUMBER WHICH IS NOT RIGHT-A"
    "DJUSTED IN ITS DATA FIELD.   IN',/,5x,'PARTICULAR, COLUMN NUMBER',i4,"
    "'  CONTAINS THE CHARACTER  =',a1,'= ,  WHILE COLUMN',i3,', WHICH IS THE',"
    "/,5x,"
    "'RIGHT-MOST COLUMN OF THE FIELD IN QUESTION, IS BLANK.   NOW MAYBE SUCH U"
    "SAGE IS LEGAL FORTRAN INPUT FOR THE USER=S',/,5x,"
    "'COMPUTER SYSTEM, BUT IT OFFENDS THE KEENLY-HONED SENSIBILITIES OF THE EM"
    "TP (AT WHOSE MERCY THE USER NOW FINDS')"),
    lstat(14), bus1, lstat(15);
  write(lunit6,
    "(5x,'HIMSELF, IT MAY BE NOTED).   TOO OFTEN A USER WILL ERRONEOUSLY WIND "
    "UP WITH A VALUE WHICH IS IN ERROR BY',/,5x,"
    "'A POWER OF TEN, IN SUCH A CASE.   HENCE SUCH DATA IS SIMPLY NOT ALLOWED "
    "BY THE EMTP   REPUNCH THIS DATA',/,5x,'RECORD, AND TRY AGAIN, FRIEND.')");
  goto statement_6220;
  statement_6099:
  write(lunit6, format_7099);
  write(lunit6,
    "(5x,'SPECIFICALLY, THE PEAK WEIGHTING FUNCTION VALUES CAN NOT BOTH BE PUN"
    "CHED USING  F10.0  FORMAT.   THE PEAK',/,5x,'VALUES IN QUESTION ARE',/,"
    "10x,'MAX(A1(T)) =',e14.5,10x,'MAX(A2(T)) =',e14.5,' .',/,5x,"
    "'IN SOME WAY, THE USER=S DATA WOULD SEEM TO BE HIGHLY UNUSUAL, AND WORTHY"
    " OF CAREFUL SCRUTINY.   TWO SPECIAL CASES',/,5x,"
    "'WHICH WILL ALWAYS LEAD TO NUMERICAL TROUBLE ARE PERHAPS WORTHY OF MENTIO"
    "N, IN THIS REGARD.   FIRST, AS THE LINE-')"),
    flstat(15), flstat(16);
  write(lunit6,
    "(5x,'LENGTH  =DIST=  (COLUMNS 1-8 OF THE FIRST DATA CARD) APPROACHES ZERO"
    ",    MAX(A1(T))    IS KNOWN TO APPROACH',/,5x,"
    "'INFINITY.   SIMILAR BEHAVIOR WILL ALSO RESULT FOR ANY FIXED-LENGTH LINE,"
    " AS THE IMPULSE ATTENUATION APPROACHES',/,5x,"
    "'ZERO (E.G., LET  R  APPROACH ZERO AND  L  APPROACH A CONSTANT VALUE, FOR"
    " ALL FREQUENCIES).   THE USER IS ADVISED',/,5x,"
    "'TO SEEK EXPERIENCED COUNSEL, IF HE CAN NOT FIND AN OBVIOUS MASSIVE DATA "
    "ERROR ON HIS OWN.')");
  goto statement_6220;
  statement_6100:
  write(lunit6, format_7099);
  write(lunit6,
    "(5x,'SPECIFICALLY, THE WEIGHTING FUNCTIONS EXTEND TOO FAR OUT IN TIME, WI"
    "TH DURATION IN EXCESS OF THE  100000',/,5x,"
    "'MICROSECONDS WHICH CAN BE PUNCHED LEGALLY USING  F10.4  FORMAT.   WITH L"
    "IGHT TRAVELING AT A RATE OF  300 KM',/,5x,"
    "'(186 MILES)  PER MILLISECOND, THIS IS ABSURD FOR A POWER LINE, AND MUST "
    "BE REJECTED.   ELECTRICALLY, THE USER=S',/,5x,"
    "'LINE IS APPROXIMATELY ONE ORDER OF MAGNITUDE LONGER THAN ANYTHING WHICH "
    "IS TYPICAL FOR AMERICAN POWER SYSTEMS.',/,5x,"
    "'THE USER''S WEIGHTING FUNCTIONS HAVE A DURATION OF',e13.4,"
    "'  MICROSECONDS.')"),
    flstat(15);
  write(lunit6,
    "(5x,'THE USER IS REMINDED THAT EVEN IF HE HAS A VERY LONG LINE OF SAY  10"
    "00  MILES, HE IS ADVISED TO BREAK IT UP',/,5x,"
    "'INTO MAYBE FIVE IDENTICAL SEGMENTS OF  200  MILES EACH.   THEN HE DERIVE"
    "S WEIGHTING FUNCTIONS FOR ONE 200-MILE',/,5x,"
    "'SEGMENT, AND USES THE REFERENCE-BRANCH CAPABILITY IN SETTING UP THE EMTP"
    " DATA CASE FOR THE NETWORK IN QUESTION,',/,5x,"
    "'THEREBY SAVING  4/5  ON THE OTHERWISE-REQUIRED WEIGHTING-FUNCTION STORAG"
    "E OF LIST NUMBER  14 .')");
  goto statement_6220;
  statement_6101:
  write(lunit6,
    "(5x,'THE DECISION TO KILL THIS RUN HAS BEEN MADE WITHIN THE DUMMY (I.E., "
    "THE ORIGINAL, THE EMPTY) SUBROUTINE',/,5x,"
    "' ''ANALYT''  WHICH IS CALLED BY SUBROUTINE  ''SUBTS3''  OF OVERLAY 16 (O"
    "VERLAY 18 WHEN USING ECS OVERLAYING OF THE',/,5x,"
    "'TIME-STEP LOOP ON CDC).   THE USER DECLARED HIS INTENT TO USE ANALYTICAL"
    "LY-DEFINED SOURCES AT THE BEGINNING OF',/,5x,"
    "'THIS DATA CASE BY INPUTTING THE SPECIAL  ''ANALYTIC SOURCES''  REQUEST C"
    "ARD.   BUT HE HAS FAILED TO HAVE PROGRAM')");
  write(lunit6,
    "(5x,'MAINTENANCE REPLACE THE ORIGINAL, DUMMY MODULE  ''ANALYT''  BY THE O"
    "NE WHICH HE SHOULD HAVE WRITTEN ESPECIALLY',/,5x,"
    "'FOR THIS DATA CASE.   THE USER NEEDS A MODULE WHICH DEFINES HIS OWN SPEC"
    "IAL SOURCES --- ONE OR MORE SOURCES OF',/,5x,"
    "'TYPE  1  THROUGH  10 ,   DEFINED IN FORTRAN (OR MACHINE LANGUAGE) WITHIN"
    " SUBROUTINE  ''ANALYT'' .')");
  goto statement_6220;
  statement_6102:
  write(lunit6,
    "(5x,'LINEAR BRANCH NUMBER',i4,"
    "'  (IN ORDER OF DATA INPUT) CONNECTS BUS  ''',a6,'''  WITH BUS  ''',a6,"
    "''' .',/,5x,"
    "'DATA VALUES ON THIS CARD ARE FOR A MODE OF THE DISTRIBUTED-PARAMETER LIN"
    "E WHICH IS BEING MODELED WITH RESISTANCE',/,5x,"
    "'LUMPED, ONE HALF IN THE MIDDLE, AND ONE QUARTER AT EACH EACH END (FIELD "
    " ''IPUNCH''  OF COLUMNS 53-54 EQUAL TO -1 ).',/,5x,"
    "'BUT THE TOTAL MODAL LINE RESISTANCE OF',e15.5,"
    "'  OHMS IS UNREASONABLY LARGE WHEN COMPARED WITH THE SURGE')"),
    lstat(15), bus1, bus2, flstat(14);
  write(lunit6,
    "(5x,'(CHARACTERISTIC) IMPEDANCE OF',e15.5,"
    "'  OHMS.   PROGRAM LOGIC CAN NOT HANDLE A RESISTANCE WHICH',/,5x,"
    "'EXCEEDS FOUR TIMES THE CHARACTERISTIC IMPEDANCE.   FOR NORMAL POWER LINE"
    "S, SUCH VALUES ARE ABSURD ANYWAY, SO',/,5x,"
    "'THE USER GETS LITTLE SYMPATHY ON THIS ONE.')"),
    flstat(15);
  goto statement_6220;
  statement_6103:
  if (lstat(12) > 0) {
    write(lunit6,
      "(5x,'POSSIBLE LOSS OF SIGNIFICANCE IN ELIMINATION STEP ',1x,i4,1x,"
      "'IN SUBROUTINE DGELG',/)"),
      lstat(12);
  }
  goto statement_6220;
  statement_6104:
  write(lunit6,
    "(5x,'THE DATA CASE NOW BEING SOLVED INVOLVES ONE OR MORE DYNAMIC SYNCHRON"
    "OUS MACHINE (S.M.) SOURCE COMPONENTS.',/,5x,"
    "'THE ASSOCIATED EQUATIONS (PARK''S OR BLONDEL''S) ARE NONLINEAR, AND MUST"
    " BE SOLVED BY AN ITERATIVE PROCEDURE AT',/,5x,"
    "'EACH TIME STEP.   THIS ITERATION HAS FAILED TO CONVERGE WITHIN THE ITERA"
    "TION LIMIT OF',i5,' ,   FOR DYNAMIC',/,5x,'S.M. NUMBER',i5,"
    "'  (IN ORDER OF INPUT).   THE ITERATION LIMIT IS VARIABLE  ''NIOMAX'' ,  "
    " WHICH CAN BE')"),
    iprsov(37), lstat(12);
  write(lunit6,
    "(5x,'RE-DEFINED DURING THE S.M. DATA INPUT, USING A  ''TOLERANCES''  SPEC"
    "IAL-REQUEST CARD.   THE S.M. IN QUESTION HAS',/,5x,"
    "'PHASE ''A'' CONNECTED TO BUS  ''',a6,"
    "''' .   THE UNACHIEVED TOLERANCE IS VARIABLE  ''EPOMEG'' ,   WHICH HAS VA"
    "LUE',/,5x,e14.3,"
    "' .   THE FRACTIONAL SPEED DISCREPANCY ON THE FINAL ITERATION WAS',e16.7,"
    "' .   ASSUMING',/,5x,"
    "'THAT  ''NIOMAX''  IS REASONABLE (SAY FIVE OR LARGER), THEN THE EFFECT OF"
    " TWO REMAINING VARIABLES MIGHT PROFITABLY')"),
    bus1, epomeg, flstat(14);
  write(lunit6,
    "(5x,'BE CONTEMPLATED.   FIRST, THE USER SHOULD CHECK THAT HIS TIME-STEP S"
    "IZE  ''DELTAT''  IS NOT TOO BIG, SO AS',/,5x,"
    "'TO INSURE THAT THE CHANGE IN SPEED BETWEEN SUCCESSIVE TIME STEPS WILL BE"
    " SMALL.   THIS DATA CASE USED  ''DELTAT'' =',/,5x,e14.3,"
    "' .   SECOND AND MORE SUBTLE IS THE CHOICE OF TOLERANCE  ''EPOMEG'' ,   W"
    "HICH SHOULD NOT BE SET SMALLER',/,5x,"
    "'THAN THE ROUNDOFF LIMITATION WHICH APPLIES TO THE ITERATIVE CORRECTION O"
    "F THE SPEED.')"),
    deltat;
  goto statement_6220;
  statement_6105:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD IS THE FIRST CARD OF CLASS-2 DATA FOR A DYNA"
    "MIC SYNCHRONOUS MACHINE (S.M.) SOURCE',/,5x,"
    "'COMPONENT.   VARIABLE  ''NUMAS''  AS READ FROM COLUMNS 1-2 OF THIS CARD "
    "(USING  I2  FORMAT) HAS VALUE',i5,' .',/,5x,"
    "'THIS IS SUPPOSED TO BE THE NUMBER OF MASSES WHICH MAKE UP THE SHAFT SYST"
    "EM OF THE ROTOR OF THE MACHINE.   BUT',/,5x,"
    "'THIS FIGURE IS NON-POSITIVE .')"),
    lstat(14);
  goto statement_6220;
  statement_6106:
  d1 = 1.0f / cmn.fltinf;
  write(lunit6,
    "(5x,'ERRONEOUS DATA DISCOVERED DURING THE INITIALIZATION OF MULTIPLE S.M."
    " CONNECTED TO BUS','''',a6,'''. THE SPECIFIED',/,5x,"
    "'VALUES OF PARAMETERS ''SMOUTP'' AND/OR ''SMOUTQ'' FOR THE INVOLVED S.M.'"
    "'S ADD UP TO ZERO.,',/,5x,"
    "'RECALL THAT ANY BLANK FIELD USED IN THE ABOVE DATA IS REPLACED BY THE NE"
    "AR-ZERO EMTP TOLERANCE 1.0/FLTINF =')"),
    bus1;
  write(lunit6,
    "(5x,e14.3,"
    "' .   THE USER SHOULD NEVER USE THE NEGATIVE OF THIS VALUE FOR ANY OF THE"
    " FOUR PARAMETERS IN',/,5x,"
    "'QUESTION.   ALSO, HE MUST NOT PUNCH ONE OF THE  ''SMOUTP''  FIELDS SO AS"
    " TO BE THE NEGATIVE OF THE OTHER.   THE',/,5x,"
    "'SAME PROHIBITION APPLIES TO THE TWO  ''SMOUTQ''  VALUES.')"),
    d1;
  goto statement_6220;
  statement_6107:
  write(lunit6,
    "(5x,' FRACTIONAL MASS TORQUE PARAMETERS DO NOT CONFORM',"
    "' TO RULES -- SEE USER MANUAL',/)");
  goto statement_6220;
  statement_6108:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD IS TAKEN BY THE EMTP TO BE A REQUEST FOR AN "
    "AUXILIARY SYNCHRONOUS MACHINE (S.M.) INPUT',/,5x,"
    "'TO TACS.   RECALL THAT SUCH DATA CARDS (IF ANY) COMPLETE THE DATA INPUT "
    "FOR A DYNAMIC S.M., AFTER BEING FOLLOWED',/,5x,"
    "'BY A TERMINATOR RECORD WHICH BEARS THE TEXT  ''FINISH''  IN COLUMNS 3-8."
    "   BUT THE LAST-READ DATA CARD IS ILLEGAL,')");
  if (lstat(16) <= lstat(15)) {
    goto statement_7308;
  }
  write(lunit6,
    "(5x,'SINCE STORAGE FOR SUCH S.M.-TACS INTERFACE VARIABLES HAS BEEN OVERFL"
    "OWED.   THE EXISTING PROGRAM DIMENSION',/,5x,'IS',i4,"
    "' ,   WHICH IS EQUAL TO THE NUMBER OF PREVIOUSLY-DEFINED INTERFACE VARIAB"
    "LES IN ARRAYS  ''ETAC  ''  AND',/,5x,'''ISMTAC'' .')"),
    lstat(15);
  goto statement_6220;
  statement_7308:
  if (lstat(17) > 0) {
    goto statement_7508;
  }
  write(lunit6,
    "(5x,'SINCE THE NAME ''',a6,''' OF THE INTERFACE VARIA',"
    "'BLE (AS READ FROM COLUMNS 3-8 USING A6 FORMAT) IS INVALID.',/,5x,"
    "'ALL SUCH NAMES MUST BE VALID, FOR THEY SERVE AS NAMES OF',"
    "' TACS VARIABLES (FOR TYPE-92 TACS SOURCES).')"),
    bus6;
  goto statement_6220;
  statement_7508:
  write(lunit6,
    "(5x,'SINCE THE DATA READ FROM COLUMNS 1-2 USING  I2',"
    "' FORMAT AND FROM COLUMNS 15-17 USING I3 FORMAT IS INVALID .',/,5x,"
    "'THE READ VALUES WERE....',i4,i5)"),
    lstat(14), lstat(13);
  goto statement_6220;
  statement_6109:
  write(lunit6, "(5x,'UNUSED KILL CODE NUMBER....',i5)"), kill;
  goto statement_6220;
  statement_6110:
  write(lunit6,
    "(5x,'PARAMETER  ''NENERG''  OF THE INTEGER MISCELLANEOUS DATA CARD WAS PU"
    "NCHED NONZERO (VALUE',i5,'  )   FOR THIS',/,5x,"
    "'DATA CASE, REPRESENTING A REQUEST FOR A  ''STATISTICS''  OR A  ''SYSTEMA"
    "TIC''  SIMULATION.   THE LAST-READ DATA CARD',/,5x,"
    "'IS FOR AN EMTP SWITCH, AND IT BEARS ONE OF THE TWO JUST-MENTIONED KEY WO"
    "RDS IN COLUMNS 55-64, WHICH IS FINE.',/,5x,"
    "'BUT THIS IS A DEPENDENT SWITCH, WITH ILLEGAL REFERENCE NAMES  ''',a6,"
    "'''  AND  ''',a6,'''  PUNCHED FOR DATA')"),
    nenerg, bus5, bus6;
  write(lunit6,
    "(5x,'FIELDS  ''BUS5''  AND  ''BUS6''  (COLUMNS 65-76).   THE ORDERED PAIR"
    " OF REFERENCE NAMES CORRESPONDS TO EMTP NODE',/,5x,'NUMBERS',i5,'  AND',"
    "i5,' ,   RESPECTIVELY, WITH A ZERO VALUE MEANING THAT THE ASSOCIATED  A6 "
    " NAME IS',/,5x,"
    "'ILLEGAL (UNRECOGNIZABLE AS A LEGITIMATE EMTP ELECTRICAL NETWORK NODE NAM"
    "E).   IF BOTH OF THE JUST-PRINTED',/,5x,"
    "'INTEGERS ARE POSITIVE, THEN BOTH NAMES ARE LEGITIMATE EMTP NETWORK NAMES"
    ", BUT DO NOT CORRESPOND TO A PREVIOUSLY-')"),
    lstat(15), lstat(16);
  write(lunit6,
    "(5x,'INPUTTED SWITCH.   REMEMBER THAT ORDERING OF THE PAIR OF REFERENCE N"
    "AMES IS CRUCIAL, WITH IT BEING MANDATORY',/,5x,"
    "'THAT THE FIRST REFERENCE NAME  ''BUS5''  MATCH A FIRST SWITCH NAME  ''BU"
    "S1'' ,   ETC. FOR  ''BUS6''  MATCHING  ''BUS2'' .')");
  goto statement_6220;
  statement_6111:
  write(lunit6,
    "(5x,'ONE OF THE WORKING VECTORS WHICH ARE USED TO ASSEMBLE OUTPUT QUANTIT"
    "IES FOR ALL DYNAMIC SYNCHRONOUS MACHINE',/,5x,"
    "'SOURCE COMPONENTS HAS OVERFLOWED.   THE DIMENSIONED LIMIT FOR THE NUMBER"
    " OF  A6  IDENTIFICATION NAMES IS',i6,' ,',/,5x,"
    "'AS IS THE MAXIMUM ALLOWABLE NUMBER OF OUTPUT QUANTITIES.   BUT AFTER FIN"
    "ISHING WITH MACHINE NUMBER',i5,' ,',/,5x,"
    "'THE TWO CORRESPONDING TABLE SIZES ARE',i6,'   AND',i6,"
    "' ,   RESPECTIVELY.   ONE OR BOTH OF THESE TABLE',/,5x,"
    "'SIZES HAS NOW BEEN EXCEEDED.   EXECUTION WILL BE STOPPED.   EITHER REQUE"
    "ST FEWER OUTPUTS, OR REDIMENSION THE TABLES.')"),
    lstat(13), lstat(15), lstat(16), lstat(17);
  goto statement_6220;
  statement_6112:
  write(lunit6,
    "(5x,'WOW.   DOUBLE WOW (WOW, WOW).   THE EMTP HAS FINISHED WITH THE INPUT"
    " OF ALL SWITCH CARDS FOR THIS DATA CASE.',/,5x,'OF THE',i5,"
    "'  SWITCHES, OVER TEN HAD THE KEY WORD  ''STATISTICS''  OR  ''SYSTEMATIC'"
    "'  PUNCHED IN COLUMNS 55-64.',/,5x,"
    "'IN FACT, THERE ARE OVER TEN INDEPENDENT  ''STATISTICS''  OR  ''SYSTEMATI"
    "C''  SWITCHES  ----  DISTINGUISHED BY EITHER',/,5x,"
    "'FIELD  ''BUS5''  (COLS. 65-70)  PUNCHED WITH  ''TARGET'' ,   OR BOTH FIE"
    "LDS  ''BUS5''  AND  ''BUS6''  (COLS. 65-76)')"),
    kswtch;
  write(lunit6,
    "(5x,'LEFT BLANK.   THE EMTP LIMIT IS TEN, HOWEVER, WHICH WAS EXCEEDED BY "
    "SWITCH NUMBER',i5,' ,   WHICH CONNECTS',/,5x,'NODE  ''',a6,"
    "'''  WITH NODE  ''',a6,"
    "''' .   THE EMTP WONDERS WHETHER THE USER REALLY APPRECIATES THE',/,5x,"
    "'SIGNIFICANCE OF TEN INDEPENDENT SWITCHES, OR EQUIVALENTLY, THE VASTNESS "
    "OF A TEN-DIMENSIONAL VECTOR SPACE.',/,5x,"
    "'REMEMBER, EVEN IF ONE QUANTIZED EACH DIMENSION INTO ONLY TWO DISCRETE VA"
    "LUES, TEN INDEPENDENT VARIABLES WOULD')"),
    lstat(14), bus1, bus2;
  write(lunit6,
    "(5x,'YIELD   2**10 = 1024   COMPARTMENTS OR CELLS.   WITH THREE DISCRETE "
    "VALUES, THE FIGURE BECOMES  59049.   AND',/,5x,"
    "'WITH FOUR, IT JUMPS TO THE STAGGERING FIGURE OF  1048576.   THE USER''S "
    "COMPUTER SYSTEM MAY BE FAST, BUT NOT SWIFT',/,5x,"
    "'ENOUGH TO EVEN BEGIN TO REALISTICALLY SAMPLE A TEN-DIMENSIONAL VECTOR SP"
    "ACE IN A REPRESENTATIVE FASHION.   EXECUTION',/,5x,"
    "'WILL NOT BE ALLOWED TO CONTINUE, FOR THIS DATA CASE.')");
  goto statement_6220;
  statement_6113:
  n2 = lstat(13);
  write(lunit6,
    "(5x,'THE DATA CASE NOW BEING PROCESSED IS FOR A  ''SYSTEMATIC''  STUDY, S"
    "INCE INTEGER MISCELLANEOUS DATA PARAMETER',/,5x,"
    "' ''NENERG''  WAS PUNCHED AS A NEGATIVE NUMBER.   USING  I8  FORMAT, A VA"
    "LUE OF',i6,'   WAS READ FOR  ''NENERG''',/,5x,"
    "'FROM COLUMNS 65-72.   BY DEFINITION, THIS IS SUPPOSED TO BE THE NEGATIVE"
    " OF THE NUMBER OF ENERGIZATIONS WHICH',/,5x,"
    "'ARE TO BE RUN.   OF COURSE THIS FIGURE IS DETERMINED BY MULTIPLYING TOGE"
    "THER THE NUMBER OF STEPS TO BE TAKEN')"),
    nenerg;
  write(lunit6,
    "(5x,'BY EACH INDEPENDENT  ''SYSTEMATIC''  SWITCH.   BUT WHEN THE EMTP MUL"
    "TIPLIES TOGETHER ALL SUCH INTEGERS',/,5x,"
    "'WHICH WERE READ USING  I10  FORMAT FROM COLUMNS 35-44 OF  ''SYSTEMATIC''"
    "  SWITCH CARDS, IT FINDS THE PRODUCT TO BE',/,5x,'EQUAL TO',i6,"
    "' .    THIS VALUE IS INCONSISTENT WITH THE AFOREMENTIONED  ''NENERG'' .  "
    "  TO AID THE USER IN',/,5x,"
    "'CORRECTING THIS DISCREPANCY, IT IS MENTIONED THAT THIS DATA CASE HAS',"
    "i5,'  SWITCHES.   IN ORDER OF DATA')"),
    lstat(12), kswtch;
  {
    write_loop wloop(cmn, lunit6,
      "(5x,'INPUT, THE INTEGERS READ FROM THE',i4,"
      "'  INDEPENDENT  ''SYSTEMATIC''  SWITCH CARDS ARE AS FOLLOWS ....',/(1x,"
      "12i10))");
    wloop, numref;
    FEM_DO_SAFE(i, 1, numref) {
      wloop, ipntv(i);
    }
  }
  FEM_DO_SAFE(i, 1, numref) {
    if (ipntv(i) <= 0) {
      goto statement_7513;
    }
  }
  goto statement_6220;
  statement_7513:
  write(lunit6,
    "(5x,'UPON INSPECTING THESE FIGURES, THE EMTP IMMEDIATELY NOTICES THAT NUM"
    "BER',i4,'  IS ILLEGAL.   A VALUE OF',/,5x,i6,"
    "'   IS SEEN, WHICH CERTAINLY IS NOT POSITIVE (AS PER THE USER''S MANUAL I"
    "NSTRUCTIONS).   REMEMBER, ANY  ''SYSTEMATIC''',/,5x,"
    "'SWITCH CARD WHICH HAS EITHER FIELD  ''BUS5''  (COLS. 65-70) PUNCHED WITH"
    "  ''TARGET'' ,   OR BOTH FIELDS  ''BUS5''  AND',/,5x,"
    "'''BUS6''  (COLS. 65-76)  LEFT BLANK, IS AN INDEPENDENT SWITCH.   COLUMNS"
    " 35-44 OF SUCH A SWITCH MUST THEN BE')"),
    i, ipntv(i);
  write(lunit6,
    "(5x,'PUNCHED WITH THE NUMBER OF STEPS (NECESSARILY POSITIVE) WHICH ARE TO"
    " BE TAKEN WITH THIS SWITCH.')");
  goto statement_6220;
  statement_6114:
  write(lunit6, "(' UNUSED.')");
  statement_6115:
  write(lunit6,
    "(5x,'THE USER HAS BEEN INPUTTING ''TACS'' DATA, SPECIFICALLY CARDS WHICH "
    "DEFINE TACS FUNCTION BLOCKS.   YET THE',/,5x,"
    "'LAST-READ DATA CARD HAS AN ILLEGAL INTEGER  ''N''  PUNCHED IN THE FIELD "
    "OF COLUMNS 1-2.   A VALUE OF',i4,'  WAS',/,5x,"
    "'READ, FOR THIS BLOCK HAVING (OUTPUT) VARIABLE NAME  ''',a6,"
    "''' .   SINCE THIS INTEGER DOES NOT EQUAL ONE OF',/,5x,"
    "'THE SPECIAL CODE NUMBERS WHICH ARE USED TO INDICATE SPECIAL BLOCK TYPES "
    "(E.G., N=99 FOR A ZERO-TH ORDER BLOCK), IT')"),
    lstat(14), bus1;
  write(lunit6,
    "(5x,'IS TAKEN BY THE EMTP TO BE THE ORDER OF THE LAPLACE TRANSFER FUNCTIO"
    "N  H(S)  OF THE BLOCK.   BUT THIS MUST',/,5x,"
    "'BE POSITIVE.   ALSO, A LIMIT OF 10-TH ORDER HAS BEEN ARBITRARILY IMPOSED"
    " BY THE EMTP.   IF THE USER REALLY DOES',/,5x,"
    "'HAVE A HIGHER-ORDER  H(S)  THAN 10 (HIGHLY UNLIKELY), HE MUST SIMPLY SPL"
    "IT HIS ORIGINAL  H(S)  INTO TWO OR MORE',/,5x,"
    "'CASCADED SUB-BLOCKS, EACH OF WHICH IS OF ORDER  10  OR LESS.')");
  goto statement_6220;
  statement_6116:
  write(lunit6,
    "(5x,'THE EMTP DATA CASE UNDER CONSIDERATION INCLUDES A TACS REPRESENTATIO"
    "N, THE FUNCTION BLOCKS OF WHICH ARE NOW',/,5x,"
    "'BEING INPUTTED.   NOW, THE LAST TACS FUNCTION BLOCK WHICH WAS READ BY TH"
    "E EMTP HAD (OUTPUT) NAME  ''',a6,'''',/,5x,"
    "'(PUNCHED IN COLUMNS 3-8), AND WAS PURPORTED TO BE A DYNAMIC FUNCTION BLO"
    "CK OF ORDER',i3,'  (PUNCHED IN COLUMNS',/,5x,"
    "'1-2).   THE TACS FUNCTION BLOCK IS CHARACTERIZED BY A LAPLACE TRANSFER F"
    "UNCTION  H(S) ,   WHICH IS A RATIONAL')"),
    bus1, lstat(14);
  if (lstat(17) == 1) {
    goto statement_16116;
  }
  write(lunit6,
    "(5x,'FUNCTION (RATIO OF POLYNOMIALS) OF THE COMPLEX FREQUENCY VARIABLE  '"
    "'S'' .   BY DEFINITION, THE ORDER OF THE',/,5x,"
    "'TACS BLOCK REFERS TO THE ORDER OF THE HIGHEST POLYNOMIAL INVOLVED (EITHE"
    "R NUMERATOR OR DENOMINATOR).   BUT BOTH',/,5x,"
    "'THE NUMERATOR AND DENOMINATOR COEFFICIENTS OF  ''S''  RAISED TO THE POWE"
    "R',i3,'  ARE ZERO.   THE HIGHEST POWER',/,5x,"
    "'OF  ''S''  IS THUS MISSING, COMPLETELY.   THE BLOCK ORDER IS INCONSISTEN"
    "T WITH THE POLYNOMIAL COEFFICIENTS WHICH',/,5x,"
    "'ARE SUPPOSED TO DEFINE THE BLOCK''S  H(S) ,   SO EXECUTION IS BEING TERM"
    "INATED.')"),
    lstat(14);
  goto statement_6220;
  statement_16116:
  write(lunit6,
    "(5x,'FUNCTION (RATIO OF POLYNOMIALS) OF',"
    "' THE COMPLEX FREQUENCY VARIABLE ''S'' .',/,5x,"
    "'HERE, THE ORDER-ZERO COEFFICIENTS',' (OF THE TERMS WITHOUT ''S'')  IN',"
    "' BOTH NUMERATOR AND DENOMINATOR',/,5x,'WERE READ AS  ZERO .           ',"
    "/,5x,'DID THE USER REALLY MEAN THIS,',' THE PROGRAM WONDERS.   DON''T.')");
  goto statement_6220;
  statement_6117:
  n9 = 50;
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD IS THE FIRST BRANCH CARD FOR A MULTI-PHASE L"
    "INE WHICH IS TO BE MODELED USING SEMLYEN',/,5x,"
    "'OR AMETANI RECURSIVE CONVOLUTION FOR THE FREQUENCY-DEPENDENT REPRESENTAT"
    "ION.   SUCH MODELING IS LIMITED TO A',/,5x,'MAXIMUM OF',i4,"
    "'   MODES (COUPLED PHASES).   BUT THIS LIMIT IS EXCEEDED BY THE USER''S R"
    "EQUESTED NUMBER, WHICH',/,5x,'WAS PUNCHED AS',i5,"
    "'   (READ FROM COLUMNS 77-78).   A MAJOR PROGRAMMING EFFORT (INVOLVING SO"
    "ME UNANSWERED')"),
    n9, cmn.ipunch;
  write(lunit6,
    "(5x,'THEORETICAL QUESTIONS) WOULD BE REQUIRED IN ORDER TO EXTEND THIS MOD"
    "ELING LIMITATION, SO THE USER HAS NO OTHER',/,5x,"
    "'ALTERNATIVE THAN DECREASING THE NUMBER OF COUPLED AMETANI OR SEMLYEN PHA"
    "SES IN HIS COUPLED BRANCH GROUP.')");
  goto statement_6220;
  statement_6118:
  write(lunit6,
    "(5x,'THE BLANK CARD WHICH TERMINATES THE INPUT OF TACS DATA CARDS WHICH D"
    "EFINE FUNCTION BLOCKS HAS NOW JUST BEEN',/,5x,"
    "'READ.   BUT NO FUNCTION-BLOCK DEFINITIONS PRECEDED THIS BLANK CARD.   TH"
    "E USER WILL NOT BE ALLOWED TO CONTINUE',/,5x,"
    "'WITH SUCH A DEGENERATE TACS REPRESENTATION.  IF THE USER''S PRESENT REPR"
    "ESENTATION HAS ANY MEANING AT ALL, IT MUST ',/,5x,"
    "'SURELY HAVE ONE OR MORE SUPPLEMENTAL VARIABLES.   IF ADDING OR SUBTRACTI"
    "NG IS THEREIN INVOLVED (AS IS USUALLY')");
  write(lunit6,
    "(5x,'THE CASE), A ZERO-TH ORDER FUNCTION BLOCK COULD HAVE BEEN EMPLOYED F"
    "OR ONE OF THESE OPERATIONS, THEREBY',/,5x,"
    "'RESOLVING THE PRESENT DIFFICULTY.   OTHERWISE, AS A LAST RESORT, THE USE"
    "R CAN ADD A DUMMY TACS FUNCTION BLOCK TO',/,5x,"
    "'HIS TACS REPRESENTATION, BEING CAREFUL TO PROVIDE IT WITH A VALID INPUT "
    "VARIABLE.')");
  goto statement_6220;
  statement_6119:
  write(lunit6, format_7147), bus6;
  goto statement_7421;
  statement_6120:
  write(lunit6,
    "(5x,'THE EMTP IS IN THE PROCESS OF INPUTTING THE USER''S TACS SUPPLEMENTA"
    "L-VARIABLE DATA CARDS, WITH THE LAST-READ',/,5x,"
    "'SUCH DATA CARD BEING IN ERROR.   SPECIFICALLY, THE USER HAS ATTEMPTED TO"
    " DEFINE A SUPPLEMENTAL VARIABLE NAMED',/,5x,' ''',a6,"
    "'''  (DATA FIELD OF COLUMNS 3-8 OF THE CARD), FOR WHICH THE TYPE CODE WHI"
    "CH HAS BEEN PUNCHED IN COLUMNS 1-2',/,5x,'IS INVALID.   A VALUE OF',i4,"
    "'  WAS READ FROM COLUMNS 1-2, WHICH IS AN UNRECOGNIZED TYPE CODE.')"),
    bus1, lstat(14);
  goto statement_6220;
  statement_6121:
  write(lunit6,
    "(5x,'THE TACS DATA WHICH HAS NOW ALL BEEN INPUTTED IS INCOMPLETE.   SPECI"
    "FICALLY, THERE IS A DIFFICULTY ASSOCIATED',/,5x,"
    "'WITH THE TACS FUNCTION BLOCK WHICH WAS GIVEN THE (OUTPUT) NAME  ''',a6,"
    "'''  (AS READ FROM COLUMNS 3-8 OF THE',/,5x,"
    "'LEADING CARD WHICH DEFINES THIS FUNCTION BLOCK).   ONE OF THE FIVE POSSI"
    "BLE INPUTS TO THIS BLOCK WAS GIVEN NAME',/,5x,' ''',a6,"
    "'''  (AS READ FROM ONE OF THE FIELDS OF COLUMNS 12-17, 20-25, 28-33, 36-4"
    "1, AND 44-49, USING  A6  FORMAT).')"),
    bus2, bus1;
  write(lunit6,
    "(5x,'BUT THIS INPUT VARIABLE IS UNDEFINED.   IT IS NEITHER THE OUTPUT OF "
    "ANOTHER FUNCTION BLOCK, NOR A SUPPLEMENTAL',/,5x,"
    "'VARIABLE, NOR A TACS SOURCE OF ANY TYPE (1, 2, 90, 91, 92, OR 93 TYPE CO"
    "DES).   DID THE USER MAKE A SPELLING ERROR, THE',/,5x,"
    "'EMTP WONDERS.   THE EMTP DOES NOT KNOW WHAT TO DO WITH THE AFOREMENTIONE"
    "D INPUT, SO EXECUTION WILL BE TERMINATED.')");
  statement_7421:
  write(lunit6,
    "(/,5x,"
    "'SINCE THE USER IS HAVING TROUBLE WITH 6-CHARACTER TACS VARIABLE NAMES, I"
    "T IS PERHAPS WORTH QUALIFYING THE',/,5x,"
    "'PRECEDING ERROR TEXT WHICH COMPLAINS ABOUT AN UNIDENTIFIABLE NAME THAT I"
    "S ASSOCIATED WITH A CERTAIN TACS COMPONENT',/,5x,"
    "'OR DATA CLASS.   ALL THAT IS REALLY INVOLVED HERE IS A SPELLING COMPARIS"
    "ON WITH OTHER USAGES OF THE SAME VARIABLE',/,5x,"
    "'NAME.   WHEN FOR SOME PARTICULAR TACS COMPONENT A GIVEN NAME  ''NAME1 ''"
    "  CAN NOT BE FOUND IN A TABLE WHERE IT')");
  write(lunit6,
    "(5x,'BELONGS, THE EMTP SAYS THAT THE FORMER IS UNRECOGNIZABLE.   YET, AS "
    "USED WITH THE COMPONENT EXPLICITELY',/,5x,"
    "'MENTIONED IN THE MESSAGE,   ''NAME1 ''   MAY IN FACT BE SPELLED EXACTLY "
    "AS THE USER INTENDED.   IT MAY BE THE TABLE',/,5x,"
    "'BEING SEARCHED WHICH IS IN ERROR, DUE TO FAULTY SPELLING OF THE VARIABLE"
    " NAME ON SOME OTHER DATA CARD (WHICH',/,5x,"
    "'WAS THE USAGE THAT GENERATED THE TABLE ENTRY).   HENCE THE USER SHOULD L"
    "OOK AT OTHER DATA CARDS FOR MIS-SPELLING OF')");
  write(lunit6,
    "(5x,'THE NAME IN QUESTION, IF THE SPELLING AS PRINTED IN THE ABOVE ERROR "
    "TEXT IS ACTUALLY AS THE USER WANTED IT.')");
  write(lunit6,
    "(/,5x,"
    "'THEN TOO, WHILE TALKING ABOUT SPELLING, IT MIGHT BE A GOOD IDEA TO EMPHA"
    "SIZE WHAT IS INVOLVED.   ALL SIX-',/,5x,"
    "'CHARACTER VARIABLE NAMES ARE  A6  FORTRAN ALPHANUMERIC INFORMATION.   WH"
    "EN PRINTED OUT WITHIN ERROR MESSAGES, THE',/,5x,"
    "'SIX CHARACTERS IN QUESTION ARE DELINEATED BY A LEADING AND A TRAILING QU"
    "OTATION OR APOSTROPHE MARK.   POSITION',/,5x,"
    "'OF IMBEDDED BLANKS IS INDEED CRUCIAL, THEN.   FOR EXAMPLE,   ''RAVER '' "
    " AND  '' RAVER''  ARE COMPLETELY DIFFERENT,')");
  write(lunit6,
    "(5x,'DISTINCT 6-CHARACTER NAMES, AS FAR AS THE EMTP IS CONCERNED.   EMTP "
    "NAMES (INCLUDING THOSE OF TACS)',/,5x,"
    "'CONSIST OF AN ORDERED STRING OF 6 CHARACTERS, WITH ''BLANK'' BEING A CHA"
    "RACTER LIKE ANY OTHER ONE.   TWO VARIABLE',/,5x,"
    "'NAMES ARE EQUAL IF AND ONLY IF BOTH CHARACTERS OF ANY CHARACTER POSITION"
    " ARE EQUAL FOR THE TWO NAMES, FOR ALL',/,5x,"
    "'POSSIBLE CHARACTER POSITIONS  1, 2, .... 6 .')");
  goto statement_6220;
  statement_6122:
  write(lunit6,
    "(5x,'THE TACS REPRESENTATION CURRENTLY BEING PROCESSED HAS OVERFLOWED THE"
    " DIMENSIONED TACS STORAGE.   SPECIFICALLY,',/,5x,"
    "'THE TABLES WHICH ARE NUMBERED',i4,"
    "'  (SEE EXPLANATORY DIRECTORY OF TABLE NUMBERS BELOW) WHICH HAVE A LENGTH"
    " OF',/,5x,i4,"
    "'  ENTRIES ARE NOW FULL.   BECAUSE THERE IS NOT ENOUGH ROOM TO SOLVE THE "
    "PROBLEM, EXECUTION IS BEING STOPPED.',/,1x)"),
    lstat(17), lstat(16);
  write(lunit6,
    "(5x,'SINCE TACS CAN BE PARTIALLY REDIMENSIONED AT EXECUTION TIME, THE USE"
    "R CAN SIMPLY INCREASE THE APPROPRIATE TABLE',/,5x,"
    "'SIZES ON HIS  TACS-TABLE-SIZE CARDS , AND TRY THE DATA  CASE AGAIN.  YET"
    " SUCH RELATIVE SIZE CHANGES CAN ONLY BE',/,5x,"
    "'MADE WITHIN THE OVERALL EMTP VARIABLE-DIMENSIONING LIMITATION OF EMTP LI"
    "ST NUMBER 19, WHICH CONSTRAINS THE SUM',/,5x,"
    "'TOTAL SPACE WHICH IS ALLOWED FOR TACS ARRAYS.   HENCE OVERALL EMTP REDIM"
    "ENSIONING WITH A LARGER SIZE FOR LIST')");
  write(lunit6,
    "(5x,'NUMBER 19 MAY ALSO BE NECESSARY.   SEE THE EMTP CASE SUMMARY STATIST"
    "ICS FOR THE CURRENT SIZE OF EMTP LIST',/,5x,"
    "'NUMBER 19.   THE USER IS REMINDED THAT THE EXISTING LIST-19 SPACE CAN BE"
    " ALLOCATED EITHER IN ABSOLUTE TERMS (USING',/,5x,"
    "'THE  ''ABSOLUTE TACS DIMENSIONS''  REQUEST) OR IN RELATIVE TERMS (USING "
    "THE  ''RELATIVE TACS DIMENSIONS''  REQUEST).  IN',/,5x,"
    "'THE ''ABSOLUTE'' CASE, THE ''PRESENT FIGURE'' FOR LIST 19 WILL SHOW THE "
    "TOTAL WORKING SPACE WHICH IS REQUIRED FOR THE',/,5x,"
    "'USER-REQUESTED DIMENSIONS.   FOR THE ''RELATIVE'' CASE, THE ''PRESENT FI"
    "GURE'' WILL SIMPLY EQUAL THE LIMIT.')");
  write(lunit6,
    "(/,5x,"
    "'THE AFOREMENTIONED DIRECTORY OF TACS TABLE NUMBERS, INDICATING UPON WHAT"
    " THE TABLE LENGTHS DEPEND, READS AS FOLLOWS....',/,8x,"
    "'1.  NUMBER OF TACS DYNAMIC FUNCTION BLOCKS, HAVING LAPLACE TRANSFER FUNC"
    "TIONS  H(S) .')");
  write(lunit6,
    "(8x,'2.  NUMBER OF ZERO-TH ORDER TACS FUNCTION BLOCKS (TYPE CODE 99 PUNCH"
    "ED IN COLS. 1-2).',/,8x,"
    "'3.  TOTAL NUMBER OF INPUT VARIABLES TO TACS DYNAMIC AND ZERO-TH ORDER BL"
    "OCKS.',/,8x,"
    "'4.  NUMBER OF SIGNAL SOURCES TO TACS (TYPE CODES 1, 2, 90, 91, 92, OR 93"
    ").',/,12x,"
    "'REMEMBER THAT IN ADDITION TO USER-DEFINED TACS SOURCES, THERE ARE INTERN"
    "ALLY-DEFINED ONES ( ''TIMEX''  AND',/,12x,"
    "'''UNITY'' ,   AS OF JANUARY, 1977).')");
  write(lunit6,
    "(8x,'5.  NUMBER OF TACS SUPPLEMENTAL VARIABLES AND DEVICES (TYPE CODES 99"
    ", 98, OR 88).',/,8x,"
    "'6.  TOTAL NUMBER OF ARGUMENTS DESCRIBING THE SUPPLEMENTAL VARIABLES PROP"
    "ER (NOT THE DEVICES).',/,8x,"
    "'7.  TOTAL NUMBER OF NUMERICAL ARGUMENTS (NOT ALPHANUMERIC) OF SUPPLEMENT"
    "AL VARIABLES (NOT DEVICES).')");
  write(lunit6,
    "(8x,'8.  NUMBER OF TACS SUPPLEMENTAL DEVICES PROPER (TYPE CODES 50, 51, ."
    ".. 58).',/,8x,"
    "'9.  TOTAL NUMBER OF SIGNED INPUT VARIABLES TO SUPPLEMENTAL DEVICES.',/,"
    "7x,'10.  TOTAL NUMBER OF TRANSPORT DELAY HISTORY TERMS, DIGITIZER LEVELS,"
    " AND 2*POINTS FOR NONLINEAR DEVICES.')");
  write(lunit6,
    "(7x,'11.  THE SUM OVER ALL TACS DYNAMIC FUNCTION BLOCKS OF THE BLOCK ORDE"
    "R + ONE --- THE SUM OF (N+1).',/,7x,"
    "'12.  TOTAL NUMBER OF DYNAMIC AND ZERO-TH ORDER BLOCKS (MAY BE LESS THAN "
    "THE SUM OF TABLE NUMBERS 1 AND 2).',/,7x,"
    "'13.  NUMBER OF DISTINCT  A6  NAMES USED IN THE TACS DATA REPRESENTATION."
    "')");
  write(lunit6,
    "(7x,'14.  NUMBER OF NONZERO FACTORS OF THE TRIANGULARIZED MATRIX (STEADY-"
    "STATE OR TRANSIENTS).',/,7x,"
    "'15.  NUMBER OF TACS OUTPUT VARIABLES (AS REQUESTED BY THE USER BEFORE TA"
    "CS INITIAL CONDITION CARDS).',/,1x)");
  if (lstat(17) == 15) {
    write(lunit6,
      "(12x,"
      "'ACTUALLY, THE LIMIT FOR TACS TABLE 15 IS ONE LESS THAN WAS INDICATED A"
      "BOVE, IF THE USER''S PROBLEM',/,12x,"
      "'POSSESSES AN ELECTRIC NETWORK.   THE EXTRA OUTPUT-IDENTIFICATION NAME "
      " ''TACS  ''  IS INTERNALLY ADDED TO',/,12x,"
      "'THE OUTPUT VECTOR BY THE EMTP, IN THIS CASE.',"
      "'   MORE IMPORTANTLY, IF THE USER ASKED',"
      "' FOR THE OUTPUT OF ALL TACS VARIABLES,',/,12x,"
      "'HE JUST SHOT HIMSELF IN THE FOOT.  THIS',"
      "' WILL NEVER WORK, DUE TO ASTRONOMICAL',"
      "' CSP SPY DEMANDS.  USE SELECTIVE OUTPUT.')");
  }
  {
    write_loop wloop(cmn, lunit6,
      "(5x,'OK, SO JUST AS WITH OVERALL EMTP VARIABLE DIMENSIONING, THE USER C"
      "AN INTELLIGENTLY ALLOCATE STORAGE AMONG THE',/,5x,"
      "'DIFFERENT TACS TABLES ONLY IF HE KNOWS THE MULTIPLICITY OF EACH.   FOR"
      " THE TACS TABLE NUMBERS JUST DELINEATED,',/,5x,"
      "'ONE HAS THE FOLLOWING MULTIPLICITIES ....',/,10x,'TACS TABLE NUMBER.',"
      "10x,15i5,/,10x,'ALPHANUMERIC MULTIPLICITY.',2x,"
      "'    5    3    1    1    1    1    0    2    1    0    0    0    2    0"
      "    1')");
    FEM_DO_SAFE(i, 1, 15) {
      wloop, i;
    }
  }
  write(lunit6,
    "(10x,'FLOATING-POINT MULTIPLICITY.',"
    "'    7    3    0    5    0    0    1    3    0    1    5    3    6    2  "
    "  5',/,10x,'INTEGER MULTIPLICITY.',7x,"
    "'    7    3    1    1    3    2    0    3    1    0    0    3    0    1  "
    "  1',/,10x,'TOTAL MULTIPLICITY.',9x,"
    "'   19    9    2    7    4    3    1    8    2    1    5    6    8    3  "
    "  7')");
  {
    write_loop wloop(cmn, lunit6,
      "(5x,'DIMENSIONED SIZES OF THE TACS TABLES WHICH WERE USED FOR THE PRESE"
      "NT RUN ARE AS FOLLOWS ....',/,10x,'TACS TABLE NUMBER.',10x,15i5,/,10x,"
      "'PRESENT DIMENSION.',10x,15i5)");
    FEM_DO_SAFE(i, 1, 15) {
      wloop, i;
    }
    FEM_DO_SAFE(i, 1, 15) {
      wloop, lstat(i);
    }
  }
  goto statement_6220;
  statement_6123:
  write(lunit6, "(' UNUSED.')");
  statement_6124:
  write(lunit6,
    "(5x,'PRECEDING ALL TACS DATA CARDS, THE USER INPUTTED A SPECIAL REQUEST C"
    "ARD WHICH WAS PUNCHED WITH THE TEXT  ''TACS',/,5x,"
    "'EMTP SOURCES''  IN COLUMNS 1-17.   NOW, COLUMNS 21-80 OF THIS CARD ARE T"
    "O BE READ BY THE EMTP USING  10A6  FORMAT,',/,5x,"
    "'IN ORDER TO DISCOVER WHICH TYPE 1 THROUGH 10 EMTP SOURCES THE USER WANTS"
    " TO HAVE CONTROLLED BY SPECIFIED TACS',/,5x,"
    "'VARIABLES.   RECALL THAT IF THE K-TH FIELD SO-READ CONTAINS THE NONBLANK"
    "  A6  TEXT  ''NAME'' ,   THEN ON THE')");
  write(lunit6,
    "(5x,'ELECTRICAL SIDE IT WILL BE THE EMTP SOURCE OF TYPE-CODE  ''K''  WHIC"
    "H WILL BE GIVEN THE NUMERICAL VALUE OF TACS',/,5x,"
    "'VARIABLE  ''NAME'' .   NOW, THE USER''S  ''TACS EMTP SOURCES''  CARD IS "
    "IN ERROR BECAUSE FIELD NUMBER',i3,'  WAS PUNCHED',/,5x,"
    "'WITH THE NAME  ''',a6,"
    "''' ,   WHICH DOES NOT CORRESPOND TO ANY TACS VARIABLE.   MAYBE THIS NAME"
    " WAS MISSPELLED,',/,5x,"
    "'THE EMTP WONDERS.   IN ANY CASE, SINCE TACS CANNOT SUPPLY A NECESSARY IN"
    "TERFACE REQUEST, EXECUTION WILL BE STOPPED.')"),
    lstat(14), bus1;
  goto statement_7421;
  statement_6125:
  n1 = 90;
  write(lunit6, format_7125), n1, bus1;
  write(lunit6,
    "('+',17x,"
    "'BUT NO BRANCH OR SWITCH CARD OF THE SUBSEQUENTLY-INPUTTED ELECTRICAL NET"
    "WORK DEFINED THIS  A6  NODE',/,5x,"
    "'NAME.   SINCE THE EMTP DOES NOT KNOW WHAT VARIABLE OF THE ELECTRICAL NET"
    "WORK SHOULD BE USED TO CONTROL THIS TYPE-90',/,5x,"
    "'SOURCE, EXECUTION OF THE DATA CASE WILL NOW BE STOPPED.')");
  goto statement_7421;
  statement_6126:
  n1 = 91;
  write(lunit6, format_7125), n1, bus1;
  write(lunit6,
    "('+',17x,"
    "'ALSO, THIS EMTP ELECTRICAL-NETWORK NODE MUST HAVE A SWITCH CONNECTED TO "
    "IT, SINCE IT IS THE',/,5x,"
    "'CURRENT IN THE FIRST (IN ORDER OF DATA INPUT) SUCH ADJACENT SWITCH WHICH"
    " IS TO CONTROL THE TYPE-91 TACS SOURCE.',/,5x,"
    "'BUT NO SUCH SWITCH CAN BE FOUND BY THE EMTP.   SINCE THE EMTP DOES NOT K"
    "NOW WHAT VARIABLE OF THE ELECTRICAL',/,5x,"
    "'NETWORK SHOULD BE USED TO CONTROL THIS TYPE-91 TACS SOURCE, EXECUTION MU"
    "ST BE STOPPED.')");
  goto statement_7421;
  statement_6127:
  write(lunit6,
    "(5x,'AS PART OF THE INPUT OF TACS DATA WHICH IS NOW COMPLETE, THE USER HA"
    "S ELECTED TO MANUALLY DEFINE INITIAL',/,5x,"
    "'CONDITIONS FOR ONE OR MORE TACS VARIABLES.   RECALL THAT SUCH DATA FOLLO"
    "WS THE BLANK CARD WHICH TERMINATES TACS',/,5x,"
    "'OUTPUT-VARIABLE SPECIFICATION CARDS, WITH ONE TACS VARIABLE NAME AND ASS"
    "OCIATED INITIAL CONDITION ON EACH',/,5x,"
    "'CARD.   NOW, OF SUCH SPECIFICATIONS, NUMBER',i4,"
    "'  IN ORDER OF INPUT IS FOR A TACS VARIABLE WHICH IS',/,5x,"
    "'PURPORTED TO HAVE THE 6-CHARACTER ALPHANUMERIC NAME  ''',a6,"
    "''' .   BUT NO SUCH TACS VARIABLE HAS BEEN')"),
    lstat(14), bus1;
  write(lunit6,
    "(5x,'PREVIOUSLY DEFINED.   RATHER THAN ALLOW THE SOLUTION TO CONTINUE WIT"
    "H INITIAL CONDITIONS WHICH ARE PROBABLY',/,5x,"
    "'INCORRECT, EXECUTION WILL NOW BE TERMINATED.')");
  goto statement_7421;
  statement_6128:
  write(lunit6,
    "(5x,'DURING TRIANGULARIZATION OF THE REAL COEFFICIENT MATRIX  (A)  WHICH "
    "IS USED BY TACS EITHER FOR DC INITIAL',/,5x,"
    "'CONDITIONS OR FOR THE REPEAT SOLUTION OF THE TIME-STEP LOOP, AN INDICATI"
    "ON OF SINGULARITY OR NEAR-SINGULARITY HAS')");
  write(lunit6, format_7228), lstat(14), bus1, flstat(14);
  write(lunit6,
    "(5x,'(SIGN INCLUDED), WHILE JUST PRIOR TO RECIPROCATION THIS HAS DIMINISH"
    "ED (IN ABSOLUTE VALUE) TO',e14.5,' .',/,5x,"
    "'A NEAR-ZERO DIAGONAL VALUE HAS THUS OCCURRED, AS MEASURED BY THE RATIO O"
    "F THESE TWO VALUES VIS-A-VIS THE EMTP',/,5x,"
    "'MISCELLANEOUS DATA PARAMETER  ''EPSILN'' ,   WHICH HAS A VALUE OF',"
    "e13.4,' .   MOST PROBABLY THE USER HAS')"),
    flstat(15), cmn.epsiln;
  write(lunit6, format_7428);
  goto statement_6220;
  statement_6129:
  d1 = sqrtz(flstat(14));
  d2 = sqrtz(flstat(15));
  d3 = sqrtz(cmn.tolmat);
  write(lunit6,
    "(5x,'DURING TRIANGULARIZATION OF THE COMPLEX COEFFICIENT MATRIX  (C)  WHI"
    "CH IS USED BY TACS TO FIND AC SINUSOIDAL',/,5x,"
    "'STEADY-STATE INITIAL CONDITIONS, AN INDICATION OF MATRIX SINGULARITY (NO"
    "N-INVERTIBILITY) OR NEAR-SINGULARITY HAS')");
  write(lunit6, format_7228), lstat(14), bus1, d1;
  write(lunit6,
    "(5x,'(IN MAGNITUDE), WHILE JUST PRIOR TO RECIPROCATION, THIS HAS DIMINISH"
    "ED IN MAGNITUDE TO',e14.5,' .',/,5x,"
    "'A NEAR-ZERO DIAGONAL VALUE HAS THUS OCCURRED, AS MEASURED BY THE RATIO O"
    "F THESE TWO VALUES VIS-A-VIS THE EMTP',/,5x,"
    "'MISCELLANEOUS DATA PARAMETER  ''TOLMAT'' ,   WHICH HAS A VALUE OF',"
    "e13.4,' .   MOST PROBABLY THE USER HAS')"),
    d2, d3;
  write(lunit6, format_7428);
  goto statement_6220;
  statement_6130:
  write(lunit6, format_7130), bus2;
  write(lunit6,
    "('+',68x,'FOR WHICH ONE OF THE ALGEBRAIC OPERATOR CODES',/,5x,"
    "'IS ILLEGAL ACCORDING TO TACS RULES.   ONE OF THE  A1  FIELDS IN WHICH SP"
    "ECIFICATION OF THE ALGEBRAIC OPERATORS',/,5x,"
    "'IS TO BE PUNCHED WAS READ AS  ''',a1,"
    "''' ,   WHICH IS AN UNRECOGNIZED CHARACTER FOR THIS USAGE.   THE USER',/,"
    "5x,'IS ADVISED TO STUDY THE TACS RULES RELATED TO THE CONSTRUCTION OF SUP"
    "PLEMENTAL-VARIABLE CARDS, AND THEN LOOK',/,5x,"
    "'CLOSELY AT THE LAST-READ DATA CARD, TO SEE PRECISELY WHAT THE EMTP OBJEC"
    "TS TO.')"),
    bus1;
  goto statement_6220;
  statement_6131:
  n1 = lstat(14);
  write(lunit6,
    "(5x,'THE PROBLEM UNDER CONSIDERATION INCLUDES TACS DATA, THE TACS FUNCTIO"
    "N BLOCKS OF WHICH HAVE ALREADY ALL BEEN',/,5x,"
    "'READ BY THE EMTP.   COLUMNS 69-80 OF THE LEADING DATA CARD FOR EACH FUNC"
    "TION BLOCK ARE READ USING  2A6  FORMAT,',/,5x,"
    "'IN ORDER TO DETERMINE WHICH TACS VARIABLES (IF ANY....IF THE FIELDS ARE "
    "NONBLANK) ARE TO BE USED AS VARIABLE',/,5x,"
    "'LIMITS FOR THE BLOCK.   NOW, ON THIS BASIS THE EMTP TAKES EXCEPTION TO T"
    "HE DATA CARD WHICH DEFINES THE FUNCTION')");
  write(lunit6,
    "(5x,'BLOCK WITH NAME  ''',a6,"
    "'''  (AS READ FROM COLUMNS 3-8).   COLUMNS         ARE FOR THE     -LIMIT"
    " NAME,')"),
    bus1;
  if (n1 == 1) {
    write(lunit6, "('+',70x,'69-74',15x,'LOW')");
  }
  if (n1 == 2) {
    write(lunit6, "('+',70x,'75-80',14x,'HIGH')");
  }
  write(lunit6,
    "(5x,'WITH  ''',a6,"
    "'''  READ THEREFROM BY THE EMTP.   THIS LIMIT VARIABLE IS UNKNOWN TO THE "
    "EMTP, NOT BEING',/,5x,"
    "'RECOGNIZED AS ANY VALID TACS VARIABLE NAME.   DID THE USER MAKE A SPELLI"
    "NG ERROR, THE EMTP WONDERS.   SINCE THE',/,5x,"
    "'EMTP IS UNCERTAIN AS TO WHAT THE USER WANTS DONE WITH THIS LIMIT, EXECUT"
    "ION OF THIS DATA CASE IS BEING TERMINATED.')"),
    bus6;
  goto statement_7421;
  statement_6132:
  write(lunit6, format_7130), bus2;
  write(lunit6,
    "('+',68x,'FOR WHICH ONE OF THE FUNCTION CODES IS INVALID.',/,5x,"
    "'ONE OF THE  A5  FIELDS IN WHICH THE FUNCTIONS ARE TO BE SPECIFIED WAS RE"
    "AD AS  ''',a5,''' ,   WHICH IS AN',/,5x,"
    "'UNRECOGNIZABLE NAME FOR A SUPPLEMENTAL VARIABLE FUNCTION.   DID THE USER"
    " MAKE A SPELLING ERROR, THE EMTP WONDERS.')"),
    bus1;
  goto statement_6220;
  statement_6133:
  write(lunit6, format_7130), bus1;
  write(lunit6,
    "('+',68x,'FOR WHICH NO OPERATOR, FUNCTION, OR ARGUMENT HAS',/,5x,"
    "'BEEN DEFINED.   THE EMTP CANNOT CALCULATE THE OUTPUT FOR A TACS BLOCK WH"
    "OSE INPUT IS UNKNOWN.')");
  goto statement_6220;
  statement_6134:
  write(lunit6, format_7130), bus1;
  write(lunit6,
    "('+',68x,'FOR WHICH THE DEVICE CODE IS INVALID.   A VALUE',/,5x,'OF',i4,"
    "'  WAS READ FROM COLUMNS 9-10 OF THE CARD, WHICH IS NOT A LEGAL TACS SUPP"
    "LEMENTAL DEVICE CODE NUMBER.')"),
    lstat(14);
  goto statement_6220;
  statement_6135:
  write(lunit6, format_7130), bus1;
  write(lunit6, format_7236);
  goto statement_6220;
  statement_6136:
  write(lunit6,
    "(5x,'THE USER HAS BEEN INPUTTING TACS DATA, WITH THE LAST-READ DATA CARD "
    "BEING A REQUEST FOR A FUNCTION BLOCK.',/,5x,"
    "'THIS WAS TO BE GIVEN (OUTPUT) VARIABLE NAME  ''',a6,"
    "''' ,   AS READ FROM COLUMNS 3-8 OF THE LAST-READ DATA CARD.')"),
    bus1;
  write(lunit6, format_7236);
  goto statement_6220;
  statement_6137:
  write(lunit6,
    "(5x,'THE EMTP HAS BEEN INPUTTING TACS FUNCTION BLOCKS, WITH THE LAST-READ"
    " DATA CARD REPRESENTING AN ILLEGAL SUCH',/,5x,"
    "'REQUEST.   THIS WAS TO HAVE BEEN THE LEAD CARD OF A FUNCTION BLOCK HAVIN"
    "G (OUTPUT) NAME  ''',a6,'''  (COLS. 3-8).',/,5x,'INPUT FIELD NUMBER',i3,"
    "'  TO THIS BLOCK HAS BEEN PUNCHED WITH TACS NAME  ''',a6,"
    "''' ,   BUT IS NOT IMMEDIATELY',/,5x,"
    "'PRECEDED BY EITHER A PLUS SIGN OR A MINUS SIGN.   RATHER, THE CHARACTER "
    " ''',a1,'''  WAS READ.   REMEMBER,')"),
    bus1, lstat(14), bus2, bus3;
  write(lunit6,
    "(5x,'EACH NON-BLANK TACS INPUT-NAME FIELD ( A6  INFORMATION, COLUMNS 12-1"
    "7, 20-25, 28-33, 36-41, 44-49)  MUST BE',/,5x,"
    "'IMMEDIATELY PRECEDED BY EITHER A PLUS SIGN OR A MINUS SIGN ( A1  INFORMA"
    "TION, COLUMNS 11, 19, 27, 35, 43), INDICATING',/,5x,"
    "'THE POLARITY TO BE APPLIED TO THE ASSOCIATED INPUT VARIABLE.')");
  goto statement_6220;
  statement_6138:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD HAS BEEN TAKEN BY THE EMTP TO BE A CARD SPEC"
    "IFYING WHICH TACS VARIABLES ARE TO BE',/,5x,"
    "'PLACED IN THE EMTP OUTPUT VECTOR (AND HENCE WILL BE AVAILABLE FOR PRINTI"
    "NG AND/OR PLOTTING PURPOSES).   YET THE  I2',/,5x,"
    "'FIELD OF COLUMNS 1-2 CONTAINS AN ILLEGAL INTEGER VALUE  ''',i2,"
    "''' .   ONLY VALUES OF ZERO (FOR SELECTIVE OUTPUT)',/,5x,"
    "'OR UNITY (FOR OUTPUT OF ALL TACS VARIABLES) ARE ALLOWED BY THE EMTP.')"),
    lstat(14);
  goto statement_6220;
  statement_6139:
  write(lunit6, format_7130), bus3;
  n1 = lstat(14);
  switch (n1) {
    case 1: goto statement_7139;
    case 2: goto statement_7239;
    case 3: goto statement_7339;
    default: break;
  }
  statement_7139:
  write(lunit6,
    "(5x,'ONE OF THE ARGUMENTS HAS BEEN READ AS  ''',a6,"
    "''' ,   FOR WHICH THE USER HAS FAILED TO DEFINE AN',/,5x,"
    "'ALGEBRAIC OR A LOGICAL OPERATOR.')"),
    bus1;
  goto statement_6220;
  statement_7239:
  write(lunit6,
    "(5x,'ONE OF THE ARGUMENTS HAS BEEN READ AS THE FLOATING-POINT NUMBER',"
    "e14.6,' ,   FOR WHICH THE USER HAS',/,5x,"
    "'FAILED TO DEFINE AN ALGEBRAIC OR A LOGICAL OPERATOR.')"),
    flstat(16);
  goto statement_6220;
  statement_7339:
  write(lunit6,
    "(5x,'ONE OF THE OPERATORS HAS BEEN READ AS THE ALPHANUMERIC TEXT  ''',a1,"
    "''' ,   FOR WHICH THE USER HAS FAILED',/,5x,"
    "'TO DEFINE A FUNCTION AND/OR AN ARGUMENT.')"),
    bus2;
  goto statement_6220;
  statement_6140:
  write(lunit6,
    "(5x,'WERE IT NOT FOR THE SHARP EYE AND ALWAYS HELPFUL GOOD COMMON SENSE O"
    "F THE EMTP, THIS SIMULATION MIGHT HAVE',/,5x,"
    "'CONTINUED.   BUT THERE ARE NO REQUESTS FOR TACS VARIABLES TO BE PLACED I"
    "N THE OUTPUT VECTOR, NOR IS THE EMTP',/,5x,"
    "'EXPECTING ANY ELECTRICAL NETWORK DATA TO FOLLOW, AS PART OF THIS DATA CA"
    "SE.   RECALL THAT ONE OR MORE NONBLANK',/,5x,"
    "'FIELDS ON EITHER THE  ''TACS OUTPUTS''  OR THE  ''TACS EMTP SOURCES''  C"
    "ARD IS REQUIRED FOR EMTP ELECTRICAL NETWORK')");
  write(lunit6,
    "(5x,'DATA TO FOLLOW THE TACS DATA, AS PART OF A HYBRID DATA CASE.   THERE"
    " WOULD THUS BE NO OUTPUT VECTOR, AND IF',/,5x,"
    "'THE SIMULATION WERE ALLOWED TO CONTINUE, RESULTS WOULD GO UNOBSERVED.   "
    "POSSIBLY THE USER WANTED THIS SITUATION,',/,5x,"
    "'BUT THE EMTP WILL NOT ALLOW IT.   FOR A DATA CASE TO BE ALLOWED TO ENTER"
    " THE TIME-STEP LOOP, THERE MUST HAVE BEEN',/,5x,"
    "'REQUESTED ONE OR MORE OUTPUT VARIABLES (EITHER A TACS VARIABLE, OR AN EL"
    "ECTRICAL-NETWORK VARIABLE).')");
  goto statement_6220;
  statement_6141:
  write(lunit6,
    "(5x,'THE KEY WORD  ''STATISTICS''  OR  ''SYSTEMATIC''  CAN BE PUNCHED IN "
    "COLUMNS 55-64 OF A SWITCH CARD, AS PART OF A',/,5x,"
    "'DATA CASE WHICH HAS INTEGER MISCELLANEOUS DATA PARAMETER  ''NENERG''  PU"
    "NCHED NONZERO.   BUT THESE MUST BE',/,5x,'COORDINATED AS FOLLOWS .....',"
    "/,12x,'POSITIVE  ''NENERG''  -------  USE ONLY  ''STATISTICS''',/,12x,"
    "'NEGATIVE  ''NENERG''  -------  USE ONLY  ''SYSTEMATIC''',/,12x,"
    "'    ZERO  ''NENERG''  -------  USE NEITHER ONE.',/,5x,"
    "'THE LAST-READ DATA CARD IS A SWITCH CARD WHICH VIOLATES THIS RULE.   A V"
    "ALUE OF',i6,'   WAS READ FOR  ''NENERG'' ,')"),
    nenerg;
  write(lunit6,
    "(5x,'THE USER IS REMINDED.   HENCE THIS DATA CASE EITHER MIXES THE TWO KE"
    "Y WORDS OF COLUMNS 55-64, OR THE SIGN ON',/,5x,"
    "'PARAMETER  ''NENERG''  DOES NOT CORRESPOND TO THE SINGLE KEY WORD WHICH "
    "IS BEING USED.')");
  goto statement_6220;
  statement_6142:
  write(lunit6, "(5x,'UNUSED KILL CODE NUMBER....',i5)"), kill;
  goto statement_6220;
  statement_6143:
  write(lunit6,
    "(5x,'THE TACS DATA WHICH HAS NOW ALL BEEN INPUTTED IS INCOMPLETE.   SPECI"
    "FICALLY, THERE IS A PROBLEM WHICH IS',/,5x,"
    "'ASSOCIATED WITH THE TACS SUPPLEMENTAL VARIABLE OR DEVICE WHICH WAS GIVEN"
    " THE (OUTPUT) NAME  ''',a6,'''  (AS',/,5x,"
    "'READ FROM COLUMNS 3-8 OF THE DATA CARD WHICH DEFINED THIS VARIABLE).   T"
    "HE DIFFICULTY HERE IS ASSOCIATED WITH',/,5x,"
    "'ONE OF THE ARGUMENTS OR INPUTS TO THIS SUPPLEMENTAL VARIABLE OR DEVICE. "
    "  THIS PROBLEM ARGUMENT OR INPUT, WHICH')"),
    bus2;
  write(lunit6,
    "(5x,'WAS IDENTIFIED BY THE 6-CHARACTER  A6  NAME  ''',a6,"
    "''' ,   IS UNDEFINED.   THIS NAME IS NEITHER THE',/,5x,"
    "'OUTPUT OF A TACS DYNAMIC OR ZERO-TH ORDER FUNCTION BLOCK, NOR IS IT A TA"
    "CS SOURCE NAME.   THE NAME IN QUESTION',/,5x,"
    "'DOES NOT IDENTIFY ANY OTHER SUPPLEMENTAL VARIABLE OR DEVICE, EITHER, AT "
    "LEAST NOT ANY WHICH HAS BEEN DEFINED',/,5x,"
    "'BEFORE THE APPEARANCE OF THE PROBLEM SUPPLEMENTAL VARIABLE OR DEVICE (AS"
    " REQUIRED BY TACS RULES ON ORDERING).')"),
    bus1;
  write(lunit6, "(5x,'DID THE USER MAKE A SPELLING ERROR, THE EMTP WONDERS.')");
  goto statement_7421;
  statement_6144:
  n1 = 93;
  write(lunit6, format_7125), n1, bus1;
  write(lunit6,
    "('+',17x,"
    "'ALSO, THIS EMTP ELECTRICAL-NETWORK NODE MUST HAVE A SWITCH CONNECTED TO "
    "IT, SINCE IT IS THE',/,5x,"
    "'STATUS OF THE FIRST (IN ORDER OF EMTP DATA INPUT) SUCH SWITCH WHICH IS T"
    "O BE CONTROLLED BY THIS TYPE-93 TACS',/,5x,"
    "'SOURCE.   BUT NO EMTP SWITCH ADJACENT TO THE NODE IN QUESTION CAN BE FOU"
    "ND BY THE EMTP.   SINCE THE EMTP DOES',/,5x,"
    "'NOT KNOW WHAT VARIABLE OF THE ELECTRICAL NETWORK SHOULD BE USED TO CONTR"
    "OL THIS TYPE-93 TACS SOURCE, EXECUTION',/,5x,"
    "'MUST BE TERMINATED AT THIS POINT.')");
  goto statement_7421;
  statement_6145:
  write(lunit6,
    "(5x,'THE EMTP DATA CASE NOW BEING INPUTTED INVOLVES ONE OR MORE CONTINUOU"
    "SLY-TRANSPOSED DISTRIBUTED-PARAMETER',/,5x,"
    "'TRANSMISSION LINES, WITH FREQUENCY-DEPENDENT REPRESENTATION OF RESISTANC"
    "E  R  AND  INDUCTANCE  L  IN ONE OR MORE',/,5x,"
    "'OF THE MODES.   IN FACT, THE LAST-READ DATA CARD IS THE MISCELLANEOUS DA"
    "TA PARAMETER CARD WHICH PRECEDES THE POINT-',/,5x,"
    "'BY-POINT DEFINITION OF A PAIR OF WEIGHTING FUNCTIONS.   THE FIRST 16 COL"
    "UMNS OF THIS CARD ARE READ USING  2I8')");
  write(lunit6,
    "(5x,'FORMAT, TO FIND PARAMETERS  ''NTIME1''  AND  ''NTIME2'' .   THESE GI"
    "VE THE NUMBER OF POINTS WHICH ARE USED TO',/,5x,"
    "'DEFINE THE TWO WEIGHTING FUNCTIONS  A1(T)  AND  A2(T) ,   AND WERE READ "
    "AS VALUES',i8,'   AND',i8,' ,',/,5x,"
    "'RESPECTIVELY.   THE LARGER OF THESE EXCEEDS THE AVAILABLE MAXIMUM WORKIN"
    "G SPACE, WHICH IS DIMENSIONED',i8,'   CELLS.')"),
    lstat(14), lstat(15), lstat(16);
  if (kburro == 0) {
    write(lunit6,
      "(5x,'CONCERNING THIS LATTER FIGURE, THE USER SHOULD BE AWARE THAT THE  "
      " /LABEL/   STORAGE OF EMTP LISTS')");
  }
  if (kburro == 0) {
    write(lunit6,
      "(5x,'NUMBER  5  AND  7  ONLY IS INVOLVED.   THIS LIMITED REGION OF MEMO"
      "RY IS DIVIDED INTO FOUR EQUAL-SIZED ARRAYS,',/,5x,"
      "'EACH HAVING THE AFORESTATED INADEQUATE DIMENSION.   IN ORDER TO GET TH"
      "E USER''S WIEGHTING FUNCTIONS INTO THE EMTP',/,5x,"
      "'(AND COMPACTED INTO THEIR FINAL STORAGE IN THE ARRAY OF EMTP LIST NUMB"
      "ER 14), THE SIZES OF EMTP LIST NUMBERS  5',/,5x,"
      "'AND/OR  7  MUST BE INCREASED.   USE THE ABOVE EXPLANATION TOGETHER WIT"
      "H KNOWN LIST MULTIPLICITIES IN ORDER TO',/,5x,"
      "'DETERMINE THE REQUIRED INCREASE IN SIZE.')");
  }
  if (kburro != 0) {
    write(lunit6,
      "(5x,'CONCERNING THIS LATTER FIGURE, THE USER',"
      "' SHOULD REMEMBER THAT HE IS USING A',"
      "' VIRTUAL COMPUTER, SO LIST 23 OF \"VARDIM\"',/,5x,"
      "'IS USED FOR STORAGE.  SUCH A REGION OF',"
      "' MEMORY IS DIVIDED INTO FOUR EQUAL-SIZE',"
      "' ARRAYS, WITH EACH OF THESE HAVING THE',/,5x,"
      "'AFOREMENTIONED INADEQUATE SIZE.  IN',"
      "' ORDER TO SUCCESSFULLY PROCESS THE',"
      "' WEIGHTING FUNCTIONS, LIST 23 MUST GROW.')");
  }
  goto statement_6220;
  statement_6146:
  write(lunit6,
    "(5x,'SWITCH CARDS ARE NOW BEING INPUTTED, FOR THE EMTP DATA CASE UNDER CO"
    "NSIDERATION.   SPECIFICALLY, THE LAST-READ',/,5x,"
    "'DATA CARD REPRESENTS A REQUEST FOR A TYPE-11 SWITCH (I.E., A DIODE OR A "
    "VALVE) WHICH CONNECTS NODE  ''',a6,'''',/,5x,'WITH NODE  ''',a6,''' .')"),
    bus1, bus2;
  n1 = kswtch - 1;
  write(lunit6,
    "('+',28x,"
    "'NOW, COLUMNS 61-64 WERE PUNCHED WITH THE KEY-WORD  ''SAME'' ,   WHICH IS"
    " UNDERSTOOD TO BE',/,5x,"
    "'A REQUEST THAT THE PHYSICAL CHARACTERISTICS OF THE PRESENT VALVE OR DIOD"
    "E BE IDENTICAL TO THOSE OF THE MOST-RECENT',/,5x,"
    "'PRECEDING TYPE-11 SWITCH ELEMENT.   BUT OF THE PRECEDING',i4,"
    "'  SWITCH CARDS, NONE WERE TYPE-11 (PUNCHED IN',/,5x,"
    "'COLS. 1-2).   THUS THE REFERENCE SWITCH DOES NOT EXIST, AND THE EMTP HAS"
    " NO WAY OF KNOWING WHAT MODELING',/,5x,"
    "'PARAMETERS SHOULD BE USED TO DESCRIBE THE PRESENT DIODE OR VALVE.')"),
    n1;
  goto statement_6220;
  statement_6147:
  write(lunit6, format_7147), bus5;
  goto statement_7421;
  statement_6148:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD IS FOR A SWITCHED-INDUCTANCE ELEMENT (TYPE-9"
    "3 SWITCH CARD) WHICH CONNECTS NODE',/,5x,' ''',a6,'''  WITH NODE  ''',a6,"
    "''' .   BUT THE VALUE FOR RESIDUAL FLUX (PUNCHED IN COLUMNS 15-24, AND RE"
    "AD',/,5x,"
    "'USING  E10.6  FORMAT) IS ILLEGAL, FOR IT EXCEEDS THE SATURATION FLUX (PU"
    "NCHED IN COLUMNS 45-54, AND READ USING',/,5x,"
    "'E10.6  FORMAT).   THE NUMERICAL VALUES FOR THESE TWO NUMBERS ARE',e15.4,"
    "'  AND',e15.4,' ,  RESPECTIVELY.')"),
    bus1, bus2, flstat(15), flstat(16);
  write(lunit6,
    "(5x,'CORRECT THIS VIOLATION OF THE EMTP RULES, AND TRY AGAIN.')");
  goto statement_6220;
  statement_6149:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD HAS BEEN TAKEN BY THE EMTP TO BE A SOURCE CA"
    "RD OF TYPE 14 (SINUSOIDAL GENERATOR).',/,5x,"
    "'BUT THE FREQUENCY AS READ FROM COLUMNS 21-30 OF THIS CARD IS NOT POSITIV"
    "E, AS REQUIRED BY EMTP RULES.   A VALUE',/,5x,'OF',e13.4,"
    "'  WAS READ.   SINUSOIDS OF OTHER THAN POSITIVE FREQUENCY MUST BE REJECTE"
    "D BY THE EMTP ON',/,5x,"
    "'AESTHETIC GROUNDS.   THE USER SHOULD CORRECT COLUMNS 21-30, AND TRY AGAI"
    "N.')"),
    flstat(14);
  goto statement_6220;
  statement_6150:
  d1 = flstat(14) / deltat;
  write(lunit6,
    "(5x,'THE USER HAS PICKED A TIME-STEP SIZE  ''DELTAT''  (READ FROM COLUMNS"
    " 1-8 OF THE FLOATING-POINT MISCELLANEOUS',/,5x,"
    "'DATA CARD) WHICH IS TOO SMALL FOR ONE OF THE DISTRIBUTED PARAMETER TRANS"
    "MISSION LINES THAT IS TO BE MODELED USING',/,5x,"
    "'SEMLYEN RECURSIVE CONVOLUTION.   A STEP-SIZE OF',e14.4,"
    "'  SECONDS WAS REQUESTED, WHICH IS TOO LARGE',/,5x,"
    "'FOR THE SEMLYEN LINE HAVING PHASE NUMBER 1 THAT CONNECTS NODE  ''',a6,"
    "'''  WITH NODE  ''',a6,''' .   THE')"),
    deltat, bus1, bus2;
  write(lunit6,
    "(5x,'RULE IS THAT THE TRAVEL TIME FOR ALL SEMLYEN MODES MUST EXCEED  TWO "
    " TIME STEPS.   BUT FOR MODE NUMBER',i4,/,5x,"
    "'OF THE AFOREMENTIONED LINE, THE TRAVEL TIME  ''TAU''  IS ONLY',e14.4,"
    "'  SECONDS.   THE RATIO OF THESE GIVES',/,5x,'TAU/DELTAT =',e12.4,"
    "' ,   WHICH IS TOO SMALL (LESS THAN 2.0).   DECREASE THE TIME-STEP SIZE  "
    "''DELTAT''',/,5x,"
    "'ACCORDINGLY, OR ALTER THE TRANSMISSION LINE MODELING, IN ORDER TO MAKE T"
    "HIS DATA CASE SOLVABLE USING THE EMTP.')"),
    lstat(15), flstat(14), d1;
  goto statement_6220;
  statement_6220:
  cmn.lastov = nchain;
  nchain = cmn.nfrfld + 50;
  if (iprsup >= 1) {
    write(lunit6, "(' \"EXIT  MODULE OVER53.\" ')");
  }
  statement_99999:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
over54(
  common& cmn) try
{
  common_write write(cmn);
  fem::str<8>& bus4 = cmn.bus4;
  fem::str<8>& bus5 = cmn.bus5;
  double& twopi = cmn.twopi;
  const auto& voltbc = cmn.voltbc;
  const auto& flstat = cmn.flstat;
  auto& lstat = cmn.lstat;
  int& numsm = cmn.numsm;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  const auto& volti = static_cast<common_volpri&>(cmn).volti_50;
  const auto& voltk = static_cast<common_volpri&>(cmn).voltk_50;
  //
  auto& lunit6 = cmn.lunit6;
  int n1 = fem::int0;
  int j = fem::int0;
  double d1 = fem::double0;
  double d2 = fem::double0;
  static const char* format_4568 = "('  \"EXIT  MODULE OVER54.\"')";
  static const char* format_7154 =
    "(5x,'THE EMTP HAS BEEN INPUTTING DATA FOR A  ''SEMLYEN SETUP''  CASE, AND"
    " HAS DISCOVERED AN INCONSISTENCY OR',/,5x,"
    "'ILLEGALITY IN THE NUMERICAL VALUES WHICH WERE PUNCHED BY THE USER.   SPE"
    "CIFICALLY,')";
  static const char* format_7172 =
    "(5x,'THE EMTP HAS BEEN READING DATA WITHIN THE  ''CABLE CONSTANTS''  SUPP"
    "ORTING PROGRAM, WITH THE LAST-READ DATA CARD',/,5x,"
    "'BEING THE MISCELLANEOUS DATA CARD OF A NEW CASE.   BUT THE NUMBERS PUNCH"
    "ED HEREUPON ARE INCONSISTENT.   SPECIFICALLY,')";
  if (iprsup >= 1) {
    write(lunit6, "('  \"BEGIN MODULE OVER54.\"')");
  }
  if (nchain != 54) {
    goto statement_99999;
  }
  n1 = kill - 150;
  switch (n1) {
    case 1: goto statement_6151;
    case 2: goto statement_6152;
    case 3: goto statement_6153;
    case 4: goto statement_6154;
    case 5: goto statement_6155;
    case 6: goto statement_6156;
    case 7: goto statement_6157;
    case 8: goto statement_6158;
    case 9: goto statement_6159;
    case 10: goto statement_6160;
    case 11: goto statement_6161;
    case 12: goto statement_6162;
    case 13: goto statement_6163;
    case 14: goto statement_6164;
    case 15: goto statement_6165;
    case 16: goto statement_6166;
    case 17: goto statement_6167;
    case 18: goto statement_6168;
    case 19: goto statement_6169;
    case 20: goto statement_6170;
    case 21: goto statement_6171;
    case 22: goto statement_6172;
    case 23: goto statement_6173;
    case 24: goto statement_6174;
    case 25: goto statement_6175;
    case 26: goto statement_6176;
    case 27: goto statement_6177;
    case 28: goto statement_6178;
    case 29: goto statement_6179;
    case 30: goto statement_6180;
    case 31: goto statement_6181;
    case 32: goto statement_6182;
    case 33: goto statement_6183;
    case 34: goto statement_6184;
    case 35: goto statement_6185;
    case 36: goto statement_6186;
    case 37: goto statement_6187;
    case 38: goto statement_6188;
    case 39: goto statement_6189;
    case 40: goto statement_6190;
    case 41: goto statement_6191;
    case 42: goto statement_6192;
    case 43: goto statement_6193;
    case 44: goto statement_6194;
    case 45: goto statement_6195;
    case 46: goto statement_6196;
    case 47: goto statement_6197;
    case 48: goto statement_6198;
    case 49: goto statement_6199;
    case 50: goto statement_6200;
    default: break;
  }
  statement_6151:
  write(lunit6,
    "(5x,'THE PRESENT DATA CASE HAS A POSITIVE PARAMETER  ''NENERG''  (READ FR"
    "OM COLUMNS 65-72 OF THE FLOATING-POINT',/,5x,"
    "'MISCELLANEOUS DATA CARD), INDICATING THAT RANDOM SWITCH CLOSING TIMES FO"
    "R  ''STATISTICS''  SWITCHES ARE TO BE',/,5x,"
    "'GENERATED.   SINCE PARAMETER  ''ISW''  WAS PUNCHED WITH THE KEY REQUEST "
    "VALUE  ''4444'' ,   ONLY AN ANALYSIS OF THE',/,5x,"
    "'SWITCH CLOSING TIMES IS DESIRED (NO EMTP SIMULATIONS ARE  TO BE PERFORME"
    "D).   BUT SUCH AN ANALYSIS IS NOT POSSIBLE,')");
  write(lunit6,
    "(5x,'DUE TO A SHORTAGE OF AVAILABLE WORKING SPACE IN MEMORY.   ONLY',i6,"
    "'  INTEGER CELLS OF   /LABEL/   ARE',/,5x,'AVAILABLE, WHILE',i7,"
    "'  SUCH CELLS ARE REQUIRED IN ORDER TO EXECUTE THIS DATA CASE.   A FORMUL"
    "A FOR THIS',/,5x,'REQUIRED MINIMUM INTEGER STORAGE SPACE IS ....',/,30x,"
    "'MIN  =  ( 3 + NS*(NS-1)/2 ) * NC',/,5x,"
    "'WHERE  ''NS''  IS THE NUMBER OF  ''STATISTICS''  SWITCHES,  AND  ''NC'' "
    " IS THE NUMBER OF COMPARTMENTS OF THE')"),
    lstat(14), lstat(15);
  write(lunit6,
    "(5x,'CUMULATIVE DISTRIBUTION FUNCTION TABULATION.   FOR THIS DATA CASE,  "
    " NS =',i4,' ,   WHILE   NC =',i4,' ,',/,5x,"
    "'WITH THE LATTER FIGURE EQUAL TO TWICE PARAMETER  ''SIGMAX''  DIVIDED BY "
    " ''AINCR''  (SEE  ''STATISTICS''  MISCELLANEOUS',/,5x,"
    "'DATA CARD PARAMETERS).   IN ORDER TO RUN THIS TEST OF THE RANDOM NUMBER "
    "GENERATOR, EITHER THE NUMBER OF  ''STATISTICS''',/,5x,"
    "'SWITCHES OR TABULATION COMPARTMENTS MUST BE APPROPRIATELY DECREASED, OR "
    "THE EMTP MUST BE RE-DIMENSIONED SO AS')"),
    lstat(16), lstat(13);
  write(lunit6,
    "(5x,'TO PROVIDE FOR MORE WORKING SPACE IN MEMORY.   IF THE LATTER COURSE "
    "IS TAKEN, IT IS RECOMMENDED THAT ALL OF',/,5x,"
    "'INCREASED SPACE BE CONFINED TO LISTS NUMBER  5,  7,  8,  13,  14,  OR  1"
    "5,  IN WHICH CASE THERE IS NO WASTE OR',/,5x,"
    "'LOSS (THE INCREASE IS  100 PER CENT EFFECTIVE).')");
  goto statement_6220;
  statement_6152:
  write(lunit6,
    "(5x,'EXECUTION OF THE LINE CONSTANTS PROGRAM CAN NOT BE ALLOWED TO CONTIN"
    "UE, DUE TO A SHORTAGE OF CORE STORAGE FOR',/,5x,"
    "'USE AS TABULAR WORKING SPACE.   THE EMTP IS VARIABLY-DIMENSIONED, OF COU"
    "RSE, WITH THE PRESENT SIZE OF   /LABEL/',/,5x,"
    "'SIMPLY INSUFFICIENT TO ALLOW FOR EVEN THE SOLUTION OF A SINGLE-CONDUCTOR"
    " PROBLEM.   AVAILABLE DIMENSIONED WORKING',/,5x,"
    "'SPACE IN SUBROUTINE  ''VDOV44''  IS',i5,"
    "'  CELLS.   FITTING ALL MATRICES INTO THIS CONSTRAINT REQUIRES THAT')"),
    lstat(14);
  write(lunit6,
    "(5x,'A CONDUCTOR LIMIT OF',i5,"
    "'  CONDUCTORS BE IMPOSED.   THE USER MUST REDIMENSION THE EMTP IN ORDER T"
    "O',/,5x,"
    "'PROVIDE FOR MORE   /LABEL/   STORAGE (WITH THE DISTRIBUTION OF THIS STOR"
    "AGE AMONG THE DIFFERENT LISTS BEING',/,5x,"
    "'IMMATERIAL), AND RESUBMIT THE JOB.')"),
    lstat(15);
  goto statement_6220;
  statement_6153:
  write(lunit6,
    "(5x,'AS PART OF THE TACS DATA WHICH HAS NOW BEEN COMPLETELY READ BY THE E"
    "MTP, THE USER HAS EMPLOYED THE SAME SIX-',/,5x,"
    "'CHARACTER ALPHANUMERIC NAME  ''',a6,"
    "'''  FOR TWO DIFFERENT TACS VARIABLES.   UNFORTUNATELY FOR THE USER,',/,"
    "5x,'HOMOGRAPHS ARE TO BE EXILED FOR LIFE FROM THE EMTP WORLD.   YET SHOUL"
    "D THIS SUCCINCT CHARACTERIZATION BE LESS',/,5x,"
    "'THAN PERFECTLY CLEAR, SUFFICE IT TO SAY THAT IT IS A VIOLATION OF EMTP R"
    "ULES FOR THE USER TO APPLY THE SAME  A6')"),
    cmn.bus1;
  write(lunit6,
    "(5x,'NAME TO WHAT ARE SUPPOSED TO BE TWO DISTINCT TACS VARIABLES.')");
  goto statement_7421;
  statement_7421:
  write(lunit6,
    "(/,5x,"
    "'SINCE THE USER IS HAVING TROUBLE WITH 6-CHARACTER TACS VARIABLE NAMES, I"
    "T IS PERHAPS WORTH QUALIFYING THE',/,5x,"
    "'PRECEDING ERROR TEXT WHICH COMPLAINS ABOUT AN UNIDENTIFIABLE NAME THAT I"
    "S ASSOCIATED WITH A CERTAIN TACS COMPONENT',/,5x,"
    "'OR DATA CLASS.   ALL THAT IS REALLY INVOLVED HERE IS A SPELLING COMPARIS"
    "ON WITH OTHER USAGES OF THE SAME VARIABLE',/,5x,"
    "'NAME.   WHEN FOR SOME PARTICULAR TACS COMPONENT A GIVEN NAME  ''NAME1 ''"
    "  CAN NOT BE FOUND IN A TABLE WHERE IT')");
  write(lunit6,
    "(5x,'BELONGS, THE EMTP SAYS THAT THE FORMER IS UNRECOGNIZABLE.   YET, AS "
    "USED WITH THE COMPONENT EXPLICITELY',/,5x,"
    "'MENTIONED IN THE MESSAGE,   ''NAME1 ''   MAY IN FACT BE SPELLED EXACTLY "
    "AS THE USER INTENDED.   IT MAY BE THE TABLE',/,5x,"
    "'BEING SEARCHED WHICH IS IN ERROR, DUE TO FAULTY SPELLING OF THE VARIABLE"
    " NAME ON SOME OTHER DATA CARD (WHICH',/,5x,"
    "'WAS THE USAGE THAT GENERATED THE TABLE ENTRY).   HENCE THE USER SHOULD L"
    "OOK AT OTHER DATA CARDS FOR MIS-SPELLING OF')");
  write(lunit6,
    "(5x,'THE NAME IN QUESTION, IF THE SPELLING AS PRINTED IN THE ABOVE ERROR "
    "TEXT IS ACTUALLY AS THE USER WANTED IT.')");
  write(lunit6,
    "(/,5x,"
    "'THEN TOO, WHILE TALKING ABOUT SPELLING, IT MIGHT BE A GOOD IDEA TO EMPHA"
    "SIZE WHAT IS INVOLVED.   ALL SIX-',/,5x,"
    "'CHARACTER VARIABLE NAMES ARE  A6  FORTRAN ALPHANUMERIC INFORMATION.   WH"
    "EN PRINTED OUT WITHIN ERROR MESSAGES, THE',/,5x,"
    "'SIX CHARACTERS IN QUESTION ARE DELINEATED BY A LEADING AND A TRAILING QU"
    "OTATION OR APOSTROPHE MARK.   POSITION',/,5x,"
    "'OF IMBEDDED BLANKS IS INDEED CRUCIAL, THEN.   FOR EXAMPLE,   ''RAVER '' "
    " AND  '' RAVER''  ARE COMPLETELY DIFFERENT,')");
  write(lunit6,
    "(5x,'DISTINCT 6-CHARACTER NAMES, AS FAR AS THE EMTP IS CONCERNED.   EMTP "
    "NAMES (INCLUDING THOSE OF TACS)',/,5x,"
    "'CONSIST OF AN ORDERED STRING OF 6 CHARACTERS, WITH ''BLANK'' BEING A CHA"
    "RACTER LIKE ANY OTHER ONE.   TWO VARIABLE',/,5x,"
    "'NAMES ARE EQUAL IF AND ONLY IF BOTH CHARACTERS OF ANY CHARACTER POSITION"
    " ARE EQUAL FOR THE TWO NAMES, FOR ALL',/,5x,"
    "'POSSIBLE CHARACTER POSITIONS  1, 2, .... 6 .')");
  goto statement_6220;
  statement_6154:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'DATA PARAMETERS  ''IOTX'' ,  ''IOSS'' ,  AND  ''IOFL''  ARE REQUIRED"
    " TO BE OCTAL (BASE-8) NUMBERS.   DIGITS',/,5x,"
    "' ''8''  AND  ''9''  ARE THUS ILLEGAL (NONEXISTANT), AND MUST NOT BE USED"
    ".   BUT THE FIELD FOR NUMBER',i4,'   AMONG',/,5x,"
    "'THESE WAS PUNCHED WITH THE VALUE',i6,' .   NAUGHTY, NAUGHTY.')"),
    lstat(13), lstat(14);
  goto statement_6220;
  statement_6155:
  write(lunit6,
    "(5x,'WITHIN THE COMPUTATIONS FOR A  ''SEMLYEN SETUP''  DATA CASE, THE ITE"
    "RATIVE PROCEDURE WHICH IS USED FOR FITTING',/,5x,"
    "'THE CHARACTERISTIC-ADMITTANCE STEP-RESPONSE HAS FAILED TO CONVERGE.   TH"
    "IS FITTING IS DONE BY MEANS OF AN',/,5x,"
    "'ALGEBRAIC ADJUSTMENT IN THE FREQUENCY DOMAIN, NOT THE MORE WELL-KNOWN FI"
    "TTING OF EXPONENTIALS IN THE TIME DOMAIN.',/,5x,'THE ITERATION LIMIT OF',"
    "i5,'   (PARAMETER  ''NITERY'' )  WAS REACHED FOR MODE NUMBER',i4,"
    "'   WITHOUT')"),
    lstat(13), lstat(14);
  write(lunit6,
    "(5x,'SATISFYING TOLERANCES  ''EPSYC''  AND  ''EPSN'' ,   WHICH HAVE VALUE"
    "S',e15.3,'   AND',e15.3,' ,',/,5x,"
    "'RESPECTIVELY.   THE USER IS REMINDED THAT THESE JUST-MENTIONED  ''SEMLYE"
    "N SETUP''  PARAMETERS ARE UNDER USER',/,5x,"
    "'CONTROL BY MEANS OF A SPECIAL  ''TOLERANCES''  REQUEST-WORD CARD, IF THI"
    "S WILL HELP ANY.   ALTERNATIVELY, DID THE',/,5x,"
    "'USER PERHAPS ALREADY REDEFINED DEFAULT VALUES BY MEANS OF SUCH A CARD, T"
    "HEREBY MAKING CONVERGENCE IMPOSSIBLE,',/,5x,'THE EMTP WONDERS.')"),
    flstat(13), flstat(14);
  goto statement_6220;
  statement_6156:
  write(lunit6,
    "(5x,'THE PRESENT   ''SEMLYEN SETUP''   DATA CASE HAS PROVEN TO BE TOO MUC"
    "H FOR THE EMTP LOGIC, FOR MODE NUMBER',i4,' .')"),
    lstat(14);
  if (lstat(19) == 40080) {
    goto statement_7556;
  }
  if (lstat(19) == 4545 || lstat(19) == 4557) {
    goto statement_7956;
  }
  write(lunit6,
    "(5x,' THE TOE OF THE STEP RESPONSE HAS BEEN LOCATED, BASED ON THE SPEED O"
    "F THE HIGHEST FREQUENCY SPECIFIED .',/,5x,"
    "' THE TIME STEP USED IN THE FITTING PROCESS IS ESTABLISHED BY A TECHNIQUE"
    " DETERMINED BY PARAMETER ''KFIT''',/,5x,"
    "' FOR WHICH THE USER HAS SUPPLIED A VALUE OF',i2,' .',/,5x,"
    "'IF  \"0\"    THE TIME STEP IS SIMPLY TOE TIME / NOO',/,5x,"
    "'IF  \"1\"    THE TIME STEP IS SIZED TO PUT 25\" OF THE SPECIFIED \"NPOIN"
    "T\" POINTS BETWEEN THE TOE',/,16x,"
    "'AND THE TIME AT WHICH THE VALUE IS 2/3 .',/,5x,"
    "'IF  \"2\"    THE TIME STEP IS SIZED TO PUT  5\" OF THE SPECIFIED \"NPOIN"
    "T\" POINTS BETWEEN THE 1/3 AND THE 2/3  TIMES .')"),
    lstat(15);
  write(lunit6,
    "(5x,'DETERMINING THE 1/3 POINT OR THE 2/3 POINT MAY NOT BE POSSIBLE BECAU"
    "SE OF NOISE AT SMALL TIMES IN INVERSE FOURIER ROUTINES .',/,5x,"
    "'THIS RUN HAS SUFFERED FROM THIS DIFFICULTY .',5x,i4,"
    "' ITERATIONS HAVE FAILED TO LOCATE ONE OF THESE POINTS .',/,5x,"
    "'THE SOLUTIONS AVAILABLE ARE \"  \"A\"  DIFFERENT VALUE OF \"KFIT\",',/,"
    "5x,'\"B\" A HIGHER NUMBER FOR \"NFIT\" WHICH CONTROLS THE PERMISSIBLE NO."
    " OF ITERATIONS,',/,5x,"
    "'\"C\" A HIGHER FREQUENCY RANGE AND/OR MORE FREQUENCY POINTS IN AN ATTEMP"
    "T TO IMPROVE THE ACCURACY OF THE IFR .')"),
    lstat(11);
  write(lunit6,
    "(5x,'OTHER PARAMETERS RELEVENT TO THIS NON-CONVERGED ITERATION ARE AS FOL"
    "LOWS :',/,5x,'THE INITIAL SIZE OF THE TIME INCREMENT WAS',e15.5,"
    "' .  THE TARGET VALUE WAS',e15.5,/,5x,"
    "'THE NUMBER OF POINTS \"NPOINT\" AS REQUESTED BY THE USER =',i4,' .')"),
    flstat(11), flstat(16), lstat(10);
  goto statement_6220;
  statement_7556:
  write(lunit6,
    "(5x,'THE TECHNIQUE FOR FITTING OF THE ADMITTANCE STEP RESPONSE HAS BEEN D"
    "ETERMINED BY THE FIRST COLUMN IN PARAMETER ''KFIT''',/,5x,"
    "'FOR WHICH THE USER HAS SUPPLIED A VALUE OF',i2,' .')"),
    lstat(13);
  write(lunit6,
    "(5x,'IF ''1'', THE USER HAS REQUESTED A TIME DOMAIN FIT, WHICH REQUIRES T"
    "HE PROGRAM TO DETERMINE THE TIME PERIOD TO BE FITTED.',/,5x,"
    "'IN THIS PROCESS THE PROGRAM SEARCHES A LIMITED TIME FRAME FOR A CHANGE I"
    "N RESPONSE OF',f4.2,' OF THE INITIAL VALUE .',/,5x,"
    "'THE PROGRAM HAS BEEN UNABLE TO LOCATE THIS VALUE, EITHER BECAUSE THE PER"
    "IOD SEARCHED WAS TOO SHORT,',/,5x,"
    "'OR BECAUSE THE IFT ROUTINE FAILED TO PRODUCE IT.',/,5x,"
    "'A WIDER FREQUENCY RANGE OR MORE NUMEROUS FREQUENCY DATA MAY IMPROVE THE "
    "IFT RESULT.',/,5x,"
    "'A VALUE OF ''2'' WILL RESULT IN A PRELIMINARY FREQUENCY DOMAIN FIT TO DE"
    "TERMINE THE TIME PERIOD.')"),
    flstat(16);
  write(lunit6,
    "(5x,'OTHER PARAMETERS RELEVANT TO THIS SEARCH FAILURE ARE AS FOLLOWS:',/,"
    "5x,'THE INITIAL SIZE OF THE TIME INCREMENT WAS',e15.5,"
    "' .  THE TIME ZONE SEARCHED WAS',e15.5,/,5x,"
    "'THE NUMBER OF POINTS ''NPOINT'' AS REQUESTED BY THE USER =',i4)"),
    flstat(11), flstat(13), lstat(10);
  goto statement_6220;
  statement_7956:
  write(lunit6,
    "(5x,'THE NEWTON-RAPHSON ALGORITHM, USED TO FIT THE LINE RESPONSE WITH EXP"
    "ONENTIALS, IS IN TROUBLE.',/,5x,"
    "'EITHER THE JACOBIAN MATRIX IS SINGULAR, OR THE INITIAL GUESS MADE BY THE"
    " PROGRAM IS NOT CLOSE ENOUGH.',/,5x,"
    "'AFTER CAREFULLY CHECKING DATA, A CONSULTATION WITH PROGRAM MAINTENANCE I"
    "S INDICATED.')");
  goto statement_6220;
  statement_6157:
  write(lunit6,
    "(5x,'THE ''SEMLYEN SETUP''  DATA CASE NOW UNDER CONSIDERATION REQUIRES TH"
    "AT MODAL STEP RESPONSES BE COMPUTED FIRST,',/,5x,"
    "'BY INVERSE FOURIER TRANSFORMATION.   THIS PROCEDURE HAS NOW BEEN COMPLET"
    "ED.')");
  if (lstat(14) == 0) {
    goto statement_7457;
  }
  write(lunit6,
    "(5x,'BUT THE STEP RESPONSE FOR MODE NUMBER',i4,"
    "'   IS PHYSICALLY INVALID.   IN THEORY, THIS SHOULD BEGIN',/,5x,"
    "'AT ZERO, AND SHOULD RISE MONATONICALLY TO UNITY, AS TIME GOES TO INFINIT"
    "Y.   BUT THE VALUE FOR THE FINAL',/,5x,'POINT NUMBER',i5,'   IS',e14.3,"
    "' ,   WHICH IS NOWHERE NEAR UNITY.   IN FACT, THIS FINAL VALUE DOES')"),
    lstat(14), lstat(15), flstat(14);
  write(lunit6,
    "(5x,'NOT EVEN REACH THE THRESHOLD  ''FIT2Z'' ,   WHICH EQUALS',e14.3,"
    "' .    THE STEP RESPONSE IS THUS',/,5x,"
    "'INVALID, AND EXECUTION WILL NOT BE ALLOWED TO CONTINUE.')"),
    flstat(15);
  goto statement_6220;
  statement_7457:
  write(lunit6,
    "(5x,'BUT BETWEEN POINTS NUMBER',i6,'   AND',i6,"
    "' ,   THE RISE TO UNITY IS NOT CHARACTERIZED BY',/,5x,"
    "'MONOTONE-DECREASING SLOPE (CONCAVE DOWNWARD).   AT POINT NUMBER',i6,"
    "' ,   THERE IS TROUBLE,   LET''S DENOTE',/,5x,"
    "'THIS POINT BY  ''K'' .   VALUES FOR POINTS  K-1, K, % K+1  THEN ARE  ..."
    "',3e14.5,'  .')"),
    lstat(16), lstat(15), lstat(17), flstat(14), flstat(15), flstat(
    16);
  goto statement_6220;
  statement_6158:
  write(lunit6,
    "(5x,'THE DATA CASE UNDER STUDY INVOLVES THE CONVERSION OF EMTP DATA CARDS"
    " FOR A SATURABLE  ''TRANSFORMER''  TO',/,5x,"
    "'(R), (L)  FORMAT (TYPE-51, 52, ... ).   THIS IS A FEATURE OF SUPPORTING "
    "ROUTINE  ''XFORMER'' .   BUT THERE IS',/,5x,"
    "'TROUBLE WITH THE USER''S  ''TRANSFORMER''  DATA WHICH IS NOW BEING READ."
    "   SPECIFICALLY, ...')");
  n1 = lstat(14);
  if (n1 == 1) {
    write(lunit6,
      "(8x,'THE EMTP IS JUST BEGINNING A NEW CONVERSION CASE, AND IT EXPECTS T"
      "HE LAST-READ DATA CARD (SINCE NON-BLANK) TO',/,8x,"
      "'HAVE KEY WORD  ''TRANSFORMER''  PUNCHED IN COLUMNS  3-14 .   BUT COLUM"
      "NS  3-8  CONTAIN   ''',a6,''' .')"),
      bus5;
  }
  if (n1 == 2) {
    write(lunit6,
      "(8x,'THE DATA CARD FOR WINDING NUMBER ONE CAN NOT BE LOCATED.   COLUMN "
      " 2  MUST BE PUNCHED WITH UNITY, OF COURSE,',/,8x,"
      "'AND COLUMN  1  MUST BE EITHER BLANK OR BE PUNCHED WITH ZERO.   REREAD "
      "THE RULES GOVERNING SATURABLE  ''TRANSFORMER''',/,8x,"
      "'COMPONENT, AND CORRECT THE DATA ACCORDINGLY.')");
  }
  if (n1 == 3) {
    write(lunit6,
      "(8x,'PROGRAM WORKING SPACE ALLOWS FOR A MAXIMUM OF  19  WINDINGS,   WHI"
      "CH HAS BEEN EXCEEDED BY THE USER''S DATA.')");
  }
  goto statement_6220;
  statement_6159:
  write(lunit6, "(5x,'INVALID KILL CODE =',i5)"), kill;
  goto statement_6220;
  statement_6160:
  write(lunit6,
    "(5x,'THE FREQUENCY CARD CONTAINING THE NUMBER OF DECADES  AND THE NUMBER "
    "OF FREQUENCIES PER DECADE',/,5x,"
    "'IK AND IPS RESPECTIVELY, FOR THE INVERSE FOURIER TRANSFORM',/,5x,"
    "'HAS REQUESTED A TOTAL NUMBER OF FREQUENCIES GREATER THAN THE AVAILABLE S"
    "TORAGE OF',i5,/,5x,"
    "'SURELY WITH A GEOMETRIC PROGRESSION OF FREQUENCIES, THIS MANY STEPS IS N"
    "OT NECESSARY.')"),
    lstat(14);
  goto statement_6220;
  statement_6161:
  write(lunit6,
    "(5x,' THE LAST-READ DATA CARD BEARS THE SPECIAL REQUEST WORD  ''TRANSFORM"
    "ER ''   IN COLUMNS  3-14, AND IS THE FIRST',/,5x,"
    "'OF SEVERAL CARDS USED TO DEFINE A SATURABLE TRANSFORMER COMPONENT.   BUT"
    " THE USER HAS FAILED TO PUNCH COLUMNS',/,5x,"
    "'39-44  (FIELD  ''BUSTOP'' )   WITH A NON-BLANK 6-CHARACTER (A6) ALPHANUM"
    "ERIC NAME.   THIS IS THE NODE NAME FOR THE',/,5x,"
    "'EXTRA, INTERNAL NODE OF THE SATURABLE TRANSFORMER COMPONENT, AT THE TOP "
    "OF THE MAGNETIZING BRANCH (SEE TRANSFORMER')");
  write(lunit6,
    "(5x,'EQUIVALENT CIRCUIT IN THE EMTP USER''S MANUAL).   THE DATA FIELD  ''"
    "BUSTOP''  FOR EACH SATURABLE TRANSFORMER',/,5x,"
    "'COMPONENT MUST BE NON-BLANK, AND ALL SHOULD BE UNIQUE --- DIFFERENT FROM"
    " EACH OTHER, AND ALSO DIFFERENT FROM ALL',/,5x,"
    "'OTHER EMTP NETWORK NODES.')");
  goto statement_6220;
  statement_6162:
  write(lunit6,
    "(5x,'THE USER IS RUNNING A  ''LINE CONSTANTS''  DERIVATION IN WHICH THE E"
    "MTP AUTOMATICALLY LOOPS OVER THE DIFFERENT',/,5x,"
    "'FREQUENCIES OF INTEREST.   ON THE FREQUENCY CARD WHICH REQUESTED THIS MO"
    "DE OF PROGRAM EXECUTION, THE FIELD FOR',/,5x,"
    "'EMTP VARIABLE  ''IPUNCH''  (COLUMNS  66-68 ,   READ USING  I3  FORMAT)  "
    "CONTAINS AN ILLEGAL NUMERICAL VALUE.',/,5x,"
    "'ONLY VALUES  0,  1,  2,  3,  88,  AND  89  ARE RECOGNIZED AS BEING LEGIT"
    "IMATE, ALTHOUGH A VALUE OF  ''',i3,'''  WAS')"),
    cmn.ipunch;
  write(lunit6,
    "(5x,'READ FROM THE USER''S FREQUENCY CARD.   CORRECT THIS VALUE, AND TRY "
    "AGAIN.')");
  goto statement_6220;
  statement_6163:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD IS FOR A TACS SOURCE OF TYPE',i5,"
    "' (TYPE CODE AS READ FROM COLUMNS 1-2 OF THE SOURCE',/,5x,"
    "'CARD).   BUT NO VALID EMTP ELECTRIC-NETWORK NODE NAMES WERE SPECIFIED BY"
    " THE USER ON EITHER A PRECEDING   ''TACS',/,5x,"
    "'EMTP SOURCES''   CARD,  OR ON A PRECEDING   ''TACS OUTPUTS''   CARD.   H"
    "ENCE THE EMTP CONCLUDES THAT THERE IS NO',/,5x,"
    "'ELECTRIC NETWORK, THAT THE PRESENT PROBLEM BEING INPUTTED IS A TACS STAN"
    "D-ALONE CASE.   BUT TACS SOURCE TYPES')"),
    lstat(14);
  write(lunit6,
    "(5x,' 90,  91,  ETC.  ALL COME FROM THE ELECTRIC-NETWORK SIDE OF THE EMTP"
    ", BY DEFINITION.   IN SUM, THE USER HAS',/,5x,"
    "'REQUESTED THAT A TACS SOURCE BE DETERMINED BY A NON-EXISTENT PART OF THE"
    " PROBLEM.   THIS DISCREPANCY MUST BE',/,5x,"
    "'CORRECTED, BEFORE EXECUTION WILL BE ALLOWED TO CONTINUE.')");
  goto statement_6220;
  statement_6164:
  write(lunit6, "(5x,'  UNUSED.      ')");
  goto statement_6220;
  statement_6165:
  write(lunit6,
    "(5x,'DURING CALCULATION OF EIGENVALUES AND EIGENVECTORS BY THE POWER METH"
    "OD,',/,5x,"
    "'THE ITTERATION COUNT HAS EXCEEDED \"NIEIG\".  THIS LIMIT AND THE CORRESP"
    "ONDING TOLERANCE \"EPSEIG\"',/,5x,"
    "'MAY BE CHANGED BY A \"TOLERANCES\" CARD.')");
  goto statement_6220;
  statement_6166:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD IS ASSUMED BY THE EMTP TO HAVE FREE-FORMAT D"
    "ATA ON IT, DUE TO THE PRESENCE OF ONE OR',/,5x,"
    "'MORE SEPARATOR CHARACTERS  ''',a1,"
    "'''  OR  CONTINUATION-CARD CHARACTERS  ''',a1,"
    "''' .   WELL, EMTP CONTROL WAS WITHIN MODULE',/,5x,"
    "'''FREFLD''  OF UTPF OVERLAY  (MAIN00, -1)  WHEN THE DATA RAN OUT.   THAT"
    " IS, CONTROL WAS LOOKING FOR MORE DATA ITEMS')"),
    cmn.csepar, cmn.chcont;
  write(lunit6,
    "(5x,'THAN HAVE BEEN PUNCHED ON THE CARD.   THE USER SHOULD FIRST VERIFY T"
    "HAT THE DATA CARD IN QUESTION WAS INTENDED',/,5x,"
    "'TO BE FREE-FIELD DATA FORMAT.   THEN, HE SHOULD CHECK ALL DATA ITEMS, CO"
    "UNTING SEPARATOR CHARACTERS (WHICH',/,5x,"
    "'DEFINE THE NUMBER OF DATA ITEMS).')");
  goto statement_6220;
  statement_6167:
  n1 = fem::iabs(lstat(14));
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD HAS THE  ''BUS3''  FIELD OF COLUMNS  15-20  "
    "PUNCHED WITH   ''',a6,''' ,   SO THAT THE',/,5x,"
    "'''BUS4''  FIELD OF COLUMNS  21-26  IS TO BE THE NAME OF THE BRANCH.   BU"
    "T THE 6-CHARACTER TEXT USED FOR THIS NAME,',/,5x,'''',a6,"
    "''' ,   IS NOT NEW AND UNIQUE AS REQUIRED BY EMTP LAW.   90 DAYS IN JAIL "
    "OR A $100 FINE.   ROW NUMBER',i6,'   OF THE')"),
    cmn.branch, bus4, n1;
  if (lstat(14) > 0) {
    write(lunit6,
      "(5x,'LINEAR BRANCH TABLE CONTAINS A LINEAR BRANCH WHICH HAS ALREADY BEE"
      "N SO NAMED.')");
  }
  if (lstat(14) < 0) {
    write(lunit6,
      "(5x,'NONLINEAR BRANCH TABLE CONTAINS A NONLINEAR OR PSEUDO-NONLINEAR BR"
      "ANCH WHICH HAS ALREADY BEEN SO NAMED.')");
  }
  goto statement_6220;
  statement_6168:
  write(lunit6, "(' UNUSED.')");
  statement_6169:
  write(lunit6, "(' UNUSED.')");
  statement_6170:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD IS A  ''LINE CONSTANTS''  FREQUENCY CARD WHI"
    "CH BELONGS TO THE INTERIOR DATA OF ANOTHER',/,5x,"
    "'EMTP SUPPORTING PROGRAM (E.G.,  ''SEMLYEN SETUP'' ).   BUT THE EMTP LIMI"
    "T ON SUCH INDIVIDUALLY-SPECIFIED FREQUENCIES',/,5x,'IS',i5,"
    "' ,   WHICH HAS BEEN OVERFLOWED BY THE LAST-READ DATA CARD.   DIMENSIONIN"
    "G OF THE CRUCIAL ARRAYS IN',/,5x,"
    "'QUESTION IS NOT UNDER USER CONTROL.   A COMPLETE EMTP RECOMPILATION WOUL"
    "D BE REQUIRED IN ORDER TO INCREASE THIS',/,5x,"
    "'LIMIT, SHOULD THIS PROVE TO BE REALLY NECESSARY.')"),
    lstat(14);
  goto statement_6220;
  statement_6171:
  write(lunit6,
    "(5x,'THE BRANCH CARD NOW BEING PROCESSED REPRESENTS A REQUEST FOR SEMLYEN"
    " RECURSIVE CONVOLUTION MODELING.   BUT',/,5x,"
    "'THE USER SPECIFIED FLOATING-POINT MISCELLANEOUS DATA PARAMETERS  ''XOPT'"
    "'  AND  ''COPT''  AS',e13.4,'   AND',/,5x,e13.4,"
    "' ,   RESPECTIVELY.   THIS IS ILLEGAL.   BOTH PARAMETERS MUST BE EQUAL, A"
    "ND ALSO NONZERO.')"),
    cmn.xopt, cmn.copt;
  goto statement_6220;
  statement_6172:
  write(lunit6, format_7172);
  write(lunit6,
    "(5x,'A VALUE OF',i5,"
    "'   WAS READ FROM THE FIELD  ''ITYPEC''  OF COLUMNS  1  THROUGH  5  OF TH"
    "E CARD, USING',/,5x,"
    "' I5  FORMAT.   BUT ONLY THE VALUES  1  (FOR OVERHEAD LINE CONSTANTS) AND"
    "  2  (FOR CABLE CONSTANTS) ARE LEGAL, IF',/,5x,"
    "'THE CARD IN QUESTION IS NONBLANK (RECALL THAT A BLANK CARD MARKS THE END"
    " OF SUCH CASES WITHIN  ''CABLE CONSTANTS'' ).')"),
    lstat(14);
  goto statement_6220;
  statement_6173:
  write(lunit6, format_7172);
  write(lunit6,
    "(5x,'FIELD  ''ISYST''  OF COLUMNS  6  THROUGH  10  HAS BEEN PUNCHED WITH "
    "THE INTEGER VALUE  -1 ,   WHICH MEANS THAT',/,5x,"
    "'AN UNDERGROUND CABLE SYSTEM IS TO BE UNDER CONSIDERATION.   BUT FIELD  '"
    "'IEARTH''  OF COLUMNS  16  THROUGH  20',/,5x,"
    "'HAS BEEN PUNCHED WITH THE INTEGER VALUE  99 ,   WHICH MEANS THAT THE STR"
    "ATIFIED-EARTH OPTION IS DESIRED.   BUT',/,5x,"
    "'THIS COMBINATION OF FEATURES IS ILLEGAL (THE EMTP IS INCAPABLE OF FINDIN"
    "G THE PARAMETERS FOR AN UNDERGROUND',/,5x,"
    "'CABLE WHEN THE EARTH IS NOT HOMOGENEOUS AND UNIFORM).')");
  goto statement_6220;
  statement_6174:
  write(lunit6,
    "(5x,'ALL CONDUCTOR CARDS OF AN OVERHEAD-LINE CASE WITHIN THE  ''CABLE CON"
    "STANTS''  SUPPORTING PROGRAM HAVE NOW BEEN',/,5x,"
    "'READ.   BUT ONE OR MORE OF THESE CARDS HAS BEEN PUNCHED WITH ILLEGAL OR "
    "INCONSISTENT DATA.   SPECIFICALLY,')");
  n1 = 3 * lstat(14) - 1;
  write(lunit6,
    "(5x,'NON-COMMENT CARD NUMBER',i4,"
    "'  AFTER THE MISCELLANEOUS DATA CARD BEARS GEOMETRICAL CONDUCTOR DATA WHI"
    "CH',/,5x,"
    "'IS PHYSICALLY IMPOSSIBLE.   THE INNER RADIUS OF THE CONDUCTOR HAS BEEN R"
    "EAD AS',e16.4,'   METERS, WHILE',/,5x,'THE OUTER RADIUS IS',e16.4,"
    "' .    THIS VIOLATES THE EMTP RESTRICTION THAT THE TUBULAR CONDUCTOR',/,"
    "5x,'THICKNESS MUST BE POSITIVE.   ZERO OR NEGATIVE THICKNESS IS NOT ALLOW"
    "ED.')"),
    n1, flstat(15), flstat(16);
  goto statement_6220;
  statement_6175:
  write(lunit6,
    "(5x,'SUBROUTINE  ''EIGEN''  IS USED TO CALCULATE EIGENVALUES OF THE   (Z)"
    "(Y)   MATRIX PRODUCT, WITHIN THE  ''CABLE',/,5x,"
    "'CONSTANTS''  SUPPORTING PROGRAM.   BUT WITHIN THE ITERATION LIMIT OF',"
    "i5,' ,   THE ITERATIVE ALGORITHM HAS',/,5x,"
    "'FAILED TO SATISFY THE CONVERGENCE TOLERANCE OF',e14.2,"
    "' .    THE RESULTING EIGENVALUES MUST BE',/,5x,"
    "'VIEWED WITH SUSPICION (AT BEST), SO THE SOLUTION IS BEING TERMINATED AT "
    "THIS POINT.')"),
    lstat(15), flstat(14);
  goto statement_6220;
  statement_6176:
  write(lunit6,
    "(5x,'ERROR IS IN SYNCHRONOUS MACHINE ELECTRICAL DATA. ',/,5x,"
    "'DATA HAS ONE OR MORE OF THE FOLLOWING ERRORS  ',/,10x,"
    "'1. XL NOT SMALLEST REACTANCE',/,10x,'2. XDPP NOT SMALLER THAN XDP',/,"
    "10x,'3. XDP  NOT SMALLER THAN XD',/,10x,'4. XQPP NOT SMALLER THAN XQP',/,"
    "10x,'5. XQP  NOT SMALLER THAN XQ',/,10x,"
    "'6. ONE OR MORE REACTANCES OR RA IS NEGATIVE ',/)");
  goto statement_6220;
  statement_6177:
  write(lunit6,
    "(5x,'THE EMTP IS PRESENTLY IN THE PROCESS OF READING EMTP SOURCE CARDS, W"
    "ITH THE LAST-READ CARD PRODUCING A',/,5x,"
    "'VIOLATION OF THE ORDERING RESTRICTION WHICH IS APPLICABLE WHEN DYNAMIC S"
    "YNCHRONOUS MACHINE (S.M.) SOURCE',/,5x,"
    "'COMPONENTS ARE PRESENT.   RECALL THAT ALL NON-S.M. SOURCE CARDS MUST PRE"
    "CEDE ANY S.M. SOURCE CARDS, IN ORDER OF',/,5x,"
    "'DATA INPUT.   THUSFAR THERE HAVE BEEN',i4,"
    "'   S.M. SOURCE COMPONENTS INPUTTED (WITH AN SCE DUAL MACHINE')"),
    numsm;
  write(lunit6,
    "(5x,'COUNTING AS JUST ONE SOURCE COMPONENT), BEFORE THELAST-READ DATA CAR"
    "D.   BUT THE LAST DATA CARD HAS THE FIELD',/,5x,"
    "'OF SOURCE TYPE-CODE  ''ITYPE''  (COLUMNS 1-2) PUNCHED WITH THE INTEGER V"
    "ALUE',i5,' ,   WHICH IS NOT A LEGAL',/,5x,"
    "'CHARACTERIZATION FOR A S.M. SOURCE COMPONENT.   THE LAST-READ DATA CARD "
    "IS THUS EITHER ERRONEOUS BY ITSELF, OR',/,5x,"
    "'OUT OF ORDER (IT MUST PRECEDE THE FIRST S.M. SOURCE COMPONENT).')"),
    lstat(14);
  goto statement_6220;
  statement_6178:
  write(lunit6,
    "(5x,'THE EMTP IS PRESENTLY INPUTTING SOURCE COMPONENTS, WITH THE LAST-REA"
    "D DATA CARD SERVING TO DEFINE THE NETWORK',/,5x,"
    "'CONNECTION FOR THE THIRD AND FINAL PHASE OF A 3-PHASE DYNAMIC SYNCHRONOU"
    "S MACHINE (S.M.) COMPONENT.   BUT THE',/,5x,"
    "'SOURCE TYPE-CODE FOR THIS COMPONENT IS ILLEGAL (UNRECOGNIZABLE).   FROM "
    "THE FIELD  ''ITYPE''  (COLUMNS 1-2) OF',/,5x,"
    "'THE FIRST DATA CARD FOR THIS S.M. COMPONENT --- TWO NON-COMMENT CARDS BE"
    "FORE THE LAST-READ DATA CARD --- WAS',/,5x,'READ A TYPE CODE OF',i2,"
    "' .    BUT ONLY S.M. MODEL TYPES  51  THROUGH  54  AND  59  ARE PRESENTLY"
    " AVAILABLE.')"),
    lstat(14);
  write(lunit6,
    "(5x,'FURTHER, THE USER IS ALLOWED TO USE EITHER MACHINE TYPES  51-54 ,   "
    "OR TYPE  59  ---- BUT NOT A MIXTURE OF',/,5x,"
    "'THE TWO.   RECALL THAT THESE TWO CLASSES OF S.M.  ARE QUITE DIFFERENT, U"
    "TILIZING DIFFERENT SOLUTION METHODS.',/,5x,"
    "'THE JUST-READ DYNAMIC  S.M.  EMTP  SOURCE COMPONENT WAS NUMBER',i4,"
    "'   IN ORDER OF INPUT.')"),
    numsm;
  goto statement_6220;
  statement_6179:
  write(lunit6,
    "(5x,'THE DATA CASE UNDER CONSIDERATION HAS TOO MANY OUTPUT QUANTITIES FOR"
    " THE PRESENT EMTP TABLE SIZES.   THIS IS',/,5x,"
    "'REALLY AN OVERFLOW OF EMTP LIST NUMBER  11 ,   THOUGH NOT DUE TO CONVENT"
    "IONAL EMTP ELECTRIC-NETWORK BRANCH OR',/,5x,"
    "'NODE QUANTITIES.   RATHER, IT IS THE ADDED BURDEN OF DYNAMIC SYNCHRONOUS"
    " MACHINE (S.M.) OUTPUT VARIABLES, PLUS',/,5x,"
    "'THE BURDEN OF TACS OUTPUT VARIABLES, WHICH HAS NOW LED TO THE PRESENT LI"
    "ST-11 OVERFLOW.   FIGURES WHICH')");
  write(lunit6,
    "(5x,'CHARACTERIZE THIS DIFFICULTY ARE AS FOLLOWS ....',/,5x,i5,"
    "' = PRESENT USER-DIMENSIONED SIZE OF LIST 11',/,5x,i5,"
    "' = NUMBER OF CONVENTIONAL ELECTRIC-NETWORK BRANCH-OUTPUT QUANTITIES',/,"
    "5x,i5,' = NUMBER OF S.M. OUTPUT QUANTITIES',/,5x,i5,"
    "' = NUMBER OF TACS OUTPUT QUANTITIES',/,5x,"
    "'THE LAST THREE FIGURES ABOVE TOTAL',i6,"
    "' ,   WHICH IS THEREFORE THE MINIMUM ACCEPTABLE SIZE OF LIST NUMBER 11.')"
    ""),
    cmn.lsiz12, cmn.nc, lstat(15), lstat(16), lstat(14);
  write(lunit6,
    "(5x,'EITHER INCREASE THE SIZE OF LIST 11 TO AT LEAST THIS SIZE, OR APPROP"
    "RIATELY REDUCE THE NUMBER OF OUTPUT',/,5x,"
    "'QUANTITIES, BEFORE TRYING ONCE AGAIN TO SOLVE THE DATA CASE IN QUESTION."
    "')");
  kill = 1;
  lstat(16) = 11;
  nchain = 51;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  goto statement_99999;
  statement_6180:
  write(lunit6,
    "(5x,'THE SIZE OF ARRAY ''VOLTBC'', DEFINED IN BLKCOM TO BE',i6,',',3x,"
    "'IS NOT ADEQUATE FOR THE USE OF THAT ARRAY IN THE',/,5x,"
    "'PROCESSING OF OUTPUT REQUESTS FOR THE TYPE 59 S.M.  A MINIMUM OF',i5,3x,"
    "'CELLS IS REQUIRED.')"),
    lstat(16), lstat(17);
  goto statement_6220;
  statement_6181:
  write(lunit6,
    "(5x,'INCONSISTENCY DISCOVERD ON ONE OF THE MASS CARDS . THE SPECIFIED MAS"
    "S NO. WAS',i5,'.',3x,'FOR A S.M. WITH',i5,'  MASSES',/,5x,"
    "'ALLOWABLE RANGE IS BETWEEN     1   AND',i5,'  MASSES.')"),
    lstat(15), lstat(16), lstat(16);
  goto statement_6220;
  statement_6182:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'THE NUMBER OF FREQUENCY CARDS WHICH ARE PRESENT IN THE PREVIOUSLY-RE"
    "AD LINE-CONSTANTS DATA IS INCORRECT.',/,5x,"
    "'BEFORE THE ONE WHICH REQUESTS AN AUTOMATIC LOOPING OVER LOGARITHMICALLY-"
    "SPACED FREQUENCIES, THERE WERE',i4,/,5x,"
    "'FREQUENCY CARDS, EACH OF WHICH REQUESTS THE LINE-CONSTANTS CALCULATION A"
    "T AN INDIVIDUAL, DISCRETE FREQUENCY.',/,5x,"
    "'BUT THE TRANSPOSITION FLAG (MISCELLANEOUS DATA PARAMETER  ''NSS''  )  HA"
    "D VALUE',i4,' .   THESE TWO INTEGERS')"),
    lstat(14), lstat(15);
  write(lunit6,
    "(5x,'SHOULD ADD UP TO TWO.   BUT THEY DO NOT.   REMEMBER, FOR AN UNTRANSP"
    "OSED LINE, THERE ARE TO BE TWO DISCRETE-',/,5x,"
    "'FREQUENCY CARDS, WHILE A TRANSPOSED LINE REQUIRES EXACTLY ONE.')");
  goto statement_6220;
  statement_6183:
  j = lstat(13);
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'THE FREQUENCY CARDS WHICH ARE PRESENT IN THE PREVIOUSLY-READ LINE-CO"
    "NSTANTS DATA ARE NOT ALL CONSISTENT.',/,5x,"
    "'THE EMTP REQUIRES THAT ALL SUCH CARDS APPLY TO THE SAME MODEL OF THE TRA"
    "NSMISSION LINE.   BUT IT WILL BE NOTED',/,5x,"
    "'THAT AN EARTH RESISTIVITY OF',e17.5,"
    "'   OHM-METERS WAS READ FROM FREQUENCY CARD NUMBER',i4,' ,   WHILE',/,5x,"
    "e17.5,"
    "'   WAS READ FROM THE FIRST SUCH CARD.   THESE TWO RESISTIVITIES ARE UNEQ"
    "UAL, WHICH IS ILLEGAL.')"),
    volti(j), j, cmn.ci1;
  goto statement_6220;
  statement_6184:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'THE PREVIOUSLY-READ LINE-CONSTANTS DATA CARDS ARE ILLEGALLY-STRUCTUR"
    "ED FOR USAGE WITH  ''SEMLYEN SETUP'' .',/,5x,"
    "'FIRST, THERE SHOULD BE THE LINE-CONDUCTOR CARDS, TERMINATED BY A BLANK C"
    "ARD.   THEN COME THE FREQUENCY CARDS,',/,5x,"
    "'WITH ONLY THE LAST OF THESE REQUESTING THE LOGARITHMIC FREQUENCY-LOOPING"
    " OPTION.   FINALLY, A BLANK CARD',/,5x,"
    "'TERMINATES THE FREQUENCY CARDS, AND A SECOND BLANK CARD FINISHES THE LIN"
    "E CONSTANTS DATA CARDS.',10x,'N1 =',i2)"),
    lstat(13);
  goto statement_6220;
  statement_6185:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'THE EMTP HAS PREVIOUSLY READ A VALUE OF',i6,"
    "'   (DECIMAL) FOR THE MISCELLANEOUS DATA PARAMETER',/,5x,"
    "' ''IOTX''  WHICH CONTROLS PRINTOUT.   BUT THIS EXCEEDS THE LEGAL MEANING"
    "FUL LIMIT OF',i6,'  (DECIMAL).')"),
    lstat(13), lstat(14);
  goto statement_6220;
  statement_6186:
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'FOR PURPOSES OF  ''SEMLYEN SETUP''  USAGE, THE FREQUENCIES FOR WHICH"
    " LINE CONSTANTS HAVE JUST BEEN CALCULATED',/,5x,"
    "'ARE INAPPROPRIATE.   RECALL THAT WITHIN THE LINE-CONSTANTS DATA, THE FRE"
    "QUENCY CARD FOR LOGARITHMIC LOOPING OVER',/,5x,"
    "'A RANGE OF FREQUENCIES IS TO BE PRECEEDED BY A FREQUENCY CARD FOR THE ST"
    "EADY-STATE FREQUENCY.   THE SEMLYEN CODE',/,5x,"
    "'REQUIRES THAT THE BEGINNING LOOP-FREQUENCY EXCEED THE STEADY-STATE FREQU"
    "ENCY.   BUT SUCH IS NOT THE CASE FOR THE',/,5x,'USER''S DATA (VALUES OF',"
    "e16.4,'   AND',e16.4,'   WERE PUNCHED FOR THESE, RESPECTIVELY).')"),
    voltbc(1), voltk(cmn.icheck);
  goto statement_6220;
  statement_6187:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD BELONGS TO A  ''SEMLYEN SETUP''  DATA CASE, "
    "BUT IS NOT WHAT THE EMTP WAS EXPECTING.',/,5x,"
    "'FOLLOWING THE FIRST SEMLYEN MISCELLANEOUS DATA CARD, THE USER MUST SUPPL"
    "Y A CARD WHICH BEARS EITHER THE TEXT',/,5x,"
    "' ''LINE CONSTANTS''   OR THE TEXT   ''CABLE CONSTANTS'' ,   PUNCHED IN C"
    "OLUMNS ONE ONWARD.   NOT SO FOR THE USER''S',/,5x,"
    "'CARD, THE COLUMN 1-18 CONTENTS OF WHICH WERE READ AS   ''',3a6,"
    "''' .    CORRECT THIS CARD SO AS TO')"),
    cmn.bus3, bus4, bus5;
  write(lunit6,
    "(5x,'PROPERLY INFORM THE EMTP AS TO WHICH SUPPORTING ROUTINE PROGRAM CONT"
    "ROL IS TO BE TRANSFERRED TO NEXT.')");
  goto statement_6220;
  statement_6188:
  d1 = flstat(13) / twopi;
  d2 = flstat(15) / twopi;
  write(lunit6, format_7154);
  write(lunit6,
    "(5x,'AFTER HAVING COMPLETED THE  ''LINE CONSTANTS''  OR  ''CABLE CONSTANT"
    "S''  CALCULATION, PROGRAM CONTROL IS NOW',/,5x,"
    "'BACK IN THE  ''SEMLYEN SETUP''  OVERLAY WHERE MATRICES  (R),  (X),  (G),"
    "  AND  (B)  ARE BEING READ FROM INPUT/OUTPUT',/,5x,"
    "'UNIT NUMBER  3 .   BUT THE CAPACITANCE MATRIX IS ERRONEOUS.   IT SHOULD "
    "BE INDEPENDENT OF FREQUENCY, BUT IS NOT.',/,5x,"
    "'IN PARTICULAR, THE FIRST DIAGONAL ENTRY  C(1,1) =',e20.8,"
    "'   FARAD/LENGTH FOR FREQUENCY',e18.6)"),
    d1, flstat(14);
  write(lunit6,
    "(5x,'HZ,  WHILE THE  C(1,1)  VALUE FOR THE PRECEDING FREQUENCY WAS',"
    "e20.8,' .   IT IS REQUIRED THAT',/,5x,"
    "'THESE CAPACITANCES AGREE WITHIN A TOLERANCE OF',e14.2,"
    "'   (FLOATING-POINT MISCELLANEOUS DATA PARAMETER',/,5x,"
    "' ''EPSILN'' ).   FOR THE USER''S DATA, THIS CHECK HAS NOT BEEN MET.   TH"
    "E CAPACITANCE MATRICES ARE JUDGED TO BE',/,5x,"
    "'INVALID, AND THE SOLUTION IS BEING TERMINATED.')"),
    d2, cmn.epsiln;
  goto statement_6220;
  statement_6189:
  write(lunit6,
    "(5x,'THE EMTP DATA CASE NOW BEING PROCESSED MAKES USE OF THE TACS MODELIN"
    "G CAPABILITY, ALL DATA CARDS FOR WHICH',/,5x,"
    "'HAVE NOW BEEN READ.   AS THE PRECEDING PRINTOUT SHOWS, THE VECTOR OF TAC"
    "S VARIABLE NAMES HAS REPEATED ENTRIES.',/,5x,'THERE ARE',i4,"
    "'   SUCH CONFLICTS.   THE TROUBLE CAN BE TRACED BACK TO THE DEFINITION OF"
    " TACS FUNCTION BLOCKS,',/,5x,"
    "'TACS SUMMERS, AND TACS SUPPLEMENTAL VARIABLES AND DEVICES.   ALL NAMES A"
    "SSIGNED TO SUCH OUTPUTS MUST BE DISTINCT.')"),
    lstat(15);
  write(lunit6,
    "(5x,'FOR EXAMPLE, IF A TACS FUNCTION BLOCK IS GIVEN THE NAME  ''KONTRL'' "
    " (READ FROM COLUMNS 3-8 OF THE DATA CARD',/,5x,"
    "'DEFINING THE BLOCK), THEN THIS SAME 6-CHARACTER NAME HAD BETTER NOT BE U"
    "SED FOR A TACS SUPPLEMENTAL VARIABLE',/,5x,"
    "'(READ FROM COLUMNS 3-8 OF THE VARIABLE-DEFINITION CARD).')");
  goto statement_7421;
  statement_6190:
  write(lunit6,
    "(5x,'THE EMTP HAS BEEN READING DATA CARDS WHICH DEFINE A DYNAMIC SYNCHRON"
    "OUS MACHINE (S.M.) COMPONENT.   THE LAST-',/,5x,"
    "'READ CARD FOLLOWS THE S.M. OUTPUT-REQUEST CARD, AND PRECEDES THE  ''FINI"
    "SH''  CARD|   HAVING COLUMNS 1-2 PUNCHED',/,5x,'WITH  ''',i2,"
    "''' ,   THIS CARD REPRESENTS A REQUEST THAT THE MACHINE BE CONTROLLED BY "
    "TACS.    BUT EITHER THE A-6',/,5x,'NAME  ''',a6,"
    "'''  WHICH WAS READ FROM COLUMNS 3-8 IS NOT A LEGAL TACS-VARIABLE NAME FO"
    "R THIS PURPOSE, SINCE IT')"),
    lstat(14), cmn.bus6;
  write(lunit6,
    "(5x,'WAS NOT ALSO PUNCHED ON A   ''TACS OUTPUTS''   CARD WHICH BEGAN THE "
    "INPUT OF TACS DATA.   BEFORE TACS VARIABLES',/,5x,"
    "'CAN BE USED WITHIN THE ELECTRIC NETWORK, THEY MUST BE DECLARED ON A   ''"
    "TACS OUTPUTS''   OR A   ''TACS EMTP SOURCES''',/,5x,'CARD.')");
  write(lunit6,
    "(5x,'OR... THE NUMBER PUNCHED IN COLUMNS 15-17',"
    "' HAS AN INCORRECT VALUE OF,',i5)"),
    lstat(15);
  goto statement_6220;
  statement_6191:
  write(lunit6,
    "(5x,'THE EMTP FINDS THE USER''S DATA CASE TO BE OBNOXIOUSLY DEGENERATE, A"
    "ND REFUSES TO CONTINUE WITH THE SIMULATION.',/,5x,"
    "'THE ELECTRIC NETWORK HAS NO SOURCES AND NO DYNAMIC SYNCHRONOUS MACHINES,"
    " SO ONLY A NATURAL (UNFORCED) SOLUTION',/,5x,"
    "'IS CALLED FOR.   BUT THE USER HAS FAILED TO INPUT ANY NONZERO INITIAL CO"
    "NDITIONS.   HENCE THE SOLUTION WILL BE',/,5x,"
    "'IDENTICALLY ZERO FOR ALL TIME.   THERE IS NO NEED TO CONTINUE WITH THE S"
    "OLUTION, THEN.')");
  goto statement_6220;
  statement_6192:
  write(lunit6,
    "(5x,'DURING THE LIST-BUILDING OPERATION WHICH IS REQUIRED FOR CONNECTIVIT"
    "Y OUTPUT, THE TEMPORARY WORKING VECTORS',/,5x,"
    "'OF LIST 99 WHICH ARE USED HAVE OVERFLOWED.   THE PROPER SOLUTION IS TO R"
    "EDIMENSION THE EMTP, THOUGH REMOVAL OF',/,5x,"
    "'THE ''1''-PUNCH IN FIELD  ''IDOUBL''  OF THE INTEGER MISCELLANEOUS DATA "
    "CARD WILL BYPASS THE PRESENT COMPLICATION.',/,5x,"
    "'BUT UNLESS THE USER INCREASES DIMENSIONS, HE WILL PROBABLY JUST BE STOPP"
    "ED SHORTLY HEREAFTER, IN RENUMBERING.')");
  write(lunit6,
    "(5x,'BOTH COMPUTATIONS USE THE SAME ARRAYS, AND HAVE RELATED STORAGE REQU"
    "IREMENTS.   LISTS NUMBER 5 % 8 CONTRIBUTE',/,5x,"
    "'TOTALLY TO DEPENDENT LIST NUMBER 99.')");
  goto statement_6220;
  statement_6193:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD BEARS THE KEY WORD   ''FREQUENCY SCAN''   IN"
    " COLUMNS 1-14.   THIS IS A REQUEST FOR THE',/,5x,"
    "'AUTOMATIC LOOPING OVER STEADY-STATE PHASOR SOLUTIONS ONLY, AS THE SOURCE"
    " FREQUENCY IS METHODICALLY INCREASED.',/,5x,'A BEGINNING FREQUENCY OF',"
    "e15.4,"
    "'   WAS READ FROM THE  ''FMIN''  FIELD OF COLUMNS 25-32 USING  E8.0',/,"
    "5x,'FORMAT, AND MUST BE POSITIVE (TO BE LEGAL DATA).   THE FREQUENCY INCR"
    "EMENT  ''DELF''  OF COLUMNS 33-40 WAS READ USING')"),
    cmn.fminfs;
  write(lunit6,
    "(5x,'E8.0  FORMAT AS',e15.4,"
    "' .    THIS MUST BE POSITIVE, UNLESS DATA FIELD  ''LOG''  OF COLUMNS 49-5"
    "6',/,5x,"
    "'(SEE BELOW) IS PUNCHED POSITIVE.   THE MAXIMUM (OR END) FREQUENCY  ''FMA"
    "X''  OF COLUMNS 41-48 WAS READ AS',e15.4,/,5x,"
    "' ,   WHICH MUST EXCEED  ''FMIN'' .   FINALLY, INTEGER FIELD  ''LOG''  OF"
    " COLUMNS 49-56 WAS PUNCHED WITH THE VALUE',/,5x,i5,"
    "' ,   WHICH MUST NOT BE NEGATIVE.   THE USER''S DATA CARD IS ILLEGAL IN T"
    "HAT IT VIOLATES ONE OR MORE OF THESE',/,5x,'JUST-DELINEATED RULES.')"),
    cmn.delffs, cmn.fmaxfs, lstat(14);
  goto statement_6220;
  statement_6194:
  write(lunit6,
    "(5x,'THE DATA CASE NOW BEING READ IN INCLUDES A REQUEST FOR THE  ''FREQUE"
    "NCY SCAN''  FEATURE.   BUT THE SOURCE',/,5x,"
    "'DATA IS INCONSISTENT WITH THIS INTENDED USAGE.   TO BE LEGAL, THERE MUST"
    " BE AT LEAST ONE TYPE-14 EMTP SOURCE',/,5x,"
    "'COMPONENT WHICH IS PRESENT DURING THE STEADY-STATE PHASOR NETWORK SOLUTI"
    "ONS (AS REQUESTED BY PUNCHING DATA FIELD',/,5x,"
    "' ''TSTART''  OF COLUMNS 61-70 NEGATIVE).   BUT THE USER HAS',i5,"
    "'   EMTP SOURCE COMPONENTS, OF WHICH',i5,'   ARE',/,5x,"
    "'OF TYPE 14, OF WHICH (IN TURN)',i5,'   HAVE  ''TSTART''  NEGATIVE.')"),
    cmn.kconst, lstat(13), lstat(14);
  goto statement_6220;
  statement_6195:
  write(lunit6,
    "(5x,'THE EMTP IS IN THE PROCESS OF INPUTTING BRANCH CARDS FOR A TRANSMISS"
    "ION CIRCUIT WHICH IS MODELED USING',/,5x,"
    "'AMETANI LINEAR CONVOLUTION.   THE LAST-READ DATA CARD CONTAINS PARAMETER"
    "S FOR MODE NUMBER',i5,' .    BUT',/,5x,"
    "'THE INTEGER WHICH WAS READ FROM COLUMNS  73-74  USING  I2  FORMAT IS   '"
    "'',i2,''' .    THIS IS THE NUMBER OF',/,5x,"
    "'LINEAR SEGMENTS WHICH REPRESENT THE RESPONSE ---- WHICH IS PRESENTLY CON"
    "STRAINED TO EQUAL FIVE.    RE-RUN',/,5x,"
    "' ''AMETANI SETUP''   TO GET A VALID NEW SET OF BRANCH CARDS FOR THE CIRC"
    "UIT, AND THEN TRY AGAIN.')"),
    lstat(14), lstat(15);
  goto statement_6220;
  statement_6196:
  write(lunit6,
    "(5x,'EMTP CONTROL IS NOW IN THE   ''AMETANI SETUP''   SUPPORTING ROUTINE,"
    " READY TO TRANSFER TO EITHER   ''CABLE',/,5x,"
    "'CONSTANTS''   OR   ''LINE CONSTANTS'' .    BUT THE LAST-READ DATA CARD D"
    "OES NOT BEAR ONE OF THESE KEY WORDS ON IT,',/,5x,"
    "'BEGINNING IN COLUMN NUMBER  1 .')");
  goto statement_6220;
  statement_6197:
  write(lunit6,
    "(5x,'THE EMTP IS NOW INPUTTING DATA FOR A TRANSMISSION',"
    "' CIRCUIT THAT IS BEING MODELED USING',/,5x,"
    "'FREQUENCY DEPENDENT REPRESENTATION.  BUT FOR THIS DATA, THE PRESENT TIME"
    "-STEP SIZE  ''DELTAT''  OF',e15.4,' SEC    IS',/,5x,"
    "'TOO LARGE.   THE  TRAVEL TIME OF THE CURRENT MODE IS EQUAL TO',e15.4,"
    "' SEC ,    WHICH MUST EXCEED  ''DELTAT'' .   THE',/,5x,"
    "'TIME-STEP SIZE OF THE STUDY MUST BE DECREASED TO SATISFY THIS CONSTRAINT"
    ".')"),
    cmn.deltat, flstat(14);
  goto statement_6220;
  statement_6198:
  write(lunit6,
    "(5x,'THE EMTP IS IN THE MIDDLE OF SOLVING A    ''SEMLYEN SETUP''    DATA "
    "CASE, AT WHICH POINT IT HAS BEEN DISCOVERED',/,5x,"
    "'THAT INSUFFICIENT WORKING SPACE EXISTS.    THE   ''LINE CONSTANTS''   OR"
    "   ''CABLE CONSTANTS''   CALCULATION HAS NOW',/,5x,"
    "'BEEN SUCCESSFULLY COMPLETED, AND A MINIMUM WORKING SPACE OF',i7,"
    "'    FLOATING-POINT CELLS IS NOW A KNOWN',/,5x,"
    "'REQUIREMENT FOR THE COMPLETION OF   ''SEMLYEN SETUP''   PROCESSING.   BU"
    "T MODULE  ''VDOV45''  ONLY CONTAINS',i7)"),
    lstat(16), lstat(15);
  write(lunit6,
    "(5x,'FLOATING-POINT CELLS OF SUCH WORKING SPACE.   THE EMTP MUST BE RE-DI"
    "MENSIONED BY THE USER, SO AS TO INCREASE',/,5x,"
    "'THE SIZE OF   /LABEL/   BY THE JUST-INDICATED SHORTFALL.   DISTRIBUTION "
    "OF TOTAL STORAGE AMONG THE DIFFERENT EMTP',/,5x,"
    "'LISTS IS IMMATERIAL IN THIS CASE (AS WITH THE DIMENSIONING OF ALL PRIMAR"
    "Y-LEVEL NON-SOLUTION OVERLAYS).')");
  goto statement_6220;
  statement_6199:
  write(lunit6,
    "(5x,'THE PRESENT   ''SEMLYEN SETUP''   DATA CASE HAS BROKEN DOWN IN THE M"
    "IDDLE OF A MATRIX INVERSION OPERATION FOR',/,5x,'FREQUENCY',e14.5,"
    "'    HERTZ.   THE EIGENVECTOR (MODAL TRANSFORMATION) MATRIX OF ORDER',i5,"
    "'    HAS',/,5x,'THE VALUE',e13.3,"
    "'    FOR THE LARGEST POSSIBLE PIVOT ELEMENT OF ROW NUMBER',i5,"
    "' .    BUT THIS DOES')"),
    flstat(15), lstat(14), flstat(13), lstat(13);
  write(lunit6,
    "(5x,'NOT EXCEED THE NEAR-ZERO TOLERANCE  ''EPSPV2'' ,   WHICH HAS VALUE',"
    "e13.3,' .    EXECUTION MUST',/,5x,"
    "'BE STOPPED IMMEDIATELY.   YET, THE USER IS REMINDED THAT HE CAN REDEFINE"
    "  ''EPSPV2''  BY MEANS OF AN OPTIONAL',/,5x,"
    "' ''TOLERANCES''   CARD (READ BY   ''SEMLYEN SETUP''  ) .')"),
    flstat(14);
  goto statement_6220;
  statement_6200:
  write(lunit6,
    "(5x,'MEMORY-OVERFLOW PROBLEM, BEFORE ENTRY INTO THE RENUMBERING OVERLAY ("
    "FOR TRANSIENT NETWORK RENUMBERING).',/,5x,"
    "'RECALL THAT SPACE FOR RENUMBERING COMES FROM A MAJOR PORTION OF   /LABEL"
    "/ .    THREE VECTORS ARE USED, WITH SIZE',/,5x,"
    "'GIVEN BY LIST NUMBER  99  OF THE CASE-SUMMARY STATISTICS.   THIS SPACE I"
    "S INSUFFICIENT EVEN FOR THE SIMPLE STORAGE',/,5x,"
    "'OF THE CONNECTIVITY OF  (Y) --- TO SAY NOTHING OF THE SIMULATION OF FILL"
    "IN UPON TRIANGULARIZATION.')");
  if (lstat(14) > 0) {
    write(lunit6,
      "(5x,'OF THE',i6,'   ENTRIES OF THE BRANCH TABLE, ONLY',i6,"
      "'   WERE INSERTED INTO THE WORKING STORAGE BEFORE OVERFLOW.')"),
      cmn.ibr, lstat(14);
  }
  if (lstat(14) == 0) {
    write(lunit6,
      "(5x,'ALL BRANCH-TABLE ENTRIES WERE SUCCESSFULLY INSERTED INTO THE WORKI"
      "NG STORAGE, BUT ENTRIES FROM THE NONLINEAR',/,5x,"
      "'ELEMENT TABLE AND THE SWITCH TABLE THEN PRODUCED OVERFLOW.')");
  }
  write(lunit6,
    "(5x,'AS FOR REDIMENSIONING OF THE EMTP, LISTS  5  AND  8  CONTRIBUTE  100"
    "  PER CENT TO THE SIZE OF DEPENDENT LIST',/,5x,"
    "'99.   INCREASE ONE OF THESE LIST SIZES SUBSTANTIALLY, AND TRY AGAIN.')");
  statement_6220:
  cmn.lastov = nchain;
  nchain = cmn.nfrfld + 50;
  if (iprsup >= 1) {
    write(lunit6, format_4568);
  }
  statement_99999:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
statsv()
{
}

struct subr55_save
{
  fem::str<8> text1;
  fem::str<8> text11;
  fem::str<8> text12;
  fem::str<8> text13;
  fem::str<8> text14;
  fem::str<8> text15;
  fem::str<8> text16;
  fem::str<8> text17;
  fem::str<8> text18;
  fem::str<8> text19;
  fem::str<8> text2;
  fem::str<8> text3;
  fem::str<8> text4;
  fem::str<8> text5;

  subr55_save() :
    text1(fem::char0),
    text11(fem::char0),
    text12(fem::char0),
    text13(fem::char0),
    text14(fem::char0),
    text15(fem::char0),
    text16(fem::char0),
    text17(fem::char0),
    text18(fem::char0),
    text19(fem::char0),
    text2(fem::char0),
    text3(fem::char0),
    text4(fem::char0),
    text5(fem::char0)
  {}
};

void
subr55(
  common& cmn) try
{
  FEM_CMN_SVE(subr55);
  common_read read(cmn);
  common_write write(cmn);
  fem::str<8>& bus1 = cmn.bus1;
  fem::str<8>& bus2 = cmn.bus2;
  fem::str<8>& bus3 = cmn.bus3;
  auto& texcol = cmn.texcol;
  const auto& texta6 = cmn.texta6;
  const auto& tclock= cmn.tclock;
  const auto& abuff = cmn.abuff;
  double& epsiln = cmn.epsiln;
  const auto& flstat = cmn.flstat;
  const auto& moncar = cmn.moncar;
  auto& lunit3 = cmn.lunit3;
  auto& lunit9 = cmn.lunit9;
  int& nright = cmn.nright;
  int& nfrfld = cmn.nfrfld;
  int& kolbeg = cmn.kolbeg;
  const auto& ipntv = cmn.ipntv;
  auto& lstat = cmn.lstat;
  int& kpartb = cmn.kpartb;
  int& lastov = cmn.lastov;
  int& noutpr = cmn.noutpr;
  int& jflsos = cmn.jflsos;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  int& intinf = cmn.intinf;
  int& kswtch = cmn.kswtch;
  int& ntot = cmn.ntot;
  int& nenerg = cmn.nenerg;
  //
  fem::str<8>& text1 = sve.text1;
  fem::str<8>& text11 = sve.text11;
  fem::str<8>& text12 = sve.text12;
  fem::str<8>& text13 = sve.text13;
  fem::str<8>& text14 = sve.text14;
  fem::str<8>& text15 = sve.text15;
  fem::str<8>& text16 = sve.text16;
  fem::str<8>& text17 = sve.text17;
  fem::str<8>& text18 = sve.text18;
  fem::str<8>& text19 = sve.text19;
  fem::str<8>& text2 = sve.text2;
  fem::str<8>& text3 = sve.text3;
  fem::str<8>& text4 = sve.text4;
  fem::str<8>& text5 = sve.text5;
  if (is_called_first_time) {
    text1 = "BEGIN ";
    text2 = "NEW   ";
    text3 = "DATA  ";
    text4 = "CASE  ";
    text5 = "BNDC  ";
    text11 = "END   ";
    text12 = "LAST  ";
    text13 = "ELDC  ";
    text14 = "STATIS";
    text15 = "TICS  ";
    text16 = "OUTPUT";
    text17 = "SALVAG";
    text18 = "E     ";
    text19 = "SOS   ";
  }
  //int knt = fem::int0;
  //int isw = fem::int0;
  //int mtape = fem::int0;
  auto& lunit6 = cmn.lunit6;
  auto& kunit6 = lunit6;
  int n1 = fem::int0;
  int i = fem::int0;
  int i1 = fem::int0;
  double d7 = fem::double0;
  int n15 = fem::int0;
  int j = fem::int0;
  int n9 = fem::int0;
  int kilsav = fem::int0;
  int n6 = fem::int0;
  int n13 = fem::int0;
  double d1 = fem::double0;
  double d11 = fem::double0;
  double d12 = fem::double0;
  double seed = fem::double0;
  int n2 = fem::int0;
  int n5 = fem::int0;
  int n3 = fem::int0;
  int n4 = fem::int0;
  static const char* format_4096 =
    "(5x,'-------------1----------------','------------------------------',"
    "'------------------------------','------------------------')";
  static const char* format_4568 =
    "(' EXIT MODULE  \"SUBR55\".  KILL,',' IPNTV(2) =',2i6)";
  static const char* format_5316 =
    "(' ----------------------------------------------------------------------"
    "-------------------------------------------------------------')";
  static const char* format_7213 =
    "(5x,'WHILE READING  ZNO  ARRESTER DATA',"
    "' CARDS, A STRUCTURAL (NUMBERING)',' DEFECT WAS FOUND.   THIS IS FOR',/,"
    "5x,'NONLINEAR ELEMENT NUMBER',i5,'   WHICH CORRESPONDS TO ARRESTER',"
    "' NUMBER',i5,' .')";
  static const char* format_7214 =
    "(5x,'THE EMTP IS IN THE PROCESS OF',' READING THE DATA ASSOCIATED',"
    "' WITH THE  TACS  DEVICE',/,5x,' IDENTIFIED BY THE 6-CHARACTER',"
    "' (OUTPUT) NAME ''',a6,''' .')";
  static const char* format_7306 =
    "(10x,i5,' = NTOT    (NUMBER OF ELECTRIC NETWORK NODES)',/,10x,i5,"
    "' = NSTAT   (NUMBER OF OUTPUT VARIABLES)',/,10x,i5,"
    "' = KSWTCH  (NUMBER OF SWITCHES)',/,9x,a6,"
    "' = BUS(NTOT)  (NAME OF LAST NETWORK NODE).')";

  auto& knt = moncar(1);
  auto& isw = moncar(4);
  auto& mtape = moncar(10);
  //C
  if (iprsup >= 1) {
    write(lunit6, "(' TOP OF \"SUBR55\".  KILL =',i6)"), kill;
  }
  if (isw ==  - 3344) {
    goto statement_6740;
  }
  if (kill <= 200) {
    goto statement_4092;
  }
  n1 = kill - 200;
  switch (n1) {
    case 1: goto statement_6201;
    case 2: goto statement_6202;
    case 3: goto statement_6203;
    case 4: goto statement_6204;
    case 5: goto statement_6205;
    case 6: goto statement_6206;
    case 7: goto statement_6207;
    case 8: goto statement_6208;
    case 9: goto statement_6209;
    case 10: goto statement_6210;
    case 11: goto statement_6211;
    case 12: goto statement_6212;
    case 13: goto statement_6213;
    case 14: goto statement_6214;
    case 15: goto statement_6215;
    case 16: goto statement_6216;
    case 17: goto statement_6217;
    case 18: goto statement_6218;
    case 19: goto statement_6219;
    case 20: goto statement_6220;
    case 21: goto statement_6221;
    case 22: goto statement_6222;
    case 23: goto statement_6223;
    case 24: goto statement_6224;
    case 25: goto statement_6225;
    case 26: goto statement_6226;
    case 27: goto statement_6227;
    case 28: goto statement_6228;
    case 29: goto statement_6229;
    case 30: goto statement_6230;
    case 31: goto statement_6231;
    case 32: goto statement_6232;
    case 33: goto statement_6233;
    case 34: goto statement_6234;
    case 35: goto statement_6235;
    case 36: goto statement_6236;
    case 37: goto statement_6237;
    case 38: goto statement_6238;
    case 39: goto statement_6239;
    case 40: goto statement_6240;
    case 41: goto statement_6241;
    default: break;
  }
  goto statement_6540;
  statement_6201:
  write(lunit6,
    "(5x,'THE LAST-READ DATA CARD IS A REQUEST FOR THE FURTHER (CONTINUED) SOL"
    "UTION OF A PREVIOUSLY-SOLVED EMTP DATA',/,5x,"
    "'CASE.   THE   ''RESTART''   REQUEST SPECIFIES A PERMANENT FILE IN WHICH "
    "IS STORED   /BLANK/   AND   /LABEL/ .',/,5x,"
    "'BUT EMTP DIMENSIONING OF THE PRESENT PROGRAM VERSION IS NOT IDENTICAL TO"
    " THAT FOR THE VERSION WHICH CREATED THE',/,5x,"
    "'PERMANENT FILE.   SPECIFICALLY, THE TOTAL LENGTH OF   /LABEL/   FOR THE "
    "FILE-CREATING PROGRAM WAS',i8,'   INTEGER')"),
    lstat(16);
  write(lunit6,
    "(5x,'WORDS, WHILE THE CORRESPONDING PRESENT FIGURE IS',i8,"
    "' .    ANY SUCH DISCREPANCY IS ILLEGAL.   AS A',/,5x,"
    "'GENERAL RULE, THE USER IS COUNSELED TO USE THE SAME PROGRAM VERSION FOR "
    "BOTH OPERATIONS, THEREBY GUARANTEEING SUCCESS.')"),
    cmn.ltlabl;
  goto statement_6550;
  statement_6202:
  goto statement_6550;
  statement_6203:
  write(lunit6,
    "(5x,'THE DATA CASE NOW BEING SOLVED INVOLVES ONE OR MORE TYPE-96 HYSTERET"
    "IC INDUCTORS.   FINE.   HOWEVER, NO       ',/,5x,"
    "'STEADY-STATE PHASOR SOLUTION FOR INITIAL CONDITIONS WAS REQUESTED BY THE"
    " USER.   THIS COMBINATION IS PERMITTED',/,5x,"
    "'ONLY IF THE SIMULATION BEGINS AS THE CONTINUATION OF A PREVIOUSLY-HALTED"
    " RUN (WITH FIELD  ''TSTART''  OF THE',/,5x,"
    "'FLOATING-POINT MISCELLANEOUS DATA CARD PUNCHED POSITIVE).   THE DATA CAS"
    "E UNDER CONSIDERATION DOES NOT SATISFY THESE',/,5x,"
    "'RESTRICTIONS, SO SOLUTION SHALL BE STOPPED.')");
  goto statement_6550;
  statement_6204:
  write(lunit6,
    "(5x,'THE LAST-INPUTTED EMTP COMPONENT WAS A TYPE-96 HYSTERETIC INDUCTOR. "
    "  COLUMNS  27-32  AND  33-38  OF THE',/,5x,"
    "'BRANCH CARD ARE TO BE PUNCHED WITH  ''I-STEADY''  AND   ''PSI-STEADY'' ,"
    "   RESPECTIVELY.   BUT VALUES',e14.4,'   AND',/,5x,e14.4,"
    "'   WERE READ FOR THESE TWO VARIABLES, WHICH REPRESENTS A POINT IN THE CU"
    "RRENT-FLUX PLANE THAT LIES OUTSIDE',/,5x,"
    "'THE USER-DEFINED MAJOR HYSTERESIS LOOP.   THE EMTP DOES NOT ALLOW SUCH S"
    "LOPPINESS (EVEN THOUGH THE RATIO MAY BE',/,5x,"
    "'CORRECT).   DEFINE A POINT WITHIN THE LOOP, AND TRY AGAIN.')"),
    flstat(14), flstat(15);
  goto statement_6550;
  statement_6205:
  write(lunit6,
    "(5x,'THE LAST-INPUTTED EMTP COMPONENT WAS A TYPE-96 HYSTERETIC INDUCTOR. "
    "  COLUMNS  39-44  OF THE BRANCH CARD ARE',/,5x,"
    "'TO BE PUNCHED WITH A RESIDUAL (REMNANT) FLUX VALUE.   BUT A VALUE OF',"
    "e14.4,'   WAS READ FOR THIS, WHICH',/,5x,"
    "'EXCEEDS (IN ABSOLUTE VALUE) THE FLUX OF THE USER-INPUTTED MAJOR HYSTERES"
    "IS LOOP AT ZERO CURRENT.   THIS LATTER FLUX',/,5x,'VALUE IS',e14.4,"
    "' .   THE RESULT IS A CURRENT-FLUX POINT WHICH LIES OUTSIDE THE MAJOR HYS"
    "TERESIS LOOP, WHICH',/,5x,"
    "'IS IMPOSSIBLE.   PUNCH A LEGAL RESIDUAL FLUX VALUE IN COLUMNS  39-44 ,  "
    " AND TRY AGAIN.')"),
    flstat(16), flstat(17);
  goto statement_6550;
  statement_6206:
  write(lunit6,
    "(5x,'THE USER IS TRYING TO COMBINE  ''STATISTICS''  OR  ''SYSTEMATIC''  R"
    "ESULTS USING THE   ''TABULATE ENERGIZATION RESULTS''',/,5x,"
    "'FEATURE.   BUT NOT ALL OF THE PARTIAL RESULTS ARE COMPATIBLE.   FILES PR"
    "EVIOUSLY ATTACHED AND READ HAVE THE',/,5x,"
    "'FOLLOWING CHARACTERISTIC PARAMETERS ...')");
  {
    write_loop wloop(cmn, lunit6, format_7306);
    FEM_DO_SAFE(i, 11, 13) {
      wloop, lstat(i);
    }
    wloop, bus2;
  }
  write(lunit6,
    "(5x,'ON THE OTHER HAND, THE MOST RECENTLY ATTACHED FILE, NUMBER',i5,"
    "'   IN ORDER OF USER SPECIFICATION, HAS',/,5x,"
    "'THE FOLLOWING DIFFERENT CHARACTERISTICS ...')"),
    lstat(17);
  write(lunit6, format_7306), ntot, lstat(14), kswtch, bus1;
  write(lunit6,
    "(5x,'NEVER TRY TO COMBINE RESULTS WHICH BELONG TO DIFFERENTLY-STRUCTURED "
    "PROBLEMS, AS IN THIS DATA CASE.')");
  goto statement_6550;
  statement_6207:
  write(lunit6,
    "(5x,'THIS DATA CASE HAS  ''STATISTICS''  SWITCHES, BUT IT IS HIGHLY IMPRO"
    "BABLE THAT ANY WOULD EVER CLOSE.   THE',/,5x,"
    "'TERMINATION TIME  ''TMAX''  OF THE SIMULATION EQUALS',e14.4,"
    "' ,   WHILE ALL RANDOM SWITCH-CLOSING TIMES',/,5x,'EXCEED',e14.4,"
    "'   SECONDS WITH  3*SIGMA  PROBABILITY.   SUCH A WASTE OF COMPUTER RESOUR"
    "CES WILL NOT BE TOLERATED.',/,5x,"
    "'EITHER INCREASE  ''TMAX''  BEYOND THIS LATTER FIGURE, OR APPROPRIATELY D"
    "ECREASE THE CLOSING TIMES.')"),
    cmn.tmax, cmn.tenerg;
  goto statement_6550;
  statement_6208:
  goto statement_6550;
  statement_6209:
  write(lunit6,
    "(5x,'THE JACOBIAN MATRIX FOR A NEWTON',"
    "' SOLUTION OF ZINC-OXIDE ARRESTERS',' HAS BEEN FOUND TO BE SINGULAR.',/,"
    "5x,'THE TOLERANCE  ''EPSILN''  EQUALS',e12.3,"
    "' ,   WHILE THE ITERATION COUNT IS',i5,' .')"),
    epsiln, lstat(17);
  goto statement_7412;
  statement_6210:
  write(lunit6,
    "(5x,'THE INITIALIZATION OF A SATURATED SYNCHRONOUS MACHINE HAS FAILED TO "
    "CONVERGE. THE MACHINE IN QUESTION',/,5x,'HAD THE FOLLOWING NUMBER',2x,"
    "i6)"),
    lstat(14);
  goto statement_6550;
  statement_6211:
  write(lunit6,
    "(5x,'THE PROGRAM WAS INPUTTING DATA FOR SYNCHRONOUS MACHINE NO.',i8,"
    "'A NON-POSITIVE SET OF SATURATION DATA',/,5x,"
    "'FOR ONE OF THE AXIS HAS BEEN DETECTED. THE READ IN DATA FOLLOW',"
    "' BELOW THIS LINE ........',/,10x,3e20.8,/,5x,"
    "'IN A CASE OF AN UNSATURATED S.M. THIS KILL-CODE IS CAUSED BY A NONSPECIF"
    "IED VALUE OF PARAMETER ''AGLINE''.')"),
    lstat(14), flstat(13), flstat(14), flstat(15);
  goto statement_6550;
  statement_6212:
  write(lunit6,
    "(5x,'A RIGOROUS SOLUTION FOR ONE OR MORE',"
    "' ZINC-OXIDE ARRESTERS HAS FAILED.','   UP TO',i5,"
    "'   ITERATIONS (VARIABLE ''MAXZNO'')',/,5x,"
    "'WERE ALLOWED TO DRIVE THE CURRENT',' RESIDUALS BELOW',e12.4,"
    "'   AMPERES (TOLERANCE ''EPSTOP'').',/,5x,'BUT',e13.4,"
    "'   AMPERES REMAIN FOR A PROBLEM',' EQUATION, SO THE NEWTON ITERATION',"
    "' HAS DIVERGED.')"),
    cmn.maxzno, cmn.epstop, flstat(14);
  statement_7412:
  write(lunit6,
    "(5x,'BY WAY OF COMPONENT IDENTIFICATION,',' THERE ARE',i5,"
    "'   COUPLED ELEMENTS WHICH ARE BEING',' SOLVED SIMULTANEOUSLY, WITH',/,"
    "5x,'THE FIRST OF THESE (IN ORDER OF DATA',' INPUT) CONNECTING NODE  ''',"
    "a6,'''  TO NODE  ''',a6,''' .   THE FIRST ELEMENT IS')"),
    lstat(13), bus1, bus2;
  write(lunit6,
    "(5x,'LOCATED IN ROW',i5,'   OF THE NONLINEAR ELEMENT TABLE,',"
    "'   WHILE THE LAST IS IN ROW NUMBER',i5,' .',/,5x,'A RANK OF',i5,"
    "'   EXISTS FOR  (ZTHEV) ,   AND THE',' SIMULATION TIME IS',e13.5,"
    "' SEC.')"),
    lstat(15), lstat(14), lstat(16), cmn.t;
  write(lunit6,
    "(5x,'POSSIBLE AMELIORATIVE ACTIONS INCLUDE',"
    "' A DECREASE IN TIME-STEP SIZE \"DELTAT\",',"
    "' OR AN INCREASE IN THE ITERATION',/,5x,"
    "' LIMIT \"MAXZNO\", OR AN INCREASE IN',"
    "' THE DIVERGENCE TOLERANCE \"EPSTOP\" .')");
  goto statement_6550;
  statement_6213:
  write(lunit6, format_7213), lstat(15), lstat(16);
  write(lunit6,
    "(5x,' THE READ-IN IDENTIFICATION NUMBER',i8,3x,"
    "'DOES NOT AGREE WITH THE ARRESTER',' NUMBER EQUAL TO',i8,' .')"),
    lstat(17), lstat(16);
  goto statement_6550;
  statement_6214:
  write(lunit6, format_7214), bus1;
  write(lunit6,
    "(5x,'THIS IS A TYPE-58 DEVICE DEFINED',"
    "' BY THE FOLLOWING TRANSFER FUNCTION:',/,/,10x,"
    "'GAIN / ( D0 +  D1 * S  )',/,/,5x,'THE DENOMINATOR OF THIS FUNCTION IS',"
    "' PRESENTLY FOUND TO HAVE A VALUE',' OF   0.0  ,  THUS CREATING',/,5x,"
    "'A SINGULARITY IN THE SYSTEM.   IN',' EFFECT, THIS DENOMINATOR IS INTER',"
    "'NALLY TRANSFORMED')");
  write(lunit6,
    "(5x,'BY THE TRAPEZOIDAL RULE OF IMPLICIT',"
    "' INTEGRATION INTO THE EXPRESSION:',/,/,10x,"
    "'( D0  +  D1 * 2.0 / DELTAT  )',/,/,5x,'WITH THE VALUE OF DELTAT = ',"
    "e14.6,/,5x,'CORRECT THIS SITUATION BY CHANGING',"
    "' EITHER  D0,  D1,  OR  DELTAT .')"),
    cmn.deltat;
  goto statement_6550;
  statement_6215:
  write(lunit6, format_7214), bus1;
  write(lunit6,
    "(5x,'THIS  TYPE-60  IF-DEVICE  RECOGNIZES',"
    "'  3  AND ONLY  3  SEPARATE INPUT SIGNALS.',/,/,5x,"
    "'OF THE  5  FIELDS AVAILABLE FOR DEFINING',' THE INPUTS',/,10x,"
    "'EACH ONE OF THE FIRST THREE MUST BE',' NON-BLANK  (COLUMNS 11 - 33 )',/,"
    "10x,'AND THE TWO REMAINING FIELDS MUST',"
    "' BE LEFT BLANK  ( COLUMNS 35 - 49 )')");
  goto statement_6550;
  statement_6216:
  write(lunit6, format_7214), bus1;
  write(lunit6,
    "(5x,'THIS  TYPE-61  DEVICE  SELECTS AS',"
    "' OUTPUT  ONE OF THE POSSIBLY  8  ','CONNECTED INPUTS                 ',"
    "/,5x,'DEPENDING ON THE VALUE OF ANOTHER',"
    "' TACS VARIABLE CALLED ''SELECTOR SIGNAL''.')");
  write(lunit6,
    "(5x,'HOWEVER, THE USER HAS NEGLECTED',"
    "' TO IDENTIFY THE NAME OF THE TACS',"
    "' VARIABLE THAT IS TO SERVE THIS PURPOSE.',/,5x,"
    "'THE USER SHOULD SPECIFY THIS SELECTOR',"
    "' SIGNAL IN THE  6-CHARACTER FIELD',' OF COLUMNS  75 - 80  .')");
  goto statement_6550;
  statement_6217:
  write(lunit6, format_7214), bus1;
  write(lunit6,
    "(5x,'THIS  TYPE-',i2,'  MIN/MAX  DEVICE  WILL IDENTIFY',"
    "' EITHER MAXIMA OR MINIMA, DEPENDING ON',/,5x,"
    "'THE NUMERICAL NALUE READ IN COLUMNS','  57 - 62  OF THE DATA CARD.')"),
    lstat(17);
  write(lunit6,
    "(5x,'THIS VALUE MUST BE TYPED AS EITHER',/,10x,"
    "'   +1.0  TO INDICATE THAT A MAXIMUM',' IS TO BE CALCULATED,',/,10x,"
    "'OR -1.0   -     -      -    MINIMUM','    -     -     -   .',/,/,5x,"
    "'THE PRESENT VALUE WAS READ AS ',f13.6)"),
    flstat(14);
  goto statement_6550;
  statement_6218:
  write(lunit6,
    "(5x,'THE PROGRAM WAS READING THE USER-',"
    "'DEFINED FREE-FORMAT FORTRAN EXPRESSION',/,5x,"
    "'FOR THE TACS VARIABLE IDENTIFIED BY',' THE  6-CHARACTER NAME ''',a6,"
    "''' ,',/,5x,'WHEN THE FOLLOWING ILLEGAL SITUATION',' WAS DETECTED:')"),
    bus1;
  i1 = lstat(17);
  if (i1 > 6) {
    goto statement_62180;
  }
  switch (i1) {
    case 1: goto statement_62181;
    case 2: goto statement_62182;
    case 3: goto statement_62183;
    case 4: goto statement_62184;
    case 5: goto statement_62185;
    case 6: goto statement_62186;
    default: break;
  }
  statement_62180:
  i1 = i1 - 6;
  switch (i1) {
    case 1: goto statement_62187;
    case 2: goto statement_62188;
    case 3: goto statement_62189;
    case 4: goto statement_62190;
    case 5: goto statement_62191;
    case 6: goto statement_62192;
    case 7: goto statement_62193;
    default: break;
  }
  statement_62181:
  write(lunit6, "(10x,'A PARENTHESIS WAS OPENED AND NEVER CLOSED.')");
  goto statement_6550;
  statement_62182:
  write(lunit6, "(10x,'THIS EXPRESSION CONTAINS NO ARGUMENT.')");
  goto statement_6550;
  statement_62183:
  write(lunit6,
    "(10x,'ATTEMPT TO CLOSE A PARENTHESIS THAT',"
    "' HAD NOT BEEN OPENED.              ')");
  goto statement_6550;
  statement_62184:
  write(lunit6,
    "(10x,'THE OPERATOR ''',a6,''' IS THE LAST ELEMENT OF THIS',"
    "' FORTRAN EXPRESSION.         ',/,10x,"
    "'ISN''T THERE AN ARGUMENT MISSING ...')"),
    bus2;
  goto statement_6550;
  statement_62185:
  write(lunit6,
    "(10x,'THE TWO FOLLOWING ARGUMENTS CANNOT',"
    "' BE ADJACENT:                     ',/,10x,'''',a6,'''  ''',a6,'''')"),
    bus2, bus3;
  goto statement_6550;
  statement_62186:
  write(lunit6,
    "(10x,'THE FIRST ELEMENT OF THIS EXPRESSION',' WAS READ AS ''',a6,''' .',"
    "/,10x,'CAN IT REALLY BE ...                ')"),
    bus2;
  goto statement_6550;
  statement_62187:
  write(lunit6, "(10x,'MISSING  ''(''  AFTER FUNCTION ''',a6,'''')"), bus2;
  goto statement_6550;
  statement_62188:
  write(lunit6,
    "(10x,'PLEASE BREAK THIS MONSTRUOUSLY LARGE',"
    "' EXPRESSION INTO SMALLER SECTIONS.  ')");
  goto statement_6550;
  statement_62189:
  write(lunit6,
    "(10x,'THIS EXPRESSION IS NOT HOMOGENEOUS.',/,10x,"
    "'THE TWO OPERATORS UPON WHICH THIS ',"
    "'CONDITION WAS DETECTED ARE        ',/,15x,'''',a6,''' AND ''',a6,"
    "''' .')"),
    bus2, bus3;
  goto statement_6550;
  statement_62190:
  write(lunit6,
    "(10x,'THE NUMERICAL ARGUMENT ENDING IN',' COLUMN  ',i2,/,10x,"
    "'IS MORE THAN  20  CHARACTERS LONG.')"),
    lstat(16);
  goto statement_6550;
  statement_62191:
  write(lunit6,
    "(10x,'THE ALPHANUMERIC ARGUMENT ENDING',' IN COLUMN  ',i2,/,10x,"
    "'IS MORE THAN  6 CHARACTERS LONG.')"),
    lstat(16);
  goto statement_6550;
  statement_62192:
  write(lunit6,
    "(10x,'UNRECOGNIZABLE LOGICAL OPERATOR',' NEAR COLUMN  ',i2)"),
    lstat(16);
  goto statement_6550;
  statement_62193:
  write(lunit6,
    "(10x,'THE NUMERICAL ARGUMENT ENDING IN',' COLUMN ',i2,/,10x,"
    "'CONTAINS MORE THAN ONE DECIMAL POINT.')"),
    lstat(16);
  goto statement_6550;
  statement_6219:
  write(lunit6, format_7213), lstat(16), lstat(15);
  write(lunit6,
    "(5x,'A NON-POSITIVE REFERENCE VOLTAGE',' EQUAL TO',e13.4,"
    "'   WAS SPECIFIED BY THE USER.')"),
    flstat(15);
  goto statement_6550;
  statement_6220:
  write(lunit6,
    "(5x,' OVERFLOW OF STEADY-STATE TABLE SPACE.',"
    "'   LIST 23 TABLES ARE SIZED AT',i6,"
    "'   WORDS,   WHICH IS INSUFFICIENT FOR',/,5x,"
    "'EVEN JUST THE FORMATION OF  (Y),  TO',"
    "' SAY NOTHING OF LATER TRIANGULARIZATION.',"
    "'   OVERFLOW HAS OCCURRED AFTER ONLY',i5,/,5x,"
    "'BRANCHES HAVE BEEN PROCESSED, OUT OF A',' TOTAL OF',i5,' .')"),
    cmn.last, lstat(15), cmn.ibr;
  goto statement_6550;
  statement_6221:
  write(lunit6,
    "(5x,' THE NUMBER OF PHASES IN THIS LINE',"
    "' IS LARGER THAN THE TEMPORARY LIMIT',' OF 10 FOR K. C. LEE MODELING.')");
  goto statement_6550;
  statement_6222:
  write(lunit6,
    "(5x,'THE STEADY-STATE SOLUTION IS',' FOR TWO OR MORE FREQUENCIES WHICH',"
    "' ARE NOT SEPARATED.   TROUBLE WAS',' SPOTTED AT BRANCH NUMBER',i5,/,5x,"
    "'WHICH CONNECTS BUS  \"',a6,'\"  WITH BUS  \"',a6,'\" .   ONE',"
    "' SOURCE OF CONFLICT IS IN ROW',i5)"),
    lstat(14), bus1, bus2, lstat(15);
  goto statement_6550;
  statement_6223:
  write(lunit6,
    "(5x,'THE STEADY-STATE SOLUTION IS',' FOR TWO OR MORE FREQUENCIES WHICH',"
    "' ARE NOT SEPARATED.   TROUBLE WAS',' SPOTTED AT SWITCH NUMBER',i5,/,5x,"
    "'WHICH CONNECTS BUS  \"',a6,'\"  WITH BUS  \"',a6,'\" .   THE',"
    "' LEFT IS EXCITED BY SOURCE NUMBER',i5,/,5x,"
    "'WHILE THE RIGHT IS EXCITED BY',' SOURCE NUMBER',i6,' .')"),
    lstat(14), bus1, bus2, lstat(15), lstat(16);
  goto statement_6550;
  statement_6224:
  write(lunit6,
    "(5x,'THE LAST-READ SWITCH CARD HAS BOTH',"
    "' NAMES IDENTICAL.   THE SWITCH IS',"
    "' CLOSED ON ITSELF, AND HAS NO USE.')");
  goto statement_6550;
  statement_6225:
  write(lunit6,
    "(5x,'THE USER HAS OVERFLOWED STORAGE WITHIN THE CABLE',"
    "' CONNSTANTS SUPPORTING PROGRAM.   FOR THE CURRENT PROGRAM',/,5x,"
    "'VERSION, ONE IS LIMITED TO CASES HAVING NOT OVER',i4,' CONDUCTORS OR ',"
    "i4,' CABLES( THE STORAGE FOR A THREE',/,5x,"
    "'PHASE TRANSMISSION LINE IS EQUAL TO 5 CABLES IF IT HAS 2 ,',"
    "' GROUND WIRES.  STORAGE FOR THE ARRAYS IN QUESTION HAS',/,5x,"
    "'BEEN OPTIMALLY (AND DYNAMICALLY) ALLOCATED SO AS TO USE AS MUCH OF THE E"
    "MTP CORE STORAGE AS IS AVAILABLE.   IT THUS',/,5x,"
    "'IS NOT THE FAULT OF THE CABLE-CONSTANTS SUPPORTING PROGRAM',"
    "' ITSELF, BUT RATHER OF THE OVERALL EMTP DIMENSIONING, THAT',/,5x,"
    "'THIS DATA CASE MUST BE REJECTED.   GO PROCURE OR MAKE ANOTHER PROGRAM VE"
    "RSION WHICH HAS MORE TOTAL TABULAR')"),
    lstat(14), lstat(15);
  write(lunit6,
    "(5x,'STORAGE SPACE, AND TRY THE JOB OVER AGAIN.   REME',"
    "'MBER, THE CABLE CONSTANTS CALCULATION REQUIRES THE STORAGE',/,5x,"
    "'OF FULL MATRICES, SO MEMORY REQUIREMENTS GO UP APPROXIMATELY AS THE SQUA"
    "RE OF THE NUMBER OF CONDUCTORS.')");
  goto statement_6550;
  statement_6226:
  statement_6227:
  statement_6228:
  statement_6229:
  statement_6230:
  statement_6231:
  statement_6232:
  statement_6233:
  statement_6234:
  statement_6235:
  statement_6236:
  statement_6237:
  statement_6238:
  statement_6239:
  statement_6240:
  statement_6241:
  statement_6540:
  write(lunit6,
    "(/,'INVALID  KILL  CODE',i5,5x,'LASTOV =',i4,/,1x)"), kill,
    lastov;
  statement_6550:
  if (ipntv(1) !=  - 8888) {
    goto statement_1429;
  }
  kill = ipntv(3) + 1;
  if (kill <= ipntv(2)) {
    goto statement_1417;
  }
  kill = 0;
  lastov = nchain;
  nchain = 1;
  if (iprsup >= 1) {
    write(lunit6, format_4568), kill, ipntv(2);
  }
  goto statement_9000;
  statement_1417:
  write(lunit6, "(/,' MESSAGE OF KILL-CODE NUMBER',i4,'.')"), kill;
  lastov = nchain;
  nchain = 51;
  if (iprsup >= 1) {
    write(lunit6, format_4568), kill;
  }
  goto statement_9000;
  statement_1429:
  if (jflsos == 0) {
    goto statement_1430;
  }
  if (nenerg == 0) {
    goto statement_1430;
  }
  //C     WRITE BOUNDING RECORDS IN THE CASE OF STATISTICS SALVAGE (SOS).   M23.6421
  d7 = -9999.f;
  n15 = kswtch + 1;
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(j, 1, n15) {
      wloop, d7;
    }
  }
  n15 = lstat(32);
  {
    write_loop wloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(j, 1, n15) {
      wloop, d7;
    }
  }
  statsv();
  statement_1430:
  if (cmn.m4plot != 1) {
    goto statement_6645;
  }
  spying(cmn);
  statement_6645:
  if (kill > 1) {
    goto statement_4092;
  }
  write(lunit6,
    "(/,' FOR   KILL = 1   ERROR STOPS, PROGRAM MAINTENANCE MAY SOMETIMES WISH"
    " TO INSPECT THE CONTENTS OF ERROR-',/,"
    "' INTERFACE VECTORS  ''LSTAT''  AND  ''FLSTAT'' .   THESE FOLLOW ....',/,"
    "/,' VECTOR  ''LSTAT''',/(1x,10i13))"),
    lstat;
  write(lunit6, "(/,' VECTOR  ''FLSTAT''',/(1x,10e13.4))"), flstat;
  n1 = lstat(16);
  write(lunit6,
    "(/,' OF COURSE MAYBE THE USER WOULD LIKE SOME SUGGESTIONS AS TO WHY THE T"
    "ABLE IN QUESTION (LIST NUMBER ',i2,')',/,"
    "' HAS OVERFLOWED.   IF SO, READ ON, GOOD BUDDY.   THE EMTP HAS A LONG-EST"
    "ABLISHED POLICY OF MERITORIOUS AND LAUDABLE',/,"
    "' COOPERATION IN THE FORM OF CRYSTAL-CLEAR DIAGNOSTIC MESSAGES, SUCH AS T"
    "HE FOLLOWING .....')"),
    n1;
  if (n1 == 99) {
    goto statement_4499;
  }
  switch (n1) {
    case 1: goto statement_4001;
    case 2: goto statement_4002;
    case 3: goto statement_4003;
    case 4: goto statement_4004;
    case 5: goto statement_4005;
    case 6: goto statement_4006;
    case 7: goto statement_4007;
    case 8: goto statement_4008;
    case 9: goto statement_4009;
    case 10: goto statement_4010;
    case 11: goto statement_4011;
    case 12: goto statement_4012;
    case 13: goto statement_4013;
    case 14: goto statement_4014;
    case 15: goto statement_4015;
    case 16: goto statement_4016;
    case 17: goto statement_4017;
    case 18: goto statement_4018;
    case 19: goto statement_4019;
    case 20: goto statement_4020;
    case 21: goto statement_4021;
    case 22: goto statement_4022;
    case 23: goto statement_4023;
    case 24: goto statement_4024;
    case 25: goto statement_4025;
    case 26: goto statement_4026;
    case 27: goto statement_4027;
    case 28: goto statement_4028;
    case 29: goto statement_4029;
    default: break;
  }
  statement_4001:
  write(lunit6,
    "(5x,'NETWORK NODES ARE OF COURSE DEFINED BY THE USER''S BRANCH AND SWITCH"
    " CARDS, BY THE NAMES WHICH IDENTIFY THE',/,5x,"
    "'TWO ENDS OF THE ELEMENT (FIELDS  ''BUS1''  AND  ''BUS2''  OF THE DATA CA"
    "RD, COLUMNS 3-14).   IN ADDITION, THERE ARE',/,5x,"
    "'SEVERAL LESS-OBVIOUS WAYS IN WHICH NODES ARE ADDED TO THE BUS TABLE ...."
    "',/,8x,"
    "'1.  SWITCHED-R ELEMENTS (TYPE-92) AND SWITCHED-L ELEMENTS (TYPE 93) EACH"
    " CREATE ONE INTERNAL NODE FOR EVERY',/,12x,'SUCH ELEMENT.')");
  write(lunit6,
    "(8x,'2.  GROUND (BLANK NODE NAME) ALWAYS HAS AN ENTRY IN THE BUS LIST.',"
    "/,8x,"
    "'3.  EACH SINGLE-PHASE SATURABLE TRANSFORMER COMPONENT ADDS ONE NODE (NOD"
    "E NAME  ''BUSTOP'' ,  COLUMNS 39-44 OF THE',/,12x,"
    "'CARD BEARING THE REQUEST WORD ''TRANSFORMER '' IN COLUMNS 3-14).',/,8x,"
    "'4.  EACH THREE-PHASE SATURABLE TRANSFORMER COMPONENT ADDS ONE NODE (NODE"
    " NAME ''BUS3PH'', READ FROM COLUMNS 27-32',/,12x,"
    "'OF THE CARD BEARING THE REQUEST WORD ''TRANSFORMER THREE PHASE '' IN COL"
    "UMNS 3-26).   THIS IS A 4-TH WORD, IN')");
  write(lunit6,
    "(12x,"
    "'ADDITION TO THE 3 WHICH ARE ADDED UNDER POINT 3, FOR A 3-PHASE TRANSFORM"
    "ER.')");
  goto statement_4099;
  statement_4002:
  write(lunit6,
    "(5x,'NETWORK BRANCHES ARE OF COURSE DEFINED DIRECTLY BY THE USER AS HE IN"
    "PUTS BRANCH DATA.   YET THE COUNTING OF',/,5x,"
    "'ENTRIES IN THIS LINEAR BRANCH TABLE HAS SOME SUBTLE POINTS WHICH ARE WOR"
    "THY OF THE FOLLOWING DETAILED COMMENT ....',/,8x,"
    "'1.  TRUE NONLINEAR ELEMENTS (TYPE CODES 92 OR 93) OR THE CONTINUOUS TIME"
    "-VARYING RESISTANCE ELEMENT (TYPE 91)',/,12x,"
    "'NEVER CONTRIBUTE TO THE LINEAR BRANCH TABLE.   THESE ELEMENTS ARE PULLED"
    " OUTSIDE OF THE NETWORK, AND ARE HANDLED',/,12x,'BY COMPENSATION.')");
  write(lunit6,
    "(8x,'2.  SWITCHED-RESISTANCE ELEMENTS (TYPE-92) EACH CONTRIBUTE ONE ENTRY"
    " TO THE LINEAR BRANCH TABLE.   SWITCHED-',/,12x,"
    "'INDUCTANCE ELEMENTS (TYPE 93) CONTRIBUTE TWO ENTRIES APIECE.',/,8x,"
    "'3.  EACH TYPE-99 PSEUDO-NONLINEAR RESISTANCE ELEMENT CONTRIBUTES AN ENTR"
    "Y, UNLESS IT IS PARALLELED BY ANOTHER',/,12x,"
    "'LINEAR BRANCH.   THESE ADDED VERY-HIGH-IMPEDANCE BRANCHES SHOW UP WITH A"
    " CARD IMAGE AND DATA INTERPRETATION',/,12x,"
    "'ALMOST AS THOUGH THE USER HAD INPUTTED THE RESISTOR HIMSELF.')");
  write(lunit6,
    "(8x,'4.  EACH N-WINDING SINGLE-PHASE SATURABLE TRANSFORMER COMPONENT ALWA"
    "YS INTERNALLY SETS UP   2(N-1) + 1   BRANCHES',/,12x,"
    "'FOR EVERYTHING BUT THE MAGNETIZING BRANCH.   FOR THE LATTER, A NONZERO M"
    "AGNETIZING RESISTANCE (FIELD  ''RMAG'' ,',/,12x,"
    "'COLUMNS 45-50 OF THE TRANSFORMER REQUEST CARD) WILL ADD AN ENTRY, AS WIL"
    "L A SATURATION CHARACTERISTIC DEFINED',/,12x,"
    "'BY EXACTLY ONE POINT.   A 3-PHASE SATURABLE-TRANSFORMER COMPONENT CONTRI"
    "BUTES ONLY IN THAT IT CONSISTS OF 3',/,12x,"
    "'SINGLE-PHASE UNITS AS JUST DETAILED.')");
  goto statement_4099;
  statement_4003:
  write(lunit6,
    "(5x,'THE R, L, C TABLES STORE FLOATING-POINT RESISTANCE, INDUCTANCE, AND "
    "CAPACITANCE PARAMETER VALUES ASSOCIATED',/,5x,"
    "'WITH LUMPED-PARAMETER ELEMENTS.   ALTHOUGH SUCH VALUES ARE INPUTTED ON B"
    "RANCH CARDS (MOSTLY), THE USER SHOULD NOT',/,5x,"
    "'CONFUSE THE PRESENT PARAMETER STORAGE WITH THE BRANCH-TABLE STORAGE OF L"
    "IST 2.   CONTRIBUTIONS TO THE PRESENT',/,5x,"
    "'LIST-3 TABLE BY DIFFERENT EMTP COMPONENTS ARE AS FOLLOWS, ASSUMING NO US"
    "AGE OF THE REFERENCE-BRANCH OR REFERENCE-',/,5x,'COMPONENT IDEA .....')");
  write(lunit6,
    "(8x,'1.  EACH UNCOUPLED SERIES R-L-C BRANCH CONTRIBUTES ONE ENTRY.',/,8x,"
    "'2.  EACH N-PHASE PI-CIRCUIT COMPONENT, OR EACH N-PHASE MUTUALLY-COUPLED "
    "R-L COMPONENT, CONTRIBUTES   N(N+1)/2',/,12x,'ENTRIES.',/,8x,"
    "'3.  EACH SINGLE-PHASE N-WINDING SATURABLE-TRANSFORMER COMPONENT CONTRIBU"
    "TES   3N-2   ENTRIES, AT LEAST.   IF',/,12x,"
    "'MAGNETIZING RESISTANCE  ''RMAG''  IS USED, ADD ANOTHER ENTRY.   IF THE T"
    "RANSFORMER IS ACTUALLY LINEAR, WITH FINITE-',/,12x,"
    "'SLOPE MAGNETIZATION CHARACTERISTIC, ADD ANOTHER ENTRY.')");
  write(lunit6,
    "(8x,'4.  A 3-PHASE SATURABLE TRANSFORMER HAS THE AFOREMENTIONED ENTRIES I"
    "N THE TABLE FOR THE THREE SINGLE-PHASE',/,12x,"
    "'TRANSFORMERS WHICH ARE SUB-COMPONENTS OF IT.   IN ADDITION, THERE ARE AL"
    "WAYS   3   EXTRA ENTRIES.',/,8x,"
    "'5.  IF A NETWORK USES ONE OR MORE TYPE-99 PSEUDO-NONLINEAR RESISTANCE EL"
    "EMENTS WHICH IS NOT PARALLELED BY ANOTHER',/,12x,"
    "'LUMPED-PARAMETER BRANCH, ONE ENTRY IS ADDED TO THE TABLE (FOR ALL SUCH E"
    "LEMENTS, NOT FOR EACH ONE).',/,8x,"
    "'6.  EACH SWITCHED-RESISTANCE ELEMENT (TYPE-92 SWITCH CARD) CONTRIBUTES O"
    "NE ENTRY.')");
  write(lunit6,
    "(8x,'7.  EACH SWITCHED-INDUCTANCE ELEMENT (TYPE-93 SWITCH CARD) CONTRIBUT"
    "ES TWO ENTRIES.',/,8x,"
    "'8.  EACH  TYPE-16  SOURCE ELEMENT (SIMPLIFIED  AC/DC  CONVERTER REPRESEN"
    "TATION) CONTRIBUTES TWO ENTRIES.',/,8x,"
    "'9.  EACH DISTRIBUTED-PARAMETER TRANSMISSION CIRCUIT CONTRIBUTES     N * "
    "(N+1) / 2    ENTRIES, WHERE  ''N''  IS')");
  write(lunit6,
    "(12x,"
    "'THE NUMBER OF PHASES OF THE LINE.   IN CASE OF SUCH OVERFLOW, THE  ''PRE"
    "SENT FIGURE''   WILL NOT INCLUDE THESE.',/,5x,"
    "'WHERE REFERENCE-BRANCH OR REFERENCE-COMPONENT IDEAS ARE USED, THERE GENE"
    "RALLY IS NO CONTRIBUTION AT ALL TO THE',/,5x,"
    "'R, L, C TABLES.   IN THIS CASE, THE PROGRAM SIMPLY MAKES REFERENCE TO PR"
    "EVIOUSLY-STORED (AND HENCE PREVIOUSLY-',/,5x,'COUNTED) DATA VALUES.')");
  goto statement_4099;
  statement_4004:
  write(lunit6,
    "(5x,'COUNTING THE NUMBER OF ENTRIES IN THE SOURCE TABLE (SIZE OF LIST 4) "
    "IS QUITE SIMPLE, AS PER THE FOLLOWING',/,5x,'RULES ....',/,8x,"
    "'1.  EACH CONVENTIONAL SOURCE COMPONENT (TYPE CODE 1 THROUGH 14, PUNCHED "
    "IN COLUMNS 1-2 OF THE SOURCE CARD)',/,12x,'CONTRIBUTES ONE ENTRY.',/,8x,"
    "'2.  EACH TYPE-15 SOURCE COMPONENT (THE SIMPLIFIED AC/DC CONVERTER MODEL,"
    " NEGLECTING RIPPLE ON THE DC SIDE)',/,12x,'CONTRIBUTES TWO ENTRIES.')");
  write(lunit6,
    "(8x,'3.  EACH 3-PHASE DYNAMIC SYNCHRONOUS-MACHINE COMPONENT (TYPE CODES 2"
    "1, 22, 23 PUNCHED IN COLUMNS 1-2 OF',/,12x,"
    "'CONSECUTIVE SOURCE CARDS) CONTRIBUTES THREE ENTRIES.',/,8x,"
    "'4.  EACH SWITCHED-RESISTANCE ELEMENT (TYPE CODE 92 PUNCHED IN COLUMNS 1-"
    "2 OF THE SWITCH CARD) CONTRIBUTES 2 ENTRIES.')");
  goto statement_4099;
  statement_4005:
  write(lunit6,
    "(5x,'LIST 5 OSTENSIBLY GIVES THE SIZE OF THE TABLE-OF-FACTORS STORAGE (L-"
    "U DECOMPOSITION) FOR THE TRIANGULARIZED',/,5x,"
    "'REAL EQUIVALENT NODAL ADMITTANCE MATRIX  (Y)  OF THE TIME-STEP LOOP.   A"
    "T EACH TIME-STEP, THE REAL MATRIX EQUATIONS',/,5x,"
    "' (Y)V = I   ARE SOLVED FOR REAL NODE-VOLTAGE VECTOR  V ,   BY MEANS OF A"
    " REPEAT SOLUTION USING THE TABLE OF FACTORS.',/,5x,"
    "'BECAUSE  (Y)  IS SYMMETRIC, ONLY THE UPPER-TRIANGULAR FACTORS (INCLUDING"
    " THE DIAGONAL) ARE STORED.   THERE IS ONLY',/,5x,"
    "'ONE INTEGER WORD AND ONE FLOATING-POINT WORD FOR EACH FACTOR, IT WILL BE"
    " NOTED (SEE BELOW).   NODE ORDERING')");
  if (lstat(13) == 1) {
    write(lunit6,
      "(5x,'BEGINNING WITH \"M32.\" VERSIONS,  LIST 7',"
      "' STORAGE OF (YBB/YBC) IS BEING',"
      "' DESTROYED,  AND THE FULL (Y) IS ADDED',/,5x,"
      "'TO THE BOTTOM OF LIST 5 (FILLS FROM THE',"
      "' BOTTOM UP).   BUT SPACE RAN OUT BEFORE',"
      "' THE STORAGE OF (Y) IS FINISHED.   ONLY',/,i8,"
      "'   ROWS ARE DONE,  OUT OF A TOTAL OF',i4,"
      "' ,   AND FACTORING HAS NOT YET EVEN BEGUN.')"),
      lstat(14), kpartb;
  }
  if (lstat(13) == 2) {
    write(lunit6,
      "(5x,'BEGINNING WITH \"M32.\" VERSIONS,  LIST 7',"
      "' STORAGE OF (YBB/YBC) IS BEING',"
      "' DESTROYED,  AND THE FULL (Y) IS ADDED',/,5x,"
      "'TO THE BOTTOM OF LIST 5 (FILLS FROM THE',"
      "' BOTTOM UP).   THE DOWNWARD-GROWING',"
      "' FACTORS SPILLED OVER ONTO (Y) AT ROW',/,i8,"
      "'   OF THE TRIANGULARIZATION,  WHEREAS WE',' MUST REACH ROW KPARTB =',"
      "i4,'   TO END SUCCESSFULLY.')"),
      lstat(15), kpartb;
  }
  write(lunit6,
    "(5x,'THE ORDER OF ELIMINATION (NODE RENUMBERING)',"
    "' IS CONSTRAINED ONLY IN THAT NODES OF',"
    "' KNOWN VOLTAGE ARE FORCED LAST.')");
  goto statement_4099;
  statement_4006:
  write(lunit6,
    "(5x,'SWITCHES ARE COMPLETELY STRAIGHTFORWARD, BEING DEFINED ONLY BY SWITC"
    "H CARDS.   ONE ENTRY IN THE SWITCH TABLE',/,5x,"
    "'IS CREATED FOR EVERY SWITCH CARD, WHETHER IT IS FOR AN ORDINARY SWITCH ("
    " ''ITYPE''  OF COLUMNS 1-2 EQUAL TO ZERO),',/,5x,"
    "'A SWITCHED RESISTANCE ELEMENT ( ''ITYPE'' = 92), OR A SWITCHED-INDUCTANC"
    "E ELEMENT ( ''ITYPE'' = 93).')");
  goto statement_4099;
  //C       ???????????   LIST 7 IS PRESENTLY UNUSED   ????????????????     M32,2362
  statement_4007:
  write(lunit6, "(' UNUSED ')");
  goto statement_4099;
  statement_4008:
  write(lunit6,
    "(5x,'PAST-HISTORY POINTS FOR DISTRIBUTED-PARAMETER REPRESENTATION OF TRAN"
    "SMISSION LINES ARE STORED IN MODAL FORM,',/,5x,"
    "'ALWAYS.   EACH MODE REQUIRES STORAGE, WHERE THERE ARE AS MANY MODES AS T"
    "HERE ARE COUPLED CONDUCTORS (E.G., A DOUBLE',/,5x,"
    "'CIRCUIT LINE HAS 6 MODES.).   A CONSTANT-PARAMETER (FREQUENCY-INDEPENDEN"
    "T) MODE CONTRIBUTES    TAU/DELTAT    ENTRIES,',/,5x,"
    "'WHERE  ''TAU''  IS THE MODAL TRAVEL-TIME OF THE LINE,  ''DELTAT''  IS TH"
    "E TIME-STEP SIZE, AND THE DIVISION INVOLVES')");
  write(lunit6,
    "(5x,'INTEGER TRUNCATION FOLLOWED BY THE ADDITION OF UNITY.   FOR A FREQUE"
    "NCY-DEPENDENT MODE, MORE PAST-HISTORY',/,5x,"
    "'THAN THIS IS NEEDED, ENOUGH TO PERFORM THE  A2(T)  CONVOLUTION.   IN THE"
    " PRECEDING FORMULA, TAKE  ''TAU''  TO BE THE',/,5x,"
    "'TIME  ''T2''  AT WHICH THE EXPONENTIAL TAIL ON  A2(T)  BEGINS (TYPICALLY"
    " 3 TRAVEL-TIMES OR SO).')");
  goto statement_4099;
  statement_4009:
  write(lunit6,
    "(5x,'ENTRIES IN THE NONLINEAR-ELEMENT TABLE ARE CREATED BY THE FOLLOWING "
    "ELEMENT TYPES ....',/,8x,"
    "'1.  PIECEWISE-LINEAR TIME-VARYING RESISTANCE ELEMENTS  R(T) ,   BRANCH-T"
    "YPE 91.',/,8x,'2.  TRUE NONLINEAR  V-I  CHARACTERISTIC, BRANCH-TYPE 92.',"
    "/,8x,'3.  TRUE NONLINEAR INDUCTANCE ELEMENT, BRANCH-TYPE 93.',/,8x,"
    "'4.  STAIRCASE TIME-VARYING RESISTANCE ELEMENT  R(T) ,   BRANCH-TYPE 97.'"
    ")");
  write(lunit6,
    "(8x,'5.  PSEUDO-NONLINEAR INDUCTANCE ELEMENT, BRANCH-TYPE 98.',/,8x,"
    "'6.  PSEUDO-NONLINEAR  V-I  CHARACTERISTIC, BRANCH-TYPE 99.',/,5x,"
    "'EVERY ELEMENT FALLING INTO THIS CLASSIFICATION CONTRIBUTES ONE ENTRY TO "
    "LIST 9.')");
  goto statement_4099;
  statement_4010:
  write(lunit6,
    "(5x,'THIS LIST-10 STORAGE APPLIES TO ALL CHARACTERISTICS WHICH ARE DEFINE"
    "D AS PAIRS OF COORDINATES, TERMINATED BY',/,5x,"
    "'A  9999-CARD.   EACH PAIR OF COORDINATES SO SEEN ON THE INPUT-DATA LISTI"
    "NG CONTRIBUTES ONE ENTRY TO LIST 10.',/,5x,"
    "'BUT NOTE CAREFULLY THE WORDING OF THIS RULE.   IT IS ONLY THE ONES WHICH"
    " ARE ACTUALLY SEEN VISUALLY ON THE DATA',/,5x,"
    "'LISTING (USE OF THE REFERENCE-BRANCH PROCEDURE ADDS NOTHING TO LIST 10, "
    "AND WILL NOT BE SEEN ON THE DATA LISTING.')");
  write(lunit6,
    "(/,5x,"
    "'A SECOND CONTRIBUTOR TO THE LIST-10 STORAGE REQUIREMENT IS THE TYPE-94 N"
    "ONLINEAR ELEMENT COMPONENT (SURGE',/,5x,"
    "'ARRESTER WITH CURRENT LIMITING GAP).   EACH SUCH SURGE ARRESTER WHICH DO"
    "ES NOT USE THE REFERENCE-BRANCH OPTION',/,5x,"
    "'ADDS  18  ENTRIES TO THE LIST-10 STORAGE REQUIREMENT.   FOR EACH SURGE A"
    "RRESTER WHICH DOES USE THE REFERENCE-BRANCH',/,5x,"
    "'PROCEDURE, THERE IS A CONTRIBUTION OF  11  ENTRIES TO THE LIST-10 STORAG"
    "E REQUIREMENT.')");
  write(lunit6,
    "(/,5x,"
    "'FINALLY, IF YOU HAVE ZNO SURGE ARRESTERS IN THE CASE, FOUR ADDTIONAL CEL"
    "LS ARE REQUIRED FOR EACH OF THE ZNO ARRESTERS.')");
  goto statement_4099;
  statement_4011:
  write(lunit6,
    "(5x,'BRANCH-OUTPUT QUANTITIES ARE GENERATED BY COLUMN-80 PUNCHES ON BRANC"
    "H CARDS AND ON SWITCH CARDS.   EACH PUNCH',/,5x,"
    "'OF  ''1''  OR  ''2''  (BRANCH CURRENT OR BRANCH VOLTAGE) CONTRIBUTES ONE"
    " ENTRY TO LIST 11.   PUNCHES OF  ''3''  (FOR',/,5x,"
    "'BRANCH CURRENT AND VOLTAGE) OR  ''4''  (FOR BRANCH POWER AND ENERGY) CON"
    "TRIBUTE TWO ENTRIES EACH, TO LIST 11.',/,5x,"
    "'NODE-VOLTAGE OUTPUTS WHICH ARE SPECIFIED INDIVIDUALLY, ONE AT A TIME, --"
    "--- I.E., BY PUNCHING 6-CHARACTER NODE')");
  write(lunit6,
    "(5x,'NAMES IN THE  13A6  FIELD OF THE NODE-VOLTAGE OUTPUT-SPECIFICATION C"
    "ARD ----- ARE LIKEWISE LIMITED BY LIST 11.',/,5x,"
    "'IF THE USER HAS REQUESTED THE AUTOMATIC OUTPUT OF EVERY NODE VOLTAGE INS"
    "TEAD OF THIS SELECTIVE OUTPUT (BY MEANS',/,5x,"
    "'OF A  ''1''  PUNCHED IN COLUMN 2 OF THE AFOREMENTIONED CARD), THIS LIST-"
    "11 LIMIT DOES NOT APPLY TO NODE VOLTAGE',/,5x,'OUTPUTS.')");
  goto statement_4099;
  statement_4012:
  write(lunit6, "(5x,'SORRY, NO SPECIAL ADVICE AVAILABLE.')");
  goto statement_4099;
  statement_4013:
  write(lunit6,
    "(5x,'EVERY CONTINUOUSLY-TRANSPOSED DISTRIBUTED-PARAMETER TRANSMISSION-LIN"
    "E COMPONENT (BRANCH TYPE-CODE  ''ITYPE''  OF',/,5x,"
    "'COLUMNS 1-2 EQUAL TO  -1,  -2,  ETC.) REPRESENTS A POSSIBLE CONTRIBUTION"
    " TO LIST 13.   EACH LINE MODE WHICH IS',/,5x,"
    "'MODELLED AS BEING FREQUENCY-DEPENDENT (VARIABLE  ''IPUNCH''  OF COLUMNS "
    "53-54 EQUAL TO  -1 )  CONTRIBUTES ONE ENTRY',/,5x,"
    "'TO LIST 13.   GENERALLY THIS WILL ONLY BE FOR THE ZERO-SEQUENCE MODE (TH"
    "E FIRST CARD OF THE GROUP), IF AT ALL.')");
  goto statement_4099;
  statement_4014:
  write(lunit6,
    "(5x,'FREQUENCY-DEPENDENT REPRESENTATION FOR A MODE OF A DISTRIBUTED-PARAM"
    "ETER TRANSMISSION LINE IS REQUESTED BY A',/,5x,"
    "'VALUE OF  -1  PUNCHED IN FIELD  ''IPUNCH''  (COLUMNS 53-54) OF THE ASSOC"
    "IATED BRANCH CARD.   ASSUMING THAT THE',/,5x,"
    "'REFERENCE-BRANCH PROCEDURE IS NOT USED, THE INPUT OF WEIGHTING FUNCTIONS"
    "  A1(T)  AND  A2(T)  FOLLOWS.   THE NUMBER',/,5x,"
    "'OF POINTS ON THESE INPUT CARDS IS IRRELEVANT, AND IS IN NO WAY RELATED T"
    "O THE SIZE OF LIST 14.   INSTEAD, THE')");
  write(lunit6,
    "(5x,'LIST-14 STORAGE DEPENDS UPON BOTH THE TIME-SPAN OF THE WEIGHTING FUN"
    "CTIONS, AND ALSO UPON THE TIME-STEP SIZE',/,5x,"
    "'''DELTAT'' ,  AS FOLLOWS.   LET  ''T1''  BE THE TIME SPAN FROM THE NONZE"
    "RO BEGINNING OF  A1(T)  (AT ABOUT ONE TRAVEL',/,5x,"
    "'TIME) TO WHERE ITS EXPONENTIAL TAIL BEGINS (TYPICALLY ABOUT TWO TRAVEL T"
    "IMES).   ALSO, DEFINE  ''T2''  TO BE THE',/,5x,"
    "'TIME AT WHICH THE EXPONENTIAL TAIL OF  A2(T)  BEGINS (TYPICALLY ABOUT TH"
    "REE TRAVEL TIMES).   THEN THE STORAGE')");
  write(lunit6,
    "(5x,'REQUIREMENT IN LIST 14 IS GIVEN BY THE RELATION     NP = (T1 + T2) /"
    " DELTAT  .     LINES WHICH USE THE',/,5x,"
    "'REFERENCE-BRANCH PROCEDURE REQUIRE NO LIST-14 STORAGE, NOTE.')");
  goto statement_4099;
  statement_4015:
  write(lunit6,
    "(5x,'TO PERFORM THE CONVOLUTION ASSOCIATED WITH FREQUENCY-DEPENDENT MODES"
    " OF DISTRIBUTED-PARAMETER TRANSMISSION',/,5x,"
    "'LINES, MODAL PAST-HISTORY MUST BE STORED FOR BOTH ENDS OF THE LINE.   WH"
    "ETHER THE REFERENCE-BRANCH PROCEDURE WAS',/,5x,"
    "'USED OR NOT IN NO WAY MODIFIES THIS REQUIREMENT.   FOR EVERY FREQUENCY-D"
    "EPENDENT MODE, TWO CELLS ARE TAKEN UP',/,5x,'IN LIST 15.')");
  goto statement_4099;
  statement_4016:
  goto statement_4012;
  statement_4017:
  goto statement_4012;
  statement_4018:
  goto statement_4012;
  statement_4019:
  write(lunit6,
    "(5x,'DO NOT DISPAIR, ALL IS NOT LOST (YET).   WHAT HAS HAPPENED IS THAT L"
    "IST  19  IS INADEQUATE FOR THE TACS TABLE',/,5x,"
    "'SIZES WHICH WERE REQUESTED.   EITHER THE USER SPECIFIED THESE SIZES EXPL"
    "ICITELY HIMSELF USING AN  ''ABSOLUTE TACS',/,5x,"
    "'DIMENSIONS''  CARD, OR THE EMTP SUPPLIED ITS OWN DEFAULT SET.   IN EITHE"
    "R CASE, THESE ABSOLUTE TACS TABLE SIZES WILL',/,5x,"
    "'REQUIRE A LIST-19 SIZE AS SHOWN UNDER THE  ''PRESENT FIGURE'' COLUMN IN "
    "ROW  19 .   BEFORE SIMPLY REDIMENSIONING THE')");
  write(lunit6,
    "(5x,'EMTP TO PROVIDE SUCH A LIST-19 FIGURE, HOWEVER, THE USER MIGHT TRY T"
    "O MORE OPTIMALLY DIVIDE THE EXISTING TOTAL',/,5x,"
    "'AMONG THE DIFFERENT TACS TABLES, USING EITHER AN  ''ABSOLUTE TACS DIMENS"
    "IONS''  CARD OR A  ''RELATIVE TACS DIMENSIONS''',/,5x,"
    "'CARD.   FINALLY, BECAUSE   KILL = 122   PROVIDES MUCH GENERAL INFORMATIO"
    "N ABOUT TACS DIMENSIONING, WE SHALL NOW',/,5x,'PRINT IT AS WELL....')");
  kill = 122;
  lstat(17) = 0;
  lstat(16) = 0;
  lastov = nchain;
  nchain = 51;
  if (iprsup >= 1) {
    write(lunit6, format_4568), kill;
  }
  goto statement_9000;
  statement_4020:
  goto statement_4012;
  statement_4021:
  goto statement_4012;
  statement_4022:
  goto statement_4012;
  statement_4023:
  goto statement_4012;
  statement_4024:
  n9 = cmn.lcomp * cmn.lbus / ntot;
  write(lunit6,
    "(5x,'THE PRESENT DATA CASE INVOLVES',i4,"
    "'   PHASE COMPENSATION, WHICH EXCEEDS',' THE EFFECTIVE PROGRAM LIMIT OF',"
    "i4,' .',/,5x,'THIS LATTER FIGURE IS THE LIMITING',"
    "' VALUE OF LIST 24 MULTIPLIED BY','  LBUS/NTOT  (THE RATIO OF THE',/,5x,"
    "'MAXIMUM NUMBER OF BUSES TO THE',' ACTUAL NUMBER FOR THIS PROBLEM).')"),
    cmn.ncomp, n9;
  write(lunit6,
    "(5x,'NOTE THAT THE EFFECTIVE LIMIT ON THE',"
    "' NUMBER OF PHASES OF COMPENSATION',"
    "' THUS VARIES INVERSELY WITH PROBLEM',/,5x,"
    "'SIZE.  CUT THE SIZE IN HALF, AND TWICE',"
    "' AS MANY PHASES ARE AVAILABLE, WITHOUT',"
    "' REDIMENSIONING WITH A LARGER LIST 24.')");
  goto statement_4099;
  statement_4025:
  goto statement_4012;
  statement_4026:
  if (lstat(13) == 0) {
    goto statement_4226;
  }
  write(lunit6,
    "(5x,'THE USER''S DATA INCLUDES A COUPLED',' BRANCH GROUP OF',i5,"
    "'   PHASES.   SQUARING THIS NUMBER',' EXCEEDS  LIST 26  (',i5,' ).')"),
    lstat(13), cmn.lsiz26;
  goto statement_4099;
  statement_4226:
  write(lunit6,
    "(5x,'LIST 26 WORKING VECTORS \"VOLT\", \"VOLTI\",',"
    "' \"VOLTK\", \"VIM\", AND \"VOLTA\"  ARE USED',"
    "' IN VARIOUS WAYS.   THIS IS ONE.',/,5x,"
    "'IF USER DOES NOT REQUEST 50 OR MORE,','  AND IF HE HAS TROUBLE,  SEE',"
    "' PROGRAM MAINTENANCE FOR DETAILS.')");
  goto statement_4099;
  statement_4027:
  goto statement_4012;
  statement_4028:
  goto statement_4012;
  statement_4029:
  goto statement_4012;
  statement_4499:
  write(lunit6,
    "(5x,'BOTH NETWORK NODE-RENUMBERING (TRANSIENT AND ALSO STEADY-STATE) AND "
    "THE STEADY-STATE PHASOR SOLUTION MAKE USE',/,5x,"
    "'OF THREE VERY LARGE ARRAYS WHICH OVERLAY MOST OF THE LABELED-COMMON STOR"
    "AGE SPACE (THE DATA OF WHICH IS PRESERVED',/,5x,"
    "'ON LOGICAL 4 DURING THESE CALCULATIONS).   THIS IS A DYNAMICALLY-DIMENSI"
    "ONED TABLE, THEN, WHICH IS SIZED TO USE',/,5x,"
    "'ALL AVAILABLE SPACE (PERHAPS 2/3 OF LABELED COMMON).   IN PARTICULAR, TH"
    "IS WORKING AREA INCLUDES ALL OF THE')");
  write(lunit6,
    "(5x,'GENERALLY-LARGE STORAGE FOR LISTS 5 AND 8.   INCREASING THE DIMENSIO"
    "NS OF EITHER OF THESE TWO LISTS WILL DIRECTLY',/,5x,"
    "'(AND WITHOUT ANY LOSS) INCREASE THE SIZE OF LIST 99.   IT MIGHT BE MENTI"
    "ONED THAT THE STEADY-STATE PHASOR',/,5x,"
    "'MANIPULATIONS (RENUMBERING, SOLUTION) WILL ALMOST ALWAYS PROVIDE THE LIM"
    "ITING DIFFICULTY.   THIS IS BECAUSE',/,5x,"
    "'SPARSITY OF THE STEADY-STATE PHASOR NETWORK IS GENERALLY WORSE THAN FOR "
    "THE TIME-STEP-LOOP NETWORK, DUE TO THE')");
  write(lunit6,
    "(5x,'DIFFERENCE IN TREATMENT OF DISTRIBUTED-PARAMETER LINES.   FOR STEADY"
    "-STATE SOLUTION, EQUIVALENT BRANCHES',/,5x,"
    "'INTERCONNECT EVERY TERMINAL NODE OF THE LINE, WHILE THE TWO ENDS ARE DIS"
    "CONNECTED BY BERGERON''S METHOD FOR THE',/,5x,"
    "'TIME-STEP-LOOP NETWORK.   DOUBLE-CIRCUIT (6-CONDUCTOR) LINES ARE PARTICU"
    "LARLY NASTY IN THE STEADY-STATE, THEN,',/,5x,"
    "'HAVING 12 TERMINAL NODES WHICH ARE ALL INTERCONNECTED BY EQUIVALENT BRAN"
    "CHES.')");
  statement_4099:
  write(lunit6,
    "(/,' IN ORDER TO EFFECTIVELY TRADE MEMORY SPACE AMONG THE DIFFERENT TABLE"
    "S, ONE MUST KNOW HOW MANY ARRAYS THERE',/,"
    "' ARE IN EACH TABLE (EFFECTIVELY).   THE FOLLOWING TABULATION SHOWS THE E"
    "FFECTIVE MULTIPLICITY ASSOCIATED WITH EACH',/,"
    "' INDEPENDENT LIST ----- THOSE LISTS WHOSE LENGTHS ARE UNDER USER  CONTRO"
    "L BY MEANS OF EMTP VARIABLE DIMENSIONING.')");
  write(lunit6, format_4096);
  {
    write_loop wloop(cmn, lunit6, "(5x,'LIST NUMBER  1',25i4)");
    FEM_DO_SAFE(i, 1, 25) {
      wloop, i;
    }
  }
  write(lunit6, format_4096);
  write(lunit6,
    "(5x,'FLOATING PT. 1',"
    "'   6   5   3   6   1  12   2   2   8   3   1   4   8   1   2   0   6   1"
    "   1  24   2   1   #   *   1')");
  write(lunit6,
    "(5x,'INTEGER      1',"
    "'   4   7   0   2   1  10   0   0  11   0   3   0   4   0   0   1  10   2"
    "   0   0   0   0   0   0   0',/,5x,'TOTAL        1',"
    "'  10  12   3   8   2  22   2   2  19   3   4   4  12   1   2   1  16   3"
    "   1  24   2   1   #   *   1')");
  write(lunit6, format_4096);
  write(lunit6,
    "(3x,'# --- USED ONLY FOR VIRTUAL MACHINES',"
    "' (BURROUGHS, PRIME, VAX, APOLLO, ETC.)',"
    "'   OTHERS CAN IGNORE THIS LIST.',/,3x,'* --- RATHER THAN COUNT LIST 24',"
    "' ITSELF, ADD THE VALUE TO THE',' FLOATING-POINT AND TOTAL COUNTS',"
    "' FOR LISTS 1 AND 6.')");
  statement_4092:
  write(lunit6, "(' ')");
  write(lunit6,
    "(25x,"
    "'CAUTION.   BE SKEPTICAL OF ABOVE  ''PRESENT FIGURE''  ENTRIES, DUE TO AB"
    "NORMAL TERMINATION OF CASE.')");
  write(lunit6, format_5316);
  FEM_DO_SAFE(i, 1, 2) {
    write(lunit6,
      "(' ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ER"
      "ROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR/ERROR')");
  }
  write(lunit6, format_5316);
  if (kilsav == 92) {
    goto statement_6767;
  }
  //C     LUNIT5 = MTAPE                                                    M39.3916
  write(6, star), " COMMENTED OUT  LUNIT5 = MTAPE.", "   SET KILL = 0.";
  kill = 0;
  n6 = 0;
  //C     READ INPUT CARD USING CIMAGE                                         18086
  statement_6740:
  cimage(cmn);
  n13 = kolbeg;
  nright = -2;
  kolbeg = 1;
  read(abuff, "(80a1)"), texcol;
  freone(cmn, d1);
  nright = 0;
  if (nfrfld != 1) {
    goto statement_6743;
  }
  if (texta6(1) == text5) {
    goto statement_6754;
  }
  if (texta6(1) == text13) {
    goto statement_6764;
  }
  if (texta6(1) == text19) {
    goto statement_6771;
  }
  statement_6743:
  if (nfrfld != 4) {
    goto statement_6770;
  }
  if (texta6(4) != text4) {
    goto statement_6770;
  }
  if (texta6(3) != text3) {
    goto statement_6770;
  }
  if (texta6(2) != text2) {
    goto statement_6760;
  }
  if (texta6(1) != text1) {
    goto statement_6760;
  }
  statement_6754:
  write(kunit6, "('+MARKER CARD PRECEDING NEW DATA CASE.')");
  interp();
  if (n6 < 5) {
    goto statement_6758;
  }
  n6 = n6 - 4;
  write(lunit6,
    "(51x,'END SUPPRESSION OF LISTING.',i6,'  CARDS WERE UNLISTED.')"),
    n6;
  statement_6758:
  noutpr = 0;
  kolbeg = -intinf;
  lastov = nchain;
  nchain = 1;
  if (iprsup >= 1) {
    write(lunit6, format_4568), 4568;
  }
  goto statement_9000;
  statement_6760:
  if (texta6(2) != text12) {
    goto statement_6770;
  }
  if (texta6(1) != text11) {
    goto statement_6770;
  }
  statement_6764:
  write(kunit6, "('+MARKER CARD FOLLOWING LAST DATA CASE.')");
  interp();
  statement_6767:
  kill = 9999;
  lastov = nchain;
  nchain = 31;
  if (iprsup >= 1) {
    write(lunit6, format_4568), kill;
  }
  goto statement_9000;
  statement_6770:
  if (nfrfld != 5) {
    goto statement_6773;
  }
  if (texta6(1) != text14) {
    goto statement_6773;
  }
  if (texta6(2) != text15) {
    goto statement_6773;
  }
  if (texta6(3) != text16) {
    goto statement_6773;
  }
  if (texta6(4) != text17) {
    goto statement_6773;
  }
  if (texta6(5) != text18) {
    goto statement_6773;
  }
  statement_6771:
  if (nenerg == 0) {
    goto statement_6773;
  }
  if (knt <= 1) {
    goto statement_6773;
  }
  write(kunit6, "('+REQUEST FOR STATISTICS SALVAGE.')");
  interp();
  if (jflsos > 0) {
    goto statement_6773;
  }
  d7 = -9999.f;
  n15 = kswtch + 1;
  {
    write_loop wloop(cmn, lunit3, fem::unformatted);
    FEM_DO_SAFE(j, 1, n15) {
      wloop, d7;
    }
  }
  n15 = lstat(32);
  {
    write_loop wloop(cmn, lunit9, fem::unformatted);
    FEM_DO_SAFE(j, 1, n15) {
      wloop, d7;
    }
  }
  if (n13 ==  - intinf) {
    kolbeg = n13;
  }
  if (kolbeg > 0) {
    goto statement_1773;
  }
  read(abuff, "(29x,i3)"), n1;
  goto statement_1778;
  statement_1773:
  freone(cmn, d1);
  n1 = d1;
  statement_1778:
  if (n1 > 0) {
    goto statement_1774;
  }
  if (n1 < 0) {
    iprsup = 9;
  }
  //C     FIND RANDOM INTEGER  'N1'  BETWEEN ZERO AND 999.                  M23.6490
  runtym(d11, d12);
  seed = seedy(cmn, tclock(1)) + 1000.f * (d11 + d12);
  n13 = alog1z(seed) + epsiln;
  n13 = n13 - 2;
  seed = seed / fem::pow(10.f, n13);
  n1 = seed;
  statement_1774:
  n2 = n1 / 100;
  n5 = n1 - 100 * n2;
  n3 = n5 / 10;
  n4 = n5 - 10 * n3;
  write(lunit6, "('+',34x,'''',3i1,'''')"), n2, n3, n4;
  lstat(14) = n2;
  lstat(15) = n3;
  lstat(16) = n4;
  statsv();
  goto statement_6740;
  statement_6773:
  if (noutpr == 0) {
    write(kunit6, "('+CARD IGNORED IN SEARCH FOR NEW-CASE BEGINNING.')");
  }
  n6++;
  if (n6 < 5) {
    goto statement_6769;
  }
  if (noutpr == 1) {
    goto statement_6769;
  }
  noutpr = 1;
  write(lunit6, "(51x,'BEGIN SUPPRESSION OF SKIPPED-RECORD PRINTOUT.')");
  statement_6769:
  goto statement_6740;
  statement_9000:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
over55(
  common& cmn) try
{
  common_write write(cmn);
  const auto& flstat = cmn.flstat;
  //auto& moncar = cmn.moncar;
  auto& lstat = cmn.lstat;
  const auto& iprsov = cmn.iprsov;
  int& kol132 = cmn.kol132;
  const auto& ktrlsw = cmn.ktrlsw;
  int& lastov = cmn.lastov;
  int& ktab = cmn.ktab;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  int& iprsup = cmn.iprsup;
  //
  auto& lunit6 = cmn.lunit6;
  int kilsav = fem::int0;
  int i = fem::int0;
  int k = fem::int0;
  double d6 = fem::double0;
  double d7 = fem::double0;
  double d1 = fem::double0;
  double d4 = fem::double0;
  double hmin = fem::double0;
  double d2 = fem::double0;
  double d3 = fem::double0;
  static const char* format_38010 = "(93x,'TOTALS ',3f10.3,/,/,1x)";
  static const char* format_4568 = "(' EXIT \"OVER55\".  KILL =',i6)";
  //C!EQUIVALENCE                       (MONCAR(4),  ISW)
  auto& isw = cmn.moncar(4);
  if (iprsup >= 1) {
    write(lunit6, "(' BEGIN \"OVER55\".  KILL =',i6)"), kill;
  }
  kilsav = kill;
  if (kill <= 0) {
    goto statement_6633;
  }
  subr55(cmn);
  statement_6633:
  if (nchain == 51) {
    goto statement_99999;
  }
  if (nchain == 31) {
    goto statement_99999;
  }
  kill = 0;
  if (kol132 == 132) {
    goto statement_6639;
  }
  {
    write_loop wloop(cmn, lunit6,
      "(/,' ACTUAL LIST SIZES FOR PRECEDING SOLUTION:',/,'   SIZE  1-10:',"
      "10i6,/,'   SIZE 11-20:',10i6,/,'   SIZE 21-ON:',10i6)");
    FEM_DO_SAFE(i, 1, 26) {
      wloop, lstat(i + 20);
    }
  }
  goto statement_6645;
  statement_6639:
  write(lunit6,
    "(/,' CORE STORAGE FIGURES FOR PRECEDING DATA CASE NOW COMPLETED.  -------"
    "--------------------------------',2x,'PRESENT',3x,'PROGRAM',/,"
    "' A VALUE OF  -9999 INDICATES DEFAULT, WITH NO FIGURE AVAILABLE.',41x,"
    "'FIGURE',5x,'LIMIT (NAME)')");
  write(lunit6,
    "(5x,'SIZE LIST 1.   NUMBER OF NETWORK NODES.',56x,2i10,' (LBUS)')"),
    lstat(21), cmn.lbus;
  write(lunit6,
    "(5x,'SIZE LIST 2.   NUMBER OF NETWORK BRANCHES.',53x,2i10,' (LBRNCH)')"),
    lstat(22), cmn.lbrnch;
  write(lunit6,
    "(5x,'SIZE LIST 3.   NUMBER OF DATA VALUES IN R, L, C TABLES.',40x,2i10,"
    "' (LDATA)')"),
    lstat(23), cmn.ldata;
  write(lunit6,
    "(5x,'SIZE LIST 4.   NUMBER OF ENTRIES IN SOURCE TABLE.',46x,2i10,"
    "' (LEXCT)')"),
    lstat(24), cmn.lexct;
  write(lunit6,
    "(5x,'SIZE LIST 5.   STORAGE FOR (Y) AND',' TRIANGULARIZED (Y).',6x,"
    "'NO. TIMES =',i5,3x,'FACTORS =',i5,2x,2i10,' (LYMAT)')"),
    ktrlsw(3), iprsov(36), lstat(25), cmn.lymat;
  write(lunit6,
    "(5x,'SIZE LIST 6.   NUMBER OF ENTRIES IN',' SWITCH TABLE.',15x,"
    "'NO. FLOPS =',i6,14x,2i10,' (LSWTCH)')"),
    ktrlsw(5), lstat(26), cmn.lswtch;
  write(lunit6,
    "(5x,'SIZE LIST 7.   NUMBER OF TOTAL DISTINCT',"
    "' ALPHANUMERIC (A6) PROGRAM NAMES',24x,2i10,' (LSIZE7)')"),
    cmn.maxbus, cmn.lsize7;
  write(lunit6,
    "(5x,'SIZE LIST 8.   NUMBER OF PAST HISTORY POINTS FOR DISTRIBUTED LINES.'"
    ",28x,2i10,' (LPAST)')"),
    lstat(28), cmn.lpast;
  write(lunit6,
    "(5x,'SIZE LIST 9.   NUMBER OF NONLINEAR ELEMENTS.',51x,2i10,' (LNONL)')"),
    lstat(29), cmn.lnonl;
  write(lunit6,
    "(5x,'SIZE LIST 10.  NUMBER OF POINTS DEFINING NONLINEAR CHARACTERISTICS.'"
    ",28x,2i10,' (LCHAR)')"),
    lstat(30), cmn.lchar;
  write(lunit6,
    "(5x,'SIZE LIST 11.  NUMBER OF BRANCH OR SELECTIVE-NODE-VOLTAGE OUTPUTS.',"
    "29x,2i10,' (LSMOUT)')"),
    lstat(31), cmn.lsmout;
  write(lunit6,
    "(5x,'SIZE LIST 12.  NUMBER OF OUTPUT QUANTITIES (LIMITED ONLY WHEN PRINTI"
    "NG MAX ABSOLUTE VALUES).',3x,2i10,' (LSIZ12)')"),
    lstat(32), cmn.lsiz12;
  write(lunit6,
    "(5x,'SIZE LIST 13.  NUMBER OF ''WEIGHTING'' FREQUENCY-DEPENDENT LINE MODE"
    "S.',27x,2i10,' (LFDEP)')"),
    lstat(33), cmn.lfdep;
  write(lunit6,
    "(5x,'SIZE LIST 14.  NUMBER OF CELLS USED TO STORE FREQ.-DEPENDENCE WEIGHT"
    "ING FUNCTIONS.',13x,2i10,' (LWT)')"),
    lstat(34), cmn.lwt;
  write(lunit6,
    "(5x,'SIZE LIST 15.  NUMBER OF CELLS USED FOR EXPONENTIAL-TAIL LINE-HISTOR"
    "Y STORAGE.',17x,2i10,' (LTAILS)')"),
    lstat(35), cmn.ltails;
  write(lunit6,
    "(5x,'SIZE LIST 16.  TOTAL NUMBER OF TYPE-59',' S.M. MASSES.',44x,2i10,"
    "' (LIMASS)')"),
    lstat(36), cmn.limass;
  write(lunit6,
    "(5x,'SIZE LIST 17.  NUMBER OF DYNAMIC SYNCHRONOUS MACHINES.',41x,2i10,"
    "' (LSYN)')"),
    lstat(37), cmn.lsyn;
  write(lunit6,
    "(5x,'SIZE LIST 18.  NUMBER OF BRANCH POWER-AND-ENERGY OUTPUTS.',38x,2i10,"
    "' (MAXPE)')"),
    lstat(38), cmn.maxpe;
  write(lunit6,
    "(5x,'SIZE LIST 19.  FLOATING-POINT WORKING SPACE FOR ALL TACS ARRAYS.',"
    "31x,2i10,' (LTACST)')"),
    lstat(39), cmn.ltacst;
  //C     KTAB IS IN BLKCOM, SO IT CAN NOT BE EQUIVALENCED TO               M39.3749
  if (ktab <= 0) {
    goto statement_7272;
  }
  lstat(53) += lstat(63) - lstat(60);
  lstat(56) = lstat(56) - lstat(58) + 3;
  lstat(58) = ktab;
  {
    write_loop wloop(cmn, lunit6,
      "(7x,'TACS TABLE NO.',8i10,/,7x,'PRESENT FIGURE',8i10,/,7x,"
      "'PROGRAM LIMIT ',8i10)");
    FEM_DO_SAFE(k, 1, 8) {
      wloop, k;
    }
    FEM_DO_SAFE(k, 51, 58) {
      wloop, lstat(k);
    }
    FEM_DO_SAFE(k, 61, 68) {
      wloop, lstat(k);
    }
  }
  statement_7272:
  write(lunit6,
    "(5x,'SIZE LIST 20.  RECURSIVE CONVOLUTION PARAMETER',"
    "' STORAGE FOR NON-COPIED BRANCH COMPONENTS.',7x,2i10,' (LFSEM)')"),
    lstat(40), cmn.lfsem;
  write(lunit6,
    "(5x,'SIZE LIST 21.  TOTAL STORAGE CELLS FOR MODAL-PHASE TRANSFORMATION MA"
    "TRICES.',20x,2i10,' (LFD)')"),
    lstat(41), cmn.lfd;
  write(lunit6,
    "(5x,'SIZE LIST 22.  NUMBER OF CELLS FOR',' CONVOLUTION HISTORY.',40x,"
    "2i10,' (LHIST)')"),
    lstat(42), cmn.lhist;
  write(lunit6,
    "(5x,'SIZE LIST 23.  GIANT ARRAYS FOR RENUMBERING AND STEADY-STATE SOLUTIO"
    "N CALCULATIONS.',12x,2i10,' (LSIZ23)')"),
    lstat(43), cmn.lsiz23;
  write(lunit6,
    "(5x,'SIZE LIST 24.  NUMBER OF PHASES OF COMPENSATION, BASED ON MAXIMUM NO"
    "DES.',23x,2i10,' (NCOMP)')"),
    cmn.ncomp, cmn.lcomp;
  write(lunit6,
    "(5x,'SIZE LIST 25.','  FLOATING-POINT WORKING SPACE FOR  U.M.  ARRAYS.',"
    "33x,2i10,' (LSPCUM)')"),
    lstat(45), cmn.lspcum;
  write(lunit6,
    "(5x,'SIZE LIST 26.  SQUARE OF MAXIMUM NUMBER',' OF COUPLED PHASES.',37x,"
    "2i10,' (LSIZ26)')"),
    lstat(46), cmn.lsiz26;
  statement_6645:
  if (kol132 == 132) {
    write(lunit6,
      "(' TIMING FIGURES (DECIMAL) CHARACTERIZING CASE SOLUTION SPEED.  ------"
      "-------------------------------',4x,'CP SEC',3x,'I/O SEC',3x,"
      "'SUM SEC')");
  }
  if (flstat(7) !=  - 9999.f) {
    goto statement_2601;
  }
  //C     SPECIAL TIMING CODE FOR SUPPORTING PROGRAMS.                      M39.3789
  d6 = flstat(9) + flstat(1);
  d7 = flstat(10) + flstat(2);
  d1 = d6 + d7;
  if (kol132 == 132) {
    write(lunit6, format_38010), d6, d7, d1;
  }
  if (kol132 == 80) {
    write(lunit6,
      "(' TOTAL CASE TIMING (CP, I/O, TOT), SEC:',1x,3f10.3)"), d6,
      d7, d1;
  }
  lastov = nchain;
  nchain = 1;
  if (iprsup >= 1) {
    write(lunit6, format_4568), kill;
  }
  goto statement_99999;
  statement_2601:
  d1 = flstat(1) + flstat(2);
  d4 = d1;
  if (kol132 == 132) {
    write(lunit6,
      "(5x,'DATA INPUT, SORTING, AND RENUMBERING (PRE STEADY STATE STUFF) ...."
      ".',28x,3f10.3)"),
      flstat(1), flstat(2), d1;
  }
  if (kol132 == 80) {
    write(lunit6,
      "(' SECONDS FOR OVERLAYS  1-6  :',3f9.3,'  --- (CP;  I/O;  TOT)')"),
      flstat(1), flstat(2), d1;
  }
  d1 = flstat(3) + flstat(4);
  d4 += d1;
  if (kol132 == 132) {
    write(lunit6,
      "(5x,'STEADY-STATE (S.S.) SOLUTION CALCULATIONS .....',48x,3f10.3)"),
      flstat(3), flstat(4), d1;
  }
  if (kol132 == 80) {
    write(lunit6, "(' SECONDS FOR OVERLAYS  7-12 :',3f9.3)"), flstat(3),
      flstat(4), d1;
  }
  d1 = flstat(5) + flstat(6);
  d4 += d1;
  if (kol132 == 132) {
    write(lunit6,
      "(5x,'POST-S.S. TO PRE-INTEGRATION-SETUP CALCULATIONS .....',42x,"
      "3f10.3)"),
      flstat(5), flstat(6), d1;
  }
  if (kol132 == 80) {
    write(lunit6, "(' SECONDS FOR OVERLAYS 13-15 :',3f9.3)"), flstat(5),
      flstat(6), d1;
  }
  d1 = flstat(7) + flstat(8);
  d4 += d1;
  if (kol132 == 132) {
    write(lunit6,
      "(5x,'INTEGRATION CALCULATION (TIME IN TIME-STEP LOOP) .....',41x,"
      "3f10.3)"),
      flstat(7), flstat(8), d1;
  }
  if (kol132 == 80) {
    write(lunit6, "(' SECONDS FOR TIME-STEP LOOP :',3f9.3)"), flstat(7),
      flstat(8), d1;
  }
  hmin = flstat(9) + flstat(10);
  d4 += hmin;
  if (kol132 == 132) {
    write(lunit6,
      "(5x,'COMPUTER TIME IN PLOTTING OR STATISTICS TERMINATION OVERLAY .....'"
      ",30x,3f10.3)"),
      flstat(9), flstat(10), hmin;
  }
  if (kol132 == 80) {
    write(lunit6, "(' SECONDS AFTER DELTAT-LOOP  :',3f9.3)"), flstat(9),
      flstat(10), hmin;
  }
  d1 = flstat(11) + flstat(12);
  d4 += d1;
  if (kol132 == 132) {
    write(lunit6,
      "(5x,'''DELTAT''-CHANGE RESTART TIME  .......',58x,3f10.3,/,101x,"
      "'-----------------------------')"),
      flstat(11), flstat(12), d1;
  }
  d2 = 0.0f;
  d3 = 0.0f;
  FEM_DOSTEP(i, 1, 12, 2) {
    d2 += flstat(i);
    d3 += flstat(i + 1);
  }
  if (kol132 == 132) {
    write(lunit6, format_38010), d2, d3, d4;
  }
  if (kol132 == 80) {
    write(lunit6,
      "(29x,'-------------------------  ',/,20x,'TOTALS  :',3f9.3)"),
      d2, d3, d4;
  }
  if (isw != 4444) {
    goto statement_6673;
  }
  isw = -3344;
  subr55(cmn);
  statement_6673:
  lastov = nchain;
  nchain = 1;
  kill = 0;
  if (iprsup >= 1) {
    write(lunit6, format_4568), kill;
  }
  statement_99999:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
copyr(
  double const& d1,
  arr_ref<double> to,
  int const& kk)
{
  to(dimension(1));
  //C     ROUTINE WHICH COPIES THE SAME FLOATING-POINT WORD  'D1'  INTO A   M22. 638
  //C     CONTIGUOUS REGION OF MEMORY ----  'KK'  WORDS IN LENGTH,          M22. 639
  //C     BEGINNING WITH WORD  TO(1) .                                      M22. 640
  int i = fem::int0;
  FEM_DO_SAFE(i, 1, kk) {
    to(i) = d1;
  }
}

void
ioerr(
  int const& /* naddr */)
{
}

void
caterr(
  int const& /* naddr */,
  int const& /* koderr */)
{
}

//C!      SUBROUTINE TRGWND ( X, D17 )                                      M42. 571
//C!      include 'zdef1.inc'
//C!      INCLUDE  'BLKCOM.inc'
//C!      D17 = X                                                           M42. 573
//C!      IF ( DABS(X) .LT. 25000. )  GO TO 9000
//C!      N13 = X / TWOPI
//C!      D17 = D17 - N13 * TWOPI
//C!      IF ( IPRSUP .GE. 1 )                                              M42. 577
//C!     1 WRITE (*, 3456)  NCHAIN, X, D17                                  M42. 578
//C! 3456 FORMAT ( ' ANGLE UNWIND IN "TRGWND" CALLED BY "RFUNL1".',         M42. 579
//C!     1         '   NCHAIN, X, D17 =',  I5, 2E25.16  )                   M42. 580
//C! 9000 RETURN                                                            M42. 581
//C!      END                                                               M42. 582

void
cmultz(
  double& ar,
  double& ai,
  double const& br,
  double const& bi,
  double const& cr,
  double const& ci,
  int const& ksn) try
{
  double sr = fem::double0;
  sr = br * cr - bi * ci;
  ai = bi * cr + br * ci;
  ar = sr;
  if (ksn >= 0) {
    goto statement_200;
  }
  ar = -ar;
  ai = -ai;
  statement_200:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
cdivz(
  double& ar,
  double& ai,
  double const& br,
  double const& bi,
  double const& cr,
  double const& ci,
  int const& ksn) try
{
  double fac = fem::double0;
  double sr = fem::double0;
  fac = cr * cr + ci * ci;
  fac = 1.f / fac;
  sr = br * fac * cr + bi * fac * ci;
  ai = bi * fac * cr - br * fac * ci;
  ar = sr;
  if (ksn >= 0) {
    goto statement_200;
  }
  ar = -ar;
  ai = -ai;
  statement_200:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

int
ifunl2(
  int const& n1,
  int const& n2) try
{
  int return_value = fem::int0;
  //C     PROVISION FOR ALL INTEGER LIBRARY FUNCTIONS OF 2 INTEGER ARGUMENTSM25.  78
  return_value = n1;
  return return_value;
  // UNHANDLED: ENTRY isignz(n1,n2)
  int isignz = fem::isign(n1, n2);
  return return_value;
  // UNHANDLED: ENTRY modz(n1,n2)
  int modz = fem::mod(n1, n2);
  return return_value;
  // UNHANDLED: ENTRY min0z(n1,n2)
  int min0z = fem::min0(n1, n2);
  return return_value;
  // UNHANDLED: ENTRY max0z(n1,n2)
  int max0z = fem::max0(n1, n2);
  return return_value;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
dlibrf(
  double const& x,
  double& y) try
{
  //C     THIS MODULE SERVES TO PROVIDE SELECTED DOUBLE-PRECISION           M32. 171
  //C     LIBRARY FUNCTIONS FOR SEVERAL PLACES IN THE PROGRAM.              M32. 172
  //C     MAKING THIS A SUBROUTINE RATHER THAN A FUNCTION AVOIDS ALL        M32. 173
  //C     COMPLICATIONS WITH THE MODULE NAME HAVING A VARIABLE TYPE         M32. 174
  //C     ASSOCIATED WITH IT.   IT IS INSTALLATION-DEPENDENT BECAUSE OF TWO M32. 175
  //C     THINGS --- FIRST THE USE OF ENTRY POINTS, AND SECOND THE USE      M32. 176
  //C     OF THE DOUBLE-PRECISION DECLARATION (BY WHICH IS MEANT DOUBLE     M32. 177
  //C     THE PRECISION OF REGULAR FLOATING-POINT VARIABLES OF THE EMTP).   M32. 178
  //C     SINCE MOST BYTE-ORGANIZED MACHINES USE  REAL*8  FOR OTHER         M32. 179
  //C     VARIABLES, THIS IMPLIES  REAL*16 ,  IF AVAILABLE.                 M32. 180
  //C     INSTALLATION-DEPENDENT MODULE CODED FOR  DEC VAX-11               M32. 181
  return;
  // UNHANDLED: ENTRY dabsz(x,y)
  y = std::abs(x);
  return;
  // UNHANDLED: ENTRY dcosz(x,y)
  y = std::cos(x);
  return;
  // UNHANDLED: ENTRY dexpz(x,y)
  y = std::exp(x);
  return;
  // UNHANDLED: ENTRY dsinz(x,y)
  y = std::sin(x);
  return;
  // UNHANDLED: ENTRY dsqrtz(x,y)
  y = std::sqrt(x);
  return;
  // UNHANDLED: ENTRY dlogz(x,y)
  y = fem::dlog(x);
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
dlibr2(
  double const& x,
  double const& y,
  double& z)
{
  //C     INSTALLATION-DEPENDENT MODULE FOR DEC VAX-11 COMPUTER             M32. 200
  //C     LIKE "DLIBRF" (SEE COMMENTS THERE), ONLY FOR TWO INPUTS           M32. 201
  return;
  // UNHANDLED: ENTRY datn2z(x,y,z)
  z = fem::datan2(x, y);
}

void
setmar()
{
  //C     SUBROUTINE TO CHANGE PAGE SIZE AND EJECT PAGE FOR PRINTER PLOTS.  M32. 208
  //C     DUMMY MODULE SINCE THIS ONTARIO HYDRO (UNIVAC) TRICK IS UNKNOWN.  M32. 209
  return;
  // UNHANDLED: ENTRY chrsiz(n)
  //C     ENTRY POINT FOR DO-NOTHING MIMICED TEKTRONIX PLOT10 OF "TEKPLT"   M32. 213
  return;
  // UNHANDLED: ENTRY setplt
  //C     ENTRY POINT TO CHANGE LINES/PAGE TO MAXIMUM NUMBER ALLOWED,       M32. 213
  //C     TO ALLOW PRINTER PLOTS TO BE CONTINUOUS OVER PAGE BOUNDRIES.      M32. 214
  //C     CALL SYSTEM DEPENDANT ROUTINE TO CHANGE PAGE SIZE                 M32. 215
  //C     WRITE (LUNIT6, 1000 )                                             M32. 216
  return;
  // UNHANDLED: ENTRY setstd
  //C     ENTRY POINT TO RESTORE PAGE LIMITS TO STANDARD VALUES.            M32. 220
  //C     CALL SYSTEM DEPENDANT ROUTINE TO CHANGE PAGE SIZE                 M32. 221
  //C     WRITE (LUNIT6, 1000 )                                             M32. 222
}

void
ancho(
  int const& /* i */)
{
}

void
grid1(
  float const& /* x */,
  float const& /* y */,
  int const& /* i */,
  float const& /* g */,
  int const& /* k */,
  float const& /* h */,
  int const& /* L */)
{
}

void
movabs(
  int const& /* i */,
  int const& /* j */)
{
}

void
dshabs(
  int const& /* i */,
  int const& /* j */,
  int const& /* k */)
{
}

void
vecrxx(
  common& cmn,
  arr_ref<double> array,
  int& n13,
  int const& n2) try
{
  array(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  auto& lunt13 = cmn.lunt13;
  int& iprsup = cmn.iprsup;
  //
  auto& lunit6 = cmn.lunit6;
  int n6 = fem::int0;
  int j = fem::int0;
  int n14 = fem::int0;
  int k = fem::int0;
  //C     UNIVERSAL (NON-VIRTUAL) FORM OF MODULE FOR BINARY I/O.  IF        M32. 568
  //C     EXTRACTED FROM UTPF FOR USE, CONVERT NAME "VECRXX" TO "VECRSV"    M32. 569
  if (iprsup >= 1) {
    write(lunit6, "(' BEGIN \"VECRSV\".  N13, N2 =',2i8)"), n13, n2;
  }
  if (n2 != 0) {
    goto statement_1638;
  }
  //C     ZERO N2 MEANS THAT WE WANT TO POSITION TAPE FOR NEXT READ:        M32. 576
  if (n13 >= 0) {
    goto statement_1592;
  }
  n6 = -n13;
  FEM_DO_SAFE(j, 1, n6) {
    cmn.io.backspace(lunt13);
  }
  goto statement_9000;
  statement_1592:
  cmn.io.rewind(lunt13);
  if (n13 == 0) {
    goto statement_1612;
  }
  FEM_DO_SAFE(j, 1, n13) {
    read(lunt13, fem::unformatted), n14;
  }
  statement_1612:
  if (iprsup >= 1) {
    write(6, "(' POSITION MAGNETIC TAPE.  N13 =',i4)"), n13;
  }
  n13 = 3;
  goto statement_9000;
  statement_1638:
  if (n2 == 1) {
    goto statement_1671;
  }
  //C     BEGIN CODE TO RESTORE  (ARRAY(K), K=1, N13)  FROM TAPE:           M32. 592
  {
    read_loop rloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(k, 1, n13) {
      rloop, array(k);
    }
  }
  goto statement_9000;
  //C     BEGIN CODE TO DUMP  (ARRAY(K), K=1, N13)  ONTO TAPE:              M32. 595
  statement_1671:
  {
    write_loop wloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(k, 1, n13) {
      wloop, array(k);
    }
  }
  statement_9000:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT \"VECRSV\".  ARRAY(1;2;N13) =',3e15.6)"),
      array(1), array(2), array(n13);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
vecixx(
  common& cmn,
  arr_ref<int> karr,
  int const& n13,
  int const& n2) try
{
  karr(dimension(1));
  common_read read(cmn);
  common_write write(cmn);
  auto& lunt13 = cmn.lunt13;
  int& iprsup = cmn.iprsup;
  //
  auto& lunit6 = cmn.lunit6;
  int k = fem::int0;
  //C     UNIVERSAL (NON-VIRTUAL) FORM OF MODULE FOR BINARY I/O.  IF        M32. 603
  //C     EXTRACTED FROM UTPF FOR USE, CONVERT NAME "VECIXX" TO "VECISV"    M32. 604
  if (iprsup >= 1) {
    write(lunit6, "(' BEGIN \"VECISV\".  N13, N2 =',2i8)"), n13, n2;
  }
  if (n2 == 1) {
    goto statement_1471;
  }
  //C     BEGIN CODE TO RESTORE  (KARR(K), K=1, N13)  FROM TAPE:            M32. 611
  {
    read_loop rloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(k, 1, n13) {
      rloop, karr(k);
    }
  }
  goto statement_9000;
  //C     BEGIN CODE TO DUMP  (KARR(K), K=1, N13)  ONTO TAPE:               M32. 614
  statement_1471:
  {
    write_loop wloop(cmn, lunt13, fem::unformatted);
    FEM_DO_SAFE(k, 1, n13) {
      wloop, karr(k);
    }
  }
  statement_9000:
  if (iprsup >= 1) {
    write(lunit6, "(' EXIT \"VECISV\".  KARR(1;2;N13) =',3i10)"),
      karr(1), karr(2), karr(n13);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
mul(
  arr_cref<double> y,
  arr_cref<double> z,
  arr_ref<double> xay,
  int const& l1,
  int const& m,
  int const& n) try
{
  y(dimension(1));
  z(dimension(1));
  xay(dimension(1));
  int L = fem::int0;
  int j = fem::int0;
  int nm = fem::int0;
  int nl = fem::int0;
  double a = fem::double0;
  int i = fem::int0;
  int n1 = fem::int0;
  int n2 = fem::int0;
  int nl1 = fem::int0;
  //C)    MULTIPLICATION OF TWO MATRICES STORED AS VECTORS BY COLUMNS       M20.3510
  L = 1;
  statement_2:
  j = 1;
  nm = -n;
  statement_4:
  nm += n;
  nl = nm + L;
  a = 0.0f;
  i = 1;
  n1 = -m;
  n2 = nm;
  statement_3:
  n1 += m;
  nl1 = n1 + L;
  n2++;
  a += y(nl1) * z(n2);
  i++;
  if (i <= m) {
    goto statement_3;
  }
  xay(nl) = a;
  j++;
  if (j <= n) {
    goto statement_4;
  }
  L++;
  if (L <= l1) {
    goto statement_2;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
redinv(
  arr_ref<double> x1,
  int const& m,
  int const& n) try
{
  x1(dimension(1));
  int j = fem::int0;
  int ik = fem::int0;
  int nk = fem::int0;
  double c = fem::double0;
  arr_1d<20, double> a1(fem::fill0);
  int k = fem::int0;
  int mk = fem::int0;
  int n9 = fem::int0;
  double b = fem::double0;
  int i = fem::int0;
  //C     GAUSS-JORDAN ELIMINATION PROCESS PERFORMED ON A SQUARE MATRIX X   M30. 357
  //C)    THIS ROUTINE CAN ALSO BE USED FOR MATRIX INVERSION * * * * * * * *M30. 358
  //C     MAXIMUM ORDER OF MATRIX X IS 20                                   M30. 359
  j = m;
  ik = fem::pow2(m);
  nk = ik - m;
  statement_1:
  c = x1(ik);
  c = 1.0f / c;
  mover(x1(nk + 1), a1(1), m);
  k = 1;
  statement_4:
  mk = (k - 1) * m;
  n9 = mk + j;
  b = -x1(n9) * c;
  i = 1;
  statement_3:
  mk++;
  x1(mk) += b * a1(i);
  i++;
  if (i <= m) {
    goto statement_3;
  }
  n9 = mk + j - m;
  x1(n9) = b;
  k++;
  if (k == j) {
    k++;
  }
  if (k <= m) {
    goto statement_4;
  }
  FEM_DO_SAFE(k, 1, m) {
    n9 = nk + k;
    x1(n9) = a1(k) * c;
  }
  x1(ik) = c;
  j = j - 1;
  ik = ik - m - 1;
  nk = nk - m;
  if (j > n) {
    goto statement_1;
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
qyqtr(
  int const& nphs,
  arr_cref<double> dy,
  arr_cref<double> q,
  arr_ref<double> y) try
{
  dy(dimension(1));
  q(dimension(1));
  y(dimension(1));
  //C      INSERT DECK  LABCOM                                              VAX.2323
  //C                                                                       VAX.2325
  int n1 = nphs * (nphs + 1) / 2;
  int i = fem::int0;
  FEM_DO_SAFE(i, 1, n1) {
    y(i) = 0.e0;
  }
  //C                                                                       VAX.2330
  int k = fem::int0;
  int km1 = fem::int0;
  double dyk = fem::double0;
  int ij = fem::int0;
  int j = fem::int0;
  int jk = fem::int0;
  double qjk = fem::double0;
  int ik = fem::int0;
  double qik = fem::double0;
  double b = fem::double0;
  FEM_DO_SAFE(k, 1, nphs) {
    km1 = (k - 1) * nphs;
    dyk = dy(k);
    ij = 0;
    FEM_DO_SAFE(j, 1, nphs) {
      jk = km1 + j;
      qjk = q(jk);
      FEM_DO_SAFE(i, 1, j) {
        ij++;
        ik = km1 + i;
        qik = q(ik);
        b = qik * qjk;
        y(ij) += dyk * b;
      }
    }
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
movers(
  str_arr_cref<> from,
  str_arr_ref<> to,
  int const& num) try
{
  from(dimension(1));
  to(dimension(1));
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M35.4048
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4049
  int j = fem::int0;
  FEM_DO_SAFE(j, 1, num) {
    to(j) = from(j);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
moverl(
  arr_cref<double> from,
  arr_ref<double> to,
  int const& num) try
{
  from(dimension(1));
  to(dimension(1));
  //C     MODULE OF INTERACTIVE EMTP USAGE ONLY, WHICH SERVICES "EMTSPY".   M35.4056
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.4057
  int j = fem::int0;
  FEM_DO_SAFE(j, 1, num) {
    to(j) = from(j);
  }
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
fresp3(
  common& cmn,
  str_ref ansi,
  float& d12,
  float& d13,
  float& d14) try
{
  common_read read(cmn);
  //C     UNIVERSAL MODULE (WORKS FOR ANY COMPUTER) USED ONLY FOR THE       M38.4624
  //C     INTERACTIVE EMTP ("EMTSPY").  IT IS CALLED TO DECODE THREE        M38.4625
  //C     FLOATING POINT NUMBERS D12,D13,D13 FROM CHARACTER*80 ANSI.        M38.4626
  //C     THIS IS IDENTICAL TO "FREFP3", EXCEPT FOR SINGLE PRECISION.       M38.4627
  int n8 = 3;
  frefix(cmn, ansi, n8);
  read(ansi, "(3e20.0)"), d12, d13, d14;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
back14(
  common& cmn) try
{
  common_write write(cmn);
  double& tstep = static_cast<common_cblock&>(cmn).tstep;
  //
  //C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.7388
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.7389
  if (cmn.iprspy < 1) {
    goto statement_1483;
  }
  write(cmn.munit6, "(' TOP OF  \"BACK14\" .   TSTEP =',e15.5)"), tstep;
  window(cmn);
  statement_1483:
  tstep = -1.0f;
  //C     THIS DECK IS USED ONLY BY INTERACTIVE EXECUTION MODULES           M35.  11
  //C     WHICH BEGIN WITH "EMTSPY".  NOTE "DECK29" WORKING SPACE:          M35.  12
  //C!COMMON /C29B01/  KARRAY(1)  ! "DECK29" STORES PLOT POINTS
  //C REAL*4 PLOT STORA
  //C!w EQUIVALENCE  ( PLTBUF(1), KARRAY(1) )  ! /C29B01/ PLOT POINTS
  //C LOGICAL VARIABLE FOR "INQUIRE" USAGE
  //C       END REALS, NEXT COME INTEGERS, IN NEW COMMON BLOCK:             M35.  20
  //C!w EQUIVALENCE (KAR1, FKAR1), (KAR2, FKAR2)
  //C     USAGE IS RESTRICTED TO "PLOT" FUNCTION OF "EMTSPY", DUE           M35.  37
  //C     TO VARIABLE-LENGTH CONFLICT (THIS IS SINGLE-PRECISION).           M35.  38
  //C!w nc -> ncz, numnvo -> numnvz, numout -> numouz, nv -> nvz
  //C     EVNBYT PUTS BUSLST ON REAL*8 BYTE BOUNDARY (IBM LEVEL 4 ERROR):   M39.  44
  //C!w EQUIVALENCE  ( EV(   1), BUSLST(1) ),  ( EV(1001), IBSOUT(1) )
  //C!w EQUIVALENCE  ( EV(1301), IBRNCH(1) ),  ( EV(1601), JBRNCH(1) )
  //C!w EQUIVALENCE  ( FVCOM( 1),   VMIN ),  ( FVCOM( 2),   VMAX )
  //C!w EQUIVALENCE  ( FVCOM( 3),   HMIN ),  ( FVCOM( 4),   HMAX )
  //C!w EQUIVALENCE  ( FVCOM( 5),     HA ),  ( FVCOM( 6), TAXISL )
  //C!w EQUIVALENCE  ( FVCOM( 7), TOLRCE ),  ( FVCOM( 8),   HTAX )
  //C!w EQUIVALENCE  ( FVCOM( 9),   XTIT ),  ( FVCOM(10),   YTIT )
  //C!w EQUIVALENCE  ( FVCOM(11), SIZTIT ),  ( FVCOM(12), XSUPER )
  //C!w EQUIVALENCE  ( FVCOM(13), YSUPER ),  ( FVCOM(14), SIZSUP )
  //C!w EQUIVALENCE  ( FVCOM(15),  FLINE ),  ( FVCOM(16),  SIZID )
  //C!w EQUIVALENCE  ( FVCOM(17),    XID ),  ( FVCOM(18),    YID )
  //C!w EQUIVALENCE  ( FVCOM(19),   FACT ),  ( FVCOM(20), DXGRD1 )
  //C!w EQUIVALENCE  ( FVCOM(21), DYGRD1 ),  ( FVCOM(22), DXGRD2 )
  //C!w EQUIVALENCE  ( FVCOM(23), DYGRD2 ),  ( FVCOM(24),  FILL1 )
  //C!w EQUIVALENCE  ( FVCOM(25),  FILL2 ),  ( FVCOM(26),     VS )
  //C!w EQUIVALENCE  ( FVCOM(27),     VL ),  ( FVCOM(28),     VH )
  //C!w EQUIVALENCE  ( FVCOM(29), PAPMAX ),  ( FVCOM(30), TIMBEG )
  //C!w EQUIVALENCE  ( FVCOM(31), TIMEND ),  ( FVCOM(32), FHTAX  )
  //C!w EQUIVALENCE  ( FVCOM(33), FXSUP  ),  ( FVCOM(34), FYSUP  )
  //C!w EQUIVALENCE  ( FVCOM(35), FXTIT  ),  ( FVCOM(36), FYTIT  )
  //C!w EQUIVALENCE  ( FVCOM(37), FXID   ),  ( FVCOM(38), FYID   )
  //C!w EQUIVALENCE  ( FVCOM(39), FTCARR ),  ( FVCOM(40), VAXISL )
  //C!w EQUIVALENCE  ( FVCOM(41), FXNUMV ),  ( FVCOM(42), FXNUMH )
  //C!w EQUIVALENCE  ( FVCOM(43), FVAXTT ),  ( FVCOM(44), FXVERT )
  //C!w EQUIVALENCE  ( FVCOM(45), FSYMB  ),  ( FVCOM(46), PAPLIM )
  //C!w EQUIVALENCE  ( IVCOM( 1),  KLEVL ),  ( IVCOM( 2),  KEXTR )
  //C!w EQUIVALENCE  ( IVCOM( 3),    IHS ),  ( IVCOM( 4), LU7PLT )
  //C!w EQUIVALENCE  ( IVCOM( 5), IPRSRT ),  ( IVCOM( 6), LIMCOL )
  //C!w EQUIVALENCE  ( IVCOM( 7), LINEPR ),  ( IVCOM( 8),  IBAUD )
  //C!w EQUIVALENCE  ( IVCOM( 9),   LTEK ),  ( IVCOM(10), NUMTIT )
  //C!w EQUIVALENCE  ( IVCOM(11), MAXSYM ),  ( IVCOM(12),   MTIT )
  //C!w EQUIVALENCE  ( IVCOM(13), MAXISX ),  ( IVCOM(14), MAXISY )
  //C!w EQUIVALENCE  ( IVCOM(15), MGRID1 ),  ( IVCOM(16), MGRID2 )
  //C!w EQUIVALENCE  ( IVCOM(17), MSUPER ),  ( IVCOM(18),    MID )
  //C!w EQUIVALENCE  ( IVCOM(19),  MLINE ),  ( IVCOM(20),  NCUT1 )
  //C!w EQUIVALENCE  ( IVCOM(21),  NCUT2 ),  ( IVCOM(22), NSMPLT )
  //C!w EQUIVALENCE  ( IVCOM(23),  LSYMB ),  ( IVCOM(24),  NXMAX )
  //C!w EQUIVALENCE  ( IVCOM(25),  NYMAX ),  ( IVCOM(26),  LCHID )
  //C!w EQUIVALENCE  ( IVCOM(27), NXINCH ),  ( IVCOM(28), NYINCH )
  //C!w EQUIVALENCE  ( IVCOM(29),  NXOFF ),  ( IVCOM(30),  NYOFF )
  //C!w EQUIVALENCE  ( IVCOM(31),   LOOK ),  ( IVCOM(32), LCHSUP )
  //C!w EQUIVALENCE  ( IVCOM(33), LCHTIT ),  ( IVCOM(34), LCHXAX )
  //C!w EQUIVALENCE  ( IVCOM(35), LCHYAX ),  ( IVCOM(36),  ITERM )
  //C!w EQUIVALENCE  ( IVCOM(37),   LTIC ),  ( IVCOM(38),  IZTIT )
  //C!w EQUIVALENCE  ( IVCOM(39),  IZGR1 ),  ( IVCOM(40),  IZGR2 )
  //C!w EQUIVALENCE  ( IVCOM(41), LDSHG1 ),  ( IVCOM(42), LDSHG2 )
  //C!w EQUIVALENCE  ( IVCOM(43),  IZXAX ),  ( IVCOM(44),  IZYAX )
  //C!w EQUIVALENCE  ( IVCOM(45),  NXID6 ),  ( IVCOM(46),  NYID6 )
  //C!w EQUIVALENCE  ( IVCOM(47),  NXEND ),  ( IVCOM(48),  NYEND )
  //C!w EQUIVALENCE  ( IVCOM(49),   IZID ),  ( IVCOM(50), NXVERN )
  //C!w EQUIVALENCE  ( IVCOM(51), ICHREF ),  ( IVCOM(52), ICHEND )
  //C!w EQUIVALENCE  ( IVCOM(53), INCHPX ),  ( IVCOM(54), INCHPY )
  //C!w EQUIVALENCE  ( IVCOM(55), INWAIT ),  ( IVCOM(56), NOLABL )
  //C!w EQUIVALENCE  ( IVCOM(57), LCHFIL ),  ( IVCOM(58), LCHLIM )
  //C!w EQUIVALENCE  ( IVCOM(59), MU6STD )
  //C       NEXT TYPE KEY CHARACTER KEY WORDS IN COMMON, IN ORDER:          M35. 120
  //C!w EQUIVALENCE ( ANPLT( 1), CHOICE ),  ( ANPLT( 2),   STOP )
  //C!w EQUIVALENCE ( ANPLT( 3),  PURGE ),  ( ANPLT( 4),    OUT )
  //C!w EQUIVALENCE ( ANPLT( 5),   HELP ),  ( ANPLT( 6), SMOOTH )
  //C!w EQUIVALENCE ( ANPLT( 7),   SIZE ),  ( ANPLT( 8),   SHOW )
  //C!w EQUIVALENCE ( ANPLT( 9), LINEZZ ),  ( ANPLT(10),  PHOTO )
  //C!w EQUIVALENCE ( ANPLT(11), REPEAT ),  ( ANPLT(12),  FLUSH )
  //C!w EQUIVALENCE ( ANPLT(13), PLAYBA ),  ( ANPLT(14),    PEN )
  //C!w EQUIVALENCE ( ANPLT(15), MULTIP ),  ( ANPLT(16), OFFSET )
  //C!w EQUIVALENCE ( ANPLT(17), LIMITS ),  ( ANPLT(18),  DEBUG )
  //C!w EQUIVALENCE ( ANPLT(19),    TEK ),  ( ANPLT(20),  STACK )
  //C!w EQUIVALENCE ( ANPLT(21), PRINTE ),  ( ANPLT(22), METRIC )
  //C!w EQUIVALENCE ( ANPLT(23), ALLTIM ),  ( ANPLT(24), COLUMN )
  //C!w EQUIVALENCE ( ANPLT(25), SETCOL ),  ( ANPLT(26), LONGER )
  //C!w EQUIVALENCE ( ANPLT(27), AVERAG ),  ( ANPLT(28),  INNER )
  //C!w EQUIVALENCE ( ANPLT(29), RESCAL ),  ( ANPLT(30),  LASTPL)
  //C!w EQUIVALENCE ( ANPLT(31),  BATCH ),  ( ANPLT(32),  PUNCH )
  //C!w EQUIVALENCE ( ANPLT(33), EXTREM ),  ( ANPLT(34),  LEVEL )
  //C!w EQUIVALENCE ( ANPLT(35), NOPLOT ),  ( ANPLT(36), MESSAG )
  //C!w EQUIVALENCE ( ANPLT(37),    END ),  ( ANPLT(38), TIMESP )
  //C!w EQUIVALENCE ( ANPLT(39),  LABEL ),  ( ANPLT(40), TIMEUN )
  //C!w EQUIVALENCE ( ANPLT(41), CURSOR ),  ( ANPLT(42), XYPLOT )
  //C!w EQUIVALENCE ( ANPLT(43),  SLOPE ),  ( ANPLT(44),   BACK )
  //C!w EQUIVALENCE ( ANPLT(45), REFILE ),  ( ANPLT(46), TEXBLK )
  //C!w EQUIVALENCE ( ANPLT(47), SETDAT )
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

//C!w not used
//C!      SUBROUTINE FLATBD               ! NO IMPLICIT                     M35.8163
//C!      include 'zdef1.inc'
//C!C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.8164
//C!C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.8165
//C!C     THE ONE AND ONLY USE IS TO PROVIDE CALCOMP COPIES OF WHAT         M35.8166
//C!C     IS ON THE SCREEN (FOR "PLOT" COMMAND OF "EMTSPY"), WITH           M35.8167
//C!C     BPA PSEUDO-CALCOMP VERSATEK CALLS ACTUALLY USED.                  M35.8168
//C!      INCLUDE  'DEKSPY.inc'
//C!      INCLUDE  'DEKPLT.inc'
//C!      IF ( KILLPL  .EQ.  0 )   GO TO 2005                               M35.8171
//C!      CALL PLOT ( 0.0, 0.0, 999 )                                       M35.8172
//C!      RETURN                                                            M35.8173
//C! 2005 D1 = HPI * TMULT                                                  M35.8174
//C!      WRITE (PROM80, 2010)  D1                                          M35.8175
//C! 2010 FORMAT (  ' SEND T-AXIS UNITS/INCH (',  E12.3,                    M35.8176
//C!     1          ' ) :'   )                                              M35.8177
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8178
//C!      READ (MUNIT5, 7241)  BUFF77   ! READ A80 CHARACTER INPUT          M35.8179
//C!      IF ( BUFF77(1:8)  .NE.  METRIC )   GO TO 7236                     M35.8180
//C!      FACT = .7874                                                      M35.8181
//C!      DXGRD1 = 0.5                                                      M35.8182
//C!      DYGRD1 = DXGRD1                                                   M35.8183
//C!      DXGRD2 = 0.1                                                      M35.8184
//C!      DYGRD2 = DXGRD2                                                   M35.8185
//C!      GO TO 2005                                                        M35.8186
//C! 7236 IF ( BUFF77(1:8)  .NE.  PEN )   GO TO 7261                        M35.8187
//C!      WRITE (MUNIT6, 7238)                                              M35.8188
//C! 7238 FORMAT (                                                          M35.8189
//C!     1   ' Respond to each pen-width request with integer'  ,/,         M35.8190
//C!     1   ' information.  Blank or zero implies that there'  ,/,         M35.8191
//C!     2   ' will be no change from the present value, while' ,/,         M35.8192
//C!     3   ' a value of  -1  suppresses the printout, and'    ,/,         M35.8193
//C!     4   ' values of  1  through  5  are Versatek dot'      ,/,         M35.8194
//C!     5   ' widths (VAX "CalComp" at BPA is Versatek).'      )           M35.8195
//C!      WRITE (PROM80, 7240)  MTIT                                        M35.8196
//C! 7240 FORMAT ( 3X,  '80-COL. CASE-TITLE (',  I2,  ' ) :'   )            M35.8197
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8198
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8199
//C! 7241 FORMAT ( A80 )                                                    M35.8200
//C!      CALL FREIN1 ( PROM80, N1 )   ! DECODE FREE-FIELD N1               M35.8201
//C!      IF ( N1  .NE.  0 )   MTIT = N1                                    M35.8202
//C!      WRITE (PROM80, 7242)  MAXISX                                      M35.8203
//C! 7242 FORMAT ( 3X,  'X-AXIS STRUCTURE (',  I2,  ' ) :'    )             M35.8204
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8205
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8206
//C!      CALL FREIN1 ( PROM80, N1 )   ! DECODE FREE-FIELD N1               M35.8207
//C!      IF ( N1  .NE.  0 )   MAXISX = N1                                  M35.8208
//C!      WRITE (PROM80, 7244)  MAXISY                                      M35.8209
//C! 7244 FORMAT ( 3X,  'Y-AXIS STRUCTURE (',  I2,  ' ) :'    )             M35.8210
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8211
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8212
//C!      CALL FREIN1 ( PROM80, N1 )   ! DECODE FREE-FIELD N1               M35.8213
//C!      IF ( N1  .NE.  0 )   MAXISY = N1                                  M35.8214
//C!      WRITE (PROM80, 7246)  MGRID1                                      M35.8215
//C! 7246 FORMAT ( 3X,  'BIG BACKGROUND GRID (',  I2,  ' ) :'    )          M35.8216
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8217
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8218
//C!      CALL FREIN1 ( PROM80, N1 )   ! DECODE FREE-FIELD N1               M35.8219
//C!      IF ( N1  .NE.  0 )   MGRID1 = N1                                  M35.8220
//C!      WRITE (PROM80, 7247)  MGRID2                                      M35.8221
//C! 7247 FORMAT ( 3X,  'FINE INNER GRID (',  I2,  ' ) :'    )              M35.8222
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8223
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8224
//C!      CALL FREIN1 ( PROM80, N1 )   ! DECODE FREE-FIELD N1               M35.8225
//C!      IF ( N1  .NE.  0 )   MGRID2 = N1                                  M35.8226
//C!      WRITE (PROM80, 7250)  MSUPER                                      M35.8227
//C! 7250 FORMAT ( 3X,  'SUPER-TITLE (',  I2,  ' ) :'    )                  M35.8228
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8229
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8230
//C!      CALL FREIN1 ( PROM80, N1 )   ! DECODE FREE-FIELD N1               M35.8231
//C!      IF ( N1  .NE.  0 )   MSUPER = N1                                  M35.8232
//C!      WRITE (PROM80, 7251)  MID                                         M35.8233
//C! 7251 FORMAT ( 3X,  'DATE, TIME, ETC. (',  I2,  ' ) :'    )             M35.8234
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8235
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8236
//C!      CALL FREIN1 ( PROM80, N1 )   ! DECODE FREE-FIELD N1               M35.8237
//C!      IF ( N1  .NE.  0 )   MID = N1                                     M35.8238
//C!      WRITE (MUNIT6, 7254)  ( MCURVE(J), J=1, JPLT )                    M35.8239
//C! 7254 FORMAT ( 3X,  'VECTOR OF CURVE WEIGHTS (',  20I3,  ' ) :'  )      M35.8240
//C!      READ (MUNIT5, *)  ( KP(J), J=1, JPLT )                            M35.8241
//C!      DO 7255  J=1, JPLT                                                M35.8242
//C!      IF ( KP(J)  .NE.  0 )   MCURVE(J) = KP(J)                         M35.8243
//C! 7255 CONTINUE                                                          M35.8244
//C!      GO TO 2005                                                        M35.8245
//C! 7261 IF ( BUFF77(1:8)  .NE.  SHOW  )   GO TO 7287                      M35.8246
//C!      WRITE (MUNIT6, 3421)  MTIT, MAXISX, MAXISY,                       M35.8247
//C!     1                 MGRID1, MGRID2, MSUPER, MID                      M35.8248
//C! 3421 FORMAT ( /,  ' BEGIN WITH  #PEN#  PARAMETERS :'  ,/,              M35.8249
//C!     1  I5,  ' = PEN FOR 80-COLUMN CASE TITLE LINES;'  ,/,              M35.8250
//C!     2  I5,  ' = PEN FOR X-AXIS STRUCTURE;'            ,/,              M35.8251
//C!     3  I5,  ' = PEN FOR Y-AXIS STRUCTURE;'            ,/,              M35.8252
//C!     4  I5,  ' = PEN FOR BIG BACKGROUND GRID;'         ,/,              M35.8253
//C!     5  I5,  ' = PEN FOR FINE INNER GRID;'             ,/,              M35.8254
//C!     6  I5,  ' = PEN FOR 1-LINE SUPER-TITLE;'          ,/,              M35.8255
//C!     7  I5,  ' = PEN FOR DATE, TIME, ETC.'    )                         M35.8256
//C!      WRITE (MUNIT6, 3428)  ( MCURVE(J), J=1, JPLT )                    M35.8257
//C! 3428 FORMAT ( 8X,  'PENS FOR DRAWING INDIVIDUAL CURVES FOLLOW ...'     M35.8258
//C!     1  ,/,  ( 8X,  10I5 )  )                                           M35.8259
//C!      WRITE (MUNIT6, 3453)  XTIT, YTIT, SIZTIT, XID, YID, SIZID,        M35.8260
//C!     1                 XSUPER, YSUPER, SIZSUP                           M35.8261
//C! 3453 FORMAT ( /,  ' NEXT COME THE  #SIZE#  PARAMETERS :'  ,/,          M35.8262
//C!     1  4X,  7HX-BEGIN,  3X,  7HY-BEGIN,  3X,  6HHEIGHT    ,/,          M35.8263
//C!     2  1X,  3F10.2,  '  --- 80-COL. CASE TITLE (1ST LINE)'    ,/,      M35.8264
//C!     3  1X,  3F10.2,  '  --- DATE, TIME, ETC. (TOP LINE)'      ,/,      M35.8265
//C!     4  1X,  3F10.2,  '  --- ONE LINE SUPER-TITLE'    )                 M35.8266
//C!      WRITE (MUNIT6, 3459)  HTAX, FACT, NUMSYM                          M35.8267
//C! 3459 FORMAT ( /,                                                       M35.8268
//C!     1  1X,  F14.3,  '  --- HEIGHT OF TIME AXIS;'               ,/,     M35.8269
//C!     2  1X,  F14.6,  '  --- GRAPH MAGNIFICATION FACTOR',                M35.8270
//C!     3                      ' (.7874 FOR METRIC);'              ,/,     M35.8271
//C!     4  1X,  I14,    '  --- NUMBER OF SYMBOLS MARKING EACH CURVE.'  )   M35.8272
//C!      WRITE (MUNIT6, 3464)  FILL1, FILL2, NCUT1, NCUT2                  M35.8273
//C! 3464 FORMAT ( /,                                                       M35.8274
//C!     1  11H MAJOR GRID,  4X,  10HMINOR GRID  ,/,                        M35.8275
//C!     2  1X,  F10.3,  F14.3,  '  --- FILL-IN FRACTIONS (1.0 FOR',        M35.8276
//C!     3                          ' SOLID GRID);'                 ,/,     M35.8277
//C!     4  1X,    I10,    I14,  '  --- NUMBER OF DASHES PER GRID LINE;'  ) M35.8278
//C!      WRITE (MUNIT6, 3472)  DXGRD1, DXGRD2, DYGRD1, DYGRD2              M35.8279
//C! 3472 FORMAT (                                                          M35.8280
//C!     1  1X,  F10.3,  F14.3,  '  --- SPACING BETWEEN VERTICAL',          M35.8281
//C!     2                          ' GRID LINES;'                  ,/,     M35.8282
//C!     3  1X,  F10.3,  F14.3,  '  --- SPACING BETWEEN HORIZONTAL',        M35.8283
//C!     4                          ' GRID LINES;'   ,/, 1X  )              M35.8284
//C!      GO TO 2005                                                        M35.8285
//C! 7287 IF ( BUFF77(1:8)  .NE.  SIZE )   GO TO 7328                       M35.8286
//C!      WRITE (MUNIT6, 7288)                                              M35.8287
//C! 7288 FORMAT (  ' Respond to each request with revised',                M35.8288
//C!     1          ' values.   A blank or zero means no'   ,/,             M35.8289
//C!     2          ' change from the value shown within',                  M35.8290
//C!     3          ' square brackets.'                       )             M35.8291
//C!      WRITE (PROM80, 7291)  XTIT, YTIT, SIZTIT                          M35.8292
//C! 7291 FORMAT ( '   X,Y COORDINATES AND SIZE OF 79-CHAR. TITLE  (',      M35.8293
//C!     1         3F6.2,  ' ) :'  )                                        M35.8294
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8295
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8296
//C!      CALL FRESP3 ( PROM80, D1, D2, D3 )     ! DECODE FREE-FIELD        M38.5392
//C!      IF ( D1  .NE.  0.0 )   XTIT = D1                                  M35.8298
//C!      IF ( D2  .NE.  0.0 )   YTIT = D2                                  M35.8299
//C!      IF ( D3  .NE.  0.0 )   SIZTIT = D3                                M35.8300
//C!      WRITE (PROM80, 7304)  XID, YID, SIZID                             M35.8301
//C! 7304 FORMAT ( '   LIKEWISE FOR DATE, TIME, ETC.  (',                   M35.8302
//C!     1         3F6.2,  ' ) :'  )                                        M35.8303
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8304
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8305
//C!      CALL FRESP3 ( PROM80, D1, D2, D3 )     ! DECODE FREE-FIELD        M38.5393
//C!      IF ( D1  .NE.  0.0 )   XID = D1                                   M35.8307
//C!      IF ( D2  .NE.  0.0 )   YID = D2                                   M35.8308
//C!      IF ( D3  .NE.  0.0 )   SIZID = D3                                 M35.8309
//C!      WRITE (PROM80, 7309)  XSUPER, YSUPER, SIZSUP                      M35.8310
//C! 7309 FORMAT ( '   LIKEWISE FOR 16-CHAR. SUPER-TITLE  (',               M35.8311
//C!     1         3F6.2,  ' ) :'  )                                        M35.8312
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8313
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8314
//C!      CALL FRESP3 ( PROM80, D1, D2, D3 )     ! DECODE FREE-FIELD        M38.5394
//C!      IF ( D1  .NE.  0.0 )   XSUPER = D1                                M35.8316
//C!      IF ( D2  .NE.  0.0 )   YSUPER = D2                                M35.8317
//C!      IF ( D3  .NE.  0.0 )   SIZSUP = D3                                M35.8318
//C!      WRITE (PROM80, 7315)  HTAX                                        M35.8319
//C! 7315 FORMAT (  '   HEIGHT OF TIME-AXIS  (',  F6.2,  ' ) :'   )         M35.8320
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8321
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8322
//C!      CALL FRESP1 ( PROM80, D1 )   ! DECODE FREE-FIELD D1               M38.5395
//C!      IF ( D1  .NE.  0.0 )   HTAX = D1                                  M35.8324
//C!      WRITE (PROM80, 7319)  FACT                                        M35.8325
//C! 7319 FORMAT (  '   BLOWUP FACTOR.  METRIC=.7874  (',                   M35.8326
//C!     1          F6.4,  ' ) :'    )                                      M35.8327
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8328
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8329
//C!      CALL FRESP1 ( PROM80, D1 )   ! DECODE FREE-FIELD D1               M38.5396
//C!      IF ( D1  .NE.  0.0 )   FACT = D1                                  M35.8331
//C!      WRITE (PROM80, 7320)  FILL1, FILL2                                M35.8332
//C! 7320 FORMAT (  '   FILL-IN FRACTIONS FOR MAJOR AND MINOR GRIDS  (',    M35.8333
//C!     1  2F6.3,  ' ) :'  )                                               M35.8334
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8335
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8336
//C!      CALL FRESP2 ( PROM80, D1, D2 )  ! DECODE FREE-FIELD D1, D2        M38.5397
//C!      IF ( D1  .NE.  0.0 )   FILL1 = D1                                 M35.8338
//C!      IF ( D2  .NE.  0.0 )   FILL2 = D2                                 M35.8339
//C!      WRITE (PROM80, 7321)  NCUT1, NCUT2                                M35.8340
//C! 7321 FORMAT (  '   NUMBER OF BREAKS FOR MAJOR AND MINOR GRIDS  (',     M35.8341
//C!     1  I4,  '.0 ',  I4,  '.0 ) :'   )                                  M35.8342
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8343
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8344
//C!      CALL FRESP2 ( PROM80, D1, D2 )  ! DECODE FREE-FIELD D1, D2        M38.5398
//C!      IF ( D1  .NE.  0.0 )   NCUT1 = D1                                 M35.8346
//C!      IF ( D2  .NE.  0.0 )   NCUT2 = D2                                 M35.8347
//C!      WRITE (PROM80, 7322)  DXGRD1, DYGRD1                              M35.8348
//C! 7322 FORMAT (  '   X,Y SPACING BETWEEN MAJOR GRID LINES  (',           M35.8349
//C!     1          2F6.3,  ' ) :'  )                                       M35.8350
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8351
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8352
//C!      CALL FRESP2 ( PROM80, D1, D2 )  ! DECODE FREE-FIELD D1, D2        M38.5399
//C!      IF ( D1  .GT.  0.0 )   DXGRD1 = D1                                M35.8354
//C!      IF ( D2  .GT.  0.0 )   DYGRD1 = D2                                M35.8355
//C!      WRITE (PROM80, 7323)  DXGRD2, DYGRD2                              M35.8356
//C! 7323 FORMAT (  '   X,Y SPACING BETWEEN MINOR GRID LINES  (',           M35.8357
//C!     1          2F6.3,  ' ) :'  )                                       M35.8358
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8359
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8360
//C!      CALL FRESP2 ( PROM80, D1, D2 )  ! DECODE FREE-FIELD D1, D2        M38.5400
//C!      IF ( D1  .GT.  0.0 )   DXGRD2 = D1                                M35.8362
//C!      IF ( D2  .GT.  0.0 )   DYGRD2 = D2                                M35.8363
//C!      WRITE (PROM80, 7325)  NUMSYM                                      M35.8364
//C! 7325 FORMAT (  '   NUMBER OF MARKING SYMBOLS PER CURVE  (',            M35.8365
//C!     1          I3,  ' ) :'   )                                         M35.8366
//C!      CALL PROMPT     ! WRITE PROM80 WITH CURSOR CONTROL (NO LF)        M35.8367
//C!      READ (MUNIT5, 7241)  PROM80                                       M35.8368
//C!      CALL FREIN1 ( PROM80, N2 )   ! DECODE FREE-FIELD N2               M35.8369
//C!      IF ( N2  .NE.  0 )   NUMSYM = N2                                  M35.8370
//C!      GO TO 2005                                                        M35.8371
//C! 7328 READ (BUFF77, 2030)  D3                                           M35.8372
//C! 2030 FORMAT ( 10E6.0 )                                                 M35.8373
//C!      IF ( D3  .EQ.  0.0 )   GO TO 2060                                 M35.8374
//C!      HPI = D3 / TMULT                                                  M35.8375
//C! 2060 D1 = ( HMAX - HMIN ) / HPI                                        M35.8376
//C!      IF(D1 .LE. 72.0) GO TO 2090                                       M35.8377
//C!      WRITE (MUNIT6, 2070)                                              M35.8378
//C! 2070 FORMAT ( 64H ERROR. ----- REQUESTED FLATBED PLOT WOULD EXCEED 72 IM35.8379
//C!     1NCH LIMIT.   ,/,  32H SEND ANOTHER TIME-AXIS SCALING.   )         M35.8380
//C!      GO TO 2005                                                        M35.8381
//C! 2090 IF ( IPRSRT  .GE.  1 )                                            M35.8382
//C!     1 WRITE (MUNIT6, 2103)  JPLT, IHS, NUMFLT, VMIN, VMAX,             M35.8383
//C!     2                  HMIN, HMAX, HPI                                 M35.8384
//C! 2103 FORMAT ( /,  ' BEGIN FLATBED.',                                   M35.8385
//C!     1  24H    JPLT     IHS  NUMFLT  ,/,  15X,  3I8  ,/,                M35.8386
//C!     2  1X,  11X,  4HVMIN,  11X,  4HVMAX,  11X,  4HHMIN,                M35.8387
//C!     3  11X,  4HHMAX,  12X,  3HHPI  ,/,  1X,  5E15.6  )                 M35.8388
//C!      IF ( NUMFLT  .GT.  0 )   GO TO 2108                               M35.8389
//C!      CALL PLOTS ( 0, 0, 0 )                                            M35.8390
//C!      CALL PLOT ( 1.0, 1.0, -3 )                                        M35.8391
//C!      CALL FACTOR ( FACT )                                              M35.8392
//C! 2108 NUMFLT = NUMFLT + 1                                               M35.8393
//C!      WRITE (MUNIT6, 2109)                                              M35.8394
//C! 2109 FORMAT ( '    Ready to draw CalComp titles.'  )                   M35.8395
//C!      N3 = NUMTIT / 10                                                  M35.8396
//C!      IF ( N3  .LE.  0 )   GO TO 2114                                   M35.8397
//C!      IF ( MTIT  .EQ.  -1 )   GO TO 2114                                M35.8398
//C!      D2 = YTIT                                                         M35.8399
//C!      N4 = 1                                                            M35.8400
//C!      IF ( YTIT  .GT.  10 )   GO TO 2114                                M35.8401
//C!      CALL NEWPEN ( MTIT )                                              M35.8402
//C!      DO 2113  J=1, N3                                                  M35.8403
//C!      CALL SYMBOL ( XTIT, D2, SIZTIT, SEXT(N4), 0.0, 80 )               M35.8404
//C!      D2 = D2 - FLINE * SIZTIT                                          M35.8405
//C! 2113 N4 = N4 + 10                                                      M35.8406
//C! 2114 N1 = 3 * ( IHS - 1 )  +  1                                        M35.8407
//C!C     ONLY UNITS OF  #SECONDS#  CAN BE PRESENTLY HONORED.               M35.8408
//C!      N1 = 7                                                            M35.8409
//C!      IF ( MXYPL  .EQ.  1 )   N1 = 22                                   M35.8410
//C!      D2 = (VMAX - VMIN ) / 8.0                                         M35.8411
//C!      CALL NEWPEN ( MAXISX )                                            M35.8412
//C!      WRITE (MUNIT6, 2115)                                              M35.8413
//C! 2115 FORMAT ( '   Ready to draw CalComp axes.'  )                      M35.8414
//C!      IF ( MAXISX  .GT.  0 )                                            M35.8415
//C!     1 CALL AXIS ( 0.0,  HTAX, HORZL(N1),  -24,  D1,  0.0, HMIN,  HPI ) M35.8416
//C!      CALL NEWPEN ( MAXISY )                                            M35.8417
//C!      IF ( MAXISY  .GT.  0 )                                            M35.8418
//C!     1 CALL AXIS ( 0.0,  0.0,  VERTL,   NCHVER,  8.,  90.,              M35.8419
//C!     2             VMIN,  D2 )                                          M35.8420
//C!      N8 = D1 / DXGRD1  +  0.5                                          M35.8421
//C!      N9 = 8.0 / DYGRD1  +  0.5                                         M35.8422
//C!      FILL = FILL1                                                      M35.8423
//C!      NCUT = NCUT1                                                      M35.8424
//C!      CALL NEWPEN ( MGRID1 )                                            M35.8425
//C!      WRITE (MUNIT6, 2116 )                                             M35.8426
//C! 2116 FORMAT (  '   Ready to call CalComp grid number 1.'  )            M35.8427
//C!      IF ( MGRID1  .GT.  0 )                                            M35.8428
//C!     1 CALL GRID ( 0.0, 0.0, N8, DXGRD1, N9, DYGRD1, LMASK1 )           M35.8429
//C!      WRITE (MUNIT6, 2117 )                                             M35.8430
//C! 2117 FORMAT ( '   Done with CalComp grid number 1.'  )                 M35.8431
//C!      CALL NEWPEN ( MGRID2 )                                            M35.8432
//C!      FILL = FILL2                                                      M35.8433
//C!      NCUT = NCUT2                                                      M35.8434
//C!      N8  =  D1 / DXGRD2  +  0.5                                        M35.8435
//C!      N9  =  8.0/ DYGRD2  +  0.5                                        M35.8436
//C!      IF ( MGRID2  .GT.  0 )                                            M35.8437
//C!     1 CALL GRID ( 0.0, 0.0, N8, DXGRD2, N9, DYGRD2, LMASK2 )           M35.8438
//C!      CALL NEWPEN ( MSUPER )                                            M35.8439
//C!      WRITE (MUNIT6, 2118)                                              M35.8440
//C! 2118 FORMAT ( '   Done with CalComp grid number 2.'  )                 M35.8441
//C!      IF ( MSUPER  .GT.  0 )                                            M35.8442
//C!     1 CALL SYMBOL ( XSUPER, YSUPER, SIZSUP, HEADL, 0.0, NCHSUP )       M35.8443
//C!      D6 = YID                                                          M35.8444
//C!C     ENCODE (18, 2119, ALPHA(1) )   DATE1, TCLOCK                      M35.8445
//C!      WRITE (ANSI32, 2119)  DATEPL, TCLOPL                              M37.7916
//C! 2119 FORMAT ( 2A4, 2X, 2A4 )                                           M35.8447
//C!      CALL NEWPEN ( MID )                                               M35.8448
//C!      IF ( MID  .EQ.  -1 )   GO TO 2127                                 M35.8449
//C!      CALL SYMBOL ( XID, D6, SIZID, ANSI32, 0.0, 18 )                   M35.8450
//C!      D6 = D6 - FLINE * SIZID                                           M35.8451
//C!C     ENCODE (14, 2122, ALPHA(1) )   ICP                                M35.8452
//C!      WRITE (ANSI16, 2122)  ICP                                         M35.8453
//C! 2122 FORMAT ( 9HPLOT TYPE, I5 )                                        M35.8454
//C!      CALL SYMBOL ( XID, D6, SIZID, ANSI16, 0.0, 14 )                   M35.8455
//C!      D6 = D6 - FLINE * SIZID                                           M35.8456
//C!      IF ( MFAKE  .EQ.  JPLT )   GO TO 3149                             M35.8457
//C!      N5 = JPLT                                                         M35.8458
//C!      IF ( JPLT  .GT.  6 )   N5 = 6                                     M35.8459
//C!C     ENCODE (80, 3146, ALPHA(1) )  ( AAA(J), J=1, N5 )                 M35.8460
//C!      WRITE (BUFF77, 3146)  ( AAA(J), J=1, N5 )                         M35.8461
//C! 3146 FORMAT (  9H FACTOR :,  6E11.3  )                                 M35.8462
//C!      CALL SYMBOL ( XID, D6, SIZID, BUFF77, 0.0, 80 )                   M35.8463
//C!      D6 = D6 - FLINE * SIZID                                           M35.8464
//C!C     ENCODE (80, 3147, ALPHA(1) )  ( BBB(J), J=1, N5 )                 M35.8465
//C!      WRITE (BUFF77, 3147)  ( BBB(J), J=1, N5 )                         M35.8466
//C! 3147 FORMAT (  9H OFFSET :,  6E11.3  )                                 M35.8467
//C!      CALL SYMBOL ( XID, D6, SIZID, BUFF77, 0.0, 80 )                   M35.8468
//C!      D6 = D6 - FLINE * SIZID                                           M35.8469
//C! 3149 WRITE (MUNIT6, 3150)                                              M35.8470
//C! 3150 FORMAT ( '   Ready for SLOT1 ENCODE.'  )                          M35.8471
//C!      N5 = 4                                                            M35.8472
//C!      IF ( NAMVAR  .LT.  4 )   N5 = NAMVAR                              M35.8473
//C!C     ENCODE (36, 2125, ALPHA(1) )   ( SLOT1(J), J=1, N5 )              M35.8474
//C!      WRITE (BUFF77, 2125)  ( SLOT1(J), J=1, N5 )                       M35.8475
//C! 2125 FORMAT ( 8HNAMES : ,  4A7  )                                      M35.8476
//C!      CALL SYMBOL ( XID, D6, SIZID, BUFF77, 0.0, 36 )                   M35.8477
//C!      IF ( NAMVAR  .LE.  4 )   GO TO 2127                               M35.8478
//C!      DO 2140  J=5, NAMVAR, 4                                           M35.8479
//C!      N5 = J + 3                                                        M35.8480
//C!C     ENCODE (36, 2137, ALPHA(1) )                                      M35.8481
//C!      WRITE (BUFF77, 2137)                                              M35.8482
//C! 2137 FORMAT ( 36X )                                                    M35.8483
//C!C     ENCODE (36, 2138, ALPHA(1) )   ( SLOT1(I), I=J, N5 )              M35.8484
//C!      WRITE (BUFF77, 2137)                                              M35.8485
//C! 2138 FORMAT ( 8X,  4A7 )                                               M35.8486
//C!      D6 = D6 - FLINE * SIZID                                           M35.8487
//C! 2140 CALL SYMBOL ( XID, D6, SIZID, BUFF77, 0.0, 36 )                   M35.8488
//C! 2127 N4 = 0                                                            M35.8489
//C!      DO 2132  J=1, JPLT                                                M35.8490
//C!      N5 = KSTART(J)                                                    M35.8491
//C!      N6 = ( N5 - N4 ) / 2                                              M35.8492
//C!      N7 = N6 / NUMSYM                                                  M35.8493
//C!      IF ( NUMSYM  .LT.  0 )   N7 = 99999                               M35.8494
//C!      IF ( NUMSYM  .GT.  N6 )  N7 = 1                                   M35.8495
//C!      EW(N5+3) = HPI                                                    M35.8496
//C!      N8 = N4 + 2*N6 + 8                                                M35.8497
//C!      IF ( IPRSRT  .GE.  5 )                                            M35.8498
//C!     1 WRITE (MUNIT6, 3117)  J, N4, N5, N6, N7, (EW(MM), MM=N4, N8)     M35.8499
//C! 3117 FORMAT ( /,  ' READY TO CALL LINE.',                              M35.8500
//C!     1  40H       J      N4      N5      N6      N7  ,/,                M35.8501
//C!     2  20X,  5I8  ,/,  ( 1X,  8E15.6  )  )                             M35.8502
//C!      CALL NEWPEN ( MCURVE(J) )                                         M35.8503
//C!      SX = 1.0 / EW(N5+3)                                               M35.8504
//C!      SY = 1.0 / EW(N5+4)                                               M35.8505
//C!      XMIN = EW(N5+1)                                                   M35.8506
//C!      YMIN = EW(N5+2)                                                   M35.8507
//C!      D1 = ( EW(N4+1) - XMIN ) * SX                                     M35.8508
//C!      D2 = ( EW(N4+2) - YMIN ) * SY                                     M35.8509
//C!      CALL PLOT ( D1, D2, 3 )                                           M35.8510
//C!      N6 = N7                                                           M35.8511
//C!      IF ( IPRSRT  .GE.  2 )                                            M35.8512
//C!     1 WRITE (MUNIT6, 4122)  XMIN, YMIN, SX, SY, D1, D2                 M35.8513
//C! 4122 FORMAT ( /, ' ENTER CURVE-LOOP.  XMIN, YMIN, SX, SY, D1, D2 =',   M35.8514
//C!     1  /, 1X, 6E13.4 )                                                 M35.8515
//C! 2121 N4 = N4 + 2                                                       M35.8516
//C!      IF ( N4  .GE.  N5 )   GO TO 2132                                  M35.8517
//C!      N6 = N6 - 1                                                       M35.8518
//C!      IF ( N6  .GT.  0 )   GO TO 8243                                   M35.8519
//C!      CALL SYMBOL ( D1, D2, SIZID, J, 0.0, -1 )                         M35.8520
//C!      N6 = N7                                                           M35.8521
//C! 8243 D1 = (EW(N4+1) - XMIN ) * SX                                      M35.8522
//C!      D2 = (EW(N4+2) - YMIN ) * SY                                      M35.8523
//C!      IF ( IPRSRT  .GE.  9 )                                            M35.8524
//C!     1 WRITE (MUNIT6, 2123)  N4, N6, D1, D2                             M35.8525
//C! 2123 FORMAT ( ' NEXT POINT DRAWN.  N4, N6, D1, D2 =',  2I5, 2E13.4 )   M35.8526
//C!      CALL PLOT ( D1, D2, 2 )                                           M35.8527
//C!      GO TO 2121                                                        M35.8528
//C! 2132 N4 = N5 + 4                                                       M35.8529
//C!      D1 = D1 + 1.0                                                     M35.8530
//C!      CALL PLOT ( D1, 0.0, -3 )                                         M35.8531
//C!      IF ( IPRSPY  .GE.  1 )                                            M35.8532
//C!     1 WRITE (MUNIT6, 9006)                                             M35.8533
//C! 9006 FORMAT ( '   Done with CalComp copy of screen.'  )                M35.8534
//C!      RETURN                                                            M35.8535
//C!      END                                                               M35.8536
//C NO IMPLICIT
void
tgrid(
  int const& ix,
  int const& iy,
  int const& nx,
  int const& idelx,
  int const& ny,
  int const& idely,
  int const& ldash) try
{
  int n8 = fem::int0;
  int n9 = fem::int0;
  int n3 = fem::int0;
  int n2 = fem::int0;
  int j = fem::int0;
  int n4 = fem::int0;
  //C     MODULE USED ONLY FOR INTERACTIVE EMTP (SERVICE TO "EMTSPY").      M35.8547
  //C     FOR NON-INTERACTIVE EMTP, THIS MODULE CAN BE DESTROYED.           M35.8548
  //C       RELIANCE UPON TEKTRONIX PLOT10 MAKES THIS INSTALLATION-         M36.3560
  //C       DEPENDENT (THIS IS VAX-11 MODULE, ACTUALLY).                    M36.3561
  if (nx <= 0) {
    return;
  }
  if (ny <= 0) {
    return;
  }
  movabs(ix, iy);
  n8 = ix + (nx - 1) * idelx;
  n9 = iy + (ny - 1) * idely;
  n3 = n9;
  n2 = ix;
  FEM_DO_SAFE(j, 1, nx) {
    dshabs(n2, n3, ldash);
    n2 += idelx;
    if (j == nx) {
      goto statement_1356;
    }
    movabs(n2, n3);
    n4 = n3;
    n3 = n9;
    if (n4 == n9) {
      n3 = iy;
    }
  }
  statement_1356:
  movabs(n8, n9);
  n2 = ix;
  n3 = n9;
  FEM_DO_SAFE(j, 1, ny) {
    dshabs(n2, n3, ldash);
    if (j == ny) {
      goto statement_1382;
    }
    n3 = n3 - idely;
    movabs(n2, n3);
    n4 = n2;
    n2 = n8;
    if (n4 == n8) {
      n2 = ix;
    }
  }
  statement_1382:;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
paprsz(
  double const& /* horiz */,
  double const& /* vert */)
{
  //C)    THE REAL (I.E., NON-DUMMY) SUBROUTINE PAPRSZ IS USED WITH BPA'S   M15.1458
  //C)    EAI FLATBED PLOTTER.   THIS IS THE WAY THE DIMENSIONS OF THE TABLEM15.1459
  //C)    UPON WHICH THE EMTP CAN LEGALLY DRAW PLOTS IS COMMUNICATED TO THE M28.7027
  //C)    SYSTEM.   THE PLOTTING SOFTWARE THEN WILL PROTECT THE HARDWARE,   M15.1461
  //C)    NOT ALLOWING THE PEN TO EXCEED THE  X  AND  Y  COORDINATES WHICH  M15.1462
  //C)    ARE SPECIFIED BY THE ARGUMENTS IN THE CALL TO THIS SUBROUTINE.    M15.1463
  //C)    FOR REGULAR CALCOMP DRUM PLOTTING (WHERE THERE IS NO TABLE AS SUCHM15.1464
  //C)    ), LEAVE IN THIS DUMMY SUBROUTINE AS IT IS WRITTEN HERE.   CALLINGM15.1465
  //C)    IT WILL DO NOTHING, OF COURSE.                                    M15.1466
}

void
store(
  common& cmn,
  int const& i,
  int const& j,
  int const& n,
  double const& d2r,
  double const& d2x,
  double const& d1r,
  double const& d1x) try
{
  common_write write(cmn);
  // COMMON zprint
  auto& zoutr = cmn.zoutr;
  auto& zoutx = cmn.zoutx;
  //
  auto& lunit6 = cmn.lunit6;
  if (cmn.iprsup >= 5) {
    write(lunit6, "(' I, J, N, D2R, D2X, D1R, D1X =',3i5,4e18.8)"),
      i, j, n, d2r, d2x, d1r, d1x;
  }
  int kij = j + i * (i - 1) / 2;
  int k1 = (n + i - 1) * (n + i) / 2 + n + j;
  int k16 = 2 * n;
  int k2 = (k16 + i - 1) * (k16 + i) / 2 + k16 + j;
  int km1 = (n + j - 1) * (n + j) / 2 + i;
  int km2 = (k16 + j - 1) * (k16 + j) / 2 + i;
  int km3 = km2 + n;
  int km4 = (n + i - 1) * (n + i) / 2 + j;
  int km5 = (k16 + i - 1) * (k16 + i) / 2 + j;
  int km6 = km5 + n;
  double br = (d2r + 2.f * d1r) / 3.0f;
  double bx = (d2x + 2.f * d1x) / 3.0f;
  zoutr(kij) = br;
  zoutr(k1) = br;
  zoutr(k2) = br;
  zoutx(kij) = bx;
  zoutx(k1) = bx;
  zoutx(k2) = bx;
  br = (d2r - d1r) / 3.0f;
  bx = (d2x - d1x) / 3.0f;
  zoutr(km1) = br;
  zoutr(km2) = br;
  zoutr(km3) = br;
  zoutr(km4) = br;
  zoutr(km5) = br;
  zoutr(km6) = br;
  zoutx(km1) = bx;
  zoutx(km2) = bx;
  zoutx(km3) = bx;
  zoutx(km4) = bx;
  zoutx(km5) = bx;
  zoutx(km6) = bx;
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}

void
err87(
  common& cmn,
  arr_cref<int> /* lstat */,
  arr_cref<double> /* flstat */,
  int const& lunit6)
{
  common_write write(cmn);
  write(lunit6,
    "(5x,'AS PART OF THE INTERACTIVE CRT PLOTTING OR  ''REPLOT''  FEATURES OF "
    "THE EMTP,  PLOT DATA POINTS ARE STORED ON',/,5x,"
    "'DISK AS A  ''PERMANENT FILE''  (AS OPPOSED TO TEMPORARY, SCRATCH STORAGE"
    ", WHICH IS USED FOR EVERY EMTP RUN).   IT',/,5x,"
    "'IS THE OPERATION OF INTERNALLY CATALOGING THIS DATA FILE AS A PERMANENT "
    "FILE, INSIDE THE EMTP, WHICH HAS GOTTEN',/,5x,"
    "'THE EMTP INTO TROUBLE WITH THE COMPUTER OPERATING SYSTEM (OTHERWISE AFFE"
    "CTIONATELY KNOWN AS ''BIGGER BIG BROTHER'').')");
}

int
indblk(
  str_cref tempbus)
{
  int return_value = fem::int0;
  return_value = fem::index(tempbus, " ");
  return return_value;
}

struct program_main_save
{
  int ll34;

  program_main_save() :
    ll34(fem::int0)
  {}
};

void fildel(
  common& cmn,
  int const lun)
{
  bool lopen = fem::bool0;
  cmn.io.inquire_unit(lun)
    .opened(lopen);
  if (lopen) {
    cmn.io.close(lun)
      .status("DELETE");
  }
}

void filcls(
  common& cmn,
  int const lun)
{
  bool lopen = fem::bool0;
  cmn.io.inquire_unit(lun)
    .opened(lopen);
  if (lopen) {
    cmn.io.close(lun);
  }
}

class IO_FileManager {
  std::unordered_map<int, bool> map_{}; // io unit number and if kepp
  common& cmn_;
public:
  IO_FileManager(common& cmn) : cmn_(cmn)
  {};
  ~IO_FileManager() {
    for (auto [unit, isSave] : map_) {
      if (isSave) filcls(cmn_, unit);
      else fildel(cmn_, unit);
    }
  };
  void add(int ioUnit, bool is_save = true) {
    map_[ioUnit] = is_save;
  }
  void close(int unit) {
    filcls(cmn_, unit);
  }
};


void program_main(
  const std::string& inpFile, 
  const std::string& logFile, 
  const std::string& outFile) try
{
  common cmn(0, 0);

#ifdef _DEBUG // test
  {
  arr_1d<13, fem::str<8> > sext(fem::fill0);
  sext(2) = "11111111";
  auto spa1 = ArraySpan(sext.begin(), sext.size());
  
  auto a1 = spa1(1);  
  auto a2 = spa1(2);    
  auto a8 = spa1(8);
  auto a9 = spa1(9);
  auto a10 = spa1(10);

  arr<int> aa1(dimension(5), fem::fill0);
  auto n10 = aa1(1);
  arr<fem::str<8>> aa2(dimension(5), fem::fill0);;
  auto s10 = aa2(1);

  }
#endif // _DEBUG // test

  cmn.inp_stream.open(inpFile);
  if (!cmn.inp_stream.good()) {
    std::cout << "Cannot open '" << inpFile << "' !\n";
    return;
  }

  blockdata_unnamed(cmn);
  blockdata_blkplt(cmn);
  FEM_CMN_SVE(program_main);
  common_write write(cmn);
  auto& iprsov= cmn.iprsov;
  int& kill = cmn.kill;
  int& nchain = cmn.nchain;
  //
  int& ll34 = sve.ll34;
  if (is_called_first_time) {
    ll34 = 34;
  }
  auto& lunit6 = cmn.lunit6;
  int n1 = fem::int0;

  //C)**********************************************************************M15. 203
  //C)                                                                     *M15. 204
  //C)    --------------- ELECTROMAGNETIC TRANSIENTS PROGRAM ------------  *M15. 205
  //C)                    METHODS DEVELOPMENT BRANCH, ROUTE EOGB           *M38.  87
  //C)                    DIVISION OF SYSTEM ENGINEERING                   *M38.  88
  //C)                    BONNEVILLE POWER ADMINISTRATION                  *M15. 208
  //C)                    P. O. BOX 3621                                   *M15. 209
  //C)                    PORTLAND, OREGON  97208                          *M15. 210
  //C)                    U.S.A.     PHONE: (503) 230-4404                 *M38.  89
  //C)                                                                     *M15. 212
  //C)    THE FORTRAN COMMENT-CARD TEXT NOW BEING READ REPRESENTS A        *M15. 213
  //C)    SUMMARY INTRODUCTION AND EXPLANATION WHICH APPLIES TO A VERY     *M15. 214
  //C)    LARGE PROGRAM DEVELOPMENT REFERRED TO BY THE TITLE OF            *M15. 215
  //C)    'ELECTROMAGNETIC TRANSIENTS PROGRAM'  (ABBREVIATED  'EMTP' ,     *M28. 115
  //C)    OR   'T.P.'  IN THE OLDER NOTATION).                             *M28. 116
  //C)                                                                     *M15. 218
  //C)    IN GENERAL TERMS, THE PURPOSE OF THIS WORK IS TO SIMULATE        *M15. 219
  //C)    TRANSIENT PHENOMENA IN POWER SYSTEM NETWORKS, TAKING INTO        *M15. 220
  //C)    ACCOUNT TRAVELING WAVES (ELECTROMAGNETIC TRANSIENTS) ON          *M15. 221
  //C)    TRANSMISSION LINES, SATURATION OF TRANSFORMERS, NONLINEARITIES   *M15. 222
  //C)    OF SURGE ARRESTERS, ETC.   WHILE NOT SO RESTRICTED IN THEORY,    *M15. 223
  //C)    THE MOST COMMON PROGRAM APPLICATION IS FOR THE SIMULATION OF     *M15. 224
  //C)    SWITCHING SURGES WHICH PROPAGATE ON POWER NETWORK TRANSMISSION   *M15. 225
  //C)    LINES.   FOR A MORE DETAILED EXPLANTION OF THE MODELING          *M15. 226
  //C)    TECHNIQUES WHICH ARE USED, THE READER IS REFERRED TO THE         *M28. 117
  //C)    MANUAL FOR THIS PROGRAM (840 PAGES FOR THE VERSION DATED         *M36.  56
  //C)    MARCH, 1983).  ).    WHILE OLDER ISSUES WERE TITLED              *M36.  57
  //C)    "EMTP USER'S MANUAL",  BEGINNING IN SEPTEMBER OF 1980            *M28. 120
  //C)    THIS WORK IS NOW CALLED THE  "EMTP RULE BOOK" .                  *M28. 121
  //C)                                                                     *M15. 229
  //C     THE UTPF IS A LARGE 80-COLUMN BCD CARD-IMAGE FILE, TO BE USED    *M03. 814
  //C     AS INPUT TO E/T PROGRAMS.   E/T PROGRAMS MACHINE TRANSLATE THIS  *M03. 815
  //C     UTPF CODE INTO LEGAL FORTRAN FOR MOST COMPUTER SYSTEMS OF        *M28. 125
  //C     INTEREST (IBM, CDC, UNIVAC, HONEYWELL, DEC PDP-10, DEC VAX-11,   *M28. 126
  //C     PRIME, SEL, APOLLO, HITACHI, FACOM, HARRIS, ETC.).               *VAX.   7
  //C                                                                      *M03. 824
  //C     IN CONFORMITY WITH LONG-STANDING BPA POLICY, AS WELL AS THE      *M03. 825
  //C)    MORE RECENT (FEBRUARY 19, 1975) FEDERAL FREEDOM OF INFORMATION   *M15. 231
  //C)    ACT, DISSEMINATION OF THESE PROGRAM MATERIALS IS FREELY MADE     *M15. 232
  //C)    TO ANY AND ALL INTERESTED PARTIES.   A FEE TO COVER REPRODUCTION,*M15. 233
  //C)    HANDLING, AND MAILING COSTS MAY BE ASSESSED AGAINST THE          *M15. 234
  //C)    ORGANIZATION RECEIVING THE MATERIAL, HOWEVER.   NO CLAIM OR      *M15. 235
  //C)    WARRANTY AS TO THE USEFULNESS, ACCURACY, FIDELITY, OR            *M15. 236
  //C)    COMPLETENESS OF THESE MATERIALS IS (OR EVER HAS BEEN) IN ANY     *M15. 237
  //C)    WAY EXPRESSED OR IMPLIED.                                        *M15. 238
  //C                                                                      *M36.  58
  //C)**********************************************************************M15. 240
  //C     UNIT ASSIGNMENTS OF "OVER1" NEEDED EARLIER BY SPY:                M38.  90
  //cmn.lunit1 = 1;
  //cmn.lunit2 = 2;
  //cmn.lunit3 = 3;
  //cmn.lunit4 = 4;
  //cmn.lunit5 = 5;
  //cmn.lunit6 = 60; // lunit6 = 6; 0,5,6 are the cansole screen
  //cmn.lunit7 = 7;
  //cmn.lunit8 = 8;
  //cmn.lunit9 = 9;
  //cmn.lunt10 = 10;
  //cmn.lunt11 = 11;
  //cmn.lunt12 = 12;
  //cmn.lunt13 = 13;
  //cmn.lunt14 = 14;
  //cmn.lunt15 = 15;

  cmn.llbuff = -3333;
  cmn.kol132 = 132;

  IO_FileManager ioFileManager(cmn);
  ioFileManager.add(cmn.lunit1, false); // delete
  ioFileManager.add(cmn.lunit2, false); // delete
  ioFileManager.add(cmn.lunit3, false); // delete
  ioFileManager.add(cmn.lunit4, false); // delete
  ioFileManager.add(cmn.lunit5, false); // delete
  ioFileManager.add(cmn.lunit6, true);  // log file: save
  ioFileManager.add(cmn.lunit7, false); // delete
  ioFileManager.add(cmn.lunit8, false); // delete
  ioFileManager.add(cmn.lunit9, false); // delete
  ioFileManager.add(cmn.lunt10, false); // delete
  ioFileManager.add(cmn.lunt11, false); // delete
  ioFileManager.add(cmn.lunt12, false); // delete
  ioFileManager.add(cmn.lunt13, false); // delete
  ioFileManager.add(cmn.lunt14, false); // delete
  ioFileManager.add(cmn.lunt15, false); // delete

  //cmn.log_stream.open(logFile);       // use lunit6
  cmn.out_stream.open(outFile);  // open output streams
  if (!cmn.out_stream.is_open())
    return;

  // open log file
  bool lexst{false};
  int open_status = 0;
  cmn.io.inquire_file(logFile)
    .exist(lexst);
  if (lexst) {
    cmn.io.open(lunit6, logFile);
    cmn.io.close(lunit6)
      .status("delete");
  }

  cmn.io.open(lunit6, logFile)
    .access("SEQUENTIAL")
    .form("FORMATTED")
    .status("UNKNOWN")
    .iostat(open_status);

  if (open_status != 0) {
    return;
  }


  nchain = -1;
  cmn.lastov = 0;
  kill = 0;
  statement_2000:
  if (kill == 0) {
    goto statement_2001;
  }
  if (kill == 9999) {
    goto statement_2001;
  }
  if (kill != 7733) {
    goto statement_4372;
  }
  write(lunit6, "(' \"MAIN00\" INTERCEPT OF \"BEGIN\" REQUEST.')");
  kill = 0;
  cmn.numdcd = 0;
  nchain = 1;
  goto statement_1983;
  statement_4372:
  if (nchain > 51) {
    goto statement_2001;
  }
  nchain = 51;
  statement_2001:
  n1 = nchain;
  if (n1 > 30) {
    n1 = n1 - 30;
  }
  if (n1 <= 0) {
    n1 = 1;
  }
  cmn.iprsup = iprsov(n1);
  if (nchain > 20) {
    goto statement_2010;
  }
  if (nchain == 12 || nchain == 2) {
    goto statement_1983;
  }
  if (nchain ==  - 1) {
    move0(iprsov, ll34);
  }
  //erexit(cmn);
  datain(cmn);
  nchain = 0;
  if (nchain > 20) {
    goto statement_2000;
  }
  statement_1983:
  main10(cmn);
  goto statement_2000;
  statement_2010:
   if (cmn.m4plot == 1) {
    emtspy(cmn);
  }
  if (nchain > 29) {
    goto statement_2020;
  }
  over29(cmn);
  goto statement_2000;
  statement_2020:
  if (nchain > 31) {
    goto statement_2024;
  }
  over31(cmn);
  goto statement_2000;
  statement_2024:
  if (nchain > 39) {
    goto statement_2025;
  }
  over39(cmn);
  goto statement_2000;
  statement_2025:
  if (nchain > 41) {
    goto statement_2070;
  }
  over41(cmn);
  goto statement_2000;
  statement_2070:
  if (nchain > 42) {
    goto statement_2080;
  }
  over42(cmn);
  goto statement_2000;
  statement_2080:
  if (nchain > 44) {
    goto statement_2100;
  }
  over44(cmn);
  goto statement_2000;
  statement_2100:
  if (nchain > 45) {
    goto statement_2110;
  }
  over45(cmn);
  goto statement_2000;
  statement_2110:
  if (nchain > 47) {
    goto statement_2130;
  }
  over47(cmn);
  goto statement_2000;
  statement_2130:
  if (nchain > 51) {
    goto statement_2260;
  }
  over51(cmn);
  goto statement_2000;
  statement_2260:
  if (nchain > 52) {
    goto statement_2270;
  }
  over52(cmn);
  goto statement_2000;
  statement_2270:
  if (nchain > 53) {
    goto statement_2280;
  }
  over53(cmn);
  goto statement_2000;
  statement_2280:
  if (nchain > 54) {
    goto statement_2290;
  }
  over54(cmn);
  goto statement_2000;
  statement_2290:
  if (nchain > 55) {
    goto statement_2300;
  }
  over55(cmn);
  //goto statement_2000;
  // cleanup posible open files and eng the program
  //cmn.io.close(lunit6) // log file
  //  .status("keep");

  //filcls(cmn, lunit6);

  //fildel(cmn, cmn.lunit1);
  //fildel(cmn, cmn.lunit2);
  //fildel(cmn, cmn.lunit3);
  //fildel(cmn, cmn.lunit4);
  //fildel(cmn, cmn.lunit5);
  //fildel(cmn, cmn.lunit7);
  //fildel(cmn, cmn.lunit8);
  //fildel(cmn, cmn.lunit9);
  //fildel(cmn, cmn.lunt10);
  //fildel(cmn, cmn.lunt11);
  //fildel(cmn, cmn.lunt12);
  //fildel(cmn, cmn.lunt13);
  //fildel(cmn, cmn.lunt14);
  //fildel(cmn, cmn.lunt15);

  return;
  statement_2300:
  write(lunit6, "(/,' ILLEGAL NCHAIN IN MAIN00.',i8)"), nchain;
  goto statement_2000;
  //C)                                                                      
  //C)    THE PRESENT MODULE  MAIN00  IS ALWAYS IN MEMORY.   IT IS THE      
  //C)    HIGHEST LEVEL MODULE OF A PROGRAM WHICH HAS TWO LEVELS OF         
  //C)    OVERLAYING.   IT CALLS PRIMARY LEVEL OVERLAYS ONLY (DIRECTLY),    
  //C)    BASED ON THE VALUE OF VARIABLE  'NCHAIN' .   THE FOLLOWING        
  //C     LEGITIMATE VALUES, AND THE MEANING OF THE ASSOCIATED OVERLAY      
  //C     CALLS, EXIST .....                                                
  //C     1-20.  FOR OVERLAYS 1, 2, ..., 20, WHICH ARE SECONDARY-LEVEL      
  //C            OVERLAYS, A CALL MUST BE FIRST MADE TO THE CONTROLLING     
  //C            PRIMARY-LEVEL OVERLAY. THUS FOR SUCH  'NCHAIN' VALUES,  
  //C            CONTROL IS TRANSFERED FIRST TO MODULE  MAIN10 .  THIS     
  //C            IS THE ONLY CASE WHERE CALLS TO OVERLAYS ARE NOT MADE      
  //C            DIRECTLY.                                                  
  //C                                                                       
  //C     29.  COMPLETION OF STATISTICS (MONTE CARLO) STUDY, WHERE VARIABLE 
  //C          MAXIMA OF THE DIFFERENT CASE SOLUTIONS ARE READ OFF THE      
  //C          DISK, AND ARE PROCESSED STATISTICALLY TO PRODUCE             
  //C          CUMULATIVE DISTRIBUTION FUNCTIONS, ETC.                      
  //C                                                                       
  //C     31.  PLOT ROUTINE, FOR GRAPHICAL OUTPUT OF TRANSIENTS.            
  //C          THE PROGRAM ALSO TERMINATES EXECUTION HERE, USUALLY,         
  //C          AFTER WRITING AN END-OF-INFORMATION MARK ON THE              
  //C          PLOT TAPE (WHETHER OR NOT THE USER HAS PLOTTED ANYTHING).    
  //C                                                                       
  //C     39.  SUPPORTING ROUTINE WHICH GENERATES EMTP BRANCH               
  //C          CARDS FOR THE FREQUENCY-DEPENDENT REPRESENTATION OF          
  //C          AN UNTRANSPOSED TRANSMISSION LINE.   THIS IS THE             
  //C          "MARTI SETUP"  CODE, NAMED AFTER DR. JOSE MARTI OF           
  //C          VANCOUVER AND CARACAS (SEE 1981 IEEE PICA PAPER).            
  //C                                                                       
  //C     41.  SUPPORTING ROUTINE WHICH CALCULATES TRANSFORMER MATRICES (R)
  //C          AND  (L)  FROM SHORT-CIRCUIT AND OPEN-CIRCUIT DATA.          
  //C                                                                       
  //C     42.  SUPPORTING ROUTINE WHICH CONVERTS AN RMS VOLTAGE VS. CURRENT 
  //C          SATURATION CHARACTERISTIC INTO AN INSTANTANEOUS FLUX VS.     
  //C          CURRENT CHARACTERISTIC.                                      
  //C                                                                       
  //C     43.  SUPPORTING ROUTINE WHICH CALCULATES WEIGHTING FUNCTIONS      
  //C          A1(T)  AND  A2(2)  FOR THE ZERO-SEQUENCE MODE OF A           
  //C          DISTRIBUTED LINE WHICH HAS FREQUENCY-DEPENDENT LINE          
  //C          CONSTANTS  R  AND  L .                                       
  //C                                                                       
  //C     44.  SUPPORTING ROUTINE WHICH CALCULATES LINE CONSTANTS FOR       
  //C          OVERHEAD TRANSMISSION LINES BY MEANS OF CARSON'S FORMULA.    
  //C          THIS IS A MODIFIED VERSION OF WHAT WAS ORIGINALLY (UNTIL     
  //C          JANUARY 1975) THE COMPLETELY-SEPARATE BPA LINE-CONSTANTS     
  //C          PROGRAM.                                                     
  //C                                                                       
  //C     45.  SUPPORTING ROUTINE OF  'SEMLYEN SETUP'  CODE.  THE OUTPUT   
  //C          IS A GROUP OF PUNCHED CARDS, AS ARE REQUIRED FOR THE EMTP    
  //C          SIMULATION OF A TRANSMISSION CIRCUIT USING  SEMLYEN          
  //C          RECURSIVE CONVOLUTION MODELING.                              
  //C                                                                       
  //C     47.  SUPPORTING ROUTINE OF  'CABLE CONSTANTS'  CODE.   THE        
  //C          PRIMARY FUNCTION IS TO CALCULATE  (R),  (L),  %  (C)         
  //C          MATRICES FOR A MULTI-PHASE SYSTEM OF SINGLE-CORE COAXIAL     
  //C          CABLES.                                                      
  //C                                                                       
  //C     51.  PRINTING OF INTRODUCTORY PARAGRAPH OF ERROR-MESSAGE          
  //C          TERMINATION ('YOU LOSE, FELLA, ... '), PLUS ERROR-MESSAGE    
  //C          TEXTS FOR  'KILL'  CODES NUMBERED  1  THROUGH  50 .          
  //C          THE EXITING LINKAGE IS TO THE LAST ERROR OVERLAY.            
  //C     52.  ERROR MESSAGE TEXTS FOR  'KILL'  CODES NUMBERED  51          
  //C          THE EXITING LINKAGE IS TO THE LAST ERROR OVERLAY.            
  //C     53.  ERROR MESSAGE TEXTS FOR  'KILL'  CODES NUMBERED  91          
  //C          THROUGH  150.  THE EXITING LINKAGE IS TO THE LAST            
  //C          ERROR OVERLAY.                                               
  //C     54.  ERROR MESSAGE TEXTS FOR  'KILL'  CODES NUMBERED  151         
  //C          THROUGH  200.   THE EXITING LINKAGE IS TO THE                
  //C          LAST ERROR OVERLAY.                                          
  //C     55.  FINAL ERROR OVERLAY.  MESSAGES FOR  KILL = 201               
  //C          ONWARD ARE CONTAINED, AS WELL AS SUMMARY STATISTICS          
  //C          --- TABLE SIZES AND TIMING FIGURES FOR THE RUN.              
  //C          THE EXITING LINKAGE IS GENERALLY TO MODULE  OVER1  (TO READ  
  //C          A NEW DATA CASE), BUT MAY BE TO MODULE  OVER31 (FOR FINAL    
  //C          CASE TERMINATION).                                           
}
catch (...) {
  std::throw_with_nested(std::runtime_error(__func__ + std::string("()")));
}



} // namespace emtp
